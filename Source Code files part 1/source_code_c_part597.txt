3 * amplitude
    0xFFFF, // 0dB
    };

#endif

// The two routines that follow convert from a linear AmpFactor in the
// range 65535/65536 to 1/65536 to a decibel range of -100.00 to -0.01
// and vice versa.
//
// The amp factors are expressed in parts per 65536 as a 16 bit numerator,
// i.e. actual amplification is (ampfactor)/65536.
//
// The decibels are expressed as parts per 100.  i.e. -100 means -1dB.
//
// Note that although a decibel is formally 10 * log10(x), the AmpFactor
// refers to voltages and the dB to powers, and power = v**2/r
// so the rule is dB = 20*log10(x)
//
// If you change one routine you will almost certainly have to change
// the other.  In an ideal world the routines would be inverses
// meaning that the following is true
//
// 	AmpFactor == DBToAmpFactor(AmpFactorToDB(AmpFactor))
//
// HOWEVER many iterations are made through the routines. The
// secondary objective is to minimise the drift such that
// successive iterations do not stray too far from the starting
// point.
//
// This is clearly impossible because the quantisations are
// quite different.  10**-.005 = 1.0115 or 65536->64786, so if
// we start from (say) 65000 then something nasty must happen.
// likewise the difference between an amp factor of 1/65536 and
// 2/65536 is about 6dB - so much for the nearest hundredth!
//
// From here on we'll call them DB (even though that should be a
// dekabell (10 bells) to avoid confusion with hungarian.
//

//
//  DBToAmpFactor
//
//  Converts lDB, specified in 100ths decibels, into a
//  linear amplification factor.  For all lDB >= 0 this
//  function returns 0xffff.  This is because our current
//  implementation of DirectSound doesn't allow amplification,
//  and users of this function often require 16-bit results
//
AMOVIEAPI_DB DWORD WINAPI DBToAmpFactor( LONG lDB )
{
#if 0
    double dAF;

    // REMIND hack to make mixer code work- it only handles 16-bit factors and
    //  cannot amplify
    if (0 <= lDB) return 0x0000FFFF;

    // input lDB is 100ths of decibels

    dAF = pow(10.0, (0.5+((double)lDB))/2000.0);

    // This gives me a number in the range 0-1
    // normalise to 0-65535

    return (DWORD)(dAF*65535);

#else
    DWORD dwFactor;

    //
    // bias and scale the input and check boundaries for indexing into table
    //
    lDB = (lDB-5)/10;		    // scaled to 1/10th dB units

    if (lDB > 0)    lDB = 0;        // upper boundary
    if (lDB < -964) return 0;  	    // lower boundary

    lDB = (lDB + 964);		    // bias

    // lDB better be a good index
//    ASSERT(lDB >= 0);
//    ASSERT(lDB <= sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]));

    dwFactor = (DWORD) tblDBTenthsToAmpFactor[lDB];

    return dwFactor;
#endif
}

AMOVIEAPI_DB LONG WINAPI AmpFactorToDB( DWORD dwFactor )
{
#if 0
    if (1>=dwFactor) {
	return -10000;
    } else if (0xFFFF <= dwFactor) {
	return 0;	// This puts an upper bound - no amplification
    } else {
	return (LONG)(2000.0 * log10((-0.5+(double)dwFactor)/65536.0));
    }

#else

    LONG    lDB;

    int	    iMin;
    int	    iMax;
    int     iMiddle;

    iMin = 0;

    iMax = sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]) - 1;

#ifdef BINARY_CHOP
    int     i;
    for (i = 0; i <= iMax - 1; i++) {
	if (dwFactor <= (DWORD) tblDBTenthsToAmpFactor[i]) break;
    }

    lDB = (i - 964) * 10;
#else
    //
    // Binary search through the table of AmpFactors.
    //
    // iMin and iMax specify the range in which the result can be found this
    // is initially the whole table.
    //
    // In each interation we reduce the range by half.
    //
    // Loop variant: iMax - iMin, which decreases in each iteration.
    // Invariant:  iMin <= iMax.
    // Exit condition: iMin = iMax.
    //
    while (iMin != iMax) {
//        ASSERT(iMin < iMax);

        iMiddle = (iMin + iMax) / 2;

        // Chose the half which includes dwFactor.
        if (dwFactor <= tblDBTenthsToAmpFactor[iMiddle])
            iMax = iMiddle;       // iMin does not change
        else
            iMin = iMiddle + 1;   // iMax does not change
    }

    lDB = (iMin - 964) * 10;
#endif

    return lDB;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\dynlink\dynlink.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.


// Dynamic linking to AVIFIL32.DLL and MSVFW32.DLL and MSACM32.DLL
//
// To minimize the Quartz working set we dynamically link to the VFW dlls
// only when needed.  The header file defines a class that should be
// inherited from if you wish to support dynamic linking.  The VFW api
// entries that are used are then redirected to the code here.
//
// The VFW dll will be loaded when the dependent class is instantiated and
// unloaded when the final using class is destroyed.  We maintain our own
// reference count of how many times our constructor is called in order to
// do this.
//

#include <streams.h>
#include <dynlink.h>
//
// This is a bit of a hack... we need one of the AVI GUIDs defined
// within this file.  Sigh...
//

#define REALLYDEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID CDECL name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

#define REALLYDEFINE_AVIGUID(name, l, w1, w2) \
    REALLYDEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

REALLYDEFINE_AVIGUID(IID_IAVIStreaming,       0x00020022, 0, 0);

//end of declare guid hack


// Static data for all instances of these classes

HMODULE CAVIDynLink::m_hAVIFile32 = NULL;	// handle to AVIFIL32
HMODULE CVFWDynLink::m_hVFW = NULL;		// handle to MSVFW32
HMODULE CACMDynLink::m_hACM = NULL;		// handle to MSACM32
HMODULE CURLMonDynLink::m_hURLMon = NULL;	// handle to URLMon

CRITICAL_SECTION CAVIDynLink::m_LoadAVILock;      // serialise constructor/destructor
CRITICAL_SECTION CVFWDynLink::m_LoadVFWLock;      // serialise constructor/destructor
CRITICAL_SECTION CACMDynLink::m_LoadACMLock;      // serialise constructor/destructor
CRITICAL_SECTION CURLMonDynLink::m_LoadURLMonLock;      // serialise constructor/destructor

LONG    CAVIDynLink::m_dynlinkCount = -1;	// instance count for this process
LONG    CVFWDynLink::m_vfwlinkCount = -1;	// instance count for this process
LONG    CACMDynLink::m_ACMlinkCount = -1;	// instance count for this process
LONG    CURLMonDynLink::m_URLMonlinkCount = -1;	// instance count for this process

//
// The entry points we are redirecting.
// There is a one-one correspondence with CAVIDynLink member functions
//


static char *aszAVIEntryPoints[] = {
      "AVIFileInit"
    , "AVIFileExit"
    , "AVIFileOpenW"
    };

#define AVIFILELIBRARY TEXT("AVIFIL32")

//
// Dynamically loaded array of entry points
//
FARPROC aAVIEntries[sizeof(aszAVIEntryPoints)/sizeof(char*)];

#define indxAVIFileInit 		0
#define indxAVIFileExit 		1
#define indxAVIFileOpenW 		2
#define indxAVIStreamRead 		
#define indxAVIStreamStart 		
#define indxAVIStreamLength 		
#define indxAVIStreamTimeToSample 	
#define indxAVIStreamSampleToTime 	
#define indxAVIStreamBeginStreaming 	
#define indxAVIStreamEndStreaming 	
#define indxAVIStreamFindSample


//
// We must serialise class construction for all dynamic load classes.
// By providing a single routine Quartz.DLL will call us when it gets
// loaded.  We can then distribute the call as needed.
//

void __stdcall CAMDynLinkLoad(BOOL fLoading);

void __stdcall CAMDynLinkLoad(BOOL fLoading)
{
    if (fLoading) {
	CAVIDynLink::CAVIDynLinkLoad();
	CVFWDynLink::CVFWDynLinkLoad();
	CACMDynLink::CACMDynLinkLoad();
	CURLMonDynLink::CURLMonDynLinkLoad();
    } else {
	CAVIDynLink::CAVIDynLinkUnload();
	CVFWDynLink::CVFWDynLinkUnload();
	CACMDynLink::CACMDynLinkUnload();
	CURLMonDynLink::CURLMonDynLinkUnload();
    }
}

//
// "null" routines that will be used if we fail to load one of the dynamically
// linked dlls.  We do not need to point each entry at a "null" routine.
// The user should always call Open (or equivalent) for each dynamically
// loaded utility, but to get complete coverage we provide a null routine
// for each of the redirected functions.
//

void SetupNullEntryAVI(void);
void SetupNullEntryVFW(void);
void SetupNullEntryACM(void);
void SetupNullEntryURL(void);

void fnNULL0(void)
{
    ;
}

void fnNULL1(PVOID pv)
{
    ;
}

HRESULT fnHR4(PVOID p1, PVOID p2, PVOID p3, PVOID p4)
{
    return E_FAIL;
}

HRESULT fnHR3(PVOID p1, PVOID p2, PVOID p3)
{
    return E_FAIL;
}

HRESULT fnHR2(PVOID p1, PVOID p2)
{
    return E_FAIL;
}

MMRESULT fnMMR8(PVOID p1, PVOID p2, PVOID p3, PVOID p4, PVOID p5, PVOID p6, PVOID p7, PVOID p8)
{
    return E_FAIL;
}

MMRESULT fnMMR5(PVOID p1, PVOID p2, PVOID p3, PVOID p4, PVOID p5)
{
    return E_FAIL;
}

MMRESULT fnMMR4(PVOID p1, PVOID p2, PVOID p3, PVOID p4)
{
    return E_FAIL;
}

MMRESULT fnMMR3(PVOID p1, PVOID p2, PVOID p3)
{
    return E_FAIL;
}

MMRESULT fnMMR2(PVOID p1, PVOID p2)
{
    return E_FAIL;
}

HIC fnHIC4(PVOID p1, PVOID p2, PVOID p3, PVOID p4, WORD w)
{
    return 0;
}

LRESULT fnLRESULT5(PVOID p1, PVOID p2, PVOID p3, PVOID p4, PVOID p5)
{
    return E_FAIL;
}

HIC fnHIC5(PVOID p1, PVOID p2, PVOID p3, PVOID p4, PVOID p5)
{
    return 0;
}

HIC fnHIC3(PVOID p1, PVOID p2, PVOID p3)
{
    return 0;
}

//
//  Constructor for CAVIDynlink
//
//  Called when a dependent class is constructed
//
//  If AVIFIL32.DLL has not been loaded then load it and resolve the
//  entry points that we are going to use - defined in aszAVIEntryPoints.
//
//  Increment a reference count of how many times we have been called.
//

CAVIDynLink::CAVIDynLink()
{
    EnterCriticalSection(&m_LoadAVILock);
    if (0 == InterlockedIncrement(&m_dynlinkCount))
    {
	// First time - we need to load
	ASSERT(!m_hAVIFile32);

	m_hAVIFile32 = LoadLibrary(AVIFILELIBRARY);
	if (!m_hAVIFile32) {
	    InterlockedDecrement(&m_dynlinkCount);
	    DWORD err = GetLastError();
	    DbgLog((LOG_ERROR, 0, TEXT("Error %d loading %s"), err, AVIFILELIBRARY));
	    SetupNullEntryAVI();
	} else {
	    DWORD err = 0;
	    FARPROC fn;

	    for (int i=0; i < sizeof(aszAVIEntryPoints)/sizeof(char*); ++i) {
		fn = GetProcAddress(m_hAVIFile32, aszAVIEntryPoints[i]);
		if (!fn) {
		    DbgLog((LOG_ERROR, 0, "Failed to resolve entry point %hs", aszAVIEntryPoints[i]));
		    err++;
		} else {
		    aAVIEntries[i]=fn;
		}
	    }
	    if (err) {
		FreeLibrary(m_hAVIFile32);
		m_hAVIFile32 = NULL;
		InterlockedDecrement(&m_dynlinkCount);
		SetupNullEntryAVI();
	    }
	}
    } else {
	ASSERT(m_hAVIFile32);
    }
    LeaveCriticalSection(&m_LoadAVILock);
}


//
//  Destructor for CAVIDynlink
//
//  Called when a dependent class is destroyed.
//
//  Decrement a reference count of how many times we have been called.
//  If the count returns to its initial value (negative) then unload
//  the DLL.
//

CAVIDynLink::~CAVIDynLink()
{
    EnterCriticalSection(&m_LoadAVILock);
    if (0 > InterlockedDecrement(&m_dynlinkCount)) {
	if (m_hAVIFile32) {
	    FreeModule(m_hAVIFile32);
	    m_hAVIFile32 = 0;
	}
    }
    LeaveCriticalSection(&m_LoadAVILock);
}


void  CAVIDynLink::AVIFileInit(void)
{
    aAVIEntries[indxAVIFileInit]();
    return;
}

void  CAVIDynLink::AVIFileExit(void)
{
    aAVIEntries[indxAVIFileExit]();
    return;
}

HRESULT  CAVIDynLink::AVIFileOpenW(PAVIFILE FAR * ppfile, LPCWSTR szFile,
    		  UINT uMode, LPCLSID lpHandler)
{
    // if running on Win95 change the filename to be the short file name
    // this is to sidestep a bug in the Win95 version of AVIFIL32.DLL for
    // wave files...
    OSVERSIONINFO osver;
    osver.dwOSVersionInfoSize = sizeof(osver);
    WCHAR wcShortName[_MAX_PATH];
    LPCWSTR pszFile = szFile;

    BOOL fUseShortName = TRUE;

    if (GetVersionEx(&osver)) {
	if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT) {
	    fUseShortName = FALSE;
	}
    }
    if (fUseShortName) {
	// this is win95... the W entry point will not exist
	CHAR longFileName[_MAX_PATH];
	CHAR shortFileName[_MAX_PATH];
	wsprintfA(longFileName, "%ls", szFile);

	DWORD dw = GetShortPathNameA(longFileName, shortFileName, _MAX_PATH);
	if (dw && (dw < _MAX_PATH)) {
	    pszFile = wcShortName;
	    MultiByteToWideChar(CP_ACP, 0, shortFileName, -1,
		    wcShortName, _MAX_PATH);
	}
    }

    return(((pAVIFileOpenW)aAVIEntries[indxAVIFileOpenW])(ppfile, pszFile, uMode, lpHandler));
}



LONG  CAVIDynLink::AVIStreamTimeToSample(PAVISTREAM pavi, LONG lTime)
{
    AVISTREAMINFOW          aviStreamInfo;
    HRESULT                 hr;
    LONG                    lSample;

    // Invalid time
    if (lTime < 0) return -1;

    hr = pavi->Info(&aviStreamInfo, sizeof(aviStreamInfo));

    if (hr != NOERROR || aviStreamInfo.dwScale == 0 || aviStreamInfo.dwRate == 0) {
        return lTime;
    }

    // This is likely to overflow if we're not careful for long AVIs
    // so keep the 1000 inside the brackets.
    ASSERT(aviStreamInfo.dwScale < (0x7FFFFFF/1000));
#if 1
    lSample =  MulDiv(lTime, aviStreamInfo.dwRate, aviStreamInfo.dwScale * 1000);
#else
    if (aviStreamInfo.dwRate / aviStreamInfo.dwScale < 1000)
        lSample =  muldivrd32(lTime, aviStreamInfo.dwRate, aviStreamInfo.dwScale * 1000);
    else
        lSample =  muldivru32(lTime, aviStreamInfo.dwRate, aviStreamInfo.dwScale * 1000);
#endif

    lSample = min(max(lSample, (LONG) aviStreamInfo.dwStart),
                  (LONG) (aviStreamInfo.dwStart + aviStreamInfo.dwLength));


    return lSample;
    //return(((pAVIStreamTimeToSample)aAVIEntries[indxAVIStreamTimeToSample])(pavi, lTime));
}

LONG  CAVIDynLink::AVIStreamSampleToTime(PAVISTREAM pavi, LONG lSample)
{
    AVISTREAMINFOW          aviStreamInfo;
    HRESULT                 hr;

    hr = pavi->Info(&aviStreamInfo, sizeof(aviStreamInfo));

    if (hr != NOERROR || aviStreamInfo.dwRate == 0 || aviStreamInfo.dwScale == 0) {
        return lSample;
    }

    lSample = min(max(lSample, (LONG) aviStreamInfo.dwStart),
                  (LONG) (aviStreamInfo.dwStart + aviStreamInfo.dwLength));

    ASSERT(aviStreamInfo.dwScale < (0x7FFFFFF/1000));
#if 1
    return MulDiv(lSample, aviStreamInfo.dwScale * 1000, aviStreamInfo.dwRate);
#else
    // lSample * 1000 would overflow too easily
    if (aviStreamInfo.dwRate / aviStreamInfo.dwScale < 1000)
        return muldivrd32(lSample, aviStreamInfo.dwScale * 1000, aviStreamInfo.dwRate);
    else
        return muldivru32(lSample, aviStreamInfo.dwScale * 1000, aviStreamInfo.dwRate);
#endif
    //return(((pAVIStreamSampleToTime)aAVIEntries[indxAVIStreamSampleToTime])(pavi, lSample));
}

HRESULT  CAVIDynLink::AVIStreamBeginStreaming(PAVISTREAM pavi, LONG lStart, LONG lEnd, LONG lRate)
{
    IAVIStreaming *	pIAVIS;
    HRESULT 		hr;

    if (FAILED(GetScode(pavi->QueryInterface(IID_IAVIStreaming,
                                             (void FAR* FAR*) &pIAVIS))))
        return AVIERR_OK; // ??? this is what avifile returns

    hr = pIAVIS->Begin(lStart, lEnd, lRate);

    pIAVIS->Release();

    return hr;
    //return(((pAVIStreamBeginStreaming)aAVIEntries[indxAVIStreamBeginStreaming])(pavi, lStart, lEnd, lRate));
}

HRESULT  CAVIDynLink::AVIStreamEndStreaming(PAVISTREAM pavi)
{
    IAVIStreaming FAR * pi;
    HRESULT hr;

    if (FAILED(GetScode(pavi->QueryInterface(IID_IAVIStreaming, (LPVOID FAR *) &pi))))
        return AVIERR_OK;

    hr = pi->End();
    pi->Release();

    return hr;
    //return(((pAVIStreamEndStreaming)aAVIEntries[indxAVIStreamEndStreaming])(pavi));
}


//------------------------------------------------------------------
// Dynamic linking to VFW entry points (decompressor)

// Make sure that this array corresponds to the indices in the
// header file
static char *aszVFWEntryPoints[] = {
      "ICClose"
    , "ICSendMessage"
    , "ICLocate"
    , "ICOpen"
    , "ICInfo"
    , "ICGetInfo"
    };

#define VFWLIBRARY TEXT("MSVFW32")

//
// Dynamically loaded array of entry points
//
FARPROC aVFWEntries[sizeof(aszVFWEntryPoints)/sizeof(char*)];


//
//  Constructor for CVFWDynlink
//
//  Called when a dependent class is constructed
//
//  If MSVFW32.DLL has not been loaded then load it and resolve the
//  entry points that we are going to use - defined in aszVFWEntryPoints.
//
//  Increment a reference count of how many times we have been called.
//

CVFWDynLink::CVFWDynLink()
{
    EnterCriticalSection(&m_LoadVFWLock);
    if (0 == InterlockedIncrement(&m_vfwlinkCount))
    {
	// First time - we need to load
	ASSERT(!m_hVFW);

	m_hVFW = LoadLibrary(VFWLIBRARY);
	if (!m_hVFW) {
	    InterlockedDecrement(&m_vfwlinkCount);
	    SetupNullEntryVFW();
	} else {
	    DWORD err = 0;
	    FARPROC fn;

	    for (int i=0; i < sizeof(aszVFWEntryPoints)/sizeof(char*); ++i) {
		fn = GetProcAddress(m_hVFW, aszVFWEntryPoints[i]);
		if (!fn) {
		    DbgLog((LOG_ERROR, 0, "Failed to resolve entry point %hs", aszVFWEntryPoints[i]));
		    err++;
		} else {
		    aVFWEntries[i]=fn;
		}
	    }
	    if (err) {
		FreeLibrary(m_hVFW);
		m_hVFW = NULL;
		InterlockedDecrement(&m_vfwlinkCount);
		SetupNullEntryVFW();
	    }
	}
    } else {
	ASSERT(m_hVFW);
    }
    LeaveCriticalSection(&m_LoadVFWLock);
}


//
//  Destructor for CVFWDynlink
//
//  Called when a dependent class is destroyed.
//
//  Decrement a reference count of how many times we have been called.
//  If the count returns to its initial value (negative) then unload
//  the DLL.
//

CVFWDynLink::~CVFWDynLink()
{
    EnterCriticalSection(&m_LoadVFWLock);
    if (0 > InterlockedDecrement(&m_vfwlinkCount)) {
	if (m_hVFW) {
	    FreeModule(m_hVFW);
	    m_hVFW = 0;
	}
    }
    LeaveCriticalSection(&m_LoadVFWLock);
}



//------------------------------------------------------------------
// Dynamic linking to ACM entry points

// Make sure that this array corresponds to the indices in the
// header file
static char *aszACMEntryPoints[] = {
      "acmStreamConvert"
    , "acmStreamSize"
    , "acmStreamPrepareHeader"
    , "acmMetrics"
    , "acmStreamUnprepareHeader"
    , "acmStreamOpen"
    , "acmFormatSuggest"
    , "acmStreamClose"
#ifdef UNICODE
    , "acmFormatEnumW"
#else
    , "acmFormatEnumA"
#endif
    };

#define ACMLIBRARY TEXT("MSACM32")

//
// Dynamically loaded array of entry points
//
FARPROC aACMEntries[sizeof(aszACMEntryPoints)/sizeof(char*)];


//
//  Constructor for CACMDynlink
//
//  Called when a dependent class is constructed
//
//  If MSACM32.DLL has not been loaded then load it and resolve the
//  entry points that we are going to use - defined in aszACMEntryPoints.
//
//  Increment a reference count of how many times we have been called.
//

CACMDynLink::CACMDynLink()
{
    EnterCriticalSection(&m_LoadACMLock);
    if (0 == InterlockedIncrement(&m_ACMlinkCount))
    {
	// First time - we need to load
	ASSERT(!m_hACM);

	m_hACM = LoadLibrary(ACMLIBRARY);
	if (!m_hACM) {
	    InterlockedDecrement(&m_ACMlinkCount);
	    SetupNullEntryACM();
	} else {
	    DWORD err = 0;
	    FARPROC fn;

	    for (int i=0; i < sizeof(aszACMEntryPoints)/sizeof(char*); ++i) {
		fn = GetProcAddress(m_hACM, aszACMEntryPoints[i]);
		if (!fn) {
		    DbgLog((LOG_ERROR, 0, "Failed to resolve entry point %hs", aszACMEntryPoints[i]));
		    err++;
		} else {
		    aACMEntries[i]=fn;
		}
	    }
	    if (err) {
		FreeLibrary(m_hACM);
		m_hACM = NULL;
		InterlockedDecrement(&m_ACMlinkCount);
		SetupNullEntryACM();
	    }
	}
    } else {
	ASSERT(m_hACM);
    }
    LeaveCriticalSection(&m_LoadACMLock);
}


//
//  Destructor for CACMDynlink
//
//  Called when a dependent class is destroyed.
//
//  Decrement a reference count of how many times we have been called.
//  If the count returns to its initial value (negative) then unload
//  the DLL.
//

CACMDynLink::~CACMDynLink()
{
    EnterCriticalSection(&m_LoadACMLock);
    if (0 > InterlockedDecrement(&m_ACMlinkCount)) {
	if (m_hACM) {
	    FreeModule(m_hACM);
	    m_hACM = 0;
	}
    }
    LeaveCriticalSection(&m_LoadACMLock);
}





//------------------------------------------------------------------
// Dynamic linking to URLMon entry points

// Make sure that this array corresponds to the indices in the
// header file
static char *aszURLMonEntryPoints[] = {
      "CreateURLMoniker"
    , "RegisterBindStatusCallback"
    , "RevokeBindStatusCallback"
    };

#define URLMonLIBRARY TEXT("URLMon")

//
// Dynamically loaded array of entry points
//
FARPROC aURLMonEntries[sizeof(aszURLMonEntryPoints)/sizeof(char*)];


//
//  Constructor for CURLMonDynlink
//
//  Called when a dependent class is constructed
//
//  If MSURLMon32.DLL has not been loaded then load it and resolve the
//  entry points that we are going to use - defined in aszURLMonEntryPoints.
//
//  Increment a reference count of how many times we have been called.
//

CURLMonDynLink::CURLMonDynLink()
{
    EnterCriticalSection(&m_LoadURLMonLock);
    if (0 == InterlockedIncrement(&m_URLMonlinkCount))
    {
	// First time - we need to load
	ASSERT(!m_hURLMon);

	m_hURLMon = LoadLibrary(URLMonLIBRARY);
	if (!m_hURLMon) {
	    InterlockedDecrement(&m_URLMonlinkCount);
	    SetupNullEntryURL();
	} else {
	    DWORD err = 0;
	    FARPROC fn;

	    for (int i=0; i < sizeof(aszURLMonEntryPoints)/sizeof(char*); ++i) {
		fn = GetProcAddress(m_hURLMon, aszURLMonEntryPoints[i]);
		if (!fn) {
		    DbgLog((LOG_ERROR, 0, "Failed to resolve entry point %hs", aszURLMonEntryPoints[i]));
		    err++;
		} else {
		    aURLMonEntries[i]=fn;
		}
	    }
	    if (err) {
		FreeLibrary(m_hURLMon);
		m_hURLMon = NULL;
		InterlockedDecrement(&m_URLMonlinkCount);
		SetupNullEntryURL();
	    }
	}
    } else {
	ASSERT(m_hURLMon);
    }
    LeaveCriticalSection(&m_LoadURLMonLock);
}


//
//  Destructor for CURLMonDynlink
//
//  Called when a dependent class is destroyed.
//
//  Decrement a reference count of how many times we have been called.
//  If the count returns to its initial value (negative) then unload
//  the DLL.
//

CURLMonDynLink::~CURLMonDynLink()
{
    EnterCriticalSection(&m_LoadURLMonLock);
    if (0 > InterlockedDecrement(&m_URLMonlinkCount)) {
	if (m_hURLMon) {
	    // !!! FreeModule(m_hURLMon);  IE4's URLMon doesn't like to be freed.
	    m_hURLMon = 0;
	}
    }
    LeaveCriticalSection(&m_LoadURLMonLock);
}

//
// If we fail to load one of the dynamically linked DLLs we set up the
// array of function pointers to point to our own routines that will then
// return an error.  This prevents a GPF.
//

void SetupNullEntryAVI(void)
{
    aAVIEntries[indxAVIFileInit]  = (FARPROC)fnNULL0;
    aAVIEntries[indxAVIFileExit]  = (FARPROC)fnNULL0;
    aAVIEntries[indxAVIFileOpenW] = (FARPROC)fnHR4;
    ASSERT(3 == sizeof(aszAVIEntryPoints)/sizeof(char*));
}

void SetupNullEntryVFW(void)
{
    aVFWEntries[indxICClose      ] = (FARPROC)fnNULL1;
    aVFWEntries[indxICSendMessage] = (FARPROC)fnLRESULT5;
    aVFWEntries[indxICLocate     ] = (FARPROC)fnHIC5;
    aVFWEntries[indxICOpen       ] = (FARPROC)fnHIC3;
    aVFWEntries[indxICInfo       ] = (FARPROC)fnHIC3; // returns NULL as would fnBOOL3;
    aVFWEntries[indxICGetInfo    ] = (FARPROC)fnHIC3; // returns NULL as would fnBOOL3;
    ASSERT(6 == sizeof(aszVFWEntryPoints)/sizeof(char*));
}

void SetupNullEntryACM(void)
{
    aACMEntries[indxacmStreamConvert        ] = (FARPROC)fnMMR3;
    aACMEntries[indxacmStreamSize           ] = (FARPROC)fnMMR4;
    aACMEntries[indxacmStreamPrepareHeader  ] = (FARPROC)fnMMR3;
    aACMEntries[indxacmMetrics              ] = (FARPROC)fnMMR3;
    aACMEntries[indxacmStreamUnprepareHeader] = (FARPROC)fnMMR3;
    aACMEntries[indxacmStreamOpen           ] = (FARPROC)fnMMR8;
    aACMEntries[indxacmFormatSuggest        ] = (FARPROC)fnMMR5;
    aACMEntries[indxacmStreamClose          ] = (FARPROC)fnMMR2;
#ifdef UNICODE
    aACMEntries[indxacmFormatEnumW          ] = (FARPROC)fnMMR5;
#else
    aACMEntries[indxacmFormatEnumA          ] = (FARPROC)fnMMR5;
#endif

    ASSERT(8 == sizeof(aszACMEntryPoints)/sizeof(char*));
}

void SetupNullEntryURL(void)
{
    aURLMonEntries[indxurlmonCreateURLMoniker] = (FARPROC)fnHR3;
    aURLMonEntries[indxurlmonRegisterCallback] = (FARPROC)fnHR4;
    aURLMonEntries[indxurlmonRevokeCallback  ] = (FARPROC)fnHR2;
					
    ASSERT(3 == sizeof(aszURLMonEntryPoints)/sizeof(char*));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\control\vidctl.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

#include <streams.h>
#include <measure.h>
#include "fgctl.h"
#include "vidprop.h"
#include "viddbg.h"
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx


HRESULT
FindInterfaceFromFiltersPins(
    IUnknown* pUnk,
    REFIID iid,
    LPVOID* lp
    )
{
    IBaseFilter* pFilter;
    IEnumPins* pEP;

    HRESULT hr = pUnk->QueryInterface(IID_IBaseFilter, (void **)&pFilter);
    if (SUCCEEDED(hr)) {

        // Check out each pin
        hr = pFilter->EnumPins(&pEP);
        if (SUCCEEDED(hr)) {

            IPin *pPin;

            hr = E_NOINTERFACE;
            while (pEP->Next(1, &pPin, NULL) == S_OK) {

                hr = pPin->QueryInterface(iid, lp);
                pPin->Release();

                if (SUCCEEDED(hr)) {
                    break;
                }
            }
            pEP->Release();
        }

        pFilter->Release();
    }

    return hr;
}

void
GetCurrentMonitorSize(
    IVideoWindow *pWindow,
    LPRECT lprc
    )
{
    IOverlay *pOverlay = NULL;
    HWND hwnd;
    HMONITOR hm;

    HRESULT hr = FindInterfaceFromFiltersPins(pWindow, IID_IOverlay, (VOID **)&pOverlay);

    if (FAILED(hr) || FAILED(pOverlay->GetWindowHandle(&hwnd)) ||
        ((hm = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST)) == (HMONITOR)NULL)) {

        HDC hdcScreen = GetDC(NULL);
        lprc->left = lprc->top = 0;
        lprc->right = GetDeviceCaps(hdcScreen,HORZRES);
        lprc->bottom = GetDeviceCaps(hdcScreen,VERTRES);
        ReleaseDC(NULL,hdcScreen);
    }
    else {

        MONITORINFOEX mi;
        mi.cbSize = sizeof(mi);
        GetMonitorInfo(hm, &mi);
        *lprc = mi.rcMonitor;
    }

    if (pOverlay) {
        pOverlay->Release();
    }
}


// Constructor for IVideoWindow plug in distributor. The distributor simply
// sits on top of any filter that implements IVideoWindow directly (such as
// the normal window renderer and the text renderer). For all of the video
// window properties we only pass the call on to one filter as that makes
// the best result when we have multiple window renderers in a graph. The
// filter that gets the property settings is obviously dependent on which
// order they are returned by the filter graph enumerator. This can mostly
// be controlled by changing the order that streams are placed into a file

CFGControl::CImplVideoWindow::CImplVideoWindow(const TCHAR *pName,CFGControl *pfgc) :
    CBaseVideoWindow(pName, pfgc->GetOwner()),
    m_pFGControl(pfgc),
    m_hwndOwner(NULL),
    m_hwndDrain(NULL),
    m_bFullScreen(FALSE),
    m_pFullDirect(NULL),
    m_pFullIndirect(NULL),
    m_pModexFilter(NULL),
    m_pNormalFilter(NULL),
    m_pNormalPin(NULL),
    m_bAddedToGraph(FALSE),
    m_bGlobalOwner(FALSE),
    m_pModexPin(NULL)
{
    ASSERT(pfgc);
}


// Destructor

CFGControl::CImplVideoWindow::~CImplVideoWindow()
{
    // Don't call RemoveFilter in destructors

    m_bAddedToGraph = FALSE;
    ReleaseFullScreen();
    put_MessageDrain(NULL);

#if 0
    // Back when we subclassed our owner, it used to be very very bad
    // to not do a put_Owner(NULL), but now we don't anymore, so this
    // isn't a big concern, certainly not worth putting up a dialog box in retail.
    if (m_hwndOwner) {
        MessageBox(NULL,TEXT("Application not calling put_Owner(NULL)"),
                   TEXT("Puppy Application Error"),
                   MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
    }
#endif

    ASSERT(m_pModexFilter == NULL);
    ASSERT(m_pModexPin == NULL);
    ASSERT(m_pNormalFilter == NULL);
    ASSERT(m_pNormalPin == NULL);
}


// Return the interface of the first in the list of IVideoWindow i/f pointers
//  - S_OK on success, failure code otherwise

HRESULT CFGControl::CImplVideoWindow::GetFirstVW(IVideoWindow*& pVW)
{
    ASSERT(CritCheckIn(m_pFGControl->GetFilterGraphCritSec()));
    if (m_bFullScreen == TRUE) {
        return VFW_E_IN_FULLSCREEN_MODE;
    }

    pVW = m_pFGControl->GetFirstVW();
    return pVW ? S_OK : E_NOINTERFACE;
}

template<class Method, class T> static HRESULT __fastcall Dispatch1Arg( CFGControl::CImplVideoWindow * This, Method pMethod, T t )
{
    HRESULT hr;
    IVideoWindow *pV;
    {
        CAutoMsgMutex lock(This->GetFGControl()->GetFilterGraphCritSec());
        hr = This->GetFirstVW(pV);
        if (SUCCEEDED(hr)) {
            pV->AddRef();
        }
    }
    //
    //  Don't hold the critical section while calling the method -
    //  it might call SetParent or something that broadcasts messages
    //  and deadlock us
    //
    if (SUCCEEDED(hr)) {
        hr = (pV->*pMethod)(t);
        pV->Release();
    }
    return hr;
}

#define REROUTE_IVW1( Method, ArgType ) \
STDMETHODIMP CFGControl::CImplVideoWindow::Method(ArgType Arg) \
{ return Dispatch1Arg( this, &IVideoWindow::Method, Arg ); }

REROUTE_IVW1( put_Caption, BSTR )
REROUTE_IVW1( get_Caption, BSTR* )
REROUTE_IVW1( put_AutoShow, long )
REROUTE_IVW1( get_AutoShow, long * )
REROUTE_IVW1( put_WindowStyle, long )
REROUTE_IVW1( get_WindowStyle, long* )
REROUTE_IVW1( put_WindowStyleEx, long )
REROUTE_IVW1( get_WindowStyleEx, long * )
REROUTE_IVW1( put_WindowState, long )
REROUTE_IVW1( get_WindowState, long* )
REROUTE_IVW1( put_BackgroundPalette, long )
REROUTE_IVW1( get_BackgroundPalette, long* )
REROUTE_IVW1( put_Visible, long )
REROUTE_IVW1( get_Visible, long* )
REROUTE_IVW1( put_Left, long )
REROUTE_IVW1( get_Left, long* )
REROUTE_IVW1( put_Width, long )
REROUTE_IVW1( get_Width, long* )
REROUTE_IVW1( put_Top, long )
REROUTE_IVW1( get_Top, long* )
REROUTE_IVW1( put_Height, long )
REROUTE_IVW1( get_Height, long* )
REROUTE_IVW1( get_BorderColor, long* )
REROUTE_IVW1( put_BorderColor, long )


// Called to set an owning window for the video renderer
STDMETHODIMP CFGControl::CImplVideoWindow::put_Owner(OAHWND Owner)
{
    const HRESULT hr = Dispatch1Arg( this, &IVideoWindow::put_Owner, Owner );
    if (SUCCEEDED(hr)) m_hwndOwner = (HWND) Owner;
    return hr;
}

// Return the owning window handle
STDMETHODIMP CFGControl::CImplVideoWindow::get_Owner(OAHWND *Owner)
{
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    CheckPointer(Owner,E_POINTER);
    IVideoWindow * pV;
    const HRESULT hr = GetFirstVW(pV);
    if (SUCCEEDED(hr)) *Owner = (OAHWND) m_hwndOwner;
    return hr;
}


// Set the window to post messages onto
STDMETHODIMP CFGControl::CImplVideoWindow::put_MessageDrain(OAHWND Drain)
{
    const HRESULT hr = Dispatch1Arg( this, &IVideoWindow::put_MessageDrain, Drain );
    if (SUCCEEDED(hr)) m_hwndDrain = (HWND) Drain;
    return hr;
}


// Return the window we are posting messages onto
STDMETHODIMP CFGControl::CImplVideoWindow::get_MessageDrain(OAHWND *Drain)
{
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    CheckPointer(Drain,E_POINTER);
    IVideoWindow * pV;
    const HRESULT hr = GetFirstVW(pV);
    if (SUCCEEDED(hr)) *Drain = (OAHWND) m_hwndDrain;
    return hr;
}


// Return what the current full screen mode is
STDMETHODIMP CFGControl::CImplVideoWindow::get_FullScreenMode(long *FullScreenMode)
{
    CheckPointer(FullScreenMode,E_POINTER);
    *FullScreenMode = (m_bFullScreen ? OATRUE : OAFALSE);
    return NOERROR;
}


// Return the first filter who supports fullscreen mode directly. To find out
// if a filter supports fullscreen mode directly we call get_FullScreenMode.
// If it does support it then it will return anything but E_NOTIMPL. We try
// and find a filter that supports fullscreen mode directly. If we can't get
// one then we we look at the maximum ideal image sizes to see if they can
// be used like that, and failing that we switch renderers to a Modex filter

IVideoWindow *CFGControl::CImplVideoWindow::FindFullScreenDirect()
{
    NOTE("Searching for fullscreen direct");
    ASSERT(CritCheckIn(m_pFGControl->GetFilterGraphCritSec()));
    CGenericList<IVideoWindow> *pWindowList;
    long Mode;

    // Get a list of IVideoWindow supporting filters

    HRESULT hr = m_pFGControl->GetListWindow(&pWindowList);
    if (FAILED(hr)) {
        NOTE("No list");
        return NULL;
    }

    // Look for anyone not returning E_NOTIMPL

    POSITION pos = pWindowList->GetHeadPosition();
    while (pos) {
        IVideoWindow *pWindow = pWindowList->GetNext(pos);
        if (pWindow->get_FullScreenMode(&Mode) != E_NOTIMPL) {
            NOTE("Found filter");
            return pWindow;
        }
    }
    return NULL;
}


// Set the renderer into a paused state and return the autoshow property

LONG CFGControl::CImplVideoWindow::PauseRenderer(IVideoWindow *pWindow)
{
    IMediaFilter *pMediaFilter = NULL;
    NOTE("Pausing renderer");
    LONG AutoShow;
    ASSERT(pWindow);

    // We need this to do the state change

    pWindow->QueryInterface(IID_IMediaFilter,(VOID **) &pMediaFilter);
    if (pMediaFilter == NULL) {
        NOTE("No IMediaFilter");
        return OAFALSE;
    }

    // Pause the single renderer

    pWindow->get_AutoShow(&AutoShow);
    pWindow->put_AutoShow(OAFALSE);
    NOTE("Pausing filter");
    pMediaFilter->Pause();
    pMediaFilter->Release();

    return AutoShow;
}


// After checking the stretching extents set the renderer state back again

BOOL CFGControl::CImplVideoWindow::StopRenderer(IVideoWindow *pWindow,LONG AutoShow)
{
    IMediaFilter *pMediaFilter = NULL;
    NOTE("Stopping renderer");
    ASSERT(pWindow);

    // We need this to do the state change

    pWindow->QueryInterface(IID_IMediaFilter,(VOID **) &pMediaFilter);
    if (pMediaFilter == NULL) {
        NOTE("No IMediaFilter");
        return FALSE;
    }

    // Reset the state of any filter we touch

    pMediaFilter->Stop();
    pMediaFilter->Release();
    pWindow->put_AutoShow(AutoShow);

    return TRUE;
}


// This is called with the IVideoWindow interface on a renderer filter in the
// filtergraph. We must check the minimum and maximum stretching capabilities
// for the filter against the size of the target. The size of the target must
// be calculated such that we don't destroy any pixel aspect ratio, this is
// done by working out which axis will hit the display edge first and making
// this the base scale (it's possible that the scale factor is less than one)

BOOL CFGControl::CImplVideoWindow::CheckRenderer(IVideoWindow *pWindow)
{
    IBasicVideo *pBasicVideo = NULL;
    LONG Width,Height;
    NOTE("Checking renderer");
    ASSERT(pWindow);

    // We need this to do the state change

    pWindow->QueryInterface(IID_IBasicVideo,(VOID **) &pBasicVideo);
    if (pBasicVideo == NULL) {
        NOTE("No IBasicVideo");
        return FALSE;
    }

    // We need these to know how to scale
    pBasicVideo->GetVideoSize(&Width,&Height);
    // Get the pixel aspect ratio if there is one
    IBasicVideo2 *pBasicVideo2;
    DbgLog((LOG_TRACE, 0, TEXT("Width/Height(%d,%d)"), Width, Height));
    if (SUCCEEDED(pBasicVideo->QueryInterface(IID_IBasicVideo2, (void**)&pBasicVideo2)))
    {
        pBasicVideo2->GetPreferredAspectRatio(&Width, &Height);
        DbgLog((LOG_TRACE, 0, TEXT("Preferred aspect ratio(%d,%d)"),
                Width, Height));
        pBasicVideo2->Release();
    }

    pBasicVideo->Release();
    pBasicVideo = NULL;

    //
    // Get the size of the current display mode for the monitor that we
    // are playing back on.
    //

    RECT rc;
    GetCurrentMonitorSize(pWindow, &rc);
    int ScreenWidth = WIDTH(&rc);
    int ScreenHeight = HEIGHT(&rc);
    double Scale = min((double(ScreenWidth) / double(Width)),
                            (double(ScreenHeight) / double(Height)));

    NOTE2("Screen size (%dx%d)",ScreenWidth,ScreenHeight);
    NOTE2("Video size (%dx%d)",Width,Height);
    NOTE1("Pixel aspect ratio scale (x1000) (%d)",LONG(Scale*1000));

    // This calculates the ideal destination video position

    LONG ScaledWidth = min(ScreenWidth,LONG((double(Width) * Scale)));
    LONG ScaledHeight = min(ScreenHeight,LONG((double(Height) * Scale)));
    m_ScaledRect.left = (ScreenWidth - ScaledWidth) / 2;
    m_ScaledRect.top = (ScreenHeight - ScaledHeight) / 2;
    m_ScaledRect.right = ScaledWidth;
    m_ScaledRect.bottom = ScaledHeight;

    NOTE4("Scaled video (left %d top %d width %d height %d)",
            m_ScaledRect.left, m_ScaledRect.top,
              m_ScaledRect.right, m_ScaledRect.bottom);

    // Get the filter's maximum ideal size

    HRESULT hr = pWindow->GetMaxIdealImageSize(&Width,&Height);
    if (FAILED(hr)) {
        return FALSE;
    }

    // Check we can stretch at least as big

    if (hr == NOERROR) {
        NOTE2("Maximum ideal image size (%dx%d)",Width,Height);
        if (Width <= ScaledWidth || Height <= ScaledHeight) {
            NOTE("Maximum failed");
            return FALSE;
        }
    }

    // Get the filter's minimum ideal size

    hr = pWindow->GetMinIdealImageSize(&Width,&Height);
    if (FAILED(hr)) {
        return FALSE;
    }

    // We may have to stretch more than the target requires

    if (hr == NOERROR) {
        NOTE2("Minimum ideal image size (%dx%d)",Width,Height);
        if (Width >= ScaledWidth || Height >= ScaledHeight) {
            NOTE("Minimum failed");
            return FALSE;
        }
    }
    return TRUE;
}


// Return the first filter who supports fullscreen mode by having the window
// stretched. We know that we haven't found a filter who supports fullscreen
// directly so the next best thing is a filter if unhooked (it maybe playing
// in another window like the OLE control) could be stretched fullscreen with
// no penalty - this ensures we use DirectDraw overlays or hardware MPEG when
// it is available. If we return NULL heer we will switch to a Modex renderer

IVideoWindow *CFGControl::CImplVideoWindow::FindFullScreenIndirect()
{
    CGenericList<IVideoWindow> *pWindowList;
    NOTE("Searching for fullscreen indirect");
    OAFilterState State;
    long AutoShow;

    // Get a list of IVideoWindow supporting filters

    HRESULT hr = m_pFGControl->GetListWindow(&pWindowList);
    if (FAILED(hr)) {
        NOTE("No list");
        return NULL;
    }

    // We need the current filtergraph state

    m_pFGControl->m_implMediaControl.GetState(0,&State);
    ASSERT(CritCheckIn(m_pFGControl->GetFilterGraphCritSec()));
    POSITION pos = pWindowList->GetHeadPosition();

    while (pos) {

        // The renderers must be paused or running

        IVideoWindow *pWindow = pWindowList->GetNext(pos);
        if (State == State_Stopped) {
            AutoShow = PauseRenderer(pWindow);
        }

        // Check the minimum and maximum stretch allowances
        BOOL bFoundFilter = CheckRenderer(pWindow);

        // Reset the renderer's state
        if (State == State_Stopped) {
            StopRenderer(pWindow,AutoShow);
        }

        // Finally return any filter if we got one

        if (bFoundFilter == TRUE) {
            NOTE("Found filter");
            return pWindow;
        }
    }
    return NULL;
}


// Create a Modex renderer filter through CoCreateInstance. We are currently
// hardwired to the Modex renderer we supply in the ActiveMovie runtime. We
// initialise m_pModexFilter with IBaseFilter interface of the renderer and
// m_pModexPin with the single input pin it supports. If we fail to get them
// we return the appropriate error, should we be using QzCreateFilterObject?

HRESULT CFGControl::CImplVideoWindow::FindModexFilter()
{
    NOTE("Creating a Modex filter");
    ASSERT(m_pModexFilter == NULL);
    ASSERT(m_pModexPin == NULL);

    HRESULT hr = CoCreateInstance(CLSID_ModexRenderer,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IBaseFilter,
                                  (void **) &m_pModexFilter);
    if (FAILED(hr)) {
        NOTE("No object");
        FailFullScreenModex();
        return hr;
    }

    IEnumPins *pEnumPins = NULL;
    ASSERT(m_pModexFilter);
    ULONG FetchedPins = 0;
    m_pModexFilter->EnumPins(&pEnumPins);

    // Did we get an enumerator

    if (pEnumPins == NULL) {
        FailFullScreenModex();
        NOTE("No enumerator");
        return E_UNEXPECTED;
    }

    // Get the one and only input pin

    pEnumPins->Next(1,&m_pModexPin,&FetchedPins);
    if (m_pModexPin == NULL) {
        NOTE("No input pin");
        pEnumPins->Release();
        FailFullScreenModex();
        return E_UNEXPECTED;
    }

    pEnumPins->Release();
    return NOERROR;
}


// This is only really interesting the first time through where we initialise
// what fullscreen option we will use. If there is a filter that can do full
// screen mode directly then we do that. Otherwise if we can stretch a window
// fullscreen we will do that (we may have a DirectDraw overlay surface). If
// that fails we try and create a Modex renderer and failing that we have to
// stretch the window fullscreen and accept the terrible performance we'll get

HRESULT CFGControl::CImplVideoWindow::InitFullScreenOptions()
{
    NOTE("InitFullScreenOptions");

    // Have we got a Modex renderer

    if (m_pModexFilter) {
        NOTE("Modex renderer");
        ASSERT(m_pModexPin);
        return NOERROR;
    }

    // We must have at least one window filter

    CGenericList<IVideoWindow> *pWindowList;
    HRESULT hr = m_pFGControl->GetListWindow(&pWindowList);
    if( FAILED( hr ) ) {
        return hr;
    }

    if (pWindowList->GetCount() < 1) {
        return VFW_E_NO_FULLSCREEN;
    }

    // Initialise our fullscreen options

    m_pFullDirect = FindFullScreenDirect();
    if (m_pFullDirect == NULL) {
        m_pFullIndirect = FindFullScreenIndirect();
        if (m_pFullIndirect == NULL) {
            FindModexFilter();
        }
    }
    return NOERROR;
}


// This is called during fullscreen initialisation if we detect a blocking
// problem such that we can't switch to a Modex renderer. In which case we
// should release all interfaces and set ourselves so that we just stretch
// the first IVideoWindow enabled filter we find. After being called it is
// safe to call StartFullScreenMode again to have any old window stretched

void CFGControl::CImplVideoWindow::FailFullScreenModex()
{
    NOTE("FailFullScreenModex");
    ReleaseFullScreen();

    // Get the first IVideoWindow enabled filter

    CGenericList<IVideoWindow> *pWindowList;
    m_pFGControl->GetListWindow(&pWindowList);
    POSITION pos = pWindowList->GetHeadPosition();
    m_pFullIndirect = pWindowList->Get(pos);
}


// Release any resources held by us. When using a filter that can support a
// fullscreen mode directly, or when we're stretching a window we don't keep
// reference counts on the filters. When we come to use them each time we do
// a quick check that the interface is still valid. However when switching
// into a Modex renderer we disconnect the normal filter and reference count
// it - which ensures that when we switch back the same filter is available

void CFGControl::CImplVideoWindow::ReleaseFullScreen()
{
    NOTE("ReleaseFullScreen");
    m_pFullDirect = NULL;
    m_pFullIndirect = NULL;

    // Remove the Modex renderer from the graph

    if (m_bAddedToGraph == TRUE) {
        NOTE("Removing fullscreen filter from graph");
        m_pFGControl->GetFG()->CFilterGraph::RemoveFilter(m_pModexFilter);
    }

    m_bAddedToGraph = FALSE;

    if (m_pModexFilter) {
        m_pModexFilter->Release();
        m_pModexFilter = NULL;
    }

    if (m_pModexPin) {
        m_pModexPin->Release();
        m_pModexPin = NULL;
    }

    if (m_pNormalFilter) {
        m_pNormalFilter->Release();
        m_pNormalFilter = NULL;
    }

    if (m_pNormalPin) {
        m_pNormalPin->Release();
        m_pNormalPin = NULL;
    }
}


// Called when we want to try and load the Modex renderer to use. If there is
// no filter available then we stretch whatever window we have fullscreen
// as there is no alternative - it'll look terrible but what else can we do
// We must also take into account the restart after connecting a Modex filter
// failing (perhaps a fullscreen exclusive game was started just beforehand)

HRESULT CFGControl::CImplVideoWindow::CueFullScreen()
{
    NOTE("CueFullScreen");
    ASSERT(m_bFullScreen == TRUE);
    OAFilterState Before;

    // Always stop the graph just in case it's lying

    Before = m_pFGControl->GetLieState();
    NOTE("Stopping filtergraph");

    //  Stop will not work if we were in the middle of a repaint
    //  In this case we need to repaint anyway and the target state
    //  ws stopped so just cancel the current repaint
    m_pFGControl->CancelRepaint();
    m_pFGControl->m_implMediaControl.Stop();
    ASSERT(m_pFGControl->GetFilterGraphState() == State_Stopped);
    NOTE("(Temporary stop of graph)");

    // Have the renderers switched

    HRESULT hr = ConnectModexFilter();
    if (FAILED(hr)) {
        NOTE("Reconnection bad");
        FailFullScreenModex();
        StretchWindow(m_pFullIndirect);
    }

    // Try and pause the graph first of all

    hr = m_pFGControl->m_implMediaControl.Pause();
    if (FAILED(hr)) {
        m_pFGControl->m_implMediaControl.Stop();

        // if the modex filter is still connected, we need to put the
        // original renderer back in. However, it is possible that the
        // modex filter is no longer connected (eg., ConnectModexFilter has
        // failed). So we test for the IBaseFilter pointers to be still
        // valid.

        if (m_pNormalFilter && m_pModexFilter)
        {
            ConnectNormalFilter();
            FailFullScreenModex();
        }
        m_pFGControl->m_implMediaControl.Pause();
        StretchWindow(m_pFullIndirect);
    }

    // Issue run on the worker thread

    if (Before == State_Running) {
        // cancel Cue() timer
        m_pFGControl->CancelAction(); 
        return m_pFGControl->CueThenRun();
    } else {
        // If we were originally stopped then stop now
        if (Before == State_Stopped) {
            return m_pFGControl->m_implMediaControl.Stop();
        }
    }
    return NOERROR;
}


// If we can either stretch a window with no penalty or we have a filter that
// supports full screen mode directly then we get them into fullscreen mode
// immediately. Before we cue fullscreen playback we must be sure to prepare
// a filter to swap out in favour of the fullscreen renderer. If there is no
// likely looking suspect then we just take any old window and stretch it up

HRESULT CFGControl::CImplVideoWindow::StartFullScreenMode()
{
    NOTE("StartFullScreenMode");
    ASSERT(m_bFullScreen == TRUE);

    // Check there is at least some support

    HRESULT hr = InitFullScreenOptions();
    if (FAILED(hr)) {
        NOTE("No fullscreen available");
        return VFW_E_NO_FULLSCREEN;
    }

    // Do we have a filter supporting fullscreen mode

    if (m_pFullDirect || m_pFullIndirect) {
        if (m_pFullDirect) {
            m_pFullDirect->get_MessageDrain(&m_FullDrain);
            m_pFullDirect->put_MessageDrain((OAHWND)m_hwndDrain);
            return m_pFullDirect->put_FullScreenMode(OATRUE);
        }
        return StretchWindow(m_pFullIndirect);
    }

    // Look for a renderer to swap out

    if (m_pNormalFilter == NULL) {
        hr = InitNormalRenderer();
        if (FAILED(hr)) {
            NOTE("Having to stretch window");
            return StretchWindow(m_pFullIndirect);
        }
    }
    return CueFullScreen();
}


// Called when we are in fullscreen mode to reconnect the normal video filter
// instead of the Modex renderer we currently have. When we switched to the
// Modex filter we will have stored reference counted filter and pin objects
// so we know who to restore. The reconnection of the source filter and the
// normal renderer should always succeed as they were originally connected

HRESULT CFGControl::CImplVideoWindow::ConnectNormalFilter()
{
    IVideoWindow *pWindow = NULL;
    NOTE("ConnectNormalFilter");
    HRESULT hr = NOERROR;
    IPin *pPin = NULL;

    // This transfers the IMediaSelection between renderers if need be
    m_pFGControl->m_implMediaSeeking.SetVideoRenderer(m_pNormalFilter,m_pModexFilter);

    // Find who it's connected to

    m_pModexPin->ConnectedTo(&pPin);
    if (pPin == NULL) {
        NOTE("No peer pin");
        return E_UNEXPECTED;
    }

    // Disconnect and reconnect the source filter

    CFilterGraph * const m_pGraph = m_pFGControl->GetFG();
    m_pGraph->CFilterGraph::Disconnect(m_pModexPin);
    m_pGraph->CFilterGraph::Disconnect(pPin);
    hr = m_pGraph->CFilterGraph::Connect(pPin,m_pNormalPin);

    // Get an IVideoWindow interface from the filter

    m_pNormalFilter->QueryInterface(IID_IVideoWindow,(VOID **) &pWindow);
    if (pWindow == NULL) {
        NOTE("No IVideoWindow");
        pPin->Release();
        return E_UNEXPECTED;
    }

    // Show the normal window again

    pWindow->put_Visible(OATRUE);
    pWindow->Release();
    pPin->Release();
    return hr;
}


// This switches renderers to Modex. We disconnect the current chosen renderer
// and connect the output pin of the filter supplying it to the Modex renderer
// That may fail because there is no DirectDraw available in which case we go
// back to the initial window. All IVideoWindow and IBasicVideo properties are
// persistent across connections which makes reconnecting filters very simple

HRESULT CFGControl::CImplVideoWindow::ConnectModexFilter()
{
    IFullScreenVideo *pFullVideo = NULL;
    IVideoWindow *pWindow = NULL;
    BSTR Caption = NULL;
    NOTE("ConnectModexFilter");
    HRESULT hr = NOERROR;
    IPin *pPin = NULL;

    // Find out who it's connected to

    m_pNormalPin->ConnectedTo(&pPin);
    if (pPin == NULL) {
        NOTE("No peer pin");
        return E_UNEXPECTED;
    }

    // Get an IVideoWindow interface from the filter

    m_pNormalFilter->QueryInterface(IID_IVideoWindow,(VOID **) &pWindow);
    if (pWindow == NULL) {
        NOTE("No IVideoWindow");
        pPin->Release();
        return E_UNEXPECTED;
    }

    // Hide the window while fullscreen

    pWindow->put_Visible(OAFALSE);
    pWindow->get_Caption(&Caption);
    pWindow->Release();

    // Add the Modex renderer to the graph

    CFilterGraph * const m_pGraph = m_pFGControl->GetFG();
    if (m_bAddedToGraph == FALSE) {
        WCHAR FilterName[STR_MAX_LENGTH];
        WideStringFromResource(FilterName,IDS_VID34);
        hr = m_pGraph->CFilterGraph::AddFilter(m_pModexFilter,FilterName);
        if (FAILED(hr)) {
            FailFullScreenModex();
            return E_UNEXPECTED;
        }
    }

    m_bAddedToGraph = TRUE;

    // Disconnect and reconnect the source filter

    m_pGraph->Disconnect(m_pNormalPin);
    m_pGraph->Disconnect(pPin);

    // Try and connect the output to the Modex filter

    hr = m_pGraph->CFilterGraph::ConnectDirect(pPin,m_pModexPin,NULL);
    if (FAILED(hr)) {
        NOTE("Reconnecting normal renderer");
        m_pGraph->CFilterGraph::Connect(pPin,m_pNormalPin);
        pPin->Release();
        return E_UNEXPECTED;
    }

    pPin->Release();

    // Get an IFullScreenVideo interface from the filter

    hr = m_pModexFilter->QueryInterface(IID_IFullScreenVideo,(VOID **) &pFullVideo);
    if (hr == NOERROR) {
        pFullVideo->SetCaption(Caption);
        pFullVideo->SetMessageDrain(m_hwndDrain);
        pFullVideo->HideOnDeactivate(OATRUE);
        pFullVideo->Release();
    }

    // This transfers the IMediaSelection between renderers if need be
    m_pFGControl->m_implMediaSeeking.SetVideoRenderer(m_pModexFilter,m_pNormalFilter);

    FreeBSTR(&Caption);
    return NOERROR;
}


// This finds the first filter that supports IVideoWindow in the filtergraph
// and initialises m_pNormalFilter and m_pNormalPin (which is the first input
// pin we find). Both of these interface are stored reference counted which
// makes sure that they are available when we switch back again. If an error
// occurs then we call FailFullScreenModex, this releases any interfaces we
// got and initialises the object to do fullscreen by stretching any window

HRESULT CFGControl::CImplVideoWindow::InitNormalRenderer()
{
    NOTE("InitNormalRenderer");

    ASSERT(m_pNormalFilter == NULL);
    ASSERT(m_pNormalPin == NULL);
    ASSERT(m_pModexFilter);
    ASSERT(m_pModexPin);

    // Get the first IVideoWindow enabled filter

    CGenericList<IVideoWindow> *pWindowList;
    HRESULT hr = m_pFGControl->GetListWindow(&pWindowList);
    if (FAILED(hr)) {
        NOTE("No window list");
        return E_UNEXPECTED;
    }

    POSITION pos = pWindowList->GetHeadPosition();
    IVideoWindow *pWindow = pWindowList->Get(pos);
    pWindow->QueryInterface(IID_IBaseFilter,(VOID **) &m_pNormalFilter);

    // All renderers should implement IBaseFilter

    if (m_pNormalFilter == NULL) {
        ASSERT(m_pNormalFilter == NULL);
        NOTE("No IBaseFilter interface");
        FailFullScreenModex();
        return E_UNEXPECTED;
    }

    IEnumPins *pEnumPins = NULL;
    ULONG FetchedPins = 0;
    m_pNormalFilter->EnumPins(&pEnumPins);

    // Did we get an enumerator

    if (pEnumPins == NULL) {
        NOTE("No enumerator");
        FailFullScreenModex();
        return E_UNEXPECTED;
    }

    // Get the first and hopefully only input pin

    pEnumPins->Next(1,&m_pNormalPin,&FetchedPins);
    pEnumPins->Release();
    if (m_pNormalPin == NULL) {
        NOTE("No input pin");
        FailFullScreenModex();
        return E_UNEXPECTED;
    }
    return NOERROR;
}


// When we stretched the window fullscreen we will have restored if it was an
// icon or maximised. We will also have stored the window size so that in here
// we can reset the size. We also show the window again regardless of whether
// or not it was previously visible. This means the applications will always
// have their window restored and made visible coming out of fullscreen modes

HRESULT CFGControl::CImplVideoWindow::RestoreProperties(IVideoWindow *pWindow)
{
    NOTE("Restoring properties");

    // Set a zero size so that the task bar sees the fullscreen window being
    // restored, when we go fullscreen USER takes off the WS_EX_TOPMOST flag
    // from the taskbar to conceal it. If we don't size the window like this
    // USER does not add the extended style back onto the taskbar afterwards

    pWindow->SetWindowPosition(0,0,0,0);

    // Restore the extended window styles

    if (g_amPlatform & VER_PLATFORM_WIN32_NT) {
        pWindow->put_WindowStyleEx(m_FullStyleEx);
    }

    // Now hide the window for the changes

    pWindow->put_Visible(OAFALSE);
    pWindow->put_WindowStyle(m_FullStyle);
    pWindow->put_MessageDrain(m_FullDrain);
    RestoreVideoProperties(pWindow);

    // Reset the filter's window parent

    if (m_bGlobalOwner == TRUE) {
        NOTE("Set global owner");
        put_Owner(m_FullOwner);
    } else {
        NOTE("Set owner direct");
        pWindow->put_Owner(m_FullOwner);
    }

    pWindow->SetWindowPosition(m_FullPosition.left,    // Left position
                               m_FullPosition.top,     // And top place
                               m_FullPosition.right,   // Width not right
                               m_FullPosition.bottom); // And the height

    return pWindow->put_WindowState(SW_SHOWNORMAL);
}


// We use an IVideoWindow interface to stretch windows fullscreen. The filter
// may also have had a source or destination set through IBasicVideo whcih we
// must reset. We alwasy reset the rectangles in fullscreen mode because we
// cannot guarantee that all filters supporting fullscreen playback will ever
// implement IBasicVideo (a good example being the specialist modex renderer)

HRESULT CFGControl::CImplVideoWindow::StoreVideoProperties(IVideoWindow *pWindow)
{
    NOTE("StoreVideoProperties");
    IBasicVideo *pBasicVideo = NULL;
    pWindow->IsCursorHidden(&m_CursorHidden);
    pWindow->HideCursor(OATRUE);

    // First of all get the IBasicVideo interface

    pWindow->QueryInterface(IID_IBasicVideo,(VOID **)&pBasicVideo);
    if (pBasicVideo == NULL) {
        NOTE("No IBasicVideo");
        return NOERROR;
    }

    // Read these just in case they're useful later

    pBasicVideo->GetSourcePosition(&m_FullSource.left,         // Left source
                                   &m_FullSource.top,          // Top position
                                   &m_FullSource.right,        // Source width
                                   &m_FullSource.bottom);      // And height

    pBasicVideo->GetDestinationPosition(&m_FullTarget.left,    // Target left
                                        &m_FullTarget.top,     // Top position
                                        &m_FullTarget.right,   // Target width
                                        &m_FullTarget.bottom); // And height

    // Read and reset the current default settings

    m_FullDefSource = pBasicVideo->IsUsingDefaultSource();
    m_FullDefTarget = pBasicVideo->IsUsingDefaultDestination();
    pBasicVideo->SetDefaultSourcePosition();

    // These were calculated in InitFullScreenOptions

    pBasicVideo->SetDestinationPosition(m_ScaledRect.left,    // Target left
                                        m_ScaledRect.top,     // Top position
                                        m_ScaledRect.right,   // Target width
                                        m_ScaledRect.bottom); // And height

    pBasicVideo->Release();
    return NOERROR;
}


// This complements the StoreVideoProperties method. We are called when the
// video window being stretched is restored to its original size. In doing
// so we must also restore the source and destination rectangles the filter
// had on its IBasicVideo interface. As said before this isn't mandatory as
// not all rendering filters support IBasicVideo (like the modex renderer)

HRESULT CFGControl::CImplVideoWindow::RestoreVideoProperties(IVideoWindow *pWindow)
{
    NOTE("RestoreVideoProperties");
    IBasicVideo *pBasicVideo = NULL;

    // Restore the cursor state

    if (m_CursorHidden == OAFALSE) {
        pWindow->HideCursor(OAFALSE);
    }

    // First of all get the IBasicVideo interface

    pWindow->QueryInterface(IID_IBasicVideo,(VOID **)&pBasicVideo);
    if (pBasicVideo == NULL) {
        NOTE("No IBasicVideo");
        return NOERROR;
    }

    // Reset the source and destination before the defaults

    pBasicVideo->SetSourcePosition(m_FullSource.left,         // Left source
                                   m_FullSource.top,          // Top position
                                   m_FullSource.right,        // Source width
                                   m_FullSource.bottom);      // And height

    pBasicVideo->SetDestinationPosition(m_FullTarget.left,    // Target left
                                        m_FullTarget.top,     // Top position
                                        m_FullTarget.right,   // Target width
                                        m_FullTarget.bottom); // And height

    // Are we using a default source position

    if (m_FullDefSource == S_OK) {
        pBasicVideo->SetDefaultSourcePosition();
    }

    // Are we using a default destination position

    if (m_FullDefTarget == S_OK) {
        pBasicVideo->SetDefaultDestinationPosition();
    }

    pBasicVideo->Release();
    return NOERROR;
}


// We set the window styles to be suitable for a fullscreen mode (no border
// nor caption) and match the windows dimensions with the screen resolution
// After stretching the window we make sure it is brought to the foreground
// The window being stretched may be a child window if the application is
// playing the video in a document so we must save and reset it beforehand

HRESULT CFGControl::CImplVideoWindow::StretchWindow(IVideoWindow *pWindow)
{
    NOTE("Stretching existing window");
    pWindow->put_Visible(OAFALSE);
    StoreVideoProperties(pWindow);
    OAHWND GlobalOwner;

    // Get the restored video size

    pWindow->GetRestorePosition(&m_FullPosition.left,    // Left position
                                &m_FullPosition.top,     // And top place
                                &m_FullPosition.right,   // Width not right
                                &m_FullPosition.bottom); // And the height

    // Adjust the window styles for fullscreen mode

    pWindow->get_WindowStyle(&m_FullStyle);
    BOOL bIconic = (m_FullStyle & WS_ICONIC ? TRUE : FALSE);
    pWindow->put_WindowStyle(WS_POPUP);
    m_FullStyle &= ~(WS_MAXIMIZE | WS_MINIMIZE | WS_ICONIC);

    // Restore the window before sizing if iconic

    if (bIconic == TRUE) {
        NOTE("Restoring window from iconic");
        pWindow->put_WindowState(SW_SHOWNORMAL);
    }

    // Has the filter got a parent window

    pWindow->get_Owner(&m_FullOwner);
    get_Owner(&GlobalOwner);
    m_bGlobalOwner = FALSE;

    // Reset the filter's parent window

    if (GlobalOwner == m_FullOwner) {
        NOTE("Reset global owner");
        m_bGlobalOwner = TRUE;
        put_Owner(NULL);
    }

    pWindow->put_Owner(NULL);

    // Size the window to match the display
    //
    // Get the size of the current display mode for the monitor that we
    // are playing back on.
    //
    RECT rc;
    GetCurrentMonitorSize(pWindow, &rc);
    pWindow->SetWindowPosition(rc.left, rc.top, WIDTH(&rc), HEIGHT(&rc));

    NOTE2("Sized window to (%d,%d)",WIDTH(&rc), HEIGHT(&rc));

    // Complete the window initialisation

    pWindow->get_MessageDrain(&m_FullDrain);
    pWindow->put_MessageDrain((OAHWND)m_hwndDrain);
    pWindow->put_Visible(OATRUE);
    pWindow->SetWindowForeground(OATRUE);

    // Make sure the window comes out on top of the task bar

    if (g_amPlatform & VER_PLATFORM_WIN32_NT) {
        pWindow->get_WindowStyleEx(&m_FullStyleEx);
        pWindow->put_WindowStyleEx(WS_EX_TOPMOST);
    }
    return NOERROR;
}


// Allows an application to switch the filtergraph into fullscreen mode. We
// have a number of options. In preferred order they are, to have a renderer
// support this directly, to stretch an existing IVideoWindow enabled window
// fullscreen with no penalty (might have DirectDraw overlays), thirdly to
// switch renderers to a Modex renderer and the final catch all is to take
// any IVideoWindow and stretch it fullscreen and accept the bad performance

STDMETHODIMP CFGControl::CImplVideoWindow::put_FullScreenMode(long FullScreenMode)
{
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    NOTE("put_FullScreenMode");
    HRESULT hr = NOERROR;

    // Are we already in the mode required

    if (m_bFullScreen == (FullScreenMode == OATRUE ? TRUE : FALSE)) {
        NOTE("Nothing to do");
        return S_FALSE;
    }

    // Unset ourselves so we can set properties - we must set the full screen
    // property before doing any work. The reason for this is because when we
    // switch to a fullscreen renderer DirectDraw sends a whole bunch of stuff
    // to the application window. If any of these end up making it query the
    // current state from get_FullScreenMode then we must where we are going

    if (FullScreenMode == OAFALSE) {
        hr = StopFullScreenMode();
        m_bFullScreen = FALSE;
    } else {

        // Start fullscreen video mode

        m_bFullScreen = TRUE;
        hr = StartFullScreenMode();
        if (FAILED(hr)) {
            m_bFullScreen = FALSE;
        }
    }
    return hr;
}


// Called when we want to restore a normal mode of operation. If we have a
// filter who is handling fullscreen mode directly then we simply call it.
// If we have been stretching a window then we have to restore it's window
// properties (such as the owner). Finally if we switched to a Modex filter
// then the normal filter it replaced must be put back in place. Since it
// was originally connected to the same source this should always succeed

HRESULT CFGControl::CImplVideoWindow::StopFullScreenMode()
{
    IVideoWindow *pWindow = NULL;
    NOTE("StopFullScreenMode");
    ASSERT(m_bFullScreen == TRUE);
    OAFilterState Before;

    // Do we have a filter supporting fullscreen mode

    if (m_pFullDirect || m_pFullIndirect) {
        if (m_pFullDirect) {
            m_pFullDirect->put_MessageDrain(m_FullDrain);
            return m_pFullDirect->put_FullScreenMode(OAFALSE);
        }
        return RestoreProperties(m_pFullIndirect);
    }

    ASSERT(m_pModexFilter);
    ASSERT(m_pModexPin);
    ASSERT(m_pNormalFilter);
    ASSERT(m_pNormalPin);

    // Must stop the graph to reconnect

    Before = m_pFGControl->GetLieState();
    m_pFGControl->CancelRepaint();
    m_pFGControl->m_implMediaControl.Stop();

    // Have the renderers switched

    HRESULT hr = ConnectNormalFilter();
    if (FAILED(hr)) {
        NOTE("Reconnection bad");
        FailFullScreenModex();
    }

    // Pause the graph if we weren't stopped

    if (Before != State_Stopped) {
        NOTE("Pausing filtergraph...");
        m_pFGControl->m_implMediaControl.Pause();
        NOTE("Paused filtergraph");
    }

    // Finally have the graph run

    if (Before == State_Running) {
        return m_pFGControl->CueThenRun();
    }
    return NOERROR;
}


// This is called by the filtergraph plug in distributor worker thread. We are
// called when any window based filter gains or loses activation. We use the
// IBaseFilter passed with the call to see if a filter losing activation is
// the same as the one we are using to implement fullscreen mode. If so then
// we maually set the fullscreen state off and send a EC_FULLSCREEN_LOST code

HRESULT CFGControl::CImplVideoWindow::OnActivate(LONG bActivate,IBaseFilter *pFilter)
{
    NOTE1("OnActivate %d",bActivate);
    IVideoWindow *pGraphWindow;
    IBaseFilter *pGraphFilter;

    // Check we got a filter as well

    if (pFilter == NULL) {
        ASSERT(pFilter);
        return E_INVALIDARG;
    }

    // Only handle deactivation

    if (bActivate == TRUE) {
        NOTE("Not interested");
        return NOERROR;
    }

    // Can we ignore this notification completely

    if (m_bFullScreen == FALSE) {
        NOTE("Not in mode");
        return NOERROR;
    }

    // Is it a modex filter losing activation

    if (m_pModexFilter == pFilter) {
        NOTE("Switching from Modex");
        put_FullScreenMode(OAFALSE);
        return NOERROR;
    }

    // Are we using a filter directly

    pGraphWindow = m_pFullDirect;
    if (pGraphWindow == NULL) {
        NOTE("Using indirect filter");
        pGraphWindow = m_pFullIndirect;
    }

    // Is someone else being deactivated

    if (pGraphWindow == NULL) {
        NOTE("No stretch filter");
        ASSERT(m_pModexFilter);
        return NOERROR;
    }

    ASSERT(pGraphWindow);

    pGraphWindow->QueryInterface(IID_IBaseFilter,(VOID **) &pGraphFilter);
    if (pGraphFilter == NULL) {
        NOTE("No IBaseFilter");
        return E_UNEXPECTED;
    }

    // Does the filter match our fullscreen jobby

    if (pGraphFilter != pFilter) {
        pGraphFilter->Release();
        NOTE("No filter match");
        return NOERROR;
    }

    // Change the display mode if necessary

    NOTE("Resetting fullscreen mode...");
    put_FullScreenMode(OAFALSE);
    m_pFGControl->Notify(EC_FULLSCREEN_LOST,0,0);
    pGraphFilter->Release();
    NOTE("Reset mode completed");

    return NOERROR;
}


// Change the window position as a method call

STDMETHODIMP CFGControl::CImplVideoWindow::SetWindowPosition(long Left,
                                                             long Top,
                                                             long Width,
                                                             long Height)
{
    IVideoWindow *pV;
    HRESULT hr;
    {
        CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
        hr = GetFirstVW(pV);
        if (SUCCEEDED(hr)) {
            pV->AddRef();
        }
    }

    if (SUCCEEDED(hr)) {
        hr = pV->SetWindowPosition(Left, Top, Width, Height);
        pV->Release();
    }
    return hr;
}

REROUTE_IVW1( SetWindowForeground, long )

// Pass on window messages from the owning video window

STDMETHODIMP
CFGControl::CImplVideoWindow::NotifyOwnerMessage(OAHWND hwnd,   // Owner handle
                          long uMsg,   // Message ID
                          LONG_PTR wParam, // Parameters
                          LONG_PTR lParam) // for message
{
    IVideoWindow *pV;
    HRESULT hr;
    {
        if (m_hwndOwner == NULL) {
            NOTE("Ignoring message");
            return NOERROR;
        }
        if (m_bFullScreen) {
            return VFW_E_IN_FULLSCREEN_MODE;
        }
        pV = m_pFGControl->FirstVW();
        if (!pV) {
            return(E_NOINTERFACE);
        }
    }

    // Release lock once we have AddRef'd the interface
    hr = pV->NotifyOwnerMessage(hwnd,uMsg,wParam,lParam);

    pV->Release();
    return hr;
}


// Return the ideal minimum size for the video window

STDMETHODIMP
CFGControl::CImplVideoWindow::GetMinIdealImageSize(long *Width,long *Height)
{
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    IVideoWindow *pV;
    HRESULT hr;

    if (FAILED(hr = GetFirstVW(pV))) {
        return(hr);
    }
    return pV->GetMinIdealImageSize(Width, Height);
}


// Likewise return the maximum ideal window size

STDMETHODIMP
CFGControl::CImplVideoWindow::GetMaxIdealImageSize(long *Width,long *Height)
{
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    IVideoWindow *pV;
    HRESULT hr;

    if (FAILED(hr = GetFirstVW(pV))) {
        return(hr);
    }
    return pV->GetMaxIdealImageSize(Width, Height);
}


// Return the window coordinates in one atomic operation

STDMETHODIMP CFGControl::CImplVideoWindow::GetWindowPosition(long *pLeft,
                                                             long *pTop,
                                                             long *pWidth,
                                                             long *pHeight)
{
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    IVideoWindow *pV;
    HRESULT hr;

    if (FAILED(hr = GetFirstVW(pV))) {
        return(hr);
    }
    return pV->GetWindowPosition(pLeft,pTop,pWidth,pHeight);
}


// Return the normal (restored) window coordinates

STDMETHODIMP CFGControl::CImplVideoWindow::GetRestorePosition(long *pLeft,
                                                              long *pTop,
                                                              long *pWidth,
                                                              long *pHeight)
{
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    IVideoWindow *pV;
    HRESULT hr;

    if (FAILED(hr = GetFirstVW(pV))) {
        return(hr);
    }
    return pV->GetRestorePosition(pLeft,pTop,pWidth,pHeight);
}


// Allow an application to hide the cursor on our window
REROUTE_IVW1( HideCursor, long )

// Returns whether we have the cursor hidden or not
REROUTE_IVW1( IsCursorHidden, long* )


// Return the interface of the first in the list of IBasicVideo i/f pointers
//  - S_OK on success, failure code otherwise

HRESULT CFGControl::CImplBasicVideo::GetFirstBV(IBasicVideo*& pBV)
{
    ASSERT(CritCheckIn(m_pFGControl->GetFilterGraphCritSec()));

    // this is very similar to GetFirstVW, with the difference that
    // from CImplBasicVideo we do not know if we are in fullscreen mode...

    pBV = m_pFGControl->GetFirstBV();
    return pBV ? S_OK : E_NOINTERFACE;
}

// Constructor for an IBasicVideo plug in distributor. When we have properties
// set we always send them to the first filter that supports IBasicVideo, we
// don't have any properties that have to be sent to all filters. When we are
// asked for a property we just return the value from the first filter only.
// We offer properties like source and destination rectangle positions both
// as individual method calls and also as atomic methods more suitable for
// runtime environments - properties are normally used within VB form design

CFGControl::CImplBasicVideo::CImplBasicVideo(const TCHAR* pName,CFGControl *pfgc) :
    CBaseBasicVideo(pName, pfgc->GetOwner()),
    m_pFGControl(pfgc)
{
    ASSERT(pfgc);
}

template<class Method> static HRESULT __fastcall Dispatch0Arg( CFGControl::CImplBasicVideo * This, Method pMethod )
{
    CAutoMsgMutex lock(This->GetFGControl()->GetFilterGraphCritSec());
    IBasicVideo *pV;
    HRESULT hr = This->GetFirstBV(pV);
    if (SUCCEEDED(hr)) hr = (pV->*pMethod)();
    return hr;
}

#define REROUTE_IBV0( Method ) \
STDMETHODIMP CFGControl::CImplBasicVideo::Method() \
{ return Dispatch0Arg( this, &IBasicVideo::Method ); }

template<class Method, class T> static HRESULT __fastcall Dispatch1Arg( CFGControl::CImplBasicVideo * This, Method pMethod, T t )
{
    CAutoMsgMutex lock(This->GetFGControl()->GetFilterGraphCritSec());
    IBasicVideo *pV;
    HRESULT hr = This->GetFirstBV(pV);
    if (SUCCEEDED(hr)) hr = (pV->*pMethod)(t);
    return hr;
}

#define REROUTE_IBV1( Method, ArgType ) \
STDMETHODIMP CFGControl::CImplBasicVideo::Method(ArgType Arg) \
{ return Dispatch1Arg( this, &IBasicVideo::Method, Arg ); }

template<class Method, class T1, class T2, class T3, class T4>
static HRESULT __fastcall Dispatch4Arg( CFGControl::CImplBasicVideo * This, Method pMethod, T1 t1, T2 t2, T3 t3, T4 t4 )
{
    CAutoMsgMutex lock(This->GetFGControl()->GetFilterGraphCritSec());
    IBasicVideo *pV;
    HRESULT hr = This->GetFirstBV(pV);
    if (SUCCEEDED(hr)) hr = (pV->*pMethod)(t1,t2,t3,t4);
    return hr;
}

#define REROUTE_IBV4( Method, ArgType1, ArgType2, ArgType3, ArgType4 ) \
STDMETHODIMP CFGControl::CImplBasicVideo::Method(ArgType1 Arg1, ArgType2 Arg2, ArgType3 Arg3, ArgType4 Arg4) \
{ return Dispatch4Arg( this, &IBasicVideo::Method, Arg1, Arg2, Arg3, Arg4 ); }

#define REROUTE_IBV4Same( Method, ArgType ) \
STDMETHODIMP CFGControl::CImplBasicVideo::Method(ArgType Arg1, ArgType Arg2, ArgType Arg3, ArgType Arg4) \
{ return Dispatch4Arg( this, &IBasicVideo::Method, Arg1, Arg2, Arg3, Arg4 ); }

REROUTE_IBV1(get_AvgTimePerFrame, REFTIME * )
REROUTE_IBV1(get_BitRate, long *)
REROUTE_IBV1(get_BitErrorRate, long *)
REROUTE_IBV1(get_VideoWidth, long *)
REROUTE_IBV1(get_VideoHeight, long *)
REROUTE_IBV1(put_SourceLeft, long)
REROUTE_IBV1(get_SourceLeft, long *)
REROUTE_IBV1(put_SourceWidth, long)
REROUTE_IBV1(get_SourceWidth, long *)
REROUTE_IBV1(put_SourceTop, long)
REROUTE_IBV1(get_SourceTop, long *)
REROUTE_IBV1(put_SourceHeight, long)
REROUTE_IBV1(get_SourceHeight, long *)
REROUTE_IBV1(put_DestinationLeft, long)
REROUTE_IBV1(get_DestinationLeft, long *)
REROUTE_IBV1(put_DestinationWidth, long)
REROUTE_IBV1(get_DestinationWidth, long *)
REROUTE_IBV1(put_DestinationTop, long)
REROUTE_IBV1(get_DestinationTop, long *)
REROUTE_IBV1(put_DestinationHeight, long)
REROUTE_IBV1(get_DestinationHeight, long *)

REROUTE_IBV4Same( SetSourcePosition, long )
REROUTE_IBV4( GetVideoPaletteEntries, long, long, long *, long * )
REROUTE_IBV4Same( GetSourcePosition, long * )


// Return the dimenions of the native video
STDMETHODIMP CFGControl::CImplBasicVideo::GetVideoSize(long *pWidth,
                                                       long *pHeight)
{
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    IBasicVideo *pV;
    HRESULT hr;

    if (FAILED(hr = GetFirstBV(pV))) {
        return(hr);
    }
    return pV->GetVideoSize(pWidth,pHeight);
}

REROUTE_IBV0(SetDefaultSourcePosition)
REROUTE_IBV0(IsUsingDefaultSource)

REROUTE_IBV4Same(SetDestinationPosition, long)
REROUTE_IBV4Same(GetDestinationPosition, long*)

REROUTE_IBV0(SetDefaultDestinationPosition)
REROUTE_IBV0(IsUsingDefaultDestination)

// When we get asked for a current image we must make sure that the renderer
// is not using any DirectDraw surfaces. We can do this by hiding the window
// and then causing a seek. So we firstly reset the IVideoWindow interface
// then get the current filtergraph position. Finally by setting the current
// position to the same value we will have the same picture (hopefully) sent

HRESULT
CFGControl::CImplBasicVideo::PrepareGraph(WINDOWSTATE *pState)
{
    ASSERT(pState);
    IVideoWindow *pVideoWindow;
    NOTE("PrepareGraph");

    // To do the right thing the window must be hidden

    pState->pVideo->QueryInterface(IID_IVideoWindow,(VOID **) &pVideoWindow);
    if (pVideoWindow == NULL) {
        NOTE("No IVideoWindow");
        return NOERROR;
    }

    // Reset the IVideoWindow interface

    pVideoWindow->get_AutoShow(&pState->AutoShow);
    pVideoWindow->put_AutoShow(OAFALSE);
    pVideoWindow->get_Visible(&pState->Visible);
    pVideoWindow->put_Visible(OAFALSE);
    if (pVideoWindow) pVideoWindow->Release();

    // Pause the graph if we're either stopped or running
    if (pState->State != State_Paused) {
        m_pFGControl->m_implMediaControl.Pause();
    }

    // Read the current position then cause the frame to be repainted
    HRESULT hr = m_pFGControl->m_implMediaPosition.get_CurrentPosition(&pState->Position);
    if (SUCCEEDED(hr)) {
        m_pFGControl->m_implMediaPosition.put_CurrentPosition(pState->Position);
    }
    return NOERROR;
}


// When we get asked for a current image we must make sure that the renderer
// is not using any DirectDraw surfaces. We can do this by hiding the window
// and then causing a seek. When we come back in here we reset the properties
// reset earlier to force us out of DirectDraw mode, the window show will not
// cause an EC_REPAINT because the renderer will still have the video sample
// we used to get a copy of. The final seek should get us back to DirectDraw

HRESULT
CFGControl::CImplBasicVideo::FinishWithGraph(WINDOWSTATE *pState)
{
    ASSERT(pState);
    IVideoWindow *pVideoWindow;
    NOTE("FinishWithGraph");

    // Make sure we switch back into DirectDraw

    pState->pVideo->QueryInterface(IID_IVideoWindow,(VOID **) &pVideoWindow);
    if (pVideoWindow == NULL) {
        NOTE("No IVideoWindow");
        return NOERROR;
    }

    // Put the graph back into the same state
    m_pFGControl->m_implMediaPosition.put_CurrentPosition(pState->Position);

    // Wait a while (but not INFINITE) for the state to complete, so we have a
    // frame to display - otherwise we'll erase window to black (see comment
    // before CVideoWindow::OnEraseBackground()).
    OAFilterState State;
    m_pFGControl->m_implMediaControl.GetState(1000,&State);

    // Reset the IVideoWindow interface

    pVideoWindow->put_AutoShow(pState->AutoShow);
    pVideoWindow->put_Visible(pState->Visible);
    if (pVideoWindow) pVideoWindow->Release();
    NOTE1("Reset autoshow (%d)",pState->AutoShow);
    NOTE1("And visible property (%d)",pState->Visible);

    return NOERROR;
}


// Called when the filtergraph should be restored to an initial state

HRESULT CFGControl::CImplBasicVideo::RestoreGraph(OAFilterState State)
{
    NOTE("Entering RestoreGraph");

    if (State == State_Stopped) {
        return m_pFGControl->m_implMediaControl.Stop();
    } else if (State == State_Running) {
        return m_pFGControl->CueThenRun();
    }
    return NOERROR;
}


// Debug function to dump a static image to the display

// void ShowCurrentImage(long *pSize,long *pImage)
// {
//     BITMAPINFOHEADER *pHeader = (BITMAPINFOHEADER *) pImage;
//     HDC hdcDisplay = GetDC(NULL);
//     int StretchMode = SetStretchBltMode(hdcDisplay,COLORONCOLOR);
//     LONG FormatSize = GetBitmapFormatSize(pHeader) - SIZE_PREHEADER;
//     BYTE *pVideoImage = (PBYTE) pImage + FormatSize;
//
//     StretchDIBits(hdcDisplay,0,0,pHeader->biWidth,pHeader->biHeight,0,0,
//                   pHeader->biWidth,pHeader->biHeight,pVideoImage,
//                   (BITMAPINFO *) pHeader,DIB_RGB_COLORS,SRCCOPY);
//
//     SetStretchBltMode(hdcDisplay,StretchMode);
//     ReleaseDC(NULL,hdcDisplay);
// }


// Return a rendering of the current image. This is complicated because when
// the video renderer is in DirectDraw mode it cannot give us a picture. So
// what we do is to pause the graph, reset the surfaces it is allowed to use
// Then we effectively do a repaint for the current position, after waiting
// for the pause to complete (we time out after a short while) we can then
// get the current image. After doing this we must restore the graph state.

#define IMAGE_TIMEOUT 5000

STDMETHODIMP
CFGControl::CImplBasicVideo::GetCurrentImage(long *pSize,long *pImage)
{
    CheckPointer(pSize,E_POINTER);
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    IBasicVideo *pVideo;
    OAFilterState State, Before;
    WINDOWSTATE WindowState;

    // Make sure we have an IVideoWindow
    HRESULT hr = GetFirstBV(pVideo);
    if (FAILED(hr)) {
        return(hr);
    }

    // Is the application just asking for the memory required
    if (pImage == NULL) return pVideo->GetCurrentImage(pSize,pImage);

    // Get the current filtergraph state before we start
    m_pFGControl->m_implMediaControl.GetState(0,&Before);

    WindowState.pVideo = pVideo;
    WindowState.AutoShow = OAFALSE;
    WindowState.Visible = OATRUE;
    WindowState.Position = double(0);
    WindowState.State = Before;
    PrepareGraph(&WindowState);

    // Wait a while (but not INFINITE) for the state to complete

    hr = m_pFGControl->m_implMediaControl.GetState(IMAGE_TIMEOUT,&State);
    if (hr == VFW_S_STATE_INTERMEDIATE) {
        FinishWithGraph(&WindowState);
        RestoreGraph(Before);
        return VFW_E_TIMEOUT;
    }

    ASSERT(State == State_Paused);

    // Call the renderer to give us the image
    hr = pVideo->GetCurrentImage(pSize,pImage);
    if (FAILED(hr)) NOTE("Image not returned");

    // Tidy up the filtergraph state
    FinishWithGraph(&WindowState);
    RestoreGraph(Before);

    return (SUCCEEDED(hr) ? S_OK : hr);
}

STDMETHODIMP
CFGControl::CImplBasicVideo::GetPreferredAspectRatio(long *plAspectX, long *plAspectY)
{
    CAutoMsgMutex lock(m_pFGControl->GetFilterGraphCritSec());
    IBasicVideo *pVideo;

    // Make sure we have an IVideoWindow
    HRESULT hr = GetFirstBV(pVideo);
    IBasicVideo2 *pVideo2;
    if (SUCCEEDED(hr)) {
        hr = pVideo->QueryInterface(IID_IBasicVideo2, (void**)&pVideo2);
        if (SUCCEEDED(hr)) {
            hr = pVideo2->GetPreferredAspectRatio(plAspectX, plAspectY);
            pVideo2->Release();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filchain\filchain.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1999 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "FilGraph.h"
#include "MsgMutex.h"
#include "FilChain.h"
#include "List.h"

CFilterChain::CFilterChain( CFilterGraph* pFilterGraph ) :
    CUnknown( NAME("Filter Chain"), (IFilterGraph*)pFilterGraph ),
    m_pFilterGraph(pFilterGraph)

{
    // Make sure that pFilterGraph is a valid CFilterGraph pointer.
    ValidateReadPtr( pFilterGraph, sizeof(CFilterGraph) );
}

STDMETHODIMP CFilterChain::StartChain( IBaseFilter* pStartFilter, IBaseFilter* pEndFilter )
{
    CAutoMsgMutex alFilterGraphLock( m_pFilterGraph->GetCritSec() );

    if( State_Running != m_pFilterGraph->GetStateInternal() ) {
        return VFW_E_NOT_RUNNING;
    }

    HRESULT hr = ChangeFilterChainState( State_Running, pStartFilter, pEndFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

STDMETHODIMP CFilterChain::PauseChain( IBaseFilter *pStartFilter, IBaseFilter *pEndFilter )
{
    CAutoMsgMutex alFilterGraphLock( m_pFilterGraph->GetCritSec() );

    if( State_Paused != m_pFilterGraph->GetStateInternal() ) {
        return VFW_E_NOT_PAUSED;
    }

    HRESULT hr = ChangeFilterChainState( State_Paused, pStartFilter, pEndFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

STDMETHODIMP CFilterChain::StopChain( IBaseFilter* pStartFilter, IBaseFilter* pEndFilter )
{
    CAutoMsgMutex alFilterGraphLock( m_pFilterGraph->GetCritSec() );

    if( State_Stopped == m_pFilterGraph->GetStateInternal() ) {
        return S_OK;
    }

    HRESULT hr = ChangeFilterChainState( State_Stopped, pStartFilter, pEndFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

STDMETHODIMP CFilterChain::RemoveChain( IBaseFilter* pStartFilter, IBaseFilter* pEndFilter )
{
    // Validate Arguments
    CheckPointer( pStartFilter, E_POINTER );
    ValidateReadPtr( pStartFilter, sizeof(IBaseFilter*) );

    CAutoMsgMutex alFilterGraphLock( m_pFilterGraph->GetCritSec() );

    CFilterChainList fclFilterChain( pEndFilter, m_pFilterGraph );

    HRESULT hr = fclFilterChain.Create( pStartFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    hr = fclFilterChain.RemoveFromFilterGraph( m_pFilterGraph );
    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

HRESULT CFilterChain::ChangeFilterChainState( FILTER_STATE fsNewChainState, IBaseFilter* pStartFilter, IBaseFilter* pEndFilter )
{
    // Validate Arguments
    CheckPointer( pStartFilter, E_POINTER );
    ValidateReadPtr( pStartFilter, sizeof(IBaseFilter*) );

    CFilterChainList fclFilterChain( pEndFilter, m_pFilterGraph );

    HRESULT hr = fclFilterChain.Create( pStartFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    switch( fsNewChainState ) {

    case State_Running:
        hr = fclFilterChain.Run( m_pFilterGraph->GetStartTimeInternal() );
        break;

    case State_Paused:
        hr = fclFilterChain.Pause();
        break;

    case State_Stopped:
        hr = fclFilterChain.Stop();
        break;

    default:
        DbgBreak( "WARNING: Illegal case occured in CFilterChain::ChangeFilterChainState()" );
        return E_UNEXPECTED;
    }
    
    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filchain\filchain.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1999 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef FilterChain_h
#define FilterChain_h

class CFilterGraph;

class CFilterChain : public IFilterChain, public CUnknown
{
public:
    CFilterChain( CFilterGraph* pFilterGraph );

    DECLARE_IUNKNOWN

    STDMETHODIMP StartChain( IBaseFilter* pStartFilter, IBaseFilter* pEndFilter );
    STDMETHODIMP PauseChain( IBaseFilter *pStartFilter, IBaseFilter *pEndFilter );
    STDMETHODIMP StopChain( IBaseFilter* pStartFilter, IBaseFilter* pEndFilter );
    STDMETHODIMP RemoveChain( IBaseFilter* pStartFilter, IBaseFilter* pEndFilter );

private:
    HRESULT ChangeFilterChainState( FILTER_STATE fsNewChainState, IBaseFilter* pStartFilter, IBaseFilter* pEndFilter );

    CFilterGraph* m_pFilterGraph;

};

#endif // FilterChain_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filchain\list.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1999 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "FilGraph.h"
#include "FGEnum.h"
#include "list.h"
#include "util.h"

/******************************************************************************
    CDownStreamFilterList Implememtation
******************************************************************************/
CDownStreamFilterList::CDownStreamFilterList( CFilterGraph* pFilterGraph ) :
    m_pFilterGraph(pFilterGraph)
{
    // This class does not work if it does not have a valid CFilterGraph pointer.
    ASSERT( NULL != pFilterGraph );
}

HRESULT CDownStreamFilterList::Create( IBaseFilter* pStartFilter )
{
    // The list should be empty because it has not been created.
    ASSERT( 0 == GetCount() );

    CheckPointer( pStartFilter, E_POINTER );

    HRESULT hr = FindDownStreamFilters( pStartFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

CDownStreamFilterList::~CDownStreamFilterList()
{
}

HRESULT CDownStreamFilterList::FindDownStreamFilters( IPin* pOutputPin )
{
    // FindReachableFilters() assumes pOutputPin is an output pin.  The function
    // will not work properly if pOutputPin is an input pin.
    ASSERT( PINDIR_OUTPUT == Direction( pOutputPin ) );

    CComPtr<IBaseFilter> pDownStreamFilter;

    HRESULT hr = GetFilterWhichOwnsConnectedPin( pOutputPin, &pDownStreamFilter );
    if( VFW_E_NOT_CONNECTED == hr ) {
        // Since the output pin is unconnected, no filters are reachable from
        // this pin.
        return S_OK;
    }

    return FindDownStreamFilters( pDownStreamFilter );
}

HRESULT CDownStreamFilterList::FindDownStreamFilters( IBaseFilter* pDownStreamFilter )
{
    HRESULT hr = FilterMeetsCriteria( pDownStreamFilter );
    if( FAILED( hr ) ) {
        // FilterMeetsCriteria() returns an error code if class should stop
        // building the list and report failure.
        return hr;
    } 

    // ContinueSearching() returns S_FALSE if FindDownStreamFilters() should 
    // stop looking for more downstream filters. 
    hr = ContinueSearching( pDownStreamFilter );
    if( FAILED( hr ) ) {
        return hr;
    } else if( S_FALSE != hr ) {
        // Call this function recursively on each connected output pin.
        IPin* pCurrentOutputPin;
        CEnumPin NextOutputPin( pDownStreamFilter, CEnumPin::PINDIR_OUTPUT );

        do
        {
            pCurrentOutputPin = NextOutputPin();

            // CEnumPins::operator() returns NULL if all the pins have been enumerated.
            if( NULL != pCurrentOutputPin ) {
                hr = FindDownStreamFilters( pCurrentOutputPin );
                if( FAILED( hr ) ) {
                    pCurrentOutputPin->Release();
                    return hr;
                }

                pCurrentOutputPin->Release();
            }
        } while( NULL != pCurrentOutputPin ); 
    }

    POSITION posNewFilter = AddHead( pDownStreamFilter );
    if( NULL == posNewFilter ) {
        return E_FAIL;
    }

    // The list will release this reference when it's destroyed.
    pDownStreamFilter->AddRef(); 
    
    return S_OK;
}

HRESULT CDownStreamFilterList::FilterMeetsCriteria( IBaseFilter* pFilter )
{
    UNREFERENCED_PARAMETER( pFilter );

    return S_OK;
}

HRESULT CDownStreamFilterList::ContinueSearching( IBaseFilter* pFilter )
{
    UNREFERENCED_PARAMETER( pFilter );

    return S_OK;
}

HRESULT CDownStreamFilterList::RemoveFromFilterGraph( CFilterGraph* pFilterGraph )
{
    // Stop the filters
    HRESULT hr;
    POSITION posCurrent;
    IBaseFilter* pCurrentFilter;
    
    hr = Stop();
    if( FAILED( hr ) ) {
        return hr;
    }

    // Disconnect Down Stream Filters
    posCurrent = GetTailPosition();
    while( NULL != posCurrent ) {

        // posCurrent contains the position of the previous
        // filter after this function ends.
        pCurrentFilter = GetPrev( posCurrent );

        hr = pFilterGraph->RemoveAllConnections2( pCurrentFilter );
        if( FAILED( hr ) ) {
            return hr;
        }
    }

    // Remove Filters from the filter graph
    posCurrent = GetTailPosition();
    while( NULL != posCurrent ) {

        // posCurrent contains the position of the previous
        // filter after this function returns.
        pCurrentFilter = GetPrev( posCurrent );

        hr = pFilterGraph->RemoveFilter( pCurrentFilter );
        if( FAILED( hr ) ) {
            return hr;
        }
    } 

    return S_OK;
}

HRESULT CDownStreamFilterList::Run( REFERENCE_TIME rtFilterGraphRunStartTime )
{
    return ChangeDownStreamFiltersState( State_Running, rtFilterGraphRunStartTime );
}

HRESULT CDownStreamFilterList::Pause( void )
{
    return ChangeDownStreamFiltersState( State_Paused, 0 );
}

HRESULT CDownStreamFilterList::Stop( void )
{
    return ChangeDownStreamFiltersState( State_Stopped, 0 );
}

HRESULT CDownStreamFilterList::ChangeDownStreamFiltersState( FILTER_STATE fsNewState, REFERENCE_TIME rtFilterGraphRunStartTime )
{
    // The rtFilterGraphRunStartTime parameter should be 0 if the filter chain 
    // is not changing to the running state.  This parameter is only used if 
    // fsNewState equals State_Running.
    ASSERT( (State_Running == fsNewState) ||
            ((State_Paused == fsNewState) && (0 == rtFilterGraphRunStartTime)) ||
            ((State_Stopped == fsNewState) && (0 == rtFilterGraphRunStartTime)) );

    HRESULT hr;
    HRESULT hrReturn;
    POSITION posCurrent;
    IBaseFilter* pCurrentFilter;

    hrReturn = S_OK;

    // Change the downstream filter's state.

    // Filters must always be restarted in downstream order.  In order words,
    // Renderers are started first.  Then the filters connected to the renderers.
    // Then the filters connected to the filters connected to the renderers.  Etc.
    // Finally, the source filters are started last.  For example, the filters in 
    // the following filter graph should be started in one of the following orders:
    // C, D, B and A or D, C, B and A.
    //
    //                  |---| 
    //                  | C |
    // |---|    |---|-->|---|
    // | A |--->| B |
    // |---|    |---|-->|---|
    //                  | D |
    //                  |---|
    //
    // CDownStreamFilterList stores filters in downstream order.
    posCurrent = GetTailPosition();

    while( NULL != posCurrent ) {

        // posCurrent contains the position of the previous
        // filter after this function ends.
        pCurrentFilter = GetPrev( posCurrent );
        
        hr = ChangeFilterState( pCurrentFilter, fsNewState, rtFilterGraphRunStartTime );

        if( FAILED( hr ) ) {
            DbgLog(( LOG_ERROR, 3, "WARNING: Filter %#010x failed to change state.", pCurrentFilter ));
 
            if( (State_Running == fsNewState) || (State_Paused == fsNewState) ) {
                // Either all the filters are stopped, running or paused.  This function should never leave 
                // some filters in the stopped state and some in the running or paused state.
                EXECUTE_ASSERT( SUCCEEDED( Stop() ) );
                return hr;
            } else {
                // This function assumes there are three legal states: stopped, paused and running.
                ASSERT( State_Stopped == fsNewState );

                // Return the first failure.
                if( SUCCEEDED( hrReturn ) ) {
                    hrReturn = hr;
                }
            }
        }
    } 

    return hrReturn;
}

HRESULT CDownStreamFilterList::ChangeFilterState( IBaseFilter* pFilter, FILTER_STATE fsNewState, REFERENCE_TIME rtFilterGraphRunStartTime )
{
    // The rtFilterGraphRunStartTime parameter should be 0 if the filter
    // is not changing to the running state.  This parameter is only used if 
    // fsNewState equals State_Running.
    ASSERT( (State_Running == fsNewState) ||
            ((State_Paused == fsNewState) && (0 == rtFilterGraphRunStartTime)) ||
            ((State_Stopped == fsNewState) && (0 == rtFilterGraphRunStartTime)) );

    FILTER_STATE fsOldState;

    HRESULT hr = pFilter->GetState( 0, &fsOldState );
    if( FAILED( hr ) ) {
        return hr;
    }

    switch( fsNewState ) {

    case State_Running:
        hr = pFilter->Run( rtFilterGraphRunStartTime );
        break;

    case State_Paused:
        hr = pFilter->Pause();
        break;

    case State_Stopped:
        hr = pFilter->Stop();
        break;

    default:
        DbgBreak( "WARNING: An illegal case occured in CDownStreamFilterList::ChangeFilterState()" );
        return E_UNEXPECTED;
    }

    if( State_Running == m_pFilterGraph->GetStateInternal() ) {
        if( (State_Stopped == fsNewState) || (State_Running == fsNewState) ) {
            if( fsOldState != fsNewState ) {
                hr = m_pFilterGraph->IsRenderer( pFilter );
                if( FAILED( hr ) ) {
                    return hr;
                }

                // IsRenderer() only returns two success values: S_OK and S_FALSE.
                ASSERT( (S_OK == hr) || (S_FALSE == hr) );

                // Does this filter send an EC_COMPLETE message?
                if( S_OK == hr ) {
                    hr = m_pFilterGraph->UpdateEC_COMPLETEState( pFilter, fsNewState );
                    if( FAILED( hr ) ) {
                        return hr;
                    }
                }
            }
        }
    }

    return S_OK;
}

/******************************************************************************
    CFilterChainList Implementation
******************************************************************************/
CFilterChainList::CFilterChainList( IBaseFilter* pEndFilter, CFilterGraph* pFilterGraph  ) :
    CDownStreamFilterList(pFilterGraph),
    m_pEndFilter(pEndFilter), // CComPtr addrefs the interface pointer.
    m_fFoundEndFilter(false)
{
}

HRESULT CFilterChainList::Create( IBaseFilter* pStartFilter )
{
    // Validate Arguments
    CheckPointer( pStartFilter, E_POINTER );

    HRESULT hr = IsChainFilter( pStartFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    if( m_pEndFilter ) { // m_pEndFilter != NULL
        hr = IsChainFilter( m_pEndFilter );
        if( FAILED( hr ) ) {
            return hr;
        }
    }

    m_fFoundEndFilter = false;
    
    hr = CDownStreamFilterList::Create( pStartFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    if( m_pEndFilter ) { // m_pEndFilter != NULL
        if( !m_fFoundEndFilter ) {
            return E_FAIL; // VFW_E_END_FILTER_NOT_REACHABLE_FROM_START_FILTER
        }
    }

    return S_OK;
}

HRESULT CFilterChainList::FilterMeetsCriteria( IBaseFilter* pFilter )
{
    HRESULT hr = CDownStreamFilterList::FilterMeetsCriteria( pFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    hr = IsChainFilter( pFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

HRESULT CFilterChainList::ContinueSearching( IBaseFilter* pFilter )
{
    // This function expects chain filters.
    ASSERT( S_OK == IsChainFilter( pFilter ) );

    HRESULT hr = CDownStreamFilterList::ContinueSearching( pFilter );
    if( FAILED( hr ) || (S_FALSE == hr) ) {
        return hr;
    }

    // The user selected the end filter.
    if( m_pEndFilter ) { // NULL != m_pEndFilter
        if( ::IsEqualObject( pFilter, m_pEndFilter ) ) {
            m_fFoundEndFilter = true;
            return S_FALSE;
        }

    } else {
        // The user wants us to find the end filter.
        hr = IsFilterConnectedToNonChainFilter( pFilter );
        if( S_FALSE == hr ) {
            return S_FALSE;
        } else if( FAILED( hr ) ) {
            return hr;
        }
    }

    return S_OK; 
}

/******************************************************************************

IsChainFilter

    IsChainFilter() determines if a filter can be part of a filter chain.  
Each filter in a filter chain has the following properties:

    - Each filter has at most one connected input pin and one connected output
      pin.  For example, filters A, C, D, F, G, H, I, J and K (see the diagram
      below) can be in a filter chain because each one has at most one 
      connected input pin and one connected output pin.

              --->|---|    |---|--->                   
                  | C |--->| D |
|---|    |---|--->|---|    |---|--->|---|    |---|    |---|    |---|
| A |--->| B |                      | E |--->| F |--->| G |--->| H |
|---|    |---|--->|---|------------>|---|    |---|    |---|    |---|
                  | I |--->
              --->|---|--->

|---|    |---|    |---|
| J |--->| K |--->| L |
|---|    |---|    |---|

Parameters:
- pFilter [in]
    A Direct Show filter.

Return Value:
    S_OK if no errors occur.  Otherwise, an error HRESULT.

******************************************************************************/
HRESULT CFilterChainList::IsChainFilter( IBaseFilter* pFilter )
{
    CEnumPin NextPin( pFilter );

    HRESULT hr;
    IPin* pCurrentPin;
    DWORD dwNumConnectedInputPins = 0;
    DWORD dwNumConnectedOutputPins = 0;
    PIN_DIRECTION pdCurrentPinDirection;
    CComPtr<IPin> pFirstConnectedInputPinFound;
    CComPtr<IPin> pFirstConnectedOutputPinFound;

    // Determine the number of connected input and output pins.
    do
    {
        pCurrentPin = NextPin();
        
        // CEnumPins::operator() returns NULL if it has finished enumerating 
        // the filter's input pins.
        if( NULL != pCurrentPin ) {

            hr = pCurrentPin->QueryDirection( &pdCurrentPinDirection );
            
            if( FAILED( hr ) ) {
                pCurrentPin->Release();
                return hr;
            }
        
            if( IsConnected( pCurrentPin ) ) {
                switch( pdCurrentPinDirection ) {
                
                    case PINDIR_INPUT:
                        if( !pFirstConnectedInputPinFound ) { // NULL == pFirstConnectedInputPinFound
                            pFirstConnectedInputPinFound = pCurrentPin;
                        }

                        dwNumConnectedInputPins++;
                        break;
    
                    case PINDIR_OUTPUT:
                        if( !pFirstConnectedOutputPinFound ) { // NULL == pFirstConnectedOutputPinFound
                            pFirstConnectedOutputPinFound = pCurrentPin;
                        }

                        dwNumConnectedOutputPins++;
                        break;

                    default:
                        DbgBreak( "ERROR in CFilterChainList::IsChainFilter().  This case should never occur because it was not considered." );

                        pCurrentPin->Release();
                        return E_UNEXPECTED;
                }
            }

            pCurrentPin->Release();
        }
    } while( NULL != pCurrentPin );

    // Check to see if more than 1 input or output pin is connected.
    if( dwNumConnectedInputPins > 1 ) {
        return E_FAIL; // VFW_E_TOO_MANY_CONNECTED_INPUT_PINS
    }

    if( dwNumConnectedOutputPins > 1 ) {
        return E_FAIL; // VFW_E_TOO_MANY_CONNECTED_OUTPUT_PINS
    }

    // If the filter has a connected input pin and a connected output pin,
    // make sure the two pins are internally connected.
    if( pFirstConnectedInputPinFound && pFirstConnectedOutputPinFound ) { // (NULL != pFirstConnectedInputPinFound) && (NULL != pFirstConnectedOutputPinFound)
        hr = ChainFilterPinsInternallyConnected( pFirstConnectedInputPinFound, pFirstConnectedOutputPinFound );
        if( S_FALSE == hr ) {
            return E_FAIL; // VFW_E_INPUT_PIN_NOT_INTERNALLY_CONNECTED_TO_OUTPUT_PIN
        } if( FAILED( hr ) ) {
            return hr;
        }
    }

    return S_OK;
}

HRESULT CFilterChainList::ChainFilterPinsInternallyConnected( IPin* pInputPin, IPin* pOutputPin )
{
    // ChainFilterPinsInternallyConnected() assumes pOutputPin is an output pin.  The function
    // will not work properly if pOutputPin is an input pin.
    ASSERT( PINDIR_OUTPUT == Direction( pOutputPin ) );

    // ChainFilterPinsInternallyConnected() assumes pInputPin is an input pin.  The function
    // will not work properly if pInputPin is an output pin.
    ASSERT( PINDIR_INPUT == Direction( pInputPin ) );

    IPin* apConnectedInputPins[1];
    bool fInputAndOutputPinInternallyConnected;
    ULONG ulNumConnectedInputPins = sizeof(apConnectedInputPins)/sizeof(apConnectedInputPins[0]);

    HRESULT hr = pOutputPin->QueryInternalConnections( apConnectedInputPins, &ulNumConnectedInputPins );
    if( FAILED( hr ) && (E_NOTIMPL != hr) ) {
        return hr;
    }

    // IPin::QueryInternalConnections() returns three expected values: S_OK, 
    // S_FALSE and E_NOTIMPL. S_FALSE indicates that there was not enough room
    // in the apConnectedInputPins array to store all the internally connected
    // pins.  S_OK indicates that there was enough room and E_NOTIMPL indicates
    // that all input pins are internally connected to all output pins and vica-versa.
    // This macro detects illegal return value combinations.  If it fires, the filter
    // has a bug.
    ASSERT( ((S_FALSE == hr ) && (1 < ulNumConnectedInputPins)) ||
            ((S_OK == hr) && (0 == ulNumConnectedInputPins)) ||
            ((S_OK == hr) && (1 == ulNumConnectedInputPins)) ||
            (E_NOTIMPL == hr) );

    // IPin::QueryInternalConnections() returns E_NOTIMPL if every input pin
    // is internally connected to every output pin and every output pin is internally
    // connected to every input pin.
    if( E_NOTIMPL == hr ) {
        // The input pin and output pin are internally connected.
        fInputAndOutputPinInternallyConnected = true;

    } else if( (S_OK == hr) && (1 == ulNumConnectedInputPins) && IsEqualObject( pInputPin, apConnectedInputPins[0] ) ) {
        // The input pin and output pin are internally connected.
        fInputAndOutputPinInternallyConnected = true;

    } else {

        fInputAndOutputPinInternallyConnected = false;
    }

    if( (S_OK == hr) && (1 == ulNumConnectedInputPins) ) {
        apConnectedInputPins[0]->Release();
    }

    if( !fInputAndOutputPinInternallyConnected ) {
        return S_FALSE;
    }

    return S_OK;
}

HRESULT CFilterChainList::IsFilterConnectedToNonChainFilter( IBaseFilter* pUpstreamFilter )
{
    // This function expects chain filters.
    ASSERT( S_OK == IsChainFilter( pUpstreamFilter ) );

    CEnumPin NextOutputPin( pUpstreamFilter, CEnumPin::PINDIR_OUTPUT );

    HRESULT hr;
    IPin* pCurrentOutputPin;
    CComPtr<IBaseFilter> pDownStreamFilter;

    do
    {
        pCurrentOutputPin = NextOutputPin();

        // CEnumPins::operator() returns NULL if all the pins have been enumerated.
        if( NULL != pCurrentOutputPin ) {

            hr = GetFilterWhichOwnsConnectedPin( pCurrentOutputPin, &pDownStreamFilter );
            
            pCurrentOutputPin->Release();

            if( SUCCEEDED( hr ) ) {
                hr = IsChainFilter( pDownStreamFilter );
                if( FAILED( hr ) ) {
                    return S_FALSE;
                }
                 
                return S_OK;               

            } else if( VFW_E_NOT_CONNECTED == hr ) {
                // Since the output pin is unconnected, no filters are reachable from
                // this pin.
            } else if( FAILED( hr ) ) {
                return hr;
            }
        }
    } while( NULL != pCurrentOutputPin );

    // None of the upstream filter's output pins are connected.  Therefore, none of them
    // can be connected to a non-chain filter.
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filchain\list.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1999 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef List_h
#define List_h

#include "Util.h"

class CFilterGraph;

class CDownStreamFilterList : public CFilterList
{
public:
    CDownStreamFilterList( CFilterGraph* pFilterGraph );
    virtual HRESULT Create( IBaseFilter* pStartFilter );
    virtual ~CDownStreamFilterList();

    HRESULT RemoveFromFilterGraph( CFilterGraph* pFilterGraph );
    HRESULT Run( REFERENCE_TIME rtFilterGraphRunStartTime );
    HRESULT Pause( void );
    HRESULT Stop( void );

protected:
    virtual HRESULT FilterMeetsCriteria( IBaseFilter* pFilter );
    virtual HRESULT ContinueSearching( IBaseFilter* pFilter );

private:
    HRESULT ChangeDownStreamFiltersState( FILTER_STATE fsNewState, REFERENCE_TIME rtFilterGraphRunStartTime );
    HRESULT ChangeFilterState( IBaseFilter* pFilter, FILTER_STATE fsNewState, REFERENCE_TIME rtFilterGraphRunStartTime );

    HRESULT FindDownStreamFilters( IPin* pOutputPin );
    HRESULT FindDownStreamFilters( IBaseFilter* pDownStreamFilter );

    CFilterGraph* m_pFilterGraph;
};

class CFilterChainList : public CDownStreamFilterList
{
public:
    CFilterChainList( IBaseFilter* pEndFilter, CFilterGraph* pFilterGraph );
    HRESULT Create( IBaseFilter* pStartFilter );

private:
    HRESULT FilterMeetsCriteria( IBaseFilter* pFilter );
    HRESULT ContinueSearching( IBaseFilter* pFilter );

    HRESULT IsChainFilter( IBaseFilter* pFilter );
    HRESULT ChainFilterPinsInternallyConnected( IPin* pInputPin, IPin* pOutputPin );
    HRESULT IsFilterConnectedToNonChainFilter( IBaseFilter* pUpstreamFilter );

    bool m_fFoundEndFilter;
    CComPtr<IBaseFilter> m_pEndFilter;

};

#endif // List_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filerdr\code\driver.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

#include <objbase.h>
#include <wxdebug.h>
#include <stmonfil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filerdr\inc\stmonfil.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

/*
     stmonfil.h

     Limited implmentation of IStream on file

*/

class CSimpleStream : public IStream, public CUnknown
{
public:
    // Constructor
    CSimpleStream(TCHAR *pName, LPUNKNOWN lpUnk, HRESULT *phr);

    // Destructor
    ~CSimpleStream();

    // Opening and closing
    HRESULT Open(LPCTSTR lpszFileName);
    void Close();


    // IStream interfaces
    DECLARE_IUNKNOWN

    // Return the IStream interface if it was requested
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    STDMETHODIMP Write(CONST VOID *pv, ULONG cb, PULONG pcbWritten);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm,
                        ULARGE_INTEGER cb,
                        ULARGE_INTEGER *pcbRead,
                        ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset,
                            ULARGE_INTEGER cb,
                            DWORD dwLockType);

    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset,
                              ULARGE_INTEGER cb,
                              DWORD dwLockType);
    STDMETHODIMP Clone(IStream **ppstm);
};

class CStreamOnFile : public CSimpleStream
{
public:
    // Constructor
    CStreamOnFile(TCHAR *pName, LPUNKNOWN lpUnk, HRESULT *phr);

    // Destructor
    ~CStreamOnFile();

    // Opening and closing
    HRESULT Open(LPCTSTR lpszFileName);
    void Close();

    STDMETHODIMP Read(void * pv, ULONG cb, PULONG pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                      ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP Stat(STATSTG *pstatstg,
                      DWORD grfStatFlag);

private:
    HANDLE m_hFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\dyngraph.cpp ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved
//
//
//   dyngraph.cpp
//
//   Contains code to implement IGraphConfig in the DirectShow filter
//   graph
//
#include <streams.h>
#include <atlbase.h>
#include "fgenum.h"
#include "distrib.h"
#include "rlist.h"
#include "filgraph.h"
#include "FilCache.h"
#include "Util.h"

extern HRESULT GetFilterMiscFlags(IUnknown *pFilter, DWORD *pdwFlags);

HRESULT DisconnectPeer(IGraphBuilder *pGraph, IPin *pPin)
{
    CComPtr<IPin> pConnectedTo;
    HRESULT hr = pPin->ConnectedTo(&pConnectedTo);
    if (SUCCEEDED(hr)) {
        hr = pGraph->Disconnect(pConnectedTo);
    }
    return hr;
}

//  Helpers
HRESULT GetPinListHelper(
    IPin *pOut,
    IPin *pIn,
    CPinList *pList,
    int *nAdded
);

HRESULT GetPinList(IPin *pOut, IPin *pIn, CPinList *pList)
{
    int nAdded = 0;
    HRESULT hr = GetPinListHelper(pOut, pIn, pList, &nAdded);
    if (FAILED(hr)) {
        while (nAdded--) {
            EXECUTE_ASSERT(NULL != pList->RemoveTail());
        }
    }
    return hr;
}

HRESULT GetPinListHelper(
    IPin *pOut,
    IPin *pIn,
    CPinList *pList,
    int *pnAdded
)
{
    *pnAdded = 0;

    for (; ; ) {
        IPin *pConnected;
        HRESULT hr = pOut->ConnectedTo(&pConnected);

        if (FAILED(hr)) {
            return hr;
        }

        if (IsEqualObject(pIn, pConnected)) {
            pConnected->Release();
            return S_OK;
        }

        //  This call transfers the ref count on pConnected to
        //  the pin list

        if (!pList->AddTail(pConnected)) {
            pConnected->Release();
            return E_OUTOFMEMORY;
        }

        (*pnAdded)++;

        //  Find a pin related to the pin we found - also look at
        //  all of them in case one of them is our target
        CEnumConnectedPins EnumPins(pConnected, &hr);
        if (SUCCEEDED(hr)) {
            IPin *pPin;
            for (; ; ) {
                pPin = EnumPins();
                if (NULL == pPin) {
                    return VFW_E_NOT_CONNECTED;
                }
                hr = GetPinList(pPin, pIn, pList);
                pPin->Release();
                if (SUCCEEDED(hr)) {
                    return hr;
                }
            }
        }
        return VFW_E_NOT_CONNECTED;
    }
}


//
//  This is problematical if the filters have extra pins and
//  we don't stop the filters connected to those pins
//
HRESULT StopAndRemoveFilters(
    CFilterGraph *pGraph,
    const CPinList *pPins,
    IPin *pInput,
    DWORD dwFlags,
    FILTER_STATE fs )
{
    // The FILTER_STATE enumeration has three possible values: State_Stopped,
    // State_Paused and State_Running.
    ASSERT( (State_Stopped == fs) || (fs == State_Running) || (fs == State_Paused) );

    POSITION Pos;

    if( (fs == State_Running) || (fs == State_Paused) ) {

        //  Step the list stopping the filters then
        Pos = pPins->GetTailPosition();
        while (Pos) {
            IPin *pPin = pPins->GetPrev(Pos);
            CComPtr<IBaseFilter> pFilter;
            GetFilter(pPin, &pFilter);
            if (pFilter) {
                HRESULT hr = pFilter->Stop();
                if (FAILED(hr)) {
                    return hr;
                }

                if( fs == State_Running ) {

                    DWORD dwMiscFilterFlags;

                    hr = GetFilterMiscFlags( pFilter, &dwMiscFilterFlags );
                    if (SUCCEEDED(hr) && (dwMiscFilterFlags & AM_FILTER_MISC_FLAGS_IS_RENDERER) ) {
                        hr = pGraph->UpdateEC_COMPLETEState( pFilter, State_Stopped );
                        if (FAILED(hr)) {
                            return hr;
                        }
                    }
                }
            }
        }
    }

    //  step it again removing them
    //  Note that because we disconnect each pin and its partner
    //  we effectively disconnect all the output pins too here
    //
    //  pOut==>pIn1 Filter1 pOut1==>pIn2 .. Filtern pOutn==>pIn
    // disconnect its peer
    HRESULT hr = DisconnectPeer(pGraph, pInput);
    if (FAILED(hr))
    {
        // bug in app or filter if disconnect fails. we can't always
        // handle this gracefully.
        DbgBreak("StopAndRemoveFilters: failed to disconnect pin");
        return hr;
    }

    IPinConnection *ppc;
    hr = pInput->QueryInterface(IID_IPinConnection, (void **)&ppc);
    // caller (CGraphConfig::Reconnect) validates
    ASSERT(hr == S_OK);
    
    if(SUCCEEDED(hr))           // !!!
    {
        hr = ppc->DynamicDisconnect();
        ppc->Release();
    }
    if (FAILED(hr)) {
        // bug in app or filter if disconnect fails. we can't always
        // handle this gracefully.
        DbgBreak("StopAndRemoveFilters: failed to disconnect pin");
        return hr;
    }

    Pos = pPins->GetTailPosition();
    while (Pos) {
        IPin *pPin = pPins->GetPrev(Pos);
        HRESULT hr;
        hr = DisconnectPeer(pGraph, pPin);
        if (FAILED(hr)) {
            return hr;
        }
        hr = pGraph->Disconnect(pPin);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Place removed filters in the filter cache.
    if( dwFlags & AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS ) {
        IPin *pCurrentPin;
        IGraphConfig* pGraphConfig;
        IBaseFilter* pCurrentFilter;

        hr = pGraph->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
        if( FAILED( hr ) ) {
            return hr;
        }

        Pos = pPins->GetTailPosition();
        while (Pos) {
            pCurrentPin = pPins->GetPrev( Pos );

            GetFilter( pCurrentPin, &pCurrentFilter );
            if( NULL == pCurrentFilter ) {
                pGraphConfig->Release();
                return E_FAIL;
            }

            hr = pGraphConfig->AddFilterToCache( pCurrentFilter );

            pCurrentFilter->Release();

            if( FAILED( hr ) ) {
                pGraphConfig->Release();
                return hr;
            }
        }

        pGraphConfig->Release();
    }

    return hr;
}

//  Flags from the reconnect call
HRESULT ReconnectPins(
    CFilterGraph *pGraph,
    IPin *pOut,
    IPin *pIn,
    const AM_MEDIA_TYPE *pmtFirstConnection,
    DWORD dwFlags)
{
    if (dwFlags & AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT) {
        return pGraph->ConnectDirect(pOut, pIn, pmtFirstConnection);
    } else {
        DWORD dwConnectFlags = 0;  // No flags.

        if( dwFlags & AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS ) {
            dwConnectFlags |= AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS;
        }

        return pGraph->ConnectInternal(pOut, pIn, pmtFirstConnection, dwConnectFlags);
    }
}


//  Restart filters
HRESULT RestartFilters(
    IPin *pOut,
    IPin *pIn,
    REFERENCE_TIME tStart,
    FILTER_STATE fs,
    CFilterGraph* pGraph )
{
    // This function should only be called when the filter graph is running or pasued.
    ASSERT( (State_Paused == fs) || (State_Running == fs) );

    //  Find which filters we're dealing with
    CPinList PinList;
    HRESULT hr = GetPinList(pOut, pIn, &PinList);

    POSITION pos = PinList.GetHeadPosition();
    while (pos) {
        IPin *pPin = PinList.GetNext(pos);
        CComPtr<IBaseFilter> pFilter;
        GetFilter(pPin, &pFilter);
        if (pFilter != NULL) {
            if (fs == State_Paused) {
                hr = pFilter->Pause();
                if (FAILED(hr)) {
                    return hr;
                }
            } else {
                if (fs == State_Running) {
                    hr = pFilter->Run(tStart);
                    if (FAILED(hr)) {
                        return hr;
                    }

                    DWORD dwMiscFilterFlags;

                    hr = GetFilterMiscFlags( pFilter, &dwMiscFilterFlags );
                    if (SUCCEEDED(hr) && (dwMiscFilterFlags & AM_FILTER_MISC_FLAGS_IS_RENDERER) ) {
                        hr = pGraph->UpdateEC_COMPLETEState( pFilter, State_Running );
                        if (FAILED(hr)) {
                            return hr;
                        }
                    }
                }
            }
        }
    }
    return S_OK;
}

//  Now do our thing - note this code is not a method it's
//  perfectly generic
HRESULT DoReconnectInternal(
                    CFilterGraph *pGraph,
                    IPin *pOutputPin,
                    IPin *pInputPin,
                    const AM_MEDIA_TYPE *pmtFirstConnection,
                    IBaseFilter *pUsingFilter, // can be NULL
                    HANDLE hAbortEvent,
                    DWORD dwFlags,
                    const CPinList *pList,
                    REFERENCE_TIME tStart,
                    FILTER_STATE fs
)
{
    CComPtr<IPin> pUsingOutput, pUsingInput;

    //  If we're using a filter find an input pin and an output pin
    //  to connect to
    //  BUGBUG - should we support filters that are not just
    //  transforms?

    if (pUsingFilter) {
        CEnumPin EnumPins(pUsingFilter);
        for (;;) {
            IPin *pPin = EnumPins();
            if (NULL == pPin) {
                break;
            }
            int dir = Direction(pPin);
            if (pUsingOutput == NULL && dir == PINDIR_OUTPUT) {
                pUsingOutput = pPin;
            }
            else if (pUsingInput == NULL && dir == PINDIR_INPUT) {
                pUsingInput = pPin;
            }

            pPin->Release();
        }
        if (pUsingInput == NULL || pUsingOutput == NULL) {
            return VFW_E_CANNOT_CONNECT;
        }
    }

    //  Stop all the intermediate filters
    HRESULT hr = StopAndRemoveFilters(pGraph, pList, pInputPin, dwFlags, fs);
    if (FAILED(hr)) {
        return hr;
    }

    //  Need some way of knowing what filters got added to the graph!

    //  Do 1 or 2 connects
    if (NULL != pUsingFilter) {

        // If the new filter is a legacy one (how to tell) it
        // May need stopping before we can connect it
        hr = pUsingFilter->Stop();

        // Find some pins
        if (SUCCEEDED(hr)) {
            hr = ReconnectPins(pGraph, pOutputPin, pUsingInput, pmtFirstConnection, dwFlags);
        }
        if (SUCCEEDED(hr)) {
            hr = ReconnectPins(pGraph, pUsingOutput, pInputPin, NULL, dwFlags);
        }
    } else {
        hr = ReconnectPins(pGraph, pOutputPin, pInputPin, pmtFirstConnection, dwFlags);
    }

    //  BUGBUG - what backout logic do we need?
    //
    //  Now start the filters
    //  Because we should not have added any filters actually connecting
    //  the 2 we've just connected we should just be able to restart
    //  the path between them.

    //  BUGBUG
    //  However - there could be a stream split or merge or just more
    //  filters in the graph so just start everyone?

    if( State_Stopped != fs ) {
        if (SUCCEEDED(hr)) {
            hr = RestartFilters(pOutputPin, pInputPin, tStart, fs, pGraph);
        }
    }

    return hr;
}

//  Now do our thing - note this code is not a method it's
//  perfectly generic
HRESULT DoReconnect(CFilterGraph *pGraph,
                    IPin *pOutputPin,
                    IPin *pInputPin,
                    const AM_MEDIA_TYPE *pmtFirstConnection,
                    IBaseFilter *pUsingFilter, // can be NULL
                    HANDLE hAbortEvent,
                    DWORD dwFlags,
                    REFERENCE_TIME tStart,
                    FILTER_STATE fs
)
{
    //  Find the set of pins - for now we'll fail if we find a
    //  terminal filter before we find the pin we're looking for
    int  nPins    = 0;
    CPinList PinList;

    HRESULT hr = GetPinList(pOutputPin, pInputPin, &PinList);

    if (FAILED(hr)) {
        return hr;
    }

    return DoReconnectInternal(
               pGraph,
               pOutputPin,
               pInputPin,
               pmtFirstConnection,
               pUsingFilter,
               hAbortEvent,
               dwFlags,
               &PinList,
               tStart,
               fs);
}

//  CGraphConfig

CGraphConfig::CGraphConfig(CFilterGraph *pGraph, HRESULT *phr) :
    m_pFilterCache(NULL),
    m_pGraph(pGraph),
    CUnknown(NAME("CGraphConfig"), (IFilterGraph *)pGraph)
{
    m_pFilterCache = new CFilterCache( m_pGraph->GetCritSec(), phr );
    if( NULL == m_pFilterCache )
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    if( FAILED( *phr ) )
    {
        delete m_pFilterCache;
        m_pFilterCache = NULL;
        return;
    }
}

CGraphConfig::~CGraphConfig()
{
    delete m_pFilterCache;

    // This object should never be destroyed if someone holds a
    // valid IGraphConfig interface pointer.
    ASSERT( 0 == m_cRef );
}

STDMETHODIMP CGraphConfig::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IGraphConfig) {
        return GetInterface((IGraphConfig *)this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

//  IGraphConfig

STDMETHODIMP CGraphConfig::Reconnect(IPin *pOutputPin,
                                     IPin *pInputPin,
                                     const AM_MEDIA_TYPE *pmtFirstConnection,
                                     IBaseFilter *pUsingFilter, // can be NULL
                                     HANDLE hAbortEvent,
                                     DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if(pOutputPin == 0 && pInputPin == 0) {
        return E_INVALIDARG;
    }

    // It makes no sense to specify both of these flags because if the user
    // specifies the AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT flag, then the
    // filter graph manager never uses any filters from the filter cache.
    if( (AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT & dwFlags) &&
        (AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS & dwFlags) )
    {
        return E_INVALIDARG;
    }

    // smart pointer to hold refcount for pInputPin or pOutputPin --
    // which ever we set.
    QzCComPtr<IPin> pPinComputed;

    if(pOutputPin && !pInputPin) {
        hr = GetSinkOrSource(pOutputPin, &pPinComputed, hAbortEvent);
        pInputPin = pPinComputed; // no refcount
    }
    else if(!pOutputPin && pInputPin) {
        hr = GetSinkOrSource(pInputPin, &pPinComputed, hAbortEvent);
        pOutputPin = pPinComputed; // no refcount
    }

    if(FAILED(hr)) {
        return hr;
    }

    CComQIPtr<IPinConnection, &IID_IPinConnection>
        pConnection(pInputPin);

    if (pConnection == NULL) {
        return E_NOINTERFACE;
    }

    // Filters do not process data if the filter graph is in the stopped state.
    if( State_Stopped != m_pGraph->GetStateInternal() ) { 
        hr = PushThroughData(pOutputPin, pConnection, hAbortEvent);
        if (FAILED(hr)) {
            return hr;
        }
    }

    //  Lock the graph with the special lock then call back
    if (!m_pGraph->GetCritSec()->Lock(hAbortEvent)) {
        return VFW_E_STATE_CHANGED;
    }

    hr = DoReconnect(
        m_pGraph,
        pOutputPin,
        pInputPin,
        pmtFirstConnection,
        pUsingFilter,
        hAbortEvent,
        dwFlags,
        m_pGraph->m_tStart,
        m_pGraph->GetStateInternal());

    m_pGraph->GetCritSec()->Unlock();

    {
        IMediaEventSink *psink;
        HRESULT hrTmp = m_pGraph->QueryInterface(IID_IMediaEventSink, (void **)&psink);
        ASSERT(hrTmp == S_OK);
        hrTmp = psink->Notify(EC_GRAPH_CHANGED, 0, 0);
        psink->Release();
    }
        
    return hr;
}

STDMETHODIMP CGraphConfig::Reconfigure(
                         IGraphConfigCallback *pCallback,
                         PVOID pvContext,
                         DWORD dwFlags,
                         HANDLE hAbortEvent)
{
    //  Lock the graph with the special lock then call back
    if (!m_pGraph->GetCritSec()->Lock(hAbortEvent)) {
        return VFW_E_WRONG_STATE;
    }

    HRESULT hr = pCallback->Reconfigure(pvContext, dwFlags);

    m_pGraph->GetCritSec()->Unlock();

    return hr;
}

STDMETHODIMP CGraphConfig::AddFilterToCache(IBaseFilter *pFilter)
{
    return m_pFilterCache->AddFilterToCache( pFilter );
}

STDMETHODIMP CGraphConfig::EnumCacheFilter(IEnumFilters **pEnum)
{
    return m_pFilterCache->EnumCacheFilters( pEnum );
}

STDMETHODIMP CGraphConfig::RemoveFilterFromCache(IBaseFilter *pFilter)
{
    return m_pFilterCache->RemoveFilterFromCache( pFilter );
}

STDMETHODIMP CGraphConfig::GetStartTime(REFERENCE_TIME *prtStart)
{
    CAutoMsgMutex alFilterGraphLock( m_pGraph->GetCritSec() );
    CheckPointer( prtStart, E_POINTER );

    if (m_pGraph->GetStateInternal() != State_Running) {
        *prtStart = 0;
        return VFW_E_WRONG_STATE;
    } else {
        *prtStart = m_pGraph->m_tStart;
        return S_OK;
    }
}

STDMETHODIMP CGraphConfig::PushThroughData(
    IPin *pOutputPin,
    IPinConnection *pConnection,
    HANDLE hEventAbort)
{
    HRESULT hr = S_OK;

    CAMEvent evDone;
    if (NULL == HANDLE(evDone)) {
        return E_OUTOFMEMORY;
    }

    CComPtr<IPinConnection> pConnectionTmp;
    if(pConnection == 0)
    {
        IPin *pPin;
        hr = GetSinkOrSource(pOutputPin, &pPin, hEventAbort);
        if(SUCCEEDED(hr))
        {
            pPin->QueryInterface(IID_IPinConnection, (void **)&pConnectionTmp);
            pConnection = pConnectionTmp;
            pPin->Release();
        }
    }

    if(!pConnection) {
        return VFW_E_NOT_FOUND;
    }

    hr = pConnection->NotifyEndOfStream(evDone);
    if (FAILED(hr)) {
        return hr;
    }
    QzCComPtr<IPin> pConnected;
    hr = pOutputPin->ConnectedTo(&pConnected);
    if (FAILED(hr)) {
        return hr;
    }
    hr = pConnected->EndOfStream();
    if (FAILED(hr)) {
        return hr;
    }

    //  They'd better set their event now!  (in the synchronous case
    //  it will have happened inside the call to EndOfStream).
    DWORD dwRet;
    DWORD dwNumEvents;
    HANDLE Events[2] = { evDone, hEventAbort };
    
    if( NULL == hEventAbort ) {
        dwNumEvents = NUMELMS(Events) - 1;
    } else {
        dwNumEvents = NUMELMS(Events);
    }

    if (WAIT_OBJECT_0 != 
        (dwRet = WaitForMultipleObjects(dwNumEvents, Events, FALSE, INFINITE))) {
        ASSERT(dwRet == WAIT_OBJECT_0 + 1);
        hr = VFW_E_STATE_CHANGED;
    }

    // ??? should all paths do this? worrying that the downstream
    // filter has a handle that may or may not be valid.
    pConnection->NotifyEndOfStream(NULL);

    return hr;
}

// report whether pPinStart is a candidate and the pin connected to
// the other side of this filter. *ppPinEnd is null if we cannot
// traverse this filter.

HRESULT CGraphConfig::TraverseHelper(
    IPin *pPinStart,
    IPin **ppPinNext,
    bool *pfIsCandidate)
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock.
    ASSERT( CritCheckIn( m_pGraph->GetCritSec() ) );

    // Make sure the pin is in the filter graph.
    ASSERT( SUCCEEDED( m_pGraph->CheckPinInGraph(pPinStart) ) );

    HRESULT hr = S_OK;
    PIN_INFO pi;

    bool fCanTraverse = true;
    *pfIsCandidate = true;
    *ppPinNext = 0;

    hr = pPinStart->QueryPinInfo(&pi);
    if(SUCCEEDED(hr))
    {
        if(pi.dir == PINDIR_INPUT)
        {
            IPinConnection *ppc;
            if(SUCCEEDED(pPinStart->QueryInterface(IID_IPinConnection, (void **)&ppc))) {
                ppc->Release();
            } else {
                *pfIsCandidate = false;
            }
        }
        else
        {
            ASSERT(pi.dir == PINDIR_OUTPUT);
            IPinFlowControl *ppfc;
            hr = pPinStart->QueryInterface(IID_IPinFlowControl, (void **)&ppfc);
            if(SUCCEEDED(hr)) {
                ppfc->Release();
            } else {
                *pfIsCandidate = false;
            }
        }

        DWORD dwInternalFilterFlags = m_pGraph->GetInternalFilterFlags( pi.pFilter );

        bool fCanTraverse = !(FILGEN_ADDED_MANUALLY & dwInternalFilterFlags) ||
                            (FILGEN_FILTER_REMOVEABLE & dwInternalFilterFlags);

        // traverse to the next pin.
        if( fCanTraverse )
        {
            IEnumPins *pep;
            hr = pi.pFilter->EnumPins(&pep);
            if(SUCCEEDED(hr))
            {
                // we want there to be exactly 1 input pin and 1
                // output pin.
                IPin *rgp[3];
                ULONG cp;
                hr = pep->Next(3, rgp, &cp);
                if(SUCCEEDED(hr))
                {
                    ASSERT(hr == S_OK && cp == 3 ||
                           hr == S_FALSE && cp < 3);

                    if(cp == 2)
                    {
                        // need to make sure the pins are connected to
                        // avoid looping on circular graphs.
                        bool f_QIC_ok = false;

                        {
                            IPin *rgPinIC[1];
                            ULONG cPins = NUMELMS(rgPinIC);
                            HRESULT hrTmp = pPinStart->QueryInternalConnections(rgPinIC, &cPins);
                            if(hrTmp == E_NOTIMPL)
                            {
                                // all pins connect through
                                f_QIC_ok = true;
                            }
                            else if(SUCCEEDED(hr))
                            {
                                // can't return S_FALSE since there
                                // are only two pins
                                ASSERT(hr == S_OK);

                                if(cPins == 1)
                                {
                                    // this pin is connected to the other one
                                    f_QIC_ok = true;
                                    rgPinIC[0]->Release();
                                }
                                else
                                {
                                    ASSERT(cPins == 0);
                                }
                            }
                        }

                        IPin *pPinOtherSide = 0;

                        if(f_QIC_ok)
                        {
                            PIN_DIRECTION dir0, dir1;
                            hr = rgp[0]->QueryDirection(&dir0);
                            ASSERT(SUCCEEDED(hr));
                            hr = rgp[1]->QueryDirection(&dir1);
                            ASSERT(SUCCEEDED(hr));


                            if(dir0 != dir1 && dir0 == pi.dir)
                            {
                                pPinOtherSide = rgp[1];
                            }
                            else if(dir0 != dir1 && dir1 == pi.dir)
                            {
                                pPinOtherSide = rgp[0];
                            }

                            if(pPinOtherSide)
                            {
                                hr = pPinOtherSide->ConnectedTo(ppPinNext);
                                ASSERT(SUCCEEDED(hr) && *ppPinNext ||
                                       FAILED(hr) && !*ppPinNext);
                                
                                hr = S_OK; // supress this error
                            }
                        }
                    }

                    for(UINT i = 0; i < cp; i++) {
                        rgp[i]->Release();
                    }
                }

                pep->Release();
            }
        }

        pi.pFilter->Release();
    }

    if(FAILED(hr)) {
        ASSERT(!*ppPinNext);
    }

    return hr;
}

// go upstream or downstream until a filter added manually is found or
// until the furthest filter supporting dynamic reconnection
// (IPinConnection or IPinFlowControl) is found. stop if mux/demux
// found.
//

HRESULT CGraphConfig::GetSinkOrSource(IPin *pPin, IPin **ppPinOut, HANDLE hAbortEvent)
{
    //  Lock the graph with the special lock then call back
    if (!m_pGraph->GetCritSec()->Lock(hAbortEvent)) {
        return VFW_E_STATE_CHANGED;
    }

    HRESULT hr = GetSinkOrSourceHelper(pPin, ppPinOut);

    m_pGraph->GetCritSec()->Unlock();

    return hr;
}

HRESULT CGraphConfig::GetSinkOrSourceHelper(IPin *pPin, IPin **ppPinOut)
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock.
    ASSERT( CritCheckIn( m_pGraph->GetCritSec() ) );

    *ppPinOut = 0;

    HRESULT hr = S_OK;
    QzCComPtr<IPin> pPinLastCandidate, pPinIter;
    hr = pPin->ConnectedTo(&pPinIter);
    if(SUCCEEDED(hr))
    {
        for(;;)
        {
            IPin *pPinEnd;
            bool fIsCandidate;

            hr = TraverseHelper(pPinIter, &pPinEnd, &fIsCandidate);
            if(SUCCEEDED(hr))
            {
                if(fIsCandidate) {
                    pPinLastCandidate = pPinIter; // auto-addref;
                }

                pPinIter = pPinEnd; // auto-release, addref
                if(pPinEnd) {
                    pPinEnd->Release();
                }
            }

            if(!pPinEnd || FAILED(hr)) {
                break;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        if(pPinLastCandidate) {
            *ppPinOut = pPinLastCandidate;
            pPinLastCandidate->AddRef();
        } else {
            hr = VFW_E_NOT_FOUND;
        }
    }

    return hr;
}

// todo -
//
// GetSink graph traversal will hang on dexter circular graphs.

STDMETHODIMP CGraphConfig::SetFilterFlags(IBaseFilter *pFilter, DWORD dwFlags)
{
    CheckPointer( pFilter, E_POINTER );

    CAutoMsgMutex alFilterGraphLock( m_pGraph->GetCritSec() );

    if( !IsValidFilterFlags( dwFlags ) ) {
        return E_INVALIDARG;
    }

    HRESULT hr = m_pGraph->CheckFilterInGraph( pFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    DWORD dwInternalFilterFlags = m_pGraph->GetInternalFilterFlags( pFilter );

    if( AM_FILTER_FLAGS_REMOVABLE & dwFlags ) {
        dwInternalFilterFlags |= FILGEN_FILTER_REMOVEABLE;
    } else {
        dwInternalFilterFlags &= ~FILGEN_FILTER_REMOVEABLE;
    }

    m_pGraph->SetInternalFilterFlags( pFilter, dwInternalFilterFlags );

    return S_OK;
}

STDMETHODIMP CGraphConfig::GetFilterFlags(IBaseFilter *pFilter, DWORD *pdwFlags)
{
    CheckPointer( pFilter, E_POINTER );
    CheckPointer( pdwFlags, E_POINTER );

    ValidateWritePtr( pdwFlags, sizeof(DWORD*) );

    CAutoMsgMutex alFilterGraphLock( m_pGraph->GetCritSec() );

    HRESULT hr = m_pGraph->CheckFilterInGraph( pFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    DWORD dwInternalFilterFlags = m_pGraph->GetInternalFilterFlags( pFilter );

    *pdwFlags = 0;

    if( FILGEN_FILTER_REMOVEABLE & dwInternalFilterFlags ) {
        (*pdwFlags) |= AM_FILTER_FLAGS_REMOVABLE;
    }

    //Make sure the function only returns valid information.
    ASSERT( IsValidFilterFlags( *pdwFlags ) );

    return S_OK;
}

STDMETHODIMP CGraphConfig::RemoveFilterEx(IBaseFilter *pFilter, DWORD Flags)
{
    return m_pGraph->RemoveFilterEx( pFilter, Flags );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\cachemap.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/*
    Caching the filter cache


    Filter cache cache looks like this

    FILTER_CACHE - includes
        total size
        version
        merit
*/


typedef struct _FILTER_CACHE
{
    DWORD dwSize;
    //  Signature
    enum {
        CacheSignature  = 'fche',
        FilterDataSignature = 'fdat'
    };
    DWORD dwSignature;
    DWORDLONG dwlBootTime;    // Save when we think we last booted
    enum { Version = 0x0102 }; // Change this for new cache layouts
    DWORD dwVersion;
    DWORD dwPnPVersion;        // Compare against mmdevldr value
    DWORD dwMerit;
    DWORD cFilters;
} FILTER_CACHE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filerdr\stmonfil\stmonfil.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
     stmonfil.cpp

     Limited implmentation of IStream on file

*/

#include <streams.h>
#include <objbase.h>
#include <stmonfil.h>

// Constructor
CSimpleStream::CSimpleStream(TCHAR *pName,
                             LPUNKNOWN lpUnk,
                             HRESULT *phr) :
    CUnknown(pName, lpUnk)
{
}

// Destructor
CSimpleStream::~CSimpleStream()
{
}

// Return the IStream interface if it was requested
STDMETHODIMP CSimpleStream::NonDelegatingQueryInterface(REFIID riid, void ** pv)
{
    if (riid == IID_IStream) {
        return GetInterface((IStream *)this, pv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, pv);
    }
}

STDMETHODIMP CSimpleStream::Write(CONST VOID * pv, ULONG cb, PULONG pcbWritten)
{
    return E_NOTIMPL;
}
STDMETHODIMP CSimpleStream::SetSize(ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}
STDMETHODIMP CSimpleStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb,
                    ULARGE_INTEGER *pcbRead,
                    ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}
STDMETHODIMP CSimpleStream::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}
STDMETHODIMP CSimpleStream::Revert()
{
    return E_NOTIMPL;
}
STDMETHODIMP CSimpleStream::LockRegion(ULARGE_INTEGER libOffset,
                        ULARGE_INTEGER cb,
                        DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSimpleStream::UnlockRegion(ULARGE_INTEGER libOffset,
                          ULARGE_INTEGER cb,
                          DWORD dwLockType)
{
    return E_NOTIMPL;
}
STDMETHODIMP CSimpleStream::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}


/* -- CStreamOnFile -- */

// Constructor
CStreamOnFile::CStreamOnFile(TCHAR *pName,
                             LPUNKNOWN lpUnk,
                             HRESULT *phr) :
    CSimpleStream(pName, lpUnk, phr),
    m_hFile(INVALID_HANDLE_VALUE)
{
}

// Destructor
CStreamOnFile::~CStreamOnFile()
{
    Close();
}

void CStreamOnFile::Close()
{
    if (m_hFile != INVALID_HANDLE_VALUE) {
        EXECUTE_ASSERT(CloseHandle(m_hFile));
        m_hFile = INVALID_HANDLE_VALUE;
    }
}

HRESULT CStreamOnFile::Open(LPCTSTR lpszFileName)
{
    Close();

    /*  Try to open the file */
    m_hFile       = CreateFile(lpszFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL);

    if (m_hFile       == INVALID_HANDLE_VALUE) {
        DWORD dwErr = GetLastError();
        DbgLog((LOG_ERROR, 2, TEXT("Failed to open file %s - code %d"),
               lpszFileName, dwErr));
	return AmHresultFromWin32(dwErr);
    }
    return S_OK;
}

/*  IStream interface */
STDMETHODIMP CStreamOnFile::Read(void * pv, ULONG cb, ULONG * pcbRead)
{
    if (m_hFile == INVALID_HANDLE_VALUE) {
        DbgLog((LOG_ERROR, 1, TEXT("Trying to access unopened file!")));
        return E_UNEXPECTED;
    }
    if (!ReadFile(m_hFile,
                  pv,
                  cb,
                  pcbRead,
                  NULL)) {
        DWORD dwRet = GetLastError();
        return AmHresultFromWin32(dwRet);
    } else {
        return S_OK;
    }
}

STDMETHODIMP CStreamOnFile::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                  ULARGE_INTEGER *plibNewPosition)
{
    if (m_hFile == INVALID_HANDLE_VALUE) {
        DbgLog((LOG_ERROR, 1, TEXT("Trying to access unopened file!")));
        return E_UNEXPECTED;
    }
    LONG lPosHi = dlibMove.HighPart;
    DWORD dwPosLow = SetFilePointer(m_hFile,
                                    (LONG)dlibMove.LowPart,
                                    &lPosHi,
                                    dwOrigin);

    DWORD dwError = NOERROR;
    if (dwPosLow == INVALID_FILE_SIZE) {
        dwError = GetLastError();
    }
    if (dwError == NOERROR) {
        plibNewPosition->HighPart = lPosHi;
        plibNewPosition->LowPart  = dwPosLow;
    }
    return AmHresultFromWin32(dwError);
}

STDMETHODIMP CStreamOnFile::Stat(STATSTG *pstatstg,
                  DWORD grfStatFlag)
{
    if (m_hFile == INVALID_HANDLE_VALUE) {
        DbgLog((LOG_ERROR, 1, TEXT("Trying to access unopened file!")));
        return E_UNEXPECTED;
    }
    if (grfStatFlag != STATFLAG_NONAME) {
        return E_NOTIMPL;
    }
    ULARGE_INTEGER li;
    li.LowPart = GetFileSize(m_hFile, &li.HighPart);
    if (li.LowPart == INVALID_FILE_SIZE) {
        DWORD dwErr = GetLastError();
        if (dwErr != NOERROR) {
            return AmHresultFromWin32(dwErr);
        }
    }

    ZeroMemory((PVOID)pstatstg, sizeof(*pstatstg));
    pstatstg->type              = STGTY_STREAM;
    pstatstg->cbSize            = li;

    // This implementation of IStream::Stat() does not
    // initialize all of STATSTG's member variables.  
    // This is acceptable because every user of the
    // class only accesses STATSTG's type member and cbsize 
    // member.

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\dyngraph.h ===
// Copyright (c) Microsoft Corporation 1996-1999. All Rights Reserved

class CFilterGraph;
class CFilterCache;

#include "util.h"

//  Dynamic graph object - just forwards stuff to the filter graph
class CGraphConfig :
    public IGraphConfig,
    public CUnknown
{
public:
    CGraphConfig(CFilterGraph *pGraph, HRESULT *phr);
    ~CGraphConfig();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);    

    //  IGraphConfig
    
    STDMETHODIMP Reconnect(IPin *pOutputPin, 
                           IPin *pInputPin,
                           const AM_MEDIA_TYPE *pmtFirstConnection,
                           IBaseFilter *pUsingFilter, // can be NULL
                           HANDLE hAbortEvent,
                           DWORD dwFlags);

    STDMETHODIMP Reconfigure(IGraphConfigCallback *pCallback,
                             PVOID pvContext,
                             DWORD dwFlags,
                             HANDLE hAbortEvent);

     
    STDMETHODIMP AddFilterToCache(IBaseFilter *pFilter);
    STDMETHODIMP EnumCacheFilter(IEnumFilters **pEnum);
    STDMETHODIMP RemoveFilterFromCache(IBaseFilter *pFilter);

    STDMETHODIMP GetStartTime(REFERENCE_TIME *prtStart);

    STDMETHODIMP PushThroughData(
        IPin *pOutputPin,
        IPinConnection *pConnection,
        HANDLE hEventAbort );

    STDMETHODIMP SetFilterFlags(IBaseFilter *pFilter, DWORD dwFlags);
    STDMETHODIMP GetFilterFlags(IBaseFilter *pFilter, DWORD *pdwFlags);

    STDMETHODIMP RemoveFilterEx( IBaseFilter *pFilter, DWORD Flags );
    

private:    
    HRESULT GetSinkOrSource(IPin *pPin, IPin **ppPinOut, HANDLE hAbortEvent);
    HRESULT GetSinkOrSourceHelper(IPin *pPin, IPin **ppPinOut);
    HRESULT TraverseHelper(IPin *pPinStart, IPin **ppPinNext, bool *pfIsCandidate);
    
    bool IsValidFilterFlags( DWORD dwFlags );

    CFilterGraph *m_pGraph;
    CFilterCache* m_pFilterCache;
};

inline bool CGraphConfig::IsValidFilterFlags( DWORD dwFlags )
{
    const DWORD VALID_FLAGS_MASK = AM_FILTER_FLAGS_REMOVABLE;

    return ValidateFlags( VALID_FLAGS_MASK, dwFlags );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\distrib.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.

#ifndef __DISTRIB_H__
#define __DISTRIB_H__

// This class supports plug-in distributors into the filtergraph.
//
// The filtergraph is a COM object that provides a single point of control
// for applications. It may contain several filters. The application will want to
// control those filters by talking to an interface on the filtergraph. For
// example, the app controls volume by asking the filtergraph for IBasicAudio
// and setting the volume property. The filtergraph has no knowledge of
// IBasicAudio itself, so it finds a plug-in distributor. This is an object
// that implements (eg) IBasicAudio by enumerating the filters in the graph
// and talking to those that support audio output. For any given interface we
// are asked for, we look for a clsid in the registry of an object that can
// implement that interface by distributing its methods to relevant filters
// in the graph.
//
// A distributor is instantiated as an aggregated object. It is created with
// an outer IUnknown* to which it defers all QueryInterface, AddRef and
// Release calls. It can also Query that outer unknown to obtain interfaces
// such as IFilterGraph which it uses to talk to the filters within the graph.
// This outer unknown is the filtergraph itself. Distributors must not
// hold refcounts on interfaces obtained from the filtergraph or circular
// refcounts will prevent anything from being released.
//
// The CDistributorManager class defined here manages a list of distributors.
// It will search the registry for a distributor for any given interface,
// and instantiate it aggregated by the outer unknown given on construction.
// It will make only one instance of a given class id. It also caches
// interfaces to reduce accesses to the registry.
//
// It will pass on Run, Pause, Stop and SetSyncSource calls to those
// loaded distributors that support IDistributorNotify. For backwards
// compatibility, we pass state changes to distributors that support
// IMediaFilter instead.


// This object represents one loaded distributor.
//
// for each loaded distributor, we remember
// its clsid (to avoid loading multiple instances of the
// same clsid), its non-delegating IUnknown to make new
// interfaces from, and its IMediaFilter (optional) to pass
// messages on to.
class CMsgMutex;  // predeclare
class CDistributor {
public:
    CLSID m_Clsid;

    // instantiate it from a clsid
    CDistributor(LPUNKNOWN pUnk, CLSID *clsid, HRESULT * phr, CMsgMutex * pFilterGraphCritSec );
    ~CDistributor();

    HRESULT QueryInterface(REFIID, void**);

    HRESULT Run(REFERENCE_TIME t);
    HRESULT Pause();
    HRESULT Stop();
    HRESULT SetSyncSource(IReferenceClock* pClock);
    HRESULT NotifyGraphChange();

private:
    IUnknown* m_pUnk;           // non-del unknown for plug-in object
    IUnknown* m_pUnkOuter;      // pUnk for aggregator
    IDistributorNotify *m_pNotify;
    IMediaFilter * m_pMF;
};

// this class represents one interface supported by a loaded
// distributor. We maintain a list of these
// simply as a cache to reduce registy accesses.
class CDistributedInterface {
public:
    GUID m_iid;
    IUnknown* m_pInterface;
    CDistributedInterface(REFIID, IUnknown*);
};

class CDistributorManager
{
public:

    // outer unknown passed to constructor is used as the aggregator for
    // all instantiations
    CDistributorManager(LPUNKNOWN pUnk, CMsgMutex * pFilterGraphCritSec );
    ~CDistributorManager();

// call this to find an interface distributor. If one is not already loaded
// it will search HKCR\Interface\<iid>\Distributor for a clsid and then
// instantiate that object.

    HRESULT QueryInterface(REFIID iid, void ** ppv);

// we pass on the basic IMediaFilter methods
    HRESULT Run(REFERENCE_TIME tOffset);
    HRESULT Pause();
    HRESULT Stop();
    HRESULT SetSyncSource(IReferenceClock* pClock);
    HRESULT NotifyGraphChange();

// notify shutdown to the IMediaEventSink handler if loaded
    HRESULT Shutdown(void);

protected:

    // protect against re-entry during destructor - destroying the list
    // of PIDs can lead to events eg NotifyGraphChange being called when the
    // lists are partly destroyed - if this member is TRUE then the
    // lists are not valid
    BOOL m_bDestroying;

    HRESULT GetDistributorClsid(REFIID riid, CLSID *pClsid);
    HRESULT ReturnInterface(CDistributor*, REFIID, void**);

    // this is the aggregator object
    LPUNKNOWN m_pUnkOuter;

    // pass on sync source and state to new objects
    FILTER_STATE m_State;
    REFERENCE_TIME m_tOffset;
    IReferenceClock * m_pClock;
    CMsgMutex * m_pFilterGraphCritSec;

    // list of loaded distributors
    CGenericList<CDistributor> m_listDistributors;

    // list of supported interfaces that we have returned already
    CGenericList<CDistributedInterface> m_listInterfaces;
};



#endif // __DISTRIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\cachemap.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.

// #include <windows.h>   already included in streams.h
#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include <string.h>
// #include <initguid.h>
#include <wxutil.h>
#include <wxdebug.h>

#include "mapper.h"
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <stats.h>
#include "..\squish\regtypes.h"
#include "..\squish\squish.h"

#define ROUND(_x_) (((_x_) + 3) & ~ 3)

const TCHAR szCache[] =
    TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie\\Filter Cache");

//  Get time since we booted
DWORDLONG GetLoadTime()
{
    FILETIME fTime;
    GetSystemTimeAsFileTime(&fTime);
    ULARGE_INTEGER ul;
    ul.HighPart = fTime.dwHighDateTime;
    ul.LowPart  = fTime.dwLowDateTime;
    DWORDLONG dwl = ul.QuadPart - (DWORDLONG)GetTickCount() * 10000;
    DbgLog((LOG_TRACE, 3, TEXT("Load time low part %d"), (DWORD)dwl));
    return dwl;
}

HRESULT CMapperCache::SaveCacheToRegistry(DWORD dwMerit, DWORD dwPnPVersion)
{
    HRESULT hr = S_OK;
    DWORD nFilters = 0;
    DWORD dwSizenames = 0;

    //  First convert to registry form
    //  First stage is to convert monikers to names or clsids
    {
        CComPtr<IBindCtx> pbc;
        hr = CreateBindCtx(0, &pbc);
        if (FAILED(hr)) {
            return hr;
        }
        POSITION pos = m_plstFilter->GetHeadPosition();


        while (pos) {
            CMapFilter *pMap = m_plstFilter->GetNext(pos);

            if (pMap->m_prf2->dwMerit >= dwMerit) {
                nFilters++;
#ifdef USE_CLSIDS
                //  BUGBUG - the filter name doesn't work because of
                //  the moniker scheme but let's use it
                //  for now and fix it later with a special method
                //  because calling MkParseDisplayName is going to
                //  be horrible
                HRESULT hr = GetMapFilterClsid(pMap, &pMap->clsid);
                if (SUCCEEDED(hr)) {
                    if (pMap->clsid == CLSID_NULL) {
                        return E_UNEXPECTED;
                    }
                } else
#endif // USE_CLSIDS
                {
#ifdef USE_CLSIDS
                    pMap->clsid = CLSID_NULL;
#endif
                    hr = pMap->pDeviceMoniker->GetDisplayName(
                                     pbc, NULL, &pMap->m_pstr);
                    if (FAILED(hr)) {
                        return hr;
                    }
                    DWORD dwStringSize =
                        sizeof(OLECHAR) * (1 + lstrlenW(pMap->m_pstr));
                    dwSizenames += ROUND(dwStringSize);
                }
            }
        }
    }

    //  Now figure out the size of our basic buffer
    //  allocate pointers to the stuff to be cached
    REGFILTER2 **ppRegFilters =
        (REGFILTER2**)_alloca(nFilters * sizeof(REGFILTER2*));

    POSITION pos = m_plstFilter->GetHeadPosition();

    DWORD iPosition = 0;
    DWORD dwSize = 0;
    while (pos) {
        CMapFilter *pMap = m_plstFilter->GetNext(pos);
        if (pMap->m_prf2->dwMerit >= dwMerit) {
            ppRegFilters[iPosition] = pMap->m_prf2;
            iPosition++;
        }
    }
    ASSERT(iPosition == nFilters);

    //  Let's figure the total size
    DWORD dwTotalSize = 0;
    hr = RegSquish(NULL, (const REGFILTER2 **)ppRegFilters, &dwTotalSize, nFilters);
    if (FAILED(hr)) {
        return hr;
    }
    DWORD dwFilterDataSize = dwTotalSize;

    //  Add in size for all the other junk
    dwTotalSize +=
#ifdef USE_CLSIDS
    sizeof(CLSID) * nFilters +
#endif
    dwSizenames +
                  sizeof(FILTER_CACHE) + sizeof(DWORD);

    PBYTE pbData = new BYTE[dwTotalSize];
    if (NULL == pbData) {
        return E_OUTOFMEMORY;
    }
    //  Initialize header
    FILTER_CACHE *pCache = (FILTER_CACHE *)pbData;
    pCache->dwVersion = FILTER_CACHE::Version;
    pCache->dwSignature = FILTER_CACHE::CacheSignature;
    pCache->dwMerit = dwMerit;
    pCache->dwPnPVersion = dwPnPVersion;
    pCache->cFilters = nFilters;

    //  Copy the data
    pbData += sizeof(FILTER_CACHE);
    pos = m_plstFilter->GetHeadPosition();
    while (pos) {
        CMapFilter *pMap = m_plstFilter->GetNext(pos);
        if (pMap->m_prf2->dwMerit >= dwMerit) {
#ifdef USE_CLSIDS
            *(CLSID*)pbData = pMap->clsid;
            pbData += sizeof(CLSID);
            if (pMap->clsid == CLSID_NULL)
#endif
            {
                lstrcpyW((OLECHAR *)pbData, pMap->m_pstr);
                DWORD dwStringSize =
                    sizeof(OLECHAR) * (1 + lstrlenW(pMap->m_pstr));
                pbData +=
                    ROUND(dwStringSize);
            }
        }
    }
    //  Put in a signature to help with debugging
    *(DWORD *)pbData = FILTER_CACHE::FilterDataSignature;
    pbData += sizeof(DWORD);

    //  Now squish the rest of the data
    DWORD dwUsed = dwFilterDataSize;
    hr = RegSquish(pbData, (const REGFILTER2 **)ppRegFilters, &dwUsed, nFilters);
    dwTotalSize -= (dwFilterDataSize - dwUsed);
    pCache->dwSize = dwTotalSize;

    if (SUCCEEDED(hr)) {
        //  Save in the registry
        hr = SaveData((PBYTE)pCache, dwTotalSize);
    }

    delete [] (PBYTE)pCache;
    return hr;
}

HRESULT CMapperCache::RestoreFromCache(DWORD dwPnPVersion)
{
    FILTER_CACHE *pCache = LoadCache(MERIT_DO_NOT_USE + 1, dwPnPVersion);
    if (NULL == pCache) {
        return E_FAIL;
    }
    HRESULT hr = RestoreFromCacheInternal(pCache);
    delete [] (PBYTE)pCache;
    return hr;
}

HRESULT CMapperCache::RestoreFromCacheInternal(FILTER_CACHE *pCache)
{
    REGFILTER2 ***ppprf2 = (REGFILTER2 ***)_alloca(pCache->cFilters * sizeof(REGFILTER2 **));
    PBYTE pbEnd = (PBYTE)pCache + pCache->dwSize;
    PBYTE pbCurrent = (PBYTE)(pCache + 1);
    //  Create all our filter stuff
    for (DWORD iFilter = 0; iFilter < pCache->cFilters; iFilter++) {
        CMapFilter *pFil = new CMapFilter;
        if (NULL == pFil) {
            return E_OUTOFMEMORY;
        }
        if (!m_plstFilter->AddTail(pFil)) {
            return E_OUTOFMEMORY;
        }
        ppprf2[iFilter] = &pFil->m_prf2;
#ifdef USE_CLSIDS
        //  Save the name/clsid
        if (pbEnd < (PBYTE)pbCurrent + sizeof(CLSID)) {
            return E_UNEXPECTED;
        }
        pFil->clsid = *(CLSID*)pbCurrent;
        pbCurrent += sizeof(CLSID);
        if (pFil->clsid == CLSID_NULL)
#endif // USE_CLSIDS
        {
            //  Pull out the name - check first
            for (LPCOLESTR pwstr = (LPCOLESTR)pbCurrent; ; pwstr++) {
                //  Hack to make sure the rounded up bit fits (use 2
                //  on the line below)
                if ((PBYTE)(pwstr + 2) > pbEnd) {
                    return E_UNEXPECTED;
                }
                if (*pwstr == 0) {
                    break;
                }
                //  Round up
            }
            DWORD dwSize = (DWORD)((PBYTE)(pwstr + 1) - pbCurrent);
            pFil->m_pstr = (LPOLESTR)CoTaskMemAlloc(dwSize * sizeof(OLECHAR));
            if (pFil->m_pstr == NULL) {
                return E_OUTOFMEMORY;
            }
            CopyMemory(pFil->m_pstr, pbCurrent, dwSize);
            dwSize = ROUND(dwSize);
            pbCurrent += dwSize;
        }
    }
    //  Now unsquish the rest
    if (*(DWORD *)pbCurrent != FILTER_CACHE::FilterDataSignature) {
        return E_UNEXPECTED;
    }
    pbCurrent += sizeof(DWORD);
    //  Unsquish the data
    HRESULT hr = UnSquish(pbCurrent, pCache->dwSize -
                          (DWORD)(pbCurrent - (PBYTE)pCache),
                          ppprf2,
                          pCache->cFilters);

    return hr;
}

HRESULT CMapperCache::SaveData(PBYTE pbData, DWORD dwSize)
{
    HKEY hkCache;
    //  Hack for windows 9x
    if (g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        ((FILTER_CACHE *)pbData)->dwlBootTime = GetLoadTime();
    } else {
        ((FILTER_CACHE *)pbData)->dwlBootTime = 0;
    }
    LONG lResult = RegOpenKeyEx(HKEY_CURRENT_USER, szCache, 0, KEY_WRITE,
                                  &hkCache);
    if (NOERROR != lResult) {
        DWORD dwDisposition;
        lResult = RegCreateKeyEx(HKEY_CURRENT_USER, szCache, 0, NULL,
                                  REG_OPTION_VOLATILE, KEY_WRITE, NULL,
                                  &hkCache, &dwDisposition);
    }
    if (NOERROR != lResult) {
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = NOERROR;

#if 0
    DWORD dwMaxSize = g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ?
                          16000 : 32768;
#else
    DWORD dwMaxSize = 32768;
#endif

    TCHAR szName[8];
    for (int j = 0; ;j++) {
        wsprintf(szName, TEXT("%d"), j);
        DWORD dwType;

        DWORD dwToWrite;
        for (; ;) {
            dwToWrite = min(dwSize, dwMaxSize);
            lResult = RegSetValueEx(hkCache, szName, 0, REG_BINARY,
                                         pbData, dwToWrite);

            //  Windows 9x has a much lower limit (why on earth?) so
            //  we'll wind up using 8K on Win9x
            if (lResult != ERROR_INVALID_PARAMETER || dwMaxSize <= 2048) {
                break;
            }
            dwMaxSize /= 2;
        }

        if (NOERROR != lResult) {
            break;
        }

        dwSize -= dwToWrite;
        if (dwSize == 0) {
            break;
        }
        pbData += dwToWrite;
    }
    HRESULT hr = S_OK;
    if (NOERROR != lResult) {
        RegCloseKey(hkCache);
        RegDeleteKey(HKEY_CURRENT_USER, szCache);
        return HRESULT_FROM_WIN32(lResult);
    } else {
        //  Delete any possible next entry left over from before
        wsprintf(szName, TEXT("%d"), j + 1);
        RegDeleteValue(hkCache, szName);
    }
    RegCloseKey(hkCache);
    return hr;
}


FILTER_CACHE * CMapperCache::LoadCache(DWORD dwMerit, DWORD dwPnPVersion)
{
    HKEY hkCache;
    LONG lResult = RegOpenKeyEx(HKEY_CURRENT_USER, szCache, 0, KEY_READ,
                                  &hkCache);
    PBYTE pbData = NULL;
    if (S_OK == lResult) {
        DWORD dwTotal = 0;
        for (int i = 0; i < 2; i++) {
            if (i == 1 && pbData == NULL) {
                break;
            }
            PBYTE pbCurrent = pbData;
            for (int j = 0; ; j++) {
                TCHAR szName[8];
                wsprintf(szName, TEXT("%d"), j);
                DWORD dwType;
                DWORD cbData = 0;
                if (i == 1) {
                    cbData = dwTotal - (DWORD)(pbCurrent - pbData);
                }
                LONG lResult = RegQueryValueEx(hkCache,
                                               szName,
                                               NULL,
                                               &dwType,
                                               i == 0 ? NULL : pbCurrent,
                                               &cbData);
                if (lResult == NOERROR) {
                    pbCurrent += cbData;
                } else {
                    break;
                }
            }
            if (i == 0) {
                dwTotal = (DWORD)(pbCurrent - pbData);
                pbData = new BYTE[dwTotal];
            }
        }
        RegCloseKey(hkCache);
        FILTER_CACHE *pCache = (FILTER_CACHE *)pbData;

        //  Nasty subtle bug is that old stuff might be left around
        //  when we save new stuff.
        //  Check size and version
        if (dwTotal < sizeof(FILTER_CACHE) ||
            NULL == pbData ||
            dwTotal != pCache->dwSize ||
            FILTER_CACHE::Version != pCache->dwVersion ||
            pCache->dwMerit > dwMerit ||
            pCache->dwPnPVersion != dwPnPVersion ||
            pCache->dwSignature != FILTER_CACHE::CacheSignature) {
            delete [] pbData;
            return NULL;
        }

        //  Hack for windows 9x
        if (g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
            if (GetLoadTime() > 30 * UNITS + pCache->dwlBootTime) {
                delete [] pbData;
                return NULL;
            }
        }
        return pCache;
    } else {
        return NULL;
    }
}

HRESULT CFilterMapper2::InvalidateCache()
{
    LONG lReturn = RegDeleteKey(HKEY_CURRENT_USER, szCache);
    return HRESULT_FROM_WIN32(lReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\distrib.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include "distrib.h"
#include "..\..\control\fgctl.h"

// implementation of plug-in distributor manager

CDistributorManager::CDistributorManager(LPUNKNOWN pUnk, CMsgMutex * pCritSec )
 : m_State(State_Stopped),
   m_pClock(NULL),
   m_pUnkOuter(pUnk),
   m_listDistributors(NAME("listDistributors")),
   m_listInterfaces(NAME("listInterfaces")),
   m_bDestroying(FALSE),
   m_pFilterGraphCritSec( pCritSec )
{
}


CDistributorManager::~CDistributorManager()
{
    // we addref'ed the clock
    if (m_pClock) {
        m_pClock->Release();
    }

    // the lists are about to become invalid, so no more distributed calls
    // please
    m_bDestroying = TRUE;

    // need to empty the lists
    POSITION pos = m_listDistributors.GetHeadPosition();
    while (pos) {

        CDistributor* p = m_listDistributors.GetNext(pos);
        delete p;
    }
    m_listDistributors.RemoveAll();

    pos = m_listInterfaces.GetHeadPosition();
    while (pos) {

        CDistributedInterface* p = m_listInterfaces.GetNext(pos);
        delete p;
    }
    m_listInterfaces.RemoveAll();
}


// search for a distributor for iid.
//
// We first check whether we have this interface already.
// If not, we get the clsid for the distributor from the registry.
// If we found one, we look to see if we have that clsid already, in which
// case we use that one.

HRESULT
CDistributorManager::QueryInterface(REFIID iid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    // first see if we have the interface already
    POSITION pos = m_listInterfaces.GetHeadPosition();
    while (pos) {
        CDistributedInterface* pDisti;
        pDisti = m_listInterfaces.GetNext(pos);
        if (pDisti->m_iid == iid) {
            pDisti->m_pInterface->AddRef();
            *ppv = pDisti->m_pInterface;
            return S_OK;
        }
    }

    // look in the registry for a distributor clsid
    CLSID clsid;
    HRESULT hr = GetDistributorClsid(iid, &clsid);
    if (FAILED(hr)) {
        return hr;
    }

    // search for this clsid in our list of distributors
    CDistributor* pDisti;
    pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        pDisti = m_listDistributors.GetNext(pos);
        if (pDisti->m_Clsid == clsid) {

            // found it - query for interface and return
            return ReturnInterface(pDisti, iid, ppv);
        }
    }

    // need to create new object
    hr = S_OK;
    pDisti = new CDistributor(m_pUnkOuter, &clsid, &hr, m_pFilterGraphCritSec);
    if (!pDisti) {
        return E_OUTOFMEMORY;
    } else if (FAILED(hr)) {
        delete pDisti;
        return hr;
    }

    // give it the current state and clock before adding it to our list
    if (m_pClock) {
        pDisti->SetSyncSource(m_pClock);
    }

    if (m_State == State_Stopped) {
        pDisti->Stop();
    } else if (m_State == State_Paused) {
        pDisti->Pause();
    } else {
        pDisti->Run(m_tOffset);
    }
    m_listDistributors.AddTail(pDisti);

    return ReturnInterface(pDisti, iid, ppv);

}

// look in the registry to find the Clsid for the object that will
// act as a distributor for the interface iid.
HRESULT
CDistributorManager::GetDistributorClsid(REFIID riid, CLSID *pClsid)
{
    // look in Interface\<iid>\Distributor for the clsid

    TCHAR chSubKey[128];
    WCHAR chIID[48];
    if (QzStringFromGUID2(riid, chIID, 48) == 0) {
        return E_NOINTERFACE;
    }
    wsprintf(chSubKey, TEXT("Interface\\%ls\\Distributor"), chIID);

    HKEY hk;
    LONG lRet = RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    chSubKey,
                    NULL,
                    KEY_READ,
                    &hk);
    if (lRet != ERROR_SUCCESS) {
        return E_NOINTERFACE;
    }

    LONG lLength;
    lRet = RegQueryValue(hk, NULL, NULL, &lLength);
    if (lRet != ERROR_SUCCESS) {
        RegCloseKey(hk);
        return E_NOINTERFACE;
    }


    TCHAR* pchClsid = new TCHAR[lLength / sizeof(TCHAR)];
    if (NULL == pchClsid) {
        RegCloseKey(hk);
        return E_OUTOFMEMORY;
    }
    lRet = RegQueryValue(hk, NULL, pchClsid, &lLength);
    RegCloseKey(hk);
    if (lRet != ERROR_SUCCESS) {
        delete [] pchClsid;
        return E_NOINTERFACE;
    }

#ifndef UNICODE
    WCHAR* pwch = new WCHAR[lLength];
    if (NULL == pwch) {
        delete [] pchClsid;
        return E_OUTOFMEMORY;
    }
    MultiByteToWideChar(
        CP_ACP,
        0,
        pchClsid,
        lLength,
        pwch,
        lLength
    );
    HRESULT hr = QzCLSIDFromString(pwch, pClsid);
    delete [] pwch;
#else
    HRESULT hr = QzCLSIDFromString(pchClsid, pClsid);
#endif
    delete [] pchClsid;
    if (FAILED(hr)) {
        return hr;
    }

    return S_OK;
}


// Query for a new interface and return it, caching it in our list
HRESULT
CDistributorManager::ReturnInterface(
    CDistributor* pDisti,
    REFIID riid,
    void** ppv)
{
    // Query for the new interface
    IUnknown* pInterface;
    HRESULT hr = pDisti->QueryInterface(riid, (void**)&pInterface);
    if (FAILED(hr)) {
        return hr;
    }

    // cache it on our list
    CDistributedInterface* pDI = new CDistributedInterface(riid, pInterface);
    m_listInterfaces.AddTail(pDI);

    // return it
    *ppv = pInterface;
    return S_OK;
}


// pass on IMediaFilter::Run method to distributors that need to
// know state
HRESULT
CDistributorManager::Run(REFERENCE_TIME tOffset)
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->Run(tOffset);
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }

    // remember this for any objects added later
    m_State = State_Running;
    m_tOffset = tOffset;

    return hr;
}

HRESULT
CDistributorManager::Pause()
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->Pause();
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }
    m_State = State_Paused;
    return hr;
}

HRESULT
CDistributorManager::Stop()
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->Stop();
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }
    m_State = State_Stopped;
    return hr;
}

HRESULT
CDistributorManager::NotifyGraphChange()
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->NotifyGraphChange();
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }
    return hr;
}

HRESULT CDistributorManager::SetSyncSource(IReferenceClock* pClock)
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    // replace our clock - remember to addref before release in case same
    if (pClock) {
        pClock->AddRef();
    }
    if (m_pClock) {
        m_pClock->Release();
    }
    m_pClock = pClock;

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->SetSyncSource(pClock);
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }
    return hr;
}

// the filter graph has entered its destructor.
// Pass on EC_SHUTTING_DOWN to the IMediaEventSink handler if
// we have it loaded. this will stop async event notifications such as
// EC_REPAINT from happening after shutdown.
HRESULT CDistributorManager::Shutdown(void)
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    // first see if we have the interface already
    POSITION pos = m_listInterfaces.GetHeadPosition();
    while (pos) {
        CDistributedInterface* pDisti;
        pDisti = m_listInterfaces.GetNext(pos);
        if (pDisti->m_iid == IID_IMediaEventSink) {

            IMediaEventSink* pSink = (IMediaEventSink*) pDisti->m_pInterface;
            return pSink->Notify(EC_SHUTTING_DOWN, 0, 0);

        }
    }

    // didn't find IMediaEventSink, so no-one was notified. not an error.
    return S_FALSE;
}


// --- CDistributor object implementation ---------------

// this object represents one instantiated distributor.
// The constructor attempts to instantiate it given the clsid.
CDistributor::CDistributor(LPUNKNOWN pUnk, CLSID *pClsid, HRESULT * phr, CMsgMutex * pCritSec )
 : m_pUnkOuter(pUnk), m_pMF(NULL), m_pNotify(NULL)
{
    m_Clsid = *pClsid;

    HRESULT hr = QzCreateFilterObject(
                    m_Clsid,
                    pUnk,
                    CLSCTX_INPROC,
                    IID_IUnknown,
                    (void**) &m_pUnk);

    if (FAILED(hr)) {
        *phr = hr;
        return;
    }

    // get the notify interface if exposed
    hr = m_pUnk->QueryInterface(IID_IDistributorNotify, (void**)&m_pNotify);
    if (SUCCEEDED(hr)) {
        // COM aggregation rules - this QI has addrefed the outer
        // object, and I must release that AddRef.
        m_pUnkOuter->Release();
    }

    // if no IDistributorNotify, then see if it understands IMediaFilter
    // instead (for backwards compatibility only)
    if (!m_pNotify) {
        hr = m_pUnk->QueryInterface(IID_IMediaFilter, (void**)&m_pMF);
        if (SUCCEEDED(hr)) {
            // COM aggregation rules - this QI has addrefed the outer
            // object, and I must release that AddRef.
            m_pUnkOuter->Release();
        }
    }
}


CDistributor::~CDistributor()
{
    // release our ref counts on the object
    if (m_pNotify) {
        // COM aggregation rules - since I released the refcount on
        // myself after the QI for this interface, I need to addref
        // myself before releasing it
        m_pUnkOuter->AddRef();

        m_pNotify->Release();
    }

    if (m_pMF) {
        // COM aggregation rules - since I released the refcount on
        // myself after the QI for this interface, I need to addref
        // myself before releasing it
        m_pUnkOuter->AddRef();

        m_pMF->Release();
    }

    // this is the non-delegating unknown of the aggregated object
    if (m_pUnk) {
        m_pUnk->Release();
    }
}

// ask for an interface that this object is supposed to distribute
HRESULT
CDistributor::QueryInterface(REFIID riid, void**ppv)
{
    if (m_pUnk) {
        return m_pUnk->QueryInterface(riid, ppv);
    }
    return E_NOINTERFACE;
}

// distribute IMediaFilter info if the object supports it
HRESULT
CDistributor::Run(REFERENCE_TIME t)
{
    if (m_pNotify) {
        return m_pNotify->Run(t);
    } else if (m_pMF) {
        return m_pMF->Run(t);
    } else {
        // not an error - notify support is optional
        return S_OK;
    }
}

HRESULT
CDistributor::Pause()
{
    if (m_pNotify) {
        return m_pNotify->Pause();
    } else if (m_pMF) {
        return m_pMF->Pause();
    } else {
        // not an error - notify support is optional
        return S_OK;
    }
}

HRESULT
CDistributor::Stop()
{
    if (m_pNotify) {
        return m_pNotify->Stop();
    } else if (m_pMF) {
        return m_pMF->Stop();
    } else {
        // not an error - notify support is optional
        return S_OK;
    }
}

HRESULT
CDistributor::SetSyncSource(IReferenceClock * pClock)
{
    if (m_pNotify) {
        return m_pNotify->SetSyncSource(pClock);
    } else if (m_pMF) {
        return m_pMF->SetSyncSource(pClock);
    } else {
        // not an error - notify support is optional
        return S_OK;
    }
}

HRESULT
CDistributor::NotifyGraphChange()
{
    if (m_pNotify) {
        return m_pNotify->NotifyGraphChange();
    } else {
        // not an error - and not on IMediaFilter
        return S_OK;
    }
}

CDistributedInterface::CDistributedInterface(
    REFIID riid,
    IUnknown* pInterface)
    : m_pInterface(pInterface)
{
    m_iid = riid;

    // actually we don't addref or release the interface pointer.
    // Since we aggregate this object, it's lifetime is maintained
    // by the CDistributor object. This interface pointer is delegated,
    // and an addref call would simply increase the refcount of the
    // outer object of which we are part.

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\efcache.cpp ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved

//
//   efcache.cpp
//
//       Implementation of filter enumerator for filter graph's
//       filter cache
//

#include <streams.h>
#include "FilCache.h"
#include "EFCache.h"
#include "MsgMutex.h"

/******************************************************************************
    CEnumCachedFilter Interface
******************************************************************************/
CEnumCachedFilter::CEnumCachedFilter( CFilterCache* pEnumeratedFilterCache, CMsgMutex* pcsFilterCache ) :
    CUnknown( NAME("Enum Cached Filters"), NULL )
{
    Init( pEnumeratedFilterCache,
          pcsFilterCache,
          pEnumeratedFilterCache->GetFirstPosition(),
          pEnumeratedFilterCache->GetCurrentVersion() );
}

CEnumCachedFilter::CEnumCachedFilter
    (
    CFilterCache* pEnumeratedFilterCache,
    CMsgMutex* pcsFilterCache,
    POSITION posCurrentFilter,
    DWORD dwCurrentCacheVersion
    ) :
    CUnknown( NAME("Enum Cached Filters"), NULL )
{
    Init( pEnumeratedFilterCache, pcsFilterCache, posCurrentFilter, dwCurrentCacheVersion );
}

CEnumCachedFilter::~CEnumCachedFilter()
{
}

void CEnumCachedFilter::Init
    (
    CFilterCache* pEnumeratedFilterCache,
    CMsgMutex* pcsFilterCache,
    POSITION posCurrentFilter,
    DWORD dwCurrentCacheVersion
    )
{
    // This class can not function if pEnumeratedFilterCache is not a
    // pointer to a valid CFilterCache object.
    ASSERT( NULL != pEnumeratedFilterCache );

    m_pcsFilterCache = pcsFilterCache;
    m_posCurrentFilter = posCurrentFilter;
    m_dwEnumCacheVersion = dwCurrentCacheVersion;
    m_pEnumeratedFilterCache = pEnumeratedFilterCache;
}

/******************************************************************************
    INonDelegatingUnknown Interface
******************************************************************************/
STDMETHODIMP CEnumCachedFilter::NonDelegatingQueryInterface( REFIID riid, void** ppv )
{
    CheckPointer( ppv, E_POINTER );
    ValidateWritePtr( ppv, sizeof(void*) );

    if( IID_IEnumFilters == riid )
    {
        return GetInterface( (IEnumFilters*)this, ppv );
    }
    else
    {
        return CUnknown::NonDelegatingQueryInterface( riid, ppv );
    }
}

/******************************************************************************
    IEnumFilters Interface
******************************************************************************/
STDMETHODIMP CEnumCachedFilter::Next( ULONG cFilters, IBaseFilter** ppFilter, ULONG* pcFetched )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    ValidateWritePtr( ppFilter, sizeof(IBaseFilter*)*cFilters );

    if( NULL != pcFetched )
    {
        ValidateReadWritePtr( pcFetched, sizeof(ULONG) );
        *pcFetched = 0;
    }

    // Validate Arguments
    if( 0 == cFilters )
    {
        // While cFilters can equal 0 (see the IEnumXXXX::Next() documentation in the Platform SDK),
        // this is probably an error
        ASSERT( false );
        return E_INVALIDARG;
    }

    if( NULL == ppFilter )
    {
        // ppFilter should never be NULL.
        ASSERT( false );
        return E_POINTER;
    }

    if( (NULL == pcFetched) && (1 != cFilters) )
    {
        // pcFetched can only equal NULL if cFilters equals 1.  See
        // the IEnumXXXX::Next() documentation in the Platform SDK for
        // more information.
        ASSERT( false );
        return E_POINTER;
    }

    if( IsEnumOutOfSync() )
    {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    IBaseFilter* pNextFilter;
    ULONG ulNumFiltersCoppied = 0;

    while( (ulNumFiltersCoppied < cFilters) && GetNextFilter( &pNextFilter ) )
    {
        pNextFilter->AddRef();
        ppFilter[ulNumFiltersCoppied] = pNextFilter;
        ulNumFiltersCoppied++;
    }

    if( NULL != pcFetched )
    {
        *pcFetched = ulNumFiltersCoppied;
    }

    if( ulNumFiltersCoppied != cFilters )
    {
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CEnumCachedFilter::Skip( ULONG cFilters )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // The caller probably wants to skip atleast one filter.
    // Skipping 0 filters is a no-op (it's also probably a
    // bug in the calling code).
    ASSERT( 0 != cFilters );

    if( IsEnumOutOfSync() )
    {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    ULONG ulNumFiltersSkipped = 0;

    while( (ulNumFiltersSkipped < cFilters) && AdvanceCurrentPosition() )
    {
        ulNumFiltersSkipped++;
    }

    if( cFilters != ulNumFiltersSkipped )
    {
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CEnumCachedFilter::Reset( void )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    m_posCurrentFilter = m_pEnumeratedFilterCache->GetFirstPosition();
    m_dwEnumCacheVersion = m_pEnumeratedFilterCache->GetCurrentVersion();

    return S_OK;
}

STDMETHODIMP CEnumCachedFilter::Clone( IEnumFilters** ppCloanedEnum )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    ValidateReadWritePtr( ppCloanedEnum, sizeof(IEnumFilters*) );

    if( NULL == ppCloanedEnum )
    {
        return E_POINTER;
    }

    IEnumFilters* pNewFilterCacheEnum;

    pNewFilterCacheEnum = new CEnumCachedFilter( m_pEnumeratedFilterCache,
                                                 m_pcsFilterCache,
                                                 m_posCurrentFilter,
                                                 m_dwEnumCacheVersion );
    if( NULL == pNewFilterCacheEnum )
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = ::GetInterface( pNewFilterCacheEnum, (void**)ppCloanedEnum );
    if( FAILED( hr ) )
    {
        delete pNewFilterCacheEnum;
        return hr;
    }

    return S_OK;
}

bool CEnumCachedFilter::IsEnumOutOfSync( void )
{
    return !(m_pEnumeratedFilterCache->GetCurrentVersion() == m_dwEnumCacheVersion);
}

bool CEnumCachedFilter::GetNextFilter( IBaseFilter** ppNextFilter )
{
    // This code may malfunction if it's called when the enum is out of sync.
    ASSERT( !IsEnumOutOfSync() );

    return m_pEnumeratedFilterCache->GetNextFilterAndFilterPosition( ppNextFilter,
                                                                     m_posCurrentFilter,
                                                                     &m_posCurrentFilter );
}

bool CEnumCachedFilter::AdvanceCurrentPosition( void )
{
    // This code may malfunction if it's called when the enum is out of sync.
    ASSERT( !IsEnumOutOfSync() );

    return m_pEnumeratedFilterCache->GetNextFilterPosition( m_posCurrentFilter, &m_posCurrentFilter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\fgenum.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// fgenum.cpp
//

// Wrappers for IEnumXXX
// see fgenum.h for more information

// #include <windows.h> already included in streams.h
#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <hrExcept.h>

#include <atlbase.h>
#include "fgenum.h"

// Should a pin be default rendered
bool RenderPinByDefault(IPin *pPin)
{
    PIN_INFO pinInfo;
    HRESULT hr = pPin->QueryPinInfo(&pinInfo);
    if (SUCCEEDED(hr)) {
        if (pinInfo.pFilter) {
            pinInfo.pFilter->Release();
        }
        if (pinInfo.achName[0] == L'~') {
            return false;
        }
    }
    return true;
}

// *
// * CEnumPin
// *

// Enumerates a filter's pins.

//
// Constructor
//
// Set the type of pins to provide - PINDIR_INPUT, PINDIR_OUTPUT or all
CEnumPin::CEnumPin(
    IBaseFilter *pFilter,
    DirType Type,
    BOOL bDefaultRenderOnly
)
    : m_Type(Type),
      m_bDefaultRenderOnly(bDefaultRenderOnly)
{

    if (m_Type == PINDIR_INPUT) {

        m_EnumDir = ::PINDIR_INPUT;
    }
    else if (m_Type == PINDIR_OUTPUT) {

        m_EnumDir = ::PINDIR_OUTPUT;
    }

    ASSERT(pFilter);

    HRESULT hr = pFilter->EnumPins(&m_pEnum);
    if (FAILED(hr)) {
        // we just fail to return any pins now.
        DbgLog((LOG_ERROR, 0, TEXT("EnumPins constructor failed")));
        ASSERT(m_pEnum == 0);
    }
}


//
// CPinEnum::Destructor
//
CEnumPin::~CEnumPin(void) {

    if(m_pEnum) {
        m_pEnum->Release();
    }
}


//
// operator()
//
// return the next pin, of the requested type. return NULL if no more pins.
// NB it is addref'd
IPin *CEnumPin::operator() (void) {


    if(m_pEnum)
    {
        ULONG	ulActual;
        IPin	*aPin[1];

        for (;;) {

            HRESULT hr = m_pEnum->Next(1, aPin, &ulActual);
            if (SUCCEEDED(hr) && (ulActual == 0) ) {	// no more filters
                return NULL;
            }
            else if (hr == VFW_E_ENUM_OUT_OF_SYNC)
            {
                m_pEnum->Reset();

                continue;
            }
            else if (ulActual==0)
                return NULL;

            else if (FAILED(hr) || (ulActual != 1) ) {	// some unexpected problem occured
                ASSERT(!"Pin enumerator broken - Continuation is possible");
                return NULL;
            }

            // if m_Type == All return the first pin we find
            // otherwise return the first of the correct sense

            PIN_DIRECTION pd;
            if (m_Type != All) {

                /*  Check if we need to only return default rendered
                    pins
                    */
                hr = aPin[0]->QueryDirection(&pd);

                if (FAILED(hr)) {
                    aPin[0]->Release();
                    ASSERT(!"Query pin broken - continuation is possible");
                    return NULL;
                }
            }

            if (m_Type == All || pd == m_EnumDir) {	// its the direction we want

                //  Screen out pins not required by default
                if (m_bDefaultRenderOnly) {
                    if (!RenderPinByDefault(aPin[0])) {
                        aPin[0]->Release();
                        continue;
                    }
                }
                return aPin[0];
            }
            else {			// its not the dir we want, so release & try again
                aPin[0]->Release();
            }
        }
    }
    else                        // m_pEnum == 0
    {
        return 0;
    }
}




// *
// * CEnumElements - enumerates elements in a Storage
// *


//
// Constructor
//
CEnumElements::CEnumElements(IStorage *pStorage) {

    HRESULT hr = pStorage->EnumElements(0, NULL, 0, &m_pEnum);
    if (FAILED(hr)) {
        ASSERT(!"EnumElements constructor failed");
        m_pEnum = NULL;
    }
}


//
// operator ()
//
// return the next element, or NULL if no more
STATSTG *CEnumElements::operator() (void) {

    ULONG ulActual;


    HRESULT hr;

    STATSTG *pStatStg = new STATSTG;
    if (pStatStg == NULL) {
        ASSERT(!"Out of memory");
        return NULL;
    }

    hr = m_pEnum->Next(1, pStatStg, &ulActual);
    if (SUCCEEDED(hr) && (ulActual == 0)) {
        return NULL;
    }
    else if (FAILED(hr) || (ulActual != 1)) {
        ASSERT(!"Broken enumerator");
        return NULL;
    }

    return pStatStg;
}

//  Enumerate pins connected to another pin through a filter
CEnumConnectedPins::CEnumConnectedPins(IPin *pPin, HRESULT *phr) :
    m_ppPins(NULL), m_dwPins(0), m_dwCurrent(0)
{
    *phr = pPin->QueryInternalConnections(NULL, &m_dwPins);
    if (SUCCEEDED(*phr)) {
        m_ppPins = new PPIN[m_dwPins];
        if( NULL == m_ppPins ) {
            *phr = E_OUTOFMEMORY;
            return;
        }
        *phr = pPin->QueryInternalConnections(m_ppPins, &m_dwPins);
    } else {
        PIN_INFO pi;
        *phr = pPin->QueryPinInfo(&pi);
        if (SUCCEEDED(*phr) && pi.pFilter != NULL) {
            m_pindir = (PINDIR_INPUT + PINDIR_OUTPUT) - pi.dir;
            *phr = pi.pFilter->EnumPins(&m_pEnum);
            pi.pFilter->Release();
        }
    }
}


CEnumConnectedPins::~CEnumConnectedPins()
{
    if (m_ppPins) {
        for (DWORD i = 0; i < m_dwPins; i++) {
            m_ppPins[i]->Release();
        }
        delete [] m_ppPins;
    }
}

IPin *CEnumConnectedPins::operator() (void) {
    if (m_ppPins) {
        if (m_dwCurrent++ < m_dwPins) {
            IPin *pPin = m_ppPins[m_dwCurrent - 1];
            pPin->AddRef();
            return pPin;
        } else {
            return NULL;
        }
    } else {
        IPin *pPin;
        DWORD dwGot;
        while (S_OK == m_pEnum->Next(1, &pPin, &dwGot)) {
            PIN_DIRECTION dir;
            if (SUCCEEDED(pPin->QueryDirection(&dir)) && 
                dir == m_pindir) {
                return pPin;
            } else {
                pPin->Release();
            }
        }
        return NULL;
    }
}

/******************************************************************************
    CEnumCachedFilters's Public Functions
******************************************************************************/

CEnumCachedFilters::CEnumCachedFilters( IGraphConfig* pFilterCache, HRESULT* phr ) :
    m_pCachedFiltersList(NULL),
    m_posCurrentFilter(NULL)
{
    HRESULT hr = TakeFilterCacheStateSnapShot( pFilterCache );
    if( FAILED( hr ) ) {
        DestoryCachedFiltersEnum();
        *phr = hr;
        return;
    }
}

CEnumCachedFilters::~CEnumCachedFilters()
{
    DestoryCachedFiltersEnum();
}

IBaseFilter* CEnumCachedFilters::operator()( void )
{
    // m_posCurrentFilter position is moved to the next filter as part of this operation.
    IBaseFilter* pCurrentFilter = m_pCachedFiltersList->GetNext( m_posCurrentFilter /* IN and OUT */ );

    // CGenericList::GetNext() returns NULL if the next filter does not exist.    
    if( NULL != pCurrentFilter ) {
        pCurrentFilter->AddRef();
    }

    return pCurrentFilter;
}

/******************************************************************************
    CEnumCachedFilters's Private Functions
******************************************************************************/
HRESULT CEnumCachedFilters::TakeFilterCacheStateSnapShot( IGraphConfig* pFilterCache )
{
    // CGenericList allocates space for 10 filters.  The list may expand 
    // if more filters are added.
    const DWORD DEFAULT_CACHED_FILTERS_LIST_SIZE = 10;

    m_pCachedFiltersList = new CGenericList<IBaseFilter>( NAME("Enum Cached Filters"), DEFAULT_CACHED_FILTERS_LIST_SIZE );
    if( NULL == m_pCachedFiltersList ) {
        return E_OUTOFMEMORY;
    }

    IEnumFilters* pCachedFiltersEnum;

    HRESULT hr = pFilterCache->EnumCacheFilter( &pCachedFiltersEnum );
    if( FAILED( hr ) ) {
        return hr;
    }

    POSITION posNewFilter;
    IBaseFilter* aNextCachedFilter[1];

    do
    {
        hr = pCachedFiltersEnum->Next( 1, aNextCachedFilter, NULL );
        if( FAILED( hr ) ) {
            pCachedFiltersEnum->Release();
            return hr;
        }

        // IEnumFilters::Next() only returns two success values: S_OK and S_FALSE.
        ASSERT( (S_OK == hr) || (S_FALSE == hr) );

        if( S_OK == hr ) {
            posNewFilter = m_pCachedFiltersList->AddTail( aNextCachedFilter[0] );
            if( NULL == posNewFilter ) {
                aNextCachedFilter[0]->Release();
                pCachedFiltersEnum->Release();
                return E_FAIL;
            }
        }
    }
    while( S_OK == hr );

    pCachedFiltersEnum->Release();

    m_posCurrentFilter = m_pCachedFiltersList->GetHeadPosition();

    return S_OK;    
}

void CEnumCachedFilters::DestoryCachedFiltersEnum( void )
{
    IBaseFilter* pCurrentFilter;

    if( NULL != m_pCachedFiltersList ) {

        do {

            pCurrentFilter = m_pCachedFiltersList->RemoveHead();

            // CGenericList::RemoveHead() returns NULL if an error occurs.
            if( NULL != pCurrentFilter ) {
                pCurrentFilter->Release();
            }

        } while( NULL != pCurrentFilter );

        delete m_pCachedFiltersList;
        m_pCachedFiltersList = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\efcache.h ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved

//
//
//   efcache.h
//       Definition of CEnumCacheFilter which implementents
//       the filter enumerator for the filter cache
//
#ifndef EnumCachedFilter_h
#define EnumCachedFilter_h

class CMsgMutex;
class CFilterCache;

class CEnumCachedFilter : public IEnumFilters, public CUnknown
{
public:
    CEnumCachedFilter( CFilterCache* pEnumeratedFilterCache, CMsgMutex* pcsFilterCache );
    ~CEnumCachedFilter();

    // IUnknown Interface
    DECLARE_IUNKNOWN

    // INonDelegatingUnknown Interface
    STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void** ppv );

    // IEnumFilters Interface
    STDMETHODIMP Next( ULONG cFilters, IBaseFilter** ppFilter, ULONG* pcFetched );
    STDMETHODIMP Skip( ULONG cFilters );
    STDMETHODIMP Reset( void );
    STDMETHODIMP Clone( IEnumFilters** ppCloanedEnum );

private:
    CEnumCachedFilter::CEnumCachedFilter
        (
        CFilterCache* pEnumeratedFilterCache,
        CMsgMutex* pcsFilterCache,
        POSITION posCurrentFilter,
        DWORD dwCurrentCacheVersion
        );
    void Init
        (
        CFilterCache* pEnumeratedFilterCache,
        CMsgMutex* pcsFilterCache,
        POSITION posCurrentFilter,
        DWORD dwCurrentCacheVersion
        );

    bool IsEnumOutOfSync( void );
    bool GetNextFilter( IBaseFilter** ppNextFilter );
    bool AdvanceCurrentPosition( void );

    CFilterCache* m_pEnumeratedFilterCache;
    DWORD m_dwEnumCacheVersion;
    POSITION m_posCurrentFilter;

    CMsgMutex* m_pcsFilterCache;
};

#endif // EnumCachedFilter_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\fgenum.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// fgenum.h
//

// A set of wrappers for IEnumXXX interfaces.

// Long term these could (should?) replace all the TRAVERSEXXX macros

// In general these are all constructed with the object supplying
// the IEnumXXX interface as a parameter to the constructor.
// You then call the object repeatedly (using operator()) to
// get each item in turn. When the enumerator is finished
// NULL will be returned. Taking CEnumPin as an example:
//
//   CEnumPin Next(pFilter);
//   IPin *pPin;
//
//   while ((BOOL) ( pPin = Next() )) {
//
//      //... Use pPin
//
//      pPin->Release();
//   }


#include <atlbase.h>


//
// CEnumPin
//
// wrapper for IEnumPins
// Can enumerate all pins, or just one direction (input or output)
class CEnumPin {

public:

    enum DirType {PINDIR_INPUT, PINDIR_OUTPUT, All};

    CEnumPin(IBaseFilter *pFilter, DirType Type = All, BOOL bDefaultRenderOnly = FALSE);
    ~CEnumPin();

    // the returned interface is addref'd
    IPin * operator() (void);

private:

    PIN_DIRECTION m_EnumDir;
    DirType       m_Type;
    BOOL          m_bDefaultRenderOnly;

    IEnumPins	 *m_pEnum;
};

//  Enumerate pins connected to a pin
class CEnumConnectedPins
{
public:
    CEnumConnectedPins(IPin *pPin, HRESULT *phr);
    ~CEnumConnectedPins();

    // the returned interface is addref'd
    IPin * operator() (void);

private:
    CComPtr<IEnumPins> m_pEnum;
    IPin             **m_ppPins;
    DWORD              m_dwPins;
    DWORD              m_dwCurrent;
    int                m_pindir;
};


//
// CEnumElements
//
// Wrapper for IEnumSTATSTG
// returns 'new' allocated STATSTG *'s which need the
// pwcsName element CoTaskMemFree'ing..,
class CEnumElements {
public:

    CEnumElements(IStorage *pStorage);

    ~CEnumElements() { m_pEnum->Release(); }

    STATSTG *operator() (void);

private:

    IEnumSTATSTG *m_pEnum;
};

class CEnumCachedFilters
{
public:
    CEnumCachedFilters( IGraphConfig* pFilterCache, HRESULT* phr );
    ~CEnumCachedFilters();

    IBaseFilter* operator()( void );

private:
    HRESULT TakeFilterCacheStateSnapShot( IGraphConfig* pFilterCache );
    void DestoryCachedFiltersEnum( void );

    POSITION m_posCurrentFilter;

    CGenericList<IBaseFilter>* m_pCachedFiltersList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\filcache.h ===
// Copyright (c) Microsoft Corporation 1996-1999. All Rights Reserved

//
//
//   filcache.h
//
//   Definitions for filter graph cache
//
#ifndef FilterCache_h
#define FilterCache_h

class CMsgMutex;

class CFilterCache
{
public:
    CFilterCache( CMsgMutex* pcsFilterCache, HRESULT* phr );
    ~CFilterCache();

    HRESULT AddFilterToCache( IBaseFilter* pFilter );
    HRESULT EnumCacheFilters( IEnumFilters** ppCurrentCachedFilters );
    HRESULT RemoveFilterFromCache( IBaseFilter* pFilter );

    ULONG GetCurrentVersion( void ) const;
    POSITION GetFirstPosition( void );
    bool GetNextFilterAndFilterPosition
        (
        IBaseFilter** ppNextFilter,
        POSITION posCurrent,
        POSITION* pposNext
        );
    bool GetNextFilterPosition( POSITION posCurrent, POSITION* pposNext );

private:
    HRESULT AddFilterToCacheInternal( IBaseFilter* pFilter );
    HRESULT EnumCacheFiltersInternal( IEnumFilters** ppCurrentCachedFilters );
    HRESULT RemoveFilterFromCacheInternal( IBaseFilter* pFilter );
    bool IsFilterInCache( IBaseFilter* pFilter );

    static HRESULT AreAllPinsUnconnected( IBaseFilter* pFilter );
    bool FindCachedFilter( IBaseFilter* pFilter, POSITION* pPosOfFilter );

    #ifdef DEBUG
    void CFilterCache::AssertValid( void );
    #endif // DEBUG

    // The cached filters are stored in this list.
    CGenericList<IBaseFilter>* m_pCachedFilterList;

    CMsgMutex* m_pcsFilterCache;

    ULONG m_ulFilterCacheVersion;
};

#endif // FilterCache_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\filcache.cpp ===
// Copyright (c) Microsoft Corporation 1996-1999. All Rights Reserved

//
//    filcache.cpp
//
//    Implementation of filter graph cache
//

#include <streams.h>
#include "FilCache.h"
#include "EFCache.h"
#include "MsgMutex.h"
#include "fgenum.h"

/******************************************************************************
    CFilterCache Interface
******************************************************************************/
CFilterCache::CFilterCache( CMsgMutex* pcsFilterCache, HRESULT* phr ) :
    m_pcsFilterCache(NULL),
    m_pCachedFilterList(NULL),
    m_ulFilterCacheVersion(0)
{
    // See the documentation for CGenericList::CGenericList() for more
    // information on these constants.
    const int nDEAFULT_LIST_SIZE = 10;

    m_pCachedFilterList = new CGenericList<IBaseFilter>( NAME("Filter Cache List"),
                                                         nDEAFULT_LIST_SIZE );

    if( NULL == m_pCachedFilterList )
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    m_pcsFilterCache = pcsFilterCache;
}

CFilterCache::~CFilterCache()
{
#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    if( NULL != m_pCachedFilterList )
    {
        IBaseFilter* pCurrentFilter;

        do
        {
            pCurrentFilter = m_pCachedFilterList->RemoveHead();

            // CGenericList::RemoveHead() returns NULL if the list is empty.
            if( NULL != pCurrentFilter )
            {
                pCurrentFilter->Release();
            }
        }
        while( NULL != pCurrentFilter );
    }

    delete m_pCachedFilterList;
}

bool CFilterCache::IsFilterInCache( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // It makes no sense to look for a NULL filter.
    ASSERT( NULL != pFilter );

    ValidateReadPtr( pFilter, sizeof(IBaseFilter*) );

    return FindCachedFilter( pFilter, NULL );
}

HRESULT CFilterCache::AddFilterToCache( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    HRESULT hr = AddFilterToCacheInternal( pFilter );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    return hr;
}

HRESULT CFilterCache::RemoveFilterFromCache( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    HRESULT hr = RemoveFilterFromCacheInternal( pFilter );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    return hr;
}

HRESULT CFilterCache::EnumCacheFilters( IEnumFilters** ppCurrentCachedFilters )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    HRESULT hr = EnumCacheFiltersInternal( ppCurrentCachedFilters );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    return hr;
}

HRESULT CFilterCache::AddFilterToCacheInternal( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // Make sure the object was successfully created.
    ASSERT( NULL != m_pCachedFilterList );

    ValidateReadPtr( pFilter, sizeof(IBaseFilter*) );

    if( NULL == pFilter )
    {
        return E_POINTER;
    }

    if( IsFilterInCache( pFilter ) )
    {
        return S_FALSE; // TBD - Define VFW_S_FILTER_ALREADY_CACHED
    }

    //  RobinSp - if it's not in a filter graph do we really need to check
    //  if any pins are connected?
    //  Also note that E_NOTIMPL is probably OK for EnumPins
    HRESULT hr = AreAllPinsUnconnected( pFilter );
    if( FAILED( hr ) )
    {
        return hr;
    }
    else if( S_FALSE == hr )
    {
        return E_FAIL; // TBD - Define VFW_E_CONNECTED
    }

    FILTER_STATE fsCurrent;

    //  Check if the filter is stopped - we don't want to wait here
    //  so set a 0 timeout.

    hr = pFilter->GetState( 0, &fsCurrent );
    if( FAILED( hr ) )
    {
        return hr;
    }

    POSITION posNewFilter = m_pCachedFilterList->AddHead( pFilter );

    // CGenericList::AddHead() returns NULL if an error occurs.
    if( NULL == posNewFilter )
    {
        return E_FAIL;
    }

    FILTER_INFO fiFilter;

    // Check to see if the filter was added to a filter graph.
    hr = pFilter->QueryFilterInfo( &fiFilter );
    if( FAILED( hr ) )
    {
        m_pCachedFilterList->Remove( posNewFilter );
        return hr;
    }

    bool bFilterRemovedFromGraph = false;

    // Make sure the filter is not released because we remove it from the filter graph.
    pFilter->AddRef();

    // Check to see if the filter is already in the filter graph.
    if( NULL != fiFilter.pGraph )
    {
        hr = fiFilter.pGraph->RemoveFilter( pFilter );
        if( FAILED( hr ) )
        {
            m_pCachedFilterList->Remove( posNewFilter );
            QueryFilterInfoReleaseGraph( fiFilter );
            pFilter->Release();
            return hr;
        }
        bFilterRemovedFromGraph = true;
    }

    if( State_Stopped != fsCurrent )
    {
        hr = pFilter->Stop();
        if( FAILED( hr ) )
        {
            m_pCachedFilterList->Remove( posNewFilter );
            if( bFilterRemovedFromGraph )
            {
                HRESULT hrAddFilter = fiFilter.pGraph->AddFilter( pFilter, fiFilter.achName );

                // If IFilterGraph::AddFilter() fails, then pFilter will not be a
                // member of the filter graph it was originally in.
                ASSERT( SUCCEEDED( hrAddFilter ) );
            }
            QueryFilterInfoReleaseGraph( fiFilter );
            pFilter->Release();
            return hr;
        }
    }

    QueryFilterInfoReleaseGraph( fiFilter );

    m_ulFilterCacheVersion++;

    return S_OK;
}

HRESULT CFilterCache::RemoveFilterFromCacheInternal( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // Make sure the object was successfully created.
    ASSERT( NULL != m_pCachedFilterList );

    // The filter cannot be removed from the cache because the
    // cahce is empty.
    ASSERT( m_pCachedFilterList->GetCount() > 0 );

    ValidateReadPtr( pFilter, sizeof(IBaseFilter*) );

    if( NULL == pFilter )
    {
        return E_POINTER;
    }

    POSITION posFilter;

    if( !FindCachedFilter( pFilter, &posFilter ) )
    {
        // The filter is not stored in the cache.  Therefore,
        // it can not be removed.
        ASSERT( false );
        return S_FALSE;
    }

    m_pCachedFilterList->Remove( posFilter );

    m_ulFilterCacheVersion++;

    return S_OK;
}

HRESULT CFilterCache::EnumCacheFiltersInternal( IEnumFilters** ppCurrentCachedFilters )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // Make sure the object was successfully created.
    ASSERT( NULL != m_pCachedFilterList );

    ValidateWritePtr( ppCurrentCachedFilters, sizeof(IEnumFilters*) );
    *ppCurrentCachedFilters = NULL;

    CEnumCachedFilter* pNewFilterCacheEnum;

    if( NULL == ppCurrentCachedFilters )
    {
        return E_POINTER;
    }

    pNewFilterCacheEnum = new CEnumCachedFilter( this, m_pcsFilterCache );
    if( NULL == pNewFilterCacheEnum )
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = ::GetInterface( pNewFilterCacheEnum, (void**)ppCurrentCachedFilters );

    ASSERT(SUCCEEDED(hr));

    return S_OK;
}

ULONG CFilterCache::GetCurrentVersion( void ) const
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    return m_ulFilterCacheVersion;
}

POSITION CFilterCache::GetFirstPosition( void )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    return m_pCachedFilterList->GetHeadPosition();
}

bool CFilterCache::GetNextFilterAndFilterPosition
    (
    IBaseFilter** ppNextFilter,
    POSITION posCurrent,
    POSITION* pposNext
    )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    POSITION posCurrentThenNext;
    IBaseFilter* pNextFilter;

    if( NULL == posCurrent )
    {
        return false;
    }

    posCurrentThenNext = posCurrent;
    pNextFilter = m_pCachedFilterList->GetNext( posCurrentThenNext /* IN and OUT */ );

    *ppNextFilter = pNextFilter;
    *pposNext = posCurrentThenNext;

    return true;
}

bool CFilterCache::GetNextFilterPosition( POSITION posCurrent, POSITION* pposNext )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    IBaseFilter* pUnusedFilter;

    return GetNextFilterAndFilterPosition( &pUnusedFilter, posCurrent, pposNext );
}

bool CFilterCache::FindCachedFilter( IBaseFilter* pFilter, POSITION* pPosOfFilter )
{
    // It makes no sense to look for a NULL filter.
    ASSERT( NULL != pFilter );

    if( NULL != pPosOfFilter )
    {
        *pPosOfFilter = NULL;
    }

    POSITION posFilter;
    POSITION posCurrentFilter;
    IBaseFilter* pCurrentFilter;

    posFilter = m_pCachedFilterList->GetHeadPosition();

    while( NULL != posFilter )
    {
        posCurrentFilter = posFilter;

        // CGenericList::GetNext() moves posFilter to the next object's
        // position.
        pCurrentFilter = m_pCachedFilterList->GetNext( posFilter );

        if( ::IsEqualObject( pCurrentFilter, pFilter ) )
        {
            if( NULL != pPosOfFilter )
            {
                *pPosOfFilter = posCurrentFilter;
            }
            return true;
        }
    }

    return false;
}

//
//  Check if all pins are unconnected
//
//  Returns:
//    S_FALSE if any pin is connected
//    S_OK    otherwise
//
HRESULT CFilterCache::AreAllPinsUnconnected( IBaseFilter* pFilter )
{
#if 1
    bool bConnected = false;
    CEnumPin Next(pFilter);
    IPin *pCurrentPin;
    for (; ; ) {
        pCurrentPin = Next();
        if (NULL == pCurrentPin) {
            break;
        }
        IPin *pConnected;
        HRESULT hr = pCurrentPin->ConnectedTo(&pConnected);
        if (SUCCEEDED(hr)) {
            bConnected = true;
            pConnected->Release();
            break;
        }
        pCurrentPin->Release();
    }
    return bConnected ? S_FALSE : S_OK;
#else
    IPin* pCurrentPin;
    IPin* pConnectedPin;
    HRESULT hrConnectedTo;
    IEnumPins* pFiltersPins;

    HRESULT hr = pFilter->EnumPins( &pFiltersPins );
    if( FAILED( hr ) )
    {
        return hr;
    }

    do
    {
        hr = pFiltersPins->Next( 1, &pCurrentPin, NULL );
        if( FAILED( hr ) )
        {
            pFiltersPins->Release();
            return hr;
        }

        // IEnumPins::Next() returns S_OK if it can get the next pin
        // from the enumeration.
        if( S_OK == hr )
        {
            hrConnectedTo = pCurrentPin->ConnectedTo( &pConnectedPin );
            if( FAILED( hrConnectedTo ) )
            {
                // Ignore the failure code.  IPin::ConnectedTo()'s documentation
                // states that pConnectedPin MUST be set to NULL if the pin is
                // not connected.
            }

            pCurrentPin->Release();
            pCurrentPin = NULL;

            // IPin::ConnectedTo() sets *ppPin to NULL if the pin in unconnected.
            if( NULL != pConnectedPin )
            {
                pFiltersPins->Release();
                pConnectedPin->Release();
                return S_FALSE;
            }
        }
    }
    while( S_OK == hr );

    pFiltersPins->Release();

    return S_OK;
#endif
}

#ifdef DEBUG
void CFilterCache::AssertValid( void )
{
    HRESULT hr;
    POSITION posCurrent;
    FILTER_STATE fsCurrentState;
    IBaseFilter* pCurrentFilter;
    FILTER_INFO fiCurrentFilterInfo;

    posCurrent = m_pCachedFilterList->GetHeadPosition();

    while( NULL != posCurrent )
    {
        pCurrentFilter = m_pCachedFilterList->GetNext( posCurrent );

        // Cached filters should NEVER be in the filter graph.
        hr = pCurrentFilter->QueryFilterInfo( &fiCurrentFilterInfo );
        if( SUCCEEDED( hr ) )
        {
            // A cached filter should NEVER be in any filter graph.
            ASSERT( NULL == fiCurrentFilterInfo.pGraph );

            QueryFilterInfoReleaseGraph( fiCurrentFilterInfo );
        }

        // While this is not a critical failure, it's cause should be investigated.
        ASSERT( SUCCEEDED( hr ) );

        // Cached filters should never be connected to any other filters.
        ASSERT( S_OK == AreAllPinsUnconnected( pCurrentFilter ) );

        hr = pCurrentFilter->GetState( INFINITE, &fsCurrentState );

        // Cached filter should never be in an intermediate state.  In addition,
        // they should be able to tell the cache what its current state is.
        ASSERT( SUCCEEDED( hr ) && (hr != VFW_S_STATE_INTERMEDIATE) && (hr != VFW_S_CANT_CUE) );

        // All cached filters should be stopped.
        ASSERT( State_Stopped == fsCurrentState );
    }
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\filgatl.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\filgraph.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __DefFilGraph
#define __DefFilGraph

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "MsgMutex.h"
#include "stats.h"
#include "statsif.h"

#if _MSC_VER >= 1100 || defined(NT_BUILD)
#include "sprov.h"
#include "urlmon.h"
#else
#include "datapath.h"
#endif
#include "rlist.h"
#include "distrib.h"
#include "dyngraph.h"
#include "sprov.h" // CServiceProvider
#include <skipfrm.h>

class CFGControl;
class CFilterChain;
class CEnumCachedFilters;

// push source list
typedef struct {
    IAMPushSource   *pips;
    IReferenceClock *pClock;
    ULONG            ulFlags;
} PushSourceElem;
typedef CGenericList<PushSourceElem> PushSourceList;

//  Do graph spy stuff

// #define DO_RUNNINGOBJECTTABLE

// Hungarian (sort of)
// member variables of the filter graph of type t are prefixed mFG_tName
// member variables of FilGenList  ............................mfgl_tName
// member variables of FilGen      ............................mfg_tName
// member variables of ConGenList  ............................mcgl_tName
// member variables of FilGen      ............................mcg_tName
// member variables inherited (typically) .....................m_tName
// This convention has not been observed by all authors, and there may still be
// some inconsistencies, but let's work towards uniformity!

#ifdef DEBUG
DEFINE_GUID(IID_ITestFilterGraph,0x69f09720L,0x8ec8,0x11ce,0xaa,0xb9,0x00,0x20,0xaf,0x0b,0x99,0xa3);


DECLARE_INTERFACE_(ITestFilterGraph, IUnknown)
{
    STDMETHOD(TestRandom) (THIS) PURE;
    STDMETHOD(TestSortList) (THIS) PURE;
    STDMETHOD(TestUpstreamOrder) (THIS) PURE;
    // STDMETHOD(TestTotallyRemove) (THIS) PURE;
};

class CTestFilterGraph;       // forwards
#endif // DEBUG

// Used to get callbacks into filters on the main application thread
DEFINE_GUID(IID_IAMMainThread,0x69f09721L,0x8ec8,0x11ce,0xaa,0xb9,0x00,0x20,0xaf,0x0b,0x99,0xa3);

DECLARE_INTERFACE_(IAMMainThread,IUnknown)
{
    STDMETHOD(PostCallBack) (THIS_ LPVOID pfn, LPVOID pvParam) PURE;
    STDMETHOD(IsMainThread) (THIS) PURE;
    STDMETHOD(GetMainThread) (THIS_ ULONG *pThreadId) PURE;
};

enum FRAME_STEP_TYPE 
{
    FST_NOT_STEPPING_THROUGH_FRAMES,
    FST_DONT_BLOCK_AFTER_SKIP,
    FST_BLOCK_AFTER_SKIP
};

enum FRAME_SKIP_NOTIFY 
{
    FSN_NOTIFY_FILTER_IF_FRAME_SKIP_CANCELED,
    FSN_DO_NOT_NOTIFY_FILTER_IF_FRAME_SKIP_CANCELED
};

// Abstract class implementing the IGraphBuilder and IEnumFilters interfaces.
class CEnumFilters;  // Forward declaration

// CumulativeHRESULT - this function can be used to aggregate the return
// codes that are received from the filters when a method is distributed.
// After a series of Accumulate()s m_hr will be:
// a) the first non-E_NOTIMPL failure code, if any;
// b) else the first non-S_OK success code, if any;
// c) E_NOINTERFACE if no Accumulates were made;
// d) E_NOTIMPL iff all Accumulated HRs are E_NOTIMPL
// e) else the first return code (S_OK by implication).

class CumulativeHRESULT
{
protected:
    HRESULT m_hr;
public:
    CumulativeHRESULT(HRESULT hr = E_NOINTERFACE) : m_hr(hr)
    {}

    void __fastcall Accumulate( HRESULT );

    operator HRESULT() { return m_hr; }
};

STDAPI CoCreateFilter(const CLSID *pclsid, IBaseFilter **ppFilter);

//==========================================================================
//==========================================================================
// CFilterGraph class.
//==========================================================================
//==========================================================================

class CFilterGraph : public IFilterGraph2
                   , public IGraphVersion
                   , public IPersistStream
#ifdef THROTTLE
                   , public IQualityControl
#endif // IQualityControl
                   , public IObjectWithSite
                   , public IAMMainThread
                   , public IAMOpenProgress
                   , public IAMGraphStreams
                   , public IVideoFrameStep
                   , public CServiceProvider				// IServiceProvider, IRegisterServiceProvider
                   , public CBaseFilter
{
        friend class CEnumFilters;
        friend class CTestFilterGraph;
        friend class CFGControl;
        friend class CGraphConfig;

    public:
        DECLARE_IUNKNOWN

    private:
        CFGControl * mFG_pFGC;
#ifdef DEBUG
        CTestFilterGraph * mFG_Test;
#endif

    public:
        CMsgMutex *GetCritSec() { return &m_CritSec; };
        CMsgMutex m_CritSec;

        // If SetSyncSource(NULL) has been called explicitly then we must
        // avoid setting a default sync source
        // note that we also need this to be accessible from fgctl which uses it to "unset" the graph clock
        BOOL mFG_bNoSync;

        //=========================================================================
        // FilGen
        // What we know ("the gen") about the filters in the graph.
        // The graph has a list of these.  See below.
        // Note that this is a thin, public class.  Almost just a glorified struct
        //=========================================================================

// added_manually - distinguish filters Intelligent Connect picked up
// from those added external code. !!! persist this bit?
//
#define FILGEN_ADDED_MANUALLY       0x8000

// filter added while graph was running and hasn't been run()
#define FILGEN_ADDED_RUNNING        0x4000

// IGraphConfig::Reconnect() searches for a pin to reconnect to if the
// caller only specifies one pin.  For example, if the caller
// only specifies the input pin, Reconnect() searches for an output pin
// to reconnect to.  Reconnect() stops searching if it encounters a
// filter with the FILGEN_ADDED_MANUALLY flag set and the
// FILGEN_FILTER_REMOVEABLE flag is not set.  Reconnect()
// always continues to search if the FILGEN_FILTER_REMOVEABLE flag is set.
#define FILGEN_FILTER_REMOVEABLE    0x2000

        class FilGen {
            public:
                CComPtr<IBaseFilter> pFilter;  // The interface to the filter
                LPWSTR    pName;        // Its name in this graph
                                        // Caching it here makes FindFilterByName much easier
                int       nPersist;     // Its number (for the persistent graph)
                int       Rank;         // How far from the rendering end of chain
                DWORD     dwFlags;

            public:
                FilGen(IBaseFilter *pF, DWORD dwFlags);
                ~FilGen();
        }; //Filgen

        // nPersist and nPersistOffset
        // We obviously can't store pointers in a saved graph, so filters are
        // identified by an integer (nPersist) which is broadly their position
        // in the list of FilGen.  If we load a file and then decide to merge
        // in another file, the nPersist numbers in the second file will be
        // already in use, so we find the largest value in use and offset all
        // the nPersist numbers in the new file by this much when we read them in.


        //=========================================================================
        // CFilGenList
        //
        // This list is normally kept in upstream order (renderers first).
        // To help this along, as the graph normally grows downstream we add to
        // new filters to the head of the list.  We sort it when it looks like
        // the sorting is going to matter, not after every operation, but we
        // bump the version number every time we do anything significant.
        // The ordering of the list controls the order in which operations (such
        // as Stop) are distributed to the filters - i.e. the head will be a
        // renderer, the tail will be a source.  This is a partial ordering in
        // the mathematical sense.
        //=========================================================================

        class CFilGenList : public CGenericList<FilGen>
        {
            private:
                CFilterGraph *mfgl_pGraph;
            public:

                CFilGenList(TCHAR *pName, CFilterGraph * pGr)
                    : CGenericList<FilGen>(pName)
                    , mfgl_pGraph(pGr)
                    {}
                ~CFilGenList() {}

                // IBaseFilter Enumerator (see fgenum.h for general comments)

                class CEnumFilters {
                    // Use it like this:
                    //     CFilGenList::CEnumFilters NextOne(mFG_FilGenList);
                    //     while ((BOOL) (pf = NextOne())) {
                    //         etc
                    //     }
                    //
                    public:
                        CEnumFilters(CFilGenList& fgl)
                            { m_pfgl = &fgl; m_pos = fgl.GetHeadPosition(); }
                        ~CEnumFilters() {}

                        IBaseFilter *operator++ (void);

                    private:
                        CFilGenList *m_pfgl;
                        POSITION    m_pos;
                };

                // utilities to find the thing in the list:
                int FilterNumber(IBaseFilter * pF);
                FilGen *GetByPersistNumber(int n);
                FilGen *GetByFilter(IUnknown *pFilter);


        }; // CFilGenList

        void SetInternalFilterFlags( IBaseFilter* pFilter, DWORD dwFlags );
        DWORD GetInternalFilterFlags( IBaseFilter* pFilter );

        #ifdef DEBUG
        static bool IsValidInternalFilterFlags( DWORD dwFlags );
        #endif // DEBUG

        //========================================================================
        // ConGen
        // A description of a connection that has come from a saved graph
        // but was not able to be made at that time (e.g. because what was
        // saved was only a partial graph).  Pins are described as ids
        // rather than IPin* because the pins might not even exist (once
        // again Robin's splitter comes to mind) as some filters do not
        // expose their pins unless the filter is in just the right state.
        // It's possible to construct graphs that can be saved,
        // but which then won't load, (hint: add scaffolding;
        // build part you want to save; delete scaffolding; save).
        // Such graphs "ought to be valid" (in some sense).
        // To allow them, we keep a list of these outstanding connections
        // that didn't work when we loaded.
        // We try to complete these whenever we get a chance.
        //     (After any Connect, ConnectDirect, before Pause).
        // We do not purge the list on RemoveFilterInternal (which might be logical)
        // but we do purge from the list any reference to a missing filter when
        // we attempt the deferred connections.
        //
        // If the list still has outstanding items then Pause etc. must
        // give some sort of "not totally successful" return code.
        //========================================================================

        class ConGen {
            public:
                // no extra addrefs for these IBaseFilter*s.
                IBaseFilter * pfFrom;   // The interface to the FROM FILTER
                IBaseFilter * pfTo;     // The interface to the TO FILTER

                LPWSTR    piFrom;   // The id of the FROM pin
                LPWSTR    piTo;     // The id of the TO pin

                CMediaType mt;      // the media type of the connection

                ConGen()
                    : pfFrom(NULL)
                    , pfTo(NULL)
                    , piFrom(NULL)
                    , piTo(NULL)
                {};
                ~ConGen()
                {
                    if (piFrom) delete[] piFrom;
                    if (piTo) delete[] piTo;
                };
        };


        class CConGenList : public CGenericList<ConGen>
        {
            public:

                CConGenList(TCHAR *pName)
                    : CGenericList<ConGen>(pName)
                    {}
                ~CConGenList() {}
        }; // CConGenList


        // The complete topology of the filtergraph can be worked out by
        // EnumFilters to get all the filters
        // EnumPins to get the pins on a filter in the list
        // QueryConnection to get a ConnectionInfo with the peer in it
        // QueryPinInfo to get a PIN_INFO with the other IBaseFilter in it.


        // RunningStartFilters is called when the graph has been
        // changed while running.
        HRESULT RunningStartFilters();

    private:

        // Constants in the stream:  (THESE ARE NOT LOCALISABLE!)
        static const WCHAR mFG_FiltersString[];
        static const WCHAR mFG_FiltersStringX[];
        static const WCHAR mFG_ConnectionsString[];
        static const WCHAR mFG_ConnectionsStringX[];
        static const OLECHAR mFG_StreamName[];


        //=========================================================================
        // The member variables
        //=========================================================================

        CFilGenList mFG_FilGenList;  // list of filter objects in the filtergraph
        CConGenList mFG_ConGenList;  // list of connections that didn't load
        CReconnectList mFG_RList;    // list of pending reconnections
        // There is no explicit code to free the contents of mFG_RList.  The RList
        // is only non-empty during a connect or Render type of operation.

        // VERSIONs and DIRT
        // In order to traverse a list of filters quickly, we don't want to
        // go digging in the registry or interrogating the filters all the time
        // (if only because it expands the volume of code by a factor of four
        // or so checking the return codes all the time).
        // Therefore we want to keep here the
        // information on what filters we have in the graph and how they are
        // connected together.  It is only safe to perform state changes on filters
        // working from downstream to upstream.  Therefore the list is kept
        // sorted in that order (actually it's a partial ordering).  To avoid
        // excessive sorting, we only bother to sort it when we need to.
        // We increment the version number whenever a significant change occurs
        // and we record the last version number that was sorted.
        // A significant change is
        // 1. Something that alters the sort order (Connect - nothing else)
        // 2. Something that would break the enumerator (RemoveFilter, because
        //    it might leave it pointing at an object that had gone away).
        // 3. Something that might give a strange enumeration (AddFilter, etc.)
        //    (We don't need to break the enum, but it seems kinder).
        // External functions increment the version, internal ones do not because
        // Incrementing it in mid render causes sorting in mid-render.  Not good.
        // So the version is incremented by:
        // 1. Connect, ConnectDirect, Render, RenderFile,
        // 2. RemoveFilter,
        // 3. AddFilter, AddSourceFilter
        //
        // the IGraphVersion interface makes this version number
        // visible externally to eg plug-in distributors or
        // apps like graphedt
        //
        // The dirty flag indicates that changes have happened since the graph was
        // saved.  The graph starts clean and the dirty flag is set by lowest level
        // internal functions.
        //     ConnectDirectInternal,

        int mFG_iSortVersion; // version number when the list was sorted


        // you must call mFG_Distributor.NotifyGraphChange whenever version
        // is changed. You must not be holding the filtergraph
        // lock when you do the call.
        int mFG_iVersion;     // Version number, ++ whenever Add or Remove filter
                              // or alter connections.  See CEnumFilters.
                              // See VERSION comment above.
        // If mFG_iVersion==mFG_iSortVersion then the graph is sorted.

        BOOL mFG_bDirty;             // Changes made since last save
                                     // (Add, Remove Connect, Disconnect)
                                     // There could also be filter changes underneath.



        // Presentation time == base + stream time.
        // The base time is therefore the time when the zeroth sample
        // is to be rendered.

        CRefTime mFG_tBase;     // Stopped => 0, else must be valid.

        // When we pause, the stream time stops but real time goes on.
        // Therefore the time when the zeroth sample would have been
        // rendered moves.  So we need to know when we paused so that
        // we can reset tBase when we start Running.

        CRefTime mFG_tPausedAt; // time when we paused, 0 if Stopped

        // mapper unknown for aggregation
        IUnknown * mFG_pMapperUnk;

        // if this flag is TRUE the filter graph attempts to determine
        // a max latency for all graph streams and pass this value to
        // IAMPushSource filters to use as the offset in their timestamping
        BOOL mFG_bSyncUsingStreamOffset;
        REFERENCE_TIME mFG_rtMaxGraphLatency;

        int mFG_RecursionLevel;    // used to detect recursive calls.
        IPin *mFG_ppinRender;      // Some protection for bottomless Streambuilders

        HANDLE mFG_hfLog;                    // log file to trace intel actions.

        DWORD mFG_dwFilterNameCount;        // Used for name-mangling of filter names
        HRESULT InstallName(LPCWSTR pName, LPWSTR &pNewName);

        //=========================================================================
        // IAMMainThread support - get application thread callbacks
        //=========================================================================

        DWORD m_MainThreadId;
        HWND m_hwnd;

    public:
        //  IVideoFrameStep
        STDMETHODIMP Step(DWORD dwFrames, IUnknown *pStepObject);
        STDMETHODIMP CanStep(long bMultiple, IUnknown *pStepObject);
        STDMETHODIMP CancelStep();

        HRESULT SkipFrames(DWORD dwFramesToSkip, IUnknown *pStepObject, IFrameSkipResultCallback* pFSRCB);
        HRESULT CancelStepInternal(FRAME_SKIP_NOTIFY fNotifyFrameSkipCanceled);

        bool BlockAfterFrameSkip();
        bool DontBlockAfterFrameSkip();
        IFrameSkipResultCallback* GetIFrameSkipResultCallbackObject();

    private:
        //  Internal stuff
        IUnknown *GetFrameSteppingFilter(bool bMultiple);
        HRESULT CallThroughFrameStepPropertySet(IUnknown *punk,
                                            DWORD dwPropertyId,
                                            DWORD dwData);
        HRESULT StepInternal(DWORD dwFramesToSkip, IUnknown *pStepObject, IFrameSkipResultCallback* pFSRCB, FRAME_STEP_TYPE fst);
        bool FrameSkippingOperationInProgress();

        // Have the application thread call this entry point
        STDMETHODIMP PostCallBack(LPVOID pfn, LPVOID pvParam);

        // Is this current thread the application thread
        STDMETHOD(IsMainThread) (THIS)
        {
            if (GetCurrentThreadId() == m_MainThreadId)
                return S_OK;
            else return S_FALSE;
        };

        // Return the application thread identifier
        STDMETHOD(GetMainThread) (THIS_ ULONG *pThreadId)
        {
            CheckPointer(pThreadId,E_POINTER);
            *pThreadId = m_MainThreadId;
            return S_OK;
        };



    public:
        //=========================================================================
        // IPersist* support
        //=========================================================================
        // IPersistStream methods
        STDMETHODIMP IsDirty();
        STDMETHODIMP Load(LPSTREAM pStm);
        STDMETHODIMP Save(LPSTREAM pStm, BOOL fClearDirty);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize);
    private:
        HRESULT LoadInternal(LPSTREAM pStm);
        HRESULT LoadFilters(LPSTREAM pStm, int nPersistOffset);
        HRESULT LoadFilter(LPSTREAM pStm, int nPersistOffset);
        HRESULT ReadMediaType(LPSTREAM pStm, CMediaType &mt);
        HRESULT LoadConnection(LPSTREAM pStm, int nPersistOffset);
        HRESULT LoadConnections(LPSTREAM pStm, int nPersistOffset);
        HRESULT LoadClock(LPSTREAM pStm, int nPersistOffset);
        HRESULT MakeConnection(ConGen * pcg);
        HRESULT SaveFilterPrivateData
            (LPSTREAM pStm, IPersistStream* pips, BOOL fClearDirty);
        HRESULT SaveFilters(LPSTREAM pStm, BOOL fClearDirty);
        HRESULT WritePinId(LPSTREAM pStm, IPin * ppin);
        HRESULT SaveConnection( LPSTREAM pStm
                              , int nFilter1, IPin *pp1
                              , int nFilter2, IPin *pp2
                              , CMediaType & cmt
                              );
        HRESULT SaveConnections(LPSTREAM pStm);
        HRESULT SaveClock(LPSTREAM pStm);
        int FindPersistOffset();
        HRESULT GetMaxConnectionsSize(int &cbSize);
        HRESULT RemoveDeferredList(void);

#ifdef DO_RUNNINGOBJECTTABLE
        void AddToROT();
#if 0
        //  IExternalConnection
        STDMETHODIMP_(DWORD) AddConnection(DWORD extconn, DWORD Res)
        {
            return 1;
        }
        STDMETHODIMP_(DWORD) ReleaseConnection(DWORD extconn, DWORD Res,
                                               BOOL fLastReleaseCloses)

        {
            return 0;
        }
#endif
#endif // DO_RUNNINGOBJECTTABLE

        //  Create a filter on the application's thread so that
        //  The filter can create windows etc there
        HRESULT CreateFilter(const CLSID *pclsid, IBaseFilter **ppFilter);
        HRESULT CreateFilter(IMoniker *pMoniker, IBaseFilter **ppFilter);
        // !!! replace CreateFilter?
        HRESULT CreateFilterAndNotify(IMoniker *pMoniker, IBaseFilter **ppFilter);

        HRESULT CreateFilterHelper(
            const struct AwmCreateFilterArg *pArg,
            IBaseFilter **ppFilter);

        //  Return code for CreateFilter
        volatile HRESULT m_CreateReturn;

        CAMEvent m_evDone;

    public:
        void OnCreateFilter(const AwmCreateFilterArg *pArg, IBaseFilter **ppFilter);
        void OnDeleteSpareList(WPARAM wParam);

#ifdef THROTTLE
        // IQualityControl stuff
        STDMETHODIMP SetSink(IQualityControl * piqc)
            // This interface is not distributed (leastways, not yet).
            { UNREFERENCED_PARAMETER(piqc); return E_NOTIMPL; }

        // Used to receive notifications, especially from the audio renderer
        STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
#endif // THROTTLE

    public:
        // --- IObjectWithSite methods
        // This interface is here so we can keep track of the context we're
        // living in.  In particular, we use this site object to get an
        // IBindHost interface which we can use to create monikers to help
        // interpret filenames that are passed in to us.
        STDMETHODIMP    SetSite(IUnknown *pUnkSite);

        STDMETHODIMP    GetSite(REFIID riid, void **ppvSite);

        IUnknown *mFG_punkSite;
        CComAggObject<CStatContainer> *mFG_Stats;

        IAMStats *Stats() {
            return &mFG_Stats->m_contained;
        }

    private:

#ifdef THROTTLE
        // Audio-video throttle stuff

        // We make a list of audio and video renderers for quality control purposes.
        // The lists are initially empty (class constructor does that), get filled
        // when the graph is sorted (must happen before Run).
        // Entries are removed when the filter leaves the graph (must happen before
        // graph destruction).
        // We already have a ref-count on every filter, so they can't go away.
        // But we need their IQualityControl interface, and this
        // could be in some separate object, so we hold ref counts.
        /// For Audio Renderers we really want to not only pass information to video
        /// renderers, but to pass it upstream too (there might be a decoder or
        /// source filter that could do something), but experience says that
        /// this deadlocks and this problem will not be solved for Quartz 1.0
        /// Worse - it should really be a list of upstream pins
        /// for each  filter as it could presumably be some sort of mixing renderer.
        /// In that case we really wish that the quality sink stuff was defined per
        /// pin rather than per filter as we are in architectural difficulties that
        /// will not be fixed for Quartz version 1.

        // Note that to destroy the Audio render structure we must
        // 1. Release the IQualityControl
        // 2. delete the structure
        // 3. Remove the list element. (As Virgil never wrote: "Nolite collander")

        typedef struct {
            IBaseFilter * pf;              // no ref-count held
            IQualityControl * piqc;        // ref count held
        } AudioRenderer;

        CGenericList<AudioRenderer> mFG_AudioRenderers;
        CGenericList<IQualityControl> mFG_VideoRenderers;  // ref count held

        HRESULT TellVideoRenderers(Quality q);
        HRESULT FindPinAVType(IPin* pPin, BOOL &bAudio, BOOL &bVideo);
        HRESULT FindRenderers();
        HRESULT ClearRendererLists();
#endif // THROTTLE

    public:
        // IPersist method
        STDMETHODIMP GetClassID(CLSID * pclsid)
            {   CheckPointer(pclsid, E_POINTER);
                *pclsid = CLSID_FilterGraph;
                return NOERROR;
            }

        // Utility
        HRESULT RemoveAllFilters(void);

        //=====================================================================
        // Utility functions
        //=====================================================================

        HRESULT RemoveAllConnections2( IBaseFilter * pFilter );
    private:
        FilGen * RemovePointer(CFilGenList &cfgl, IBaseFilter * pFilter);
        void Log(int id,...);
        WCHAR *LoggingGetDisplayName(WCHAR szDisplayName[MAX_PATH] , IMoniker *pMon);

    public:  // used by FilGen constructor during Load.
        HRESULT AddFilterInternal( IBaseFilter * pFilter, LPCWSTR pName, bool fIntelligent );

        // used by CConGenList::Restore during Load
        HRESULT ConnectDirectInternal(
                    IPin * ppinOut,
                    IPin * ppinIn,
                    const AM_MEDIA_TYPE * pmt
                    );

    private:
        HRESULT RemoveFilterInternal( IBaseFilter * pFilter, DWORD RemoveFlags = 0 );

        HRESULT AddSourceFilterInternal( LPCWSTR lpcwstrFileName
                                       , LPCWSTR lpcwstrFilterName
                                       , IBaseFilter **ppFilter
                                       , BOOL &bGuess
                                       );

        //=====================================================================
        // Filter sorting stuff - see sort.cpp
        //=====================================================================

        void SortList( CFilGenList & cfgl );
        HRESULT NumberNodes(CFilGenList &cfgl, CFilGenList &cfglRoots);
        HRESULT NumberNodesFrom( CFilGenList &cfgAll, FilGen * pfg, int cRank);
        void ClearRanks( CFilGenList &cfgl);
        HRESULT MergeRootNodes(CFilGenList &cfglRoots, CFilGenList &cfgl);
        HRESULT MergeRootsFrom( CFilGenList &cfgAll, CFilGenList &cfglRoots, FilGen * pfg);
        void Merge( CFilGenList &cfgl, FilGen * pfg );

        // sort the filter graph into an order such that downstream nodes are
        // always encountered before upstream nodes.  Subsequent EnumFilters
        // will retrieve them in that order.
        HRESULT UpstreamOrder();

        HRESULT AttemptDeferredConnections();


        //=====================================================================
        // Performance measurement stuff
        //=====================================================================
        // incidents
#ifdef PERF
        int mFG_PerfConnect;
        int mFG_PerfConnectDirect;
        int mFG_NextFilter;
        int mFG_idIntel;
        int mFG_idConnectFail;
#ifdef THROTTLE
        int mFG_idAudioVideoThrottle;
#endif // THROTTLE
#endif

        //=======================================================================
        // INTELLIGENT CONNECTION AND RENDERING - SEE INTEL.CPP
        //=======================================================================

        //------------------------------------------------------------------------
        // To iterate through all candidate filters, allocate a Filter,
        // set the initial State to F_ZERO, set the search fields
        // bInputNeeded..SubType and then call NextFilter repeatedly.
        // If Next returns a filter with State F_INFINITY then you are done
        // If you find a filter you like and want to stop, then call TidyFilter
        // to release enumerators etc.  AddRef the filter you found first.
        //------------------------------------------------------------------------

        BOOL mFG_bAborting;   // We are requested to stop ASAP.

    public:
        typedef enum {F_ZERO, F_LOADED, F_CACHED, F_REGISTRY, F_INFINITY} F_ENUM_STATE;

    private:
        class Filter {
        public:
            F_ENUM_STATE State;

                                         // Next fields not needed for loaded filters
            IMoniker *pMon;
            IEnumMoniker * pEm;          // Registry enumerator
            BOOL bInputNeeded;           // Need at least one input pin
            BOOL bOutputNeeded;          // Need at least one output pin
            BOOL bLoadNew;               // Load a new filter?
            GUID *pTypes;                // Types (major, sub) pairs
            DWORD cTypes;                // Number of types
            LPWSTR Name;                 // Name of filter (debug & logging only)

                                         // Next fields not needed unless filter is loaded
            IBaseFilter * pf;            // The filter (when loaded)
            IEnumFilters * pef;          // filter graph enumerator

            CEnumCachedFilters*          m_pNextCachedFilter;

            Filter();
            ~Filter();

            HRESULT AddToCache( IGraphConfig* pGraphConfig );
            void RemoveFromCache( IGraphConfig* pGraphConfig );

            void ReleaseFilter( void );
        };

        void NextFilter(Filter &F, DWORD dwFlags);
        HRESULT NextFilterHelper(Filter &F);

        //------------------------------------------------------------------------
        // Intelligent Connection hierarchy  - see Intel.cpp
        //------------------------------------------------------------------------

        HRESULT GetAMediaType( IPin * ppin
                             , CLSID & MajorType
                             , CLSID & SubType
                             );
        HRESULT GetMediaTypes(
            IPin * ppin,
            GUID **ppTypes,
            DWORD *pcTypes);
        HRESULT CompleteConnection
            ( IPin * ppinIn, const Filter& F, IPin * pPin, DWORD dwFlags, int iRecurse);
        HRESULT ConnectByFindingPin
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtConnection, const Filter& F, DWORD dwFlags, int iRecurse);
        HRESULT ConnectUsingFilter
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtConnection, Filter& F, DWORD dwFlags, int iRecurse);
        HRESULT ConnectViaIntermediate
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtConnection, DWORD dwFlags, int iRecurse);
        HRESULT ConnectRecursively
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtConnection, DWORD dwFlags, int iRecurse);

        public:
        HRESULT ConnectInternal
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtFirstConnection, DWORD dwFlags );
        private:

        static bool IsValidConnectFlags( DWORD dwConnectFlags );

        //------------------------------------------------------------------------
        // Backout and spares lists for filters - see Intel.cpp
        //
        // A wrinkle on intelligent rendering requires us to sometimes partially
        // succeed in order that we can do something on a machine that has no sound
        // card in it.  Every graph that we build is given a score (actually a
        // two part score) and we keep track of the Best So Far.  If by the end of
        // the rendering we have not succeeded in rendering the graph completely
        // then we build the Best So Far (by this time it is the Best Can Do).
        // This means that we are building a graph from a description made
        // previously, and this is the same problem as loading a pre-canned filter
        // graph.  The following structure therefore handles both the description
        // of a graph for IPersist purposes and the creation of a Best Can Do graph.
        // Actually at the moment the two sections of code are regrettably separate.
        //-----------------------------------------------------------------------

        // BACKOUT is for IStreamBuilder::Backout, other two obvious
        typedef enum { DISCONNECT, REMOVE, BACKOUT} VERB;

        typedef struct{

            VERB Verb;
            union {
               struct{
                  IBaseFilter *pfilter;    // for REMOVE and pre-existers
                  IMoniker    *pMon;
                  CLSID       clsid;      // for spares or BestGraph
                  LPWSTR      Name;       // for BestGraph (new/delete)

                  // This member is true if the filter was removed from the filter cache.
                  bool        fOriginallyInFilterCache;
               } f;
               struct {
                  IPin * ppin;          // for DISCONNECT
                  int nFilter1;         // for BestGraph
                  int nFilter2;         // for BestGraph

                  LPWSTR id1;           // for the BestGraph only. (CoTaskMem)
                  LPWSTR id2;           // for the BestGraph only.
               } c;
               struct {
                  IStreamBuilder * pisb;// for BACKOUT
                  BOOL bFoundByQI;      // TRUE if pisb was fond by QueryInterface
                  IPin * ppin;          //
                  int nFilter;          // for BestGraph only
                  LPWSTR id;            // for the BestGraph only.
               } b;
            } Object;

            bool FilterOriginallyCached( void ) const { return Object.f.fOriginallyInFilterCache; }

        } Action;

        // Handling of StreamBuilders and their refcounts:
        // It follows one of these patterns:
        // 1a. In RenderViaIntermediate:
        //         QueryInterface()                    CoCreateInstance
        //         Render             (fails)          Render
        //         Release                             Release
        // 1b. In RenderViaIntermediate:
        //         QueryInterface()                    CoCreateInstance
        //         Render             (succeeds)       Render
        //         Add to Acts ("backout") list        Add to Acts
        //         set bFoundByQI                      clear bFoundByQI
        //
        //     However created we now have one addreffed pisb on Acts
        //
        // 2.  That can possibly be followed by
        //     In CopySearchState:
        //         Copy representation (filter,pin)    Copy pisb
        //                                             AddRef
        //
        //     If pisb was obtained by CoCreateInstance, it's still live
        //     and addreffed and bFoundByQI is FALSE.  Otherwise we have
        //     released it and copied info as to how to get it back again.
        //
        // 3.  If the whole thing later fails either way we do
        //     In Backout:
        //         Backout                             Backout
        //         Release                             Release
        //         delete from Acts                    delete from Acts
        //
        // 4.  If we decide to build the best-can-do graph
        //     In BuildFromSearchState:
        //         QueryInterface()                    use pisb
        //         Render             (succeeds)       Render
        //         Release                             DO NOT Release
        //
        // 5.  If we kept the built graph and did not back anything out:
        //     In DeleteBackoutList:
        //         Release                             Release
        //         delete                              delete
        //
        // 6.  If we ever built a best-so-far list
        //      In FreeList:
        //                                             Release
        //         delete                              delete
        //
        //     And that gets rid of the ref count

        typedef CGenericList<Action> CActionList;

        // information needed to do Backout
        typedef struct {
            POSITION Pos;            // see CSearchState
            double StreamsToRender;  // see CSearchState
            double StreamsRendered;  // see CSearchState
            int nFilters;            // see CSearchState
        } snapshot;

        class CSearchState {
            public:

                CActionList GraphList;   // None of the filters on this will be
                                         // adreffed.  Some may be on Spares.

                double StreamsToRender;  // fraction of the original we're doing now.
                double StreamsRendered;  // Major part of the score for BestSoFar
                int nFilters;            // Minor part of the score for BestSoFar,
                                         // number of filters added for Render.
                int nInitialFilters;     // Num pre-existing filters from Initialise
                                         // BuildFromSearchState mustn't build these
            public:
                CSearchState()
                : GraphList(NAME("GraphList"))
                {   StreamsToRender = 1.0;
                    StreamsRendered = 0.0;
                    nFilters = 0;
                    nInitialFilters = 0;
                }


                // There is no destructor.
                // Just call FreeList to get rid of the stuff

                static BOOL IsBetter(CSearchState &A, CSearchState &B)
                { return (  A.StreamsRendered>B.StreamsRendered
                         || (  A.StreamsRendered==B.StreamsRendered
                            && A.nFilters < B.nFilters
                         )  );
                }
        };

        HRESULT AddRemoveActionToList( CSearchState* pActionsList, Filter* pFilter );

        void CopySearchState(CSearchState &To, CSearchState &From);
        void FreeList(CSearchState &css);
        IBaseFilter * SearchNumberToIFilter(CActionList &cal, int nFilter);
        int SearchIFilterToNumber(CActionList &cal, IBaseFilter *pf);
        HRESULT InitialiseSearchState(CSearchState &css);

        // Spare filters that we loaded, but they didn't work in that
        // context, so we keep them lying around in case they will work once
        // we've put an extra transform or two in.
        typedef struct{
            IBaseFilter* pfilter;
            CLSID    clsid;
            IMoniker *pMon;
        } Spare;

        typedef CGenericList<Spare> CSpareList;

        void TakeSnapshot(CSearchState &Acts, snapshot &s);

        HRESULT Backout( CSearchState &Acts
                            , CSpareList &Spares, snapshot Snapshot);
        HRESULT DeleteBackoutList( CActionList &Acts);
        HRESULT DeleteSpareList( CSpareList &Spares);
        IBaseFilter * GetFilterFromSpares(IMoniker *pMon , CSpareList &Spares);
        HRESULT GetFilter(IMoniker *pMon, CSpareList &Spares, IBaseFilter **ppf);
        HRESULT DumpSearchState(CSearchState &css);
        HRESULT BuildFromSearchState
            (IPin * pPin, CSearchState &css, CSpareList &Spares);
        static HRESULT FindOutputPins2
        ( IPin* ppinIn, IPin * *appinOut, const UINT nSlots, int &nPinOut,
          bool fAllOutputPins);

        static HRESULT FindOutputPinsHelper
        ( IPin* ppinIn, IPin ***pappinOut, const int nSlots, int &nPinOut,
          bool fAllOutputPins);

        BOOL IsUpstreamOf( IPin * ppinUp, IPin* ppinDown );

        //------------------------------------------------------------------------
        // Intelligent Rendering hierarchy  - see Intel.cpp
        //------------------------------------------------------------------------

        HRESULT CompleteRendering
            ( IBaseFilter *pF, IPin * pPin, int iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);
        HRESULT RenderByFindingPin
            ( IPin * ppinOut, IBaseFilter *pF, int iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);
        HRESULT RenderUsingFilter
            ( IPin * ppinOut, Filter& F, int iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);
        HRESULT RenderViaIntermediate
            ( IPin * ppinOut, int    iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);
        HRESULT RenderRecursively
            ( IPin * ppinOut, int    iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);

        //========================================================================


#ifdef DEBUG
        void DbgDump();
        CLSID DbgExpensiveGetClsid(const Filter &F);
#else
        #define DbgDump()
#endif


        // Constructor is private.  You don't "new" it you CoCreateInstance it.
        CFilterGraph( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr );
        ~CFilterGraph();

    public:
        //========================================================================
        // Access functions to avoid having friends.
        //========================================================================

        int GetVersion() { return mFG_iVersion; }

        // increment version, probably inside lock
        void IncVersion() { ++mFG_iVersion; }

        // notify change in version number, must be outside lock
        void NotifyChange();

        CRefTime GetBaseTime() { return mFG_tBase; }

        CRefTime GetPauseTime() { return mFG_tPausedAt; }

        // Use when changing the start time in pause mode to put the stream time
        // offset back to ensure that the first sample played from the
        // new position is played at run time
        void ResetBaseTime() { mFG_tBase = mFG_tPausedAt; }

        FILTER_STATE GetStateInternal( void );
        REFERENCE_TIME GetStartTimeInternal( void );

        //========================================================================
        // The public methods (IFilterGraph, IGraphBuilder)
        //========================================================================

        static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

        // Stuff to create ourselves on a thread.
        static void InitClass(BOOL, const CLSID *);
        static CUnknown *CreateThreadedInstance(LPUNKNOWN pUnk, HRESULT *phr);

        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

        //--------------------------------------------------------------------------
        // Low level functions
        //--------------------------------------------------------------------------

        // Add a filter to the graph and name it with *pName.
        // The name is allowed to be NULL,
        // If the name is not NULL and not unique, The request will fail.
        // The Filter graph will call the JoinFilterGraph
        // member function of the filter to inform it.
        // This must be called before attempting Connect, ConnectDirect, Render
        // Pause, Run, Stopped etc.

        HRESULT CheckFilterInGraph(IBaseFilter *const pFilter) const;
        HRESULT CheckPinInGraph(IPin *const pPin) const;

        STDMETHODIMP AddFilter
            ( IBaseFilter * pFilter,
              LPCWSTR pName
            );


        // Remove a filter from the graph. The filter graph implementation
        // will inform the filter that it is being removed.

        STDMETHODIMP RemoveFilter
            ( IBaseFilter * pFilter
            );


        // Set *ppEnum to be an enumerator for all filters in the graph.

        STDMETHODIMP EnumFilters
            ( IEnumFilters **ppEnum
            );


        // Set *ppFilter to be the filter which was added with the name *pName
        // Will fail and set *ppFilter to NULL if the name is not in this graph.

        STDMETHODIMP FindFilterByName
            ( LPCWSTR pName,
              IBaseFilter ** ppFilter
            );


        // Connect these two pins directly (i.e. without intervening filters)

        STDMETHODIMP ConnectDirect
            ( IPin * ppinOut,    // the output pin
              IPin * ppinIn,      // the input pin
              const AM_MEDIA_TYPE* pmt
            );


        // On a separate thread (which will not hold any relevant locks)
        // Break the connection that this pin has and reconnect it to
        // the same other pin.

        STDMETHODIMP Reconnect
            ( IPin * ppin        // the pin to disconnect and reconnect
            );

        STDMETHODIMP ReconnectEx
            ( IPin * ppin,       // the pin to disconnect and reconnect
              AM_MEDIA_TYPE const *pmt
            );


        //--------------------------------------------------------------------------
        // intelligent connectivity
        //--------------------------------------------------------------------------

        // Disconnect this pin, if connected.  Successful no-op if not connected.

        STDMETHODIMP Disconnect
            ( IPin * ppin
            );


        // Connect these two pins directly or indirectly, using transform filters
        // if necessary.

        STDMETHODIMP Connect
            ( IPin * ppinOut,    // the output pin
              IPin * ppinIn      // the input pin
            );


        // Connect this output pin directly or indirectly, using transform filters
        // if necessary to something that will render it.

        STDMETHODIMP Render
            ( IPin * ppinOut     // the output pin
            );


        // Build a filter graph that will render this file using this play list
        // If lpwstrPlayList is NULL then it will use the default play list
        // which will typically render the whole file.

        STDMETHODIMP RenderFile
            ( LPCWSTR lpcwstrFile,
              LPCWSTR lpcwstrPlayList
            );

        // Add to the filter graph a source filter for this file.  This would
        // be the same source filter that would be added by calling RenderFile.
        // This call permits you to get then have more control over building
        // the rest of the graph, e.g. AddFilter(<a renderer of your choice>)
        // and then Connect the two.
        STDMETHODIMP AddSourceFilter
            ( LPCWSTR lpcwstrFileName,     // name of file for source
              LPCWSTR lpcwstrFilterName,   // Add the filter as this name
              IBaseFilter **ppFilter       // resulting IBaseFilter* "handle"
                                           // of the filter added.
            );

        // Add a source filter for the given moniker to the graph
        // We first try BindToStorage and if this fails we try
        // BindToObject
        STDMETHODIMP AddSourceFilterForMoniker
            ( IMoniker *pMoniker,          // Moniker to load
              IBindCtx *pCtx,              // Bind context
              LPCWSTR lpcwstrFilterName,   // Add the filter as this name
              IBaseFilter **ppFilter       // resulting IBaseFilter* "handle"
                                           // of the filter added.
            );

        // Attempt a RenderFile without adding any renderers
        STDMETHODIMP RenderEx(
             /* [in] */ IPin *pPinOut,         // Pin to render
             /* [in] */ DWORD dwFlags,         // flags
             /* [in out] */ DWORD * pvContext   // Unused - set to NULL
        );

        // If this call is made then trace information will be written to the
        // file showing the actions taken in attempting to perform an operation.
        STDMETHODIMP SetLogFile(DWORD_PTR hFile)
                {
            if (hFile==0)
                mFG_hfLog = INVALID_HANDLE_VALUE;
            else
                mFG_hfLog = (HANDLE) hFile;
            return NOERROR;
                }


        // Request that the graph builder should return as soon as possible from
        // its current task.
        // Note that it is possible fot the following to occur in the following
        // sequence:
        //     Operation begins; Abort is requested; Operation completes normally.
        // This would be normal whenever the quickest way to finish an operation
        // was to simply continue to the end.
        STDMETHODIMP Abort();

        // Return S_OK if the curent operation is to continue,
        // return S_FALSE if the current operation is to be aborted.
        // This method can be called as a callback from a filter which is doing
        // some operation at the request of the graph.
        STDMETHODIMP ShouldOperationContinue();


        //--------------------------------------------------------------------------
        // Whole graph functions
        //--------------------------------------------------------------------------

        // Once a graph is built, it can behave as a (composite) filter.
        // To control this filter, QueryInterface for IMediaFilter.

        STDMETHODIMP SetDefaultSyncSource(void);

        //--------------------------------------------------------------------------
        // Methods being overridden from CBaseFilter
        //--------------------------------------------------------------------------

        STDMETHODIMP Stop();
        STDMETHODIMP Pause();

        // override this to handle async state change completion
        STDMETHODIMP GetState(DWORD dwTimeout, FILTER_STATE * pState);

        // Set all the filters in the graph to Run from their current position.
        //
        // tStart is the base time i.e. (presentation time - stream time) which is
        // the reference time for the zeroth sample to be rendered.
        //
        // The filter graph remembers the base time.  Supplying a base time of
        // zero means "continue with the one you knew".
        //
        // e.g. at reference ("wall clock") time Tr we wish to start running
        // from a point in the Ts after the start.  In that case we should
        // seek to the point Ts and Pause then Run(Ts-Ts).
        STDMETHODIMP Run(REFERENCE_TIME tStart);

        int GetPinCount(void) { return 0;};
        CBasePin *GetPin(int n) {UNREFERENCED_PARAMETER(n);return NULL;};

        //  Get tStart
        STDMETHODIMP SetSyncSource( IReferenceClock * pirc );
        STDMETHODIMP GetSyncSource( IReferenceClock ** pirc );

        STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin)
            {UNREFERENCED_PARAMETER(Id); *ppPin = NULL; return E_NOTIMPL;}

        // IPin method
        // STDMETHODIMP QueryId(LPWSTR *Id)
        //    { Id = NULL; return E_NOTIMPL;}

        //
        // --- IGraphVersion methods ---
        //
        // return the version of the graph so that clients know
        // that they don't need to re-enumerate
        STDMETHODIMP QueryVersion(LONG * pVersion)
        {
            CheckPointer(pVersion, E_POINTER);
            *pVersion = (LONG) mFG_iVersion;
            return S_OK;
        };

        // --- IAMOpenProgress ---
        STDMETHODIMP QueryProgress(LONGLONG* pllTotal, LONGLONG* pllCurrent);
    STDMETHODIMP AbortOperation();

#ifdef DO_RUNNINGOBJECTTABLE
    // Registration in the running object table
    DWORD m_dwObjectRegistration;
#endif

    private:
#ifdef DEBUG
        //==========================================================================
        // Internal functions for testing only
        //==========================================================================

        BOOL CheckList( CFilGenList &cfgl );
        void RandomList( CFilGenList &cfgl );
        void RandomRank( CFilGenList &cfgl );
#endif // DEBUG


    // ========================================================================
    // internal helper: try loading a .grf file
    // ========================================================================
        STDMETHODIMP RenderFileTryStg
            ( LPCWSTR lpcwstrFile);

    //==========================================================================
    // IAMGraphStreams interface
    //==========================================================================
        STDMETHODIMP FindUpstreamInterface(
            IPin   *pPin,
            REFIID riid,
            void   **ppvInterface,
            DWORD  dwFlags );

        STDMETHODIMP SyncUsingStreamOffset( BOOL bUseStreamOffset );
        STDMETHODIMP SetMaxGraphLatency( REFERENCE_TIME rtMaxGraphLatency );

        HRESULT  SetMaxGraphLatencyOnPushSources( );
        HRESULT  BuildPushSourceList(PushSourceList & lstPushSource, BOOL bConnected, BOOL bGetClock);
        REFERENCE_TIME GetMaxStreamLatency(PushSourceList & lstPushSource);
        void     DeletePushSourceList(PushSourceList & lstPushSource);

    //==========================================================================
    // Plug-in distributor management
    //==========================================================================
        // this object manages plug-in distributors. See distrib.h for a
        // description.
        // If asked for an interface we don't support directly, such as
        // IBasicAudio, we ask this class to find a distributor that will
        // support it. The distributor talks to the filters in the graph
        // to do this. We also use the run, pause, stop and setsyncsource
        // methods to pass on state and clock changes to these distributors.
        CDistributorManager * mFG_pDistributor;

    // open progress notification
        // this is used in QueryProgress to ask the source filter for
        // progress info *during* a renderfile. To provide threadsafe
        // access to this without deadlocking we have a dedicated
        // critsec that is held only when accessing this member.
        CCritSec mFG_csOpenProgress;
        CGenericList<IAMOpenProgress> mFG_listOpenProgress;

    // cached BindCtx for BindToObject.
    LPBC m_lpBC;

    // determine the offset that IAMPushSource filters should use
    HRESULT SetStreamOffset( void );

    // Determine if adding renderers is allowed
    bool mFG_bNoNewRenderers;

    // Which object are we using to step
    // If != NULL we are stepping
    CComPtr<IUnknown> m_pVideoFrameSteppingObject;

    CComPtr<IFrameSkipResultCallback> m_pFSRCB;

    FRAME_STEP_TYPE m_fstCurrentOperation;

    // Support IMarshal
    CComPtr<IUnknown> m_pMarshaler;

    // Dynamic graph stuff
    CGraphConfig m_Config;
    CFilterChain* m_pFilterChain;

    protected:

    STDMETHODIMP RemoveFilterEx( IBaseFilter * pFilter, DWORD Flags = 0 );


public:
    HRESULT IsRenderer( IBaseFilter* pFilter );
    HRESULT UpdateEC_COMPLETEState( IBaseFilter* pRenderer, FILTER_STATE fsFilter );

};  // CFilterGraph


//  Helper
bool RenderPinByDefault(IPin *pPin);


#ifdef DEBUG
class CTestFilterGraph : public ITestFilterGraph, public CUnknown
{
    public:
        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
        CFilterGraph * m_pCFG;
        CTestFilterGraph( TCHAR *pName, CFilterGraph * pCFG, HRESULT *phr );

        STDMETHODIMP TestRandom();
        STDMETHODIMP TestSortList();
        STDMETHODIMP TestUpstreamOrder();
        int  Random(int Range);
        // STDMETHODIMP TestTotallyRemove(void);

};  // CTestFilterGraph
#endif // DEBUG





//==========================================================================
//==========================================================================
// CEnumFilters class.
// This enumerates filters in Upstream order.
// If the filter graph is updated during the enumeration the enumeration will
// fail.  Reset or get a new enumerator to fix it.
//==========================================================================
//==========================================================================

class CEnumFilters : public IEnumFilters,  // The interface we support
                     public CUnknown,      // A non delegating IUnknown
                     public CCritSec       // Provides object locking
{
    private:

        // It's possible that the list that we are traversing may change underneath us.
        // In that case we will fail the enumeration.
        // To do this a FilterGraph has a version number which is incremented
        // whenever a filter is added or removed.  If this changes then the
        // enumeration is sick and we fail it.  Reset or getting a new enumerator
        // will fix it.

        int mEF_iVersion;          // The version that we are enumerating.

        POSITION mEF_Pos;          // Cursor on mEF_pFilterGraph->mFG_FilGenList

        CFilterGraph * const mEF_pFilterGraph;   // The filter graph which owns us

    public:

        // Normal constructor that creates an enumerator set at the start
        CEnumFilters
            ( CFilterGraph *pFilterGraph
            );

    private:
        // Private constructor for use by clone
        CEnumFilters
            ( CFilterGraph *pFilterGraph,
              POSITION Pos,
              int iVersion
            );

    public:
        ~CEnumFilters();

        DECLARE_IUNKNOWN

        // Note that changes to the filter graph
        STDMETHODIMP Next
            ( ULONG cFilters,           // place this many filters...
              IBaseFilter ** ppFilter,  // ...in this array of IBaseFilter*
              ULONG * pcFetched         // actual count passed returned here
            );


        STDMETHODIMP Skip(ULONG cFilters);


        // Reset the enumerator to start again at the beginning.
        // Includes recovery from failure due to changing filter graph.
        STDMETHODIMP Reset(void);


        STDMETHODIMP Clone(IEnumFilters **ppEnum);


        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
};

BOOL ClsidFromText( CLSID & clsid, LPTSTR szClsid);

inline FILTER_STATE CFilterGraph::GetStateInternal( void )
{
    // The filter graph can only be in three states: stopped, running and paused.
    // See the Direct Show SDK documentation for FILTER_STATE for more information.
    ASSERT( (State_Stopped == m_State) ||
            (State_Paused == m_State) ||
            (State_Running == m_State) );

    return m_State;
}

#ifdef DEBUG
inline bool CFilterGraph::IsValidInternalFilterFlags( DWORD dwFlags )
{
    const DWORD VALID_FLAGS_MASK = FILGEN_ADDED_MANUALLY |
                                   FILGEN_ADDED_RUNNING |
                                   FILGEN_FILTER_REMOVEABLE;

    return ValidateFlags( VALID_FLAGS_MASK, dwFlags );
}
#endif // DEBUG

inline bool CFilterGraph::BlockAfterFrameSkip()
{
    // The caller must hold the filter lock because this function
    // uses m_fstCurrentOperation.
    ASSERT(CritCheckIn(&m_CritSec));

    return (FST_BLOCK_AFTER_SKIP == m_fstCurrentOperation);
}

inline bool CFilterGraph::DontBlockAfterFrameSkip()
{
    // The caller must hold the filter lock because this function
    // uses m_fstCurrentOperation.
    ASSERT(CritCheckIn(&m_CritSec));

    return (FST_DONT_BLOCK_AFTER_SKIP == m_fstCurrentOperation);
}

inline IFrameSkipResultCallback* CFilterGraph::GetIFrameSkipResultCallbackObject()
{
    // The caller must hold the filter lock because this function
    // uses m_pFSRCB and m_fstCurrentOperation.
    ASSERT(CritCheckIn(&m_CritSec));

    // m_pFSRCB only points to a valid object if someone calls
    // SkipFrames() to skip several frames.
    ASSERT(FST_DONT_BLOCK_AFTER_SKIP == m_fstCurrentOperation);

    if( m_pFSRCB ) { // m_pFSRCB != NULL
        m_pFSRCB.p->AddRef();
    }    

    return m_pFSRCB;
}

inline bool CFilterGraph::FrameSkippingOperationInProgress()
{
    return DontBlockAfterFrameSkip() && m_pFSRCB; // m_pFSRCB != NULL
}

#endif // __DefFilGraph
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\filgraph.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

/**************************************************************
The main file for implementation of the filter graph component.
Other files are
Filter graph sorting        sort.cpp
Intelligent render/connect  intel.cpp
******************************************************************/

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

/*********************************************************************
From Geraint's code review:

-- RenderByFindingPin and RenderUsingFilter need to document their assumptions
about the state of the lists on entry and exit. RenderUsingFilter appears to
do one unnecessary Backout(NewActs) on a list that should always be empty. If
it's needed here, then its also needed in RenderByFindingPin.

-- we need a policy on selecting the default clock. If more than one
filter exposes a clock, we may find that one of them will not accept
sync to another clock.

-- Use CAMThread for the Reconnect stuff.
***********************************************************/

/*********************** TO DO *********************************************
1.  No MRIDs (registering, unregistering or using)
16. No IDispatch
****************************************************************************/

#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <string.h>
#ifdef FILTER_DLL
#include <initguid.h>
#include <olectlid.h>
#include <rsrcmgr.h>
#include <fgctl.h>
#endif // FILTER_DLL

#include <ftype.h>        // GetMediaTypeFile
#include <comlite.h>
#include "MsgMutex.h"
#include "fgenum.h"
#include "rlist.h"
#include "distrib.h"
#include "filgraph.h"
#include "mapper.h"
#include "mtutil.h"
#include "resource.h"
#include <fgctl.h>
#include <stddef.h>
#include "FilChain.h"

const int METHOD_TRACE_LOGGING_LEVEL = 7;

// Stats logging
CStats g_Stats;

extern HRESULT GetFilterMiscFlags(IUnknown *pFilter, DWORD *pdwFlags);

const REFERENCE_TIME MAX_GRAPH_LATENCY = 500 * (UNITS / MILLISECONDS );

// reg key to enable/disable setting of graph latency
const TCHAR g_szhkPushClock[] = TEXT( "Software\\Microsoft\\DirectShow\\PushClock");
const TCHAR g_szhkPushClock_SyncUsingOffset[] = TEXT( "SyncUsingOffset" );
const TCHAR g_szhkPushClock_MaxGraphLatencyMS[] = TEXT( "MaxGraphLatencyMS" );

const TCHAR chRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\FilterGraph");
//  Registry values
DWORD
GetRegistryDWORD(
    const TCHAR *pKey,
    DWORD dwDefault
    )
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(
               HKEY_CURRENT_USER,
               chRegistryKey,
               0,
               KEY_QUERY_VALUE,
               &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;

        dwLen = sizeof(DWORD);
        RegQueryValueEx(hKey, pKey, 0L, &dwType,
                        (LPBYTE)&dwDefault, &dwLen);
        RegCloseKey(hKey);
    }
    return dwDefault;
}

//  Helper to get a filter's name
void GetFilterName(IPin *pPin, WCHAR *psz)
{
    PIN_INFO pi;
    if (SUCCEEDED(pPin->QueryPinInfo(&pi))) {
        if (pi.pFilter) {
            FILTER_INFO fi;
            if (SUCCEEDED(pi.pFilter->QueryFilterInfo(&fi))) {
                if (fi.pGraph != NULL) {
                    fi.pGraph->Release();
                }
                lstrcpyWInternal(psz, fi.achName);
            }
            pi.pFilter->Release();
        }
    }
}

// -- Stuff to create a graph on another thread so it stays around and
//    has access to a message loop.  We can create as many graphs
//    as we like on the thread

CRITICAL_SECTION g_csObjectThread;
DWORD            g_cFGObjects;
DWORD            g_dwObjectThreadId;

//=====================================================================
//=====================================================================
// Auxiliary functions etc.
//=====================================================================
//=====================================================================

//=====================================================================
//  Instantiate a filter
//=====================================================================
STDAPI CoCreateFilter(const CLSID *pclsid, IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 3, TEXT("Creating filter")));
    HRESULT hr =
           CoCreateInstance( *pclsid        // source filter
                           , NULL           // outer unknown
                           , CLSCTX_INPROC
                           , IID_IBaseFilter
                           , (void **) ppFilter // returned value
                           );
    DbgLog((LOG_TRACE, 3, TEXT("Created filter")));
    return hr;
}

//  Called from the message proc for AWM_CREATFILTER
void CFilterGraph::OnCreateFilter(
    const AwmCreateFilterArg *pArg,
    IBaseFilter **ppFilter
)
{
    ReplyMessage(0);

    if(pArg->creationType ==  AwmCreateFilterArg::BIND_MONIKER)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Binding to filter")));
        m_CreateReturn = pArg->pMoniker->BindToObject(
            m_lpBC, 0, IID_IBaseFilter, (void **)ppFilter);
        DbgLog((LOG_TRACE, 3, TEXT("Bound to filter")));
    }
    else
    {
        ASSERT(pArg->creationType == AwmCreateFilterArg::COCREATE_FILTER);
        m_CreateReturn = CoCreateFilter(pArg->pclsid, ppFilter);
    }


    if (FAILED(m_CreateReturn)) {
        DbgLog((LOG_ERROR, 1, TEXT("Failed to create filter code %8.8X"), m_CreateReturn));
    }

    m_evDone.Set();
}

//  Called in response to AWM_DELETESPARELIST
void CFilterGraph::OnDeleteSpareList(WPARAM wParam)
{
    DeleteSpareList(*(CSpareList *)wParam);
}

//=====================================================================
// Create a filter object on the filter graph's thread
//=====================================================================
HRESULT CFilterGraph::CreateFilter(
    const CLSID *pclsid,
    IBaseFilter **ppFilter
)
{
    CAutoTimer Timer(L"Create Filter");
    if (S_OK == CFilterGraph::IsMainThread()) {
        return CoCreateFilter(pclsid, ppFilter);
    } else {
        AwmCreateFilterArg acfa;
        acfa.pclsid = pclsid;
        acfa.creationType = AwmCreateFilterArg::COCREATE_FILTER;
        return CreateFilterHelper(&acfa, ppFilter);
    }
}

HRESULT CFilterGraph::CreateFilter(
    IMoniker *pMoniker,
    IBaseFilter **ppFilter
)
{
    CAutoTimer Timer(L"Create Filter");
    if (S_OK == CFilterGraph::IsMainThread()) {
        return pMoniker->BindToObject(
            m_lpBC, 0, IID_IBaseFilter, (void **)ppFilter);
    } else {
        AwmCreateFilterArg acfa;
        acfa.pMoniker = pMoniker;;
        acfa.creationType = AwmCreateFilterArg::BIND_MONIKER;
        return CreateFilterHelper(&acfa, ppFilter);
    }
}

HRESULT CFilterGraph::CreateFilterHelper(
    const AwmCreateFilterArg *pArg,
    IBaseFilter **ppFilter)
{
    m_CreateReturn = 0xFFFFFFFF;

    DbgLog((LOG_TRACE, 3, TEXT("CreateFilterHelper enter")));
    //  We would have liked to use SendMessage but win95 complained
    //  when we called ce inside SendMessage with
    //  RPC_E_CANTCALLOUT_ININPUTSYNCCALL
    //  So instead call PostMessage and wait for the event
    if (!PostMessage(m_hwnd,
                     AWM_CREATEFILTER,
                     (WPARAM)pArg,
                     (LPARAM)ppFilter)
       ) {
        return E_OUTOFMEMORY;
    }

    //  Even at this point we can be sent a message from
    //  a window on the filter graph thread.  What happens is:
    //  -- The video renderer window gets activated
    //  -- In processing the activation a message gets sent to
    //     a window owned by this thread to deactivate itself
    //
    WaitDispatchingMessages(m_evDone, INFINITE);
    ASSERT(m_CreateReturn != 0xFFFFFFFF);
    DbgLog((LOG_TRACE, 3, TEXT("CreateFilterHelper leave")));
    return m_CreateReturn;
}

//=====================================================================
// Return the length in bytes of str, including the terminating null
//=====================================================================
int BytesLen(LPTSTR str)
{
    if (str==NULL) {
        return 0;
    }
#ifdef UNICODE
    return (sizeof(TCHAR))*(1+wcslen(str));
#else
    return (sizeof(TCHAR))*(1+strlen(str));
#endif
} // BytesLen


//==============================================================================
// List traversal macros.
// NOTE Each of these has three unmatched open braces
// that are matched by the corresponding ENDTRAVERSExxx macro
// It's a single loop in each case so continue and break wil work
// All the names given in the macro call are available inside the loop
// They are all declared in the macro
//
// NB these could be replaced with C++ classes, see fgenum.h CEnumPin
//    TRAVERSEFILTERS may be an especially good candidate.
//==============================================================================

// Interate through every filter in the mFG_FilGenList list.  pCurrentFilter stores
// the IBaseFilter interface pointer for the current filter in the mFG_FilGenList.
#define TRAVERSEFILTERS( pCurrentFilter )                                                   \
        for (POSITION Pos = mFG_FilGenList.GetHeadPosition(); Pos; )                        \
        {   /* Retrieve the current IBaseFilter, side-effect Pos on to the next */          \
            /* IBaseFilter is decended from IMediaFilter, don't need to QI.     */          \
            IBaseFilter * const pCurrentFilter = mFG_FilGenList.Get(Pos)->pFilter;      \
            {

// dynamic reconnections can make the filgenlist change in between
// TRAVERSEFILTERS and ENDTRAVERSEFILTERS, so don't get the next Pos until now
//
#define ENDTRAVERSEFILTERS()                                                                \
            }                                                                               \
        Pos = mFG_FilGenList.Next(Pos);     \
        }                                                                                   \


// set *pfg to each FilGen in mFG_FilGenList in turn
// use Pos as a name of a temp
#define TRAVERSEFILGENS(Pos, pfg)                                              \
    {   POSITION Pos = mFG_FilGenList.GetHeadPosition();                       \
        while(Pos!=NULL) {                                                     \
            /* Retrieve the current IBaseFilter, side-effect Pos on to the next */ \
            FilGen * pfg = mFG_FilGenList.GetNext(Pos);                        \
            {


#define ENDTRAVERSEFILGENS \
            }              \
        }                  \
    }

//==============================================================================


// CumulativeHRESULT - this function can be used to aggregate the return
// codes that are received from the filters when a method is distributed.
// After a series of Accumulate()s m_hr will be:
// a) the first non-E_NOTIMPL failure code, if any;
// b) else the first non-S_OK success code, if any;
// c) E_NOINTERFACE if no Accumulates were made;
// d) E_NOTIMPL iff all Accumulated HRs are E_NOTIMPL
// e) else the first return code (S_OK by implication).

void __fastcall CumulativeHRESULT::Accumulate( HRESULT hrThisHR )
{
    if ( ( m_hr == S_OK || FAILED(hrThisHR) && SUCCEEDED(m_hr) ) && hrThisHR != E_NOTIMPL && hrThisHR != E_NOINTERFACE
         || m_hr == E_NOTIMPL
     || m_hr == E_NOINTERFACE
       )
    {
        m_hr = hrThisHR;
    }
}

#ifdef DEBUG
//===========================================================
//
// DbgDump
//
// Dump all the filter and pin addresses in the filter graph to DbgLog
//===========================================================
void CFilterGraph::DbgDump()
{

    HRESULT hr;
    DbgLog((LOG_TRACE, 2, TEXT("Filter graph dump")));

    CFilGenList::CEnumFilters NextOne(mFG_FilGenList);
    IBaseFilter *pf;

    while ((PVOID) (pf = ++NextOne)) {

        IUnknown * punk;
        pf->QueryInterface( IID_IUnknown, (void**)(&punk) );
        punk->Release();

        // note - name is a WSTR whether we are unicode or not.
        DbgLog((LOG_TRACE, 2
              , TEXT("Filter %x '%ls' Iunknown %x")
              , pf
              , (mFG_FilGenList.GetByFilter(pf))->pName
              , punk
              ));

        CEnumPin NextPin(pf);
        IPin *pPin;

        while ((PVOID) (pPin = NextPin())) {

            PIN_INFO pi;
            pPin->QueryPinInfo(&pi);
            QueryPinInfoReleaseFilter(pi);
            IPin *pConnected;
            hr = pPin->ConnectedTo(&pConnected);
            if (FAILED(hr)) {
                pConnected = NULL;
            }
            DbgLog(( LOG_TRACE, 2, TEXT("    Pin %x %ls (%s) connected to %x")
                   , pPin, pi.achName
                   , ( pi.dir==PINDIR_INPUT ? TEXT("Input") : TEXT("PINDIR_OUTPUT") )
                   , pConnected
                  ));

            if (pConnected != NULL) {
                pConnected->Release();
            }
            pPin->Release();
        }
    }
    DbgLog((LOG_TRACE, 2, TEXT("End of filter graph dump")));
} // DbgDump

//============================================================
//  TestConnection
//
//  Test that 2 pins that say they are connected do roughtly the right
//  things
//
void TestConnection(IPin *ppinIn, IPin *ppinOut)
{
    /*  Check they think they're connected to each other */
    IPin *ppinInTo;
    IPin *ppinOutTo;
    CMediaType mtIn;
    CMediaType mtOut;
    EXECUTE_ASSERT(S_OK == ppinIn->ConnectedTo(&ppinInTo));
    EXECUTE_ASSERT(S_OK == ppinOut->ConnectedTo(&ppinOutTo));
    ASSERT(IsEqualObject(ppinInTo, ppinOut));
    ASSERT(IsEqualObject(ppinOutTo, ppinIn));
    ppinInTo->Release();
    ppinOutTo->Release();
    EXECUTE_ASSERT(S_OK == ppinIn->ConnectionMediaType(&mtIn));
    EXECUTE_ASSERT(S_OK == ppinOut->ConnectionMediaType(&mtOut));
    //  Either the types match or one or other is partially specified
    ASSERT(mtIn == mtOut ||
           (mtIn.majortype == mtOut.majortype &&
            (mtIn.subtype == GUID_NULL && mtIn.formattype == GUID_NULL ||
             mtOut.subtype == GUID_NULL && mtOut.formattype == GUID_NULL)));
    FreeMediaType(mtIn);
    FreeMediaType(mtOut);
}

#endif // DEBUG

#ifdef CHECK_REGISTRY
typedef struct _CLSIDTAB {
    const CLSID * pclsid;
    LPCTSTR  szFileName;
} CLSIDTAB;

const CLSIDTAB clsidCheck[2] =
{
    {    &CLSID_DvdGraphBuilder, TEXT("qdvd.dll")
    },
    {    &CLSID_DVDNavigator, TEXT("qdvd.dll")
    }
};

extern HRESULT TextFromGUID2(REFGUID refguid, LPTSTR lpsz, int cbMax);
BOOL CheckValidClsids()
{
    for (int i = 0; i < NUMELMS(clsidCheck); i++) {
        TCHAR KeyName[100];
        lstrcpy(KeyName, TEXT("CLSID\\"));
        TextFromGUID2(*clsidCheck[i].pclsid, KeyName + lstrlen(KeyName), 100);
        lstrcat(KeyName, TEXT("\\InprocServer32"));
        TCHAR szFileName[MAX_PATH];
        LONG cbValue = sizeof(szFileName);
        if (NOERROR == RegQueryValue(HKEY_CLASSES_ROOT,
                               KeyName,
                               szFileName,
                               &cbValue)) {
            //  Check the file name
            LONG szLen = lstrlen(clsidCheck[i].szFileName);

            //  cbValue includes trailing 0
            ASSERT(cbValue > 0);
            cbValue--;
            if (cbValue < szLen ||
                lstrcmpi(clsidCheck[i].szFileName, szFileName + cbValue - szLen)) {
                return FALSE;
            }
            //  Check for derived names
            if (cbValue > szLen && szFileName[cbValue - szLen - 1] != TEXT('\\')) {
                return FALSE;
            }
        }
    }
    return TRUE;
}
#endif // CHECK_REGISTRY

#ifdef FILTER_DLL
//===========================================================
// List of class IDs and creator functions for class factory
//===========================================================

CFactoryTemplate g_Templates[3] =
{
    {L"", &CLSID_FilterGraph, CFilterGraph::CreateInstance},
    {L"", &CLSID_FilterMapper, CFilterMapper::CreateInstance
                             , CFilterMapper::MapperInit},
    {L"", &CLSID_FilterMapper2, CFilterMapper2::CreateInstance
                             , CFilterMapper2::MapperInit},
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif // FILTER_DLL


//==================================================================
//==================================================================
// Members of CFilterGraph
//==================================================================
//==================================================================


//==================================================================
//
// CreateInstance
//
// This goes in the factory template table to create new instances
//==================================================================

CUnknown *CFilterGraph::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CFilterGraph(NAME("Core filter graph"),pUnk, phr);
} // CFilterGraph::Createinstance

#pragma warning(disable:4355)

//==================================================================
//
// CFilterGraph constructor
//
//==================================================================

CFilterGraph::CFilterGraph( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
    : CBaseFilter(pName, pUnk, (CCritSec*) this, CLSID_FilterGraph)
    , mFG_hfLog(INVALID_HANDLE_VALUE)
    , mFG_FilGenList(NAME("List of filters in graph"), this)
    , mFG_ConGenList(NAME("List of outstanding connections for graph"))
    , mFG_iVersion(0)
    , mFG_iSortVersion(0)
    , mFG_bDirty(FALSE)
    , mFG_bNoSync(FALSE)
    , mFG_bSyncUsingStreamOffset(FALSE)
    , mFG_rtMaxGraphLatency(MAX_GRAPH_LATENCY)
    , mFG_dwFilterNameCount(0)
#ifdef THROTTLE
    , mFG_AudioRenderers(NAME("List of audio renderers"))
    , mFG_VideoRenderers(NAME("List of video renderers"))
#endif // THROTTLE
    , mFG_punkSite(NULL)
    , mFG_RecursionLevel(0)
    , mFG_ppinRender(NULL)
    , mFG_bAborting(FALSE)
    , m_hwnd(NULL)
    , m_MainThreadId(NULL)
    , mFG_listOpenProgress(NAME("List of filters supporting IAMOpenProgress"))
    , mFG_pDistributor(NULL)
    , mFG_pFGC(NULL)
    , mFG_pMapperUnk(NULL)
    , m_CritSec(phr)
    , m_lpBC(NULL)
    , mFG_bNoNewRenderers(false)
    , mFG_Stats(NULL)
    , m_Config( this, phr )
    , m_pFilterChain(NULL)
    , m_fstCurrentOperation(FST_NOT_STEPPING_THROUGH_FRAMES)
#ifdef DO_RUNNINGOBJECTTABLE
    , m_dwObjectRegistration(0)
#endif
{
#ifdef DEBUG
    mFG_Test = NULL;
#endif // DEBUG

    // Store the application thread ID
    m_MainThreadId = GetCurrentThreadId();

    m_pFilterChain = new CFilterChain( this );
    if( NULL == m_pFilterChain ) {
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Create free threaded marshaler
    IUnknown *pMarshaler;
    HRESULT hr = CoCreateFreeThreadedMarshaler(GetOwner(), &m_pMarshaler);
    if (FAILED(hr)) {
        *phr = hr;
        return;
    }

    // Add stats object
    mFG_Stats = new CComAggObject<CStatContainer>(GetOwner());
    if (mFG_Stats == NULL) {
        *phr = E_OUTOFMEMORY;
        return;
    }
    mFG_Stats->AddRef();

#ifdef CHECK_REGISTRY
    if (!CheckValidClsids()) {
        *phr = HRESULT_FROM_WIN32(ERROR_REGISTRY_CORRUPT);
        return;
    }
#endif // CHECK_REGISTRY
    if (SUCCEEDED(*phr)) {
        // get the unknown for aggregation. can't addref
        // IFilterMapper2 because it'll addref us.
        HRESULT hr = QzCreateFilterObject( CLSID_FilterMapper2, GetOwner(), CLSCTX_INPROC
                                   , IID_IUnknown, (void **) &mFG_pMapperUnk
                                   );
        if (FAILED(hr)) {
            *phr = hr;
        }
        if (SUCCEEDED(*phr)) {

#ifdef PERF
            mFG_PerfConnect       = Msr_Register("FilterGraph Intelligent connect");
            mFG_PerfConnectDirect = Msr_Register("FilterGraph ConnectDirectInternal");
            mFG_NextFilter        = Msr_Register("FilterGraph Next filter");
            mFG_idIntel           = Msr_Register("Intel FG stuff");
            mFG_idConnectFail     = Msr_Register("ConnectDirect Failed");
#ifdef THROTTLE
            mFG_idAudioVideoThrottle = Msr_Register("Audio-Video Throttle");
#endif // THROTTLE
#endif //PERF
       }
    }

    // check whether the default state of mFG_bSyncUsingStreamOffset or
    // mFG_rtMaxGraphLatency has been overridden
    HKEY hkPushClockParams;
    LONG lResult = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        g_szhkPushClock,
        0,
        KEY_READ,
        &hkPushClockParams);
    if(lResult == ERROR_SUCCESS)
    {
        DWORD dwType, dwVal, dwcb;

        // Graph Latency set/unset flag
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkPushClockParams,
            g_szhkPushClock_SyncUsingOffset,
            0,
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            mFG_bSyncUsingStreamOffset = (0 == dwVal ) ? FALSE : TRUE;
        }
        // Max Graph Latency
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkPushClockParams,
            g_szhkPushClock_MaxGraphLatencyMS,
            0,
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            mFG_rtMaxGraphLatency = dwVal * ( UNITS / MILLISECONDS );
        }

        EXECUTE_ASSERT(RegCloseKey(hkPushClockParams) == ERROR_SUCCESS);
    }
#if DEBUG
    if( mFG_bSyncUsingStreamOffset )
        DbgLog((LOG_TRACE, 3, TEXT("Using Graph Latency of %dms"),
              (LONG) (mFG_rtMaxGraphLatency/10000)));
#endif

    // Now build the CFGControl
    if (SUCCEEDED(*phr))
    {
        mFG_pFGC = new CFGControl( this, phr );
        if (NULL == mFG_pFGC) {
            *phr = E_OUTOFMEMORY;
        } else if (SUCCEEDED(*phr)) {
            m_hwnd = mFG_pFGC->GetWorkerHWND();
        }
    }

    if(SUCCEEDED(*phr))
    {
        *phr = CreateBindCtx(0, &m_lpBC);
#ifdef DO_RUNNINGOBJECTTABLE
        if (GetRegistryDWORD(TEXT("Add To ROT on Create"), FALSE)) {
            AddToROT();
        }
#endif // DO_RUNNINGOBJECTTABLE
    }

} // CFilterGraph::CFilterGraph



//==================================================================
//
// RemoveAllConnections
//
// Disconnect all the direct connections of *pFilter, both ends.
// Each connection is removed in upstream order.
//
// Return S_OK disconnect successful or nothing to do. Returns an
// error if Disconnect() returns an error
//==================================================================

HRESULT CFilterGraph::RemoveAllConnections2( IBaseFilter * pFilter)
{
    HRESULT hrDisc = S_OK;

    // Enumerate all the pins and fully disconnect each
    CEnumPin Next(pFilter);
    IPin *pPin;
    while (SUCCEEDED(hrDisc) && (PVOID) (pPin = Next()))
    {
        HRESULT hr;  // return code from things we call

        //-------------------------------------------------
        // Find out direction and any peer connected to
        //-------------------------------------------------
        PIN_DIRECTION pd;
        hr = pPin->QueryDirection(&pd);
        ASSERT(SUCCEEDED(hr));

        IPin *pConnected;
        hr = pPin->ConnectedTo(&pConnected);
        ASSERT(SUCCEEDED(hr) && pConnected  || FAILED(hr) && !pConnected);
        if (SUCCEEDED(hr) && pConnected!=NULL) {

            //-------------------------------------------------
            // Disconnect any downstream peer
            //-------------------------------------------------
            if (pd == PINDIR_OUTPUT) {
                hrDisc = pConnected->Disconnect();
            }

            //-------------------------------------------------
            // Disconnect the pin itself - if it's connected
            //-------------------------------------------------
            if(SUCCEEDED(hrDisc)) {
                hrDisc = pPin->Disconnect();
            }

            //-------------------------------------------------
            // Disconnect any upstream peer
            //-------------------------------------------------
            if (SUCCEEDED(hrDisc) && pd == PINDIR_INPUT) {
                hrDisc = pConnected->Disconnect();
            }

            #ifdef DEBUG
            {
                // Make sure both pins are connected or both pins are disconnected.
                // If one pin is connected and the other pin is disconnected, the
                // filter graph is in an inconsistent state.  
                IPin* pOtherPin;
                bool fPinConnected = false;
                bool fConnectedPinConnected = false;

                HRESULT hrPin = pPin->ConnectedTo(&pOtherPin);
                if (SUCCEEDED(hrPin) && (NULL != pOtherPin)) {
                    fPinConnected = true;
                    pOtherPin->Release();
                }

                HRESULT hrConnected = pConnected->ConnectedTo(&pOtherPin);
                if (SUCCEEDED(hrConnected) && (NULL != pOtherPin)) {
                    fConnectedPinConnected = true;
                    pOtherPin->Release();
                }

                // Either both pins are connected or both pins are not connected.
                // If one pin is connected and the other pin is not connected,
                // the filter graph is in an inconsistent state.  This should be
                // avoided.  There are two possible solutions to this problem.
                //
                // 1) Modify the filter which failed to disconnect.  Change
                //    the code so IPin::Disconnect() cannot fail.
                //    
                // 2) Change the application to prevent it from disconnecting
                //    the pin when the pin does not want to be disconnected.
                // 
                ASSERT((fPinConnected && fConnectedPinConnected) ||
                       (!fPinConnected && !fConnectedPinConnected));
            }
            #endif // DEBUG

            pConnected->Release();
        }

        pPin->Release();
    } // while loop

    // Breaking connections do NOT require re-sorting!
    // They only add even more slack to the partial ordering.

    if(FAILED(hrDisc)) {
        DbgLog((LOG_ERROR, 0, TEXT("RemoveAllConnections2 failed %08x"), hrDisc));
    }

    return hrDisc;
} // RemoveAllConnections



//===================================================================
// RemoveDeferredList
//
// Remove mFG_ConGenList.
// Do NOT update the version number.  This is part of graph destruction.
//===================================================================
HRESULT CFilterGraph::RemoveDeferredList(void)
{
    ConGen * pcg;
    while ((PVOID)(pcg=mFG_ConGenList.RemoveHead())){
        delete pcg;
    }
    return NOERROR;
} // RemoveDeferredList



//==================================================================
//
// CFilterGraph destructor
//
//==================================================================

CFilterGraph::~CFilterGraph()
{
#ifdef DO_RUNNINGOBJECTTABLE
    //  Unregister ourselves if necessary
    if (0 != m_dwObjectRegistration) {
        // keep us from re-entering our destructor when the ROT releases
        // its refcount on us.
        m_cRef++;
        m_cRef++;

        if (m_MainThreadId == g_dwObjectThreadId) {
            // go to the object thread to unregister ourselves
            CAMEvent evDone;
            BOOL bOK = PostThreadMessage(g_dwObjectThreadId, WM_USER + 1,
                                    (WPARAM)this, (LPARAM) &evDone);
            if (bOK)
                WaitDispatchingMessages(HANDLE(evDone), INFINITE);
        } else {
            // unregister ourselves now
            IRunningObjectTable *pirot;
            if (SUCCEEDED(GetRunningObjectTable(0, &pirot))) {
                pirot->Revoke(m_dwObjectRegistration);
                pirot->Release();
            }
        }

        //EXECUTE_ASSERT(SUCCEEDED(CoDisconnectObject(GetOwner(), NULL)));
        m_dwObjectRegistration = 0;
    }
#endif

    delete m_pFilterChain;
    m_pFilterChain = NULL;

    // We need to tell the control object that we are shutting down
    // otherwise it can find itself processing a PAUSE after we have
    // done the Stop, and then the pins don't like to disconnect and
    // then the filters won't delete themselves.
    if (mFG_pFGC) mFG_pFGC->Shutdown();
    if (mFG_pDistributor) mFG_pDistributor->Shutdown();

    // Set all filters to stopped
    // again here in case the worker thread started anything before it was
    // shutdown
    Stop();

    RemoveAllFilters();
    RemoveDeferredList();

#ifdef THROTTLE
    ASSERT(mFG_VideoRenderers.GetCount()==0);
    ASSERT(mFG_AudioRenderers.GetCount()==0);
#endif // THROTTLE

    // clock should be gone by now.
    // what if it's an external clock???
    // ---as the comment above says, this is an invalid assert - the clock
    // will only be gone now if it came from a filter. The system clock
    // won't have gone away yet if we're using it.
    //    ASSERT(m_pClock == NULL);

    if (m_pClock) {
        m_pClock->Release();

        // must set it to null as this variable is owned by a base class
        m_pClock = NULL;
    }

    if (mFG_pMapperUnk) {
        mFG_pMapperUnk->Release();
    }

#ifdef DEBUG
    delete mFG_Test;
#endif // DEBUG

#ifdef DUMPPERFLOGATEND
#ifdef PERF
    HANDLE hFile = CreateFile( "c:\\filgraph.plog" // file name
                             , GENERIC_WRITE       // access
                             , 0                   // sharemode
                             , NULL                // security
                             , OPEN_ALWAYS
                             , 0                   // flags and attrs
                             , NULL                // hTemplateFile
                             );
    if (hFile==INVALID_HANDLE_VALUE) {
        volatile int i = GetLastError();
        // DbgBreak("Failed to create default perf log ");
        // If you tried to run several graphs at once - e.g. stress then you would hit this
        GetLastError(); // Bogus - hacking round a debugger quirk!
    } else {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        MSR_DUMP(hFile);
        CloseHandle(hFile);
    }

#endif
#endif

    // Harmless on a NULL pointer, so don't test.
    delete mFG_pDistributor;
    delete mFG_pFGC;

    // OK - now tell the object creator thread to go away if necessary
    EnterCriticalSection(&g_csObjectThread);
    if (m_MainThreadId == g_dwObjectThreadId) {
        ASSERT(g_cFGObjects > 0);
        g_cFGObjects--;
        // Give the thread a nudge
        if (g_cFGObjects == 0) {
            PostThreadMessage(g_dwObjectThreadId, WM_NULL, 0, 0);
        }
    }
    LeaveCriticalSection(&g_csObjectThread);

    if(m_lpBC) {
        m_lpBC->Release();
    }

    // this list should be empty by now....
    ASSERT(mFG_listOpenProgress.GetCount() == 0);

    // Release our stats interface
    if (mFG_Stats) {
        mFG_Stats->Release();
    }
    mFG_Stats = NULL;

} // CFilterGraph::~CFilterGraph

//===================================================================
// RemoveAllFilters
//
// Utility function to remove all the filters in the graph.
// Also removes all the connections.
// Does not update the version number.
// This in turn means that it does NOT attempt to rebuild the
// connections list - which makes it OK to delete that stuff first.
//===================================================================
HRESULT CFilterGraph::RemoveAllFilters(void)
{
    HRESULT hr;
    HRESULT hrOverall = NOERROR;

    //-------------------------------------------------------------
    // while (any left in mFG_FilGenList)
    //     Remove the first FilGen from the list
    //     Disconnect all the pins of its filter
    //         // This will often fail because we have already disconnected
    //         // the pin from the other end.  These are harmless no-ops.
    //     Release its filter
    //     Free its storage
    //-------------------------------------------------------------
    while (  mFG_FilGenList.GetCount() > 0 ) {

        FilGen * pfg = mFG_FilGenList.Get( mFG_FilGenList.GetHeadPosition() );
                  ASSERT(pfg);
                  ASSERT(pfg->pFilter);
        hr = RemoveFilterInternal(pfg->pFilter);
        if (FAILED(hr) && SUCCEEDED(hrOverall)) hrOverall = hr;
    }
    return hrOverall;
} // RemoveAllFilters


//===================================================================
//
// RemovePointer
//
// Remove from a list (the first instance of) a given pointer
// return the pointer or NULL if it's not there.
// ??? This should be a generic method on the list
//===================================================================

CFilterGraph::FilGen * CFilterGraph::RemovePointer(CFilGenList &cfgl, IBaseFilter * pFilter)
{
    POSITION Pos;
    Pos = cfgl.GetHeadPosition();
    while(Pos!=NULL) {
        FilGen * pfg;
        POSITION OldPos = Pos;
        pfg = cfgl.GetNext(Pos);    // side-efects Pos onto next
        if (pfg->pFilter == pFilter) {
            cfgl.Remove(OldPos);
            return pfg;
        }
    }
    return NULL;
} // RemovePointer



//========================================================================
//
// AddFilter
//
// Add a filter to the graph and name it with *pName.
// The name is allowed to be NULL,
// If the name is not NULL and not unique, The request will fail.
// The Filter graph will call the JoinFilterGraph
// member function of the filter to inform it.
// This must be called before attempting Connect, ConnectDirect etc
// for pins of the filter.
// The filter is AddReffed iff AddFilter SUCCEEDED
//========================================================================
STDMETHODIMP CFilterGraph::AddFilter( IBaseFilter * pFilter, LPCWSTR pName )
{
    CheckPointer(pFilter, E_POINTER);

    HRESULT hr;
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        ++mFG_RecursionLevel;

        hr = AddFilterInternal( pFilter, pName, false );
        if (SUCCEEDED(hr)) {
            IncVersion();
            mFG_RList.Active();
            AttemptDeferredConnections();
            mFG_RList.Passive();
        }
        --mFG_RecursionLevel;
    }

    // notify graph change (self-inhibits if recursive)
    if (SUCCEEDED(hr)) NotifyChange();

    if (FAILED(hr)) {
        Log( IDS_ADDFILTERFAIL, hr );
    } else {
        Log( IDS_ADDFILTEROK );
        mFG_bDirty = TRUE;
    }
    return hr;
} // AddFilter

//========================================================================
// InstallName
//
// Take the name, mangle it if necessary, allocate space, point
// pNewName at it.  If it doesn't work, pName should be NULL.
//========================================================================

HRESULT CFilterGraph::InstallName(LPCWSTR pName, LPWSTR &pNewName)
{
    pNewName = 0;                   // Initialize to null

// leading space not used if empty name passed in
#define SZ_FORMAT_NUMBER (L" %04u")

    const size_t MaxNameWidth
             = NUMELMS( ((FILTER_INFO *)NULL)->achName );
             // Name width is constricted by the achName.  If we name mangle,
             // we ensure that the mangled name will fit in this field.

    HRESULT hr;
    enum _NameState { Used, Created, Mangled } eNameState;

    const WCHAR * pcwstrNameToUse;              // Ptr to name we'll really use
    WCHAR wcsNameBuffer[ MaxNameWidth  ];       // local buffer in case needed

    WCHAR * pwstrNumber = 0;                    // Place where num will be added
                                                // If null => no num needed

    int cchBase = 0;

    if ( pName == 0 || *pName == L'\0' )
    {   // Create
        eNameState = Created;
        *wcsNameBuffer = 0;
        pcwstrNameToUse = wcsNameBuffer;
        cchBase = 1;
    }
    else
    {
        IBaseFilter * pf;
        hr = FindFilterByName( pName, &pf);
        if ( FAILED(hr) )
        {   // Use
            eNameState = Used;
            pcwstrNameToUse = pName;
        }
        else
        {   // Mangle
            eNameState = Mangled;
            cchBase = lstrlenW(pName) + 1;
            cchBase = min(cchBase, MaxNameWidth);
            lstrcpynW(wcsNameBuffer, pName, cchBase);
            pcwstrNameToUse = wcsNameBuffer;
            pf->Release();
        }
    }

    ASSERT( pcwstrNameToUse );

    if (eNameState != Used)
    {
        while(++mFG_dwFilterNameCount)
        {
            UINT iPosSuffix = cchBase - 1;
            
            WCHAR wszNum[20];
            WCHAR *szFormat = eNameState == Created ? SZ_FORMAT_NUMBER + 1 : 
                              SZ_FORMAT_NUMBER;
            wsprintfW(wszNum, szFormat, mFG_dwFilterNameCount);
            const cchNum = lstrlenW(wszNum) + 1; // take log?
            iPosSuffix = min(iPosSuffix, MaxNameWidth - cchNum);

            CopyMemory(wcsNameBuffer + iPosSuffix, wszNum, cchNum * sizeof(WCHAR));
            
            IBaseFilter * pf;
            hr = FindFilterByName( wcsNameBuffer, &pf);
            if ( SUCCEEDED(hr) ) {
                pf->Release();
                continue;
            }

            break;
        }

        if(mFG_dwFilterNameCount == 0) {
            DbgBreak("Duplicate Name!");
            return VFW_E_DUPLICATE_NAME;
        }
    }

    const int ActualLen = 1+lstrlenW(pcwstrNameToUse);
    pNewName = new WCHAR[ActualLen];
    if (pNewName==NULL) {
        return E_OUTOFMEMORY;
    }
    memcpy( pNewName, pcwstrNameToUse, 2*ActualLen );

    return eNameState == Mangled ? VFW_S_DUPLICATE_NAME : NOERROR;
}

//========================================================================
//
// AddFilterInternal
//
// Check for IMediaFilter, check Name is OK, convert null pName to empty Name
// Copy Name into FilGen, JoinFilterGraph and SetSyncSource
// Don't increment the graph version count.
// (Incrementing the version count breaks the filter enumerator).
// Iff it succeeds then AddRef the filter (once!)

// ??? What are the rules if it fails - transactional semantics???
// ??? It certainly doesn't have them at the moment!

//========================================================================

HRESULT CFilterGraph::AddFilterInternal( IBaseFilter * pFilter, LPCWSTR pName, bool fIntelligent )
{
    HRESULT hr, hr2;

    //----------------------------------------------------------------
    // Add the filter to the FilGen list and Addref it
    //----------------------------------------------------------------
    hr = S_OK;

    DWORD dwAddFlag = 0;

    if(m_State != State_Stopped) {
        dwAddFlag |= FILGEN_ADDED_RUNNING;
    }

    if( !fIntelligent ) {
        dwAddFlag |= FILGEN_ADDED_MANUALLY;
    }

    FilGen * pFilGen = new FilGen(pFilter, dwAddFlag);
    if ( pFilGen==NULL ) {
        return E_OUTOFMEMORY;
    }

    //----------------------------------------------------------------
    // Put the name into the FilGen.
    // Convert NULL or duplicate name into something more sensible.
    // (Leaving NULL could even make JoinFilterGraph trap).
    //----------------------------------------------------------------
    hr2 = InstallName(pName, pFilGen->pName);
    if (FAILED(hr2)) {
        delete pFilGen;
        return hr2;
    }

    // We are usually working downstream.  By adding it to the head  we are
    // probably putting it in upstream order.  May save time on the sorting.
    POSITION pos;
    pos = mFG_FilGenList.AddHead( pFilGen );
    if (pos==NULL) {
        delete pFilGen;

        return E_OUTOFMEMORY;
    }

    //----------------------------------------------------------------
    // Tell the filter it's joining the filter graph
    // WARNING - the Image Renderer may call AddFilter INSIDE here
    // Another reason to be a state machine
    //----------------------------------------------------------------
    hr = pFilter->JoinFilterGraph( this, pFilGen->pName);
    if (FAILED(hr) || hr==S_FALSE) {
        mFG_FilGenList.RemoveHead();
        delete pFilGen;                      // also Releases the filter
        return hr;
    }


    //---------------------------------------------------------------------
    // If the FilterGraph has a syncsource defined then tell the new filter
    //---------------------------------------------------------------------
    if (NULL != m_pClock) {
        hr = pFilter->SetSyncSource( m_pClock );
        if (FAILED(hr)) {
            // Clean up - including calling JoinFilterGraph(NULL, NULL)
            RemoveFilterInternal(pFilter);
            return hr;
        }
    }

    if( mFG_bSyncUsingStreamOffset )
    {
        // if we're going to be setting a graph latency check whether this filter
        // has any IAMPushSource pins

        // First check that filter supports IAMFilterMiscFlags and is an
        // AM_FILTER_MISC_FLAGS_IS_SOURCE filter
        ULONG ulFlags;
        GetFilterMiscFlags(pFilter, &ulFlags);
        if( AM_FILTER_MISC_FLAGS_IS_SOURCE & ulFlags )
        {
            //
            // now find any IAMPushSource output pins and prepare them for the maximum latency
            // which we'll allow on the graph (the video preview pin, especially,
            // would like to know this before it connects, to adjust its buffering)
            //
            CEnumPin NextPin(pFilter);
            IPin *pPin;
            while ((PVOID) (pPin = NextPin()))
            {
                PIN_DIRECTION pd;
                hr = pPin->QueryDirection(&pd);
                ASSERT(SUCCEEDED(hr));
                if( PINDIR_OUTPUT == pd )
                {
                    IAMPushSource * pips;
                    hr = pPin->QueryInterface( IID_IAMPushSource, (void**)(&pips) );
                    if( SUCCEEDED( hr ) )
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("AddFilterInternal::Found IAMPushSource pin...Setting maximum latency ( filter %x, %ls)")
                          , pFilter, (mFG_FilGenList.GetByFilter(pFilter))->pName));

                        pips->SetMaxStreamOffset( mFG_rtMaxGraphLatency );
                        pips->Release();
                    }
                }
                pPin->Release();
            }
        }
    }

    // IAMOpenProgress -- if we haven't already got an interface
    // that implements this, then get it now
    {
        CAutoLock lock(&mFG_csOpenProgress);
        IAMOpenProgress *pOp;

        HRESULT hr2 = pFilter->QueryInterface(IID_IAMOpenProgress, (void**) &pOp);

        if (SUCCEEDED(hr2)) {
            mFG_listOpenProgress.AddTail(pOp);
        }
    }

#ifdef FG_DEVICE_REMOVAL
    IAMDeviceRemoval *pdr;
    if(pFilter->QueryInterface(IID_IAMDeviceRemoval, (void **)&pdr) == S_OK)
    {
        mFG_pFGC->AddDeviceRemovalReg(pdr);
        pdr->Release();
    }
#endif // FG_DEVICE_REMOVAL

#ifdef DEBUG
    IUnknown * punk;
    pFilter->QueryInterface( IID_IUnknown, (void**)(&punk) );
    punk->Release();

    // Get something into the trace that will allow decode of numbers
    // note - name is a WSTR whether we are unicode or not.
    DbgLog((LOG_TRACE, 2
          , TEXT("Filter %x '%ls' Iunknown %x")
          , pFilter
          , (mFG_FilGenList.GetByFilter(pFilter))->pName
          , punk
          ));
#endif // DEBUG

    return hr2;

} // AddFilterInternal


//========================================================================
//
// RemoveFilter
//
// Remove a filter from the graph.  The filter graph implementation
// will inform the filter that it is being removed.
// It also removes all connections
//========================================================================

STDMETHODIMP CFilterGraph::RemoveFilter( IBaseFilter * pFilter )
{
    // defer to the newer version which takes a flag (defaulted to normal case)
    //
    return RemoveFilterEx( pFilter );

} // RemoveFilter

HRESULT CFilterGraph::RemoveFilterEx( IBaseFilter * pFilter, DWORD Flags )
{
    CheckPointer(pFilter, E_POINTER);
    HRESULT hr;
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);

        IncVersion();
        // Removing a filter does demand re-sorting, but it does require a
        // version change to ensure that we break the enumerators.  Distributors
        // depend on this to find the renderers etc.

        // pass Flags to RemoveFilterInternal
        hr = RemoveFilterInternal(pFilter, Flags );

        // Empty lists so all our pointers get released
        mFG_pFGC->EmptyLists();

        // It's weird, but just about possible that removing a filter, and thereby
        // removing a connection that it has could make some other connection possible.
        mFG_RList.Active();
        AttemptDeferredConnections();
        mFG_RList.Passive();
    }

    // outside lock, notify change in graph
    // notify change regardless of whether the filter was removed
    // successfully or not.  (We have changed the version.)
    NotifyChange();

    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    }

    return hr;
}


//========================================================================
//
// RemoveFilterInternal
//
// RemoveFilter, but do NOT increase the version count and so do not
// break the filter enumerator.  Release the refcount on the filter.
//========================================================================

HRESULT CFilterGraph::RemoveFilterInternal( IBaseFilter * pFilter, DWORD fRemoveFlags )
{
#ifdef FG_DEVICE_REMOVAL
    IAMDeviceRemoval *pdr;
    if(pFilter->QueryInterface(IID_IAMDeviceRemoval, (void **)&pdr) == S_OK) {
        mFG_pFGC->RemoveDeviceRemovalRegistration((IUnknown *)pFilter);
        pdr->Release();
    }
#endif

    FilGen * pfg = mFG_FilGenList.GetByFilter(pFilter);

    ASSERT (pFilter!=NULL);

    // Some filters don't like to join or leave filter graphs when they
    // have connections (reasonable, I guess) so remove them first, if
    // we're in normal mode
    //

    HRESULT hrRemove = NOERROR;
    if( !( fRemoveFlags & REMFILTERF_LEAVECONNECTED ) )
    {
        hrRemove = RemoveAllConnections2(pFilter);
        if( FAILED( hrRemove ) )
        {
            return hrRemove;
        }
    }

#ifdef THROTTLE
    // If this filter was on the audio renderers list, then release its Peer
    // and take it off the list.  Call IQualityControl::SetSink(NULL)
    // to ensure that it doesn't retain a pointer to us.

    POSITION Pos = mFG_AudioRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        // Retrieve the current IBaseFilter, side-effect Pos on to the next
        // but remember where we were in case we need to delete it
        POSITION posDel = Pos;
        AudioRenderer * pAR = mFG_AudioRenderers.GetNext(Pos);

        if (IsEqualObject(pAR->pf, pFilter)) {

            // Undo the SetSink
            pAR->piqc->SetSink(NULL);
            pAR->piqc->Release();
            pAR->piqc = NULL;

            mFG_AudioRenderers.Remove(posDel);
            delete pAR;
            break;   // ASSERT no filter can be on the list more than once
        }
    }
#endif // THROTTLE


    // A filter has a JoinFilterGraph method, but no corresponding
    // LeaveFilterGraph method.  Call Join with NULLs.
    pFilter->SetSyncSource(NULL);
    pFilter->JoinFilterGraph(NULL, NULL);

    // If removing this filter also removes the clock then
    // set the sync source of the graph to NULL.
    if (m_pClock!=NULL) {
        if (IsEqualObject(pFilter,m_pClock)) {

            // this clears the current clock, but it leaves the filtergraph
            // thinking that we explicitly want to run with no clock
            SetSyncSource(NULL);

            // say that actually we do want a clock, and it will be chosen
            // on the next pause
            mFG_bNoSync = FALSE;
        }
    }

#ifdef THROTTLE
    // If this filter was on the video renderers list, then release its piqc
    // and take it off the list

    Pos = mFG_VideoRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        // Retrieve the current IBaseFilter, side-effect Pos on to the next
        // but remember where we were in case we need to delete it
        POSITION posDel = Pos;
        IQualityControl * piqc = mFG_VideoRenderers.GetNext(Pos);

        if (IsEqualObject(piqc, pFilter)) {
            piqc->Release();
            mFG_VideoRenderers.Remove(posDel);
            break;   // ASSERT no filter can be on the list more than once
        }
    }
#endif // THROTTLE

    // if this filter was currently supplying IAMOpenProgress then release it
    {
        CAutoLock lock(&mFG_csOpenProgress);

        IAMOpenProgress *pOp;
        HRESULT hr = pFilter->QueryInterface(IID_IAMOpenProgress, (void**)&pOp);
        if (SUCCEEDED(hr)) {
            POSITION Pos = mFG_listOpenProgress.GetHeadPosition();
            while (Pos!=NULL) {
                IAMOpenProgress *p;
                POSITION OldPos = Pos;
                p = mFG_listOpenProgress.GetNext(Pos);    // side-efects Pos onto next
                if (p == pOp) {
                    mFG_listOpenProgress.Remove(OldPos);
                    p->Release();
                    break;
                }
            }
            pOp->Release();
        }
    }

    {
        FILTER_STATE fsCurrent;

        HRESULT hr = pFilter->GetState( 0, &fsCurrent );
        if (SUCCEEDED(hr)) {
            if ((State_Running == fsCurrent) && (State_Running == GetStateInternal())) {
                hr = IsRenderer( pFilter );

                // IsRenderer() returns S_OK if a renderer sends an EC_COMPLETE event.
                if (SUCCEEDED(hr) && (S_OK == hr)) {
                    hr = mFG_pFGC->UpdateEC_COMPLETEState( pFilter, CFGControl::ECS_FILTER_STOPS_SENDING );
                    if (FAILED(hr)) {
                        DbgLog(( LOG_ERROR, 3, TEXT("WARNING in CFilterGraph::RemoveFilterInternal(): UpdateEC_COMPLETEState() failed and returned %#08x."), hr ));
                    }
                }
            }
        }
    }

    RemovePointer(mFG_FilGenList, pFilter);
    delete pfg;                   // This Releases the filter!

    return hrRemove;

} // RemoveFilterInternal



//========================================================================
//
// EnumFilters
//
// Get an enumerator to list all filters in the graph.
//========================================================================

STDMETHODIMP CFilterGraph::EnumFilters( IEnumFilters **ppEnum )
{
    CheckPointer(ppEnum, E_POINTER);
    CAutoMsgMutex cObjectLock(&m_CritSec);
    CEnumFilters *pEnumFilters;

    // Create a new enumerator

    // If the list hasn't been sorted since the group was last furkled with
    // sort it now so as to always enumerate it in upstream order
    // UpstreamOrder checks before resorting

    HRESULT hr = UpstreamOrder();
    if( FAILED( hr ) ) {
        return hr;
    }

    pEnumFilters = new CEnumFilters(this);
    if (pEnumFilters == NULL) {
        *ppEnum = NULL;
        return E_OUTOFMEMORY;
    }

    // Get a reference counted IID_IEnumFilters interface

    return pEnumFilters->QueryInterface(IID_IEnumFilters, (void **)ppEnum);
} // EnumFilters



//========================================================================
//
// FindFilterByName
//
// Find the filter with a given name, returns an AddRef'ed pointer
// to the filters IBaseFilter interface, or will fail if the named filter does
// not exist in this graph in which the case a NULL interface pointer is
// returned in ppFilter.
//========================================================================

STDMETHODIMP CFilterGraph::FindFilterByName
    ( LPCWSTR pName, IBaseFilter ** ppFilter )
{
    CheckPointer(pName, E_POINTER);   // You may NOT search for a null name
    CheckPointer(ppFilter, E_POINTER);
    CAutoMsgMutex cObjectLock(&m_CritSec);

    TRAVERSEFILGENS(pos, pfg)
        if (0==lstrcmpW(pfg->pName, pName)) {
            *ppFilter = pfg->pFilter;
            (*ppFilter)->AddRef();
            return NOERROR;
        }

    ENDTRAVERSEFILGENS
    *ppFilter = NULL;
    return VFW_E_NOT_FOUND;

} // FindFilterByName



//========================================================================
//
// ConnectDirect
//
// Connect these two pins directly (i.e. without intervening filters)
// The filter which owns the pins
//========================================================================

STDMETHODIMP CFilterGraph::ConnectDirect
    ( IPin * ppinOut,    // the output pin
      IPin * ppinIn,      // the input pin
      const AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr;
    mFG_bAborting = FALSE;                // Possible race. Doesn't matter.
    CheckPointer(ppinOut, E_POINTER);
    CheckPointer(ppinIn, E_POINTER);
    if (FAILED(hr=CheckPinInGraph(ppinOut)) || FAILED(hr=CheckPinInGraph(ppinIn))) {
        return hr;
    }
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);

    #ifdef DEBUG
        // See if the filters have been added to the graph.  Forestall AVs later.
        PIN_INFO pi;
        ppinOut->QueryPinInfo(&pi);
        ASSERT(mFG_FilGenList.GetByFilter(pi.pFilter));
        QueryPinInfoReleaseFilter(pi);

        ppinIn->QueryPinInfo(&pi);
        ASSERT(mFG_FilGenList.GetByFilter(pi.pFilter));
        QueryPinInfoReleaseFilter(pi);
    #endif

        mFG_RList.Active();
        hr = ConnectDirectInternal(ppinOut, ppinIn, pmt);
        IncVersion();
        AttemptDeferredConnections();
        mFG_RList.Passive();
    }

    // outside lock, notify change
    NotifyChange();

    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    }
    return hr;
} // ConnectDirect



//========================================================================
//
// ConnectDirectInternal
//
// ConnectDirect without increasing the version count and hence
// without breaking the filter enumerator (also without any more locking)
//========================================================================

HRESULT CFilterGraph::ConnectDirectInternal
    ( IPin * ppinOut,    // the output pin
      IPin * ppinIn,     // the input pin
      const AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr;
    DbgLog(( LOG_TRACE, 3, TEXT("ConnectDirectInternal pins %x-->%x")
           , ppinOut,ppinIn ));
#ifdef TIME_CONNECTS
    DWORD dwTime = timeGetTime();
#endif
#if 0
    PIN_INFO piIn, piOut;
    WCHAR sz[257];
    sz[0] = L'0';

    GetFilterName(ppinOut, sz);
    int i = lstrlenWInternal(sz);
    lstrcpyWInternal(sz + i, L" to ");
    GetFilterName(ppinIn, sz + i + 4);

    CAutoTimer Timer(L"ConnectDirectInternal ", sz);
#else
    CAutoTimer Timer(L"ConnectDirectInternal ", NULL);
#endif
    MSR_START(mFG_PerfConnectDirect);
    if (IsUpstreamOf(ppinIn, ppinOut)) {
        hr = VFW_E_CIRCULAR_GRAPH;
    } else {
        hr = ppinOut->Connect(ppinIn, pmt);
    }
    MSR_STOP(mFG_PerfConnectDirect);
#ifdef TIME_CONNECTS
    dwTime = timeGetTime() - dwTime;
    TCHAR szOutput[500];
    wsprintf(szOutput, TEXT("Time to connect %s to %s was %d ms\r\n"),
           (LPCTSTR)CDisp(ppinOut), (LPCTSTR)CDisp(ppinIn), dwTime);
    OutputDebugString(szOutput);
#endif

    if (SUCCEEDED(hr)) {
#ifdef DEBUG
        /*  Check out the connection */
        TestConnection(ppinIn, ppinOut);
#endif
        DbgLog(( LOG_TRACE, 2, TEXT("ConnectDirectInternal succeeded pins %x==>%x")
               , ppinOut,ppinIn ));
    }

#ifdef PERF
    if (FAILED(hr)) {
        MSR_NOTE(mFG_idConnectFail);
    }

    {   // bung out something of the clsid of the two filters so that
        // we can see what went on in the log
        PIN_INFO pi;
        ppinIn->QueryPinInfo(&pi);
        IPersist * piper;

        pi.pFilter->QueryInterface(IID_IPersist,(void**)&piper);
        QueryPinInfoReleaseFilter(pi);

        if (piper) {
            CLSID clsidFilter;
            piper->GetClassID(&clsidFilter);
            piper->Release();
            MSR_INTEGER(mFG_idIntel, clsidFilter.Data1);

            ppinOut->QueryPinInfo(&pi);

            pi.pFilter->QueryInterface(IID_IPersist,(void**)&piper);
            QueryPinInfoReleaseFilter(pi);

            piper->GetClassID(&clsidFilter);
            piper->Release();
            MSR_INTEGER(mFG_idIntel, clsidFilter.Data1);
        }
    }
#endif PERF
    return hr;
} // ConnectDirectInternal



//========================================================================
//
// Disconnect
//
// Disconnect this pin, if connected.  Successful no-op if not connected.
// Does not hit the version.  No change in sort order, enumerator not broken.
//========================================================================

STDMETHODIMP CFilterGraph::Disconnect( IPin * ppin )
{
    CheckPointer(ppin, E_POINTER);
    CAutoMsgMutex cObjectLock(&m_CritSec);

    HRESULT hr = ppin->Disconnect();
    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    } else {
        #ifdef DEBUG
        {
            IPin* pConnectedPin;

            HRESULT hrDebug = ppin->ConnectedTo(&pConnectedPin);
            if (SUCCEEDED(hrDebug) && (NULL != pConnectedPin)) {
                // Make sure the filter graph's state is consistent if
                // a disconnect fails.  In particular, we want to detect
                // the situation were one pin 1 thinks it's connected to 
                // pin 2 but pin 2 thinks it is not connected.  This case
                // can occur if pin 2 is successfully disconnected but 
                // pin 1 refuses to disconnect.
                TestConnection(ppin, pConnectedPin);
            }
        }
        #endif DEBUG
    }
    return hr;
} // Disconnect



//========================================================================
//
// Reconnect
//
// Break the connection that this pin has and reconnect it to the
// same other pin.
// Dogma:
//     A filter must not request a Reconnect unless it knows it will succeed.
//========================================================================

STDMETHODIMP CFilterGraph::Reconnect( IPin * pPin )
{

    return CFilterGraph::ReconnectEx(pPin, NULL);

} // Reconnect

//========================================================================
//
// ReconnectEx
//
// Break the connection that this pin has and reconnect it to the
// same other pin.
// Dogma:
//     A filter must not request a Reconnect unless it knows it will succeed.
//========================================================================

STDMETHODIMP CFilterGraph::ReconnectEx( IPin * pPin, AM_MEDIA_TYPE const *pmt )
{
    CheckPointer(pPin, E_POINTER);
    CAutoMsgMutex cObjectLock(&m_CritSec);

    HRESULT hr = S_OK;

    // Legacy filters may have called Reconnect() when running and
    // failed previously. Now that some filters may disconnect while
    // running, one pin may disconnect but another may fail leaving
    // things in an unrecoverable inconsistent state. So restrict
    // Reconnect() to filters that are stopped.
    if(m_State != State_Stopped)
    {
        PIN_INFO pi;
        FILTER_STATE fs;

        hr = pPin->QueryPinInfo(&pi);
        if(SUCCEEDED(hr))
        {
            // bug to call Reconnect with pin not in graph.
            ASSERT(pi.pFilter);

            hr = pi.pFilter->GetState(0, &fs);
            pi.pFilter->Release();
        }
        if(hr == S_OK && fs != State_Stopped ||
           hr == VFW_S_STATE_INTERMEDIATE)
        {
            hr = VFW_E_WRONG_STATE;
        }

        if(FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("CFilterGraph::ReconnectEx: graph state %d, filter state %d"),
                    m_State, fs));
        }
    }
    if(SUCCEEDED(hr)) {
        hr = mFG_RList.Schedule(pPin, pmt);
    }

    return hr;

} // Reconnect



//========================================================================
//
// AddSourceFilter
//
// Add to the filter graph a source filter for this file.  This would
// be the same source filter that would be added by calling Render.
// This call permits you to get then have more control over building
// the rest of the graph, e.g. AddFilter(<a renderer of your choice>)
// and then Connect the two.
// It returns a RefCounted filter iff it succeeds.
//========================================================================

STDMETHODIMP CFilterGraph::AddSourceFilter
    ( LPCWSTR lpcwstrFileName,
      LPCWSTR lpcwstrFilterName,
      IBaseFilter **ppFilter
    )
{
    CheckPointer(ppFilter, E_POINTER);

    HRESULT hr;
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        ++mFG_RecursionLevel;
        BOOL bGuess;
        hr = AddSourceFilterInternal( lpcwstrFileName
                                    , lpcwstrFilterName
                                    , ppFilter
                                    , bGuess
                                    );
        --mFG_RecursionLevel;
    }

    if (SUCCEEDED(hr)) {
        NotifyChange();
    }
    return hr;
} // AddSourceFilter


// Add a source filter for the given moniker to the graph
// We first try BindToStorage and if this fails we try
// BindToObject
STDMETHODIMP CFilterGraph::AddSourceFilterForMoniker(
      IMoniker *pMoniker,          // Moniker to load
      IBindCtx *pCtx,              // Bind context
      LPCWSTR lpcwstrFilterName,   // Add the filter as this name
      IBaseFilter **ppFilter       // resulting IBaseFilter* "handle"
                                   // of the filter added.
)
{
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    HRESULT hr = S_OK;
    IBaseFilter *pFilter = NULL;
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        ++mFG_RecursionLevel;

        //  Try BindToStorage via our URL reader filter (should do
        //  regular IStream too)
        hr = CreateFilter(&CLSID_URLReader, &pFilter);

        if (SUCCEEDED(hr)) {
            IPersistMoniker *pPersistMoniker;
            //  Try the Load method on it's IPersistMoniker
            hr = pFilter->QueryInterface(
                     IID_IPersistMoniker,
                     (void **)&pPersistMoniker);

            if (SUCCEEDED(hr)) {
                hr = AddFilter(pFilter, lpcwstrFilterName);
            }

            if (SUCCEEDED(hr)) {
                hr = pPersistMoniker->Load(
                                FALSE,    //  Always want async open
                                pMoniker, //  Our Moniker
                                pCtx,     //  Can the bind context be NULL?
                                0);       //  What should it be?
                pPersistMoniker->Release();
                if (FAILED(hr)) {
                    RemoveFilterInternal(pFilter);
                }
            }
            if (FAILED(hr)) {
                pFilter->Release();
                pFilter = NULL;
            }
        }

        //  If the URL reader can't open it try to create a filter object
        if (FAILED(hr)) {
            IBindCtx *pSavedCtx = m_lpBC;
            m_lpBC = pCtx;
            hr = CreateFilter(pMoniker, &pFilter);
            m_lpBC = pSavedCtx;
            if (SUCCEEDED(hr)) {
                hr = AddFilter(pFilter, lpcwstrFilterName);
            }
        }

        if (SUCCEEDED(hr)) {
            ASSERT(pFilter != NULL);
            NotifyChange();
            *ppFilter = pFilter;
        } else {
            if (pFilter != NULL) {
                pFilter->Release();
            }
        }

        --mFG_RecursionLevel;
    }

    return hr;
}

//====================================================================
//
//   RenderEx
//
//   Render extended
//
//    AM_RENDEREX_RENDERTOEXISTINGRENDERERS :
//       Try to pPinOut this pin without adding any renderers
//
//====================================================================

STDMETHODIMP CFilterGraph::RenderEx(
    IPin *pPinOut,
    DWORD dwFlags,
    DWORD * pvContext
)
{
    if (pvContext != NULL ||
        (dwFlags & ~AM_RENDEREX_RENDERTOEXISTINGRENDERERS)) {
        return E_INVALIDARG;
    }
    CAutoMsgMutex cObjectLock(&m_CritSec);
    ASSERT(!mFG_bNoNewRenderers);
    if (dwFlags & AM_RENDEREX_RENDERTOEXISTINGRENDERERS) {
        mFG_bNoNewRenderers = true;
    }
    HRESULT hr = Render(pPinOut);
    mFG_bNoNewRenderers = false;
    return hr;
}



//========================================================================
//
// AddSourceFilterInternal
//
// Does the work for AddSourceFilter (see above)
// Does NOT call NotifyChange either directly or indirectly.
// Does not claim its own lock (expects to be locked already)
//========================================================================

HRESULT CFilterGraph::AddSourceFilterInternal
    ( LPCWSTR lpcwstrFileName,
      LPCWSTR lpcwstrFilterName,
      IBaseFilter **ppFilter,
      BOOL    &bGuessingSource
    )
{
    HRESULT hr;                     // return code from stuff we call
    bGuessingSource = FALSE;

    IBaseFilter * pf;                   // We return this (with luck)

    ASSERT(CritCheckIn(&m_CritSec));      // we expect to have already been locked.

    // At this point, it could be a filename or it could be a URL.
    // if it's a URL, and it begins with "file://" or "file:", strip that off.
    // yes, this is ugly, but it's better than implementing a general routine
    // just for here.
    LPCWSTR lpcwstr = lpcwstrFileName;
    if (  (lpcwstrFileName[0] == L'F' || lpcwstrFileName[0] == L'f')
       && (lpcwstrFileName[1] == L'I' || lpcwstrFileName[1] == L'i')
       && (lpcwstrFileName[2] == L'L' || lpcwstrFileName[2] == L'l')
       && (lpcwstrFileName[3] == L'E' || lpcwstrFileName[3] == L'e')
       && (lpcwstrFileName[4] == L':')
       ) {
    // HACK: skip 'file://' at beginning of URL

    lpcwstr += 5;
    while (lpcwstr[0] == L'/')
        lpcwstr++;  // skip however many slashes are present next
    }

    //-----------------------------------------------------------------------
    //  See if we can find out what type of file it is
    //-----------------------------------------------------------------------
    GUID Type, Subtype;
    CLSID  clsidSource;
    CMediaType mt;
#ifdef UNICODE
    hr = GetMediaTypeFile(lpcwstr, &Type, &Subtype, &clsidSource);
#else
    {
        int iLen = lstrlenW(lpcwstr) * 2 + 1;
        char *psz = new char[iLen];
        if (psz == NULL) {
            return E_OUTOFMEMORY;
        }
        if (0 == WideCharToMultiByte(CP_ACP, 0, lpcwstr, -1,
                                     psz, iLen, NULL, NULL)) {
            delete [] psz;
            return E_INVALIDARG;
        }
        hr = GetMediaTypeFile(psz, &Type, &Subtype, &clsidSource);
        delete [] psz;
    }
#endif

    // if we guess at the file source, remember this for error-reporting later

    if (hr==VFW_E_UNKNOWN_FILE_TYPE) {
        Log( IDS_UNKNOWNFILETYPE );
        clsidSource = CLSID_AVIDoc;
        bGuessingSource = TRUE;
    } else if (FAILED(hr)) {
        //  If we couldn't open as a file and it wasn't 'file:'
        //  then try creating a moniker and using that
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ||
            HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr ||
            HRESULT_FROM_WIN32(ERROR_INVALID_NAME) == hr) {

            // !!!Hack: AMGetError does not know file-not-found so give it an
            // error it does know
            hr = VFW_E_NOT_FOUND;
        }
        Log ( IDS_GETMEDIATYPEFAIL, hr);

        return hr;
    } else {
        if (Type==MEDIATYPE_Stream && Subtype==CLSID_NULL) {
            // This seems to be how Robin's stuff now reports a guess.
            bGuessingSource = TRUE;
        }

        mt.SetType(&Type);
        mt.SetSubtype(&Subtype);
        Log ( IDS_MEDIATYPEFILE, Type.Data1, Subtype.Data1);
    }

    Log( IDS_SOURCEFILTERCLSID, clsidSource.Data1);

    //-----------------------------------------------------------------------
    // Load the source filter (it will have 1 RefCount)
    //-----------------------------------------------------------------------
    hr = CreateFilter( &clsidSource, &pf );
    if (FAILED(hr)) {
        Log( IDS_SOURCECREATEFAIL, hr);
        if (bGuessingSource) {
            hr = VFW_E_UNKNOWN_FILE_TYPE;
        } else if (hr!=CO_E_NOTINITIALIZED) {
            hr = VFW_E_CANNOT_LOAD_SOURCE_FILTER;
        }
        return hr;
    }


    //-----------------------------------------------------------------------
    // If it has an IFileSourceFilter then load the file
    //-----------------------------------------------------------------------
    IFileSourceFilter * pFileSource;
    hr = pf->QueryInterface(IID_IFileSourceFilter, (void**) &pFileSource);
    if (FAILED(hr)){
        // we need this to open the file - give up
        Log( IDS_NOSOURCEINTFCE, hr);
        pf->Release();
        return hr;
    }

    // Add filter to our graph lists.  This also adds a ref-count
    // and increments the version count.
    // Note - we used to erroneously set the filter name to the file
    // name - now only do this if a filter name wasn't supplied

    hr = AddFilterInternal( pf,
                            lpcwstrFilterName == NULL ? lpcwstr : lpcwstrFilterName,
                            false );
    if (FAILED(hr)) {
        // If AddRef failed this will reduce it to zero and it will go away.
        Log( IDS_ADDFILTERFAIL, hr );
        pFileSource->Release();
        pf->Release();
        return hr;
    }

    //-----------------------------------------------------------------------
    // Ask the source to load the file
    //-----------------------------------------------------------------------

    // if we don't know the media type (either we guessed at avi above,
    // or the registry had a clsid but not the media type), then pass null
    // pointers, *not* a pointer to GUID_NULL
    if (*mt.Type() == GUID_NULL) {
        hr = pFileSource->Load(lpcwstr, NULL);
    } else {
        hr = pFileSource->Load(lpcwstr, &mt);
    }
    pFileSource->Release();
    if (FAILED(hr)) {
        // load failed, remove filter from graph.
        RemoveFilterInternal(pf);

        pf->Release();

        Log( IDS_LOADFAIL, hr);

        // try to preserve interesting errors (eg. ACCESS_DENIED)
        if (bGuessingSource && (HRESULT_FACILITY(hr) == FACILITY_ITF)) {
            hr = VFW_E_UNKNOWN_FILE_TYPE;
        }
        return hr;

    }
    Log (IDS_LOADED );

    IncVersion();
    mFG_RList.Active();
    AttemptDeferredConnections();
    mFG_RList.Passive();


    // If AddRef succeeded, AddRef will have added its own count, making two.
    // That's one for the caller and one for us.
    *ppFilter = pf;

    Log( IDS_ADDSOURCEOK );
    mFG_bDirty = TRUE;
    return NOERROR;
} // AddSourceFilterInternal



//========================================================================
//
// SetSyncSource
//
// Override the IMediaFilter SetSyncSource
// Set this as the reference clock for all filters that are,
// or ever will be, in the graph.
// return NOERROR if it worked, or the result from the first IMediaFilter
// that went wrong if it didn't
//
// You are not allowed to add or remove clocks unless the graph is STOPPED
// Attempts to do so return E_VFW_NOT_STOPPED and have no effect.
// Otherwise AddReffing and Releasing is done as follows:
// The old clock (unless null) is Released
// The new clock (unless null) is AddRefed.
//
// DO NOT call with m_pClock as its parameter!!
//========================================================================

STDMETHODIMP CFilterGraph::SetSyncSource( IReferenceClock * pirc )
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    HRESULT hr = NOERROR;

#if 0
    if ((m_pClock==NULL || pirc==NULL) && m_State!=State_Stopped) {
        // ASSERT(!"Clocks can only be added or removed when stopped");
        return VFW_E_NOT_STOPPED;
        // can we not do this while paused?  i.e. m_State!=State_Running ???
    }
#endif

    if (m_State!=State_Stopped && m_pClock != pirc ) 
    {
        //
        // In order to support dynamic clock changes we need a more complete solution,
        // especially a way to query filters up front whether they support switching the
        // clock while running, otherwise we get into all kinds of problems with filters
        // being in inconsistent clock states. 
        //
        // So we'll only allow clock changes while stopped.
        //
        return VFW_E_NOT_STOPPED;
    }



    //-----------------------------------------------------------------
    // If the list was not in upstream order already, make it so now.
    // ??? Do we need to do this?
    //-----------------------------------------------------------------

    hr = UpstreamOrder();
    if( FAILED( hr ) ) {
        return hr;
    }

    if (pirc!=NULL) {
        pirc->AddRef();
        mFG_bNoSync = FALSE;
    } else {
        mFG_bNoSync = TRUE;
    }

    // tell the distributor about the new clock
    mFG_pFGC->SetSyncSource(pirc);
    if (mFG_pDistributor) mFG_pDistributor->SetSyncSource(pirc);


    //-----------------------------------------------------------------
    // If somebody is switching the clocks on the fly then we need to
    // change the base times.  If the thing is running, then I think
    // the two clocks had pretty much better be in sync already???
    //-----------------------------------------------------------------

    if (m_State!=State_Stopped) {
       ASSERT (m_pClock !=NULL);
       CRefTime tOld;
       m_pClock->GetTime((REFERENCE_TIME*)&tOld);
       CRefTime tNew;
       pirc->GetTime((REFERENCE_TIME*)&tNew);

       mFG_tBase += (tNew-tOld);
       if (m_State==State_Paused) {
           mFG_tPausedAt += (tNew-tOld);
       }
       else // ??? I have no idea!!
          ;

    }

    // We've now finished with the old clock
    if (m_pClock!=NULL) {
        m_pClock->Release();
        m_pClock = NULL;
    }

    //-----------------------------------------------------------------
    // Record the sync source for all future filters
    //-----------------------------------------------------------------
    m_pClock = pirc;        // Set our clock (the one we inherited from IMediaFilter)
                            // This could set it to NULL

    //-----------------------------------------------------------------
    // Set the sync source for all filters already in the graph
    //-----------------------------------------------------------------

    TRAVERSEFILTERS( pCurrentFilter )

        HRESULT hr1;

        hr1 = pCurrentFilter->SetSyncSource(m_pClock);

        if (FAILED(hr1) && hr==NOERROR) {
            hr = hr1;
            // note: for these loop operations whereby each error
            // overwrites the next it might be good to write to the
            // event log so that we can see all the errors that
            // occurred.
        }

    ENDTRAVERSEFILTERS()

    // Tell the app that we're doing it
    IMediaEventSink * pimes;
    QueryInterface(IID_IMediaEventSink, (void**)&pimes);
    if (pimes) {
        pimes->Notify(EC_CLOCK_CHANGED, 0, 0);
        pimes->Release();
    }

    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    }

    return hr;

} // SetSyncSource


STDMETHODIMP CFilterGraph::GetSyncSource( IReferenceClock ** pirc )
{
    if (mFG_bNoSync) {
        *pirc = NULL;
        return S_FALSE;
    } else {
        *pirc = m_pClock;

        // Returning an interface. Need to AddRef it.
        if( m_pClock )
            m_pClock->AddRef();
        return S_OK;
    }
}

//=====================================================================
//
// Stop
//
// Set all the filters in the graph to Stopped
//=====================================================================

STDMETHODIMP CFilterGraph::Stop(void)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    // Don't stop if we're already stopped
    if (m_State == State_Stopped) {
        return S_OK;
    }

    // tell the distributor that we are stopping
    mFG_pFGC->Stop();
    if (mFG_pDistributor) mFG_pDistributor->Stop();

    CumulativeHRESULT chr(S_OK);

    // Call Stop on each filter in the list, in upstream order.

    // If the list was not in upstream order already, make it so now.
    chr.Accumulate( UpstreamOrder() );


    // Since reconnections only take place when stopped many filters defer
    // sending them until stopped. So we should queue them all up and then
    // when everyone is stopped process all entries on the queue. Otherwise
    // a thread may be spun off which by the time it gets in to do anything
    // has found that that application decided to rewind and pause us again

    mFG_RList.Active();

    TRAVERSEFILTERS( pCurrentFilter )

        chr.Accumulate( pCurrentFilter->Stop() );

    ENDTRAVERSEFILTERS()

    mFG_tPausedAt = CRefTime((LONGLONG)0);
    mFG_tBase = CRefTime((LONGLONG)0);

    // only S_OK indicates a completed transition,
    // but we can say what state we are transitioning into
    m_State = State_Stopped;
    mFG_RList.Passive();

    return chr;

} // Stop



//=====================================================================
//
// Pause
//
// Set all the filters in the graph to Pause
//=====================================================================

STDMETHODIMP CFilterGraph::Pause(void)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);
    HRESULT hr;

    if (m_State==State_Stopped) {
        // Last ditch go to make the graph complete.
        mFG_RList.Active();
        AttemptDeferredConnections();
        mFG_RList.Passive();
    } else if (m_State == State_Paused) {
        return S_OK;
    }


    // If the list was not in upstream order already, make it so now.
    hr = UpstreamOrder();
    if (FAILED(hr)) {
        return hr;    // e.g. VFW_E_CIRCULAR_GRAPH
    }

    // Pause can be a way to become active from stopped.
    // mustn't do this without a clock.
    if (m_pClock==NULL && !mFG_bNoSync) {
        hr = SetDefaultSyncSource();
        if (FAILED(hr)) return hr;
    }

    if( mFG_bSyncUsingStreamOffset && m_State != State_Running )
        hr = SetStreamOffset(); // continue even on error?

    // tell the distributor that we are pausing
    mFG_pFGC->Pause();
    if (mFG_pDistributor) mFG_pDistributor->Pause();

    // Now that we have a clock we can ask it the time.
    // we only really need this if we are paused from running?
    if (m_pClock!=NULL) {
        // Does PAUSE even really mean much when not synched?

        // tPausedAt is only nonzero when we are paused. We should
        // set it to the time we first paused. If we pause again, then
        // we should leave it alone. We can't check state to see if we
        // are paused since it might be intermediate
        if (mFG_tPausedAt == TimeZero) {
            hr = m_pClock->GetTime((REFERENCE_TIME*)&mFG_tPausedAt);
            ASSERT (SUCCEEDED(hr) );
        }

        // if pausing from stopped, set base time to pausedat time to
        // show that we have paused at stream time 0
        if (m_State==State_Stopped) {
           mFG_tBase = mFG_tPausedAt;
        }
    }

    // Tell all the lower level filters to Pause.

    CumulativeHRESULT chr(S_OK);
    BOOL bAsync = FALSE;
    TRAVERSEFILTERS( pCurrentFilter )

        hr = pCurrentFilter->Pause();
        chr.Accumulate( hr );
        // If Pause was Async, record the fact
        if (hr == S_FALSE) bAsync = TRUE;
        if (FAILED(hr)) {
#ifdef DEBUG
            CLSID clsid;
            pCurrentFilter->GetClassID(&clsid);

            FILTER_INFO finfo;
            finfo.achName[0] = 0;
            IBaseFilter *pbf;
            if (pCurrentFilter->QueryInterface(IID_IBaseFilter, (void **)&pbf) == S_OK)
            {
                if (SUCCEEDED(pbf->QueryFilterInfo(&finfo)))
                {
                    finfo.pGraph->Release();
                }
                pbf->Release();
            }

            WCHAR wszCLSID[128];
            QzStringFromGUID2(clsid,wszCLSID,128);

            DbgLog((LOG_ERROR, 0, TEXT("filter %8.8X '%ls' CLSID %ls failed pause, hr=%8.8X"),
                   pCurrentFilter, finfo.achName, wszCLSID, hr));

#endif
            break;
        }

    ENDTRAVERSEFILTERS()
    hr = chr;


    // If the pause is async, return S_FALSE in preference
    // to any other non-failure return code.
    if (bAsync && SUCCEEDED(hr)) hr = S_FALSE;

    m_State = State_Paused;
    // only S_OK means a completed transition

    // Go back to stopped state if we failed
    // (but set the state otherwise Stop will NOOP)
    if (FAILED(hr)) {
        Stop();
    }

    return hr;

} // Pause



//===============================================================
//
// SetDefaultSyncSource
//
// Instantiate the default clock and tell all filters.
//
// The default clock is the first connected filter that we see
// doing the standard enumeration of filters.  If no connected
// filters are found we will use a clock from an unconnected
// filter.  If none of those, then we create a system clock.
//===============================================================


// First, two utility routines...

// Get the first (in the standard enumeration sequence) input pin
// from a filter
IPin* GetFirstInputPin (IBaseFilter *pFilter);

// returns TRUE if filter is connected
//         FALSE if filter is not connected
//
// "connected" is defined to be "The first input pin IsConnected()".
//
BOOL IsFilterConnected(IBaseFilter *pInFilter);

// TRUE: this filter is connected
// FALSE: no its not
//
// "connected" means that it has an input pin that is
// connected to another pin. We only check one level.

BOOL IsFilterConnected(IBaseFilter *pInFilter)
{

    HRESULT hr ;
    IPin *pPin1, *pPin2 ;

    // get the input pin.
    pPin1 = GetFirstInputPin (pInFilter) ;
    if (pPin1 == NULL)
    {
        return FALSE; // not going anywhere
    }

    // get the connected to pin for this pin
    hr = pPin1->ConnectedTo (&pPin2) ;

    pPin1->Release();

    if (pPin2) {
        /*  Connected - return TRUE */
        pPin2->Release () ;
        return TRUE;
    } else {
        return FALSE;
    }
}

// return the first input pin on this filter
// NULL if no input pin.
IPin* GetFirstInputPin (IBaseFilter *pFilter)
{
    return CEnumPin(pFilter, CEnumPin::PINDIR_INPUT)();
}

//
// Determine the timestamp offset to use for all filters that support
// IAMPushSource.
//
HRESULT CFilterGraph::SetStreamOffset(void)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);
    HRESULT hr;

    // for now don't allow changes while running
    if (m_State==State_Running) {
        ASSERT("FALSE");
        return VFW_E_NOT_STOPPED;
    }
    REFERENCE_TIME rtMaxLatency = 0;
    PushSourceList lstPushSource( TEXT( "IAMPushSource filter list" ) );
    hr = BuildPushSourceList( lstPushSource, TRUE, FALSE ); // only include connected filters!
    //
    // now go through the push source list and find the max offset time
    // (we really need to do this per filter chain and accumulate the
    // latency via IAMLatency for each chain). Note that at this
    // time we do this independent of filter connections.
    //
    if( SUCCEEDED( hr ) )
    {
        rtMaxLatency = GetMaxStreamLatency( lstPushSource );

        // now go through the list we built and set the offset times based on
        // the max stream latency value
        for ( POSITION Pos = lstPushSource.GetHeadPosition(); Pos; )
        {
            PushSourceElem *pElem = lstPushSource.GetNext(Pos);
            if( pElem->pips )
                hr = pElem->pips->SetStreamOffset( rtMaxLatency );

            ASSERT( SUCCEEDED( hr ) );
        }
    }
    DeletePushSourceList( lstPushSource );
    return hr;

} // SetStreamOffset


//
// Find and set a default sync source for this filter graph
//

STDMETHODIMP CFilterGraph::SetDefaultSyncSource(void)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);
    HRESULT hr;

    // Get rid of this case before we change any flags or anything.
    if (m_State==State_Running) {
        DbgBreak("Clocks can only be added or removed when stopped");
        return VFW_E_NOT_STOPPED;
        // can we not do this while paused?  i.e. m_State!=State_Running
        // ??? Trying this out!
    }

    IReferenceClock * pClock;

    // check for IAMPushSources
    PushSourceList lstPushSource( TEXT( "IAMPushSource filter list" ) );
    hr = BuildPushSourceList( lstPushSource, TRUE, TRUE ); // only include connected filters!
                                                           // check for push clocks
    IReferenceClock * pPushClock = NULL;
    BOOL bLiveSource = FALSE;
    for ( POSITION Pos = lstPushSource.GetHeadPosition(); Pos; )
    {
        PushSourceElem *pElem = lstPushSource.GetNext(Pos);
        if( pElem->pClock && !pPushClock )
        {
            pPushClock = pElem->pClock;
            pPushClock->AddRef(); // keep a hold on this clock
        }
        else if( 0 == ( pElem->ulFlags & AM_PUSHSOURCECAPS_NOT_LIVE ) )
        {
            // if the source mode is any other mode then it must be live
            bLiveSource = TRUE;
        }
    }
    DeletePushSourceList( lstPushSource );

    IReferenceClock * pirc = NULL;
    IReferenceClock * pircUnconnected = NULL;

    if( pPushClock )
    {
        // there's an IAMPushSource filter that supports a clock, use the 1st one
        // of those that we find
        pirc = pPushClock;
    }
    else if ( !bLiveSource )
    {
        CFilGenList::CEnumFilters Next(mFG_FilGenList);
        IBaseFilter *pf;
        while ((PVOID) (pf = ++Next)) {
            hr = pf->QueryInterface( IID_IReferenceClock, (void**)(&pirc) );

            if (SUCCEEDED(hr)) {
                if (IsFilterConnected(pf)) {
                    DbgLog((LOG_TRACE, 1, TEXT("Got clock from filter %x %ls")
                      , pf, (mFG_FilGenList.GetByFilter(pf))->pName));
                    break;
                }
                if (!pircUnconnected) {
                    // this is the first unconnected filter that is
                    // willing to provide a reference clock
                    pircUnconnected = pirc;
                } else {
                    // This filter is not connected, and we already have a
                    // clock from an unconnected filter.  Throw this one away.
                    pirc->Release();
                }

                pirc = NULL;

                // do not exit the loop with pircUnconnected==pirc.  We have
                // either stored pirc into pircUnconnected and will release
                // the reference count on it later, or we have already released
                // pirc.  Either way we must set pirc to null in case we exit
                // the loop now.
            }
        }
    }
    // else there's a live IAMPushSource filter in the graph, but no source clock
    // so we'll default to the system clock

    // This gets the clock from the first filter that responds with the interface.
    // We should probably do something to check if there is more than one clock
    // present in the system.  (Like construct a list of all the clocks, pass that
    // list to all the clocks, and get each to give themselves a priority number.  At
    // the end the first highest priority wins.  This would also allow something like
    // the audio renderer which has to be the system clock (or so it thinks) to use
    // an external system clock and not system time in those periods when wave data
    // is not being played.)

    // if we found a clock on an unconnected filter, and it was the only
    // clock, we will use that one.  If it was not the only clock we need
    // to release the clock on the unconnected filter.
    if (pircUnconnected) {
        if (!pirc) {
            pirc = pircUnconnected;
        } else {
            pircUnconnected->Release();
        }
    }

    if (pirc == NULL) {
        // alternatively, get a system clock
        hr = QzCreateFilterObject( CLSID_SystemClock, NULL, CLSCTX_INPROC
                                 , IID_IReferenceClock, (void **)&pirc);
        if (FAILED(hr))
            return hr;
        DbgLog((LOG_TRACE, 1, TEXT("Created system clock")));
    }

    // This has a side effect on m_pClock.  Do NOT have m_pClock as its parameter
    // it causes bugs
    hr = SetSyncSource(pirc);

    // SetSync source will have either failed (in which case it doesn't
    // need to keep the new clock around any more) or AdReffed the new clock.
    // Either way we can now get rid of the RefCount that we got from either
    // QueryInterface or CoCreateInstance

    pirc->Release();

    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    }
    return hr;

} // SetDefaultSyncSource



//=====================================================================
//
// Run
//
// Set all the filters in the graph to Run from their current position.
//
// tStart is the base time i.e. (presentation time - stream time) which is
// the reference time for the zeroth sample to be rendered.
//
// The filter graph remembers the base time.  Supplying a base time of
// zero means "continue with the one you knew".
//
// e.g. at reference ("wall clock") time Tr we wish to start running
// from a point in the Ts after the start.  In that case we should
// seek to the point Ts and Pause then Run(Ts-Ts).
//=====================================================================

STDMETHODIMP CFilterGraph::Run(REFERENCE_TIME tStart)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    if (m_State == State_Running) {
        return S_OK;
    }

    HRESULT hr = NOERROR;
    // If the list was not in upstream order already, make it so now.
    hr = UpstreamOrder();
    if (FAILED(hr)) {
        return hr;    // e.g. VFW_E_CIRCULAR_GRAPH
    }


    // mustn't become active without a clock.
    if (m_pClock==NULL && !mFG_bNoSync) {
        hr = SetDefaultSyncSource();
        if (FAILED(hr))
        {
            return hr;
        }
    }


    // If we are restarting from paused then we set the time base on by
    // the length of time we were paused for.  Starting from paused is
    // assumed to be very quick, so we do not add any extra.  If we are
    // starting from cold then we add an extra 100mSec.  Since a stopped
    // system has a PausedAt and Base time of zero, the calculation is
    // otherwise the same.

    if (CRefTime(tStart) == CRefTime((LONGLONG)0) ) {
        CRefTime tNow;
        if (m_pClock!=NULL) {
            hr = m_pClock->GetTime((REFERENCE_TIME*)&tNow);
        } else {
            tNow = CRefTime((LONGLONG)0);
        }

        ASSERT (SUCCEEDED(hr));

        mFG_tBase += (tNow - mFG_tPausedAt);

        // if we are stopped, allow a little time for warm-up.  100mSec?
        if (m_State==State_Stopped)
            mFG_tBase += CRefTime(MILLISECONDS_TO_100NS_UNITS(100));

        // even starting from paused takes a little while - another 100mSec?
        mFG_tBase += CRefTime(MILLISECONDS_TO_100NS_UNITS(100));
    }
    else mFG_tBase = CRefTime(tStart);

    mFG_tPausedAt = CRefTime((LONGLONG)0);  // we are no longer paused

    // set the start time in the base class so that StreamTime (and hence
    // get_CurrentPosition) works correctly
    m_tStart = mFG_tBase;

    // tell the distributor that we are running
    mFG_pFGC->Run(mFG_tBase);
    if (mFG_pDistributor) mFG_pDistributor->Run(mFG_tBase);

#ifdef DEBUG
    BOOL fDisplayTime=FALSE;
    DbgLog((LOG_TIMING,1,TEXT("Time for RUN: %d ms"), m_tStart.Millisecs()));
    CRefTime CurrentTime;
    // Display the current time from the clock - if we have one and if
    // we are logging timing calls.
    if (m_pClock && DbgCheckModuleLevel(LOG_TIMING,1)) {
        fDisplayTime=TRUE;
        m_pClock->GetTime((REFERENCE_TIME*)&CurrentTime);
        DbgLog((LOG_TIMING,1,TEXT("time before distribution %d ms"),CurrentTime.Millisecs()));
    }
#endif

    // Distribute Run at high priority so filters that start processing
    // don't delay others getting started
    HANDLE hCurrentThread = GetCurrentThread();
    DWORD dwPriority = GetThreadPriority(hCurrentThread);
    SetThreadPriority(hCurrentThread, THREAD_PRIORITY_TIME_CRITICAL);

    // Tell all the filters about the change in upstream order
    // Note that this means that we start the renderers first.
    // ??? should we actually add a bit of time.

    CumulativeHRESULT chr(S_OK);
    TRAVERSEFILTERS( pCurrentFilter )

        chr.Accumulate( pCurrentFilter->Run(mFG_tBase) );

    ENDTRAVERSEFILTERS()
    hr = chr;

    SetThreadPriority(hCurrentThread, dwPriority);

#ifdef DEBUG
    // Display the current time from the clock - if we have one
    if (fDisplayTime) {
        CRefTime TimeNow;
        m_pClock->GetTime((REFERENCE_TIME*)&TimeNow);
        CurrentTime = TimeNow - CurrentTime;
        DbgLog((LOG_TIMING,1,TEXT("time after distribution %d ms (diff %d ms)"),TimeNow.Millisecs(), CurrentTime.Millisecs()));
    }
#endif

    // only S_OK means a completed transition
    m_State = State_Running;

    return hr;

} // Run

// override this to handle async state change completion
// we need to allow state changes during this - we can't hold the
// fg critsec. (eg if blocked waiting for a state transition to complete
// and an error occurs, the app has to be able to stop the graph.
//
// So we hold the critsec while traversing the list of filters, calling
// GetState with no timeout. If we find one that we need to block for, we
// hold that IMediaFilter*, but exit the traversal and exit the critsec, then
// block on the GetState. Then we start from the beginning of the list again.
//
// Many filters will transition through paused on their way between stopped
// and running.  We try to regard this as an "intermediate" condition and re-query
// the filters (after a small delay) in the hope of retrieveing a consistant
// state.
//
// !!! note that if a filter completes in a non-zero time, we should knock
// this amount off the total for the next timeout. It's a small point though
// since the scheduling of the thread could easily account for the difference.
STDMETHODIMP
CFilterGraph::GetState(DWORD dwTimeout, FILTER_STATE * pState)
{
    DbgLog(( LOG_TRACE, METHOD_TRACE_LOGGING_LEVEL, "CFilterGraph::GetState()" ));
    CheckPointer(pState, E_POINTER);

    HRESULT hr;

    for( ;; )
    {
        FILTER_STATE state;
        IBaseFilter * pmf;

        // ensure that this is S_OK not just any success code
        hr = S_OK;
        IMediaFilter * pIntermediateFilter = NULL;
        {
            CAutoMsgMutex cObjectLock(&m_CritSec);

            // If the list was not in upstream order already, make it so now.
            hr = UpstreamOrder();
            if( FAILED( hr ) ) {
                return hr;
            }

            // we know what state we're supposed to be in, since a
            // requirement for using this GetState is that you do all
            // state changes through us. However, we don't know whether
            // the state is intermediate or not, since other activity
            // (for example seeks) could make it intermediate after
            // a successful transition.
            *pState = m_State;

            // always need to traverse to look for intermediate state anywhere.

            for ( POSITION Pos = mFG_FilGenList.GetTailPosition(); Pos; Pos = mFG_FilGenList.Prev(Pos) )
            {
                pmf = mFG_FilGenList.Get(Pos)->pFilter;

                // just look and see if it will block
                hr = pmf->GetState(0, &state);
                if (FAILED(hr)) return hr;

                // compare against the state we think we're in to check
                // that all filters are in the same state
                if (state != *pState)
                {
                    // !!!flag this so we understand why it is happening
                    #ifdef DEBUG
                    {
                        FILTER_INFO info;
                        EXECUTE_ASSERT(SUCCEEDED(
                            pmf->QueryFilterInfo(&info)
                        ));
                        if (info.pGraph) info.pGraph->Release();
                        DbgLog(( LOG_ERROR, 0
                               , "Graph should be in state %d, but filter '%ls' (0x%08X) reported state %d"
                               , int(*pState), info.achName, pmf, int(state)
                              ));
                    }
                    #endif

                    // This case should only happen if filters transition through paused
                    // on the way into or out of run.  Any other time, E_FAIL it.
                    if (state != State_Paused) return E_FAIL;

                    pIntermediateFilter = pmf;
                    continue;
                } // end if (state != *pState)

                // only S_OK indicates a completed transition
                if ( S_OK == hr ) continue;
                if ( hr == VFW_S_STATE_INTERMEDIATE )
                {
                    pIntermediateFilter = pmf;
                    continue;
                }
                ASSERT( hr == VFW_S_CANT_CUE && state == State_Paused && m_State == State_Paused );
                return hr;
            }  // end for( Pos )
        }  // end scope CAutoLock lck(this)

        ASSERT( SUCCEEDED(hr) );

        if ( !pIntermediateFilter )
        {
            ASSERT( hr == S_OK );
            return hr;
        }
        if ( dwTimeout == 0 ) return VFW_S_STATE_INTERMEDIATE;

        const DWORD dwStartTime = timeGetTime();
        m_CritSec.Lock();
            *pState = m_State;
            hr = pIntermediateFilter->GetState(10, &state);
        m_CritSec.Unlock();
        if (FAILED(hr) || hr == VFW_S_CANT_CUE) return hr;
        if ( state != *pState )
        {
            if ( state != State_Paused ) return E_FAIL;
            Sleep(10);
        }
        ASSERT( hr == S_OK || hr == VFW_S_STATE_INTERMEDIATE );
        const DWORD dwWait = timeGetTime() - dwStartTime;
        if (dwTimeout != INFINITE) dwTimeout = dwTimeout > dwWait ? dwTimeout - dwWait : 0;
    } // end-for(;;)
}  // GetState


#ifdef THROTTLE
// avoid compiler bug passing in q; wrong value passed in
#if defined _MIPS_
#pragma optimize ("", off)
#endif // _MIPS_

HRESULT CFilterGraph::TellVideoRenderers(Quality q)
{
    // MSR_INTEGER(mFG_idAudioVideoThrottle, (int)q.Late);   // log low order bits
    MSR_INTEGER(mFG_idAudioVideoThrottle, q.Proportion);
    // for piqc = the IQualityControl on each video renderer filter
    POSITION Pos = mFG_VideoRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        IQualityControl * piqc = mFG_VideoRenderers.GetNext(Pos);
        piqc->Notify(this, q);
    }
    return NOERROR;
} // TellVideoRenderers

#if defined _MIPS_
#pragma optimize ("", on)
#endif // _MIPS_


// Receive Quality notifications.  The only interesting ones are from
// Audio renderers.  Pass screams for help to video renderers.
STDMETHODIMP CFilterGraph::Notify(IBaseFilter * pSender, Quality q)
{
    // See if this is really from an Audio Renderer

    // NOTE!  We are NOT getting any locks here as this could be called
    // asynchronously and even from a time critical thread.
    // we do not alter any of the state variables, we only expect
    // to be called while running, and nobody else should be changing
    // any of these while we are running either!

    // for pf = each audio renderer filter
    BOOL bFound = FALSE;
    POSITION Pos = mFG_AudioRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        AudioRenderer * pAR = mFG_AudioRenderers.GetNext(Pos);
        // IsEqualObject is expensive (1mSec or more) unless the == succeeds.
        // Rather than hit the frame rate always, we'll just not do AV throttling
        // if we are getting a dumb interface.
        if (pAR->pf == pSender) {
            bFound = TRUE;
            break;
        }
    }
    if (bFound) {
        TellVideoRenderers(q);
    } else {
        DbgBreak("Notify to filter graph but not from AudioRenderer IBaseFilter *");
    }
    return NOERROR;
} // Notify

#endif // THROTTLE

//=====================================================================
//
// CFilterGraph::NonDelegatingQueryInterface
//
//=====================================================================

// new version of url reader filter knows to look for
// DISPID_AMBIENT_CODEPAGE from the container. interface looks like
// IUnknown.
static const GUID IID_IUrlReaderCodePageAware = { /* 611dff56-29c3-11d3-ae5d-0000f8754b99 */
    0x611dff56, 0x29c3, 0x11d3, {0xae, 0x5d, 0x00, 0x00, 0xf8, 0x75, 0x4b, 0x99}
  };


STDMETHODIMP CFilterGraph::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv, E_POINTER);
    IUnknown * pInterface;
#ifdef DEBUG
    pInterface = NULL;
#endif

    if (riid == IID_IMediaEventSink)  {
        pInterface = static_cast<IMediaEventSink*>(&mFG_pFGC->m_implMediaEvent);
    } else if (riid == IID_IUnknown) {
        goto CUnknownNDQI;
    } else if (riid == IID_IGraphBuilder || riid == IID_IFilterGraph2) {
        pInterface = static_cast<IFilterGraph2*>(this);
    } else if (riid == IID_IMediaControl) {
        pInterface = static_cast<IMediaControl*>(&mFG_pFGC->m_implMediaControl);
    } else if (riid == IID_IResourceManager) {
        pInterface = static_cast<IResourceManager*>(&mFG_pFGC->m_ResourceManager);
    } else if (riid == IID_IMediaSeeking) {
        pInterface = static_cast<IMediaSeeking*>(&mFG_pFGC->m_implMediaSeeking);
    } else if (riid == IID_IMediaEvent || riid == IID_IMediaEventEx) {
        return mFG_pFGC->m_implMediaEvent.NonDelegatingQueryInterface(riid, ppv);
    } else if (riid == IID_IBasicAudio) {
        pInterface = static_cast<IBasicAudio*>(&mFG_pFGC->m_implBasicAudio);
    } else if (riid == IID_IBasicVideo || riid == IID_IBasicVideo2) {
        pInterface = static_cast<IBasicVideo2*>(&mFG_pFGC->m_implBasicVideo);
    } else if (riid == IID_IVideoWindow) {
        pInterface = static_cast<IVideoWindow*>(&mFG_pFGC->m_implVideoWindow);
    } else if (riid == IID_IFilterGraph) {
        pInterface = static_cast<IFilterGraph*>(this);
    } else if (riid == IID_IFilterMapper || riid == IID_IFilterMapper2 || riid == IID_IFilterMapper3) {
        return mFG_pMapperUnk->QueryInterface(riid, ppv);
    } else if (riid == IID_IPersistStream) {
        pInterface = static_cast<IPersistStream*>(this);
    } else if (riid == IID_IObjectWithSite) {
        pInterface = static_cast<IObjectWithSite*>(this);
#ifdef DEBUG
    } else if (riid == IID_ITestFilterGraph) {
        HRESULT hr = S_OK;
        mFG_Test = new CTestFilterGraph( NAME("GraphTester"), this, &hr);
        if (mFG_Test==NULL) {
           return E_OUTOFMEMORY;
        } else if (FAILED(hr)) {
            delete mFG_Test;
            return hr;
        }
        return mFG_Test->NonDelegatingQueryInterface(riid, ppv);
#endif //DEBUG

    } else if ((riid == IID_IMediaFilter) || (riid == IID_IPersist)) {
        pInterface = static_cast<IMediaFilter *>(&mFG_pFGC->m_implMediaFilter);
    } else if (riid == IID_IGraphVersion) {
        // has a single method QueryVersion in filgraph.h
        pInterface = static_cast<IGraphVersion*>(this);
    } else if (riid == IID_IAMMainThread) {
        pInterface = static_cast<IAMMainThread*>(this);
    } else if (riid == IID_IAMOpenProgress) {
        pInterface = static_cast<IAMOpenProgress*>(this);
    } else if (riid == IID_IGraphConfig) {
        pInterface = static_cast<IGraphConfig*>(&m_Config);
    } else if (riid == IID_IAMGraphStreams) {
        pInterface = static_cast<IAMGraphStreams*>(this);
    } else if (riid == IID_IMediaPosition) {
        pInterface = static_cast<IMediaPosition*>(&mFG_pFGC->m_implMediaPosition);
    } else if (riid == IID_IQueueCommand) {
        pInterface = static_cast<IQueueCommand*>(&mFG_pFGC->m_qcmd);
    } else if (riid == IID_IVideoFrameStep) {
        pInterface = static_cast<IVideoFrameStep*>(this);
    } else if (riid == IID_IFilterChain) {
        pInterface =  static_cast<IFilterChain*>(m_pFilterChain);
    } else if (riid == IID_IAMStats) {
        return mFG_Stats->QueryInterface(riid, ppv);
    } else if (riid == IID_IMarshal) {
        return m_pMarshaler->QueryInterface(riid, ppv);
    } else if (riid == IID_IUrlReaderCodePageAware) {
        return CUnknown::NonDelegatingQueryInterface(IID_IUnknown, ppv);
    } else if (riid == IID_IRegisterServiceProvider) {
        pInterface =  static_cast<IRegisterServiceProvider *>(this);
    } else if (riid == IID_IServiceProvider) {
        pInterface =  static_cast<IServiceProvider *>(this);
    } else {
        // not an interface we know. Try the plug-in distributor.
        if (!mFG_pDistributor)
        {   // Create the distributor if we haven't got one yet.

                mFG_pDistributor = new CDistributorManager(GetOwner(), &m_CritSec);
            if (!mFG_pDistributor) return E_OUTOFMEMORY;
        }
        {
            HRESULT hr = mFG_pDistributor->QueryInterface(riid, ppv);
            if (SUCCEEDED(hr)) return hr;
        }
        // If nothing could be found in the registry - give it to the
        // base class (which will handle IUnknown and reject everything else.
    CUnknownNDQI:
            return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
    ASSERT( pInterface );
    return GetInterface( pInterface, ppv );
} // CFilterGraph::NonDelegatingQueryInterface


//========================================================================
//=====================================================================
// Persistent object support
//=====================================================================
//========================================================================


// Serialising to a stream:
//
// SYNTAX:
// <graph> ::= <version3><filters><connections><clock>END
//           | <version2><filters><connections>END
// <version3> ::= 0003\r\n
// <version2> ::= 0002\r\n
// <clock> ::= CLOCK <b> <required><b><clockid>\r\n
// <required> ::= 1|0
// <clockid> ::= <n>|<class id>
// <filters ::=FILTERS <b>[<filter list><b>]
// <connections> ::= CONNECTIONS [<b> <connection list>]
// <filter list> ::= [<filter> <b>] <filter list>
// <connection list> ::= [<connection><b>]<connection list>
// <filter> ::= <n><b>"<name>"<b><class id><b>[<file>]<length><b1><filter data>
// <n> ::= a decimal number
// <file> ::= SOURCE "<name>"<b> | SINK "<name>"<b>
// <class id> ::= class id of the filter in standard string form
// <name> ::= any sequence of characters NOT including "
// <length> ::= character string representing unsigned decimal number e.g. 23
//              this is the number of bytes of data that follow the following space.
// <b> ::= any combination of space, \t, \r or \n
// <b1> ::= exactly one space character
// <n> ::= an identifier which will in fact be an integer, 0001, 0002, 0003, etc
// <connection> ::= <n1><b>"<pin1 id>"<b><n2><b>"<pin2 id>" <media type>
// <n1> ::= identifier of first filter
// <n2> ::= identifier of second filter
// <pin1 id> ::= <Name>
// <pin2 id> ::= <Name>
// <media type> ::= <major type><b><sub type><b><flags><length><b1><format>
// <major type> ::= <class id>
// <sub type> ::= <class id>
// <flags> ::= <FixedSizeSamples><b><TemporalCompression><b>
// <FixedSizeSamples> ::= 1|0
// <TemporalCompression> ::= 1|0
// <Format> ::= <SampleSize><b><FormatType><b><FormatLength><b1><FormatData>
// <FormatType> ::= class id of the format in standard string form
// <FormatLength> ::= character string representing unsigned decimal number
//              this is the number of bytes of data that follow the following space.
// <FormatData> ::= glob of binary data
// <clock> ::= CLOCK <b> <required><b><clockid>\r\n
// <required> ::= 1|0
// <clockid> ::= <n>|<class id>
//
// On output there will be a new line (\r\n) per filter, one per connection,
// and one for each of the two keywords.
// Each other case of <B> will be a single space.
// Note that the two keywords FILTERS and CONNECTIONS are NOT LOCALISABLE.
// Note that the filter data and the format data are binary, so they may contain
// bogus line breaks, nulls etc.
// All strings are UNICODE
//
// What it will look like (well, nearly - a connection line is long and so
// has been split for presentation here):
// 0003
// FILTERS
// 0001 "Source" {00000000-0000-0000-0000-000000000001} SOURCE "foo.mpg" 0000000000
// 0002 "another filter" {00000000-0000-0000-0000-000000000002} 0000000008 XXXXXXXX
// CONNECTIONS
// 0001 "Output pin" 0002 "In"                                // no line break here
//     0000000172 {00000000-0000-0000-0000-000000000003}      // no line break here
//     {00000000-0000-0000-0000-000000000004} 1 0             // no line break here
//     0000000093 {00000000-0000-0000-0000-000000000005} 18 YYYYYYYYYYYYYYYYYY
// CLOCK 1 0002
// END
//
// XXX... represents filter data
// YYY... represents format data
//
// Whether we are ANSI or UNICODE, the data in the file will always be ANSI
// aka MultiByte




// IsDirty
//
// The graph is dirty if there have been any new filters added or removed
// any connections made or broken or if any filter says that it's dirty.
STDMETHODIMP CFilterGraph::IsDirty()
{
    HRESULT hr = S_FALSE;    // meaning clean
    if (mFG_bDirty) {
        return S_OK;  // OK means dirty
    }

    BOOL bDirty = FALSE;

    // Ask all filters if they are dirty - at least up to the first that says "yes"
    TRAVERSEFILGENS(Pos, pfg)

        IPersistStream * pps;
        hr = pfg->pFilter->QueryInterface(IID_IPersistStream, (void**)&pps);
        // A filter that does not expose IPersistStream has no data to persist
        // and therefore is always clean.  A filter that gives some other error
        // is all fouled up and so gives a failure return code.
        if (hr==E_NOINTERFACE){
            continue;
        } else if (FAILED(hr)) {
            break;
        }

        if (S_OK==pps->IsDirty()) {
            bDirty = TRUE;
        }

        pps->Release();
        if (bDirty) {
            break;
        }
    ENDTRAVERSEFILGENS

    if (SUCCEEDED(hr)) {
        hr = (bDirty ? S_OK : S_FALSE);
    }

    return hr;
} // IsDirty



//========================================================================
// BackUpOneChar
//
// Seek one UNICODE char back to read the last char again
//========================================================================
HRESULT BackUpOneChar(LPSTREAM pStm)
{
    LARGE_INTEGER li;
    li.QuadPart = -(LONGLONG)sizeof(WCHAR);
    return pStm->Seek(li, STREAM_SEEK_CUR, NULL);
} // BackUpOneChar


//========================================================================
// ReadInt
//
// Consume one optionally signed decimal integer from the stream.
// Consume also a single delimiting following white space character
// from the set {' ', '\n', '\r', '\t', '\0' }
// Other characters result in VFW_E_INVALID_FILE_FORMAT with the
// stream positioned at the first such character.
// Set n to the integer read.  Return any failure in hr.
// Overflows are NOT checked - so you'll get the number modulo something or other
// white space is not consumed.
// By a quirk "- " will be accepted and read as 0.
//========================================================================
HRESULT ReadInt(LPSTREAM pStm, int &n)
{
    HRESULT hr;
    ULONG uLen;
    WCHAR ch[1];
    int Sign = 1;
    n = 0;

    hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
    if (FAILED(hr)) {
        return hr;
    }
    if (uLen!=sizeof(WCHAR)){
        return VFW_E_FILE_TOO_SHORT;
    }
    if (ch[0]==L'-'){
        Sign = -1;
        hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)){
            return VFW_E_FILE_TOO_SHORT;
        }
    }

    for( ; ; ) {
        if (ch[0]>=L'0' && ch[0]<=L'9') {
            n = 10*n+(int)(ch[0]-L'0');
        } else if (  ch[0] == L' '
                  || ch[0] == L'\t'
                  || ch[0] == L'\r'
                  || ch[0] == L'\n'
                  || ch[0] == L'\0'
                  ) {
            break;
        } else {
            BackUpOneChar(pStm);
            return VFW_E_INVALID_FILE_FORMAT;
        }

        hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)){
            return VFW_E_FILE_TOO_SHORT;
        }
    }
    return NOERROR;
} // ReadInt


//========================================================================
// ConsumeBlanks
//
// consume ' ', '\t', '\r', '\n' until something else is found
// Leave the stream positioned at the first non-blank
// if a failure occurs first, return the failure code
// Set Delim to the first non white space character found.
//========================================================================
HRESULT ConsumeBlanks(LPSTREAM pStm, WCHAR &Delim)
{
    HRESULT hr;
    ULONG uLen;
    WCHAR ch[1];

    for( ; ; ) {
        hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }

        if (uLen!=sizeof(WCHAR)){
            return VFW_E_FILE_TOO_SHORT;
        }

        if (  ch[0] != L' '
           && ch[0] != L'\t'
           && ch[0] != L'\r'
           && ch[0] != L'\n'
           ) {
            break;
        }
    }

    BackUpOneChar(pStm);
    Delim = ch[0];
    return hr;

} // ConsumeBlanks


//========================================================================
// Consume
//
// Consume the given constant up to but not including its terminating NULL.
// In the event of a mismatch, return VFW_E_INVALID_FILE_FORMAT.
// If the file fails to read (too short or whatever) return the failure code.
// If the constant is found, return S_OK with the file positioned at the
// first character after the constant.
// (If there is a mismatch the file will be positioned one character after
// the mismatch).
//========================================================================
HRESULT Consume(LPSTREAM pStm, LPCWSTR pstr)
{
    ULONG uLen;
    WCHAR ch[1];
    HRESULT hr;

    while (pstr[0] != L'\0') {
        hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)) {
            return VFW_E_FILE_TOO_SHORT;
        }
        if (pstr[0] != ch[0]){
            return VFW_E_INVALID_FILE_FORMAT;
        }
        ++pstr;
    }
    return NOERROR;
} // Consume


//========================================================================
// ReadNonBlank
//
// Given a stream positioned at some character and a pre-allocated pstr
// with room for cch (UNICODE) chars.
// read everything up to but not including the next blank into pstr.
// Consume that next blank character.   (blank is any of  ' ', '\n', '\t', '\r')
// If there are more than cb-1 non-blanks to read
// then return VFW_INVALID_FILE_FORMAT
// NULL terminate pstr.  pstr must be pre-allocated by caller.
//========================================================================
HRESULT ReadNonBlank(LPSTREAM pStm, LPWSTR pstr, int cch)
{
    HRESULT hr;

    ULONG uLen;
    if (cch<=0) {
        return E_INVALIDARG;
    }

    hr = pStm->Read(pstr, sizeof(WCHAR), &uLen);
    if (FAILED(hr)) {
        return hr;
    }
    if (uLen!=sizeof(WCHAR)) {
        return VFW_E_FILE_TOO_SHORT;
    }
    while (  *pstr != L'\t'
          && *pstr != L'\n'
          && *pstr != L'\r'
          && *pstr != L' '
          ) {
        ++pstr;
        --cch;
        if (cch==0) {
            return VFW_E_INVALID_FILE_FORMAT;  // string is too long
        }

        hr = pStm->Read(pstr, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)) {
            return VFW_E_FILE_TOO_SHORT;
        }
    }

    // Overwrite terminating " with terminating null.
    *pstr = L'\0';
    return NOERROR;

} // ReadNonBlank


//========================================================================
// ReadString
//
// Given a stream positioned at a leading "
// read the string that follows into pstr whose size is cch UNICODE chars
// (including space for the final NULL).
// Replace final delimiting " in pstr with NULL.
// Leave pStm positioned at first character after the trailing "
//========================================================================
HRESULT ReadString(LPSTREAM pStm, LPWSTR pstr, int cch)
{
    HRESULT hr;
    ULONG uLen;

    hr = Consume(pStm, L"\"");
    if (FAILED(hr)) {
        return hr;
    }

    if (cch<=0) {
        return E_INVALIDARG;
    }

    hr = pStm->Read(pstr, sizeof(WCHAR), &uLen);
    if (FAILED(hr)) {
        return hr;
    }
    if (uLen!=sizeof(WCHAR)) {
        return VFW_E_FILE_TOO_SHORT;
    }
    while (*pstr != L'\"') {
        ++pstr;
        --cch;
        if (cch==0) {
            return VFW_E_INVALID_FILE_FORMAT;  // string is too long
        }
        hr = pStm->Read(pstr, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)) {
            return VFW_E_FILE_TOO_SHORT;
        }
    }

    // Overwrite terminating " with terminating null.
    *pstr = L'\0';
    return NOERROR;

} // ReadString


//========================================================================
// LoadFilter
//
// Given a stream positioned at what might be the start of a <filter>
// Load the filter from the stream.
// A filter looks like
// 0002 "another filter" {00000000-0000-0000-0000-000000000002} 0000000008 XXXXXXXX
// Normally return NOERROR.
// S_FALSE means the filter didn't load its data
// VFW_S_NO_MORE_ITEMS means that the data didn't start with a number and
// so probably it's the end of the <filters> and the start of CONNECTIONS
// In this case the stream is left at the same position.
// See filgraph.h for explanation of nPersistOfset.
//========================================================================
HRESULT CFilterGraph::LoadFilter(LPSTREAM pStm, int nPersistOffset){
    // Allocate filgen
    // Read filter, name, clsid
    // Instantiate it
    // Read length
    // Load it
    BOOL bFilterError = FALSE;  // True if the filter didn't load its data.
    HRESULT hr = S_OK;

    int rcLen = 0;
    int len = 0;
    WCHAR Delim;
    FilGen * pfg;

    // Apologies for GOTOs - I can't find a better resource unwinding strategy.

    // Read nPersist - try this before allocating pfg as it might be the end.
    int nPersist;
    hr = ReadInt(pStm, nPersist);
    if (FAILED(hr)) {
        if (nPersist==0 && hr == VFW_E_INVALID_FILE_FORMAT) {
            hr = VFW_S_NO_MORE_ITEMS;
        }
        goto BARE_RETURN;
    }
    nPersist += nPersistOffset;

    pfg = new FilGen(NULL, 0 /* !!! */);
    if ( pfg==NULL ) {
        hr = E_OUTOFMEMORY;
        goto BARE_RETURN;
    }

    pfg->nPersist = nPersist;

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    // read name
    WCHAR Buffer[MAX_PATH+1];
    hr = ReadString(pStm, Buffer, MAX_FILTER_NAME+1);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    len = 1+lstrlenW(Buffer);
    pfg->pName = new WCHAR[len];
    if (!(pfg->pName)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    CopyMemory(pfg->pName, Buffer, len*sizeof(WCHAR));

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    // read clsid
    WCHAR wstrClsid[CHARS_IN_GUID];
    hr = ReadNonBlank(pStm, wstrClsid, CHARS_IN_GUID);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    CLSID clsid;
    hr = QzCLSIDFromString(wstrClsid, &clsid);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    // Instantiate the filter
    hr = CreateFilter( &clsid, &pfg->pFilter);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    // We don't do AddFilter explicitly (Why not??? Code sharing???)


    // Get any Source file name and load it.
    if (Delim==L'S') {
        // SOURCE?
        hr = Consume(pStm, L"SOURCE");
        if (SUCCEEDED(hr)) {
            hr = ConsumeBlanks(pStm, Delim);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            // Read the file name
            hr = ReadString(pStm, Buffer, MAX_PATH+1);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            IFileSourceFilter * pifsf;
            hr = pfg->pFilter->QueryInterface(IID_IFileSourceFilter, (void**)&pifsf);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }
            hr = pifsf->Load(Buffer, NULL);
            pifsf->Release();
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            hr = ConsumeBlanks(pStm, Delim);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

        } else if (hr==VFW_E_INVALID_FILE_FORMAT) {
            BackUpOneChar(pStm);
            BackUpOneChar(pStm);
        } else {
            goto FREE_FILGEN_AND_RETURN;
        }


        hr = Consume(pStm, L"SINK");
        if (SUCCEEDED(hr)) {
            hr = ConsumeBlanks(pStm, Delim);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            // Read the file name
            hr = ReadString(pStm, Buffer, MAX_PATH+1);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            IFileSinkFilter * pifsf;
            hr = pfg->pFilter->QueryInterface(IID_IFileSinkFilter, (void**)&pifsf);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }
            hr = pifsf->SetFileName(Buffer, NULL);
            pifsf->Release();
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            hr = ConsumeBlanks(pStm, Delim);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

        } else if (hr==VFW_E_INVALID_FILE_FORMAT) {
            BackUpOneChar(pStm);
        } else {
            goto FREE_FILGEN_AND_RETURN;
        }
    }

    // Must add to list before calling JoinFilterGraph to allow callbacks
    // such as SetSyncSource
    // We are usually working downstream.  By adding it to the head  we are
    // probably putting it in upstream order.  May save time on the sorting.
    POSITION pos;
    pos = mFG_FilGenList.AddHead( pfg );
    if (pos==NULL) {
        hr = E_OUTOFMEMORY;
        goto FREE_FILGEN_AND_RETURN;
    }

    hr = pfg->pFilter->JoinFilterGraph( this, pfg->pName );
    if (FAILED(hr)) {
        goto REMOVE_FILTER_AND_RETURN;
    }

    // Read size of filter's private data
    int cbFilter;
    hr = ReadInt(pStm, cbFilter);
    if (FAILED(hr)) {
        goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
    }
    if (cbFilter<0) {
        hr = VFW_E_INVALID_FILE_FORMAT;
        goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
    }

    // The above also consumed exactly one (UNICODE) space after the end of the size
    if (cbFilter>0) {

        // Get the filter to read its private data
        // Take no chances on rogue filter - snapshot file position now.
        ULARGE_INTEGER StreamPos;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        hr = pStm->Seek(li, STREAM_SEEK_CUR, &StreamPos);  // get position
        if (FAILED(hr)) {
            goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
        }

        // Get filter to read from stream
        IPersistStream * pips;
        hr = pfg->pFilter->QueryInterface(IID_IPersistStream, (void**)&pips);
        if (hr==E_NOINTERFACE) {
            // This is anomalous, because we *do* have data for it to read.
            // We will IGNORE the error and carry on loading (sort of best-can-do).
            bFilterError = TRUE;
        } else if (SUCCEEDED(hr)) {
            hr = pips->Load(pStm);
            if (FAILED(hr)) {
               bFilterError = TRUE;
            }
            pips->Release();
        } else {
            bFilterError = TRUE;
        }

        // Now seek to where the filter should have left things

        // Let's see if the filter behaved itself.  Find the current position again.
        ULARGE_INTEGER StreamPos2;
        li.QuadPart = 0;
        hr = pStm->Seek(li, STREAM_SEEK_CUR, &StreamPos2);  // get position
        if (FAILED(hr)) {
            goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
        }

        // Is it where it should be?
        if (StreamPos2.QuadPart != StreamPos.QuadPart + cbFilter) {

            if (!bFilterError) {
                DbgBreak("Filter left stream wrongly positioned");
            }
            // The rat-bag!
            // Note we have a wobbly filter and seek to the right place.
            li.QuadPart = StreamPos.QuadPart + cbFilter;
            bFilterError = TRUE;
            hr = pStm->Seek(li, STREAM_SEEK_SET, NULL);   // reset position
            if (FAILED(hr)) {
                goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
            }

        }

    }


    goto BARE_RETURN;

REMOVE_FILTER_FROM_GRAPH_AND_RETURN:
    EXECUTE_ASSERT( SUCCEEDED( pfg->pFilter->JoinFilterGraph( NULL, NULL ) ) );
REMOVE_FILTER_AND_RETURN:
    mFG_FilGenList.RemoveHead();
FREE_FILGEN_AND_RETURN:
    delete pfg;
BARE_RETURN:
    if (SUCCEEDED(hr) && hr!=VFW_S_NO_MORE_ITEMS) {
        hr = (bFilterError ? S_FALSE : NOERROR);
    }
    return hr;
} // LoadFilter

//========================================================================
// LoadFilters
//
// Given a stream positioned at the start of <filters>
// Load all the filters from the stream.
// Normally return NOERROR.
// S_FALSE means some filter didn't load its data (you guess which)
// Leaves the stream positioned at the end of the filters.
// See filgraph.h for explanation of nPersistOfset.
//========================================================================

HRESULT CFilterGraph::LoadFilters(LPSTREAM pStm, int nPersistOffset)
{
    BOOL bAllOK = TRUE;
    WCHAR Delim;
    HRESULT hr = NOERROR;
    while (SUCCEEDED(hr)) {
        hr = ConsumeBlanks(pStm, Delim);
        if (FAILED(hr)) {
            return hr;
        }
        hr = LoadFilter(pStm, nPersistOffset);
        if (hr==S_FALSE) {
            bAllOK = FALSE;
        }
        if (hr==VFW_S_NO_MORE_ITEMS) {
            break;
        }

    }

    if (hr==VFW_S_NO_MORE_ITEMS) {
        hr = NOERROR;
    }
    if (SUCCEEDED(hr)) {
        hr = (bAllOK ? S_OK : S_FALSE);
    }
    return hr;
} // LoadFilters


HRESULT CFilterGraph::ReadMediaType(LPSTREAM pStm, CMediaType &mt)
{
    int cb;                      // count of bytes to read
    HRESULT hr = ReadInt(pStm, cb);
    if (FAILED(hr)) {
        return hr;
    }

    BYTE * pBuf = new BYTE[cb];          // read raw bytes
    if (pBuf==NULL) {
        return E_OUTOFMEMORY;
    }

    ULONG uLen;
    hr = pStm->Read(pBuf, cb, &uLen);
    if (FAILED(hr)) {
        delete[] pBuf;
        return hr;
    }
    if ((int)uLen!=cb) {
        delete[] pBuf;
        return VFW_E_FILE_TOO_SHORT;
    }

    hr = CMediaTypeFromText((LPWSTR)pBuf, mt);

    delete[] pBuf;

    return hr;
} // ReadMediaType


//========================================================================
// LoadConnection
//
// Given a stream positioned at a <connection> load it.
// A connection looks like.
// 0001 "Output pin" 0002 "In"                                // no line break here
//     0000000172 {00000000-0000-0000-0000-000000000003}      // no line break here
//     {00000000-0000-0000-0000-000000000004} 1 0             // no line break here
//     {00000000-0000-0000-0000-000000000005}         18 YYYYYYYYYYYYYYYYYY
// See filgraph.h for explanation of nPersistOfset.
//========================================================================
HRESULT CFilterGraph::LoadConnection(LPSTREAM pStm, int nPersistOffset)
{
    HRESULT hr = S_OK;
    int len;
    WCHAR Delim;
    ConGen *pcg;
    BOOL bTypeIgnored = FALSE;   // TRUE => we used a default media type

    // Read nPersist - try this before allocating pfg as it might be the end.
    int nPersist;
    hr = ReadInt(pStm, nPersist);
    if (FAILED(hr)) {
        if (nPersist==0 && hr == VFW_E_INVALID_FILE_FORMAT) {
            hr = VFW_S_NO_MORE_ITEMS;
        }
        goto BARE_RETURN;
    }
    nPersist += nPersistOffset;

    pcg = new ConGen;
    if (pcg==NULL) {
        hr = E_OUTOFMEMORY;
        goto BARE_RETURN;
    }
    FilGen *pfg;

    pfg = mFG_FilGenList.GetByPersistNumber(nPersist);
    if (pfg==NULL) {
        hr = VFW_E_INVALID_FILE_FORMAT;
        goto FREE_CONGEN_AND_RETURN;
    }
    pcg->pfFrom = pfg->pFilter;
    if (pcg->pfFrom==NULL)
    {
        DbgBreak("pfFrom == NULL");
        hr = E_FAIL;
        goto FREE_CONGEN_AND_RETURN;  // Don't think this should happen
    }
    WCHAR Buffer[MAX_FILTER_NAME+1];

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    hr = ReadString(pStm, Buffer, MAX_FILTER_NAME);   // actually a pinname
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    len = 1+lstrlenW(Buffer);
    pcg->piFrom = new WCHAR[len];
    if (pcg->piFrom==NULL) {
        goto FREE_CONGEN_AND_RETURN;
    }

    CopyMemory(pcg->piFrom, Buffer, len*sizeof(WCHAR));

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    hr = ReadInt(pStm, nPersist);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }
    nPersist += nPersistOffset;
    pfg = mFG_FilGenList.GetByPersistNumber(nPersist);
    if (pfg==NULL) {
        hr = VFW_E_INVALID_FILE_FORMAT;
        goto FREE_CONGEN_AND_RETURN;
    }
    pcg->pfTo = pfg->pFilter;
    if (pcg->pfTo==NULL)
    {
        DbgBreak("pfTo == NULL");
        hr = E_FAIL;
        goto FREE_CONGEN_AND_RETURN;  // Don't think this should happen
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    hr = ReadString(pStm, Buffer, MAX_FILTER_NAME);   // actually a pinname
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    len = 1+lstrlenW(Buffer);
    pcg->piTo = new WCHAR[len];
    if (pcg->piTo==NULL) {
        goto FREE_CONGEN_AND_RETURN;
    }

    CopyMemory(pcg->piTo, Buffer, len*sizeof(WCHAR));

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    hr = ReadMediaType(pStm, pcg->mt);
    if (FAILED(hr)){
        goto FREE_CONGEN_AND_RETURN;
    }

    // Try to make the connection and if it fails, put the
    // congen on the list.  NOTE: We do not have IPins in cg because
    // we might not be able to get any pins yet.
    hr = MakeConnection(pcg);
    if (FAILED(hr)) {
       if (NULL==mFG_ConGenList.AddTail(pcg)) {
           goto FREE_CONGEN_AND_RETURN;
       }
       hr = S_FALSE;      // deferred
       goto BARE_RETURN;  // It's on the list, so don't free it
    }
    if (hr==VFW_S_MEDIA_TYPE_IGNORED) {
        bTypeIgnored = TRUE;
    }

    hr = AttemptDeferredConnections();
    if (hr==VFW_S_MEDIA_TYPE_IGNORED) {
        bTypeIgnored = TRUE;
    }

    // drop through to free the congen that we have dealt with

FREE_CONGEN_AND_RETURN:
    // no need to delete[] pcg->piTo etc as the destructor does that.
    delete pcg;
BARE_RETURN:
    if (hr==NOERROR) {
        // We could have both a MEDIA_TYPE_IGNORED and a DEFERRED, but we
        // have only one return code.  Deferred is probably more serious.
        // Type ignored is probably more insidious.
        if (bTypeIgnored) {
            hr=VFW_S_MEDIA_TYPE_IGNORED;
        }
    }
    return hr;
} // LoadConnection


//========================================================================
// LoadConnections
//
// Given a stream positioned after <version> FILTERS <b> <filters>
// Load the connections from the stream
// See filgraph.h for explanation of nPersistOfset.
//========================================================================
HRESULT  CFilterGraph::LoadConnections(LPSTREAM pStm, int nPersistOffset){

    BOOL bAllOK = TRUE;
    BOOL bTypeIgnored = FALSE;
    HRESULT hr = NOERROR;
    WCHAR Delim;

    while (SUCCEEDED(hr)) {
        hr = ConsumeBlanks(pStm, Delim);
        if (FAILED(hr)) {
            return hr;
        }
        hr = LoadConnection(pStm, nPersistOffset);
        if (hr==S_FALSE) {
            bAllOK = FALSE;
        }
        if (hr==VFW_S_NO_MORE_ITEMS) {
            break;
        }
        if (hr==VFW_S_MEDIA_TYPE_IGNORED) {
            bTypeIgnored = TRUE;
        }
    }

    if (hr==VFW_S_NO_MORE_ITEMS) {
        hr = NOERROR;
    }
    if (SUCCEEDED(hr)) {
        if (!bAllOK) {
            hr = S_FALSE;
        } else if (bTypeIgnored) {
            hr = VFW_S_MEDIA_TYPE_IGNORED;
        } else {
            hr = S_OK;
        }
    }
    return hr;
} // LoadConnections


//========================================================================
// FindPersistOffset
//
// Return the value of the largest nPersist found in the list of filgens.
//========================================================================
int CFilterGraph::FindPersistOffset()
{
    int nPersist = 0;
    TRAVERSEFILGENS(Pos, pfg)
        if (pfg->nPersist>nPersist) {
            nPersist = pfg->nPersist>nPersist;
        }
    ENDTRAVERSEFILGENS
    return nPersist;

} // FindPersistOffset


HRESULT CFilterGraph::LoadClock(LPSTREAM pStm, int nPersistOffset)
{
    WCHAR Delim;
    HRESULT hr = Consume(pStm, L"CLOCK");  // do not localise!
    if (FAILED(hr)) {
        return hr;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }

    int n;
    hr = ReadInt(pStm, n);
    if (FAILED(hr)) {
        return hr;
    }
    mFG_bNoSync = (n==0);

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }

    IReferenceClock * pirc = NULL;

    // Read the file to find the new reference clock, instantiate it if need be
    // and set pirc to point to it
    if (Delim==L'{') {
        // We have a class id rather than a filter number
        WCHAR wstrClsid[CHARS_IN_GUID];
        hr = ReadNonBlank(pStm, wstrClsid, CHARS_IN_GUID);
        if (FAILED(hr)) {
            return hr;
        }

        CLSID clsid;
        hr = QzCLSIDFromString(wstrClsid, &clsid);
        if (FAILED(hr)) {
            return hr;
        }

        hr = CoCreateInstance( clsid, NULL, CLSCTX_INPROC
                             , IID_IReferenceClock, (void **) &pirc
                             );
        if (FAILED(hr)) {
            return hr;
        }

    } else {
        // We have a filter number (could be zero)
        int nClock;
        hr = ReadInt(pStm, nClock);
        if (FAILED(hr)) {
            return hr;
        }

        if (nClock!=0) {
            nClock += nPersistOffset;
            FilGen *pfg = mFG_FilGenList.GetByPersistNumber(nClock);
            if (pfg==NULL) {
                return VFW_E_INVALID_FILE_FORMAT;
            }

            hr = pfg->pFilter->QueryInterface( IID_IReferenceClock, (void**)(&pirc) );
            if (FAILED(hr)) {
                return hr;
            }
        }
    }

    // Either there was an error and we have already returned, or pirc is NULL
    // and no clock was defined
    // or pirc is a ref counted point3er to an IReferenceClock which we must use.

    if (pirc!=NULL) {
        hr = SetSyncSource(pirc);
        pirc->Release();
        if (FAILED(hr)) {
            return hr;
        }
    }

    hr = ConsumeBlanks(pStm, Delim);

    return hr;

} // LoadClock



//========================================================================
// LoadInternal
//
// Load the filter graph from the stream.
// If the operation FAILS the then filter graph may be left in an inconsistent state.
//========================================================================
HRESULT CFilterGraph::LoadInternal(LPSTREAM pStm)
{
    HRESULT hr;
    int nVersion;
    BOOL bDeferred = FALSE;      // connections deferred
    BOOL bWobblyFilter = FALSE;  // filter didn't load its data
    WCHAR Delim;
    BOOL bTypeIgnored = FALSE;

    // If the graph is not empty then we will become dirty as the file (whichever
    // one) won't contain what we will now have.
    // Mark it right now, at the beginning in case we bail out before the end.
    BOOL bDirty = (mFG_FilGenList.GetCount()>0);
    mFG_bDirty = bDirty;

    int nPersistOffset = FindPersistOffset();

    // Read the file version
    hr = ReadInt(pStm, nVersion);
    if (FAILED(hr)) {
        return hr;
    }
    if (nVersion>3 || nVersion<2) {
        return VFW_E_INVALID_FILE_VERSION;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }

    hr = Consume(pStm, mFG_FiltersString);
    if (FAILED(hr)) {
        return hr;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }

    hr = LoadFilters(pStm, nPersistOffset);
    if (FAILED(hr)) {
        return hr;
    } else if (hr==S_FALSE) {
        bWobblyFilter = TRUE;
    }

    hr = Consume(pStm, mFG_ConnectionsString);
    if (FAILED(hr)) {
        return hr;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }
    if( mFG_bSyncUsingStreamOffset )
    {
        //
        // now that all filters and pins have been created, reset the max graph
        // latency on push source filters before restoring connections
        //
        SetMaxGraphLatencyOnPushSources( );
    }

    hr = LoadConnections(pStm, nPersistOffset);
    if (FAILED(hr)) {
        return hr;
    } else if (hr==S_FALSE) {
        bDeferred = TRUE;
    } else if (hr==VFW_S_MEDIA_TYPE_IGNORED) {
        bTypeIgnored = TRUE;
    }

    if (nVersion>=3) {
        hr = LoadClock(pStm, nPersistOffset);
    }
    if (FAILED(hr)) {
        return hr;
    }

    hr = Consume(pStm, L"END");
    if (FAILED(hr)) {
        // We may be missing a large chunk off the end.  Can't tell how much.
        return hr;
    }

    if (bWobblyFilter) {
        hr = VFW_S_SOME_DATA_IGNORED;
        // and there may be deferred connections too
    } else if (bDeferred) {
        hr = VFW_S_CONNECTIONS_DEFERRED;
    } else if (bTypeIgnored) {
        hr = VFW_S_MEDIA_TYPE_IGNORED;
    } else {
        hr = NOERROR;
    }

    // If we loaded into a clean graph, then the graph is now clean.
    // Many operations during load probably set the dirty bit, so fix it now.
    mFG_bDirty = bDirty;

    return hr;
} // LoadInternal



//========================================================================
// Load
//
// Load the filter graph from the stream.  Order it.
// If the operation FAILS the then filter graph may be left in an inconsistent state.
//========================================================================
STDMETHODIMP CFilterGraph::Load(LPSTREAM pStm)
{
    // MSR_INTEGER(0,1234567);
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    CheckPointer(pStm, E_POINTER);
    HRESULT hr;
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        hr = LoadInternal(pStm);
        // ASSERT - the graph is actually ordered OK, because that's how we saved it.
        // Except that the sorting might have failed then - in which case it will fail
        // here too - but we must not try to run a circular graph.
        IncVersion();

        HRESULT hrUSO = UpstreamOrder();
        if( SUCCEEDED( hr ) && FAILED( hrUSO ) ) {
            return hrUSO;
        }
    }

    // outside lock, notify change
    NotifyChange();
    // MSR_INTEGER(0,7654321);
    return hr;
} // Load


//=======================================================================
// MakeConnection
//
// Make the connection described by pcg*
// return a failure code if it won't connect
//=======================================================================
HRESULT CFilterGraph::MakeConnection(ConGen * pcg)
{
    HRESULT hr;
    IPin * ppFrom;

    hr = pcg->pfFrom->FindPin(pcg->piFrom, &ppFrom);
    if (FAILED(hr)) {
        return hr;
    }
    ASSERT(ppFrom!=NULL);

    IPin * ppTo;

    hr = pcg->pfTo->FindPin(pcg->piTo, &ppTo);
    if (FAILED(hr)) {
        ppFrom->Release();
        return hr;
    }
    ASSERT(ppTo!=NULL);

    mFG_RList.Active();
    hr = ConnectDirectInternal(ppFrom, ppTo, &(pcg->mt));
    if (FAILED(hr)) {
        hr = ConnectDirectInternal(ppFrom, ppTo, NULL);
        if (SUCCEEDED(hr)) {
            hr = VFW_S_MEDIA_TYPE_IGNORED;
        }
    }
    mFG_RList.Passive();

    ppFrom->Release();
    ppTo->Release();
    return hr;

} // MakeConnection


//=======================================================================
// AttemptDeferredConnections
//
// Attempt all the connections on mFG_ConGenList.
// if there's any progress, try them again until no progress or all done.
// Delete from the list any that succeed.
// return S_FALSE if any left outstanding, S_OK if all done (and deleted)
// RList should probably be Active when you call this.
//=======================================================================
HRESULT CFilterGraph::AttemptDeferredConnections()
{
    BOOL bDeferred = FALSE;     // avoid compiler warning
    BOOL bProgress = TRUE;
    while (bProgress) {
        bProgress = FALSE;
        bDeferred = FALSE;
        POSITION pos = mFG_ConGenList.GetHeadPosition();
        while (pos != NULL)
        {
            ConGen * pcg;
            POSITION posRemember = pos;
            pcg = (mFG_ConGenList.GetNext(pos));   // pos now moved on

            if (  NULL==mFG_FilGenList.GetByFilter(pcg->pfFrom)
               || NULL==mFG_FilGenList.GetByFilter(pcg->pfTo)
               ) {
                // The filter has been removed - so purge it.
                delete pcg;
                mFG_ConGenList.Remove(posRemember);
            } else {
                HRESULT hr = MakeConnection(pcg);
                if (FAILED(hr)){
                    bDeferred = TRUE;
                } else {
                    delete pcg;
                    mFG_ConGenList.Remove(posRemember);
                    bProgress = TRUE;
                }
            }
        }
    }
    return (bDeferred ? S_FALSE : S_OK);
}  // AttemptDeferredConnections


//----------------------------------------------------------------------
// SaveFilterPrivateData
//
// Given that pips is a pointer to the IPersistStream interface on a filter,
// write to pStm the length of the private data of the filter as 10 decimal digits
// expressed as chars followed by a single space, followed by the private data
// of the filter.  Leave the stream positioned at the end of the private data.
// Pass the fClearDirty flag on to the filter.
//----------------------------------------------------------------------
HRESULT CFilterGraph::SaveFilterPrivateData
    (LPSTREAM pStm, IPersistStream* pips, BOOL fClearDirty)
{
    // We actually do things in a different order to achieve the above effect.
    // To allow the filter to do what it likes without advance notice, but
    // allow the stream to be parsed in one pass when we read it back in
    // we
    //    Snapshot the position at this point,
    //    Write bkanks where the size will go (10 digits plus a space)
    //    Call the filter,
    //    Find the position again,
    //    Subtract the two positions to get the real size of the filter,
    //    Seek back to the first position,
    //    Write the size data,
    //    Seek forward to the second position

    ULARGE_INTEGER StreamPos1;
    LARGE_INTEGER li;
    li.QuadPart = 0;
    HRESULT hr = pStm->Seek(li, STREAM_SEEK_CUR, &StreamPos1);  // get position
    if (FAILED(hr)) {
        return hr;
    }

    // make some space where we will go back and write a length
    const int SIZEOFLENGTH = 22;
    hr = pStm->Write(L"           ", SIZEOFLENGTH, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pips->Save(pStm, fClearDirty);                   // Write filter data
    if (FAILED(hr)) {
        return hr;
    }

    ULARGE_INTEGER StreamPos2;
    hr = pStm->Seek(li, STREAM_SEEK_CUR, &StreamPos2);     // get position
    if (FAILED(hr)) {
        return hr;
    }
    int cbFilter = (int)(StreamPos2.QuadPart-StreamPos1.QuadPart);
    cbFilter -= SIZEOFLENGTH;            // subtract our own size field and delimiter
    WCHAR Buff[12];
    wsprintfW(Buff, L"%010d ", cbFilter);   // must be SIZEOFLENGTH bytes (or less)
    li.QuadPart = StreamPos1.QuadPart;
    hr = pStm->Seek(li, STREAM_SEEK_SET, NULL);   // reset position
    if (FAILED(hr)) {
        return hr;
    }

    hr = pStm->Write( Buff, 22, NULL);      // write length
    if (FAILED(hr)) {
        return hr;
    }

    li.QuadPart = StreamPos2.QuadPart;
    hr = pStm->Seek(li, STREAM_SEEK_SET, NULL);   // reset position
    return hr;
} // SaveFilterPrivateData


//----------------------------------------------------------------------
// SaveFilters
//
// Write the keyword FILTERS and write all the filters and their private
// data out to pStm.  Pass the fClearDirty flag on to them.
// (It can be false in the SaveAs case)
// Bring filgen nPersist up to date.
//----------------------------------------------------------------------
HRESULT CFilterGraph::SaveFilters(LPSTREAM pStm, BOOL fClearDirty)
{
    // This routine progressively acquires resources and then releases them
    // in the inverse order.  Because the compiler isn't very good, multiple returns
    // are inefficient (at the moment).  To avoid this, there is code at
    // the end (ONE copy) which releases everything.  It has a bunch of
    // (shut-eyes, cross fingers behind back) GOTO targets.  Each target
    // causes some level of releasing and then exits.  Sorry.
    // The alternatives were so verbose, they seemed worse.

    HRESULT hr = pStm->Write( mFG_FiltersStringX
                            , lstrlenW(mFG_FiltersStringX)*sizeof(WCHAR)
                            , NULL
                            );
    if (FAILED(hr)) return hr;

    IPersist * pip;
    IPersistStream * pips;
    int nPersistFilter = 1;   // MUST NOT start from 0 (loading depends on this
                              // the persist offset thing would go wrong).

    // Reverse traverse of FILGENs to put the filters in the graph in
    // downstream order.
    POSITION Pos = mFG_FilGenList.GetTailPosition();
    while(Pos!=NULL) {
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        FilGen * pfg = mFG_FilGenList.Get(Pos);
        Pos = mFG_FilGenList.Prev(Pos);

        //-----------------------------------------------------------------
        // Write filter number followed by blank
        //-----------------------------------------------------------------

        pfg->nPersist = nPersistFilter; // SaveConnections needs this up to date
        WCHAR Buff[MAX_PATH+3];

        wsprintfW(Buff, L"%04d ", nPersistFilter);

        hr = pStm->Write(Buff, 10, NULL);
        if (FAILED(hr)) {
            goto BARE_RETURN;
        }

        //-----------------------------------------------------------------
        // Write filter name in quotes followed by blank
        //-----------------------------------------------------------------

        int Len = wsprintfW(Buff, L"\"%ls\" ", pfg->pName);
        hr = pStm->Write(Buff, Len*sizeof(WCHAR), NULL);


        //-----------------------------------------------------------------
        // Write filter clsid followed by blank
        //-----------------------------------------------------------------
        hr = pfg->pFilter->QueryInterface(IID_IPersist, (void**)&pip);
        if (FAILED(hr)) {
            goto BARE_RETURN;
        }

        CLSID clsid;
        hr = pip->GetClassID(&clsid);
        if (FAILED(hr)) {
            goto RELEASE_PERSIST;
        }

        hr = StringFromGUID2( clsid, Buff, CHARS_IN_GUID);
        if (FAILED(hr)) {
            goto RELEASE_PERSIST;
        }
        // Originally I had
        // lstrcatW(Buff, L" ");
        // here - but the compiler appeared to optimise it away!!!!
        // So now I'm doing the thing in two separate writes

        hr = pStm->Write(Buff, lstrlenW(Buff)*sizeof(WCHAR), NULL);
        if (FAILED(hr)) {
            goto RELEASE_PERSIST;
        }
        hr = pStm->Write(L" ", sizeof(WCHAR), NULL);
        if (FAILED(hr)) {
            goto RELEASE_PERSIST;
        }


        //-----------------------------------------------------------------
        // If it's a file source or sink, write the file name
        //-----------------------------------------------------------------

        {
            IFileSourceFilter * pifsource;
            IFileSinkFilter * pifsink;

            hr = pfg->pFilter->QueryInterface(IID_IFileSourceFilter, (void**)&pifsource);
            if (hr==E_NOINTERFACE) {
                // nothing to do
            } else if (FAILED(hr)) {
                goto RELEASE_PERSIST;
            } else {
                // it's a file source
                hr = pStm->Write( L"SOURCE "                         // DO NOT LOCALISE
                                , lstrlenW(L"SOURCE ")*sizeof(WCHAR) // DO NOT LOCALISE
                                , NULL
                                );
                if (FAILED(hr)) {
                    pifsource->Release();
                    goto RELEASE_PERSIST;
                }
                AM_MEDIA_TYPE mt;
                WCHAR *WBuff;
                hr = pifsource->GetCurFile(&WBuff, &mt);
                pifsource->Release();
                if (FAILED(hr)) {
                    goto RELEASE_PERSIST;
                }

                wsprintfW(Buff, L"\"%ls\" ", WBuff);
                hr = pStm->Write(Buff, lstrlenW(Buff)*sizeof(WCHAR), NULL);
                QzTaskMemFree(WBuff);
                if (FAILED(hr)) {
                    goto RELEASE_PERSIST;
                }
            }

            hr = pfg->pFilter->QueryInterface(IID_IFileSinkFilter, (void**)&pifsink);
            if (hr==E_NOINTERFACE) {
                // nothing to do
            } else if (FAILED(hr)) {
                goto RELEASE_PERSIST;
            } else {
                // it's a file source
                hr = pStm->Write( L"SINK "                         // DO NOT LOCALISE
                                , lstrlenW(L"SINK ")*sizeof(WCHAR) // DO NOT LOCALISE
                                , NULL
                                );
                if (FAILED(hr)) {
                    pifsink->Release();
                    goto RELEASE_PERSIST;
                }
                AM_MEDIA_TYPE mt;
                WCHAR *WBuff;
                hr = pifsink->GetCurFile(&WBuff, &mt);
                pifsink->Release();
                if (FAILED(hr)) {
                    goto RELEASE_PERSIST;
                }

                wsprintfW(Buff, L"\"%ls\" ", WBuff);
                hr = pStm->Write(Buff, lstrlenW(Buff)*sizeof(WCHAR), NULL);
                QzTaskMemFree(WBuff);
                if (FAILED(hr)) {
                    goto RELEASE_PERSIST;
                }
            }
        }

        hr = pfg->pFilter->QueryInterface(IID_IPersistStream, (void**)&pips);
        if (hr==E_NOINTERFACE) {
            hr = pStm->Write(L"0000000000 \r\n", 26, NULL);
            if (FAILED(hr)) {
                goto RELEASE_PERSIST;
            }
        } else if (FAILED(hr)) {
                goto RELEASE_PERSIST;
        } else {

            hr = SaveFilterPrivateData(pStm, pips, fClearDirty);
            if (FAILED(hr)) {
                goto RELEASE_PERSISTSTREAM;
            }

            hr = pStm->Write(L"\r\n", 4, NULL);
            if (FAILED(hr)) {
                goto RELEASE_PERSISTSTREAM;
            }

            pips->Release();
        }
        pip->Release();

        ++nPersistFilter;
    }  // end of reverse traverse of filgens

    goto BARE_RETURN;

RELEASE_PERSISTSTREAM:
    pips->Release();
RELEASE_PERSIST:
    pip->Release();
BARE_RETURN:
    return hr;
} // SaveFilters


// Write the id of ppin to stream pStm in quotes, followed by a space
HRESULT CFilterGraph::WritePinId(LPSTREAM pStm, IPin * ppin)
{
    LPWSTR id;

    HRESULT hr = ppin->QueryId(&id);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pStm->Write( L"\"", 2, NULL);
    if (FAILED(hr)) {
        QzTaskMemFree(id);
        return hr;
    }

    hr = pStm->Write( id, lstrlenW(id)*sizeof(WCHAR), NULL);
    if (FAILED(hr)) {
        QzTaskMemFree(id);
        return hr;
    }


    hr = pStm->Write( L"\" ", 4, NULL);
    if (FAILED(hr)) {
        QzTaskMemFree(id);
        return E_FAIL;
    }

    QzTaskMemFree(id);
    return NOERROR;
} // WritePinId


HRESULT CFilterGraph::SaveConnection( LPSTREAM     pStm
                                    , int          nFilter1
                                    , IPin *       pp1
                                    , int          nFilter2
                                    , IPin *       pp2
                                    , CMediaType & cmt
                                    )
{
// 0001 "Output pin" 0002 "In"                                // no line break here
//     0000000172 {00000000-0000-0000-0000-000000000003}      // no line break here
//     {00000000-0000-0000-0000-000000000004} 1 0             // no line break here
//     {00000000-0000-0000-0000-000000000005}         18 YYYYYYYYYYYYYYYYYY

    WCHAR Buff[12];

    wsprintfW(Buff, L"%04d ", nFilter1);
    HRESULT hr = pStm->Write( Buff, 10, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    hr = WritePinId(pStm, pp1);
    if (FAILED(hr)) {
        return hr;
    }

    wsprintfW(Buff, L"%04d ", nFilter2);
    hr = pStm->Write( Buff, 10, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    hr = WritePinId(pStm, pp2);
    if (FAILED(hr)) {
        return hr;
    }

    wsprintfW(Buff, L"%010d ", MediaTypeTextSize(cmt));
    hr = pStm->Write( Buff, 22, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    LPWSTR pstr;
    MediaTypeToText(cmt, pstr);         // ??? Unnecessary copy - value parm

    hr = pStm->Write( pstr, MediaTypeTextSize(cmt), NULL);
    QzTaskMemFree(pstr);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pStm->Write( L"\r\n", 4, NULL);

    return hr;

} // SaveConnection


//===================================================================
// Save all the connections to pStm in such an order that
// UPstream nodes are always encountered before DOWNstream nodes.
// This means that just working through the saved file is a valid order
// for re-establishing connections.
//===================================================================

HRESULT CFilterGraph::SaveConnections(LPSTREAM pStm)
{
    HRESULT hr;

    hr = pStm->Write( mFG_ConnectionsStringX
                    , lstrlenW(mFG_ConnectionsStringX)*sizeof(WCHAR)
                    , NULL
                    );
    if (FAILED(hr)) return hr;

    // for each filter
    //    for each pin

    // Work through the filgen list in REVERSE ORDER.
    // The connections have to be DOWNSTREAM sorted.
    POSITION Pos = mFG_FilGenList.GetTailPosition();;
    while (Pos!=NULL) {
        FilGen * pfg;

        pfg = mFG_FilGenList.Get(Pos);
        Pos = mFG_FilGenList.Prev(Pos);

        // Only enumerate input pins
        // (Note for the future.  There is no way in this scheme to
        // save out-of-graph connections).
        CEnumPin Next(pfg->pFilter, CEnumPin::PINDIR_INPUT);
        IPin *pPinIn;
        while ((PVOID) ( pPinIn = Next() )) {

           IPin *pPinOut;
           pPinIn->ConnectedTo(&pPinOut);
           if (pPinOut!=NULL) {
               PIN_INFO pi;
               HRESULT hr1 = pPinOut->QueryPinInfo(&pi);
               if (FAILED(hr1)) {
                   pi.pFilter=NULL;
                   hr = hr1;
               }
               CMediaType cmt;
               hr1 = pPinOut->ConnectionMediaType(&cmt);
               if (FAILED(hr1)) {
                   hr = hr1;
               }
               hr1 = SaveConnection( pStm
                                   , mFG_FilGenList.FilterNumber(pi.pFilter)
                                   , pPinOut
                                   , mFG_FilGenList.FilterNumber(pfg->pFilter)
                                   , pPinIn
                                   , cmt
                                   );
               if (FAILED(hr1)) {
                   hr = hr1;
               }
               QueryPinInfoReleaseFilter(pi);
               FreeMediaType(cmt);
               pPinOut->Release();
           }
           pPinIn->Release();
        }
    }

    return hr;
} // SaveConnections



HRESULT CFilterGraph::SaveClock(LPSTREAM pStm)
{
    HRESULT hr;
    // Write out whether the clock is required or not.
    hr = pStm->Write( (mFG_bNoSync ? L"CLOCK 0 " : L"CLOCK 1 "), 16, NULL);

    int nClock = 0;            // filter number of clock filter, default 0 (no filter)
    CLSID clsid = CLSID_NULL;  // class id of clock when it's not a filter.
    if (m_pClock) {

        // See if the clock comes from some filter in the graph

        FilGen *pfg = mFG_FilGenList.GetByFilter(m_pClock);
        if (pfg) {
            nClock = pfg->nPersist;
        }

        if (nClock==0) {
            // There is a clock, but it doesn't come from a filter.
            // Get its class id instead.
            IPersist *pip;
            hr = m_pClock->QueryInterface(IID_IPersist, (void**)&pip);
            if (SUCCEEDED(hr) && pip!=NULL) {
                hr = pip->GetClassID(&clsid);
                pip->Release();
                if (FAILED(hr)) {
                    return hr;
                }
            } else {
                return hr;
            }

        }
    }

    // We now have one of the following:
    // clock from filter: nClock
    // clock from elsewhere: clsid (not CLSID_NULL)
    // no clock: nClock==0 and clsid==CLSID_NULL

    if (clsid!=CLSID_NULL) {
        WCHAR Buff[CHARS_IN_GUID];
        hr = StringFromGUID2( clsid, Buff, CHARS_IN_GUID);
        if (FAILED(hr)) {
            return hr;
        }

        // CHARS_IN_GUID allows for a trailing null
        hr = pStm->Write(Buff, (CHARS_IN_GUID-1)*sizeof(WCHAR), NULL);
        if (FAILED(hr)) {
            return hr;
        }
    } else {
        WCHAR Buff[5];
        wsprintfW(Buff, L"%04d", nClock);

        hr = pStm->Write(Buff, 8, NULL);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // write a delimiter
    hr = pStm->Write(L"\r\n", 2*sizeof(WCHAR), NULL);

    return hr;

} // SaveClock




STDMETHODIMP CFilterGraph::Save(LPSTREAM pStm, BOOL fClearDirty)
{
    CheckPointer(pStm, E_POINTER);
    HRESULT hr;
    // We save this even if we are not dirty.  It could be a SaveAs
    // saving it to a new place.

    CAutoMsgMutex cObjectLock(&m_CritSec);
    hr = UpstreamOrder();
    if( FAILED( hr ) ) {
        return hr;
    }

    // Write file format version number.
    // If we change the format, increase this, then we can retain the
    // ability to read old files, or at least detect them.
    hr = pStm->Write( L"0003\r\n", 12, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    hr = SaveFilters(pStm, fClearDirty);
    if (FAILED(hr)) {
        return hr;
    }

    hr = SaveConnections(pStm);
    if (FAILED(hr)) {
        return hr;
    }

    hr = SaveClock(pStm);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pStm->Write(L"END", sizeof(L"END")-2, NULL);// DO NOT LOCALISE
    if (FAILED(hr)) return hr;

    if (mFG_bDirty) {
        mFG_bDirty = !fClearDirty;
    }
    return NOERROR;

} // Save


// set cbSize to the max number of bytes that will be needed to save
// all the connections into a stream
HRESULT CFilterGraph::GetMaxConnectionsSize(int &cbSize)
{
    HRESULT hr = NOERROR;
    cbSize = 0;
    // Same traversal as for SaveConnections
    POSITION Pos = mFG_FilGenList.GetTailPosition();;
    while (Pos!=NULL) {
        FilGen * pfg;

        pfg = mFG_FilGenList.Get(Pos);
        Pos = mFG_FilGenList.Prev(Pos);

        // Only enumerate input pins
        CEnumPin Next(pfg->pFilter, CEnumPin::PINDIR_INPUT);
        IPin *pPinIn;
        while ((PVOID) ( pPinIn = Next() )) {

            IPin *pPinOut;
            pPinIn->ConnectedTo(&pPinOut);
            if (pPinOut!=NULL) {
                CMediaType cmt;
                HRESULT hr1 = pPinOut->ConnectionMediaType(&cmt);
                if (FAILED(hr1)) {
                    hr = hr1;
                }

                cbSize += 28; // n1, n2, + 2 spaces +crlf in UNICODE
                cbSize += MediaTypeTextSize(cmt);

                LPWSTR id;
                hr1 = pPinOut->QueryId(&id);
                if (FAILED(hr1)) {
                    hr = hr1;
                } else {
                    cbSize += sizeof(WCHAR)*lstrlenW(id)+6;  // two " and a space
                    CoTaskMemFree(id);
                }

                hr1 = pPinIn->QueryId(&id);
                if (FAILED(hr1)) {
                    hr = hr1;
                } else {
                    cbSize += sizeof(WCHAR)*lstrlenW(id)+6;  // two " and a space
                    CoTaskMemFree(id);
                }
                FreeMediaType(cmt);
                pPinOut->Release();
            }
            pPinIn->Release();
        }
    }

    return hr;
} // GetMaxConnectionsSize



STDMETHODIMP CFilterGraph::GetSizeMax(ULARGE_INTEGER * pcbSize)
{
    CheckPointer(pcbSize, E_POINTER);
    // The size will be
    // sizeof(WCHAR)
    // * (  7+2    // FILTERS
    //   + for each filter
    //     ( 4+1                     // number
    //     + CHARS_IN_GUID +1        // uuid
    //     + length of name +2 +1    // "filter name"
    //     + 10 +1                   // length of filter data
    //     + 2                       // new line
    //     )
    //   + 11 +2                     // CONNECTIONS
    //   + for each connection
    //     ( 4+1                     // filter1 number
    //     + length of pin name 2 +1 // "pin1 name"
    //     + 4+1                     // filter2 number
    //     + length of pin name 2 +1 // "pin2 name"
    //     + 154                     // basic media type
    //     )
    // + for each filter
    //   ( GetSizeMax() for its own private data
    //   )
    // + for each connection
    //   ( length of format block in text form
    //   )
    //
    // which amounts to
    //
    //      44
    //    + nFilters*120
    //    + nConnection*340
    //    + sum(filter name lengths)
    //    + sum(pin name lengths)
    //  WCHARs
    //    + sum(filter data lengths)
    //    + sum(format data lengths)
    //  bytes
    //
    // NOTE: these are always ANSI chars, not TCHARS, so a char is a byte


    HRESULT hr = NOERROR;

    // Sigh.  Do we have to allow for the filter that wants to save a
    // 5GB movie as part of its filter data.
    LONGLONG MaxSize = 44;

    TRAVERSEFILGENS(Pos, pfg)                                              \

        // Add overhead for the filter
        MaxSize += 120;

        FILTER_INFO fi;
        hr = pfg->pFilter->QueryFilterInfo(&fi);
        if (SUCCEEDED(hr)) {
            MaxSize += sizeof(WCHAR)*lstrlenW(fi.achName);
            QueryFilterInfoReleaseGraph(fi);
        } else {
            break;          // Ouch!
        }

        IPersistStream * pps;
        hr = pfg->pFilter->QueryInterface(IID_IPersistStream, (void**)&pps);
        if (FAILED(hr)) {
            continue;        // a filter with no IPersist has no data
        }

        ULARGE_INTEGER li;
        hr = pps->GetSizeMax(&li);
        if (SUCCEEDED(hr)) {
            MaxSize += li.QuadPart;
        } else {
            pps->Release();
            break;           // Ouch!
        }
        pps->Release();


    ENDTRAVERSEFILGENS


    if (SUCCEEDED(hr)) {
        // Add to MaxSize the size needed for all the connections.
        int cbSize;
        hr = GetMaxConnectionsSize(cbSize);
        pcbSize->QuadPart += cbSize;

    }


    if (SUCCEEDED(hr)) {
        hr = S_OK;
        pcbSize->QuadPart = MaxSize;
    } else {
        pcbSize->QuadPart = 0;
    }

    return hr;

} // GetSizeMax

HRESULT CFilterGraph::RunningStartFilters()
{
    ASSERT(CritCheckIn(&m_CritSec));

    if(m_State == State_Stopped) {
        return S_OK;
    }

    HRESULT hr = NOERROR;

    // If the list was not in upstream order already, make it so now.
    if (mFG_iVersion !=mFG_iSortVersion) {
        hr = UpstreamOrder();
        if (FAILED(hr)) {
            return hr;    // e.g. VFW_E_CIRCULAR_GRAPH
        }
    }

    CumulativeHRESULT chr(S_OK);
    chr.Accumulate(S_OK);
    TRAVERSEFILGENS(Pos, pfg)

        if(pfg->dwFlags & FILGEN_ADDED_RUNNING)
        {
            // !!! filters may already be in the running state. harm?

            if(m_State == State_Running) {
                chr.Accumulate( pfg->pFilter->Run(m_tStart) );
            } else {
                ASSERT(m_State == State_Paused);
                chr.Accumulate( pfg->pFilter->Pause() );
            }
        }

    ENDTRAVERSEFILGENS
    hr = chr;

    return hr;
}

// These strings are NOT LOCALISABLE!  They are real constants.
const WCHAR CFilterGraph::mFG_FiltersString[] = L"FILTERS";         // DON'T LOCALISE
const WCHAR CFilterGraph::mFG_FiltersStringX[] = L"FILTERS\r\n";    // DON'T LOCALISE
const WCHAR CFilterGraph::mFG_ConnectionsString[] = L"CONNECTIONS"; // DON'T LOCALISE
const WCHAR CFilterGraph::mFG_ConnectionsStringX[] = L"CONNECTIONS\r\n"; // DON'T LOCALISE
const OLECHAR CFilterGraph::mFG_StreamName[] = L"ActiveMovieGraph";   // DON'T LOCALISE


//========================================================================
//=====================================================================
// Other methods of class FilGen
//=====================================================================
//========================================================================


//========================================================================
//
// Constructor(IBaseFilter *)
//
// QI to see if this filter supports IPersistStorage.
// AddRef the filter.
// if pF is NULL then just do a minimal initialisation.
//========================================================================

CFilterGraph::FilGen::FilGen(IBaseFilter *pF, DWORD dwFlags)
    : pFilter(pF)
    , pName(NULL)
    , dwFlags(dwFlags)
{
    Rank = -1;
    nPersist = -1;

} // FilGen construct from filter


//=======================================================================
//
// Destructor
//
// Release the Filter & PersistStorage interfaces we got
//=======================================================================

CFilterGraph::FilGen::~FilGen()
{
    delete[] pName;
} // ~FilGen



//========================================================================
//=====================================================================
// Methods of class CFilGenList
//=====================================================================
//========================================================================

//=====================================================================
//
// GetByPersistNumber
//
// Find the FilGen that has the supplied nPersist
// return NULL if none exists.
//=====================================================================

CFilterGraph::FilGen * CFilterGraph::CFilGenList::GetByPersistNumber(int nPersist)
{

    POSITION pos = GetHeadPosition();
    while (pos != NULL) {
        CFilterGraph::FilGen *pFilGen = GetNext(pos);
        if (pFilGen->nPersist == nPersist) {
            return pFilGen;
        }
    }
    return NULL;
} // GetByPersistNumber


//===================================================================
//
// GetByFilter(IBaseFilter *)
//
// Find a filter in the list of FilGen
// return a pointer to that FilGen node.
// return NULL if it's not there.
//===================================================================

CFilterGraph::FilGen * CFilterGraph::CFilGenList::GetByFilter(IUnknown * pFilter)
{
    POSITION Pos = GetHeadPosition();

    // in the first pass, compare IFilter pointers directly (faster).
    while(Pos!=NULL) {
        CFilterGraph::FilGen * pfg = GetNext(Pos); // side-efects Pos onto next
        if (pFilter == pfg->pFilter)
        {
            return pfg;
        }
    }

    // 2nd pass: try the more expensive IsEqualObject()
    Pos = GetHeadPosition();

    while(Pos!=NULL) {
        CFilterGraph::FilGen * pfg = GetNext(Pos); // side-efects Pos onto next
        if (IsEqualObject(pfg->pFilter,pFilter))
        {
            return pfg;
        }
    }

    return NULL;
} // GetByFilter

int CFilterGraph::CFilGenList::FilterNumber(IBaseFilter * pF)
{
    FilGen *pfg = GetByFilter(pF);
    if (pfg) {
        return pfg->nPersist;
    } else {
        return -1;
    }
} // CFilGenList::FilterNumber

void CFilterGraph::SetInternalFilterFlags( IBaseFilter* pFilter, DWORD dwFlags )
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock.
    ASSERT( CritCheckIn( GetCritSec() ) );

    // Make sure the filter is in the filter graph.
    ASSERT( SUCCEEDED( CheckFilterInGraph( pFilter ) ) );

    // Make sure flags are valid.
    ASSERT( IsValidInternalFilterFlags( dwFlags ) );

    CFilterGraph::FilGen *pfgen = mFG_FilGenList.GetByFilter( pFilter );

    // If this ASSERT fires, then the filter is not in the filter graph.
    ASSERT( NULL != pfgen );

    pfgen->dwFlags = dwFlags;
}

DWORD CFilterGraph::GetInternalFilterFlags( IBaseFilter* pFilter )
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock.
    ASSERT( CritCheckIn( GetCritSec() ) );

    // Make sure the filter is in the filter graph.
    ASSERT( SUCCEEDED( CheckFilterInGraph( pFilter ) ) );

    CFilterGraph::FilGen *pfgen = mFG_FilGenList.GetByFilter( pFilter );

    // If this ASSERT fires, then the filter is not in the filter graph.
    ASSERT( NULL != pfgen );

    // Make sure flags we are returning are valid.
    ASSERT( IsValidInternalFilterFlags( pfgen->dwFlags ) );

    return pfgen->dwFlags;
}


//========================================================================
//=====================================================================
// Methods of class CFilGenList::CEnumFilters
//=====================================================================
//========================================================================


//=====================================================================
//
// CFilGenList::CEnumFilters::operator()
//
// return the next IBaseFilter
//=====================================================================

IBaseFilter * CFilterGraph::CFilGenList::CEnumFilters::operator++ (void)
{
    if (m_pos != NULL) {
        FilGen * pfg = m_pfgl->GetNext(m_pos);
        ASSERT(pfg->pFilter);
        return pfg->pFilter;
    }
    return NULL;
}

//========================================================================
//=====================================================================
// Methods of class CEnumFilters
//=====================================================================
//========================================================================


//=====================================================================
//
// CEnumFilters constructor   (normal, public version)
//
//=====================================================================

CEnumFilters::CEnumFilters
    ( CFilterGraph *pFilterGraph )
    : CUnknown(NAME("CEnumFilters"), NULL),
      mEF_pFilterGraph(pFilterGraph)
{
    // The graph whose filters we are going to enumerate is allowed to
    // asynchronously change the list while we are doing it.
    // This is expected to be rare (even anomolous).
    // Therefore we take a copy of the version number when we start
    // and check that it doesn't alter as we enumerate.  If it does
    // we fail the enumeration and the caller can either reset or
    // get a new enumerator to start again (or give up).

    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);
    mEF_pFilterGraph->AddRef();
    mEF_iVersion = mEF_pFilterGraph->GetVersion();
    mEF_Pos = pFilterGraph->mFG_FilGenList.GetHeadPosition();

} // CEnumFilters constructor (public version)



//=====================================================================
//
// CEnumFilters constructor   (private version for clone)
//
//=====================================================================

CEnumFilters::CEnumFilters
    ( CFilterGraph *pFilterGraph,
      POSITION Position,
      int iVersion
    )
    : CUnknown(NAME("CEnumFilters"), NULL),
      mEF_pFilterGraph(pFilterGraph)
{
    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);
    mEF_pFilterGraph->AddRef();
    mEF_iVersion = iVersion;
    mEF_Pos = Position;

} // CEnumFilters::CEnumFilters - private constructor



//=====================================================================
//
// CEnumFilters destructor
//
//=====================================================================

CEnumFilters::~CEnumFilters()
{
    // Release the reference that the constructor got.
    mEF_pFilterGraph->Release();

} // CEnumFilters destructor



//=====================================================================
//
// CEnumFilters::NonDelegatingQueryInterface
//
//=====================================================================

STDMETHODIMP CEnumFilters::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IEnumFilters) {
        return GetInterface((IEnumFilters *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
} // CEnumFilters::NonDelegatingQueryInterface



//=====================================================================
//
// CEnumFilters::Next
//
//=====================================================================

STDMETHODIMP CEnumFilters::Next
    (   ULONG cFilters,           // place this many AddReffed filters...
        IBaseFilter ** ppFilter,  // ...in this array of IBaseFilter*
        ULONG * pcFetched         // actual count passed returned here
    )
{
    CheckPointer(ppFilter, E_POINTER);
    CAutoLock cObjectLock(this);
    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);
    if (pcFetched!=NULL) {
        *pcFetched = 0;           // default unless we succeed
    }
    // now check that the parameter is valid
    else if (cFilters>1) {        // pcFetched == NULL
        return E_INVALIDARG;
    }

    if (mEF_iVersion!=mEF_pFilterGraph->GetVersion() ) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    ULONG cFetched = 0;           // increment as we get each one.

    if (NULL==mEF_Pos) {
       return S_FALSE;
    }

    while(cFetched < cFilters) {

        // Retrieve the current and step to the next (Eugh)
        CFilterGraph::FilGen * pFilGen = mEF_pFilterGraph->mFG_FilGenList.GetNext(mEF_Pos);
        ASSERT(pFilGen !=NULL);

        ppFilter[cFetched] = pFilGen->pFilter;
        pFilGen->pFilter.p->AddRef();
        ++cFetched;

        if (NULL==mEF_Pos) {
            break;
        }
    }

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    return (cFilters==cFetched ? S_OK : S_FALSE);

} // CEnumFilters::Next



//=====================================================================
//
// CEnumFilters::Skip
//
//=====================================================================
STDMETHODIMP CEnumFilters::Skip(ULONG cFilters)
{
    // We not only need to lock ourselves (so that we can update m_position)
    // We also need to lock the list that we are traversing
    CAutoLock cObjectLockEnum(this);

    if (mEF_iVersion!=mEF_pFilterGraph->GetVersion() ) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    // Now we need the second lock
    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);

    // Do we have any left to Skip?
    if (!mEF_Pos) {
        return(E_INVALIDARG);
        // This matches the OLE spec for IENUMx::Skip
        // IF we interpret being at the end of the list as
        // an invalid place at which to start skipping
    }


    while(cFilters--) {

        // Do we have any left to Skip?
        // If there are no more to skip, but the skip count has not
        // been exhausted then we should return S_FALSE.
        if (!mEF_Pos)
            return(S_FALSE);
            // we skipped fewer than requested, but we did skip at least one
            // note: putting this here only make sense for the second and
            // subsequent iteration.  However, putting it after the call to
            // GetNext means we end up testing cFilters again.

        // Note: GetNext(NULL) leaves it still NULL
        mEF_pFilterGraph->mFG_FilGenList.GetNext(mEF_Pos);
    }
    return NOERROR;
};  // CEnumFilters::Skip



/* Reset has 3 simple steps:
 *
 * Set position to head of list
 * Sync enumerator with object being enumerated
 * return S_OK
 */

STDMETHODIMP CEnumFilters::Reset(void)
{
    CAutoLock cObjectLock(this);
    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);

    HRESULT hr = mEF_pFilterGraph->UpstreamOrder();
    if( SUCCEEDED( hr ) ) {
        mEF_iVersion = mEF_pFilterGraph->GetVersion();
        mEF_Pos = mEF_pFilterGraph->mFG_FilGenList.GetHeadPosition();
    }

    return hr;
};



//=====================================================================
//
// CEnumFilters::Clone
//
//=====================================================================

STDMETHODIMP CEnumFilters::Clone(IEnumFilters **ppEnum)
{
    CheckPointer(ppEnum, E_POINTER);
    // Since we are taking a snapshot
    // of an object (current position and all) we must lock access at the start
    CAutoLock cObjectLock(this);

    HRESULT hr = NOERROR;
    CEnumFilters *pEnumFilters;

    pEnumFilters = new CEnumFilters(mEF_pFilterGraph, mEF_Pos, mEF_iVersion);
    if (pEnumFilters == NULL) {
        *ppEnum = NULL;
        return E_OUTOFMEMORY;
    }

    /* Get a reference counted IID_IEnumFilters interface to "return" */

    return pEnumFilters->QueryInterface(IID_IEnumFilters,(void **)ppEnum);

} // CEnumFilters::Clone


// IObjectWithSite::SetSite
// remember who our container is, for QueryService or other needs
//        Used also by objects locally registered in IRegisterServiceProvider when
//        they can't find local objects.

STDMETHODIMP
CFilterGraph::SetSite(IUnknown *pUnkSite)
{
    DbgLog((LOG_TRACE, 3, TEXT("SetSite")));

    // note: we cannot addref our site without creating a circle
    // luckily, it won't go away without releasing us first.
    mFG_punkSite = pUnkSite;

    return S_OK;
}

// IObjectWithSite::GetSite
// return an addrefed pointer to our containing object
STDMETHODIMP
CFilterGraph::GetSite(REFIID riid, void **ppvSite)
{
    DbgLog((LOG_TRACE, 3, TEXT("GetSite")));

    if (mFG_punkSite)
        return mFG_punkSite->QueryInterface(riid, ppvSite);

    return E_NOINTERFACE;
}


// Request that the graph builder should return as soon as possible from
// its current task.  Returns E_UNEXPECTED if there is no task running.
// Note that it is possible fot the following to occur in the following
// sequence:
//     Operation begins; Abort is requested; Operation completes normally.
// This would be normal whenever the quickest way to finish an operation
// was to simply continue to the end.
STDMETHODIMP CFilterGraph::Abort(){
    mFG_bAborting = TRUE;
    return NOERROR;
}


// Return S_OK if the curent operation is to continue,
// return S_FALSE if the current operation is to be aborted.
// E_UNEXPECTED may be returned if there was no operation in progress.
// This method can be called as a callback from a filter which is doing
// some operation at the request of the graph.
STDMETHODIMP CFilterGraph::ShouldOperationContinue(){
    return (mFG_bAborting ? S_FALSE : S_OK);
}


// Have the application thread call this entry point
STDMETHODIMP CFilterGraph::PostCallBack(LPVOID pfn, LPVOID pvParam)
{
    if (m_hwnd == NULL) return E_FAIL;

    // Use AWM_CREATEFILTER, since that's the only message guaranteed to be dispatched
    // on the background thread....

    AwmCreateFilterArg *pcfa = new AwmCreateFilterArg;

    if (!pcfa)
        return E_OUTOFMEMORY;

    pcfa->creationType = AwmCreateFilterArg::USER_CALLBACK;
    pcfa->pfn = (LPTHREAD_START_ROUTINE) pfn;
    pcfa->pvParam = pvParam;

    if (!PostMessage(m_hwnd, AWM_CREATEFILTER, (WPARAM) pcfa, 0)) {
        delete pcfa;
        return E_OUTOFMEMORY;
    }

    return S_OK;
};


// --- IAMOpenProgress ---

STDMETHODIMP
CFilterGraph::QueryProgress(LONGLONG* pllTotal, LONGLONG* pllCurrent)
{
    CAutoLock lock(&mFG_csOpenProgress);

    HRESULT hr = E_NOINTERFACE;

    *pllTotal = *pllCurrent = 0;

    POSITION Pos = mFG_listOpenProgress.GetHeadPosition();
    while (Pos!=NULL) {
    LONGLONG llTotal, llCurrent;

        IAMOpenProgress * pOp;
        pOp = mFG_listOpenProgress.GetNext(Pos);    // side-efects Pos onto next

    HRESULT hr2 = pOp->QueryProgress(&llTotal, &llCurrent);
    if (SUCCEEDED(hr2)) {
        hr = hr2;
        *pllTotal += llTotal;
        *pllCurrent += llCurrent;
    }
    }

    return hr;
}

STDMETHODIMP
CFilterGraph::AbortOperation()
{
    CAutoLock lock(&mFG_csOpenProgress);

    if (mFG_RecursionLevel > 0)
    mFG_bAborting = TRUE;

    HRESULT hr = E_NOINTERFACE;

    POSITION Pos = mFG_listOpenProgress.GetHeadPosition();
    while (Pos!=NULL) {
        IAMOpenProgress * pOp;
        pOp = mFG_listOpenProgress.GetNext(Pos);    // side-efects Pos onto next

    hr = pOp->AbortOperation();
    }

    return hr;
}

// --- Other methods ---

void CFilterGraph::NotifyChange()
{
    if (mFG_RecursionLevel==0) {
    if (mFG_pDistributor) mFG_pDistributor->NotifyGraphChange();
    }
}

//  Initialize our thread creating cs
void CFilterGraph::InitClass(BOOL bCreate, const CLSID *pclsid)
{
    if (bCreate) {
        _Module.Init(NULL, g_hInst);
        InitializeCriticalSection(&g_Stats.m_cs);
        g_Stats.Init();
        InitializeCriticalSection(&g_csObjectThread);

    } else {
        //  For some reason g_dwObjectThreadId can be 0 here
        ASSERT(g_cFGObjects == 0 /*&& g_dwObjectThreadId == 0*/);
        DeleteCriticalSection(&g_csObjectThread);
        _Module.Term();
        DeleteCriticalSection(&g_Stats.m_cs);
    }
}


struct CreateRequest
{
    CAMEvent evDone;
    LPUNKNOWN pUnk;
    HRESULT hr;
    CUnknown *pObject;
};

//  Object thread
DWORD WINAPI ObjectThread(LPVOID pv)
{
    //  Try to avoid creating the OLE DDE window
    if (FAILED(CAMThread::CoInitializeHelper())) {
        CoInitialize(NULL);
    }

    //  Make sure we have a message loop (will CoInitialize ensure this?)
    //  and tell our initializer we're running
    MSG msg;
    EXECUTE_ASSERT(FALSE == PeekMessage(&msg, NULL, 0, 0, PM_REMOVE));
    EXECUTE_ASSERT(SetEvent((HANDLE)pv));

    //  Our task is to create objects, pump messages and go
    //  away when there are no objects left

    for (;;) {

        GetMessage(&msg, NULL, 0, 0);

        BOOL bFailedCreate = FALSE;

#ifdef DO_RUNNINGOBJECTTABLE
        if (msg.hwnd == NULL && msg.message == WM_USER + 1) {
            //  Unregister ourselves from the ROT
            CFilterGraph *pfg = (CFilterGraph *) (msg.wParam);

            IRunningObjectTable *pirot;
            if (SUCCEEDED(GetRunningObjectTable(0, &pirot))) {
                pirot->Revoke(pfg->m_dwObjectRegistration);
                pirot->Release();
            }

            CAMEvent * pevDone = (CAMEvent *) msg.lParam;

            pevDone->Set();
        } else
#endif
        if (msg.hwnd == NULL && msg.message == WM_USER) {
            //  Create request
            struct CreateRequest *pCreate = (struct CreateRequest *)msg.wParam;
            pCreate->pObject = CFilterGraph::CreateInstance(
                                  pCreate->pUnk, &pCreate->hr);
            if (pCreate->pObject == NULL) {
                bFailedCreate = TRUE;
            }
            pCreate->evDone.Set();
        } else {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        BOOL bExit = FALSE;
        EnterCriticalSection(&g_csObjectThread);
        if (bFailedCreate) {
            g_cFGObjects--;
        }
        if (g_cFGObjects == 0) {
            g_dwObjectThreadId = 0;
            bExit = TRUE;
        }
        LeaveCriticalSection(&g_csObjectThread);
        if (bExit) {
            break;
        }
    }
    CoUninitialize();
    FreeLibraryAndExitThread(g_hInst, 0);
    return 0;
}

//
//  Create objects on the thread
//  This thread serves 2 purposes :
//  1.  Keep objects (windows) alive
//  2.  Dispatch messages
//
CUnknown *CFilterGraph::CreateThreadedInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    //  Make sure we've got a thread that won't go away
    struct CreateRequest req;

    BOOL bOK = TRUE;
    if ((HANDLE)req.evDone == NULL) {
        bOK = FALSE;
    }
    req.hr = S_OK;
    req.pObject = NULL;
    req.pUnk = pUnk;
    EnterCriticalSection(&g_csObjectThread);
    if (g_dwObjectThreadId == 0 && bOK) {
        // The painful bit is to increment our load count
        // Note the thread can't exit without going through the
        // critical section we're currently holding so order doesn't
        // matter too much here
        TCHAR sz[1000];
        bOK = 0 != GetModuleFileName(g_hInst, sz, sizeof(sz) / sizeof(sz[0]));
        if (bOK) {
            HINSTANCE hInst = LoadLibrary(sz);
            if (hInst != NULL) {
                ASSERT(hInst == g_hInst);
            } else {
                bOK = FALSE;
            }
        }
        ASSERT(g_dwObjectThreadId == 0);
        if (bOK) {
            HANDLE hThread = CreateThread(NULL,
                                          0,
                                          ObjectThread,
                                          (PVOID)(HANDLE)req.evDone,
                                          0,
                                          &g_dwObjectThreadId);
            if (hThread == NULL) {
                bOK = FALSE;
                FreeLibrary(g_hInst);
            } else {
                req.evDone.Wait();
            }
            CloseHandle(hThread);
        }
    }
    if (bOK) {
        bOK = PostThreadMessage(g_dwObjectThreadId, WM_USER,
                                (WPARAM)&req, 0);
        //  Make sure the thread doesn't go away before seeing our request
        if (bOK) {
             g_cFGObjects++;
        } else {
            DbgLog((LOG_TRACE, 0, TEXT("PostThreadMessage failed")));
        }
    }
    LeaveCriticalSection(&g_csObjectThread);
    if (bOK) {
        WaitDispatchingMessages(HANDLE(req.evDone), INFINITE);
        if (FAILED(req.hr)) {
            *phr = req.hr;
        }
    } else {
        *phr = E_OUTOFMEMORY;
    }
    return req.pObject;
}


#ifdef DO_RUNNINGOBJECTTABLE
//  Add ourselves to the Running Object Table - doesn't matter
//  if this fails
void CFilterGraph::AddToROT()
{
    if (m_dwObjectRegistration) {
        return;
    }
    //  Keep alive - we're in the constructor so this is OK
    m_cRef++;

#if 1
    //  This doesn't currently work if we want to use VB's GetObject because
    //  VB only creates file monikers
    IMoniker * pmk;
    IRunningObjectTable *pirot;
    if (FAILED(GetRunningObjectTable(0, &pirot))) {
        return;
    }
    WCHAR wsz[256];
    // !!!
    wsprintfW(wsz, L"FilterGraph %08x  pid %08x", (DWORD_PTR) this, GetCurrentProcessId());
    HRESULT hr = CreateItemMoniker(L"!", wsz, &pmk);
    if (SUCCEEDED(hr)) {
        hr = pirot->Register(0, GetOwner(), pmk, &m_dwObjectRegistration);
        pmk->Release();

        // release us to compensate for the reference the ROT will keep
        this->Release();
    }
    pirot->Release();
#else

    //  This only lets us register one object but we can at least
    //  work with VB
    HRESULT hr = RegisterActiveObject(GetOwner(),
                                      CLSID_FilterGraph,
                                      ACTIVEOBJECT_WEAK,
                                      &m_dwObjectRegistration);
#endif
    m_cRef--;
}
#endif // DO_RUNNINGOBJECTTABLE

// Video frame stepping support

HRESULT CFilterGraph::SkipFrames(DWORD dwFramesToSkip, IUnknown *pStepObject, IFrameSkipResultCallback* pFSRCB)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    if (NULL == pFSRCB) {
        return E_INVALIDARG;
    }

    if (State_Running != m_State) {
        return VFW_E_WRONG_STATE;
    }

    // A filter cannot do a frame skip operation if another
    // frame step or frame skip operation is in progress.
    if (FST_NOT_STEPPING_THROUGH_FRAMES != m_fstCurrentOperation)  {
        return E_FAIL;
    }

    return StepInternal(dwFramesToSkip, pStepObject, pFSRCB, FST_DONT_BLOCK_AFTER_SKIP);
}

STDMETHODIMP CFilterGraph::Step(DWORD dwFrames, IUnknown *pStepObject)
{
    return StepInternal(dwFrames, pStepObject, NULL, FST_BLOCK_AFTER_SKIP);
}

HRESULT CFilterGraph::StepInternal(DWORD dwFramesToSkip, IUnknown *pStepObject, IFrameSkipResultCallback* pFSRCB, FRAME_STEP_TYPE fst)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    // The pFSRCB callback in only used by the frame skipping code.
    ASSERT( ((NULL == pFSRCB) && (FST_BLOCK_AFTER_SKIP == fst)) ||
            ((NULL != pFSRCB) && (FST_DONT_BLOCK_AFTER_SKIP == fst)) );

    // The application cannot do a frame step operation while a 
    // frame skip operation is in progress.  Also, a filter
    // should not do a frame skip operation if another frame skip 
    // operation is in progress.
    if (FST_DONT_BLOCK_AFTER_SKIP == m_fstCurrentOperation)  {
        return E_FAIL;
    }

    if (NULL == pStepObject) {
        //  This returns a non-AddRef()'d pointer
        pStepObject = GetFrameSteppingFilter(dwFramesToSkip != 1 ? true : false);
    }

    if (NULL == pStepObject) {
        return VFW_E_FRAME_STEP_UNSUPPORTED;
    }

    // Cancel any previous step (no notify)
    // CancelStep(false);

    // Tell the relevant filter to step
    HRESULT hr = CallThroughFrameStepPropertySet(pStepObject,
                                                 AM_PROPERTY_FRAMESTEP_STEP,
                                                 dwFramesToSkip);

    if (SUCCEEDED(hr)) {
        m_pVideoFrameSteppingObject = pStepObject;
        m_fstCurrentOperation = fst;
        m_pFSRCB = pFSRCB;
        hr = mFG_pFGC->m_implMediaControl.StepRun();
        if (FAILED(hr)) {
            CancelStep();
            return hr;
        }
    }

    return S_OK;
}

STDMETHODIMP CFilterGraph::CanStep(long bMultiple, IUnknown *pStepObject)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    // The application cannot do a frame step operation while a 
    // frame skip operation is in progress.
    if (FST_DONT_BLOCK_AFTER_SKIP == m_fstCurrentOperation)  {
        return S_FALSE;
    }

    if (NULL == pStepObject) {
        //  This returns an non-AddRef()'d pointer
        pStepObject = GetFrameSteppingFilter(!!bMultiple);
        if (pStepObject) {
            return S_OK;
        } else {
            return S_FALSE;
        }
    }

    return  CallThroughFrameStepPropertySet(
                     pStepObject,
                     bMultiple ?
                          AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE :
                          AM_PROPERTY_FRAMESTEP_CANSTEP,
                     0);
}

//  Cancel stepping
STDMETHODIMP CFilterGraph::CancelStep()
{
    return CancelStepInternal(FSN_NOTIFY_FILTER_IF_FRAME_SKIP_CANCELED);
}

HRESULT CFilterGraph::CancelStepInternal(FRAME_SKIP_NOTIFY fsn)

{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    if (m_pVideoFrameSteppingObject) {
        HRESULT hr = CallThroughFrameStepPropertySet(
                                               m_pVideoFrameSteppingObject,
                                               AM_PROPERTY_FRAMESTEP_CANCEL,
                                               0);

        mFG_pFGC->m_implMediaEvent.ClearEvents(EC_STEP_COMPLETE);
        mFG_pFGC->m_dwStepVersion++;
        m_pVideoFrameSteppingObject = NULL;
        if ((FSN_DO_NOT_NOTIFY_FILTER_IF_FRAME_SKIP_CANCELED != fsn) &&
             FrameSkippingOperationInProgress()) {
            m_pFSRCB->FrameSkipFinished(E_ABORT);
        }
        m_fstCurrentOperation = FST_NOT_STEPPING_THROUGH_FRAMES;
        m_pFSRCB = NULL;
        return hr;
    } else {
        return S_OK;
    }
}

IUnknown *CFilterGraph::GetFrameSteppingFilter(bool bMultiple)
{
    CFilGenList::CEnumFilters NextOne(mFG_FilGenList);
    IBaseFilter *pf;
    while ((PVOID) (pf = ++NextOne)) {
        if (S_OK == CanStep(bMultiple, pf)) {
            return pf;
        }
    }
    return NULL;
}

HRESULT CFilterGraph::CallThroughFrameStepPropertySet(
    IUnknown *punk,
    DWORD dwPropertyId,
    DWORD dwData)
{
    IKsPropertySet *pProp;
    HRESULT hr = punk->QueryInterface(IID_IKsPropertySet, (void**)&pProp);
    if (SUCCEEDED(hr)) {

        hr = pProp->Set(AM_KSPROPSETID_FrameStep,
                        dwPropertyId,
                        NULL,
                        0,
                        dwPropertyId == AM_PROPERTY_FRAMESTEP_STEP ? &dwData : NULL,
                        dwPropertyId == AM_PROPERTY_FRAMESTEP_STEP ? sizeof(DWORD) : 0);

        pProp->Release();
    }
    return hr;
}

REFERENCE_TIME CFilterGraph::GetStartTimeInternal( void )
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock when it calls this function.
    ASSERT( CritCheckIn( GetCritSec() ) );

    // The m_tStart variable is only valid when the filter graph
    // is running because it's the time the filter graph switched to
    // the run state.
    ASSERT( State_Running == GetStateInternal() );

    return m_tStart;
}

HRESULT CFilterGraph::IsRenderer( IBaseFilter* pFilter )
{
    return mFG_pFGC->IsRenderer( pFilter );
}

HRESULT CFilterGraph::UpdateEC_COMPLETEState( IBaseFilter* pRenderer, FILTER_STATE fsFilter )
{
    return mFG_pFGC->UpdateEC_COMPLETEState( pRenderer, fsFilter );
}

//  IServiceProvider
STDMETHODIMP CServiceProvider::QueryService(REFGUID guidService, REFIID riid,
                          void **ppv)
{
    if (NULL == ppv) {
        return E_POINTER;
    }
    *ppv = NULL;
    CAutoLock lck(&m_cs);
    for (ProviderEntry *pEntry = m_List; pEntry; pEntry = pEntry->pNext) {
        if (pEntry->guidService == guidService) {
            return pEntry->pProvider->QueryInterface(riid, ppv);
        }
    }

    CFilterGraph *pGraph = static_cast<CFilterGraph *>(this);
    if(!pGraph->mFG_punkSite)
        return E_NOINTERFACE;

    IServiceProvider *pSPSite=NULL;     // get the site...
                                    // does it support IServiceProvider?
    HRESULT hr = pGraph->mFG_punkSite->QueryInterface(IID_IServiceProvider, (void **) &pSPSite);
    if(!FAILED(hr))
    {
        hr = pSPSite->QueryService(guidService, riid, ppv);
        pSPSite->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\grphstrm.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <atlbase.h>
#include "Util.h"
#include "fgenum.h"
#include "filgraph.h"

extern HRESULT GetFilterMiscFlags(IUnknown *pFilter, DWORD *pdwFlags);

//=====================================================================
//
// CFilterGraph::FindUpstreamInterface
//
// Search a filter chain for an interface
// Find the first upstream output pin or filter which supports this interface
//
// Later:: 
// If we wanted to extend this into a generic function then we should allow
// defining a search criteria, of the superset of:
//              AM_INTF_SEARCH_INPUT_PIN | 
//              AM_INTF_SEARCH_OUTPUT_PIN | 
//              AM_INTF_SEARCH_FILTER
//
//=====================================================================
STDMETHODIMP CFilterGraph::FindUpstreamInterface
(
    IPin   *pPin, 
    REFIID riid,
    void   **ppvInterface, 
    DWORD  dwFlags
)
{
    
    ASSERT( ppvInterface );
    if( !ppvInterface )
        return E_POINTER;
        
    if( 0 == dwFlags )
    { 
        // 0 means search everything   
        dwFlags = AM_INTF_SEARCH_INPUT_PIN | AM_INTF_SEARCH_OUTPUT_PIN | 
                  AM_INTF_SEARCH_FILTER;
    }                  
        
    HRESULT hr = S_OK;
    BOOL bFound = FALSE;
    if ( PINDIR_INPUT == Direction( pPin ) ) 
    {
        if( AM_INTF_SEARCH_INPUT_PIN & dwFlags )
        {
            hr = pPin->QueryInterface( riid, (void **) ppvInterface );
            if( SUCCEEDED( hr ) ) 
            {
                bFound = TRUE;
                DbgLog( ( LOG_TRACE, 8, "interface found on input pin %x", pPin ) );
            }
        }
        if( !bFound )
        {        
            IPin * pConnectedPin;
            hr = pPin->ConnectedTo( &pConnectedPin );
            if ( S_OK == hr )
            {
                hr = FindUpstreamInterface( pConnectedPin, riid, ppvInterface, dwFlags );
                pConnectedPin->Release( );
                if( SUCCEEDED( hr ) )
                {
                    bFound = TRUE;
                }
            }
        }            
    }
    else
    {                
        if( AM_INTF_SEARCH_OUTPUT_PIN & dwFlags )
        {        
    	    // check for pin interface first, then filter
            hr = pPin->QueryInterface( riid, (void **) ppvInterface );
            if( SUCCEEDED( hr ) )
            {
                bFound = TRUE;
                DbgLog( ( LOG_TRACE, 8, "interface found on output pin %x", pPin ) );
            }                    
        }
                    
        if( !bFound )
        { 
            if( AM_INTF_SEARCH_FILTER & dwFlags )
            {            
                PIN_INFO pinfo;
                hr = pPin->QueryPinInfo( &pinfo );
                ASSERT( SUCCEEDED( hr ) );
                if ( SUCCEEDED( hr ) )
                {
                    hr = pinfo.pFilter->QueryInterface( riid, (void **) ppvInterface );
                    pinfo.pFilter->Release( );
                    if( SUCCEEDED( hr ) ) 
                    {
                        bFound = TRUE;
                        DbgLog( ( LOG_TRACE, 8, "interface found on filter %x", pinfo.pFilter ) );
                    }
                }
            }                
            if( !bFound )
            {                            
                //  move upstream and on to any internally connected pins
                CEnumConnectedPins EnumPins(pPin, &hr);
                if (SUCCEEDED(hr)) {
                    IPin *pPin;
                    for (; ; ) {
                        pPin = EnumPins();
                        if (NULL == pPin) {
                            break;
                        }
                        hr = FindUpstreamInterface( pPin, riid, ppvInterface, dwFlags );
                        pPin->Release();
                        if (SUCCEEDED(hr)) {
                            bFound = TRUE;
                            break;
                        }
                    }
                }                    
            }
        }            
    }    
    if (!( SUCCEEDED( hr ) && bFound ) ) 
    {
        DbgLog( ( LOG_TRACE, 8, "FindUpstreamInterface - interface not found" ) );
        hr = E_NOINTERFACE;
    }
    return hr;
}

//=====================================================================
//
// CFilterGraph::SetMaxGraphLatency
//
// Allows an app to change the maximum latency allowed for this graph.
//
//=====================================================================

STDMETHODIMP CFilterGraph::SetMaxGraphLatency( REFERENCE_TIME rtMaxGraphLatency )
{
    if( !mFG_bSyncUsingStreamOffset )
        return E_FAIL;
        
    HRESULT hr = S_OK;
    if( rtMaxGraphLatency != mFG_rtMaxGraphLatency )
    {
        // just assert that this value isn't bogus (say, under 2 seconds?)
        ASSERT( rtMaxGraphLatency < 2000 * ( UNITS / MILLISECONDS ) );
        
        mFG_rtMaxGraphLatency = rtMaxGraphLatency;
        
        // now reset on all push source pins in the graph
        hr = SetMaxGraphLatencyOnPushSources();
    }        
    return hr;
}

//=====================================================================
//
// CFilterGraph::SyncUsingStreamOffset
//
// Turns on/off graph latency settings
//
//=====================================================================

STDMETHODIMP CFilterGraph::SyncUsingStreamOffset( BOOL bUseStreamOffset )
{
    BOOL bLastState = mFG_bSyncUsingStreamOffset;
    mFG_bSyncUsingStreamOffset = bUseStreamOffset;
    
    if( bUseStreamOffset && 
        bUseStreamOffset != bLastState )
    {
        SetMaxGraphLatencyOnPushSources();
    }        
    return S_OK; 
}


//=====================================================================
//
// CFilterGraph::SetMaxGraphLatencyOnPushSources
//
// Tell all push sources the max graph latency
//
//=====================================================================

HRESULT CFilterGraph::SetMaxGraphLatencyOnPushSources( )
{
    if( !mFG_bSyncUsingStreamOffset ) // should be redundant
        return E_FAIL;
        
    HRESULT hr = S_OK;
        
    CAutoMsgMutex cObjectLock(&m_CritSec); // make sure this is needed!!
    
    // reset on all push source pins in the graph
    PushSourceList lstPushSource( TEXT( "IAMPushSource filter list" ) );
    hr = BuildPushSourceList( lstPushSource, FALSE, FALSE );
    if( SUCCEEDED( hr ) )
    {
        for ( POSITION Pos = lstPushSource.GetHeadPosition(); Pos; )
        {
            PushSourceElem *pElem = lstPushSource.GetNext(Pos);
    
            if( pElem->pips )  // first verify it's an IAMPushSource pin
                pElem->pips->SetMaxStreamOffset( mFG_rtMaxGraphLatency );
        } 
        DeletePushSourceList( lstPushSource );
    }
    return hr;
}


//=====================================================================
//
// CFilterGraph::BuildPushSourceList
//
// Build a list of all output pins that support IAMPushSource
//
//=====================================================================

HRESULT CFilterGraph::BuildPushSourceList(PushSourceList & lstPushSource, BOOL bConnected, BOOL bGetClock )
{
    //    
    // (doing this the easy way, for now)
    //
    // build a list of the output pins that support IAMPushSource
    //    
    // really, we need to build a list of all the streams which are sourced by an 
    // IAMPushSource pin, store the sum latency for the chain, as well as
    // maybe a ptr to the renderer (input pin) for the chain (if one exists)
    //
    // note that we're really only interested in pins the are actually connected 
    // to a renderer of some kind, so for now we at least make sure that an 
    // output pin is connected before considering it at a push source
    //
    CFilGenList::CEnumFilters Next(mFG_FilGenList);
    IBaseFilter *pf;
    HRESULT hr, hrReturn = S_OK;
    IAMPushSource * pips;
    
    while ((PVOID) (pf = ++Next)) 
    {
        // First check that filter supports IAMFilterMiscFlags and is an 
        // AM_FILTER_MISC_FLAGS_IS_SOURCE filter
        ULONG ulFlags;
        GetFilterMiscFlags(pf, &ulFlags);
        BOOL bAddPinToSourceList = FALSE;
        BOOL bCheckPins = FALSE;
        IKsPropertySet * pKsFilter;
        
        if( AM_FILTER_MISC_FLAGS_IS_SOURCE & ulFlags )
        {
            bCheckPins = TRUE;
        }
        else
        {
            //
            // Else see if it's ksproxy filter and if so always check output pins for
            // capture or push source support. This is because some ksproxy capture devices 
            // (i.e. stream class) don't correctly expose themselves as a source filter
            //
            hr = pf->QueryInterface( IID_IKsPropertySet, (void**)(&pKsFilter) );
            if( SUCCEEDED( hr ) )
            {
                pKsFilter->Release();
                bCheckPins = TRUE;
            }            
        }
        if( bCheckPins )        
        {                    
            // Enumerate the output pins for IAMPushSource support
            CEnumPin NextPin(pf, CEnumPin::PINDIR_OUTPUT);
            IPin *pPin;
            while ((PVOID) (pPin = NextPin()))
            {
                // check whether the caller's only interested in connected output pins
                if( bConnected )
                {
                    // first verify that it's connected, otherwise we're not interested
                    IPin * pConnected;
                    hr = pPin->ConnectedTo( &pConnected );
                    if( SUCCEEDED( hr ) )
                    {                
                        pConnected->Release();
                    }
                    else
                    {
                        pPin->Release();
                        continue;
                    }
                }                                                                    
                hr = pPin->QueryInterface( IID_IAMPushSource, (void**)(&pips) );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Got IAMPushSource from pin of filter %x %ls")
                      , pf, (mFG_FilGenList.GetByFilter(pf))->pName));

                    bAddPinToSourceList = TRUE;
                }
                else
                {
                    //else see if it's ksproxy 'capture' pin
                    IKsPropertySet * pKs;
                    hr = pPin->QueryInterface( IID_IKsPropertySet, (void**)(&pKs) );
                    if( SUCCEEDED( hr ) )
                    {
                        GUID guidCategory;
                        DWORD dw;
                        hr = pKs->Get( AMPROPSETID_Pin
                                     , AMPROPERTY_PIN_CATEGORY
                                     , NULL
                                     , 0
                                     , &guidCategory
                                     , sizeof(GUID)
                                     , &dw );
                        if( SUCCEEDED( hr ) )                         
                        {
                            if( guidCategory == PIN_CATEGORY_CAPTURE )
                            {
                                DbgLog((LOG_TRACE, 5, TEXT("Found capture pin that doesn't support IAMPushSource from pin of filter %x %ls")
                                  , pf, (mFG_FilGenList.GetByFilter(pf))->pName));
                                bAddPinToSourceList = TRUE;
                            } 
                        }                    
                    	pKs->Release();
                    }
                }
                                        
                if( bAddPinToSourceList )
                {    
                    PushSourceElem *pElem = new PushSourceElem;
                    if( NULL == pElem ) 
                    {                        
                        hrReturn = E_OUTOFMEMORY;
                        if( pips )
                            pips->Release();
                            
                        pPin->Release();                                
                        break;
                    }
                    pElem->pips = pips; // remember, can be NULL if the pin isn't a true IAMPushSource pin!
                    
                    // initialize pClock                        
                    pElem->pClock = NULL;
                    
                    // init flags
                    pElem->ulFlags = 0;
                                            
                    if( pips )                        
                        ASSERT( SUCCEEDED( pips->GetPushSourceFlags( &pElem->ulFlags ) ) );
                                            
                    if( bGetClock )
                    {                    
                        PIN_INFO PinInfo;  
                        hr = pPin->QueryPinInfo( &PinInfo );
                        if( SUCCEEDED( hr ) )
                        {
                            hr = PinInfo.pFilter->QueryInterface( IID_IReferenceClock
                                                                , (void **)&pElem->pClock );
                            PinInfo.pFilter->Release();
                        }
                    }
                
                    // add this interface pointer to our list                   
                    if (NULL==lstPushSource.AddTail(pElem)) 
                    {
                        hrReturn = E_OUTOFMEMORY;
                        if( pips )
                            pips->Release();
                        if( pElem->pClock )
                            pElem->pClock->Release();
                            
                        break;
                    }
                }                        
                pPin->Release();
            }
        }
    } // while loop
    return hrReturn;
}

//=====================================================================
//
// CFilterGraph::GetMaxStreamLatency
//
// Search over all graph streams for pins which support IAMPushSource
// and IAMLatency and attempt to determine a maximum stream latency
//
//=====================================================================

REFERENCE_TIME CFilterGraph::GetMaxStreamLatency(PushSourceList & lstPushSource)
{
    // now go through the list we built and set the offset times based on the max 
    // value we just found
    REFERENCE_TIME rtLatency, rtMaxLatency = 0;
    HRESULT hr = S_OK;
    for ( POSITION Pos = lstPushSource.GetHeadPosition(); Pos; )
    {
        PushSourceElem *pElem = lstPushSource.GetNext(Pos);
        // first verify it's a true push source        
        if( pElem->pips )
        {
            REFERENCE_TIME rtLatency = 0;
            hr = pElem->pips->GetLatency( &rtLatency );
            if( SUCCEEDED( hr ) )
            {        
                if( rtLatency > rtMaxLatency )
                {
                    rtMaxLatency = rtLatency;
                }                        
                else
                {
                    // else check that the filter can handle this amount of offset
                    // it may not be able to tell for sure, so even if it thinks it
                    // can't we'll still try to use it for now.
                    REFERENCE_TIME rtMaxOffset;
                    hr = pElem->pips->GetMaxStreamOffset( &rtMaxOffset );
                    if( S_OK == hr )
                    {
                        ASSERT( rtMaxLatency <= rtMaxOffset );
                    }
                } 
            }
        }            
    }
    // don't return anything larger than our established limit
    return min( rtMaxLatency, mFG_rtMaxGraphLatency) ;
}    
    
//=====================================================================
//
// CFilterGraph::DeletePushSourceList
//
// Delete the push source list we built in BuildPushSourceList
//
//=====================================================================

void CFilterGraph::DeletePushSourceList(PushSourceList & lstPushSource)
{
    PushSourceElem * pElem;
    while ( ( PVOID )( pElem = lstPushSource.RemoveHead( ) ) )
    {
        if( pElem->pClock )
        {
            pElem->pClock->Release();
        }
        if( pElem->pips )
            pElem->pips->Release();
    
        delete pElem;
    } // while loop
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\filgtest.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

// These are functions which have to be part of CFilterGraph because

// they (well, some of them) use a private type of CFilterGraph as
// parameters.  I wanted them to be part of a friend class, but it
// wouldn't compile for those that use private types as parameters.
// So some of them have to be in the main class - but I still
// introduce a friend for the public ones - because these can't have
// private parameter types and otherwise they'd have to be in the idl too.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

// #include <windows.h>    already included in streams.h
#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)

#ifdef DEBUG

#include "distrib.h"
#include "rlist.h"
#include "filgraph.h"


CTestFilterGraph::CTestFilterGraph( TCHAR *pName, CFilterGraph * pCFG, HRESULT *phr )
: CUnknown(pName, pCFG->GetOwner())
{
     m_pCFG = pCFG;
} // constructor


//========================================================================
// Check that Random is behaving OK.  Only checks for errors
// This is NOT a full scale randomness test!
//========================================================================
STDMETHODIMP CTestFilterGraph::TestRandom(  )
{
    DbgLog((LOG_TRACE, 2, TEXT("Test Me:%d"), m_pCFG->mFG_iSortVersion));


    int i;
    for (i=0; i<100; ++i) {
        if (Random(0)!=0) {
            DbgLog((LOG_ERROR, 1, TEXT("Random(0) !=0" )));
            return E_FAIL;
        }
    }

    int Count;
    Count = 0;
    for (i=0; i<100; ++i) {
        if (Random(1)==0) {
            ++Count;
        }
    }

    if (Count<20) {
        DbgLog((LOG_ERROR, 1, TEXT("Random(1) not 1 often enough")));
        return E_FAIL;
    }
    if (Count>80) {
        DbgLog((LOG_ERROR, 1, TEXT("Random(1) == 1 too often" )));
        return E_FAIL;
    }

    Count = 0;
    for (i=0; i<100; ++i) {
        Count +=Random(100);
    }

    if (Count < 40*100 || Count > 60*100) {
        DbgLog((LOG_ERROR, 1, TEXT("Random(100) implausible total" )));
        return E_FAIL;
    }

    return NOERROR;

} // TestRandom


//=====================================================================
//
// CTestFilterGraph::NonDelegatingQueryInterface
//
//=====================================================================

STDMETHODIMP CTestFilterGraph::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_ITestFilterGraph) {
        return GetInterface((ITestFilterGraph *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
} // CTestFilterGraph::NonDelegatingQueryInterface






// set *pfg to each FilGen in cfgl in turn
// use Pos as a name of a temp
#define TRAVERSEFGLIST(cfgl, Pos, pfg) {                                       \
        POSITION Pos = cfgl.GetHeadPosition();                                 \
        while(Pos!=NULL) {                                                     \
            /* Retrieve the current IBaseFilter, side-effect Pos on to the next */ \
            CFilterGraph::FilGen * pfg = cfgl.GetNext(Pos);                                  \
            {


#define ENDTRAVERSELIST    \
            }              \
        }                  \
    }


//=================================================================
// return a random integer in the range 0..Range
// Range must be in the range 0..2**31-1
//
// The only reason for making this a member of CTestFilterGraph is to
// reduce the chance of name conflict as Random is rather common
//=================================================================
int CTestFilterGraph::Random(int Range)
{
    // These really must be DWORDs - the magic only works for 32 bit
    const DWORD Seed = 1664525;              // seed for random (Knuth)
    static DWORD Base = Seed * (GetTickCount() | 1);  // Really random!
                // ORing 1 ensures that we cannot arrive at sero and stick there

    Base = Base*Seed;

    // Base is a good 32 bit random integer - but we want it scaled down to
    // 0..Range.  We will actually scale the last 31 bits of it.
    // which sidesteps problems of negative numbers.
    // MulDiv rounds - it doesn't truncate.
    int Result = MulDiv( (Base&0x7FFFFFFF), (Range), 0x7FFFFFFF);

    return Result;
} // Random



//=================================================================
// Check that the ranks are in non-descending order
//
// Note that a friend class cannot access a private typedef as a parameter,
// so in order to access CFilGenList this has to be a member of CFilterGraph
// Eugh!
//=================================================================
BOOL CFilterGraph::CheckList( CFilterGraph::CFilGenList &cfgl )
{
    int LastRankSeen = 0;
    // set *pfg to each FilGen in mFG_FilGenList in turn,
    // use Pos as the name of a temp.
    TRAVERSEFGLIST(cfgl, Pos, pfg)
        if (pfg->Rank < LastRankSeen) return FALSE;
        if (pfg->Rank > LastRankSeen) LastRankSeen = pfg->Rank;
    ENDTRAVERSELIST

    return TRUE;
} // CheckList


//=================================================================
// Set the ranks to something random
// Each Rank is randomly chosen from 0..cfgl.GetCount()
//=================================================================
void CFilterGraph::RandomRank( CFilterGraph::CFilGenList &cfgl )
{

    int Count = cfgl.GetCount();
    // set *pfg to each FilGen in mFG_FilGenList in turn,
    // use Pos as the name of a temp.
    TRAVERSEFGLIST(cfgl, Pos, pfg)
        pfg->Rank = mFG_Test->Random(Count);
    ENDTRAVERSELIST

} // RandomRank



//=================================================================
// Put the list into a random order
// Each Rank is randomly chosen from 0..cfgl.GetCount()
//=================================================================
void CFilterGraph::RandomList( CFilterGraph::CFilGenList &cfgl )
{

    CFilGenList cfglNew(NAME("Random ordered filter list"), this);

    // Make a series of traverses through the list picking a random member out
    // and adding it to the tail of the new list.

    while( cfgl.GetCount() >0 ) {
        int R = mFG_Test->Random(cfgl.GetCount() -1);
        int i;

        i = 0;
        /* Traverse the list up to the Rth member (counting from 0) */
        POSITION Pos = cfgl.GetHeadPosition();
        while(Pos!=NULL) {
            POSITION OldPos = Pos;
            cfgl.GetNext(Pos);

            ++i;
            if (i>R) {
               cfglNew.AddTail( cfgl.Remove(OldPos) );
               break;
            }
        }
    }

    // Now cfglNew is full and cfgl is empty - add it back to cfgl
    cfgl.AddTail(&cfglNew);


} // RandomList



//================================================================
// Test the SortList function.  return TRUE iff it works
//================================================================
STDMETHODIMP CTestFilterGraph::TestSortList( void )
{
    CFilterGraph * foo = NULL;
    CFilterGraph::CFilGenList cfgl(NAME("Test sort list"), foo);
    CFilterGraph::FilGen * pfg;

    // Sort a list of length zero
    m_pCFG->SortList(cfgl);
    if (cfgl.GetCount() != 0) return E_FAIL;  // about all you can do with an empty list

    // Create a list of length 1 and sort it
    m_pCFG->SortList(cfgl);

    pfg = new CFilterGraph::FilGen(NULL, false);
    pfg->Rank = 0;
    cfgl.AddTail(pfg);
    m_pCFG->SortList(cfgl);
    if (cfgl.GetCount() != 1) return E_FAIL;  // about all you can do with a unit list

    // Create a list of length 2 in order, sort it and check it
    pfg = new CFilterGraph::FilGen(NULL, false);
    cfgl.AddTail(pfg);
    pfg->Rank = 1;
    m_pCFG->SortList(cfgl);
    if (!m_pCFG->CheckList(cfgl)) return E_FAIL;

    // Reverse the order, sort it and check it
    int Rank = 2;
    TRAVERSEFGLIST(cfgl, Pos, pfg)
       pfg->Rank = Rank;
       -- Rank;
    ENDTRAVERSELIST
    m_pCFG->SortList(cfgl);
    if (!m_pCFG->CheckList(cfgl)) return E_FAIL;


    // Create a list of length 5, randomise it and sort it several times

    int i;
    for (i=0; i<3; ++i) {
       pfg = new CFilterGraph::FilGen(NULL, false);
       cfgl.AddTail(pfg);
    }

    for (i=0; i<10; ++i) {
       m_pCFG->RandomRank(cfgl);          // assign random ranks
       m_pCFG->SortList(cfgl);
       m_pCFG->RandomList(cfgl);          // now shuffle them and try again (exercises RandomList)
       m_pCFG->SortList(cfgl);

       if (!m_pCFG->CheckList(cfgl)) return E_FAIL;
    }

    // Clean up
    TRAVERSEFGLIST(cfgl, Pos, pfg)
       delete pfg;
    ENDTRAVERSELIST

    return NOERROR;

} // TestSortList



//==================================================================
// Sort the nodes into upstream order and check that the sorting is good
// Need to call this with several differently connected filter graphs
// to get any sort of valid test.
//==================================================================
STDMETHODIMP CTestFilterGraph::TestUpstreamOrder()
{
    int i;
    for (i=0; i<=10; ++i) {
        m_pCFG->IncVersion();
        m_pCFG->RandomList(m_pCFG->mFG_FilGenList);

        m_pCFG->UpstreamOrder();

        if (!m_pCFG->CheckList(m_pCFG->mFG_FilGenList)) return E_FAIL;
    }

    return NOERROR;
} // TestUpstreamOrder


#if 0
    //==================================================================
    // Pick on the first filter in the graph and TotallyRemove it
    // ??? How does this TEST it - just exercises it!
    //==================================================================
    STDMETHODIMP CTestFilterGraph::TestTotallyRemove(void)
    {

        POSITION Pos = m_pCFG->mFG_FilGenList.GetHeadPosition();
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        CFilterGraph::FilGen * pfg = m_pCFG->mFG_FilGenList.GetNext(Pos);
        HRESULT hr;
        hr = m_pCFG->TotallyRemove(pfg->pFilter);
        return hr;

    } // TestTotallyRemove
#endif //0

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\mapper.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __DefFilMapper
#define __DefFilMapper

#include "cachemap.h"
#include "fil_data.h"

// There are three classes

// CFilterMapper - you can have lots of these, but it has a static mM_pReg
// which points to the one and only MapperCache.
// CFilterMapper needs a critical section to lock access to mMpReg so that it
// never thinks it's null when it isn't really, and it needs a static
// ref count to know when to free the cache, and that means (sigh) a
// static CRITICAL_SECTION to guard that.

// CMapperCache - as mentioned.  there will only be one of these
// (OK - one per process.  One in the system would be nicer).
// It needs its own locks because...

// CEnumRegFilters - an enumerator.  These contain some data (the position)
// so they are made thread safe too.  There can be lots of these and
// they all hammer away at the same cache - that's why the cache needed a lock.


// The cache may have been rebuilt in between calls to
// RegEnumFilterInfo, so the caller needs to pass in a version # each
// time.
struct Cursor
{
    POSITION pos;
    ULONG ver;

    //  For output types only compare on wild cards for the
    //  second and subsequent types if this is set
    bool bDoWildCardsOnInput;
};


//================================================================
// CMapperCache              Registry caching
//================================================================
class CMapperCache : public CCritSec
{
private:
    // Any registration or unregistration means that
    // the cache needs to be refreshed.  We do a lazy
    // refresh.  This means that if there are several
    // changes we won't re-read it all until needed.

    BOOL m_bRefresh;            // The cache is out of date
    ULONG m_ulCacheVer;         // cache version #

    // building the cache goes through devenum which can register new
    // filters. we don't want those to break the cache.
    BOOL m_fBuildingCache;      // in Cache();

    DWORD m_dwMerit;            // merit of filters cached


    // there's a list of filters
    // every filter has a list of pins
    // every pin has a list of types
    //
    // m_lstFilter-->clsid
    //               Name
    //               dwMerit
    //               lstPin--->Output
    //                 .       bZero
    //                 .       bMany
    //                 .       clsConnectsToFilter
    //               next      strConnectsToPin
    //               filter    lstType------------>clsMajor
    //                 .         .                 clsSub
    //                 .         .                   .
    //                etc        .                   .
    //                         next                  .
    //                         pin                 next
    //                           .                 type
    //                           .                   .
    //                          etc                  .
    //                                              etc
    //

    class CMapFilter
    {
    public:
        CMapFilter() {
            pDeviceMoniker = 0;
            m_prf2 = 0;
#ifdef USE_CLSIDS
            m_clsid = GUID_NULL;
#endif
            m_pstr = NULL;
        }
        ~CMapFilter() {
            if(pDeviceMoniker) pDeviceMoniker->Release();
            CoTaskMemFree((BYTE *)m_prf2);
            CoTaskMemFree(m_pstr);
        }

        HRESULT GetFilter(IBaseFilter **ppFilter);

        IMoniker *pDeviceMoniker;
        REGFILTER2 *m_prf2;
#ifdef USE_CLSIDS
        CLSID m_clsid;
#endif
        LPOLESTR m_pstr;
    };

    //  Helper
    static HRESULT GetMapFilterClsid(CMapFilter *pFilter, CLSID *pclsid);

    typedef CGenericList<CMapFilter> CFilterList;
    CFilterList * m_plstFilter;
    typedef CGenericList<CFilterList> CFilterListList;



    bool  m_b16Color;

public:
    CMapperCache();
    ~CMapperCache();

    ICreateDevEnum *m_pCreateDevEnum;

    // Cache all the filters in the registry ready to enumerate.
    HRESULT Cache();

    // Mark the cache as out of date if we're not in Cache(); see
    // m_fBuildingCache
    HRESULT BreakCacheIfNotBuildingCache();

    // Enumerate!
    HRESULT RegEnumFilterInfo(
        Cursor & cur,
        bool bExactMatch,
        DWORD dwMerit ,
        BOOL bInputNeeded,
        const GUID *pInputTypes,
        DWORD cInputTypes,
        const REGPINMEDIUM *pMedIn ,
        const CLSID *pPinCatIn,
        BOOL bMustRender,
        BOOL bOutputNeeded,
        const GUID *pOutputTypes,
        DWORD cOutputTypes,
        const REGPINMEDIUM *pMedOut ,
        const CLSID *pPinCatOut,
        IMoniker **ppMonOut ,
        CLSID * clsFilter,
        const LPWSTR Name
        );

    //  Cache the cache stuff

    HRESULT SaveCacheToRegistry(DWORD dwMerit, DWORD dwPnPVersion);
    HRESULT RestoreFromCache(DWORD dwPnPVersion);
    HRESULT RestoreFromCacheInternal(FILTER_CACHE *pCache);
    HRESULT SaveData(PBYTE pbData, DWORD dwSize);
    FILTER_CACHE * LoadCache(DWORD dwMerit, DWORD dwPnPVersion);

private:
    // Refresh the cache from the registry.
    HRESULT Refresh();

    //
    HRESULT ProcessOneCategory(REFCLSID clsid, ICreateDevEnum *pCreateDevEnum);

    LONG CacheFilter(IMoniker *pDeviceMoniker, CMapFilter * pFil);

    static void Del(CFilterList * plstFil);
    BOOL FindType(
        const REGFILTERPINS2 * pPin,
        const GUID *pTypes,
        DWORD cTypes,
        const REGPINMEDIUM *pMed,
        const CLSID *pPinCatNeeded,
        bool fExact,
        BOOL bPayAttentionToWildCards,
        BOOL bDoWildCards);

    BOOL CheckInput(
        const REGFILTERPINS2 * pPin,
        const GUID *pTypes,
        DWORD cTypes,
        const REGPINMEDIUM *pMed,
        const CLSID *pPinCatNeeded,
        bool fExact,
        BOOL bMustRender,
        BOOL bDoWildCards);

    void Sort( CFilterList * &pfl);
    void Merge( CFilterListList & fll, CFilterList * pfl);
    void MergeTwo( CFilterList * pflA, CFilterList * pflB);
    HRESULT Split(CFilterList * pfl, CFilterListList & fll);
    int Compare(CMapFilter * pfA, CMapFilter * pfB);
    void CountPins(CMapFilter * pf, int &cIn, int &cOut);
    void DbgDumpCache(CFilterList * pfl);

}; // class CMapperCache

// class that lets you register filters with categories.
class CFilterMapper2 :
    public IFilterMapper3,
    public IFilterMapper,
    public IAMFilterData,
    public CUnknown,
    public CCritSec
{
    DECLARE_IUNKNOWN;

    // IFilterMapper2 methods
    STDMETHOD(CreateCategory)(
        /* [in] */ REFCLSID clsidCategory,
        /* [in] */ DWORD dwCategoryMerit,
        /* [in] */ LPCWSTR Description);

    STDMETHOD(UnregisterFilter)(
        /* [in] */ const CLSID *pclsidCategory,
        /* [in] */ const OLECHAR *szInstance,
        /* [in] */ REFCLSID Filter);

    STDMETHOD(RegisterFilter)(
        /* [in] */ REFCLSID clsidFilter,
        /* [in] */ LPCWSTR Name,
        /* [out][in] */ IMoniker **ppMoniker,
        /* [in] */ const CLSID *pclsidCategory,
        /* [in] */ const OLECHAR *szInstance,
        /* [in] */ const REGFILTER2 *prf2);

    STDMETHODIMP EnumMatchingFilters(
        /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppEnum,
        /* [in] */ DWORD dwFlags,
        /* [in] */ BOOL bExactMatch,
        /* [in] */ DWORD dwMerit,
        /* [in] */ BOOL bInputNeeded,
        /* [in] */ DWORD cInputTypes,
        /* [size_is] */ const GUID __RPC_FAR *pInputTypes,
        /* [in] */ const REGPINMEDIUM __RPC_FAR *pMedIn,
        /* [in] */ const CLSID __RPC_FAR *pPinCategoryIn,
        /* [in] */ BOOL bRender,
        /* [in] */ BOOL bOutputNeeded,
        /* [in] */ DWORD cOutputTypes,
        /* [size_is] */ const GUID __RPC_FAR *pOutputTypes,
        /* [in] */ const REGPINMEDIUM __RPC_FAR *pMedOut,
        /* [in] */ const CLSID __RPC_FAR *pPinCategoryOut);

    //
    // IFilterMapper methods
    //
    STDMETHODIMP RegisterFilter
    ( CLSID   clsid,    // GUID of the filter
      LPCWSTR Name,     // Descriptive name for the filter
      DWORD   dwMerit     // DO_NOT_USE, UNLIKELY, NORMAL or PREFERRED.
      );

    STDMETHODIMP RegisterFilterInstance
    ( CLSID   clsid,// GUID of the filter
      LPCWSTR Name, // Descriptive name of instance.
      CLSID  *MRId  // Returned Media Resource Id which identifies the instance,
      // a locally unique id for this instance of this filter
      );

    STDMETHODIMP  RegisterPin
    ( CLSID   clsFilter,        // GUID of filter
      LPCWSTR strName,          // Descriptive name of the pin
      BOOL    bRendered,        // The filter renders this input
      BOOL    bOutput,          // TRUE iff this is an Output pin
      BOOL    bZero,            // TRUE iff OK for zero instances of pin
      // In this case you will have to Create
      // a pin to have even one instance
      BOOL    bMany,            // TRUE iff OK for many instances of pin
      CLSID   clsConnectsToFilter, // Filter it connects to if it has a
      // subterranean connection, else NULL
      LPCWSTR strConnectsToPin  // Pin it connects to
      // else NULL
      );

    STDMETHODIMP RegisterPinType
    ( CLSID   clsFilter,        // GUID of filter
      LPCWSTR strName,          // Descriptive name of the pin
      CLSID   clsMajorType,     // Major type of the data stream
      CLSID   clsSubType        // Sub type of the data stream
      );

    STDMETHODIMP UnregisterFilter
    ( CLSID  Filter     // GUID of filter
      );


    STDMETHODIMP UnregisterFilterInstance
    ( CLSID  MRId       // Media Resource Id of this instance
      );

    STDMETHODIMP UnregisterPin
    ( CLSID   Filter,    // GUID of filter
      LPCWSTR strName    // Descriptive name of the pin
      );

    STDMETHODIMP EnumMatchingFilters
    ( IEnumRegFilters **ppEnum  // enumerator returned
      , DWORD dwMerit             // at least this merit needed
      , BOOL  bInputNeeded        // Need at least one input pin
      , CLSID clsInMaj            // input major type
      , CLSID clsInSub            // input sub type
      , BOOL bRender              // must the input be rendered?
      , BOOL bOutputNeeded        // Need at least one output pin
      , CLSID clsOutMaj           // output major type
      , CLSID clsOutSub           // output sub type
      );

    // new IFilterMapper3 method
    STDMETHODIMP GetICreateDevEnum( ICreateDevEnum **ppEnum );

    // IAMFilterData methods

    STDMETHODIMP ParseFilterData(
        /* [in, size_is(cb)] */ BYTE *rgbFilterData,
        /* [in] */ ULONG cb,
        /* [out] */ BYTE **prgbRegFilter2);

    STDMETHODIMP CreateFilterData(
        /* [in] */ REGFILTER2 *prf2,
        /* [out] */ BYTE **prgbFilterData,
        /* [out] */ ULONG *pcb);


public:

    CFilterMapper2(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);
    ~CFilterMapper2();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    // initialize cs
    static void MapperInit(BOOL bLoading,const CLSID *rclsid);

    //  Break the cache


private:

    // make cache if none exists
    HRESULT CreateEnumeratorCacheHelper();

    // Break the cache
    void BreakCacheIfNotBuildingCache();

    //  Invalidate registry cache
    static HRESULT InvalidateCache();


    ULONG m_ib;
    BYTE *m_rgbBuffer;
    ULONG m_cbLeft;

    static CMapperCache * mM_pReg;
    // we need to separately count references to this thing so that
    // we know when the last mapper has gone.
    static long           mM_cCacheRefCount;
    static CRITICAL_SECTION mM_CritSec;
};

//==========================================================================
//==========================================================================
// CEnumRegFilters class.
// This enumerates filters in the registry.
//==========================================================================
//==========================================================================

class CEnumRegFilters : public IEnumRegFilters,  // The interface we support
                        public CUnknown,         // A non delegating IUnknown
                        public CCritSec          // Provides object locking
{

    // This thing has lots of data, so needs locking to make it thread safe,
    // but in addition, there can be many of these accessing a single copy
    // of the MapperCache so that needs separate locking.

    private:

        DWORD mERF_dwMerit;      // at least this merit needed

        //  Keep the next 4 items consecutive otherwise the call to
        //  RegEnumFilterInfo won't work
        CLSID mERF_clsInMaj;     // major type reqd for input pin
        CLSID mERF_clsInSub;     // sub type reqd for input pin
        CLSID mERF_clsOutMaj;    // major type reqd for output pin
        CLSID mERF_clsOutSub;    // sub type reqd for output pin

        BOOL  mERF_bRender;      // does the input pin have to be rendered
        BOOL  mERF_bInputNeeded; // must have at least one input pin
        BOOL  mERF_bOutputNeeded;// must have at least one output pin
        BOOL  mERF_Finished ;    // Pos==NULL could mean finished or not started
        Cursor mERF_Cur;         // cursor (together with Finished)
        CMapperCache * mERF_pReg; // Registry cache

    public:

        // Normal constructor that creates an enumerator set at the start
        CEnumRegFilters( DWORD dwMerit
                       , BOOL  bInputNeeded
                       , REFCLSID clsInMaj
                       , REFCLSID clsInSub
                       , BOOL bRender
                       , BOOL bOutputNeeded
                       , REFCLSID clsOutMaj
                       , REFCLSID clsOutSub
                       , CMapperCache * pReg
                       );


        ~CEnumRegFilters();

        DECLARE_IUNKNOWN

        STDMETHODIMP Next
            ( ULONG cFilters,           // place this many filters...
              IMoniker **rgpMoniker,
              ULONG * pcFetched         // actual count passed returned here
            );

    STDMETHODIMP Next
            ( ULONG cFilters,           // place this many filters...
              REGFILTER ** apRegFilter, // ...in this array of REGFILTER*
              ULONG * pcFetched         // actual count passed returned here
            );

        STDMETHODIMP Skip(ULONG cFilters)
        {
            UNREFERENCED_PARAMETER(cFilters);
            return E_NOTIMPL;
        }

        STDMETHODIMP Reset(void)
        {
            CAutoLock cObjectLock(this);
            ZeroMemory(&mERF_Cur, sizeof(mERF_Cur));
            mERF_Finished = FALSE;
            return NOERROR;
        };

        // No cloning - ALWAYS returns E_NOTIMPL.
        // If need be do one enumeration at a time and cache the results.

        STDMETHODIMP Clone(IEnumRegFilters **ppEnum)
        {
            UNREFERENCED_PARAMETER(ppEnum);
            return E_NOTIMPL;
        }

        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
};  // class CEnumRegFilters

// ------------------------------------------------------------------------
// return monikers. could probably be combined with CEnumRegFilters
//

class CEnumRegMonikers : public IEnumMoniker,    // The interface we support
                        public CUnknown,         // A non delegating IUnknown
                        public CCritSec          // Provides object locking
{

    // This thing has lots of data, so needs locking to make it thread safe,
    // but in addition, there can be many of these accessing a single copy
    // of the MapperCache so that needs separate locking.

private:

    bool mERF_bExactMatch;    // no wildcards?
    DWORD mERF_dwMerit;       // at least this merit needed
    GUID *mERF_pInputTypes;   // types reqd for input pin
    DWORD mERF_cInputTypes;   // number of input
    CLSID mERF_clsInPinCat;   // this pin category needed
    GUID *mERF_pOutputTypes;  // types reqd for output pin
    DWORD mERF_cOutputTypes;  // number of output types
    CLSID mERF_clsOutPinCat;  // this pin category needed
    REGPINMEDIUM mERF_medIn;  // medium reqd for input pin
    REGPINMEDIUM mERF_medOut; // medium reqd for output pin
    bool mERF_bMedIn;         // medium reqd for input pin?
    bool mERF_bMedOut;        // medium reqd for output pin?
    BOOL  mERF_bRender;       // does the input pin have to be rendered
    BOOL  mERF_bInputNeeded;  // must have at least one input pin
    BOOL  mERF_bOutputNeeded; // must have at least one output pin
    BOOL  mERF_Finished ;     // Pos==NULL could mean finished or not started
    Cursor mERF_Cur;          // cursor (together with Finished)
    CMapperCache * mERF_pReg; // Registry cache

public:

        // Normal constructor that creates an enumerator set at the start
    CEnumRegMonikers(
        BOOL bExactMatch,
        DWORD dwMerit,
        BOOL bInputNeeded,
        const GUID *pInputTypes,
        DWORD cInputTypes,
        const REGPINMEDIUM *pMedIn,
        const CLSID *pPinCatIn,
        BOOL bRender,
        BOOL bOutputNeeded,
        const GUID *pOutputTypes,
        DWORD cOutputTypes,
        const REGPINMEDIUM *pMedOut,
        const CLSID *pPinCatOut,
        CMapperCache * pReg,
        HRESULT *phr
        );


    ~CEnumRegMonikers();

    DECLARE_IUNKNOWN

    STDMETHODIMP Next
    ( ULONG cFilters,           // place this many filters...
      IMoniker **rgpMoniker,
      ULONG * pcFetched         // actual count passed returned here
      );

    STDMETHODIMP Skip(ULONG cFilters)
    {
        UNREFERENCED_PARAMETER(cFilters);
        return E_NOTIMPL;
    }

    STDMETHODIMP Reset(void)
    {
        CAutoLock cObjectLock(this);
        ZeroMemory(&mERF_Cur, sizeof(mERF_Cur));
        mERF_Finished = FALSE;
        return NOERROR;
    };

    // No cloning - ALWAYS returns E_NOTIMPL.
    // If need be do one enumeration at a time and cache the results.

    STDMETHODIMP Clone(IEnumMoniker **ppEnum)
    {
        UNREFERENCED_PARAMETER(ppEnum);
        return E_NOTIMPL;
    }

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
};  // class CEnumRegFilters



#ifdef DEBUG

#define CBMAX 160
#define DBG_MON_GET_NAME(pmon) DbgMonGetName((WCHAR *)_alloca(CBMAX), pmon)
static WCHAR *DbgMonGetName(WCHAR *wszMonName, IMoniker *pMoniker)
{
    extern WCHAR *MonGetName(IMoniker *pMon);
    WCHAR *wszTmp;
    ZeroMemory(wszMonName, CBMAX);
    if (pMoniker) {
        wszTmp = MonGetName(pMoniker);
        if(wszTmp)
        {
            long cb = (lstrlenW(wszTmp) + 1) * sizeof(WCHAR);
            cb = (long)min((CBMAX - sizeof(WCHAR)) , cb);

            CopyMemory(wszMonName, wszTmp, cb);
            CoTaskMemFree(wszTmp);
        }
    } else {
        lstrcpyW(wszMonName, L"Unknown name");
    }

    return wszMonName;
}

#endif // DEBUG

WCHAR *MonGetName(IMoniker *pMon);


#endif // __DefFilMapper
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\intel.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// MUST TURN ALL THE LOG STRINGS INTO RESOURCES OR THIS IS NON-LOCALISABLE!!

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include <hrExcept.h>

// Many of these are needed to make filgraph.h compile, even though they
// are not otherwise used here
#include "fgenum.h"
#include "distrib.h"
#include "rlist.h"
#include "filgraph.h"
#include "resource.h"
#include <fgctl.h>

//#define FILGPERF 1
#ifdef FILGPERF
#define MSR_INTEGERX(a,b) MSR_INTEGER(a,b)
#else
#define MSR_INTEGERX(a,b)
#endif

#ifdef DEBUG
static void DbgValidateHeaps()
{
  HANDLE rgh[512];
  DWORD dwcHeaps = GetProcessHeaps(512, rgh);
  for(UINT i = 0; i < dwcHeaps; i++)
    ASSERT(HeapValidate(rgh[i], 0, 0) );
}
#endif

#ifdef DEBUG
#define IS_DEBUG 1
#else
#define IS_DEBUG 0
#endif

// when enumerating, start with a few pins on the stack and then use
// alloca once we know the right number. fewer in debug so we can test
// the rarer code path.
#ifdef DEBUG
#define C_PINSONSTACK 2
#else
#define C_PINSONSTACK 20
#endif

// we need the display name only for debug builds and logging
// purposes. and the caller wants it on the stack.
WCHAR *CFilterGraph::LoggingGetDisplayName(
    WCHAR szDisplayName[MAX_PATH] , IMoniker *pMon)
{
    szDisplayName[0] = 0;
    if(pMon && ( mFG_hfLog != INVALID_HANDLE_VALUE || IS_DEBUG))
    {

        WCHAR *wsz = 0; pMon->GetDisplayName(0, 0, &wsz);
        if(wsz)
        {
            lstrcpynW(szDisplayName, wsz, MAX_PATH);
            QzTaskMemFree(wsz);
        }
    }

    return szDisplayName;
}

void CFilterGraph::Log(int id,...)
{
    const cch = 400;

    TCHAR szFormat[cch];
    TCHAR szBuffer[2000];       // big to allow for large filenames in the parameters

#ifndef DEBUG
    // Don't waste time if there's no log running
    if (mFG_hfLog == INVALID_HANDLE_VALUE) {
        return;
    }

#endif


    if (LoadString(g_hInst, id, szFormat, cch) == 0) {
        return;   // Tough!
    }

    va_list va;
    va_start(va, id);

    // Format the variable length parameter list
    wvsprintf(szBuffer, szFormat, va);

    // First put it out on the debugger (if it's a debug build etc)
    DbgLog(( LOG_TRACE, 2, szBuffer));

    // Then put it out into the log file (if any)
    if (mFG_hfLog != INVALID_HANDLE_VALUE) {
        lstrcat(szBuffer, TEXT("\r\n"));
        DWORD dw;
        WriteFile(mFG_hfLog, (BYTE *) szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dw, NULL);
    }
    va_end(va);
}

#ifdef DEBUG
static CLSID DbgExpensiveGetClsid(IMoniker *pMon)
{
    CLSID retClsid = GUID_NULL;
    if(pMon)
    {
        IPropertyBag *pPropBag;
        HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
        if(SUCCEEDED(hr))
        {
            VARIANT var;
            var.vt = VT_BSTR;
            hr = pPropBag->Read(L"CLSID", &var, 0);
            if(SUCCEEDED(hr))
            {
                CLSID clsid;
                if (CLSIDFromString(var.bstrVal, &clsid) != S_OK)
                {
                    DbgBreak("couldn't convert CLSID");
                }
                else
                {
                    retClsid = clsid;
                }

                SysFreeString(var.bstrVal);
            }
            pPropBag->Release();
        }
    }
    return retClsid;
}

CLSID CFilterGraph::DbgExpensiveGetClsid(const Filter &F)
{
    CLSID clsid = ::DbgExpensiveGetClsid(F.pMon);
    if(clsid != GUID_NULL)
        return clsid;

    // if we found the filter in the graph, we don't have the
    // moniker. but we do have the filter loaded, so we can ask it its
    // clsid
    if(F.pf)
    {
        IPersist *pp;
        if(F.pf->QueryInterface(IID_IPersist, (void **)&pp) == S_OK)
        {
            CLSID clsid;
            pp->GetClassID(&clsid);
            pp->Release();
            return clsid;
        }
    }

    return GUID_NULL;
}
#endif

WCHAR *MonGetName(IMoniker *pMon)
{
    WCHAR *pszRet = 0;
    IPropertyBag *pPropBag;
    HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {
        VARIANT var;
        var.vt = VT_BSTR;
        hr = pPropBag->Read(L"FriendlyName", &var, 0);
        if(SUCCEEDED(hr))
        {
            hr = AMGetWideString(var.bstrVal, &pszRet);
            SysFreeString(var.bstrVal);
        }
        pPropBag->Release();
    }

    return pszRet;
}

// certain error codes mean that this filter will never connect, so
// best give up now. really this should have been formalized with
// documented success and failure codes

inline BOOL IsAbandonCode(HRESULT hr)
{
    return hr == VFW_E_NOT_CONNECTED || hr == VFW_E_NO_AUDIO_HARDWARE;
}

// errors that are more useful than any others we could give the end
// user.
inline bool IsInterestingCode(HRESULT hr) {
    return hr == VFW_E_NO_AUDIO_HARDWARE;
}

//========================================================================
//
//  Helper for return codes
//
//========================================================================
HRESULT ConvertFailureToInformational(HRESULT hr)
{
    ASSERT(FAILED(hr));
    if (VFW_E_NO_AUDIO_HARDWARE == hr) {
        hr = VFW_S_AUDIO_NOT_RENDERED;
    } else if (VFW_E_NO_DECOMPRESSOR == hr) {
        hr = VFW_S_VIDEO_NOT_RENDERED;
    } else if (VFW_E_RPZA == hr) {
        hr = VFW_S_RPZA;
    } else {
        hr = VFW_S_PARTIAL_RENDER;
    }
    return hr;
}

CFilterGraph::Filter::Filter() : State(F_ZERO),
                   pTypes(NULL),
                   pef(NULL),
                   pMon(NULL),
                   pEm(NULL),
                   cTypes(0),
                   pf(NULL),
                   Name(NULL),
                   m_pNextCachedFilter(NULL)
{
};

HRESULT CFilterGraph::Filter::AddToCache( IGraphConfig* pGraphConfig )
{
    // This function should only be called if the filter cache is being enumerated.
    ASSERT( F_CACHED == State );

    // It's impossible to add an non-existent filter to the filter cache.
    ASSERT( NULL != pf );

    return pGraphConfig->AddFilterToCache( pf );
}

void CFilterGraph::Filter::RemoveFromCache( IGraphConfig* pGraphConfig )
{
    // This function should only be called if the filter cache is being enumerated.
    ASSERT( F_CACHED == State );

    // It's impossible to remove an non-existent filter from the filter cache.
    ASSERT( NULL != pf );

    HRESULT hr = pGraphConfig->RemoveFilterFromCache( pf );

    // IGraphConfig::RemoveFilterFromCache() should return S_OK because 
    // 1) A cached filter can always be successfully removed from the
    //    filter cache
    // 2) IGraphConfig::RemoveFilterFromCache() returns S_OK if a 
    //    cached filter is successfully removed.
    // 3) pf MUST be cached because State == F_CACHED.
    ASSERT( S_OK == hr );

    // Release the filter cache's reference count.
    pf->Release();
}

void CFilterGraph::Filter::ReleaseFilter( void )
{
    // It's impossible to release a non-existent filter.
    ASSERT( NULL != pf );

    pf->Release();
    pf = NULL;
}

CFilterGraph::Filter::~Filter()
{
    delete [] pTypes;
    if (pef) {
        pef->Release();
    }
    if (pMon) {
        pMon->Release();
    }
    if (pEm) {
        pEm->Release();
    }
    if (pf) {
        pf->Release();
    }
    if( m_pNextCachedFilter ) {
        delete m_pNextCachedFilter;
    }

    QzTaskMemFree(Name);
}

//===========================================================================
//
// Intelligent connection/rendering design notes:
//
// Media types are structures which are open ended - there's a type, subtype
// and then extra bits.  The complexity of the way that filters respond to
// this is also open ended - therefore it will never be enough to look in the
// registry and play some games deciding how to wire things up.  We cannot
// know in advance how a filter will behave until it's actually wired up.
// Therefore the intelligent connection or rendering must be done actually
// loading the real filters and really wiring them up.
//
// Ground rules ("dogma")
// 1. Use spare input pins that are already in the graph
// 2. Don't break any connection made previous to this call to Connect or Render
// 3. Always work downstream
// 4. Connect input pins before querying output pins.
//    PINDIR_OUTPUT pins may appear on connection.
//    This might correspond to being told to connect a file output pin to
//    an audio codec.  We connect it via a parser which also generates a
//    video output.
//    Once a filter has an input pin connected, the output pin where
//    the data appears is well defined and can be queried.
// 5. Try hardware before software (= try filters in order of Merit)
// 6. It is fair game to call ConnectedTo for a pin that's not yet connected.
//    but it is likely to FAIL and in this case may return bad data.
//
//
// We may have to make an N stage connection where N is at least 2
// (parser + codec).  This makes the thing rather like a look-ahead search.
// We may need at least 3 stages to do an intelligent Render (parser, codec,
// renderer).
//
// There is no way to tell whether we are making progress or going down a
// blind alley as we start extending the chain of codecs, so we have to do
// a full scale search of the tree of possibilities with full back-out from
// blind alleys.
//
// Breadth first might be nice, but it leaves a lot of resources hanging
// around else risks going even slower than depth first.  Depth first requires
// some cut-off to prevent an infinite blind alley.
//
// Therefore I am going for a depth first search with a maximum
// depth cut-off.  The cut-off makes deep cuts in the otherwise potentially
// infinite search tree.
//
// There is an ordering of the search tree. Hence the "NextChainToTry" is
// well defined.
// In the case of "Connect" a step in the search consists of a chain of filters,
// characterised by <Filter1, InputPin1>, <Filter2, InputPin1>, ...
// In the ordering, Filter1 is the most significant part, InputPin1 next, Filter2
// next and so on.  The ordering of filters is:
//    Filters in the filter cache which are ordered arbitrarly.
//    Followed by filters already in the filter graph, in the order in which they lie
//    in FilGenList
//    followed by filters in the registry in the order in which the registry
//    enumerates them.
// The ordering of pins is the order in which they enumerate when the
// filter is queried.
// NOTE: A filter in the graph will be tried again from the registry.
// If the filter in the graph is already connected, a second instance
// might well work.
//
// NOTE:  When we are making or breaking connections we do NOT alter
// the sequence of the FilGenList other than possibly to add things
// to the end.  Otherwise we risk a closed loop.
//
// Thus if the current step in the search looked like
//           -->Parser, Pin1, MyCodec, Pin3
// meaning that Pin1 was the input pin of the parser and the parser's output
// was connected to Pin3 of MyCodec then the search would proceed by looking
// for
//         a filter in the filtergraph to connect the output of MyCodec to
//                 an input pin on that filter
//                         a filter to connect THAT to etc.
// and if that fails it backs up by trying successively:
//         a different input pin on MyCodec to connect to
//         a different second filter to use instead of MyCodec
//         a different input pin to use on the parser
//         a different filter to use instead of the parser
//         and if that doesn't work then it fails.
//
// It finds the first connection rather than the best.  This is because
// I think that often there will only be one that works and that we
// want to find a connection quickly.
//
// With luck, many of the search stages will only have one viable candidate
// and the search will go fast.  A deep tree search with multiple branches
// per level would be bound to be slow.
//
// The Connect and Render algorithms are similar, but different in detail.
// In each case we go through many stages to grow the chain and finish up
// with either another pair of pins to connect or another set of pins to
// render.  For this reason a recursive implementation seems neatest.
//
// It isn't clear to me at the moment whether the registry is or is not
// happy to have multiple enumerations at various stages.  The help for
// RegEnumKeyEx says that you can either enumerate through the keys
// forwards or backwards, but it doesn't say you can hop about.
// The alternative is to read the filters once and cache them all
// which is what the mapper actually does.

// See also RLIST.H << READ THIS before tinkering(!)

// Search depth for intelligent connection
#define CONNECTRECURSIONLIMIT 5


// THE HIERARCHY OF FUNCTIONS AND PARAMTERS
//
// For intelligent CONNECT

// Connect(pOut, pIn)                            start point
// ConnectRecursively(pOut, pIn, iRecurse)       with depth
// ConnectViaIntermediate(pnOut, pIn, iRecurse)  Finds an intermediate4 filter
// ConnectUsingFilter(pOut, pIn,  F, iRecurse)   Loads F (if need be)
// ConnectByFindingPin(pOut, pIn, F, iRecurse)   Finds input pin on F
// CompleteConnection(pIn, F, pPin, iRecurse)    Finds output pin on F
// ConnectRecursively(pOut, pIn, iRecurse+1)     Next step in the chain


// Render(ppinOut)                                start point
// RenderRecursively(ppinOut,     iRecurse,...) with depth and backout
// RenderViaIntermediate(ppinOut, iRecurse,...) Finds an intermediate filter
// RenderUsingFilter(ppinOut,  F, iRecurse,...) Loads F (if need be)
// RenderByFindingPin(ppinOut, F, iRecurse,...) Finds input pin on F
// CompleteRendering(F, pPin,     iRecurse,...) Finds all output pins  on F
// RenderRecursively(ppinOut,   iRecurse+1,...) Next step in the chain

// The ... stands for three extra parameters on every call.
// 1. A list of actions that might need backing out.  This is also the
// state of the search.
// 2. The list of spare filters.  During the course of Rendering or
// Connecting, we may find that we try a filter and it's no good.
// In that case, rather than unload it, we stick it, together with its
// CLSID, on the Spares list, a list of filters to unload eventually.
// When a new filter is to be loaded, we try the spares list before we
// try CoCreate...  This will (with luck) speed things up.
// 3. The best-so-far state.
// Best means rendering the greatest proportion of the streams with ties
// broken by using the smallest number of filters.


//========================================================================
//
// NextFilter
//
// Update F to the next filter after F in the enumeration.
// Any filter with State F_ZERO represents the start of the enumeration
// Next come filters in the filter cache.
// Next come filters already in the filter graph
// Next come filters from the registry
// After all these comes any filter with State F_INFINITY
//========================================================================
void CFilterGraph::NextFilter(Filter &F, DWORD dwFlags)
{
    HRESULT hr;         // return code from thing(s) we call

    if (F.State==F_ZERO) {
        // F.m_pNextCachedFilter should be NULL because the Filter's state
        // is not F_CACHED.  F.m_pNextCachedFilter is only used when the filter
        // cache is being searched.
        ASSERT( NULL == F.m_pNextCachedFilter );

        F.State = F_CACHED;

        // CEnumCachedFilters only changes hr's value if an error occurs.
        hr = S_OK;

        F.m_pNextCachedFilter = new CEnumCachedFilters( &m_Config, &hr );
        if( (NULL == F.m_pNextCachedFilter) || FAILED( hr ) ) {
            delete F.m_pNextCachedFilter;
            F.m_pNextCachedFilter = NULL;
            F.State = F_INFINITY;
            return;
        }
    }

    if( NULL != F.pf ) {
        F.ReleaseFilter();
    }

    if( F_CACHED == F.State ) {
        IBaseFilter* pNextCachedFilter;

        CEnumCachedFilters& NextCachedFilter = *F.m_pNextCachedFilter;  
        pNextCachedFilter = NextCachedFilter();
        if( NULL != pNextCachedFilter ) {
            F.pf = pNextCachedFilter;
            return;
        }

        // NextCachedFilter() returns NULL if it has enumerated all the filters in
        // the filter cache.  If this occurs then the filter graph should be searched.

        delete F.m_pNextCachedFilter;
        F.m_pNextCachedFilter = NULL;

        
        // IGraphConfig::Reconnect() allows the user to preform a reconnect operation useing
        // only cached filters.  
        if( dwFlags & AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS ) {
            F.State = F_INFINITY;
            return;
        }

        // F.pef should be NULL because the Filter's state is not
        // E_LOADED.  F.pef is only used when the filter graph is 
        // being searched for filters.
        ASSERT( NULL == F.pef );

        F.State = F_LOADED;

        hr = EnumFilters( &(F.pef) );
        if( FAILED( hr ) ) {
            F.State = F_INFINITY;
            return;                
        }
    }

    if (F.State==F_LOADED) {
       //------------------------------------------------------------------------
       // Try to get next filter from filtergraph, if so return it.
       //------------------------------------------------------------------------
        ULONG cFilter;
        IBaseFilter* aFilter[1];
        F.pef->Next(1, aFilter, &cFilter);

        if (cFilter==1) {
            F.pf = aFilter[0];
            DbgLog(( LOG_TRACE, 4, TEXT("NextFilter from graph %x"), F.pf));
            return;
        } else {
            // Enumeration from the filter graph failed, try enumerating the filters in the registry.
            F.pef->Release();
            F.pef = NULL;

            if (!F.bLoadNew) {
                F.State = F_INFINITY;
                return;
            }

            F.State = F_REGISTRY;
            hr = NextFilterHelper( F );
            if (FAILED(hr)) {
                F.State = F_INFINITY;
                return;
            }

            ASSERT(F.Name == NULL);

        }
    }

    //------------------------------------------------------------------------
    // Try to get next filter from registry, if so return it, else tidy up.
    //------------------------------------------------------------------------

    {
        ULONG cFilter;
        IMoniker *pMoniker;
        if (F.Name!=NULL) {
            QzTaskMemFree(F.Name);
            F.Name = NULL;
        }
        if (F.pMon != 0) {
            F.pMon->Release();
            F.pMon = 0;
        }

        while(F.pEm->Next(1, &pMoniker, &cFilter) == VFW_E_ENUM_OUT_OF_SYNC)
        {
            F.pEm->Release();
            F.pEm = 0;

            HRESULT hrTmp = NextFilterHelper(F);
            if(FAILED(hrTmp)) {
                break;
            }
        }

        if (cFilter==1) {

            DbgLog(( LOG_TRACE, 4, TEXT("NextFilter from registry %x")
                   , ::DbgExpensiveGetClsid(pMoniker).Data1
                  ));
            ASSERT(F.pMon == 0);
            F.pMon = pMoniker;  // transfer refcount

            F.Name = MonGetName(pMoniker);
            if (F.Name == 0) {
                F.State = F_INFINITY;
            }

            return;
        } else {
            F.State = F_INFINITY;
            return;
        }
    }

}  // NextFilter

// ========================================================================
// just a helper for something done twice

HRESULT CFilterGraph::NextFilterHelper(Filter &F)
{
    // qi for this each time; can't hold onto interface
    // because it'll addref us.
    IFilterMapper2 *pfm2;
    HRESULT hr = mFG_pMapperUnk->QueryInterface(IID_IFilterMapper2, (void **)&pfm2);
    if(SUCCEEDED(hr))
    {
        ASSERT(F.pEm == NULL);
        hr = pfm2->EnumMatchingFilters(
            &(F.pEm)
            , 0
            , FALSE           // do match wildcards
            , MERIT_DO_NOT_USE+1
            , F.bInputNeeded
            , F.cTypes, F.pTypes
            , 0               // medium in
            , 0               // pin category in
            , FALSE           // bRender
            , F.bOutputNeeded
            , 0, NULL
            , 0               // medium out
            , 0               // pin category out
            );
        pfm2->Release();
    }
    else
    {
        DbgBreak("filgraph/intel.cpp: qi for IFilterMapper2 failed.");
    }

    return hr;
}

// helper to use the IAMGraphBuilderCallback interface
HRESULT CFilterGraph::CreateFilterAndNotify(IMoniker *pMoniker, IBaseFilter **ppFilter)
{
    HRESULT hr = S_OK;
    
    // mFG_punkSite can be null.
    CComQIPtr<IAMGraphBuilderCallback, &IID_IAMGraphBuilderCallback> pcb(mFG_punkSite);
    if(pcb) {
        hr = pcb->SelectedFilter(pMoniker);
    }
    if(FAILED(hr)) {
        DbgLog((LOG_TRACE, 2, TEXT("callback rejected moniker %08x."), hr));
    }
    if(SUCCEEDED(hr)) {
        hr = CreateFilter(pMoniker, ppFilter);
    }
    if(SUCCEEDED(hr) && pcb)
    {
        hr = pcb->CreatedFilter(*ppFilter);

        if(FAILED(hr)) {
            (*ppFilter)->Release();
            *ppFilter = 0;
            DbgLog((LOG_TRACE, 2, TEXT("callback rejected filter %08x."), hr));
        }
    }
    return hr;
}

//========================================================================
//
// GetAMediaType
//
// Enumerate the media types of *ppin.  If they all have the same majortype
// then set MajorType to that, else set it to CLSID_NULL.  If they all have
// the same subtype then set SubType to that, else set it to CLSID_NULL.
// If something goes wrong, set both to CLSID_NULL and return the error.
//========================================================================
HRESULT CFilterGraph::GetAMediaType( IPin * ppin
                                   , CLSID & MajorType
                                   , CLSID & SubType
                                   )
{

    HRESULT hr;
    IEnumMediaTypes *pEnumMediaTypes;

    /* Set defaults */
    MajorType = CLSID_NULL;
    SubType = CLSID_NULL;

    hr = ppin->EnumMediaTypes(&pEnumMediaTypes);

    if (FAILED(hr)) {
        return hr;    // Dumb or broken filters don't get connected.
    }

    ASSERT (pEnumMediaTypes!=NULL);

    /* Put the first major type and sub type we see into the structure.
       Thereafter if we see a different major type or subtype then set
       the major type or sub type to CLSID_NULL, meaning "dunno".
       If we get so that both are dunno, then we might as well return (NYI).
    */

    BOOL bFirst = TRUE;

    for ( ; ; ) {

        AM_MEDIA_TYPE *pMediaType = NULL;
        ULONG ulMediaCount = 0;

        /* Retrieve the next media type
           Need to delete it when we've done.
        */
        hr = pEnumMediaTypes->Next(1, &pMediaType, &ulMediaCount);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr)) {
            MajorType = CLSID_NULL;
            SubType = CLSID_NULL;
            pEnumMediaTypes->Release();
            return NOERROR;    // we can still plough on
        }

        if (ulMediaCount==0) {
            pEnumMediaTypes->Release();
            return NOERROR;       // normal return
        }

        if (bFirst) {
            MajorType = pMediaType[0].majortype;
            SubType = pMediaType[0].subtype;
            bFirst = FALSE;
        } else {
            if (SubType != pMediaType[0].subtype) {
                SubType = CLSID_NULL;
            }
            if (MajorType != pMediaType[0].majortype) {
                MajorType = CLSID_NULL;
            }
        }
        DeleteMediaType(pMediaType);
    }
} // GetAMediaType


//========================================================================
//
// GetMediaTypes
//
// Enumerate the media types of *ppin.  If they all have the same majortype
// then set MajorType to that, else set it to CLSID_NULL.  If they all have
// the same subtype then set SubType to that, else set it to CLSID_NULL.
// If something goes wrong, set both to CLSID_NULL and return the error.
//========================================================================
HRESULT CFilterGraph::GetMediaTypes( IPin * ppin
                                   , GUID **ppTypes
                                   , DWORD *cTypes
                                   )
{

    HRESULT hr;
    IEnumMediaTypes *pEnumMediaTypes;

    ASSERT(*ppTypes == NULL);

    hr = ppin->EnumMediaTypes(&pEnumMediaTypes);

    if (FAILED(hr)) {
        return hr;    // Dumb or broken filters don't get connected.
    }

    ULONG ulTypes = 0;
    AM_MEDIA_TYPE *pMediaTypes[100];
    hr = pEnumMediaTypes->Next(sizeof(pMediaTypes) / sizeof(pMediaTypes[0]),
                               pMediaTypes,
                               &ulTypes);

    pEnumMediaTypes->Release();
    ASSERT(ulTypes <= 100);
    ULONG ulActualTypes = ulTypes < 2 ? 1 : ulTypes;
    *ppTypes = new GUID[ulActualTypes * 2];
    if (*ppTypes == NULL) {
        hr = E_OUTOFMEMORY;
    } else {
        hr = S_OK;
    }

    for (ULONG iType = 0; iType < ulTypes; iType++) {
        AM_MEDIA_TYPE *pmt = pMediaTypes[iType];
        if (S_OK == hr) {
            CopyMemory(&(*ppTypes)[iType * 2], &pmt->majortype,
                       2 * sizeof(GUID));
        }
        DeleteMediaType(pmt);
    }
    if (SUCCEEDED(hr)) {
        if (ulTypes == 0) {
            (*ppTypes)[0] = MEDIATYPE_NULL;
            (*ppTypes)[1] = MEDIASUBTYPE_NULL;
        }
        *cTypes = ulActualTypes;
    }
    return hr;
} // GetMediaTypes


struct CDelRgPins
{
    inline CDelRgPins(IPin **rgpPins) { m_rgpPins = rgpPins; }
    inline ~CDelRgPins() { delete[] m_rgpPins; }
    IPin **m_rgpPins;
};

//========================================================================
//
// CompleteConnection
//
// Trace the input from pPin through F and connect the output
// stream to ppinIn.  If there is not exactly one output stream then fail.
//
// given that F is loaded in the filtergraph and its input is connected
//========================================================================
HRESULT CFilterGraph::CompleteConnection
    ( IPin * ppinIn      // the input pin to ultimately connect to
    , const Filter& F           // the intermed filter (acts as cursor for filter enum)
    , IPin * pPin        // a connected input pin of F
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+7);
    DbgLog(( LOG_TRACE, 4, TEXT("CompleteConnection Pins %x->(filter %x)...>%x level %d")
           , pPin, F.pf, ppinIn, iRecurse));
    HRESULT hr;             // return code from thing(s) we call
    IPin * ppinOut = NULL;  // output pin of F that ppinIn's stream emerges through

    // We allow graphs that have spare output pins - so we enumerate the output
    // pins that the input in streams through to and try connecting each in
    // turn.  We first try QueryInternalConnections.  If that is not
    // implemented we assume that any input pin connects to every output pin.

    int nPin;
    IPin * apPinStack[C_PINSONSTACK];
    IPin **apPin = apPinStack;
    hr = FindOutputPinsHelper( pPin, &apPin, C_PINSONSTACK, nPin, false );
    if (FAILED(hr)) {
        Log( IDS_CONQICFAIL, ppinIn, hr);
        return hr;
    }
    CDelRgPins rgPins(apPin == apPinStack ? 0 : apPin);

    // apPin[0..nPin-1] are addreffed output pins.

    if (nPin==0) {
        Log(IDS_CONNOOUTPINS, F.pf);
    }

    // Do two passes.  in the first pass, take only pins whose media type
    // has a major type which matches F.MajorType
    for (int iPass = 0; iPass<=1; ++iPass) {

       BOOL bSparePins = FALSE;
       for (int iPin = 0; iPin<nPin; ++iPin) {
           if (apPin[iPin]==NULL) {
               continue;       // we must have done this one in pass 1
           }

           if (mFG_bAborting) {
               apPin[iPin]->Release();  // release the ref count on this pin
               continue;
           }

           if (iPass==0) {
              CLSID MT, ST;
              hr = GetAMediaType(apPin[iPin], MT, ST);
              if (MT!=F.pTypes[0]) {
                 continue;      // try this one only in pass 2
              }
           }

           Log(IDS_CONRECURSE, apPin[iPin], F.pf, ppinIn );
           hr = ConnectRecursively(apPin[iPin], ppinIn, NULL, dwFlags, iRecurse);
           apPin[iPin]->Release();  // release the ref count on this pin
           apPin[iPin] = NULL;      // ensure we never look again in pass 2
           if (SUCCEEDED(hr)) {
               Log(IDS_CONRECURSESUC, apPin[iPin], F.pf, ppinIn );

               // Release the ref count on the remaining untried pins
               for (int i=iPin+1; i<nPin; ++i) {
                   apPin[i]->Release();
                   bSparePins = TRUE;
               }
               MSR_INTEGERX(mFG_idIntel, 100*iRecurse+17);
               return (bSparePins ? VFW_S_PARTIAL_RENDER : NOERROR);
           } else {
               bSparePins = TRUE;
               Log(IDS_CONRECURSEFAIL, apPin[iPin], F.pf, ppinIn, hr );
           }
       }
       if (mFG_bAborting) {
          break;
       }

    }


    Log(IDS_CONNOMOREOUTPINS, F.pf);
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+37);
    return (mFG_bAborting ? E_ABORT : VFW_E_CANNOT_CONNECT);

} // CompleteConnection




//========================================================================
//
// ConnectByFindingPin
//
// Connect ppinOut to ppinIn using F as an intermediate filter
// given that F is loaded and in the filter graph
// Finds an input pin on F to connect to.
//========================================================================
HRESULT CFilterGraph::ConnectByFindingPin
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtConnection
    , const Filter& F           // the intermed filter (acts as cursor for filter enum)
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+6);
    DbgLog(( LOG_TRACE, 4, TEXT("ConnectByFindingPin %8x..(%8x)...>%8x level %d")
           , ppinOut, F.pf, ppinIn, iRecurse));
    HRESULT hr;         // return code from thing(s) we call

    // Set pPin to each pin in F to find the input pin on F
    CEnumPin Next(F.pf, CEnumPin::PINDIR_INPUT, TRUE);        // only want input pins
    IPin *pPin;

    Log(IDS_CONTRYPINS, F.pf, ppinOut, ppinIn);
    while ((LPVOID) (pPin = Next())) {
        if (mFG_bAborting) {
            pPin->Release();
            break;
        }
        DbgLog(( LOG_TRACE, 4, TEXT("ConnectByF...P Pin %x --> Trying input pin: %x ...>%x (level %d)")
                , ppinOut, pPin, ppinIn, iRecurse));

        IPin *pConnected;
        hr = pPin->ConnectedTo(&pConnected);
        if ( FAILED(hr) || pConnected==NULL) {    // don't try if already connected
            hr = ConnectDirectInternal(ppinOut, pPin, pmtConnection); // no version count
            if (SUCCEEDED(hr)) {
                Log( IDS_CONDISUC, ppinOut, pPin, F.pf );
                hr = CompleteConnection(ppinIn, F, pPin, dwFlags, iRecurse);

                if (FAILED(hr)) {
                    Log( IDS_CONCOMPLFAIL, pPin, F.pf, ppinIn, hr );
                    // Disconnect the input pin and see if there was another.
                    // Purge any pending reconnects between these two pins
                    mFG_RList.Purge(pPin);
                    mFG_RList.Purge(ppinOut);
                    DbgLog((LOG_TRACE, 3, TEXT("Disconnecting pin %x"), pPin));
                    hr = pPin->Disconnect();
                    ASSERT(SUCCEEDED(hr));
                    DbgLog((LOG_TRACE, 3, TEXT("Disconnecting pin %x"), ppinOut));
                    hr = ppinOut->Disconnect();
                    ASSERT(SUCCEEDED(hr));
                } else {

                    pPin->Release();
                    DbgLog((LOG_TRACE, 4, TEXT("Released D pin %x"), pPin));
                    DbgLog(( LOG_TRACE, 4, TEXT("ConnectByFindingPin succeeded level %d")
                           , iRecurse));
                    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+16);
                    Log( IDS_CONCOMPLSUC, pPin, F.pf, ppinIn );
                    return hr;

                }
            } else {
                Log( IDS_CONDIFAIL, ppinOut, pPin, F.pf, hr);
            }

        } else {
            pConnected->Release();
        }
        pPin->Release();
    }
    Log( IDS_CONNOMOREINPINS, F.pf);

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+26);
    return (mFG_bAborting ? E_ABORT : VFW_E_CANNOT_CONNECT);

} // ConnectByFindingPin



//========================================================================
//
// ConnectUsingFilter
//
// Connect ppinOut to ppinIn using F as an intermediate filter
//========================================================================
HRESULT CFilterGraph::ConnectUsingFilter
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtConnection
    , Filter& F          // the intermed filter (acts as cursor for filter enum)
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    // CFilterGraph::ConnectUsingFilter() expects the proposed filter (F) to be in the
    // F_LOADED state (F is in the filter graph), the F_CACHED state (F is in the filter cache) or
    // the F_REGISTRY state (F has been found in the registry but it has not been created).
    ASSERT( (F_LOADED == F.State) || (F_CACHED == F.State) || (F_REGISTRY == F.State) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+5);
    DbgLog(( LOG_TRACE, 4, TEXT("Connect Using... pins %x...>%x filter (%d %x %x) level %d")
           , ppinOut, ppinIn, F.State, F.pf, DbgExpensiveGetClsid(F).Data1, iRecurse ));
    HRESULT hr;         // return code from thing(s) we call

    if( (F_REGISTRY == F.State) || (F_CACHED == F.State) ) {

        switch( F.State ) {
        case F_REGISTRY:
            ASSERT( F.pf == NULL );

            hr = CreateFilterAndNotify(F.pMon, &(F.pf));
            {
                WCHAR szDisplayName[MAX_PATH];
                LoggingGetDisplayName(szDisplayName, F.pMon);
                Log( IDS_CONVIAREG, ppinOut, ppinIn, szDisplayName);

                if (FAILED(hr)) {
                    Log( IDS_CONLOADFAIL, szDisplayName, hr );
                    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+25);
                    return hr;
                } else {
                    Log( IDS_CONLOADSUC, szDisplayName, F.pf );
                }

            }

            ASSERT( NULL != F.Name );
            break;

        case F_CACHED:
            break;

        default:
            // This code should never be executed.
            ASSERT( false );
            return E_UNEXPECTED;

        }

        hr = AddFilterInternal(F.pf, F.Name, true);   // AddReffed, no version count
        if (hr==VFW_E_DUPLICATE_NAME) {
             // This is getting out of hand.  This is expected to be an unusual case.
             // The obvious thing to do is just to add something like _1 to the end
             // of the name - but F.Name doesn't have room on the end - and where
             // do we draw the line?  On the other hand people really could want
             // filter graphs with 50 effects filters in them...?
             hr = AddFilterInternal(F.pf, NULL, true);
        }

        if (FAILED(hr)) {
            Log( IDS_CONADDFAIL, F.pf, hr );
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+35);

            return hr;
        }

        hr = ConnectByFindingPin(ppinOut, ppinIn, pmtConnection, F, dwFlags, iRecurse);
        if (FAILED(hr)) {
            DbgLog((LOG_TRACE, 4,
                    TEXT("ConnectUsing failed (C..ByFind failure) - unloading filter %x level %d") ,
                    DbgExpensiveGetClsid(F).Data1, iRecurse));

            // If this ASSERT fires then a filter could not be removed from the filter graph.
            // This is not a fatal error but the filter graph will have an extra filter
            // in it.
            EXECUTE_ASSERT( SUCCEEDED( RemoveFilterInternal( F.pf ) ) );   // Releases AddFilter refcount

            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+55);
            return hr;
        }
    } else {
        // A filter from the filter graph
        Log( IDS_CONVIA, ppinOut, ppinIn, F.pf );
        hr = ConnectByFindingPin(ppinOut, ppinIn, pmtConnection, F, dwFlags, iRecurse);
        if (FAILED(hr)) {
            DbgLog(( LOG_TRACE, 4
                  , TEXT("ConnectUsing failed (C..ByFind failure) level %d")
                  , iRecurse));
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+65);
            return hr;
        }
    }
    DbgLog(( LOG_TRACE, 4, TEXT("ConnectUsing succeeded level %d")
           , iRecurse));
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+15);
    return hr;  // This is the hr from ConnectByFindingPin

} // ConnectUsingFilter



//========================================================================
//
// ConnectViaIntermediate
//
// Connect ppinOut to ppinIn using another filter as an intermediate
//========================================================================
HRESULT CFilterGraph::ConnectViaIntermediate
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtConnection
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+4);
    DbgLog(( LOG_TRACE, 4, TEXT("Connect Via... pins %x...>%x level %d")
           , ppinOut, ppinIn, iRecurse ));

    HRESULT hr;         // return code from thing(s) we call
    Filter F;           // represents the intermediate filter
    F.bInputNeeded = TRUE;
    F.bOutputNeeded = TRUE;

    /* Find out what we can about the media types it will tolerate */
    hr = GetMediaTypes(ppinOut, &F.pTypes, &F.cTypes);
    if (FAILED(hr)) {
        Log (IDS_CONNOMT, ppinOut, hr );
        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+24);
        return hr;
    }
    /* Try to eliminate incompatible types - we're just never going to
       support weird conversions during automatic connection - it's
       way too slow so only try filters actually in the graph in this
       case
    */
    F.bLoadNew = TRUE;
    if (F.pTypes[0] == MEDIATYPE_Audio || F.pTypes[0] == MEDIATYPE_Video) {
        GUID MajorType, SubType;
        HRESULT hr1 = GetAMediaType(ppinIn, MajorType, SubType);
        if (SUCCEEDED(hr)) {
            if (MajorType != F.pTypes[0] &&
                MajorType != GUID_NULL) {
                F.bLoadNew = FALSE;
            }
        }
    }

    // For each candidate filter, either here or in registry
    for ( ; ; ) {

        if (mFG_bAborting) {
            break;
        }

        NextFilter(F, dwFlags);
        if (F.State==F_INFINITY) {
            break;
        }

        if( F_CACHED == F.State ) {
            F.RemoveFromCache( &m_Config );
        }

        hr = ConnectUsingFilter(ppinOut, ppinIn, pmtConnection, F, dwFlags, iRecurse);
        if (SUCCEEDED(hr)) {
            DbgLog(( LOG_TRACE, 4, TEXT("ConnectVia succeeded level %d")
                   , iRecurse));
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+14);
            return hr;

        } else {
            if( F_CACHED == F.State ) {
                hr = F.AddToCache( &m_Config );
                if( FAILED( hr ) ) {
                    return hr;
                }
            }       
        
            if( IsAbandonCode(hr) ) {
                // no point in trying heroics if the filter is not in a state
                // where anything will connect to it.

                return hr;
            }
        }
    }

    DbgLog(( LOG_TRACE, 4, TEXT("ConnectVia: failed level %d")
           , iRecurse));
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+34);
    return (mFG_bAborting ? E_ABORT : VFW_E_CANNOT_CONNECT);
} // ConnectViaIntermediate

//========================================================================
//
// ConnectRecursively
//
// Connect these two pins directly or indirectly, using transform filters
// if necessary.   Trace the recursion level  Fail if it gets too deep.
//========================================================================
HRESULT CFilterGraph::ConnectRecursively
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtConnection
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )

{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+3);
    HRESULT hr;         // return code from thing(s) we call
    Log( IDS_CONTRYDIRECT, ppinOut, ppinIn);

    //-----------------------------------------------------------
    // Try direct connection
    //-----------------------------------------------------------
    hr = ConnectDirectInternal(ppinOut, ppinIn, pmtConnection);  // no version count

    if (SUCCEEDED(hr)) {
        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+13);
        Log( IDS_CONDIRECTSUC, ppinOut, ppinIn);
        return hr;
    } else if (IsAbandonCode(hr)) {
        // no point in trying any heroics if the filters won't connect to
        // anything else because their own inputs are not connected.
        // Everything will fall down the same hole.
        Log( IDS_CONCON, ppinOut, ppinIn);
        return hr;
    }

    if (iRecurse>CONNECTRECURSIONLIMIT) {
        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+23);
        Log( IDS_CONTOODEEP, ppinOut, ppinIn);
        return VFW_E_CANNOT_CONNECT;
    }

    hr = ConnectViaIntermediate(ppinOut, ppinIn, pmtConnection, dwFlags, 1+iRecurse);
    if (SUCCEEDED(hr)) {
       Log( IDS_CONINDIRECTSUC, ppinOut, ppinIn);
    } else {
       Log( IDS_CONINDIRECTFAIL, ppinOut, ppinIn, hr);
    }
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+93);
    return hr;
} // ConnectRecursively



//========================================================================
//
// Connect
//
// Connect these two pins directly or indirectly, using transform filters
// if necessary.  Do not AddRef or Release() them.  The caller should
// Release() them if he's finished.  Connect() will AddRef them underneath us.
//========================================================================

bool CFilterGraph::IsValidConnectFlags( DWORD dwConnectFlags )
{
    const DWORD VALID_CONNECT_FLAGS_MASK = AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS;

    return ((VALID_CONNECT_FLAGS_MASK & dwConnectFlags) == dwConnectFlags);
}

STDMETHODIMP CFilterGraph::Connect
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    )
{
    return ConnectInternal( ppinOut,
                            ppinIn,
                            NULL, // No first connection media type.
                            0 ); // No flags.
}

HRESULT CFilterGraph::ConnectInternal
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtFirstConnection
    , DWORD dwFlags
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags) );

    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    CheckPointer(ppinOut, E_POINTER);
    CheckPointer(ppinIn, E_POINTER);

    HRESULT hr;         // return code from thing(s) we call
    if (FAILED(hr=CheckPinInGraph(ppinOut)) || FAILED(hr=CheckPinInGraph(ppinIn))) {
        return hr;
    }
    MSR_INTEGERX(mFG_idIntel, 8);
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        ++mFG_RecursionLevel;

        Log( IDS_CONNECT, ppinOut, ppinIn);
        DbgDump();
        mFG_RList.Active();
        hr = ConnectRecursively(ppinOut, ppinIn, pmtFirstConnection, dwFlags, 0);

        if (SUCCEEDED(hr)) {
            IncVersion();
            Log( IDS_CONNECTSUC, ppinOut, ppinIn);

        } else {
            Log( IDS_CONNECTFAIL, ppinOut, ppinIn, hr);
        }

        AttemptDeferredConnections();
        mFG_RList.Passive();
        ASSERT(mFG_RList.m_lListMode == 0);
        DbgLog(( LOG_TRACE, 2, TEXT("Connect Ended hr=%x")
               , hr));
        DbgDump();
        --mFG_RecursionLevel;
    }
    MSR_INTEGERX(mFG_idIntel, 18);

    NotifyChange();
    if (SUCCEEDED(hr)) {
        // including partial success
        mFG_bDirty = TRUE;
    }
    return hr;
} // Connect



//======================================================================
// Intelligent Rendering design notes
//
// This is somewhat like intelligent connection, EXCEPT
// 1. No target pin to connect to
// 2. No requirement that the plumbing connects the input stream to
//    exactly one output stream.  Instead we simply render each output stream.
//    The recursion may either return success, leaving a tree, or failure
//    in which case at some point the tree must be backed out.
// 3. When backing out a blind alley we need to back out any other
//    output pins already connected (which could be a whole tree of
//    connections).
// 4. A consequence is that the call stack cannot contain enough state
//    to control the back-out.  i.e. we may construct a chain connected to
//    output pin A of a filter F and return leaving it constructed and
//    apparently good, but only later discover that we cannot render pin B
//    of the filter and therefore need to try a new filter instead of F
//    which means backing out what we did for pin A.
//
// At every stage we have a list of what we have done (or equivalently
// what we need to do to undo it) and we keep track
// of positions in this list that we might want to back up to.
// An operation typically records the position in the list CActionList at
// the start of the operation so that it can back out everything up to there
// if the operation goes wrong.  An operation will then either succeed and
// grow the list or fail and leave the list unchanged.
// There are only two real actions:
//    Disconnect pin
//    Remove and Release filter
// We record the position to back up to (and on failure back it out)
// 1. When we try to add a connection
// 2. When we try to add a filter
// 3. When (in CompleteRendering) we add a series of branches and where
//    a failure in a later branch requires backing out the previous
//    successful ones.
// ??? It occurs to me that this system could probably be tightened up.
// ??? I think we only really need to back things out (and hence need to
// ??? record a backout position to back it out up to) when either
// ??? a. We have something else to try (in RenderViaIntermediate) or
// ??? b. The whole thing has failed (in RenderRecursively, top level).
// ??? But we will need the others if we ever improve the retry stuff
// ??? to handle convergent streams properly.  Suppose filter A has
// ??? two pins.  We render pin 1 successfully, but pin 2 has a StreamBuilder
// ??? which fails.  It wanted pin 1 to be rendered so as to introduce a
// ??? particular filter that it wants to converge onto.  At present we
// ??? do NOT go back and se if we can re-do pin 1 differently.
//
// Filters go on the list with ONE ref count (i.e. AddFilter only)
// There is no separate count for the backout list.
//
// As the search recurses along we keep track of how well we are doing.
// Whenever we get more rendered than we ever have achieved before we
// take a snapshot of the list of backout actions.  At this point we need
// to beef it up a little as the information needed to recreate something
// is actually a litle different from the information needed to undo it.
// If the filter is there, we can record a pin as an IPin*, but if the
// filter needs to be recreated we need a persistent representation of
// the pin.  If we get to the end and the best we ever did was a partial
// rendering, we recreate that.  This solves the "no sound card" problem
// and other related problems (SMPTE streams,...).
//
// The search state is
//     The current state of the graph
//         This is the CActionList which records the operations
//         needed to build the graph or equally well, the actions
//         needed to unbuild it.  For historical reasons the
//         nomnclature refers to the way to unbuild (destroy) it.
//     The point in the graph where it is growing
//         This depends on the current operation
//             Render               : <ppinOut>
//             RenderRecursively    : <ppinOut>
//             RenderViaIntermediate: <ppinOut>
//             RenderUsingFilter    : <ppinOut, F>
//             RenderByFindingPin   : <ppinOut, F>
//             CompleteRendering    : <F, pPinIn>
//     The stream value at this point
//         This is 1.0/(the number of subdivisions that the stream has had
//         upstream of here).
//         If it was split into three and then one of those into seven and
//         the growth point is one of the seven, the value would be (1.0/21.0)
//     The current (two-part) value of the graph so far.
//         The value is the total proportion of streams rendered (a fraction)
//         and the number of filters in the graph.




//========================================================================
// TakeSnapshot
// Record information needed to do a Backout back to this popsition
//========================================================================
void CFilterGraph::TakeSnapshot(CSearchState &Acts, snapshot &Snapshot)
{
    Snapshot.StreamsRendered = Acts.StreamsRendered;
    Snapshot.StreamsToRender = Acts.StreamsToRender;
    Snapshot.nFilters = Acts.nFilters;
    Snapshot.Pos = Acts.GraphList.GetTailPosition();
}  // TaksSnapshot

//========================================================================
//
// Backout
//
// Do all the actions in Acts so as to back out what has been done.
// From the end of the list back to but NOT including the item at Snapshot.Pos.
// Do them in reverse list order.  Leave Acts with Pos as the last element.
// Pos==NULL means back them all out and leave Acts empty.
// Put any filters that were in Acts into Spares.  Keep 1 ref count on each.
// As backing out a large chunk can also back out some entire successfully
// rendered streams, the StreamsRendered must also be reset - and therefore
// also the StreamsToRender.
//========================================================================
HRESULT CFilterGraph::Backout( CSearchState &Acts
                             , CSpareList &Spares
                             , snapshot Snapshot
                             )
{

    MSR_INTEGERX(mFG_idIntel, 9);
    HRESULT hr;
    HRESULT hrUs = NOERROR;  // our return code

    Acts.StreamsRendered = Snapshot.StreamsRendered;
    Acts.StreamsToRender = Snapshot.StreamsToRender;
    Acts.nFilters = Snapshot.nFilters;

    while(Acts.GraphList.GetCount()>0){
        Action *pAct;
        POSITION posTail = Acts.GraphList.GetTailPosition();
        if (posTail==Snapshot.Pos)
            break;
        pAct = Acts.GraphList.Get(posTail);
        switch(pAct->Verb){
            case DISCONNECT:
                Log( IDS_BACKOUTDISC, pAct->Object.c.ppin );

                // kill any scheduled reconnects of this connection
                mFG_RList.Purge(pAct->Object.c.ppin);
                hr = pAct->Object.c.ppin->Disconnect();
                if (FAILED(hr)) {
                   hrUs = hr;
                }
                break;
            case REMOVE:
                Log( IDS_BACKOUTREMF, pAct->Object.f.pfilter );

                // Make sure it doesn't go away.
                pAct->Object.f.pfilter->AddRef();

                // Undo AddFilter, this loses a RefCount
                hr = RemoveFilterInternal(pAct->Object.f.pfilter);
                if (FAILED(hr)) {
                   hrUs = hr;
                }

                if( pAct->FilterOriginallyCached() ) {
                    hr = m_Config.AddFilterToCache( pAct->Object.f.pfilter );

                    pAct->Object.f.pfilter->Release();
                    pAct->Object.f.pfilter = NULL;

                    if( FAILED( hr ) ) {
                        // A previously cached filter could not be added to the filter cache.
                        // This is not a fatal error but filter cache users will notice that
                        // a previously cached filter is not in the filter cache.
                        ASSERT( false );
                        hrUs = hr;                        
                    }

                } else {
                    // Keep it alive on Spares
                    Spare *psp = new Spare;
                    if (psp==NULL) {
                        // OK - don't keep it alive.  Release it and try to
                        // re-create it when we need it again.
                        pAct->Object.f.pfilter->Release();
                        pAct->Object.f.pfilter = NULL;
                    } else {
                        psp->clsid = pAct->Object.f.clsid;
                        psp->pfilter = pAct->Object.f.pfilter;
                        psp->pMon = pAct->Object.f.pMon;
                        psp->pMon->AddRef();
                        Spares.AddTail(psp);
                    }
                }

                if( NULL != pAct->Object.f.pMon ) {
                    pAct->Object.f.pMon->Release();
                    pAct->Object.f.pMon = NULL;
                }

                if ( pAct->Object.f.Name) {
                    delete[] pAct->Object.f.Name;
                    pAct->Object.f.Name = NULL;
                }

                break;
            case BACKOUT:
                Log( IDS_BACKOUTSB, pAct->Object.b.ppin);
                pAct->Object.b.pisb->Backout(pAct->Object.b.ppin, this);
                pAct->Object.b.pisb->Release();
                break;
        }
        pAct = Acts.GraphList.Remove(posTail);
        delete pAct;
    }
    MSR_INTEGERX(mFG_idIntel, 19);
    return hrUs;
} // Backout



//========================================================================
//
// DeleteBackoutList
//
// Empty the list
//========================================================================
HRESULT CFilterGraph::DeleteBackoutList( CActionList &Acts)
{
    while(Acts.GetCount()>0){
        Action * pAct;
        pAct = Acts.RemoveHead();
        if (pAct->Verb==BACKOUT) {
            pAct->Object.b.pisb->Release();
        } else if (pAct->Verb==REMOVE) {
            if (pAct->Object.f.pMon) {
                pAct->Object.f.pMon->Release();
            }
            if (pAct->Object.f.Name) {
                delete[] pAct->Object.f.Name;
            }
        }
        delete pAct;
    }
    return NOERROR;
} // DeleteBackoutList



//========================================================================
//
// GetFilterFromSpares
//
// IF the Spares list contains a filter for clsid then delete it from the
// list and return a pointer to its IBaseFilter interface with 1 ref count
// else leave the list alone and return NULL.
//========================================================================
IBaseFilter * CFilterGraph::GetFilterFromSpares
    ( IMoniker *pMon
    , CSpareList &Spares
    )
{
    Spare * psp;
    POSITION pos;
    MSR_INTEGERX(mFG_idIntel, 1001);
    pos = Spares.GetHeadPosition();
    for (; ; ) {
        POSITION pDel = pos;            // in case we need to delete this one
        psp = Spares.GetNext(pos);      // pos is side-effected to next
        if (psp==NULL)
            break;
        if (psp->pMon == pMon ||
            psp->pMon->IsEqual(pMon) == S_OK)
        {
            psp = Spares.Remove(pDel);
            IBaseFilter * pif;
            pif = psp->pfilter;
            psp->pMon->Release();
            delete psp;
            MSR_INTEGERX(mFG_idIntel, 1002);
            return pif;
        }
    }
    MSR_INTEGERX(mFG_idIntel, 1003);
    return NULL;
} // GetFilterFromSpares



//========================================================================
//
// GetFilter
//
// IF the Spares list contains a filter for clsid then delete it from the
// list and return a pointer to its IBaseFilter interface with 1 ref count
// else instantiate the filter and return its IBaseFilter * with 1 ref count.
//========================================================================
HRESULT CFilterGraph::GetFilter
    ( IMoniker *pMon
    , CSpareList &Spares
    , IBaseFilter **ppf
    )
{
    HRESULT hr = NOERROR;
    *ppf = GetFilterFromSpares(pMon, Spares);
    if (*ppf==NULL){
        MSR_INTEGERX(mFG_idIntel, 1004);

        hr = CreateFilterAndNotify(pMon, ppf);

        MSR_INTEGERX(mFG_idIntel, 1005);
    }

    return hr;
} // GetFilter


// Put the filters which are already in the graph into the
// action list as REMOVE entries.
// Because all backup actions are given a specified
// point to back up to, we will never back out these initial entries,
// we will simply discard them once we have finished rendering.
// We will never instantiate these filters from this list either,
// so we don't ned a CLSID, so the CLSID will be recorded as NULL.
// They already have names in the graph, so we don't need those either.
HRESULT CFilterGraph::InitialiseSearchState(CSearchState &css)
{
    // Traverse all the filters in the graph
    POSITION Pos = mFG_FilGenList.GetHeadPosition();
    while(Pos!=NULL) {
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        FilGen * pfg = mFG_FilGenList.GetNext(Pos);

        // Add this filter into the action list
        Action * pAct = new Action;
        if (pAct==NULL) {
            // We're screwed
            return E_OUTOFMEMORY;
        }
        pAct->Verb = REMOVE;
        pAct->Object.f.Name = NULL;
        pAct->Object.f.pfilter = pfg->pFilter;
        pAct->Object.f.clsid = CLSID_NULL;
        pAct->Object.f.pMon = 0;
        pAct->Object.f.fOriginallyInFilterCache = false;
        css.GraphList.AddTail(pAct);
        ++css.nInitialFilters;
    }
    return NOERROR;
}



// find pf in cal, return the position 0 = first in list.
// -1 means not in the list.
int CFilterGraph::SearchIFilterToNumber(CActionList &cal, IBaseFilter *pf)
{
    POSITION pos;
    Action *pA;
    int n = 0;
    pos = cal.GetHeadPosition();
    while (pos!=NULL) {
        pA = cal.GetNext(pos);
        if (pA->Verb==REMOVE && pA->Object.f.pfilter==pf)
            return n;
        ++n;
    }
    // ASSERT(!"Failed to find filter in Actions List");
    // This happens when we encounter the source filter with the original
    // pin we were trying to render.
    return -1;
} // SearchIFilterToNumber

// Get the nth element of the list.  0 is the first
IBaseFilter * CFilterGraph::SearchNumberToIFilter(CActionList &cal, int nFilter)
{

    DbgLog(( LOG_TRACE, 3, TEXT("SearchNumber %d ToIFilter "), nFilter));
    POSITION pos;
    pos = cal.GetHeadPosition();
    Action *pA = NULL;
    while (nFilter>=0) {
        pA = cal.GetNext(pos);
        --nFilter;
    }
    ASSERT(pA!=NULL);
    ASSERT(pA->Verb==REMOVE);
    return pA->Object.f.pfilter;
} // SearchNumberToIFilter


//========================================================================
//
// DeleteSpareList
//
// Release all the filters on the list and delete the elements of the list too.
// Must do this on the application thread so that DestroyWindow() will
// work for any windows the filters created
//========================================================================
HRESULT CFilterGraph::DeleteSpareList( CSpareList &Spares)
{
    if (S_OK == CFilterGraph::IsMainThread()) {
        while (0<Spares.GetCount()) {
            Spare * ps;
            ps = Spares.RemoveHead();
            ps->pfilter->Release();
            ps->pMon->Release();
            delete ps;
        }
    } else {
        SendMessage(m_hwnd,
                    AWM_DELETESPARELIST,
                    (WPARAM)&Spares,
                    (LPARAM)0
                   );
    }
    return NOERROR;
} // DeleteSpareList


// Free up everything and delete the list
void CFilterGraph::FreeList(CSearchState &css)
{
    POSITION pos;
    pos = css.GraphList.GetHeadPosition();
    while (pos!=NULL) {
        Action *pA;
        POSITION posRemember = pos;
        pA = css.GraphList.GetNext(pos);   // pA gets the data, pos is side-efected to next
        if (pA->Verb==DISCONNECT) {
            if (pA->Object.c.id1 !=NULL) QzTaskMemFree(pA->Object.c.id1);
            if (pA->Object.c.id2 !=NULL) QzTaskMemFree(pA->Object.c.id2);
        } else if (pA->Verb==BACKOUT) {
            if (!pA->Object.b.bFoundByQI) {
                pA->Object.b.pisb->Release();
            }
        } else {  // REMOVE
            if (pA->Object.f.pMon) {
                pA->Object.f.pMon->Release();
            }
            if (pA->Object.f.Name) {
                delete[] pA->Object.f.Name;
            }
        }
        delete pA;
        css.GraphList.Remove(posRemember);
    }
} // FreeList



// Copy the score and copy the action list by doing a minimal update.
// Scan through the action list we already have (To) and see what
// initial portion is already the same.  Delete and free the
// rest that we already have.  Copy the rest of From and find
// the persistent ids of everything.
// ppinOrig is the original pin that we were rendering.
// The SearchState may contain connections to it which are held as -1.
void CFilterGraph::CopySearchState(CSearchState &To, CSearchState &From)
{

    BOOL bFailed = FALSE;
    MSR_INTEGERX(mFG_idIntel, 1006);
    DbgLog(( LOG_TRACE, 3
           , TEXT("Copy search state... ToCount=%d FromCount=%d nFilters=%d, rendered=%g")
           , To.GraphList.GetCount()
           , From.GraphList.GetCount()
           , From.nFilters
           , From.StreamsRendered
           ));
    To.StreamsToRender = -1.0;                   // hygeine.
    To.StreamsRendered = From.StreamsRendered;
    To.nFilters = From.nFilters;
    To.nInitialFilters = From.nInitialFilters;

    POSITION posF;
    POSITION posT;

    //.................................................................
    // Look for a prefix portion that's unchanged
    // set posF and posT to the first non-matching positions.
    //.................................................................

    posF = From.GraphList.GetHeadPosition();
    posT = To.GraphList.GetHeadPosition();
    for (; ; ) {
        DbgLog(( LOG_TRACE, 3, TEXT("Looking at elements for==?")));
        if (posF==NULL || posT==NULL) break;
        Action *pF = From.GraphList.Get(posF);
        Action *pT = To.GraphList.Get(posT);

        if (pF->Verb!=pT->Verb) break;
        if (pF->Verb==REMOVE) {
            DbgLog(( LOG_TRACE, 3, TEXT("To Clsid: %8x %x %x")
                   , pT->Object.f.clsid.Data1
                   , pT->Object.f.clsid.Data2
                   , pT->Object.f.clsid.Data3
                  ));
            DbgLog(( LOG_TRACE, 3, TEXT("From Clsid: %8x %x %x")
                   , pF->Object.f.clsid.Data1
                   , pF->Object.f.clsid.Data2
                   , pF->Object.f.clsid.Data3
                  ));
            if (pF->Object.f.pfilter!=pT->Object.f.pfilter) break;
            ASSERT(pF->Object.f.pfilter!=NULL);
        }
        else if (pF->Verb==DISCONNECT){

            break;

            // The alternative is to actually check that the filter has
            // the same pins as recorded and that they are connected to
            // the same other pins on the same filter.  Starts getting messy.
            // Maybe remove this whole lot and just rebuild the list from scratch???

//             DbgLog(( LOG_TRACE, 2, TEXT("DISCONNECT entry")));
//             if (pF->Object.c.ppin!=pT->Object.c.ppin) break;
        }
        else { // Verb==BACKOUT

            break;

            // The alternative is to actually check.
            // Maybe remove this whole lot and just rebuild the list from scratch???

//             DbgLog(( LOG_TRACE, 2, TEXT("Backout entry")));
//             if (pF->Object.c.ppin!=pT->Object.c.ppin) break;
        }
        posF = From.GraphList.Next(posF);
        posT = To.GraphList.Next(posT);
    }

    // posF and posT are the first non-matching positions
    // either or both can be null

    //.................................................................
    // free up everything left on the end of To
    //.................................................................
    while (posT!=NULL) {
        DbgLog(( LOG_TRACE, 3, TEXT("Freeing end of To list")));
        POSITION posRemember = posT;
        Action * pT;
        pT = To.GraphList.GetNext(posT);   // pT gets the data, posT is side-efected to next
        if (pT->Verb==DISCONNECT) {
            if (pT->Object.c.id1 !=NULL) QzTaskMemFree(pT->Object.c.id1);
            if (pT->Object.c.id2 !=NULL) QzTaskMemFree(pT->Object.c.id2);
        } else if (pT->Verb==REMOVE) {
            if( NULL != pT->Object.f.pMon ) {
                pT->Object.f.pMon->Release();
            }
            if (pT->Object.f.Name !=NULL) delete[] pT->Object.f.Name;
        } else if (pT->Verb==BACKOUT) {
            if (!pT->Object.b.bFoundByQI) {
                pT->Object.b.pisb->Release();
            }
        }
        delete pT;
        To.GraphList.Remove(posRemember);
    }

    //.................................................................
    // Copy everything left on From to the end of To
    //.................................................................
    while (posF!=NULL) {
        Action * pF;
        pF = From.GraphList.GetNext(posF);   // pF gets the data, posF is side-efected to next
        Action *pA = new Action;
        if (pA==NULL) {
            bFailed = TRUE;
            break;
        }

        pA->Verb = pF->Verb;
        // Only the id might need marshalling, but it's not used in pF
        if (pF->Verb==DISCONNECT) {

            DbgLog(( LOG_TRACE, 3, TEXT("Copying DISCONNECT")));
            pA->Object.c = pF->Object.c;    // copy unmarshalled fields
            // Get external ids for the pins
            HRESULT hr = pA->Object.c.ppin->QueryId(&(pA->Object.c.id1));
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }
            IPin * pip;
            hr = pA->Object.c.ppin->ConnectedTo(&pip);
            if (FAILED(hr) || pip==NULL) {
                bFailed = TRUE;
                break;
            }
            hr = pip->QueryId(&(pA->Object.c.id2));
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            // Get external ids (well, numbers) for the filters
            PIN_INFO pi;
            hr = pA->Object.c.ppin->QueryPinInfo(&pi);
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            pA->Object.c.nFilter1 = SearchIFilterToNumber(To.GraphList, pi.pFilter);
            QueryPinInfoReleaseFilter(pi);
            hr = pip->QueryPinInfo(&pi);
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            pA->Object.c.nFilter2 = SearchIFilterToNumber(To.GraphList, pi.pFilter);
            QueryPinInfoReleaseFilter(pi);
            pip->Release();
            DbgLog(( LOG_TRACE, 4, TEXT("Copying DISCONNECT (%x %d,%ls)-(%d,%ls)")
                   , pA->Object.c.ppin
                   , pA->Object.c.nFilter1
                   , pA->Object.c.id1
                   , pA->Object.c.nFilter2
                   , pA->Object.c.id2
                  ));
        } else if (pF->Verb==REMOVE){
            IPersist * pip;
            pA->Object.f = pF->Object.f;    // copy unmarshalled fields

            pA->Object.f.fOriginallyInFilterCache = pF->FilterOriginallyCached();

            if(pA->Object.f.pMon)
              pA->Object.f.pMon->AddRef();
            pA->Object.f.pfilter->QueryInterface(IID_IPersist, (void**)&pip);
            if (pip) {
                pip->GetClassID(&(pA->Object.f.clsid));
                pip->Release();
                DbgLog(( LOG_TRACE, 4, TEXT("Copying REMOVE Clsid: %8x %x %x")
                       , pA->Object.f.clsid.Data1
                       , pA->Object.f.clsid.Data2
                       , pA->Object.f.clsid.Data3
                      ));
            } else {
                pA->Object.f.clsid = CLSID_NULL;  // hope we never need it!
                DbgLog(( LOG_TRACE, 4, TEXT("Copying REMOVE- but CAN'T GET CLSID!!!")));
            }
            if (pF->Object.f.Name!=NULL) {
                pA->Object.f.Name = new WCHAR[ 1+lstrlenW(pF->Object.f.Name) ];
                if (pA->Object.f.Name!=NULL) {
                    lstrcpyW(pA->Object.f.Name, pF->Object.f.Name);
                }
                // else the name just gets lost as though it didn't have one
            }
        } else {  // BACKOUT
            DbgLog(( LOG_TRACE, 3, TEXT("Copying BACKOUT")));
            pA->Object.b = pF->Object.b;    // copy unmarshalled fields
            // Get external id for the pin
            HRESULT hr = pA->Object.b.ppin->QueryId(&(pA->Object.b.id));
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            // Get external id (well, number) for the filter
            PIN_INFO pi;
            hr = pA->Object.b.ppin->QueryPinInfo(&pi);
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            pA->Object.b.nFilter = SearchIFilterToNumber(To.GraphList, pi.pFilter);
            QueryPinInfoReleaseFilter(pi);

            if (!pA->Object.b.bFoundByQI) {
                pA->Object.b.pisb->AddRef();  // This one is still live
            }

            DbgLog(( LOG_TRACE, 4, TEXT("Copying BACKOUT (%x %d,%ls)")
                   , pA->Object.b.ppin
                   , pA->Object.b.nFilter
                   , pA->Object.b.id
                  ));

        }
        To.GraphList.AddTail(pA);
    }
    MSR_INTEGERX(mFG_idIntel, 1007);
    if (bFailed) {
        To.StreamsRendered = -1;   // messed up!!!
    }

} // CopySearchState

HRESULT CFilterGraph::DumpSearchState(CSearchState &css)
{
#ifndef DEBUG
    return NOERROR;
#else
    DbgLog(( LOG_TRACE, 3, TEXT("Start of search state dump")));
    HRESULT hr = NOERROR;
    POSITION pos = css.GraphList.GetHeadPosition();
    while (pos!=NULL) {
        Action *pA = css.GraphList.GetNext(pos);

        if (pA->Verb == REMOVE) { 
            DbgLog(( LOG_TRACE, 3
                   , "REMOVE pf %x (Clsid: %08x...)  Originally In Filter Cache: %d"
                   , pA->Object.f.pfilter
                   , pA->Object.f.clsid.Data1
                   , pA->FilterOriginallyCached()
                  ));

        } else if (pA->Verb == DISCONNECT) { 
            DbgLog(( LOG_TRACE, 3
                   , "DISCONNECT (%d,%ls)-(%d,%ls)"
                   , pA->Object.c.nFilter1
                   , pA->Object.c.id1
                   , pA->Object.c.nFilter2
                   , pA->Object.c.id2
                  ));

        } else { 
            DbgLog(( LOG_TRACE, 3
                   , "BACKOUT (%d,%ls) pisb=0x%x ppin=0x%x bFoundByQI=%d)"
                   , pA->Object.b.nFilter
                   , pA->Object.b.id
                   , pA->Object.b.pisb
                   , pA->Object.b.ppin
                   , pA->Object.b.bFoundByQI
                  ));

        }
    }

    DbgLog(( LOG_TRACE, 3, TEXT("End of search state dump")));

    return hr;
#endif
} // DumpSearchState


//========================================================================
// BuildFromSearchState
//
// Create a new filtergraph
// from css.  (This should have been almost the same code as for Restore,
// and maybe it should be altered to be that way.  That would mean beating
// a path away from the current format of the stored filtergraphs.
//
// Does NOT clear the list out.
//
//========================================================================
HRESULT CFilterGraph::BuildFromSearchState( IPin * pPin
                                          , CSearchState &css
                                          , CSpareList &Spares
                                          )
{
    // The action list is the list of things to undo the graph at the
    // point when it was the best we ever saw.  These are also the
    // actions (well inverse-actions - when it says DISCONNECT we must
    // CONNECT) needed to rebuild it.
    Log( IDS_RENDPART );
    Log( IDS_BESTCANDO );

    DumpSearchState(css);

    if (css.StreamsRendered<=0.000001) {  // probably 0.0 is exact, but...
        return E_FAIL;           // This is a messed up state.
    }


    HRESULT hr = NOERROR;
    POSITION pos = css.GraphList.GetHeadPosition();
    int nActions = 0;
    while (pos!=NULL) {
        if (mFG_bAborting) {
           hr = E_ABORT;
           break;  // Nothing to tidy up here as we do not clear the list anyway
        }
        Action *pA = css.GraphList.GetNext(pos);

        // The action list begins with pre-existers (if any)
        ++nActions;
        if (nActions<=css.nInitialFilters) {
            continue;
        }

        if (pA->Verb == REMOVE) { // meaning that we UN-REMOVE it
            Log( IDS_ADDINGF, pA->Object.f.clsid.Data1);

            if( pA->FilterOriginallyCached() ) {
                hr = m_Config.RemoveFilterFromCache( pA->Object.f.pfilter );
            
                // IGraphConfig::RemoveFilterFromCache() returns S_OK if the filter
                // was successfully removed from the filter cache.
                if( S_OK != hr ) {
                    // This should almost never occur because
                    // 1. Cached filters can only be placed on the the GraphList list once.
                    // 2. Cached filters are placed back in the cache if a Render() operation
                    //    fails.
                    // 
                    // This ASSERT may fire if a cached filter could not be successfully placed
                    // back in the filter cache.  However, it's unlikely this will occur.
                    ASSERT( false );
                    return E_UNEXPECTED;
                }
            
            } else {
                IBaseFilter * pf;

                hr = GetFilter( pA->Object.f.pMon, Spares, &pf);
                if (FAILED(hr)) {
                    // ??? Back out everything!
                    Log( IDS_GETFFAIL, hr);
                    return hr;
                }
                pA->Object.f.pfilter = pf;

                // The list now contains the real IBaseFilter*, as opposed to some
                // IBaseFilter* that may have been reused elsewhere and hence be
                // totally bogus.  We can now retrieve this by position in
                // the list and use it in connecting filters up.
            }

            // If AddFilterInternal AddRefs the filter if it is successful.
            hr = AddFilterInternal(pA->Object.f.pfilter, pA->Object.f.Name, true);

            pA->Object.f.pfilter->Release();

            if (FAILED(hr)) {
                Log( IDS_ADDFFAIL );
                // ??? Back out everything!?
                return hr;
            }

            Log( IDS_ADDFSUC, pA->Object.f.pfilter);

        } else if (pA->Verb == DISCONNECT) { // meaning that we will UN-DISCONNECT it

            Log( IDS_CONNING );
            IPin *ppin1;
            IBaseFilter * pf1;
            if (pA->Object.c.nFilter1 == -1) {
                ppin1 = pPin;          // the original pin.
                Log( IDS_ORIGINALP, ppin1);
            } else {
                pf1 = SearchNumberToIFilter
                                    (css.GraphList, pA->Object.c.nFilter1);
                Log( IDS_FOUNDF1, pf1);
                ASSERT(pf1!=NULL);
                hr = pf1->FindPin(pA->Object.c.id1, &ppin1);
                Log( IDS_FOUNDP1, ppin1);
                if(FAILED(hr)) {
                    // occurs if pin config. changes on reconnect
                    DbgLog((LOG_TRACE, 1, TEXT("backout DISCONNECT: FindPin failed.")));
                    return E_FAIL;
                }
                ASSERT(ppin1!=NULL);
            }

            IBaseFilter * pf2 = SearchNumberToIFilter
                                (css.GraphList, pA->Object.c.nFilter2);
            Log( IDS_FOUNDF2, pf2);

            ASSERT(pf2!=NULL);
            // By now these IBaseFilter*s are guaranteed to be non-bogus!

            IPin *ppin2;
            hr = pf2->FindPin(pA->Object.c.id2, &ppin2);
            if(FAILED(hr)) {
                // occurs if pin config. changes on reconnect
                DbgLog((LOG_TRACE, 1, TEXT("backout DISCONNECT: FindPin failed.")));
                ppin1->Release();
                return E_FAIL;
            }            

            ASSERT(ppin2!=NULL);
            Log( IDS_FOUNDP2, ppin2);

            // No need to check for circularity as we have been here before.
            hr = ConnectDirectInternal(ppin1, ppin2, NULL);

            // We're done with the pins that we found.
            ppin1->Release();
            ppin2->Release();

            // but did the connect work?
            if (FAILED(hr)) {
                // ??? Back out everything!
                Log( IDS_CONNFAIL, hr);
                return hr;
            }

            // DISCONNECTs always come in pairs to disconnect both ends
            // so skip the other end.
            // DbgLog(( LOG_TRACE, 2, TEXT("Skipping DISCONNECT")));
            pA = css.GraphList.GetNext(pos);
            ASSERT(pA->Verb==DISCONNECT);

        } else { // BACKOUT - meaning call stream builder again

            Log( IDS_STREAMBUILDING );
            IPin *ppin;
            IBaseFilter * pf;
            if (pA->Object.b.nFilter == -1) {
                ppin = pPin;          // the original pin.
                Log( IDS_ORIGINALP, ppin);
            } else {
                pf = SearchNumberToIFilter
                                    (css.GraphList, pA->Object.b.nFilter);
                Log( IDS_FOUNDF, pf);
                ASSERT(pf!=NULL);
                hr = pf->FindPin(pA->Object.b.id, &ppin);
                Log( IDS_FOUNDP, ppin);
                if(FAILED(hr)) {
                    // occurs if pin config. changes on reconnect
                    DbgLog((LOG_TRACE, 1, TEXT("backout IStreamBuilder: FindPin failed.")));
                    return E_FAIL;
                }            
                ASSERT(ppin!=NULL);
            }

            IStreamBuilder * pisb;
            if (pA->Object.b.bFoundByQI) {
                ppin->QueryInterface(IID_IStreamBuilder, (void**)&pisb);
            } else {
                // if it was found by CoCreateInstance then it is still valid.
                pisb = pA->Object.b.pisb;
            }

            mFG_ppinRender = ppin;
            hr = pisb->Render(ppin, this);
            mFG_ppinRender = NULL;

            // Balance our actions.  Release what we got in this routine.
            if (pA->Object.b.bFoundByQI) {
                pisb->Release();
            }

            // We're done with the pins that we found.
            ppin->Release();

            // but did the Render work?
            if (FAILED(hr)) {
                // ??? Back out everything!
                Log( IDS_SBFAIL, hr);
                return hr;           // we are in a mess!
            }
        }
        DbgLog(( LOG_TRACE, 3, TEXT("Done one [more] step of building best-can-do graph!")));

    }

    Log( IDS_BESTCANDONE );


    return hr;

} // BuildFromSearchState



//========================================================================
//
// CompleteRendering
//
// trace the input from pPin through F and render all the output streams
// F is loaded in the filtergraph.  Its input is connected
// Acts is left unchanged if it FAILs, may grow if it succeeds.
// (If the stream is rendered by this filter, it won't grow).
//========================================================================
HRESULT CFilterGraph::CompleteRendering
    ( IBaseFilter *pF            // the intermed filter (acts as cursor for filter enum)
    , IPin * pPin         // a connected input pin of F
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts   // how to back out what we have done
    , CSpareList &Spares  // spare filters that were loaded and backed out
    , CSearchState &Best // The score, and how to rebuild it.
    )
{
    // We need to try all the pins as some of them (Murphy's law says not the
    // first) may succeed, giving a partially successful graph that might be
    // the best so far.  After a failure below us, what failed will already be
    // backed out, but we need to record the partial failure and backout all
    // the bits that succeeded at the end and return a failure code.

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+7);
    HRESULT hr;         // return code from thing(s) we call

    snapshot Snap;      // Backout to here if we fail;
    TakeSnapshot(Acts, Snap);

    IPin * apPinStack[C_PINSONSTACK];
    IPin **apPin = apPinStack;
    int nOutPins;        // the score for this stream is divided by this number.
    BOOL bSomethingFailed = FALSE;

    Log( IDS_RENDSEARCHOUTP, pF);

    int nPin;
    hr = FindOutputPinsHelper( pPin, &apPin, C_PINSONSTACK, nPin, false );
    if (FAILED(hr)) {
        Log( IDS_RENDQISFAIL, pF);
        return hr;  // hr from QueryinternalStreams attempt
    }
    CDelRgPins rgPins(apPin == apPinStack ? 0 : apPin);

    // apPin[0..nPin-1] are addreffed output pins.

    {
        int iPin;


        nOutPins = nPin;
        if (nOutPins>0) {

            // return the most specific error we get from any stream
            HRESULT hrSpecific = VFW_E_CANNOT_RENDER;

            // We subdivide the stream for score-keeping.
            double StreamsToRender = Acts.StreamsToRender;
            Acts.StreamsToRender /= nOutPins;

            for (iPin = 0; iPin<nPin; ++iPin) {

                IPin *p = apPin[iPin];
                if (mFG_bAborting) {
                    hr = hrSpecific = E_ABORT;
                    p->Release();
                    continue;      // to release the other pins
                }
                IPin * pConTo;
                p->ConnectedTo(&pConTo);
                if (pConTo!=NULL) {
                    pConTo->Release();
                    // Assume that the pin is connected already to something
                    // that renders it.  This is a quick and dirty hack.
                    // The real solution is to trace the flow to the death
                    // and try to render all spare pins.
                    Acts.StreamsRendered += Acts.StreamsToRender;
                } else {
                    Log( IDS_RENDOUTP, p, pF);
                    hr = RenderRecursively(p, iRecurse, Acts, Spares, Best);

                    if (FAILED(hr)) {
                        bSomethingFailed = TRUE;
                        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+27);
                        // we don't return hr any more - we see if we cab
                        // render any of the other streams
                        Log( IDS_RENDOUTPFAIL, p, pF);

                        if ((VFW_E_CANNOT_CONNECT != hr) &&
                            (VFW_E_CANNOT_RENDER != hr))
                        {
                            hrSpecific = hr;
                        }

                    } else {
                        Log( IDS_RENDOUTPSUC, p, pF);
                    }
                }
                p->Release();
            }

            // Chances are this is could be a new high water mark.
            if ((!mFG_bAborting) && CSearchState::IsBetter(Acts, Best)) {
                CopySearchState(Best, Acts);
            }
            if (mFG_bAborting) {
                hr = hrSpecific = E_ABORT;
                bSomethingFailed = TRUE;
            }


            // reinstate original slice size as we emerge from the slicing
            Acts.StreamsToRender = StreamsToRender;

            if (bSomethingFailed) {
                Log( IDS_RENDOUTPPART, pF);
                Backout(Acts, Spares, Snap);
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+27);
                return hrSpecific;
            }

        } else {
            // no outputs => all rendered.
            Log( IDS_RENDNOOUT, pF);
            Acts.StreamsRendered += Acts.StreamsToRender;

            // Chances are this is a new high water mark.
            if (CSearchState::IsBetter(Acts, Best)) {
                CopySearchState(Best, Acts);
            }
        }

    }

    // At this point Acts has the full list of all the actions needed
    // to back out the full rendering of every pin.
    // Every time we +=d StreamsRendered we checked if we should
    // update Best, so Best is now up to date too.

    DbgLog((LOG_TRACE, 4, TEXT("End of CompleteRendering")));
    DumpSearchState(Best);

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+17);
    return NOERROR;

} // CompleteRendering



//========================================================================
//
// RenderByFindingPin
//
// Render ppinOut by using F as an intermediate filter, finding an input pin
// on it, connecting to it and following the stream through, rendering the output
// given that F is loaded and in the filter graph
// On failure, Acts will be restored to the way it was on entry.
// On success, Acts will have grown.
//========================================================================
HRESULT CFilterGraph::RenderByFindingPin
    ( IPin * ppinOut      // the output pin
    , IBaseFilter *pF     // the intermed filter (acts as cursor for filter enum)
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts   // how to back out what we have done
    , CSpareList &Spares  // Filters that were loaded then backed out
    , CSearchState &Best // The score, and how to rebuild it.
    )
{
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+6);
    HRESULT hr;         // return code from thing(s) we call
    Log( IDS_RENDSEARCHINP, pF, ppinOut);

    snapshot Snap;      // Backout to here if we fail;
    TakeSnapshot(Acts, Snap);

    CEnumPin Next(pF, CEnumPin::PINDIR_INPUT, TRUE);        // input pins
    IPin *pPin;

    // try to remember a specific error code if one appears
    HRESULT hrSpecific = VFW_E_CANNOT_RENDER;

    // search F to find an input pin to try
    while ( (LPVOID) (pPin = Next()) ) {

        if (mFG_bAborting) {
            pPin->Release();
            hr = hrSpecific = E_ABORT;
            break;
        }
        Log( IDS_RENDTRYP, ppinOut, pPin, pF);

        IPin *pConnected;
        hr = pPin->ConnectedTo(&pConnected);
        if (FAILED(hr) || pConnected==NULL) {       // don't try if already connected

            // Connect to the input pin we have found
            hr = ConnectDirectInternal(ppinOut, pPin, NULL);  // no version count

            if (SUCCEEDED(hr)) {
                Log( IDS_RENDCONNED, ppinOut, pPin, pF );

                // to back out a connect, disconnect both ends
                // we will need to backout upstream so add output pin first
                // (Backout reads the list backwards)
                Action * pAct1 = new Action;
                Action * pAct2 = new Action;
                // both or neither!
                if (pAct1==NULL || pAct2==NULL) {
                    pPin->Release();
                    if (pAct1!=NULL) delete pAct1;
                    if (pAct2!=NULL) delete pAct2;
                    return E_OUTOFMEMORY;
                }

                pAct1->Verb = DISCONNECT;
                pAct1->Object.c.ppin = ppinOut;
                Acts.GraphList.AddTail(pAct1);

                pAct2->Verb = DISCONNECT;        // subroutine???
                pAct2->Object.c.ppin = pPin;
                Acts.GraphList.AddTail(pAct2);

                hr = CompleteRendering(pF, pPin, iRecurse, Acts, Spares, Best);
                if (FAILED(hr)) {
                    Log( IDS_BACKOUTLEV, iRecurse );

                    Backout(Acts, Spares, Snap);

                    // remember this error code if specific
                    if ((VFW_E_CANNOT_CONNECT != hr) &&
                        (VFW_E_CANNOT_RENDER != hr)) {
                            hrSpecific = hr;
                    }
                } else {
                    pPin->Release();
                    DbgLog((LOG_TRACE, 4, TEXT("Released F  pin %x"), pPin));
                    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+16);
                    return NOERROR;
                }
            } else if (IsAbandonCode(hr)) {
                // no point in trying heroics if we're being asked to render a
                // stream on a filter whose input is dangling and so who won't
                // connect at all in this state.
                Log( IDS_RENDCONFAIL, ppinOut, pPin, pF);
                Log( IDS_RENDNOTCON, ppinOut );
                pPin->Release();
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+26);
                return hr;
            } else {
                Log ( IDS_RENDPINCONFAIL, ppinOut, pPin, pF);

                // remember this error if 'interesting'
                if ((hr != E_FAIL) &&
                    (hr != E_INVALIDARG)) {
                        hrSpecific = hr;
                }
            }
        } else {
            Log( IDS_RENDPINCON, pPin );
            pConnected->Release();
        }
        pPin->Release();
    }

    Log( IDS_RENDNOPIN, pF);

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+36);
    return hrSpecific;

} // RenderByFindingPin



//========================================================================
//
// RenderUsing
//
// Render ppinOut using F as an intermediate filter
//========================================================================
HRESULT CFilterGraph::RenderUsingFilter
    ( IPin * ppinOut      // the output pin
    , Filter& F            // the intermed filter (acts as cursor for filter enum)
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts  // how to back out what we have done
    , CSpareList &Spares  // Any filters that were loaded but backed out
    , CSearchState &Best  // The score, and how to rebuild it.
    )
{
    // CFilterGraph::RenderUsingFilter() expects the proposed filter (F) to be in the
    // F_LOADED state (F is in the filter graph), the F_CACHED state (F is in the filter cache) or
    // the F_REGISTRY state (F has been found in the registry but it has not been created).
    ASSERT( (F_LOADED == F.State) || (F_CACHED == F.State) || (F_REGISTRY == F.State) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+5);
    HRESULT hr;         // return code from thing(s) we call
    DbgLog(( LOG_TRACE, 3, TEXT("RenderUsingFilter output pin %x on filter (%d %x %x) level %d")
           , ppinOut,  F.State, F.pf, DbgExpensiveGetClsid(F).Data1, iRecurse ));

    WCHAR szDisplayName[MAX_PATH];
    LoggingGetDisplayName(szDisplayName, F.pMon);

    if( (F_REGISTRY == F.State) || (F_CACHED == F.State) ) {
    
        snapshot Snap;      // Backout to here if we fail;
        TakeSnapshot(Acts, Snap);

        Log( IDS_RENDTRYNEWF, szDisplayName );
        
        switch( F.State ) {
        case F_REGISTRY:

            // When the filter graph manager is searching the registry,
            // filter's loaded in GetFilter().  F.pf should be 
            // NULL because GetFilter() has not been called.
            ASSERT( NULL == F.pf );

            hr = GetFilter(F.pMon, Spares, &(F.pf));
            if (F.pf==NULL){
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+25);
                Log( IDS_RENDLOADFAIL, szDisplayName);
                return hr;
            }

            ASSERT( NULL != F.Name );
            break;
        
        case F_CACHED:
            F.RemoveFromCache( &m_Config );
            break;

        default:
            // This code should never be executed because this case 
            // was not considered.
            ASSERT( false );
            return E_UNEXPECTED;
        }

        MSR_INTEGERX(mFG_idIntel, 1008);
        hr = AddFilterInternal(F.pf, F.Name, true);   // no version count
        MSR_INTEGERX(mFG_idIntel, 1009);
        if (hr==VFW_E_DUPLICATE_NAME) {
             // This is getting out of hand.  This is expected to be an unusual case.
             // The obvious thing to do is just to add something like _1 to the end
             // of the name - but F.Name doesn't have room on the end - and where
             // do we draw the line?  On the other hand people really could want
             // filter graphs with 50 effects filters in them...?
             hr = AddFilterInternal(F.pf, NULL, true);
             MSR_INTEGERX(mFG_idIntel, 1010);
        }

        // If AddFilter SUCCEEDED then that got rid of the QzCreate... count.
        if (FAILED(hr)) {

            if( F_CACHED == F.State ) {
                // If this ASSERT fires, then a previously cached filter could not
                // be added back into the filter cache.  While this is not a fatal
                // error, users will notice that a previously cached filter
                // is no longer in the filter cache.
                EXECUTE_ASSERT( SUCCEEDED( F.AddToCache( &m_Config ) ) );
            }

            // If AddFilter FAILED then it did NOT addref it, so that deleted it.
            // Such a filter is apparently imnpossible to Add to the filter graph.
            // It's sick!  That's why we do NOT add it to Spares.
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+35);
            Log( IDS_RENDADDFAIL, szDisplayName, hr);
            return hr;
        }

        // It now has one RefCount (from AddFilter)

        Log( IDS_RENDERADDEDF, szDisplayName, F.pf, F.Name);

        hr = AddRemoveActionToList( &Acts, &F );
        if( FAILED(hr) ) {
            // If this ASSERT fires, an extra filter will be left in the 
            // filter graph.  
            EXECUTE_ASSERT( SUCCEEDED( RemoveFilterInternal( F.pf ) ) );

            if( F_CACHED == F.State ) {
                // If this ASSERT fires, then a previously cached filter could not
                // be added back into the filter cache.  While this is not a fatal
                // error, users will notice that a previously cached filter
                // is no longer in the filter cache.
                EXECUTE_ASSERT( SUCCEEDED( F.AddToCache( &m_Config ) ) );
            }

            return hr;            
        }

        hr = RenderByFindingPin(ppinOut, F.pf, iRecurse, Acts, Spares, Best);
        if (FAILED(hr)) {
            Backout(Acts, Spares, Snap);
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+55);
            return hr;
        } 

    } else if( F_LOADED == F.State ) {

        Log( IDS_RENDTRYF, F.pf);
        hr = RenderByFindingPin(ppinOut, F.pf, iRecurse, Acts, Spares, Best);
        if (FAILED(hr)) {
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+65);
            return hr;
        }
    } else {

        // This state was not expected.  This code should never be executed.
        ASSERT( false );
        return E_UNEXPECTED;
    }

    DbgLog((LOG_TRACE, 4, TEXT("End of RenderUsing...")));
    DumpSearchState(Best);

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+15);
    return NOERROR;

} // RenderUsingFilter

HRESULT CFilterGraph::AddRemoveActionToList( CSearchState* pActionsList, Filter* pFilter )
{
    Action * pNewRemoveAction = new Action;
    if( NULL == pNewRemoveAction) {
        return E_OUTOFMEMORY;
    }

    pNewRemoveAction->Verb = REMOVE;
    pNewRemoveAction->Object.f.pfilter = pFilter->pf;
    pNewRemoveAction->Object.f.pMon = pFilter->pMon;
    if( NULL != pNewRemoveAction->Object.f.pMon ) {
        pNewRemoveAction->Object.f.pMon->AddRef();
    }
    pNewRemoveAction->Object.f.fOriginallyInFilterCache = (F_CACHED == pFilter->State);

    // While it's nice to give filters a descriptive name,
    // it's not necessary to do so.
    if( NULL == pFilter->Name ) {
        pNewRemoveAction->Object.f.Name = NULL;
    } else {
        pNewRemoveAction->Object.f.Name = new WCHAR[ 1+lstrlenW(pFilter->Name) ];
        if( pNewRemoveAction->Object.f.Name!=NULL ) {
            lstrcpyW( pNewRemoveAction->Object.f.Name, pFilter->Name );
        }
    }

    POSITION posNewRemoveAction = pActionsList->GraphList.AddTail( pNewRemoveAction );
    if( NULL == posNewRemoveAction ) {
        delete pNewRemoveAction;
        return E_FAIL;
    }
    
    pActionsList->nFilters++;

    return S_OK;
}

// Look up the class ids in the registry and see if a StreamBuilder is registered
IStreamBuilder * GetStreamBuilder(CLSID Major, CLSID Sub)
{
    return NULL;  // NYI ???
}


//========================================================================
//
// RenderViaIntermediate
//
// Render ppinOut using another filter which we have to find
// (it isn't necessarily an intermediate, it might be the end we seek)
//========================================================================
HRESULT CFilterGraph::RenderViaIntermediate
    ( IPin * ppinOut      // the output pin
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts   // how to back out what we have done
    , CSpareList &Spares  // Any filters that were loaded but backed out
    , CSearchState &Best // The score, and how to rebuild it.
    )
{
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+4);
    HRESULT hr;         // return code from thing(s) we call
    Filter F;           // represents the intermediate filter
    F.bLoadNew = TRUE;
    F.bInputNeeded = TRUE;
    F.bOutputNeeded = mFG_bNoNewRenderers;
    DbgLog(( LOG_TRACE, 4, TEXT("RenderVia pin %x level %d")
           , ppinOut, iRecurse ));

    /* Find out what we can about the media types it will accept */
    hr = GetMediaTypes(ppinOut, &F.pTypes, &F.cTypes);
    if (FAILED(hr)) {
        Log( IDS_RENDGETMTFAIL, ppinOut, hr);
        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+24);
        return hr;
    }

    Log( IDS_RENDMAJTYPE, ppinOut, F.pTypes[0]);

    IStreamBuilder *pisb = NULL;
    BOOL bFoundByQI = FALSE;          // FALSE => CoCreate, TRUE => QueryInterface
                                      // See filgraph.h
    if (ppinOut!=mFG_ppinRender) {
        hr = ppinOut->QueryInterface(IID_IStreamBuilder, (void**)&pisb);
        ASSERT (pisb==NULL || SUCCEEDED(hr));

        if (pisb==NULL) {
            pisb = GetStreamBuilder(F.pTypes[0], F.pTypes[1]);
        } else {
            bFoundByQI = TRUE;
        }
    } else {
        pisb = NULL;
        DbgBreak("StreamBuilder is buck passing!");
    }

    HRESULT hrSpecific;

    if (pisb!=NULL) {   

        mFG_ppinRender = ppinOut;
        hrSpecific = pisb->Render(ppinOut, this);
        mFG_ppinRender = NULL;

        if (SUCCEEDED(hrSpecific)) {

            Action * pAct = new Action;
            if (pAct != NULL) {

                // CGenericList::AddTail() returns NULL if an error occurs.
                if (NULL != Acts.GraphList.AddTail(pAct)) {
                    Acts.StreamsRendered += Acts.StreamsToRender;

                    pisb->AddRef();

                    pAct->Verb = BACKOUT;
                    pAct->Object.b.pisb = pisb;
                    pAct->Object.b.ppin = ppinOut;
                    pAct->Object.b.bFoundByQI = bFoundByQI;

                    // Chances are this is could be a new high water mark.
                    if (CSearchState::IsBetter(Acts, Best)) {
                        CopySearchState(Best, Acts);
                    }
                } else {
                    hrSpecific = E_OUTOFMEMORY;
                    EXECUTE_ASSERT(SUCCEEDED(pisb->Backout(ppinOut, this)));
                    delete pAct;
                }
            } else {
                hrSpecific = E_OUTOFMEMORY;
                EXECUTE_ASSERT(SUCCEEDED(pisb->Backout(ppinOut, this)));
            }
        }

        pisb->Release();

    } else {

        // remember specific error codes if possible
        hrSpecific = VFW_E_CANNOT_RENDER;

        // For each possible candidate filter, either here or in registry
        for ( ; ; ) {
            if (mFG_bAborting) {
                return E_ABORT;
            }
            MSR_INTEGERX(mFG_idIntel, 1013);
            NextFilter(F, 0 /* No Flags */ );
            MSR_INTEGERX(mFG_idIntel, 1014);
            if (F.State==F_INFINITY) {
                if (mFG_punkSite) {
                    IAMFilterGraphCallback *pCallback;

                    HRESULT hrCallback = mFG_punkSite->
                             QueryInterface(IID_IAMFilterGraphCallback,
                                    (void **) &pCallback);

                    if (SUCCEEDED(hrCallback)) {
                        DbgLog((LOG_TRACE, 1, "Calling the UnableToRender callback on pin %x",
                            ppinOut));
                    
                        hrCallback = pCallback->UnableToRender(ppinOut);

                        pCallback->Release();
                    
                        DbgLog((LOG_TRACE, 1, "UnableToRender callback returned %x", hrCallback));
                    
                        // if it returned "success", then try rendering this pin again.
                        if (hrCallback == S_OK) {
                            if (F.pEm) {
                                F.pEm->Release();
                                F.pEm = 0;
                            }
                        
                            F.State = F_ZERO;

                            continue;
                        } else {
                            // we could propagate the error code out, but why?
                        }
                    }
                }

                break;
            }
            hr = RenderUsingFilter(ppinOut, F, iRecurse, Acts, Spares, Best);
            if (SUCCEEDED(hr)){
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+14);
                return hr;
            }
            else if (IsAbandonCode(hr)) {
                // no point in trying heroics if the filter is not in a state
                // where anything will connect to it.
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+24);
                return hr;
            } else {
                if ((hr != E_FAIL) &&
                    (hr != E_INVALIDARG) &&
                    (hr != VFW_E_CANNOT_CONNECT) &&
                    (hr != VFW_E_CANNOT_RENDER) &&
                    (hr != VFW_E_NO_ACCEPTABLE_TYPES)) {
                        hrSpecific = hr;
                }
            }
        }
    }

    if( FAILED( hrSpecific ) ) {
        DbgLog(( LOG_TRACE, 4, TEXT("RenderVia: failed level %d"), iRecurse )); 
    }

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+34);
    return hrSpecific;
} // RenderViaIntermediate




//========================================================================
//
// RenderRecursively
//
// Connect these two pins directly or indirectly, using transform filters
// if necessary.   Trace the recursion level  Fail if it gets too deep.

// ??? Can't we just get rid of this function and have its callers call
// ??? RenderViaIntermediate directly?

//========================================================================
HRESULT CFilterGraph::RenderRecursively
    ( IPin * ppinOut      // the output pin
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts   // how to back out what we have done
    , CSpareList &Spares  // Any filters that were loaded but backed out
    , CSearchState &Best // The score, and how to rebuild it.
    )

{

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+3);
    HRESULT hr;         // return code from thing(s) we call
    DbgLog(( LOG_TRACE, 4, TEXT("RenderRecursively pin %x level %d")
           , ppinOut, iRecurse ));

    if (iRecurse>CONNECTRECURSIONLIMIT) {
        return VFW_E_CANNOT_RENDER;
    }
    if (mFG_bAborting) {
        return E_ABORT;
    }

    hr = RenderViaIntermediate(ppinOut, 1+iRecurse, Acts, Spares, Best);
    DumpSearchState(Best);


    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+13);
    return hr;

} // RenderRecursively



//========================================================================
//
// Render
//
// Render this pin directly or indirectly, using transform filters
// if necessary.
//========================================================================

STDMETHODIMP CFilterGraph::Render
    ( IPin * ppinOut     // the output pin
    )
{
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    CheckPointer(ppinOut, E_POINTER);
    MSR_INTEGERX(mFG_idIntel, 2);
    HRESULT hr;         // return code from thing(s) we call
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);

        // Now that we're locked, we can check.  If we didn't lock first
        // we might find a pin that's about to be backed out.
        // We need to check that this pin is in our filter garph.
        // i.e. that the pin's filter's filter info points to us.
        hr = CheckPinInGraph(ppinOut);
        if (FAILED(hr)) {
            return hr;
        }

        ++mFG_RecursionLevel;
        Log( IDS_RENDP, ppinOut);
        DbgDump();

        CSearchState Acts;  // The search state itself
        CSearchState Best;  // The best that we ever manage
        CSpareList Spares(NAME("Spare filter list"));

        hr = InitialiseSearchState(Acts);
        if (FAILED(hr)) {
            DeleteBackoutList(Acts.GraphList);
            return hr;  // OUTOFMEMORY for sure
        }

        mFG_RList.Active();

        hr = RenderRecursively(ppinOut, 0, Acts, Spares, Best);

        DumpSearchState(Best);

        if (SUCCEEDED(hr)) {
            IncVersion();
            Log( IDS_RENDERSUCP, ppinOut);
        } else {
            Log( IDS_RENDERPART, ppinOut);
            if (Best.StreamsRendered>0.0) {
                HRESULT hrTmp = BuildFromSearchState(ppinOut, Best, Spares);
                if (FAILED(hrTmp)){
                    // Something nasty is going on.  Are we dying?
                    Log( IDS_RENDFAILTOT, ppinOut);
                }
                IncVersion();

                // note that we only partly succeeded
                if (S_OK == hrTmp) {
                    hr = ConvertFailureToInformational( hr );
                } else {
                    hr = hrTmp;
                }
            }
            // else the best we did was nothing - do not bump mFG_iVersion
        }
        Log( IDS_RENDENDSB, ppinOut);

        // Clear the backout actions (no longer needed)
        // Any reconnections left are valid and don't want purging
        DeleteBackoutList(Acts.GraphList);
        DeleteSpareList(Spares);
        FreeList(Best);
        AttemptDeferredConnections();
        mFG_RList.Passive();

        DbgLog((LOG_TRACE, 4, TEXT("Render returning %x"), hr));
        DbgDump();
        MSR_INTEGERX(mFG_idIntel, 12);
        --mFG_RecursionLevel;
    }

    // notify a change in the graph if we did anything successful.
    if (SUCCEEDED(hr)) {
        NotifyChange();
    }

    if (SUCCEEDED(hr)) {
        // including partial success
        mFG_bDirty = TRUE;
    }

    return hr;
} // Render


STDMETHODIMP CFilterGraph::RenderFileTryStg(LPCWSTR lpcwstrFile)
{
    IPersistStream* pPerStm = NULL;
    IStream * pStream;
    IStorage* pStg;
    HRESULT hr;


    hr = StgIsStorageFile(lpcwstrFile);

    if (S_OK == hr)
    {
        hr = StgOpenStorage( lpcwstrFile
                             , NULL
                             ,  STGM_TRANSACTED
                             | STGM_READ
                             | STGM_SHARE_DENY_WRITE
                             , NULL
                             , 0
                             , &pStg
                             );

        if (SUCCEEDED(hr))
        {
            // obtain our own IPersistStream interface
            hr = QueryInterface(IID_IPersistStream, (void**) &pPerStm);
            if (SUCCEEDED(hr))
            {

                // Open the filtergraph stream in the file
                hr = pStg->OpenStream( mFG_StreamName
                                       , NULL
                                       , STGM_READ|STGM_SHARE_EXCLUSIVE
                                       , 0
                                       , &pStream
                                       );
                if(SUCCEEDED(hr))
                {
                    // Load calls NotifyChange and must not be called holding a lock.
                    // Load takes out its own lock.

                    // It's a doc file with our stream in it - so load it.
                    hr = pPerStm->Load(pStream);

                    pStream->Release();
                }
                else
                {
                    // Most likely we will have a "Steam not found" return code
                    // which looks just like "file not found" and confuses the
                    // gibberish out of the OCX who knows he gave us a file.
                    // So let's be kind and give a more meaningful code.
                    hr = VFW_E_INVALID_FILE_FORMAT;
                }

                pPerStm->Release();
            }
            else
            {
                DbgBreak("unexpected failure");
            }

            pStg->Release();
        }
    }
    else
    {
        hr = VFW_E_UNSUPPORTED_STREAM;
    }

    return hr;
}


// allow RenderFile to open .grf files on a per-application basis
#define APPSHIM_ALLOW_GRF 0x1

DWORD GetAppShim()
{
    DWORD dwReturn = 0;
    // return value could be cached (it won't change)
    TCHAR *szBase = TEXT("software\\Microsoft\\DirectShow\\Compat");

    HKEY hk;
    LONG lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, szBase, 0, KEY_READ, &hk);
    if(lResult == ERROR_SUCCESS)
    {
        TCHAR szApp[MAX_PATH];
        if(GetModuleFileName(0, szApp, NUMELMS(szApp)))
        {
            TCHAR szOut[MAX_PATH];
            TCHAR *pszMod;
            if(GetFullPathName(szApp, MAX_PATH, szOut, &pszMod))
            {
                DWORD dwType, dwcb = sizeof(dwReturn);
                lResult = RegQueryValueEx(
                    hk, pszMod, 0, &dwType, (BYTE *)&dwReturn, &dwcb);
            }
        }
        
        RegCloseKey(hk);
    }

    return dwReturn;
}

//========================================================================
//
// RenderFile
//
// Build a filter graph that will render this file using this play list
// If lpwstrPlayList is NULL then it will use the default play list
// which will typically render the whole file.
//========================================================================
STDMETHODIMP CFilterGraph::RenderFile( LPCWSTR lpcwstrFile, LPCWSTR lpcwstrPlayList )
{
    // This parameter is not used.  See the IGraphBuilder::RenderFile() documentation in the Platform SDK.
    UNREFERENCED_PARAMETER(lpcwstrPlayList);

    CAutoTimer Timer(L"RenderFile");
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter

    CheckPointer(lpcwstrFile, E_POINTER);
    MSR_INTEGERX(mFG_idIntel, 1);
    HRESULT hr;


    {
        CAutoMsgMutex cObjectLock(&m_CritSec);

        Log( IDS_RENDFILE, lpcwstrFile);
        DbgDump();


        IBaseFilter * pfSource;
        // not a storage - or at least not one that we recognise.
        // (Is it just possible that some media file might look like a storage?
        // We'll soon see anyway as we try to recognise its media type.


        // Try to find source filter and then render all pins.

        #ifdef DEBUG
        LONG lInitialListMode = mFG_RList.m_lListMode;
        #endif // DEBUG

        mFG_RList.Active();

        BOOL bDirt = mFG_bDirty;
        BOOL bGuess;
        hr = AddSourceFilterInternal( lpcwstrFile, lpcwstrFile, &pfSource, bGuess );
        mFG_bDirty = mFG_bDirty;  // We'll handle this later.

        if (FAILED(hr)){
            mFG_RList.Passive();
            Log( IDS_RENDADDSOURCEFAIL, hr);
            return hr;
        }
        pfSource->Release();    // Get rid of the "caller's refcount", just keep our own


        Log( IDS_RENDADDEDSOURCE, pfSource);

        ++mFG_RecursionLevel;
        CEnumPin Next(pfSource, CEnumPin::All, TRUE);
        IPin *pPin;

        // We maintain a single spares list across all the rendering atempts.
        // We do NOT maintain a single backout list.  The current rules are that
        // if anything succeeds, we leave it.
        CSpareList Spares(NAME ("Spare filter list"));

        BOOL bAllWorked = TRUE;
        int nTried = 0;
        HRESULT hrTotal = S_OK;

        while ((LPVOID) (pPin = Next())) {
            if (mFG_bAborting) {
                pPin->Release();
                hr = E_ABORT;
                break;
            }

            ++nTried;
            CSearchState PinActs;  // back out actions for this pin
            CSearchState Best;
            hr = InitialiseSearchState(PinActs);
            if (FAILED(hr)) {
                DeleteBackoutList(PinActs.GraphList);
                pPin->Release();
                break;
            }

            Log( IDS_RENDSOURCEP, pPin);
            hr = RenderRecursively(pPin, 0, PinActs, Spares, Best);
            if (SUCCEEDED(hr)) {
                Log( IDS_RENDSUC, pPin, pfSource);
            }
            if (FAILED(hr)) {
                bAllWorked = FALSE;
                // ASSERT: Everything is backed out.
                // Should have been backed out at or below the RenderUsing level.
                ASSERT(PinActs.GraphList.GetCount()==PinActs.nInitialFilters);

                Log( IDS_RENDPARTSOURCEP, pPin, hr);

                if (Best.StreamsRendered>0.0) {
                    Log( IDS_RENDBESTCANDOP, pPin);
                    HRESULT hrTmp = BuildFromSearchState(pPin, Best, Spares);
                    if (SUCCEEDED(hrTmp)) {
                        Log( IDS_RENDBESTCANDONEP, pPin);

                        // now try to fix up a partial-success code
                        // based on the error code returned
                        hr = ConvertFailureToInformational(hr);

                    } else {
                        hr = hrTmp;
                        Log( IDS_RENDBESTCANFAIL, pPin, hr);
                    }
                } else {
                    if (bGuess && !IsInterestingCode(hr)) {
                        hr = VFW_E_UNSUPPORTED_STREAM;
                    }
                    Log( IDS_RENDWORTHLESS, pPin);
                }

            }

            /*  Aggregate hrTotal over all the pins in order of
                precedence :
                  first success code != S_OK
                  VFW_S_PARTIAL_RENDER if only S_OK and failures
                  first failure code
            */
            if (nTried == 1) {
                hrTotal = hr;
            } else {
                /*  9 cases */
                int i = (S_OK == hr ? 0 : SUCCEEDED(hr) ? 1 : 2)
                      + (S_OK == hrTotal ? 0 : SUCCEEDED(hrTotal) ? 3 : 6);

                switch (i) {
                case 0: /*  Both S_OK */
                    break;

                case 1: /*  SUCCEEDED(hr), hrTotal == S_OK */
                    hrTotal = hr;
                    break;

                case 2: /*  FAILED(hr), hrTotal == S_OK */
                    hrTotal = ConvertFailureToInformational(hr);
                    break;

                case 3: /*  hr == S_OK, SUCCEEDED(hrTotal) */
                    break;

                case 4: /*  SUCCEEDED(hr), SUCCEEDED(hrTotal) */
                    break;

                case 5: /*  FAILED(hr), SUCCEEDED(hrTotal) */
                    break;

                case 6: /*  hr == S_OK, FAILED(hrTotal) */
                    hrTotal = ConvertFailureToInformational(hrTotal);
                    break;

                case 7: /*  SUCCEEDED(hr), FAILED(hrTotal) */
                    hrTotal = hr;
                    break;

                case 8: /*  FAILED(hr), FAILED(hrTotal) */
                    break;
                }
            }

            if (FAILED(hr)) {
                // either the best we did was nothing or else all attempts failed
                Log( IDS_RENDTOTFAILP, pPin, hr);
            }

            pPin->Release();

            DeleteBackoutList(PinActs.GraphList);
            FreeList(Best);
        }
        hr = hrTotal;

        // nTried==0 means that this is a filter with no output pins.
        // In this case no success is also complete success!
        if (SUCCEEDED(hr) || nTried==0) {
            IncVersion();
        } else {
            // The only thing left is the source filter - kill that too.
            HRESULT hrTmp = RemoveFilterInternal(pfSource);
            ASSERT(SUCCEEDED(hrTmp));

            // try to preserve interesting specific error codes
            // without returning obscure internal ones
            if ((hr == VFW_E_CANNOT_CONNECT) ||
                (hr == VFW_E_NO_ACCEPTABLE_TYPES) ||
                (hr == E_FAIL) ||
                (hr == E_INVALIDARG))
            {
                hr = VFW_E_CANNOT_RENDER;
            }
        }


        DeleteSpareList(Spares);
        AttemptDeferredConnections();
        mFG_RList.Passive();

	// This ASSERT's purpose is to make sure each call to 
        // CReconnectList::Active() has a corresponding call 
        // to CReconnectList::Passive().  If the ASSERT fires,
        // CReconnectList::Passive() was called too many or 
        // too few times.
        ASSERT(mFG_RList.m_lListMode == lInitialListMode);

        Log( IDS_RENDRETCODE, hr);
        --mFG_RecursionLevel;

    } // lock

    // maybe it was a .grf
    if(hr == VFW_E_UNSUPPORTED_STREAM)
    {
        // extension must be .grf
        int cchSz = lstrlenW(lpcwstrFile);
        if(cchSz > 4 && lstrcmpiW(lpcwstrFile + cchSz - 4, L".grf") == 0)
        {
            if(GetAppShim() & APPSHIM_ALLOW_GRF)
            {
                return RenderFileTryStg(lpcwstrFile);
            }
        }
        // note we don't call NotifyChange or set mFG_bDirty;
    }

    // notify a change in the graph
    if (SUCCEEDED(hr)) {
        NotifyChange();
    }

    MSR_INTEGERX(mFG_idIntel, 11);

    if (SUCCEEDED(hr)) {
        // including partial success
        mFG_bDirty = TRUE;
    }
    // In the event of total failure, no reconnections will have been done
    // because all the filters will have been backed out first and the
    // reconnect lists purged.

    return hr;

} // RenderFile

void EliminatePinsWithTildes(IPin **appinOut, ULONG &nPin)
{
    ULONG nRemoved = 0;
    for (ULONG i = 0; i < nPin; i++) {
        appinOut[i - nRemoved] = appinOut[i];
        if (!RenderPinByDefault(appinOut[i - nRemoved])) {
            appinOut[i - nRemoved]->Release();
            nRemoved++;
        }
    }
    nPin -= nRemoved;
}


// Helper that calls FindOutputPins2 and allocates memory if too few
// slots were passed in. *pappinOut should contain an array of nSlots
// IPin * pointers. if that's not enough, *pappinOut will be changed
// to memory allocated with new
//
HRESULT CFilterGraph::FindOutputPinsHelper( IPin* ppinIn
                                            , IPin ***pappinOut
                                            , const int nSlots
                                            , int &nPin
                                            , bool fAll
                                            )
{
    HRESULT hr = FindOutputPins2( ppinIn, *pappinOut, nSlots, nPin, fAll );
    if(hr == S_FALSE)
    {
        ASSERT(nPin > C_PINSONSTACK);
        IPin **appinHeap = new IPin *[nPin];
        if(appinHeap)
        {
            hr = FindOutputPins2( ppinIn, appinHeap, nPin, nPin, fAll);
            if(hr == S_OK) {
                *pappinOut = appinHeap;
            } else {
                delete[] appinHeap;
            }

            if (hr == S_FALSE)
            {
                DbgBreak("S_FALSE from FindOutputPins2 2x");
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


// Precondition:
//     nSlots is the number of elements in appinOut
//     appinOut is an array of IPin*
//     ppinIn is an input pin
//
// set nPinOut to the number of output pins that *ppinIn is internally connected to
// set appinOut[0..nPinOut-1] to be these pins.
//
// if ppinIn supports QueryInternalConnections, then use it.
//
// otherwise return all output pins on the filter. if fAll is set, all
// output pins are returned. o/w just those that succeed
// RenderPinByDefault()
//
// Every pin returned in appinOut is AddReffed.
//
// If it FAILs return no pins and leave no new AddReffs.
// S_FALSE means nSlots was too small. nPinOut contains required no.

HRESULT CFilterGraph::FindOutputPins2( IPin* ppinIn
                                       , IPin * *appinOut
                                       , const UINT nSlots
                                       , int &nPinOut
                                       , bool fAll
                                       )
{
    ULONG nPin = nSlots;
    HRESULT hr;
    {
        hr = ppinIn->QueryInternalConnections(appinOut, &nPin);
        if(hr == S_OK && !fAll) {
            EliminatePinsWithTildes(appinOut, nPin);
        }
        if(hr == S_OK || hr == S_FALSE)
        {
            // ok or not enough slots.
            nPinOut = nPin;
            return hr;
        }

        // E_NOTIMPL is an expected failure from QIC
        ASSERT(hr == E_NOTIMPL);
    }

    // we can try the hacky version that assumes all output pins are
    // streams from the input pin.

    PIN_INFO pi;
    hr = ppinIn->QueryPinInfo(&pi);
    if (FAILED(hr)) {
        return hr;   // nothing yet addreffed
    }
    ASSERT(pi.dir == PINDIR_INPUT);
    ASSERT(pi.pFilter);

    ULONG cOutPinFound = 0;
    IEnumPins *pep;
    hr = pi.pFilter->EnumPins(&pep);
    pi.pFilter->Release();
    if(SUCCEEDED(hr))
    {
        // enumerate output pins in bunches of C_PINSONSTACK
        IPin *rgPinTmp[C_PINSONSTACK];
        while(SUCCEEDED(hr))
        {
            ULONG cFetched;
            hr = pep->Next(C_PINSONSTACK, rgPinTmp, &cFetched);
            ASSERT(hr == S_OK && cFetched == C_PINSONSTACK ||
                   hr == S_FALSE && cFetched < C_PINSONSTACK ||
                   FAILED(hr));
            if(SUCCEEDED(hr))
            {
                // cannot exit this loop until all pins have been
                // transferred or released. errors from QueryDirection
                // are lost
                for(UINT iPin = 0;
                    iPin < cFetched /* && SUCCEEDED(hr) */;
                    iPin++)
                {
                    PIN_DIRECTION dir;
                    hr = rgPinTmp[iPin]->QueryDirection(&dir);
                    if(SUCCEEDED(hr) && dir == PINDIR_OUTPUT &&
                       (fAll || RenderPinByDefault(rgPinTmp[iPin])))
                    {
                        if(cOutPinFound < nSlots)
                        {
                            // transfer ref
                            appinOut[cOutPinFound] = rgPinTmp[iPin];
                        }
                        else
                        {
                            rgPinTmp[iPin]->Release();
                        }
                        cOutPinFound++;
                    }
                    else
                    {
                        rgPinTmp[iPin]->Release();
                    }

                } // for

                if(cFetched < C_PINSONSTACK) {
                    break;
                }

            } // Next

        } // while

        pep->Release();
    }

    if(FAILED(hr) || cOutPinFound > nSlots) {
        for(UINT iPin = 0; iPin < min(nSlots, cOutPinFound); iPin++) {
            appinOut[iPin]->Release();
        }
    }

    if(SUCCEEDED(hr))
    {
        nPinOut = cOutPinFound;
        hr = cOutPinFound <= nSlots ? S_OK : S_FALSE;
    }
    return hr;

} // FindOutputPins2


// return TRUE iff you can go continuously downstream from ppinUp to ppinDown
// PreCondition: The graph must not already contain a cycle.
//               this is used to ensure that we cannot make a cycle.
//               ppinUp is an input pin.
//               ppinDown is an output pin
// Call this before attempting to connect ppinDown to ppinUp.
// If the answer is TRUE, don't do it - you'll make a cycle.
// In the event of a failure it returns "TRUE".
// No new addrefs, no extra releases.
BOOL CFilterGraph::IsUpstreamOf( IPin * ppinUp, IPin* ppinDown )
{
    // Algorithm:
    // Start from ppinUp.
    // just enumerate all output pins on the filter (cannot trust
    // QueryInternalConnections because pins may legitimately not be
    // connected internally).
    //
    // For each output pin so found:
    // {   If it's the same as ppinDown, return TRUE
    //     else if it's not connected, continue
    //     else if IsUpstreamOf(the connected input pin, ppinDown) return TRUE
    //     else continue
    // }
    // return FALSE

    HRESULT hr;

    IPin * appinOutStack[C_PINSONSTACK];
    IPin **appinOut = appinOutStack;
    int nPinOut;

    // Enumerate all pins, including names beginning with "~" that are not
    // rendered by default (fAll == true)
    //
    hr = FindOutputPinsHelper( ppinUp, &appinOut, C_PINSONSTACK, nPinOut, true);
    if (FAILED(hr)) {
        DbgBreak("FindOutputPins failed");
        return TRUE;   // actually "don't know"
    }
    CDelRgPins rgPins(appinOut == appinOutStack ? 0 : appinOut);

    // appinOut[0..nPinOut-1] are addreffed output pins.
    // They will each be investigated (unless we already know the overall answer)
    // and each released.

    // for i = 0..nPinOut-1
    BOOL bResult = FALSE;
    for (int i=0; i<nPinOut ; ++i) {
        if (bResult==TRUE)
        {   // Nothing to do except release appinOut[i]
        }
        else if (appinOut[i]==ppinDown) {
            bResult = TRUE;
        } else {
            IPin * ppinIn;
            appinOut[i]->ConnectedTo(&ppinIn);
            if (ppinIn) {
                if (IsUpstreamOf(ppinIn, ppinDown)) {
                    bResult = TRUE;
                }
                ppinIn->Release();
            }

        }
        appinOut[i]->Release();
    }

    return bResult;
} // IsUpstreamOf


// return VFW_E_NOT_IN_GRAPH     iff     pFilter->pGraph != this
// otherwise return NOERROR
HRESULT CFilterGraph::CheckFilterInGraph(IBaseFilter *const pFilter) const
{
    HRESULT hr;
    ASSERT( pFilter );
    ASSERT( this );
    if (pFilter)
    {
        FILTER_INFO FilterInfo;
        hr = pFilter->QueryFilterInfo(&FilterInfo);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr) && FilterInfo.pGraph)
        {
            hr = IsEqualObject( FilterInfo.pGraph,
                                const_cast<IFilterGraph*>(static_cast<const IFilterGraph*>(this)) )
                 ? NOERROR
                 : VFW_E_NOT_IN_GRAPH;
            FilterInfo.pGraph->Release();
        }
        else hr = VFW_E_NOT_IN_GRAPH;
    }
    else hr = VFW_E_NOT_IN_GRAPH;

    return hr;
} // CheckFilterInGraph

// return VFW_E_NOT_IN_GRAPH     iff     pPin->pFilter->pGraph != this
// otherwise return NOERROR
HRESULT CFilterGraph::CheckPinInGraph(IPin *const pPin) const
{
    HRESULT hr;
    ASSERT(pPin);
    if (pPin)
    {
        PIN_INFO PinInfo;
        hr = pPin->QueryPinInfo(&PinInfo);
        ASSERT(SUCCEEDED(hr));
        ASSERT(PinInfo.pFilter);
        if (SUCCEEDED(hr))
        {
            hr = CheckFilterInGraph(PinInfo.pFilter);
            PinInfo.pFilter->Release();
        }
    }
    else hr = VFW_E_NOT_IN_GRAPH;
    return hr;
} // CheckPinInGraph
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\msgmutex.cpp ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved

//
//  Filter graph locking implementation
//

#include <streams.h>
#include "MsgMutex.h"

//
//  Special locking stuff
//

CMsgMutex::CMsgMutex(HRESULT *phr) :
    m_dwOwnerThreadId(0),
    m_dwRecursionCount(0),
    m_hMutex(CreateMutex(NULL, FALSE, NULL)),
    m_uMsg(0),
    m_hwnd(NULL),
    m_dwWindowThreadId(0)
{
    if (m_hMutex == NULL) {
        *phr = E_OUTOFMEMORY;
    }
}

CMsgMutex::~CMsgMutex()
{
    if (m_hMutex) {
        EXECUTE_ASSERT(CloseHandle(m_hMutex));
        m_hMutex = NULL;
    }
    ASSERT(m_dwOwnerThreadId == 0 && m_dwRecursionCount == 0);
}

void CMsgMutex::SetWindow(HWND hwnd, UINT uMsg)
{
    m_hwnd = hwnd;
    m_uMsg = uMsg;
    m_dwWindowThreadId = GetWindowThreadProcessId(hwnd, NULL);
}

BOOL CMsgMutex::Lock(HANDLE hEvent)
{
    BOOL bReturn = TRUE;
    ASSERT(m_hMutex != NULL);
    const DWORD dwCurrentThreadId = GetCurrentThreadId();
    if (dwCurrentThreadId != m_dwOwnerThreadId) {
        bReturn =
        (WaitDispatchingMessages(
            m_hMutex,
            INFINITE,
            dwCurrentThreadId == m_dwWindowThreadId ? m_hwnd : NULL,
            m_uMsg,
            hEvent) ==
            WAIT_OBJECT_0);
        if (bReturn) {
            ASSERT(m_dwRecursionCount == 0 && m_dwOwnerThreadId == 0);
            m_dwOwnerThreadId = dwCurrentThreadId;
        }
    } else {
        ASSERT(m_dwRecursionCount != 0);
    }
    if (bReturn) {
        m_dwRecursionCount++;
    }
    return bReturn;
}

void CMsgMutex::Unlock()
{
    ASSERT(m_dwRecursionCount != 0 &&
           m_dwOwnerThreadId == GetCurrentThreadId());
    if (--m_dwRecursionCount == 0) {
        m_dwOwnerThreadId = 0;
        EXECUTE_ASSERT(ReleaseMutex(m_hMutex));
    }
}

#ifdef DEBUG
BOOL WINAPI CritCheckIn( const CMsgMutex *pMutex )
{
    return pMutex->m_dwOwnerThreadId == GetCurrentThreadId();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\mapper.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// Guide to enumeration for the uninitiated:
// The game starts in filgraph.cpp where
//    NextFilter enumerates filters from the graph and then calls our
//       EnumMatchingFilters to get an IEnumRegFilters interface thanks to
//           CEnumRegFilters::CEnumRegFilters.  All is now ready for
//               CEnumRegFilters::Next which calls
//                   RegEnumFilterInfo and
//                   RegEnumPinInfo to do the work.
// (This is an awful lot of storage shuffling just so as to
// have something that looks like a standard COM enumerator).

// ??? Do we want an UnregisterPinType

// #include <windows.h>   already included in streams.h
#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include <string.h>
// #include <initguid.h>
#include <wxutil.h>
#include <wxdebug.h>

#include "mapper.h"
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <stats.h>
#include "..\squish\regtypes.h"
#include "..\squish\squish.h"
#include "util.h"
#include "isactive.h"

#define DbgBreakX(_x_) DbgBreakPoint(_x_, TEXT(__FILE__),__LINE__)


#ifdef PERF
static int iBindCache;
static int iReadFilterData;
static int iReadCLSID;
static int iUnSquish;
#endif

#ifdef DEBUG
static void DbgValidateHeaps()
{
  HANDLE rgh[512];
  DWORD dwcHeaps = GetProcessHeaps(512, rgh);
  for(UINT i = 0; i < dwcHeaps; i++)
    ASSERT(HeapValidate(rgh[i], 0, 0) );
}
#endif

#ifdef PERF
#define FILGPERF(x) x
#else
#define FILGPERF(x)
#endif

// Need to declare the statics (the cache pointer and its ref count
// and its critical section) separately:

CMapperCache * CFilterMapper2::mM_pReg = NULL;
long CFilterMapper2::mM_cCacheRefCount = 0;
CRITICAL_SECTION CFilterMapper2::mM_CritSec;

// Wide strings that are names of registry keys or values
// These are NOT localisable
const WCHAR szRegFilter[]       = L"Filter";
const WCHAR szCLSID[]           = L"CLSID";
const WCHAR szInproc[]          = L"InprocServer32";
const WCHAR szName[]            = L"Name";
const WCHAR szMerit[]           = L"Merit";
const WCHAR szPins[]            = L"Pins";
const WCHAR szTypes[]           = L"Types";
const WCHAR szMajorType[]       = L"MajorType";
const WCHAR szSubType[]         = L"SubType";
const WCHAR szIsRendered[]      = L"IsRendered";
const WCHAR szDirection[]       = L"Direction";
const WCHAR szAllowedZero[]     = L"AllowedZero";
const WCHAR szAllowedMany[]     = L"AllowedMany";
const WCHAR szConnectsToFilter[]= L"ConnectsToFilter";
const WCHAR szConnectsToPin[]   = L"ConnectsToPin";
const WCHAR szThreadingModel[]  = L"ThreadingModel";
const WCHAR szBoth[]            = L"Both";
static const WCHAR g_wszInstance[] = L"Instance";

static const TCHAR g_szKeyAMCat[] = TEXT("CLSID\\{DA4E3DA0-D07D-11d0-BD50-00A0C911CE86}\\Instance");


#define MAX_STRING 260       // max length for a string found in the registry
#define MAX_KEY_LEN 260       // max length for a value name or key name
#define CLSID_LEN 100        // enough characters for a clsid in text form

// lets you define DWORD as FCC('xyzw')
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))



// A filter is registered by creating the following in the registry.
// (HKCR is HKEY_CLASSES_ROOT)

// ------Key------------------- -valuename------ -----value---------------

// \HKCR\Filter\<CLSID>                                <descriptive name of filter>
// \HKCR\CLSID\<CLSID>\InprocServer32                  <path to executable>
// \HKCR\CLSID\<CLSID>                Merit            <merit>
//
// \HKCR\CLSID\<CLSID>\Pins\<Name>    Direction        <0==PINDIR_INPUT, 1==PINDIR_OUTPUT>
// \HKCR\CLSID\<CLSID>\Pins\<Name>    IsRendered       <1==Yes, 0==No>
//                                                     Only makes sense for input
// \HKCR\CLSID\<CLSID>\Pins\<Name>    AllowedZero      <1==Yes, 0==No>
// \HKCR\CLSID\<CLSID>\Pins\<Name>    AllowedMany      <1==Yes, 0==No>
// \HKCR\CLSID\<CLSID>\Pins\<Name>    ConnectsToFilter <GUID>
// \HKCR\CLSID\<CLSID>\Pins\<Name>    ConnectsToPin    <Pin name>
// ...\Pins\<Name>\Types\<MajorType1> <Subtype1a>      - These
// ...\Pins\<Name>\Types\<MajorType1> <Subtype1b>      - do
//                                       etc             not
// ...\Pins\<Name>\Types\<MajorType2> <Subtype2a>      - have
//                                       etc             values

// graphically this is:
//<clsid>
//      Pins
//         <pin1Name>                         Direction, IsRendered, etc.
//                  Types
//                      <majortype1>
//                              <subtype1a>
//                              <subtype1b>
//                      <majortype2>
//                              <subtype2a>
//                                 ...
//         <pin2Name>                         Direction, IsRendered, etc.
// etc.
//<--                keys               -->   <--- values names ----  ->



//=====================================================================
//=====================================================================
// Auxiliary functions etc.
//=====================================================================
//=====================================================================



//=====================================================================
// Return the length in bytes of str, including the terminating null
//=====================================================================
int ByteLen(LPTSTR str)
{
    if (str==NULL) {
        return 0;
    }
#ifdef UNICODE
    return (sizeof(TCHAR))*(1+wcslen(str));
#else
    return (sizeof(TCHAR))*(1+strlen(str));
#endif
} // ByteLen

// ========================================================================
// build a moniker
// ========================================================================

// HRESULT  GetMoniker(
//     const CLSID *clsCat,
//     const CLSID *clsFilter,
//     const WCHAR *wszInstance,
//     IMoniker **ppMoniker)
// {
//     WCHAR wszDisplayName[CHARS_IN_GUID + CHARS_IN_GUID + MAX_PATH];
//     WCHAR *wszPtr = wszDisplayName;

//     const WCHAR wsz1[] = L"@device:sw:CLSID\\";
//     lstrcpyW(wszDisplayName, wsz1);
//     wszPtr += NUMELMS(wsz1) - 1;

//     EXECUTE_ASSERT(StringFromGUID2(*clsCat, wszPtr, CHARS_IN_GUID) ==
//                    CHARS_IN_GUID);

//     wszPtr += CHARS_IN_GUID - 1;

//     const WCHAR wsz2[] = L"\\Instance\\";

//     // no lstrcatW on win95, so use CopyMemory
//     CopyMemory(wszPtr, wsz2, sizeof(wsz2));
//     wszPtr += sizeof(wsz2) - sizeof(WCHAR);

//     EXECUTE_ASSERT(StringFromGUID2(*clsFilter, wszPtr, CHARS_IN_GUID) ==
//                    CHARS_IN_GUID);

//     IBindCtx *lpBC;
//     HRESULT hr = CreateBindCtx(0, &lpBC);
//     if(SUCCEEDED(hr))
//     {
//         IParseDisplayName *ppdn;
//         ULONG cchEaten;

//         hr = CoCreateInstance(
//             CLSID_CDeviceMoniker,
//             NULL,
//             CLSCTX_INPROC_SERVER,
//             IID_IParseDisplayName,
//             (void **)&ppdn);
//         if(SUCCEEDED(hr))
//         {
//             hr = ppdn->ParseDisplayName(
//                 lpBC, wszDisplayName, &cchEaten, ppMoniker);
//             ppdn->Release();
//         }

//         lpBC->Release();
//     }

//     return hr;
// }



//=====================================================================
//.....................................................................
// Routines to make calling the registry easier -
// Suppress common parameters and do unicode/ANSI conversion
//---------------------------------------------------------------------

HRESULT ParseDisplayNameHelper(WCHAR *wsz, IMoniker **ppmon)
{
    HRESULT hr;
    CComPtr<IBindCtx> lpBC;
    hr = CreateBindCtx(0, &lpBC); // !!! cache IBindCtx?
    if (SUCCEEDED(hr))
    {
        {
            CComPtr<IParseDisplayName> pParse;
            // First try our own monikers
            //
            // call CoInitialize() ???
            //
            hr = CoCreateInstance(CLSID_CDeviceMoniker,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IParseDisplayName,
                                  (void **)&pParse);

            DWORD dwEaten;
            if (SUCCEEDED(hr)) {
                hr = pParse->ParseDisplayName(
                    lpBC,
                    wsz,
                    &dwEaten,
                    ppmon);
            }
        }
        if (FAILED(hr)) {
#ifdef DEBUG
            DWORD dwTime = timeGetTime();
#endif
            DWORD dwEaten;
            hr = MkParseDisplayName(lpBC, wsz, &dwEaten,
                                    ppmon);

#ifdef DEBUG
            DbgLog((LOG_TRACE, 0, TEXT("MkParseDisplayName took %d ms"),
                    timeGetTime() - dwTime));
#endif
        }
    }

    return hr;
}




//=====================================================================
// GetRegKey
//
// Return an open registry key HKEY_CLASSES_ROOT\<strKey>
// or return NULL if it fails.
// The returned key has to have RegCloseKey done some time.
//=====================================================================

HKEY GetRegKey( LPCTSTR strKey )
{
    // registering filters is expected to be rare, so no particular care
    // taken to optimise.  Could avoid wsprintf when we are in UNICODE.

    DWORD dwOptions = REG_OPTION_NON_VOLATILE;
    HKEY hKey;
    DWORD dwDisp;      // return code from registry
                       // CREATED_NEW_KEY means we got the lock
                       // OPENED_EXISTING_KEY means we didn't
    LONG lRC;          // return codes from various operations


    // ------------------------------------------------------------------------
    // Create the \HKCR\<lpwstrKey> key
    // ------------------------------------------------------------------------
    lRC = RegCreateKeyEx( HKEY_CLASSES_ROOT    // open key
                        , strKey               // subkey name
                        , 0                    // reserved
                        , NULL                 // ??? What is a class?
                        , dwOptions            // Volatile or not
                        , MAXIMUM_ALLOWED
                        , NULL                 // Security attributes
                        , &hKey
                        , &dwDisp
                        );
    if (lRC!=ERROR_SUCCESS) {
       return (HKEY)NULL;
    }

    return hKey;
} // GetRegKey



//=====================================================================
// CheckRegKey
//
// Return TRUE if the register key HKEY_CLASSES_ROOT\<strKey> exists
// return FALSE if it doesn't
//=====================================================================

BOOL CheckRegKey( LPCTSTR strKey )
{
    // registering filters is expected to be rare, so no particular care
    // taken to optimise.  Could avoid wsprintf when we are in UNICODE.

    HKEY hKey;
    LONG lRC;          // return codes from various operations


    // ------------------------------------------------------------------------
    // Create the \HKCR\<lpwstrKey> key
    // ------------------------------------------------------------------------
    lRC = RegOpenKeyEx( HKEY_CLASSES_ROOT    // open key
                      , strKey               // subkey name
                      , 0                    // reserved
                      , KEY_READ             // security access
                      , &hKey
                      );
    if (lRC==ERROR_SUCCESS) {
       RegCloseKey(hKey);
       return TRUE;
    }

    return FALSE;
} // CheckRegKey



//=====================================================================
// SetRegString
//
// Set the value for hKey + strName to be strValue
// Works for either unicode or ANSI registry
// arbitrary limit of 300 chars
// Returns 0 if successful, else error code.
//=====================================================================

LONG SetRegString( HKEY hKey,           // an open key
                   LPCWSTR strName,     // The name of the value (or NULL if none)
                   LPCWSTR strValue     // the value
                 )
{

    LONG lRC;          // return codes from various operations
    LPTSTR lptstrName; // value name parameter for RegSetValueEx (could be NULL)

    TCHAR ValueBuff[300]; // Value converted from wchar to set in registry
    TCHAR NameBuff[300];  // Name converted from WCHAR

    wsprintf(ValueBuff, TEXT("%ls"), strValue);

    if (NULL!=strName) {
        wsprintf(NameBuff, TEXT("%ls"), strName);
        lptstrName = NameBuff;
    }
    else lptstrName = NULL;

    lRC = RegSetValueEx( hKey, lptstrName, 0, REG_SZ
                       , (unsigned char *)ValueBuff, ByteLen(ValueBuff) );

    return lRC;

} // SetRegString



//=====================================================================
// SetRegDword
//
// Set the value for hKey + strName to be dwValue
// Works for either unicode or ANSI registry
// arbitrary limit of 300 chars
// Returns 0 if successful, else error code.
//=====================================================================

LONG SetRegDword( HKEY hKey,           // an open key
                  LPCWSTR strName,     // The name of the value (or NULL if none)
                  DWORD dwValue        // the value
                )
{

    LONG lRC;          // return codes from various operations
    LPTSTR lptstrName; // value name parameter for RegSetValueEx (could be NULL)

    TCHAR NameBuff[300];  // Name converted from WCHAR

    if (NULL!=strName) {
        wsprintf(NameBuff, TEXT("%ls"), strName);
        lptstrName = NameBuff;
    }
    else lptstrName = NULL;

    lRC = RegSetValueEx( hKey, lptstrName, 0, REG_DWORD
                       , (unsigned char *)&dwValue, sizeof(dwValue) );

    return lRC;

} // SetRegDword



//=====================================================================
// SetRegClsid
//
// Set the value for hKey + strName to be clsValue
// Works for either unicode or ANSI
// Returns 0 if successful, else error code.
//=====================================================================

LONG SetRegClsid( HKEY hKey,           // an open key
                  LPCWSTR strName,     // The name of the value (or NULL if none)
                  CLSID clsValue       // the value
                )
{
    OLECHAR  str[CHARS_IN_GUID];
    HRESULT hr;
    LONG lRc;

    hr = StringFromGUID2( clsValue, str, CHARS_IN_GUID);

    lRc = SetRegString(hKey, strName, str);

    return lRc;

} // SetRegClsid



//=====================================================================
// DeleteRegValue
//
// Delete the value for  hKey+strName
// Works for either unicode or ANSI registry
// arbitrary limit of 300 chars
// Returns 0 if successful, else error code.
//=====================================================================

LONG DeleteRegValue( HKEY hKey,           // an open key
                     LPCWSTR strName      // The name of the value (or NULL if none)
                   )
{

    LONG lRC;          // return codes from various operations
    LPTSTR lptstrName; // value name parameter for RegSetValueEx (could be NULL)

    TCHAR NameBuff[300];  // Name converted from WCHAR

    if (NULL!=strName) {
        wsprintf(NameBuff, TEXT("%ls"), strName);
        lptstrName = NameBuff;
    }
    else lptstrName = NULL;

    lRC = RegDeleteValue( hKey, lptstrName);

    return lRC;

} // DeleteRegValue



//===========================================================
// List of class IDs and creator functions for class factory
//===========================================================

// See filgraph.cpp -- The filter graph and mapper share a DLL.


//==================================================================
// Register the GUID, descriptive name and binary path of the filter
// This also needs to create the Pins key as a filter with no pins
// key is taken as a duff registration. (IFilterMapper)
//==================================================================


// did have a 3rd param "LPCWSTR strBinPath, // Path to the executable"
// but this is now handled separately so that the server
// type (Inproc, etc) can be decided separately

STDMETHODIMP CFilterMapper2::RegisterFilter
    ( CLSID  Clsid,       // GUID of the filter
      LPCWSTR strName,    // Descriptive name
      DWORD  dwMerit      // DO_NOT_USE, UNLIKELY, NORMAL or PREFERRED.
    )
{
    CheckPointer(strName, E_POINTER);
    HKEY hKey;          // registry key for the filter list
    LONG lRC;           // return codes from various operations
    LONG lRcSet;        // retcode from SetRegString
    TCHAR Buffer[MAX_KEY_LEN];
    OLECHAR pstr[CHARS_IN_GUID];   // Wstring representation of clsid

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        Clsid);

    //-----------------------------------------------------------------
    // Add key HKCR\Filter\<clsid>
    //-----------------------------------------------------------------

    {   HRESULT hr;

        hr = StringFromGUID2(Clsid, pstr, CHARS_IN_GUID);
    }


    wsprintf(Buffer, TEXT("%ls\\%ls"), szRegFilter, pstr);
    hKey = GetRegKey( Buffer );

    if (hKey==NULL) {
        return VFW_E_BAD_KEY;
    }

    //-----------------------------------------------------------------
    // Add strName as a value for HKCR\Filter\<clsid>
    //-----------------------------------------------------------------

    lRcSet = SetRegString(hKey, NULL, strName);

    lRC = RegCloseKey(hKey);
    ASSERT (lRC==0);

    if (lRcSet!=ERROR_SUCCESS) {
        return AmHresultFromWin32(lRcSet);
    }

    // ------------------------------------------------------------------------
    // Add key HKCR\CLSID\<clsid>
    // ------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%ls\\%ls"), szCLSID, pstr);

    hKey = GetRegKey( Buffer );

    if (hKey==NULL) {
        return VFW_E_BAD_KEY;
    }

    // should this bit be kept???
    //
    // // ------------------------------------------------------------------------
    // // Add strName as the new value for HKCR\CLSID\<clsid>
    // // ------------------------------------------------------------------------
    //
    // lRcSet = SetRegString(hKey, NULL, strName);
    //
    // if (lRcSet!=ERROR_SUCCESS) {
    //     lRC = RegCloseKey(hKey);
    //     return AmHresultFromWin32(lRcSet);
    // }


    //-----------------------------------------------------------------
    // Add dwMerit as a value for HKCR\Filter\<clsid> Merit
    //-----------------------------------------------------------------
    lRcSet = SetRegDword(hKey, szMerit, dwMerit);
    lRC = RegCloseKey(hKey);
    ASSERT(lRC==0);

    if (lRcSet!=ERROR_SUCCESS) {
        return AmHresultFromWin32(lRcSet);
    }


    // // ------------------------------------------------------------------------
    // // Add key HKCR\CLSID\<clsid>\InprocServer32
    // // (Precond: Buffer still holds HKCR\CLSID\<clsid>)
    // // ------------------------------------------------------------------------
    //
    // TCHAR NewBuffer[MAX_KEY_LEN];
    //
    // wsprintf(NewBuffer, TEXT("%s\\%ls"), Buffer, szInproc);
    //
    // hKey = GetRegKey( NewBuffer );
    //
    // if (hKey==NULL) {
    //   return VFW_E_BAD_KEY;
    // }


    // // ------------------------------------------------------------------------
    // // Add strBinPath as the new value for HKCR\CLSID\<clsid>\InprocServer32
    // // ------------------------------------------------------------------------
    //
    // lRC = SetRegString( hKey, NULL, strBinPath );
    //
    // if (lRC!=ERROR_SUCCESS) {
    //    RegCloseKey(hKey);
    //    return AmHresultFromWin32(lRC);
    // }
    //
    // lRC = SetRegString( hKey, szThreadingModel, szBoth );
    //
    // if (lRC!=ERROR_SUCCESS) {
    //    RegCloseKey(hKey);
    //    return AmHresultFromWin32(lRC);
    // }
    //
    // RegCloseKey(hKey);


    // ------------------------------------------------------------------------
    // Add key HKCR\CLSID\<clsid>\Pins
    // (Precond: Buffer still holds HKCR\CLSID\<clsid>)
    // Buffer gets mangled.
    // ------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%s\\%ls"), Buffer, szPins);

    HKEY hKeyNew = GetRegKey( Buffer );

    if (hKeyNew==NULL) {
        RegCloseKey(hKey);
        return VFW_E_BAD_KEY;
    }
    lRC = RegCloseKey(hKeyNew);
    ASSERT(lRC==0);

    return NOERROR;


} // RegisterFilter



//=============================================================================
// Register an instance of a filter.  This is not needed if there is only one
// instance of the filter (e.g. there is only one sound card in the machine)
// or if all instances of the filter are equivalent.  It is used to distinguish
// between instances of a filter where the executable is the same - for instance
// two sound cards, one of which drives studio monitors and one broadcasts.
//=============================================================================

STDMETHODIMP CFilterMapper2::RegisterFilterInstance
    ( CLSID  Clsid, // GUID of the filter
      LPCWSTR pName, // Descriptive name of instance.
      CLSID *pMRId   // Returned Media Resource Id which identifies the instance,
                     // a locally unique id for this instance of this filter
    )
{
    UNREFERENCED_PARAMETER(Clsid);
    UNREFERENCED_PARAMETER(pName);
    UNREFERENCED_PARAMETER(pMRId);
    return E_NOTIMPL;
} // RegisterFilterInstance



//=============================================================================
//
// RegisterPin (IFilterMapper)
//
// Register a pin
// This does not exhibit transactional semantics.
// Thus it is possible to get a partially registered filter if it fails.
//=============================================================================

STDMETHODIMP CFilterMapper2::RegisterPin
    ( CLSID   clsFilter,          // GUID of filter
      LPCWSTR strName,            // Descriptive name of the pin
      BOOL    bRendered,          // The filter renders this input
      BOOL    bOutput,            // TRUE iff this is an Output pin
      BOOL    bZero,              // TRUE iff OK to have zero instances of pin
                                  // In this case you will have to Create a pin
                                  // to have even one instance
      BOOL   bMany,               // TRUE iff OK to create many instance of  pin
      CLSID  clsConnectsToFilter, // Filter it connects to if it has a
                                  // subterranean connection, else NULL
      LPCWSTR strConnectsToPin    // Pin it connects to if it has a
                                  // subterranean connection, else NULL
    )
{
    CheckPointer(strName, E_POINTER);
    HKEY hKeyPins;        // \HKCR\<strFilter>\Pins
    HKEY hKeyPin;         // \HKCR\<strFilter>\Pins\<n>
    LONG lRC;             // return code from some operation
    DWORD dwDisp;
    TCHAR Buffer[MAX_KEY_LEN];
    HRESULT hr;
    DWORD  dwOptions = REG_OPTION_NON_VOLATILE;

    //-----------------------------------------------------------------
    // Check integrity of parameters
    //-----------------------------------------------------------------

    if (bRendered && bOutput ) {
       return E_INVALIDARG;
                           //  A Filter can render only an input pin not output
    }

    // CAN now have ConnectsToPin without ConnectsToFilter

    // Cannot have ConnectsToFilter without ConnectsToPin
    if (  (NULL==strConnectsToPin || strConnectsToPin[0]==L'\0')
       && CLSID_NULL!=clsConnectsToFilter
       ) {
        return E_INVALIDARG;
    }

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        clsFilter);


    //-----------------------------------------------------------------
    // hKeyPins = open key for Create \HKCR\CLSID\<strFilter>\Pins
    //-----------------------------------------------------------------
    OLECHAR  strFilter[CHARS_IN_GUID];
    hr = StringFromGUID2(clsFilter, strFilter, CHARS_IN_GUID);
    wsprintf(Buffer, TEXT("%ls\\%ls"), szCLSID, strFilter);
    if (!CheckRegKey( Buffer ))
        return VFW_E_BAD_KEY;

    wsprintf(Buffer, TEXT("%ls\\%ls\\%ls"), szCLSID, strFilter, szPins);

    hKeyPins = GetRegKey( Buffer );
    if (hKeyPins==NULL) {
       return VFW_E_BAD_KEY;
    }


    //-----------------------------------------------------------------
    // hKeyPin = open key for \HKCR\CLSID\<strFilter>\Pins\<Name>
    //-----------------------------------------------------------------
    wsprintf(Buffer, TEXT("%ls"), strName);

    lRC = RegCreateKeyEx( hKeyPins             // open key
                        , Buffer               // subkey name
                        , 0                    // reserved
                        , NULL                 // ??? What is a class?
                        , dwOptions            // volatile or not
                        , KEY_WRITE
                        , NULL                 // Security attributes
                        , &hKeyPin
                        , &dwDisp
                        );
    if (lRC!=ERROR_SUCCESS) {
       RegCloseKey(hKeyPins);
       return AmHresultFromWin32(lRC);
    }


    //-----------------------------------------------------------------
    // Don't need the higher level key any more, so tidy it up now
    //-----------------------------------------------------------------
    lRC = RegCloseKey(hKeyPins);
    ASSERT(lRC==0);


    //-----------------------------------------------------------------
    // Create the key \HKCR\CLSID\<strFilter>\Pins\<Name>\Types
    //-----------------------------------------------------------------
    wsprintf(Buffer, TEXT("%ls"), szTypes);
    HKEY hKeyTypes;

    lRC = RegCreateKeyEx( hKeyPin              // open key
                        , Buffer               // subkey name
                        , 0                    // reserved
                        , NULL                 // ??? What is a class?
                        , dwOptions            // volatile or not
                        , KEY_WRITE
                        , NULL                 // Security attributes
                        , &hKeyTypes
                        , &dwDisp
                        );
    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }

    // We don't need to keep the types key open, we just create it.
    lRC = RegCloseKey(hKeyTypes);
    ASSERT(lRC==0);

    //-----------------------------------------------------------------
    // register whether the direction of this pin is Out (1) or In (0)
    //-----------------------------------------------------------------
    lRC = SetRegDword( hKeyPin, szDirection, !!bOutput);

    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }


    //-----------------------------------------------------------------
    // register whether data on this pin is rendered - only makes sense for Input pins
    //-----------------------------------------------------------------
    lRC = SetRegDword( hKeyPin, szIsRendered, !!bRendered);

    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }


    //-----------------------------------------------------------------
    // register whether this pin is optional
    //-----------------------------------------------------------------
    lRC = SetRegDword( hKeyPin, szAllowedZero, !!bZero);

    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }


    //-----------------------------------------------------------------
    // register whether we can create several of this pin
    //-----------------------------------------------------------------
    lRC = SetRegDword( hKeyPin, szAllowedMany, !!bMany);

    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }

    //-----------------------------------------------------------------
    // register which filter this pin connects to
    //-----------------------------------------------------------------
    if (CLSID_NULL!=clsConnectsToFilter) {

        //.................................................................
        // register in which filter this subterranean stream emerges
        //.................................................................
        lRC = SetRegClsid( hKeyPin, szConnectsToFilter, clsConnectsToFilter );

        if (lRC!=ERROR_SUCCESS) {
            RegCloseKey(hKeyPin);
            return AmHresultFromWin32(lRC);
        }

    } else {
        //.................................................................
        // Doesn't connect to another filter - kill any previous registration
        //.................................................................
        lRC = DeleteRegValue( hKeyPin, szConnectsToFilter );
        if (lRC!=ERROR_SUCCESS &&  lRC!=ERROR_FILE_NOT_FOUND) {
            RegCloseKey(hKeyPin);
            return AmHresultFromWin32(lRC);
        }
    }

    //-----------------------------------------------------------------
    // register which pin this pin connects to
    //-----------------------------------------------------------------
    if ( NULL!=strConnectsToPin && strConnectsToPin[0]!=L'\0' ) {

        //.................................................................
        // register on which pin this data stream emerges
        //.................................................................
        lRC = SetRegString( hKeyPin, szConnectsToPin, strConnectsToPin );
        if (lRC!=ERROR_SUCCESS) {
            RegCloseKey(hKeyPin);
            return AmHresultFromWin32(lRC);
        }
    } else {

        //.................................................................
        // This pin doesn't emerge - kill any previous registration
        //.................................................................
        lRC = DeleteRegValue( hKeyPin, szConnectsToPin );
        if (lRC!=ERROR_SUCCESS &&  lRC!=ERROR_FILE_NOT_FOUND) {
            RegCloseKey(hKeyPin);
            return AmHresultFromWin32(lRC);
        }
    }



    // ------------------------------------------------------------------------
    // Tidy up any litter
    // ------------------------------------------------------------------------
    lRC = RegCloseKey(hKeyPin);
    ASSERT(lRC==0);


    return NOERROR;


} // RegisterPin


//  (IFilterMapper) method
STDMETHODIMP CFilterMapper2::RegisterPinType
    ( CLSID  clsFilter,           // GUID of filter
      LPCWSTR strName,            // Descriptive name of the pin
      CLSID  clsMajorType,        // Major type of the data stream
      CLSID  clsSubType           // Sub type of the data stream
    )
{
    CheckPointer(strName, E_POINTER);

    //-----------------------------------------------------------------
    // Convert all three clsids to strings
    //-----------------------------------------------------------------
    OLECHAR strFilter[CHARS_IN_GUID];
    StringFromGUID2(clsFilter, strFilter, CHARS_IN_GUID);

    OLECHAR  strMajorType[CHARS_IN_GUID];
    StringFromGUID2(clsMajorType, strMajorType, CHARS_IN_GUID);

    OLECHAR strSubType[CHARS_IN_GUID];
    StringFromGUID2(clsSubType, strSubType, CHARS_IN_GUID);

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        clsFilter);


    //-----------------------------------------------------------------
    // Open \HKCR\CLSID\<filterClsid>\Pins\<PinName>\Types
    //                           \<strMajorType>\strSubType
    // as hkType
    //-----------------------------------------------------------------
    TCHAR Buffer[2*MAX_KEY_LEN];      // this is a long one!
    wsprintf( Buffer, TEXT("%ls\\%ls\\%ls\\%ls\\%ls")
            , szCLSID, strFilter, szPins, strName, szTypes
            );
    if (!CheckRegKey(Buffer)) {
        return VFW_E_BAD_KEY;
    }

    wsprintf( Buffer, TEXT("%ls\\%ls\\%ls\\%ls\\%ls\\%ls\\%ls")
            , szCLSID, strFilter, szPins, strName, szTypes
            , strMajorType, strSubType);

    HKEY hkType;
    hkType = GetRegKey( Buffer );
    if (hkType==NULL) {
        return VFW_E_BAD_KEY;
    }

    RegCloseKey(hkType);

    return NOERROR;
} // RegisterPinType;


//=============================================================================
//
// UnRegisterFilter  (IFilterMapper)
//
// Unregister a filter and any pins that it might have.
//=============================================================================
STDMETHODIMP CFilterMapper2::UnregisterFilter
    ( CLSID clsFilter     // GUID of filter
    )
{
    TCHAR Buffer[MAX_KEY_LEN];

    OLECHAR  strFilter[CHARS_IN_GUID];
    StringFromGUID2(clsFilter, strFilter, CHARS_IN_GUID);

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        clsFilter);

    //--------------------------------------------------------------------------
    // Delete HKCR\Filter\<clsid> and all below
    //--------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%ls\\%ls"), szRegFilter, strFilter);

    EliminateSubKey(HKEY_CLASSES_ROOT, Buffer);


    //--------------------------------------------------------------------------
    // Remove Merit value
    // Delete HKCR\CLSID\<clsid>\Pins and all below
    //--------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%ls\\%ls"), szCLSID, strFilter);

    HKEY hkey;
    LONG lRC = RegOpenKeyEx( HKEY_CLASSES_ROOT    // open key
                           , Buffer               // subkey name
                           , 0                    // reserved
                           , MAXIMUM_ALLOWED      // security access
                           , &hkey
                           );

    if (lRC==ERROR_SUCCESS)  {
        lRC = RegDeleteValue( hkey, TEXT("Merit") );
        RegCloseKey(hkey);
    }

    lstrcat( Buffer, TEXT("\\Pins") );

    EliminateSubKey(HKEY_CLASSES_ROOT, Buffer);

    return NOERROR;

} // UnregisterFilter



//=====================================================================
//
// UnregisterPin (IFilterMapper)
//
// Unergister a pin, completely removing it and everything underneath
//=====================================================================

STDMETHODIMP CFilterMapper2::UnregisterPin
    ( CLSID   clsFilter,    // GUID of filter
      LPCWSTR strName    // Descriptive name of the pin
    )
{
    CheckPointer(strName, E_POINTER);

    TCHAR Buffer[MAX_KEY_LEN];

    OLECHAR strFilter[CHARS_IN_GUID];
    StringFromGUID2(clsFilter, strFilter, CHARS_IN_GUID);

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        clsFilter);

    //--------------------------------------------------------------------------
    // Delete HKCR\CLSID\<clsid>\Pins\<strName>
    //--------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%ls\\%ls\\%ls\\%ls"), szCLSID, strFilter, szPins, strName);
    EliminateSubKey(HKEY_CLASSES_ROOT, Buffer);
    return NOERROR;
} // UnregisterPin



// (IFilterMapper) method
STDMETHODIMP CFilterMapper2::UnregisterFilterInstance
    ( CLSID MRId       // Media Resource Id of this instance
    )
{
    UNREFERENCED_PARAMETER(MRId);
    return E_NOTIMPL;
} // UnregisterFilterInstance



//========================================================================
//========================================================================
//
// Registry cacheing - see class CMapperCache in mapper.h
//
//========================================================================
//========================================================================



CMapperCache::CMapperCache()
    : m_bRefresh(TRUE)
    , m_ulCacheVer(0)
    , m_dwMerit(MERIT_PREFERRED)
    , m_plstFilter(NULL)
    , m_fBuildingCache(FALSE)
    , m_pCreateDevEnum(NULL)
{
    //  See if we're on a 16-color machine
    HDC hdc = GetDC(NULL);
    if (hdc) {
        if (4 == GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES)) {
            m_b16Color = true;
        } else {
            m_b16Color = false;
        }
        ReleaseDC(NULL, hdc);
    } else {
        m_b16Color = false;
    }
}


//======================================================================
// Del
//
// Delete all the entries in pLstFil to leave the list allocated but empty
//======================================================================

void CMapperCache::Del(CFilterList * plstFil)
{
    if (plstFil==NULL) {
        return;
    }

    CMapFilter * pFil;
    while((LPVOID)(pFil = plstFil->RemoveHead())) {
        delete pFil;
    }
}// Del


CMapperCache::~CMapperCache()
{
    // One hopes that ref-counting etc. ensure that this cannot be re-entered
    // and so it doesn't need locking.
    if (m_plstFilter!=NULL) {
        Del( m_plstFilter);
        delete m_plstFilter;
    }
    if (m_pCreateDevEnum!=NULL) {
        m_pCreateDevEnum->Release();
    }
}// ~CMapperCache


//======================================================================
//
// CacheFilter
//
// Read everything in the registry about it into *pFil
//======================================================================
LONG CMapperCache::CacheFilter(IMoniker *pDevMon, CMapFilter * pFil)
{
    ASSERT(pFil->pDeviceMoniker == 0);
    LONG lRc = ERROR_GEN_FAILURE;

    IPropertyBag *pPropBag;
    // FILGPERF(MSR_START(iBindCache));
    HRESULT hr = pDevMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    // FILGPERF(MSR_STOP(iBindCache));
    if(SUCCEEDED(hr))
    {
        // open clsid/{filter-clsid} key
        VARIANT varbstrClsid;
        varbstrClsid.vt = VT_BSTR;
        varbstrClsid.bstrVal = 0;
        //FILGPERF(MSR_START(iReadCLSID));
        {
            // try reading the FilterData value
            //
            VARIANT varFilData;
            varFilData.vt = VT_UI1 | VT_ARRAY;
            varFilData.parray = 0; // docs say zero this

            //FILGPERF(MSR_START(iReadFilterData));
            hr = pPropBag->Read(L"FilterData", &varFilData, 0);
            //FILGPERF(MSR_STOP(iReadFilterData));
            if(SUCCEEDED(hr))
            {
                BYTE *pbFilterData;
                DWORD dwcbFilterDAta;

                ASSERT(varFilData.vt == (VT_UI1 | VT_ARRAY));
                dwcbFilterDAta = varFilData.parray->rgsabound[0].cElements;

                EXECUTE_ASSERT(SafeArrayAccessData(
                    varFilData.parray, (void **)&pbFilterData) == S_OK);

                ASSERT(pbFilterData);

                REGFILTER2 *prf2;
                REGFILTER2 **pprf2 = &prf2;
                //FILGPERF(MSR_START(iUnSquish));
                hr = UnSquish(
                    pbFilterData, dwcbFilterDAta,
                    &pprf2);
                //FILGPERF(MSR_STOP(iUnSquish));

                if(hr == S_OK)
                {
                    pFil->m_prf2 = prf2;
                    ASSERT(pFil->m_prf2->dwVersion == 2);

                    // this is the only place that sets the
                    // success code.
                    ASSERT(lRc != ERROR_SUCCESS);
                    lRc = ERROR_SUCCESS;
                }

                EXECUTE_ASSERT(SafeArrayUnaccessData(
                    varFilData.parray) == S_OK);

                EXECUTE_ASSERT(VariantClear(
                    &varFilData) == S_OK);

            }
            else
            {
                lRc = ERROR_GEN_FAILURE;
            }

            if(lRc == ERROR_SUCCESS)
            {
                pFil->pDeviceMoniker = pDevMon;
                pDevMon->AddRef();

                // HACK HACK for 16-color mode - increase
                // the merit of the ditherer
                CLSID clsid;
                if (m_b16Color &&
                    SUCCEEDED(GetMapFilterClsid(pFil, &clsid)) &&
                    clsid == CLSID_Dither) {
                    pFil->m_prf2->dwMerit = MERIT_PREFERRED;
                }
            }
        }

        pPropBag->Release();
    }
    else
    {
        lRc = ERROR_GEN_FAILURE;
    }

    return lRc;

} //CacheFilter


// Get the clsid for an entry (we only need this to return
// it to the application and anyway what can they do with it?)
HRESULT CMapperCache::GetMapFilterClsid(CMapFilter *pFilter, CLSID *pclsid)
{
    IPropertyBag *pPropBag;
    FILGPERF(MSR_START(iBindCache));
    HRESULT hr = pFilter->pDeviceMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    FILGPERF(MSR_STOP(iBindCache));
    if (FAILED(hr)) {
        return hr;
    }

    // open clsid/{filter-clsid} key
    VARIANT varbstrClsid;
    varbstrClsid.vt = VT_BSTR;
    varbstrClsid.bstrVal = 0;
    //FILGPERF(MSR_START(iReadCLSID));
    hr = pPropBag->Read(L"CLSID", &varbstrClsid, 0);
    //FILGPERF(MSR_STOP(iReadCLSID));
    if(SUCCEEDED(hr))
    {
        ASSERT(varbstrClsid.vt == VT_BSTR);
        WCHAR *strFilter = varbstrClsid.bstrVal;

        hr = CLSIDFromString(varbstrClsid.bstrVal, pclsid);
        SysFreeString(varbstrClsid.bstrVal);
    }
    pPropBag->Release();
    return hr;
}

//======================================================================
//
// Cache
//
// Read everything in the registry about filters into a hierarchy of lists
// the top list is m_plstFilter which points to a CFilterList
// see mapper.h for a picture
//======================================================================
HRESULT CMapperCache::Cache()
{
    CAutoLock foo(this);
    if (m_plstFilter!=NULL) {
        Del(m_plstFilter);
    } else {
        m_plstFilter = new CFilterList(NAME("Filter list"));
        if (m_plstFilter==NULL) {
            m_bRefresh = TRUE;
            return E_OUTOFMEMORY;
        }
    }

    //  Can we restore the cache?
    DWORD dwPnPVersion = 0;
    if (m_dwMerit > MERIT_DO_NOT_USE) {

        if (g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
            GetRegistryDWORD(HKEY_DYN_DATA,
                             TEXT("Config Manager\\Global"),
                             TEXT("Changed"),
                             &dwPnPVersion);
        }
        HRESULT hr = RestoreFromCache(dwPnPVersion);
        DbgLog((LOG_TRACE, 2, TEXT("RestoreFromCache returned %x"), hr));
        if (SUCCEEDED(hr)) {
            return S_OK;
        }

        // Destroy the partially built filter list.
        Del(m_plstFilter);
    }
    DbgLog((LOG_TRACE, 2, TEXT("Entering(CMapperCache::Cache)")));

    CAutoTimer T1(L"Build Mapper Cache");

    ASSERT(!m_fBuildingCache);
    // all exit points must reset this!
    m_fBuildingCache = TRUE;
    m_ulCacheVer++;

    //
    // add pnp filters
    //
    {
        HRESULT hr = S_OK;
        if (!m_pCreateDevEnum)
        {
            DbgLog((LOG_TRACE, 2, TEXT("Creating System Dev Enum")));
            hr = CoCreateInstance( CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                                   IID_ICreateDevEnum, (void**)&m_pCreateDevEnum);
        }

        if(SUCCEEDED(hr))
        {

            DbgLog((LOG_TRACE, 2, TEXT("Created System Dev Enum")));
            IEnumMoniker *pEmCat = 0;
            hr = m_pCreateDevEnum->CreateClassEnumerator(
                CLSID_ActiveMovieCategories,
                &pEmCat,
                0);

            if(hr == S_OK)
            {
                IMoniker *pMCat;
                ULONG cFetched;
                while(hr = pEmCat->Next(1, &pMCat, &cFetched),
                      hr == S_OK)
                {
                    IPropertyBag *pPropBag;
                    hr = pMCat->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                    if(SUCCEEDED(hr))
                    {
                        // read merit for category. may be missing in
                        // which case we treat as MERIT_DO_NOT_USE

                        VARIANT varMerit;
                        varMerit.vt = VT_I4;

                        HRESULT hrRead = pPropBag->Read(L"Merit", &varMerit, 0);
                        if((SUCCEEDED(hrRead) && varMerit.lVal >= (LONG)m_dwMerit) ||
                           (FAILED(hrRead) && m_dwMerit <= MERIT_DO_NOT_USE))
                        {

                            VARIANT varCatClsid;
                            varCatClsid.vt = VT_BSTR;
                            hr = pPropBag->Read(L"CLSID", &varCatClsid, 0);
                            if(SUCCEEDED(hr))
                            {
                                CLSID clsidCat;
                                if(CLSIDFromString(varCatClsid.bstrVal, &clsidCat) == S_OK)
                                {
                                    VARIANT varCatName;
                                    varCatName.vt = VT_BSTR;
                                    hr = pPropBag->Read(L"FriendlyName", &varCatName, 0);
                                    if(SUCCEEDED(hr))
                                    {
                                        DbgLog((LOG_TRACE, 2,
                                                TEXT("CMapperCache: enumerating %S"),
                                                varCatName.bstrVal));
                                    }
                                    else
                                    {
                                        DbgLog((LOG_TRACE, 2,
                                                TEXT("CMapperCache: enumerating %S"),
                                                varCatClsid.bstrVal));
                                    }

                                    {
                                    CAutoTimer Timer(L"Process Category ",
                                               SUCCEEDED(hr) ? varCatName.bstrVal : NULL);

                                    ProcessOneCategory(
                                            clsidCat,
                                            m_pCreateDevEnum);
                                    }
                                    if (SUCCEEDED(hr)) {
                                        SysFreeString(varCatName.bstrVal);
                                    }

                                    // ignore any errors
                                }

                                SysFreeString(varCatClsid.bstrVal);
                            } // catclsid
                        } // merit

                        pPropBag->Release();
                    } // bind to storage
                    else
                    {
                        break;
                    }

                    pMCat->Release();
                } // for loop

                pEmCat->Release();
            }
        }

        if(FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("mapper: pnp enum step failed")));
        }
        // ignore pnp errors for now
    }

    // all exit points must reset this!
    ASSERT(m_fBuildingCache);
    m_fBuildingCache = FALSE;

    if (m_dwMerit > MERIT_DO_NOT_USE) {
        HRESULT hr = SaveCacheToRegistry(MERIT_DO_NOT_USE + 1, dwPnPVersion);
        DbgLog((LOG_TRACE, 2, TEXT("SaveCacheToRegistry returned %x"), hr));
    }

    DbgLog((LOG_TRACE, 2, TEXT("Leaving(CMapperCache::Cache)")));
    return NOERROR;
} // Cache

HRESULT CMapperCache::ProcessOneCategory(REFCLSID clsid, ICreateDevEnum *pCreateDevEnum)
{
    FILGPERF(static int iPerfProc = MSR_REGISTER(TEXT("CMapperCache::ProcessOneCategory")));
    FILGPERF(static int iPerfCache = MSR_REGISTER(TEXT("CMapperCache::CacheFilter")));
    FILGPERF(iBindCache = MSR_REGISTER(TEXT("CMapperCache::BindFilter")));
    FILGPERF(iReadFilterData = MSR_REGISTER(TEXT("ReadFilterData")));
    FILGPERF(iReadCLSID = MSR_REGISTER(TEXT("Read CLSID")));
    FILGPERF(iUnSquish = MSR_REGISTER(TEXT("UnSquish")));
    FILGPERF(MSR_INTEGER(iPerfProc, clsid.Data1));
    FILGPERF(MSR_START(iPerfProc));

    HRESULT hr;

    DbgLog((LOG_TRACE, 2, TEXT("Process one category enter")));

    IEnumMoniker *pEm;
    hr = pCreateDevEnum->CreateClassEnumerator(
        clsid,
        &pEm,
        m_dwMerit > MERIT_DO_NOT_USE ? CDEF_MERIT_ABOVE_DO_NOT_USE : 0);

    DbgLog((LOG_TRACE, 2, TEXT("Start caching filters")));
    if(hr == S_OK)
    {
        ULONG cFetched;
        IMoniker *pM;

        while(hr = pEm->Next(1, &pM, &cFetched),
              hr == S_OK)
        {
            CMapFilter * pFil = new CMapFilter;
            if (pFil!=NULL) {

                // FILGPERF(MSR_START(iPerfCache));
                LONG lResult = CacheFilter(pM, pFil);
                // FILGPERF(MSR_STOP(iPerfCache));

                if (lResult==ERROR_SUCCESS)
                {
                    if(!m_plstFilter->AddTail(pFil))
                    {
                        lResult = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                if (lResult != ERROR_SUCCESS)
                {
                    delete pFil;

                    if(lResult == ERROR_GEN_FAILURE)
                    {
                        // some sort of registration problem. just
                        // skip over the filter.
                        hr = S_OK;

#ifdef DEBUG
                        WCHAR *szDisplayName = 0;
                        pM->GetDisplayName(0, 0, &szDisplayName);
                        if(szDisplayName)
                        {
                            DbgLog((
                                LOG_ERROR, 1,
                                TEXT("CMapperCache: skipped filter %S"),
                                szDisplayName));
                            CoTaskMemFree(szDisplayName);
                        }

#endif
                    }
                    else
                    {
                        hr = AmHresultFromWin32(lResult);
                        m_bRefresh = TRUE;
                    }
                }
            } else {
                hr = E_OUTOFMEMORY;
                m_bRefresh = TRUE;
            }

            pM->Release();

            if(FAILED(hr))
                break;
        }

        pEm->Release();
    }

    FILGPERF(MSR_STOP(iPerfProc));
    DbgLog((LOG_TRACE, 2, TEXT("Process one category leave")));

    return hr;
}



//======================================================================
//
// Refresh
//
// If the cache does not yet exist or if it's out of date then
// delete anything we have and re-create it from the registry.
// return NOERROR if the cache was up to date
//        S_FALSE if we re-cached
//        failure code if we failed
//======================================================================
HRESULT CMapperCache::Refresh()
{
    HRESULT hr;
    BOOL bNew = (m_plstFilter==NULL);

    if (m_plstFilter==NULL || m_bRefresh) {
        m_bRefresh = FALSE;
        Del(m_plstFilter);

        hr = Cache();
        if (FAILED(hr)) return hr;
        Sort(m_plstFilter);

        return (m_bRefresh ? E_OUTOFMEMORY : (bNew ? NOERROR : S_FALSE));
    }
    return NOERROR;
} // Refresh


//======================================================================
//
// BreakCache
//
// Mark the cache as out of date.
//
//======================================================================
HRESULT CMapperCache::BreakCacheIfNotBuildingCache()
{
    CAutoLock foo(this);

    // don't break the cache while building it. many failure paths set
    // m_bRefresh manually
    if(!m_fBuildingCache) {
        m_bRefresh = TRUE;
    }
    return NOERROR;
}


//===========================================================================
// The cache has to be sorted so as to try the most useful filters first.
// The sorting is first on Merit, then on number of output pins (the fewer
// the better, then on number of input pins (the more the better)
// The sorting is done by using a merge sort.  This is an n Log n sorting
// algorithm (so it's broadly speaking as effecient as quicksort) and
// is suitable for sorting lists (i.e. sequential rather than random access).
// it uses very little intermediate storage, doesn't copy nodes.
//===========================================================================

// I haven't tried to make this a reusable sort because we don't seem to
// sort lists very often.  It could easily be made generic.

// this is gonna generate objects like they're going out of fashion
// want lightweight lists!  The number of allocated lists is equal to
// the number of sections in the original filter list.



//=======================================================================
// CountPins
//
// set cIn and cOut to the number of input and output pins respectively
// on filter pf
//=======================================================================
void CMapperCache::CountPins(CMapFilter * pf, int &cIn, int &cOut)
{
    cIn = 0;
    cOut = 0;
    for(UINT iPin = 0; iPin < pf->m_prf2->cPins; iPin++)
    {
        const REGFILTERPINS2 * pPin = &pf->m_prf2->rgPins2[iPin];
        if (pPin->dwFlags & REG_PINFLAG_B_OUTPUT) {
            ++cOut;
        } else {
            ++cIn;
        }
    }
} // CountPins



//=======================================================================
//
// Compare
//
// return -1 if pfAA < pfB, 0 if pfA == pfB, 1 if pfA > pfB
// < means lower Merit or failing that
//   more output pins or failing that
//   fewer input pins
// (Rationale - we work downstream, output pins are a nuisance, we're
// liable to have to render them too.  Input pins can be handy.
// I may change my mind about the input pins.  Current thinking is that
// a filter will always work even if not all its inputs are connected
//=======================================================================
int CMapperCache::Compare(CMapFilter * pfA, CMapFilter * pfB)
{
    if (pfA->m_prf2->dwMerit < pfB->m_prf2->dwMerit)
        return -1;
    if (pfA->m_prf2->dwMerit > pfB->m_prf2->dwMerit)
        return 1;

    // counts of pins
    int cAIn;
    int cAOut;
    int cBIn;
    int cBOut;
    CountPins(pfA, cAIn, cAOut);
    CountPins(pfB, cBIn, cBOut);

    if (cAOut > cBOut)
        return -1;
    if (cAOut < cBOut)
        return 1;

    if (cAIn < cBIn)
        return -1;
    if (cAIn > cBIn)
        return 1;

    return 0;

} // Compare


//=======================================================================
//
// Split
//
// empty fl and put the bits into fll so that each bit in fll is sorted
// the set of filters is preserved, i.e. the set of filters in fl is that
// same as the set of filters in all the fll.  Part of merge-sort.
// Allocates a lot of lists which are freed in Merge.
//=======================================================================
HRESULT CMapperCache::Split(CFilterList * pfl, CFilterListList & fll)
{
    // Move steadily through fl comparing successive elements as long as
    // we find they compare OK, keep trucking.  When we find one that's
    // out of sequence, split off the part before it into a new element
    // that gets added to fll.

    POSITION pos;
    pos = pfl->GetHeadPosition();
    if (pos==NULL) {
        return NOERROR;           // everything's empty
    }

    // *pflNew will become the next section to go onto fll
    CFilterList * pflNew = new CFilterList( NAME("fragment"));
    if (pflNew==NULL) {
        // Oh we're in desperate trouble.
        return E_OUTOFMEMORY;
    }

    for( ; ; ) {

       // (partial) loop invariant:
       //   Elements are preserved:
       //     the concatenation of all the lists in fll followed by fl
       //     makes up the original fl.
       //   Every list within fll is sorted.
       //   fl[...pos] is sorted.

       // We split the list after pos if:
       //   There is no element after pos OR
       //   The element after pos is out of sequence w.r.t. pos

       BOOL bSplit = FALSE;
       POSITION pNext = pfl->Next(pos);
       if (pNext==NULL)
           bSplit = TRUE;
       else {
           CMapFilter * pfA;
           CMapFilter * pfB;
           pfA = pfl->Get(pos);
           pfB = pfl->Get(pNext);

           if (0>Compare(pfA, pfB)) {
               bSplit = TRUE;
           }
       }

       if (bSplit) {
           pfl->MoveToTail(pos, pflNew);
           pos = pNext;
           if(!fll.AddTail( pflNew))
           {
               delete pflNew;
               return E_OUTOFMEMORY;
           }

           if (pos!=NULL) {
               pflNew = new CFilterList( NAME("Fragment"));
               if (pflNew==NULL) {
                   return E_OUTOFMEMORY;
               }
           } else {
               break;
           }
       }
       pos = pNext;
    }
    return NOERROR;

} // Split



//=========================================================================
//
// MergeTwo
//
// Merge pflA and pflB into pflA.
// the result will have all the original elements and be well sorted.
// Does not free storage of either one.
// Part of merge-sort
//=========================================================================
void CMapperCache::MergeTwo( CFilterList * pflA, CFilterList * pflB)
{
    POSITION pos = pflA->GetHeadPosition();

    // This is a loop to traverse B, meanwhile pos tries to keep pace through A
    for (; ; ) {
        CMapFilter * pfB = pflB->RemoveHead();
        if (pfB==NULL) {
            return;
        }

        // traverse pos past any elements that go before pfB
        // we want earlier elements to be >= subsequent ones
        // pos stops at the first element that goes after pfB
        // that might be NULL if it gets to the end.
        for (; ; ) {
            CMapFilter * pfA = pflA->Get(pos);
            if (Compare(pfA, pfB)<0) {
                break;                // b goes before pos
            }
            // b doesn't go before pos, so move pos on
            pos = pflA->Next(pos);
            if (pos==NULL) {
                // everything left in B goes after the end of A
                // Add the one we removed
                pflA->AddTail(pfB);
                // Add allthe rest
                pflB->MoveToTail(pflB->GetTailPosition(), pflA);
                // and we are completely done.
                return;
            }
        }
        pflA->AddBefore(pos, pfB);
    }
} // MergeTwo



//=========================================================================
//
// Merge
//
// Precondition: all the lists in fll must be sorted
// pfl must be empty.
//
// Merge all the lists in fll into one and set pfl to that.
// do the merging so as to keep the result sorted
// part of merge-sort
//=========================================================================
void CMapperCache::Merge( CFilterListList & fll, CFilterList * pfl)
{
    // while there are more than two lists in pfl, take the first two off
    // the queue, merge them and put the resulting merged list back on
    // the end of the queue.
    // When there's only one left, return that as the new *pfl

    for (; ; ) {
        CFilterList * pflA = fll.RemoveHead();
        if (pflA==NULL) {
           return;                   // the whole thing's empty!
        }
        CFilterList * pflB = fll.RemoveHead();
        ASSERT(pflA != NULL);
        if (pflB ==NULL) {
            pflA->MoveToTail(pflA->GetTailPosition(), pfl);
            delete pflA;
            return;
        }
        MergeTwo(pflA, pflB);
        fll.AddTail(pflA);
        delete pflB;
    }
} // Merge


//=========================================================================
//
// DbgDumpCache
//
// Dump the cache, showing enough fields that we can tell if we sorted it
//=========================================================================
void CMapperCache::DbgDumpCache(CFilterList * pfl)
{
    DbgLog(( LOG_TRACE, 3, TEXT("FilterMapper Cache Dump:-")));

    POSITION pos;
    for ( pos = pfl->GetHeadPosition(); pos!=NULL; /*no-op*/ ) {
        CMapFilter * pFil = pfl->GetNext(pos);  // Get AND Next of course!
        int cIn;
        int cOut;
        CountPins(pFil, cIn, cOut);
        DbgLog(( LOG_TRACE, 4
           , TEXT("Cache: Merit %d in %d out %d name %ls")
           , pFil->m_prf2->dwMerit, cIn, cOut
           , DBG_MON_GET_NAME(pFil->pDeviceMoniker) ));

        ASSERT(pFil->m_prf2->dwVersion == 2);

        for(UINT iPin = 0; iPin < pFil->m_prf2->cPins2; iPin++)
        {
            const REGFILTERPINS2 * pPin = &pFil->m_prf2->rgPins2[iPin];

            for(UINT iType = 0; iType < pPin->nMediaTypes; iType++)
            {
                const REGPINTYPES * pType = &pPin->lpMediaType[iType];

                DbgLog(( LOG_TRACE, 4 , TEXT("Major %x Sub %x") ,
                         pType->clsMajorType ? pType->clsMajorType->Data1 : 0,
                         pType->clsMinorType ? pType->clsMinorType->Data1 : 0 ));
            }
        }
    }
} // DbgDumpCache


//=========================================================================
//
// Sort
//
// Sort the filter list so that filters which should be tried first come first
//=========================================================================
void CMapperCache::Sort( CFilterList * &pfl)
{
    // Algorithm: split the list into bits where each bit is well sorted
    // merge the bits pairwise until there's ony one left.
    // The ideal strategy is to always pick the two smallest lists to merge
    // of course this is supposing that finding them is free, which it's not
    // We just merge 1-2, 3-4, 5-6, 7-8, 9-10 etc in the first pass then
    // merge 1+2-3+4, 5+6-7+8 etc in as two, in pass three 1+2+3+4-5+6+7+8
    // etc.  It's probably not bad though you can get ill-conditioned data.

    CFilterListList fll( NAME("sort's list of lists"));   // a list of CFilterLists

    HRESULT hr = Split(pfl, fll);
    if (FAILED(hr)) {
        m_bRefresh = FALSE;  // This is a hacky way to make the error surface
                             // with minimal rewriting.
    }
    ASSERT(SUCCEEDED(hr));
    // We still merge, even if we ran out of memory as it will clean up the mess.
    Merge(fll, pfl);
    DbgDumpCache(pfl);

} // Sort


//==============================================================================
// FindType
//
// Search through the list of types for *pPin
// to see if there is a pair of types that match clsMajor and clsSub
// return (a match is found)
//==============================================================================
BOOL CMapperCache::FindType(
    const REGFILTERPINS2 * pPin,
    const GUID *pTypes,
    DWORD cTypes,
    const REGPINMEDIUM *pMedNeeded,
    const CLSID *pPinCatNeeded,
    bool fExact,
    BOOL bPayAttentionToWildCards,
    BOOL bDoWildCards)
{
    //  When we're doing wild card stuff we don't want to match on
    //  a wild card if there's also an exact match
    BOOL bMatched = FALSE;

    //     if (clsMajor==CLSID_NULL) {
    //         DbgLog(( LOG_TRACE, 4
    //            , TEXT("Wild card match (requested NULL type)") ));

//         return TRUE;       // wild card
//     }

    // first test pin categories, then  mediums then media types
    bool fMediumsOk = false, fPinCatOk = false;

    // caller doesn't care ||
    // items specified and match ||
    // caller accepts filter with wildcard item
    //
    if((pPinCatNeeded == 0) ||
       (pPinCatNeeded != 0 && pPin->clsPinCategory != 0 && *pPinCatNeeded == *pPin->clsPinCategory) ||
       (!fExact && pPin->clsPinCategory == 0))
    {
        fPinCatOk = true;

        DbgLog(( LOG_TRACE, 5 ,
                 TEXT("pin categories match: Req (%08x) Found(%08x)") ,
                 pPinCatNeeded ? pPinCatNeeded->Data1 : 0,
                 pPin->clsPinCategory ? pPin->clsPinCategory->Data1 : 0
                 ));
    }
    else
    {
        DbgLog(( LOG_TRACE, 5 ,
                 TEXT("pin categories don't match: Req (%08x) Found(%08x)") ,
                 pPinCatNeeded ? pPinCatNeeded->Data1 : 0,
                 pPin->clsPinCategory ? pPin->clsPinCategory->Data1 : 0
                 ));
    }


    if(fPinCatOk)
    {
        if(pPin->nMediums == 0)
        {
            // this pin advertises no mediums, so pin is ok if caller
            // doesn't care or caller accepts wildcard items.
            fMediumsOk = (pMedNeeded == 0 || !fExact);

            if(fMediumsOk)
            {
                DbgLog(( LOG_TRACE, 5 ,
                         TEXT("mediums match: Req (%08x) Found(*)") ,
                         pMedNeeded ? pMedNeeded->clsMedium.Data1 : 0));
            }
            else
            {
                DbgLog(( LOG_TRACE, 5 ,
                         TEXT("mediums don't match: Req (%08x) Found(*)") ,
                         pMedNeeded ? pMedNeeded->clsMedium.Data1 : 0));
            }
        }
        else
        {
            for (UINT iMedium = 0;
                 iMedium < pPin->nMediums;
                 iMedium++)
            {
                ASSERT(!fMediumsOk);
                const REGPINMEDIUM *pMedPin = &pPin->lpMedium[iMedium];

                // no reason to allocate a null medium
                ASSERT(pMedPin != 0);

                // caller doesn't care ||
                // items specified and match ||
                // caller accepts filter with wildcard item
                //
                if((pMedNeeded == 0) ||
                   (pMedNeeded != 0 && pMedPin != 0 && IsEqualMedium(pMedNeeded, pMedPin)) ||
                   (!fExact && pMedPin == 0))
                {
                    DbgLog(( LOG_TRACE, 5 ,
                             TEXT("mediums match: Req (%08x) Found(%08x)") ,
                             pMedNeeded ? pMedNeeded->clsMedium.Data1 : 0,
                             pMedPin ? pMedPin->clsMedium.Data1 : 0));

                    fMediumsOk = true;
                    break;
                }

                DbgLog(( LOG_TRACE, 5 ,
                         TEXT("No medium match yet: Req (%08x) Found(%08x)") ,
                         pMedNeeded ? pMedNeeded->clsMedium.Data1 : 0,
                         pMedPin ? pMedPin->clsMedium.Data1 : 0));
            }
        }
    }

    if(fMediumsOk && fPinCatOk)
    {
        //  No types to match == wild card
        if (cTypes == 0) {
            return TRUE;
        }

        for (UINT iType = 0; iType < pPin->nMediaTypes; iType++)
        {

            const REGPINTYPES *pType = &pPin->lpMediaType[iType];

            // test maj then min types tests look like
            //
            // caller doesn't care ||
            // items specified and match ||
            // caller accepts filter with wildcard item
            //
            for (DWORD i = 0; i < cTypes; i++)
            {
                const GUID& clsMajor = pTypes[i * 2];
                const GUID& clsSub = pTypes[i * 2 + 1];
                const BOOL bMajorNull = clsMajor == CLSID_NULL;
                const BOOL bSubNull = clsSub == CLSID_NULL;
                if(bMajorNull ||
                   (pType->clsMajorType && clsMajor == *pType->clsMajorType) ||
                   (!fExact && (pType->clsMajorType == 0 || *pType->clsMajorType == CLSID_NULL)))
                {

                    if(bSubNull ||
                       (pType->clsMinorType && clsSub == *pType->clsMinorType) ||
                       (!fExact && (pType->clsMinorType == 0 || *pType->clsMinorType == CLSID_NULL)))
                    {
                        DbgLog(( LOG_TRACE, 4 ,
                                 TEXT("Types match: Req (%08x %08x) Found(%08x %08x)") ,
                                 clsMajor.Data1, clsSub.Data1 ,
                                 pType->clsMajorType ? pType->clsMajorType->Data1 : 0,
                                 pType->clsMinorType ? pType->clsMinorType->Data1 : 0));

                        //  Check the wild card stuff
                        if (!bPayAttentionToWildCards) {
                            return TRUE;
                        }

                        //  Only delay wild card matching on 2nd
                        //  or subsequent types
                        if (i > 0) {

                            BOOL bMatchedNull = bMajorNull || bSubNull;
                            if (!bDoWildCards && !bMatchedNull) {
                                return TRUE;
                            }
                            if (bDoWildCards && !bMatchedNull) {
                                //  Exact match so don't enumerate
                                return FALSE;
                            }
                            if (bDoWildCards && bMatchedNull) {
                                //  This is a match provided we
                                //  don't subsequently find an exact
                                //  match
                                bMatched = TRUE;
                            }
#if 0
                            if (!bDoWildCards && bMatchedNull) {
                                //  Not a match we're interested in
                            }
#endif
                        } else {
                            //  Always return a match on the first type
                            //  in the first pass
                            return !bDoWildCards;
                        }
                    }
                }
            }

#if 0
            DbgLog(( LOG_TRACE, 5 ,
                     TEXT("No type match yet: Req (%08x %08x) Found(%08x %08x)") ,
                     clsMajor.Data1, clsSub.Data1 ,
                     pType->clsMajorType ? pType->clsMajorType->Data1 : 0,
                     pType->clsMinorType ? pType->clsMinorType->Data1 : 0));
#endif
        }
    }

    return bMatched;

} // FindType


//==============================================================================
// CheckInput
//
// See if the types for pPin* match {clsMajor, clsSub}
// If bMustRender is TRUE, see if the pin hkPin has Renders set true
// if all OK, return TRUE - any error return FALSE.
//==============================================================================
BOOL CMapperCache::CheckInput(
    const REGFILTERPINS2 * pPin,
    const GUID *pTypes,
    DWORD cTypes,
    const REGPINMEDIUM *pMed,
    const CLSID *pPinCatNeeded,
    bool fExact,
    BOOL bMustRender,
    BOOL bDoWildCards)
{
    if ( bMustRender && !(pPin->dwFlags & REG_PINFLAG_B_RENDERER)) {
        return FALSE;
    }

    return FindType( pPin, pTypes, cTypes, pMed, pPinCatNeeded, fExact, TRUE, bDoWildCards);
} // CheckInput



//==============================================================================
//
// RegEnumFilterInfo
//
// Precondition:  The registration stuff is cached and tolerably up to date
//                or else never yet cached.
//
// Return clsid and name of filters matching { {clsInput, bRender}, clsOutput}
//
// set pos to NULL and call it.  On future calls recall it with the pos
// that it returned last time.  If it returns a pos of NULL then that's the end.
// Further calls would go through them again.
//
// if bInputNeeded is TRUE then it requires at least one input pin to match
// if it is false then it ignores input pins.
// if bOutputNeeded is TRUE then it requires at least one output pin to match
// if it is false then it ignores output pins.
// CLSID_NULL acts as a wild card and matches any type, otherwise a type
// found on a pin of the appropriate direction must match the types given.
// If bMustRender is TRUE then it will only enumerate filters which have an
// input pin which is rendered (and of the right type).
// bMustRender without bInputNeeded is nonsense.
// return NOERROR if we found one
//        S_FALSE if we fell off the end without finding one
//        failure code if we failed (e.g. out of sync)
//==============================================================================

HRESULT CMapperCache::RegEnumFilterInfo
    ( Cursor & cur          // cursor
    , bool bExactMatch      // no wildcards
    , DWORD   dwMerit       // at least this merit needed
    , BOOL bInputNeeded
    , const GUID *pInputTypes
    , DWORD cInputTypes
    , const REGPINMEDIUM *pMedIn
    , const CLSID *pPinCatIn
    , BOOL    bMustRender   // input pin must be rendered
    , BOOL    bOutputNeeded // at least one output pin wanted
    , const GUID *pOutputTypes
    , DWORD cOutputTypes
    , const REGPINMEDIUM *pMedOut
    , const CLSID *pPinCatOut
    , IMoniker **ppMoniker    // [out] moniker for filter
    , CLSID * clsFilter       // [out]
    , const LPWSTR Name       // [out]
    )
{


    // if the registry cache has never been used, set it up.
    CAutoLock foo(this);

    HRESULT hr;

    if(dwMerit < m_dwMerit)
    {
        m_bRefresh = TRUE;
        m_dwMerit = dwMerit;
    }

    hr = Refresh();
    if (FAILED(hr)) return hr;

#if 0
    DbgLog(( LOG_TRACE, 3
           , TEXT("RegEnumFilterInfo pin %8x (%d: %8x %8x %d)-(%d: %8x %8x)")
           , pos, bInputNeeded, clsInMaj.Data1, clsInSub.Data1, bMustRender
           , bOutputNeeded, clsOutMaj.Data1, clsOutSub.Data1 ));
#endif

    ASSERT(m_ulCacheVer >= cur.ver);

    if (cur.pos==NULL)
    {
        cur.pos = m_plstFilter->GetHeadPosition();
        cur.ver = m_ulCacheVer;
        cur.bDoWildCardsOnInput = false;
    }
    else if (hr==S_FALSE || cur.ver != m_ulCacheVer)
    {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    // until we find a filter that meets the criteria, or until we run out of them
    for ( /* cur.pos */; cur.pos!=NULL; /*no-op*/ ) {

        CMapFilter * pFil;
        pFil = m_plstFilter->GetNext(cur.pos); // Get pFil, side-effect pos onto Next
        ASSERT( pFil !=NULL );

        if (cur.pos == NULL && !cur.bDoWildCardsOnInput) {
            for (DWORD cType = 1; cType < cInputTypes; cType++) {
                if (pInputTypes[cType * 2] == GUID_NULL ||
                    pInputTypes[cType * 2 + 1] == GUID_NULL) {
                    cur.bDoWildCardsOnInput = true;
                    cur.pos = m_plstFilter->GetHeadPosition();
                    break;
                }
            }
        }

        // We have a filter - now decide if we want it.
        // CLSID_NULL for media types means automatically passes criterion

        BOOL bOutputOK = !bOutputNeeded;
        BOOL bInputOK  = !bInputNeeded;

        DbgLog(( LOG_TRACE, 2, TEXT("RegEnumFilterInfo[%x]: Considering (%ls)")
               , cur.pos, DBG_MON_GET_NAME(pFil->pDeviceMoniker)));

        if (pFil->m_prf2->dwMerit<dwMerit) {
            DbgLog(( LOG_TRACE, 2, TEXT("RegEnumFilterInfo[%x]: Rejected (%ls) - insufficient merit")
                   , cur.pos, DBG_MON_GET_NAME(pFil->pDeviceMoniker)));
            continue;
        }

        for(UINT iPin = 0; iPin < pFil->m_prf2->cPins; iPin++)
        {
            if (bOutputOK && bInputOK)
                break;                        // no need to look further!


            const REGFILTERPINS2 * pPin = &pFil->m_prf2->rgPins2[iPin];
            ASSERT( pPin !=NULL );


            //............................................................
            // if input - see if we need it rendered, if so check it is
            // and see if its type matches.
            //............................................................

            if (!(pPin->dwFlags & REG_PINFLAG_B_OUTPUT)) {
                bInputOK = bInputOK ||
                           CheckInput(pPin,
                                      pInputTypes,
                                      cInputTypes,
                                      pMedIn,
                                      pPinCatIn,
                                      bExactMatch,
                                      bMustRender,
                                      cur.bDoWildCardsOnInput);
            } else {
                bOutputOK = bOutputOK ||
                            FindType(pPin,
                                     pOutputTypes,
                                     cOutputTypes,
                                     pMedOut,
                                     pPinCatOut,
                                     bExactMatch,
                                     FALSE,
                                     FALSE);
            }

        } // end pins loop


        if (bInputOK && bOutputOK) {

            // Get the Moniker or whatever
            if (pFil->pDeviceMoniker == NULL)
            {
                if (pFil->m_pstr == NULL) {
                    continue;
                }
                hr = ParseDisplayNameHelper(pFil->m_pstr, &pFil->pDeviceMoniker);
            }
            if (FAILED(hr)) {
                continue;
            }
            // Make sure we got the clsid
            if (clsFilter != NULL) {
                if (FAILED(GetMapFilterClsid(pFil, clsFilter))) {
                    DbgLog((LOG_ERROR, 2, TEXT("Couldn't get filter(%ls) clsid")
                           , DBG_MON_GET_NAME(pFil->pDeviceMoniker)));
                    continue;
                }
            }

            //-------------------------------------------------------------------
            // This filter is one we want!
            // Copy the the stuff into our parameters
            //-------------------------------------------------------------------

            if(ppMoniker)
            {
                *ppMoniker = pFil->pDeviceMoniker;
                (*ppMoniker)->AddRef();
            }

            if(Name)
            {
                WCHAR *wszFilterName;
                wszFilterName = MonGetName(pFil->pDeviceMoniker);
                if(wszFilterName)
                {
                    lstrcpynW(Name, wszFilterName, MAX_STRING);
                    CoTaskMemFree(wszFilterName);
                }
            }

#ifdef DEBUG
                WCHAR *wszFilterName;
                wszFilterName = MonGetName(pFil->pDeviceMoniker);
                if(wszFilterName)
                {
                    DbgLog(( LOG_TRACE, 2, TEXT("RegEnumFilterInfo returning %ls"), wszFilterName));
                    CoTaskMemFree(wszFilterName);
                }
#endif

            return NOERROR;

        }
        else {

            DbgLog(( LOG_TRACE, 3
                     , TEXT("RegEnumFilterInfo: %ls not wanted (input %s output %s)")
                     , DBG_MON_GET_NAME(pFil->pDeviceMoniker)
                     , (bInputOK ? "OK" : "wrong")
                     , (bOutputOK ? "OK" : "wrong")
                     ));


            continue; // look for the next filter
        }

    }

    return S_FALSE;   // fell off the end without finding one

} // RegEnumFilterInfo


//========================================================================
//
// EnumMatchingFiters
//
// Get an enumerator to list filters in the registry.
//========================================================================

STDMETHODIMP CFilterMapper2::EnumMatchingFilters
   ( IEnumRegFilters **ppEnum  // enumerator returned
   , DWORD dwMerit             // at least this merit needed
   , BOOL  bInputNeeded        // Need at least one input pin
   , CLSID clsInMaj            // input major type
   , CLSID clsInSub            // input sub type
   , BOOL bRender              // must the input be rendered?
   , BOOL bOutputNeeded        // Need at least one output pin
   , CLSID clsOutMaj           // output major type
   , CLSID clsOutSub           // output sub type
   )
{
    CheckPointer(ppEnum, E_POINTER);
    *ppEnum = NULL;           // default

    CEnumRegFilters *pERF;

    // Create a new enumerator, pass in the one and only cache

    CAutoLock cObjectLock(this);   // must lock to create only one cache ever.

    HRESULT hr = CreateEnumeratorCacheHelper();
    if(FAILED(hr))
        return hr;

    pERF = new CEnumRegFilters( dwMerit
                              , bInputNeeded
                              , clsInMaj
                              , clsInSub
                              , bRender
                              , bOutputNeeded
                              , clsOutMaj
                              , clsOutSub
                              , mM_pReg
                              );
    if (pERF == NULL) {
        return E_OUTOFMEMORY;
    }

    // Get a reference counted IID_IEnumRegFilters interface

    return pERF->QueryInterface(IID_IEnumRegFilters, (void **)ppEnum);

} // EnumMatchingFilters

// ========================================================================
// =====================================================================
// Methods of class CEnumRegFilters. This one should only return
// things which can be CoCreated (but doesn't yet)
//=====================================================================
//========================================================================


//=====================================================================
// CEnumRegFilters constructor
//=====================================================================

CEnumRegFilters::CEnumRegFilters( DWORD dwMerit
                                , BOOL bInputNeeded
                                , REFCLSID clsInMaj
                                , REFCLSID clsInSub
                                , BOOL bRender
                                , BOOL bOutputNeeded
                                , REFCLSID clsOutMaj
                                , REFCLSID clsOutSub
                                , CMapperCache * pReg
                                )
    : CUnknown(NAME("Registry filter enumerator"), NULL)
{
    mERF_dwMerit = dwMerit;
    mERF_bInputNeeded = bInputNeeded;
    mERF_bOutputNeeded = bOutputNeeded;
    mERF_clsInMaj = clsInMaj;
    mERF_clsInSub = clsInSub;
    mERF_bRender  = bRender;
    mERF_clsOutMaj = clsOutMaj;
    mERF_clsOutSub = clsOutSub;
    ZeroMemory(&mERF_Cur, sizeof(mERF_Cur));
    mERF_Finished = FALSE;
    mERF_pReg = pReg;

} // CEnumRegFilters constructor





//=====================================================================
// CEnumFilters destructor
//=====================================================================

CEnumRegFilters::~CEnumRegFilters()
{
   // Nothing to do

} // CEnumRegFilters destructor



//=====================================================================
// CEnumFilters::NonDelegatingQueryInterface
//=====================================================================

STDMETHODIMP CEnumRegFilters::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IEnumRegFilters) {
        return GetInterface((IEnumRegFilters *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
} // CEnumRegFilters::NonDelegatingQueryInterface



STDMETHODIMP CEnumRegFilters::Next
    (   ULONG cFilters,           // place this many Regfilters*
        REGFILTER ** apRegFilter,   // ...in this array of RegFilter*
        ULONG * pcFetched         // actual count passed returned here
    )
{
    CheckPointer(apRegFilter, E_POINTER);

    CAutoLock cObjectLock(this);
    // It's always possible that someone may decide that the clever
    // way to call this is to ask for filters a hundred at a time,
    // but I'm not optimising for that case.  The buffers returned
    // will be over-size and I'm not going to waste time re-sizing
    // and packing.

    ULONG cFetched = 0;           // increment as we get each one.

    if (mERF_Finished) {
        if (pcFetched!=NULL) {
            *pcFetched = 0;
        }
        return S_FALSE;
    }

    if (pcFetched==NULL && cFilters>1) {
        return E_INVALIDARG;
    }

    // Buffer in which the result is built
    // The buffer layout will be
    //        apRegFilter--->pRegFilter[0] -------       This lot
    //                       pRegFilter[1] --------+--   is allocated
    //                       . . .                 |  |  by our
    //                       pRegFilter[cFilters] -+--+--  caller
    //                                             |  |  |
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX |  |  | XXXXXXXXXXXXXXX
    //                                             |  |  |
    //         REGFILTER <-------------------------   |  | This lot
    //            Filter Clsid                        |  | is allocated
    //            Filter Name                         |  | by us
    //               array of unsigned shorts in Name |  |
    //                                                |  |
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX |  | XXXXXXXXXXXXXXX
    //                                                |  |
    //         REGFILTER <----------------------------   | Another buffer
    //            . . .                                  | allocated by us
    //                                                   |
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX | XXXXXXXXXXXXXXX
    //                                                   |
    //         REGFILTER <-------------------------------  etc

    while(cFetched < cFilters) {


        REGFILTER * pRF
                  = (REGFILTER *)QzTaskMemAlloc(sizeof(REGFILTER)+ MAX_STRING * sizeof(WCHAR) );

        if (pRF==NULL) {
            break;
        }

        // Make Name point to first byte after REGFILTER
        pRF->Name = (LPWSTR)(pRF+1);   // that adds sizeof(REGFILTER)

        //----------------------------------------------------------------------
        // Get the next filter to return (including how many pins)
        //----------------------------------------------------------------------

        HRESULT hr;
        hr = mERF_pReg->RegEnumFilterInfo(
            mERF_Cur,
            false ,
            mERF_dwMerit ,
            mERF_bInputNeeded ,
            &mERF_clsInMaj,
            1,
            0 ,                 // medium in
            0 ,                 // pin category in
            mERF_bRender ,
            mERF_bOutputNeeded ,
            &mERF_clsOutMaj,
            1,
            0 ,                 // medium out
            0 ,                 // pin category out
            0 ,                 // moniker out
            &pRF->Clsid,
            pRF->Name
            );
        if (FAILED(hr)) {
            return hr;
        }
        if (hr==NOERROR) {
            apRegFilter[cFetched] = pRF;
            ++cFetched;
        } else if (hr==S_FALSE) {
            mERF_Finished = TRUE;
            QzTaskMemFree(pRF);
            break;
        } else {
#ifdef DEBUG
            TCHAR Msg[200];
            wsprintf(Msg, TEXT("Unexpected hresult (%d == 0x%8x) from RegEnumFilterInfo"), hr, hr);
            DbgBreakX(Msg);
#endif
            return E_UNEXPECTED;  // We have here an unexpected success code
                                  // from RegEnumFilterInfo (which should not
                                  // occur.  I have no idea what it means, but
                                  // it probably means that overall we failed.
        }

        if (mERF_Cur.pos==NULL) {
            mERF_Finished = TRUE;
            break;
        }

    } // for each filter

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    DbgLog(( LOG_TRACE, 4, TEXT("EnumRegFilters returning %d filters")
           , cFetched));

    return (cFilters==cFetched ? S_OK : S_FALSE);

} // CEnumRegFilters::Next

//========================================================================
//=====================================================================
// Methods of class CEnumRegMonikers
//=====================================================================
//========================================================================


//=====================================================================
// CEnumRegMonikers constructor
//=====================================================================

CEnumRegMonikers::CEnumRegMonikers(
    BOOL         bExactMatch,
    DWORD        dwMerit,
    BOOL         bInputNeeded,
    const GUID  *pInputTypes,
    DWORD        cInputTypes,
    const        REGPINMEDIUM *pMedIn,
    const        CLSID *pPinCatIn,
    BOOL         bRender,
    BOOL         bOutputNeeded,
    const GUID  *pOutputTypes,
    DWORD        cOutputTypes,
    const        REGPINMEDIUM *pMedOut,
    const        CLSID *pPinCatOut,
    CMapperCache *pReg,
    HRESULT     *phr
    )
    : CUnknown(NAME("Registry moniker enumerator"), NULL)
{
    mERF_cInputTypes = cInputTypes;
    mERF_cOutputTypes = cOutputTypes;
    mERF_dwMerit = dwMerit;
    mERF_bInputNeeded = bInputNeeded;
    mERF_bOutputNeeded = bOutputNeeded;
    mERF_clsInPinCat = pPinCatIn ? *pPinCatIn : GUID_NULL;
    mERF_bRender  = bRender;
    mERF_clsOutPinCat = pPinCatOut ? *pPinCatOut : GUID_NULL;
    ZeroMemory(&mERF_Cur, sizeof(mERF_Cur));
    mERF_Finished = FALSE;
    mERF_pReg = pReg;
    mERF_bExactMatch = bExactMatch ? true : false;

    if(pMedIn) {
        mERF_bMedIn = true;
        mERF_medIn = *pMedIn;
    } else {
        mERF_bMedIn = false;
    }

    if(pMedOut) {
        mERF_bMedOut = true;
        mERF_medOut = *pMedOut;
    } else {
        mERF_bMedOut = false;
    }

    mERF_pInputTypes = new GUID[cInputTypes * 2];
    mERF_pOutputTypes = new GUID[cOutputTypes * 2];
    if (mERF_pInputTypes == NULL || mERF_pOutputTypes == NULL) {
        *phr = E_OUTOFMEMORY;
    } else {
        CopyMemory(mERF_pInputTypes, pInputTypes, cInputTypes * (2 * sizeof(GUID)));
        CopyMemory(mERF_pOutputTypes, pOutputTypes, cOutputTypes * (2 * sizeof(GUID)));
    }

} // CEnumRegMonikers constructor




//=====================================================================
// CEnumFilters destructor
//=====================================================================

CEnumRegMonikers::~CEnumRegMonikers()
{
   delete [] mERF_pInputTypes;
   delete [] mERF_pOutputTypes;

} // CEnumRegMonikers destructor



//=====================================================================
// CEnumFilters::NonDelegatingQueryInterface
//=====================================================================

STDMETHODIMP CEnumRegMonikers::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IEnumMoniker) {
        return GetInterface((IEnumMoniker *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
} // CEnumRegMonikers::NonDelegatingQueryInterface



//=====================================================================
// CEnumFilters::Next
//=====================================================================

STDMETHODIMP CEnumRegMonikers::Next
    (   ULONG cFilters,           // place this many Regfilters*
        IMoniker **rgpMoniker,    // ...in this array of monikers
        ULONG * pcFetched         // actual count passed returned here
    )
{
    CheckPointer(rgpMoniker, E_POINTER);

    CAutoLock cObjectLock(this);
    // It's always possible that someone may decide that the clever
    // way to call this is to ask for filters a hundred at a time,
    // but I'm not optimising for that case.  The buffers returned
    // will be over-size and I'm not going to waste time re-sizing
    // and packing.

    ULONG cFetched = 0;           // increment as we get each one.

    if (mERF_Finished) {
        if (pcFetched!=NULL) {
            *pcFetched = 0;
        }
        return S_FALSE;
    }

    if (pcFetched==NULL && cFilters>1) {
        return E_INVALIDARG;
    }

    while(cFetched < cFilters) {


        //----------------------------------------------------------------------
        // Get the next filter to return (including how many pins)
        //----------------------------------------------------------------------

        IMoniker *pMon = 0;
        HRESULT hr;
        hr = mERF_pReg->RegEnumFilterInfo( mERF_Cur
                                         , mERF_bExactMatch
                                         , mERF_dwMerit
                                         , mERF_bInputNeeded
                                         , mERF_pInputTypes, mERF_cInputTypes
                                         , mERF_bMedIn ? &mERF_medIn : 0
                                         , mERF_clsInPinCat == GUID_NULL ? 0 : &mERF_clsInPinCat
                                         , mERF_bRender
                                         , mERF_bOutputNeeded
                                         , mERF_pOutputTypes, mERF_cOutputTypes
                                         , mERF_bMedOut ? &mERF_medOut : 0
                                         , mERF_clsOutPinCat == GUID_NULL ? 0 : &mERF_clsOutPinCat
                                         , &pMon, NULL, 0
                                         );
        if (FAILED(hr)) {
            return hr;
        }
        if (hr==NOERROR) {
            rgpMoniker[cFetched] = pMon;
            ++cFetched;
        } else if (hr==S_FALSE) {
            ASSERT(pMon == 0);
            mERF_Finished = TRUE;
            break;
        } else {
#ifdef DEBUG
            TCHAR Msg[200];
            wsprintf(Msg, TEXT("Unexpected hresult (%d == 0x%8x) from RegEnumFilterInfo"), hr, hr);
            DbgBreakX(Msg);
#endif
            return E_UNEXPECTED;  // We have here an unexpected success code
                                  // from RegEnumFilterInfo (which should not
                                  // occur.  I have no idea what it means, but
                                  // it probably means that overall we failed.
        }

        if (mERF_Cur.pos==NULL) {
            mERF_Finished = TRUE;
            break;
        }

    } // for each filter

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    DbgLog(( LOG_TRACE, 4, TEXT("EnumRegFilters returning %d filters")
           , cFetched));

    return (cFilters==cFetched ? S_OK : S_FALSE);

} // CEnumRegMonikers::Next


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// CFilterMapper2

CFilterMapper2::CFilterMapper2 ( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
        : CUnknown(pName, pUnk, phr),
          m_rgbBuffer(0)
{
    EnterCriticalSection(&mM_CritSec);
    InterlockedIncrement(&mM_cCacheRefCount);
    LeaveCriticalSection(&mM_CritSec);
}

CFilterMapper2::~CFilterMapper2()
{
    delete[] m_rgbBuffer;

    EnterCriticalSection(&mM_CritSec);
    LONG lRef = InterlockedDecrement(&mM_cCacheRefCount);
    ASSERT(lRef >= 0);          // refcount can't be negative
    // If the cache has been created - get rid of it again.
    if (lRef==0) {
        if (mM_pReg!=NULL) {
            delete mM_pReg;
            // We really need to set this to null
            mM_pReg = NULL;
        }
    }
    LeaveCriticalSection(&mM_CritSec);

}

HRESULT CFilterMapper2::RegisterFilter(
        /* [in] */ REFCLSID clsidFilter,
        /* [in] */ LPCWSTR Name,
        /* [out][in] */ IMoniker **ppMoniker,
        /* [in] */ const CLSID *pclsidCategory,
        /* [in] */ const OLECHAR *szInstance,
        /* [in] */ const REGFILTER2 *prf2)
{
    CheckPointer(Name, E_POINTER);

    CAutoLock foo(this);
    BreakCacheIfNotBuildingCache();

    IMoniker *pMonikerIn = 0;
    BOOL fMonikerOut = FALSE;

    TCHAR szDisplayName[16384];

    if(ppMoniker)
    {
        pMonikerIn = *ppMoniker;
        *ppMoniker = 0;
        if(!pMonikerIn)
            fMonikerOut = TRUE;
    }

    // set wszInstanceKey. if not passed in, use filter guid
    WCHAR wszInstanceKeyTmp[CHARS_IN_GUID];
    const WCHAR *wszInstanceKey;
    if(szInstance)
    {
        wszInstanceKey = szInstance;
    }
    else
    {
        StringFromGUID2(clsidFilter, wszInstanceKeyTmp, CHARS_IN_GUID);
        wszInstanceKey = wszInstanceKeyTmp;
    }

    //
    // get the moniker for this device
    //

    OLECHAR wszClsidCat[CHARS_IN_GUID], wszClsidFilter[CHARS_IN_GUID];
    IMoniker *pMoniker = 0;
    HRESULT hr = S_OK;

    const CLSID *clsidCat = pclsidCategory ? pclsidCategory : &CLSID_LegacyAmFilterCategory;
    EXECUTE_ASSERT(StringFromGUID2(*clsidCat, wszClsidCat, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);
    EXECUTE_ASSERT(StringFromGUID2(clsidFilter, wszClsidFilter, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);
    if(pMonikerIn == 0)
    {
        // Create or open HKCR/CLSID/{clsid}, and the instance key,
        // set FriendlyName, CLSID values
        USES_CONVERSION;
        const TCHAR *szClsidFilter = OLE2CT(wszClsidFilter);
        const TCHAR *szClsidCat = OLE2CT(wszClsidCat);

        IBindCtx *lpBC;
        hr = CreateBindCtx(0, &lpBC);
        if(SUCCEEDED(hr))
        {
            // no strcat on win95, so use tchars
            lstrcpy(szDisplayName, TEXT("@device:sw:"));
            lstrcat(szDisplayName, szClsidCat);
            lstrcat(szDisplayName, TEXT("\\"));
            lstrcat(szDisplayName, W2CT(wszInstanceKey));
            ULONG cchEaten;

            IParseDisplayName *ppdn;

            hr = CoCreateInstance(
                CLSID_CDeviceMoniker,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IParseDisplayName,
                (void **)&ppdn);
            if(SUCCEEDED(hr))
            {
                hr = ppdn->ParseDisplayName(
                    lpBC, T2OLE(szDisplayName), &cchEaten, &pMoniker);
                ppdn->Release();
            }

            lpBC->Release();
        }

    }
    else
    {
        pMoniker = pMonikerIn;
        pMonikerIn->AddRef();
    }


    //
    // write FriendlyName, clsid, and pin/mt data
    //

    if(SUCCEEDED(hr))
    {
        IPropertyBag *pPropBag;
        hr = pMoniker->BindToStorage(
            0, 0, IID_IPropertyBag, (void **)&pPropBag);
        if(SUCCEEDED(hr))
        {
            VARIANT var;
            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString(Name);
            if(var.bstrVal)
            {
                hr = pPropBag->Write(L"FriendlyName", &var);
                SysFreeString(var.bstrVal);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(wszClsidFilter);
                if(var.bstrVal)
                {
                    hr = pPropBag->Write(L"CLSID", &var);
                    SysFreeString(var.bstrVal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

            }

            if(SUCCEEDED(hr))
            {
                // cbMax is set to the maxium size required
                ULONG cbMax = 0;
                hr = RegSquish(0, &prf2, &cbMax);
                if(SUCCEEDED(hr))
                {
                    BYTE *pbSquished = new BYTE[cbMax];
                    if(pbSquished)
                    {
                        // cbUsed is set to the exact size required
                        ULONG cbUsed = cbMax;
                        hr = RegSquish(pbSquished, &prf2, &cbUsed);
                        if(hr == S_OK)
                        {
                            // copy squished data to variant array now
                            // that we know the proper size.
                            VARIANT var;
                            var.vt = VT_UI1 | VT_ARRAY;
                            SAFEARRAYBOUND rgsabound[1];
                            rgsabound[0].lLbound = 0;
                            rgsabound[0].cElements = cbUsed;
                            var.parray = SafeArrayCreate(VT_UI1, 1, rgsabound);

                            if(var.parray)
                            {
                                BYTE *pbData;
                                EXECUTE_ASSERT(SafeArrayAccessData(
                                    var.parray, (void **)&pbData) == S_OK);

                                CopyMemory(pbData, pbSquished, cbUsed);

                                hr = pPropBag->Write(L"FilterData", &var);

                                EXECUTE_ASSERT(SafeArrayUnaccessData(
                                    var.parray) == S_OK);

                                EXECUTE_ASSERT(SafeArrayDestroy(
                                    var.parray) == S_OK);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }

                        } // squish succeeded

                        delete[] pbSquished;

                    } // allocate pbSquish
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                } // squish to get size succeeded
            }

        } // bindtostorage

        pPropBag->Release();
    }

    if(SUCCEEDED(hr) && pMoniker)
    {
        if(fMonikerOut)
        {
            *ppMoniker = pMoniker;
        }
        else
        {
            pMoniker->Release();
        }
    }

    return hr;
}

HRESULT CFilterMapper2::CreateCategory(
    /* [in] */ REFCLSID clsidCategory,
    /* [in] */ const DWORD dwCategoryMerit,
    /* [in] */ LPCWSTR Description)
{
    HRESULT hr = S_OK;

    // Create or open ActiveMovie Filter Categories key
    CRegKey rkAMCat;
    LONG lResult = rkAMCat.Create(HKEY_CLASSES_ROOT, g_szKeyAMCat);
    if(lResult == ERROR_SUCCESS)
    {
        OLECHAR szClsid[CHARS_IN_GUID];
        StringFromGUID2(clsidCategory, szClsid, CHARS_IN_GUID);
        CRegKey rkCatGuid;

        USES_CONVERSION;
        lResult = rkCatGuid.Create(rkAMCat, OLE2CT(szClsid));

        if(lResult == ERROR_SUCCESS)
        {
            lResult = rkCatGuid.SetValue(W2CT(Description), TEXT("FriendlyName"));
            if(lResult == ERROR_SUCCESS)
            {
                OLECHAR wszGuid[CHARS_IN_GUID];
                StringFromGUID2(clsidCategory, wszGuid, CHARS_IN_GUID);
                lResult = rkCatGuid.SetValue(OLE2CT(wszGuid), TEXT("CLSID"));
            }
        }
        if(lResult == ERROR_SUCCESS)
        {
            lResult = rkCatGuid.SetValue(dwCategoryMerit, TEXT("Merit"));
        }
    }
    if(lResult != ERROR_SUCCESS)
    {
        hr = AmHresultFromWin32(lResult);
    }

    return hr;
}

HRESULT CFilterMapper2::UnregisterFilter(
    /* [in] */ const CLSID *pclsidCategory,
    /* [in] */ const OLECHAR *szInstance,
    /* [in] */ REFCLSID clsidFilter)
{
    HRESULT hr = S_OK;

    CAutoLock foo(this);
    BreakCacheIfNotBuildingCache();

    OLECHAR wszClsidCat[CHARS_IN_GUID];
    const CLSID *clsidCat = pclsidCategory ? pclsidCategory :
        &CLSID_LegacyAmFilterCategory;
    EXECUTE_ASSERT(StringFromGUID2(*clsidCat, wszClsidCat, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);

    USES_CONVERSION;

    // set wszInstanceKey. if not passed in, use filter guid
    WCHAR wszInstanceKeyTmp[CHARS_IN_GUID];
    const WCHAR *wszInstanceKey;
    if(szInstance)
    {
        wszInstanceKey = szInstance;
    }
    else
    {
        StringFromGUID2(clsidFilter, wszInstanceKeyTmp, CHARS_IN_GUID);
        wszInstanceKey = wszInstanceKeyTmp;
    }

    // build "CLSID\\{cat-guid}\\Instance. we put slashes where
    // the terminators go
    const cchszClsid = NUMELMS(szCLSID);
    const cchCatGuid = CHARS_IN_GUID;
    const cchInstance = NUMELMS(g_wszInstance);

    WCHAR *wszInstancePath = (WCHAR *)
        alloca((cchszClsid + cchCatGuid + cchInstance) * sizeof(WCHAR));

    CopyMemory(wszInstancePath,
               szCLSID,
               (cchszClsid - 1) * sizeof(WCHAR));
    wszInstancePath[cchszClsid - 1] = L'\\';

    CopyMemory(wszInstancePath + cchszClsid,
               wszClsidCat,
               (cchCatGuid - 1) * sizeof(WCHAR));
    wszInstancePath[cchszClsid + cchCatGuid - 1] = L'\\';

    CopyMemory(wszInstancePath + cchszClsid + cchCatGuid,
               g_wszInstance,
               cchInstance * sizeof(WCHAR)); // copy terminator

    LONG lResult;
    CRegKey rkInstance;
    if((lResult = rkInstance.Open(HKEY_CLASSES_ROOT, W2CT(wszInstancePath)),
        lResult == ERROR_SUCCESS) &&
       (lResult = rkInstance.RecurseDeleteKey(OLE2CT(wszInstanceKey)),
        lResult == ERROR_SUCCESS))
    {
        hr = S_OK;
    }
    else
    {
        hr = AmHresultFromWin32(lResult);
    }

    return hr;
}

#if 0
STDMETHODIMP CFilterMapper2::EnumMatchingFilters(
    /* [out] */ IEnumMoniker **ppEnum,
    /* [in] */ BOOL bExactMatch,
    /* [in] */ DWORD dwMerit,
    /* [in] */ BOOL bInputNeeded,
    /* [in] */ REFCLSID clsInMaj,
    /* [in] */ REFCLSID clsInSub,
    /* [in] */ const REGPINMEDIUM *pMedIn,
    /* [in] */ const CLSID *pPinCategoryIn,
    /* [in] */ BOOL bRender,
    /* [in] */ BOOL bOutputNeeded,
    /* [in] */ REFCLSID clsOutMaj,
    /* [in] */ REFCLSID clsOutSub,
    /* [in] */ const REGPINMEDIUM *pMedOut,
    /* [in] */ const CLSID *pPinCategoryOut
    )
{
    CheckPointer(ppEnum, E_POINTER);

    *ppEnum = NULL;           // default

    CEnumRegMonikers *pERM;

    // Create a new enumerator, pass in the one and only cache

    CAutoLock cObjectLock(this);   // must lock to create only one cache ever.

    HRESULT hr = CreateEnumeratorCacheHelper();
    if(FAILED(hr))
        return hr;

    GUID guidInput[2];
    guidInput[0] = clsInMaj;
    guidInput[1] = clsInSub;
    GUID guidOutput[2];
    guidOutput[0] = clsOutMaj;
    guidOutput[1] = clsOutSub;
    pERM = new CEnumRegMonikers(
        bExactMatch,
        dwMerit,
        bInputNeeded,
        guidInput,
        1,
        pMedIn,
        pPinCategoryIn,
        bRender,
        bOutputNeeded,
        guidOutput,
        1,
        pMedOut,
        pPinCategoryOut,
        mM_pReg,
        &hr
        );

    if (S_OK != hr || pERM == NULL) {
        delete pERM;
        return E_OUTOFMEMORY;
    }

    // Get a reference counted IID_IEnumMoniker interface

    return pERM->QueryInterface(IID_IEnumMoniker, (void **)ppEnum);
}
#endif

HRESULT BuildMediumCacheEnumerator(
    const REGPINMEDIUM  *pMedIn,
    const REGPINMEDIUM *pMedOut,
    IEnumMoniker **ppEnum)
{
    HRESULT hr;

    {
        HKEY hk;
        LONG lResult = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Control\\MediumCache"),
            0,                  // ulOptions
            KEY_READ,
            &hk);
        if(lResult == ERROR_SUCCESS)
        {
            RegCloseKey(hk);
        }
        else
        {
            // caller relies on S_FALSE on older platforms without a
            // MediumCache key to use mapper cache.
            return S_FALSE;
        }
    }

    TCHAR szMedKey[MAX_PATH];
    const REGPINMEDIUM *pmed = pMedIn ? pMedIn : pMedOut;

    const CLSID& rguid = pmed->clsMedium;
    wsprintf(
        szMedKey,
        TEXT("System\\CurrentControlSet\\Control\\MediumCache\\{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}-%x-%x"),
        rguid.Data1, rguid.Data2, rguid.Data3,
        rguid.Data4[0], rguid.Data4[1],
        rguid.Data4[2], rguid.Data4[3],
        rguid.Data4[4], rguid.Data4[5],
        rguid.Data4[6], rguid.Data4[7],
        pmed->dw1, pmed->dw2);

    HKEY hk;
    LONG lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        szMedKey,
        0,                  // ulOptions
        KEY_READ,
        &hk);

    TCHAR szValue[MAX_PATH]; // max symbolic link is 255 chars.
    if(lResult == ERROR_SUCCESS)
    {
        IMoniker *rgpmon[200];
        DWORD dwMonIndex = 0;
        for(DWORD dwIndex = 0; lResult == ERROR_SUCCESS && dwMonIndex < NUMELMS(rgpmon);
            dwIndex++)
        {
            DWORD cchValue = NUMELMS(szValue);
            PIN_DIRECTION dir;
            DWORD cbData = sizeof(dir);

            lResult = RegEnumValue(
                hk,
                dwIndex,
                szValue,
                &cchValue,
                0,              // lpReserved
                0,              // lpType
                (BYTE *)&dir,
                &cbData);

            ASSERT(cbData == sizeof(dir));

            if(lResult == ERROR_SUCCESS && (
                dir == PINDIR_OUTPUT && pMedOut ||
                dir == PINDIR_INPUT && pMedIn))
            {

                WCHAR wszDisplayName[MAX_PATH + 100];
                wsprintfW(wszDisplayName, L"@device:pnp:%s", szValue);

                IMoniker *pmon;
                hr = ParseDisplayNameHelper(wszDisplayName, &pmon);
                if(SUCCEEDED(hr))
                {
                    // The MediumCache key is never purged on win9x,
                    // so we need to check that the key is active. we
                    // could check g_amPlatform and not do the test on
                    // NT.
                    //
                    CIsActive *pcia;
                    bool fReleaseMon = true;
                    if(pmon->QueryInterface(CLSID_CIsActive, (void **)&pcia) == S_OK)
                    {
                        if(pcia->IsActive())
                        {
                            // keep refcount
                            rgpmon[dwMonIndex++] = pmon;
                            fReleaseMon = false;
                        }

                        pcia->Release();
                    }
                    if(fReleaseMon) {
                        pmon->Release();
                    }
                }
            }
        }

        EXECUTE_ASSERT(RegCloseKey(hk) == ERROR_SUCCESS);

        typedef CComEnum<IEnumMoniker,
            &IID_IEnumMoniker, IMoniker*,
            _CopyInterface<IMoniker> >
            CEnumMonikers;

        CEnumMonikers *pDevEnum;
        pDevEnum = new CComObject<CEnumMonikers>;
        if(pDevEnum)
        {
            IMoniker **ppMonikerRgStart = rgpmon;
            IMoniker **ppMonikerRgEnd = ppMonikerRgStart + dwMonIndex;

            hr = pDevEnum->Init(ppMonikerRgStart,
                                ppMonikerRgEnd,
                                0,
                                AtlFlagCopy);

            if(SUCCEEDED(hr))
            {
                hr = pDevEnum->QueryInterface(IID_IEnumMoniker, (void **)ppEnum);
                ASSERT(hr == S_OK);
            }
            else
            {
                delete pDevEnum;
            }

        }
        else
        {
            hr =  E_OUTOFMEMORY;
        }

        for(ULONG i = 0; i < dwMonIndex; i++)
        {
            rgpmon[i]->Release();
        }
    }
    else
    {
        hr = VFW_E_NOT_FOUND;
    }

    return hr;
}


STDMETHODIMP CFilterMapper2::EnumMatchingFilters(
    /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppEnum,
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL bExactMatch,
    /* [in] */ DWORD dwMerit,
    /* [in] */ BOOL bInputNeeded,
    /* [in] */ DWORD cInputTypes,
    /* [size_is] */ const GUID __RPC_FAR *pInputTypes,
    /* [in] */ const REGPINMEDIUM __RPC_FAR *pMedIn,
    /* [in] */ const CLSID __RPC_FAR *pPinCategoryIn,
    /* [in] */ BOOL bRender,
    /* [in] */ BOOL bOutputNeeded,
    /* [in] */ DWORD cOutputTypes,
    /* [size_is] */ const GUID __RPC_FAR *pOutputTypes,
    /* [in] */ const REGPINMEDIUM __RPC_FAR *pMedOut,
    /* [in] */ const CLSID __RPC_FAR *pPinCategoryOut)
{
    CheckPointer(ppEnum, E_POINTER);
    *ppEnum = NULL;           // default

    CEnumRegMonikers *pERM;

    // if caller is searching for just one medium, use the MediumCache key
    if(bExactMatch &&
       !cInputTypes && !pPinCategoryIn &&
       !cOutputTypes && !pPinCategoryOut &&
       (pMedIn && !pMedOut || !pMedIn && pMedOut))
    {
        HRESULT hr = BuildMediumCacheEnumerator(pMedIn, pMedOut, ppEnum);
        if(hr != S_FALSE) {
            return hr;
        }
    }

    {
        // Create a new enumerator, pass in the one and only cache

        CAutoLock cObjectLock(this);   // must lock to create only one cache ever.

        HRESULT hr = CreateEnumeratorCacheHelper();
        if(FAILED(hr))
            return hr;

        pERM = new CEnumRegMonikers(
            bExactMatch,
            dwMerit,
            bInputNeeded,
            pInputTypes,
            cInputTypes,
            pMedIn,
            pPinCategoryIn,
            bRender,
            bOutputNeeded,
            pOutputTypes,
            cOutputTypes,
            pMedOut,
            pPinCategoryOut,
            mM_pReg,
            &hr
            );

        if (S_OK != hr || pERM == NULL) {
            delete pERM;
            return E_OUTOFMEMORY;
        }

        // Get a reference counted IID_IEnumMoniker interface
    }


    return pERM->QueryInterface(IID_IEnumMoniker, (void **)ppEnum);

}

HRESULT CFilterMapper2::CreateEnumeratorCacheHelper()
{
    ASSERT(CritCheckIn(this));  // not really necessary

    HRESULT hr = S_OK;
    EnterCriticalSection(&mM_CritSec);   // must lock to create only one cache ever.

    ASSERT(mM_cCacheRefCount > 0); // from our constructor

    if (mM_pReg==NULL) {
        DbgLog((LOG_TRACE, 3, TEXT("creating new mapper cache.")));

        // another mapper may be looking at a partially constructed
        // mapper cache without taking the global critical section
        // (calls to BreakCacheIfNotBuildingCache, for example). So
        // make sure they don't see an partially constructed cache.
        CMapperCache *pMapperCacheTmp = new CMapperCache;

        if (pMapperCacheTmp != NULL)
        {
            // force the compiler to do the assignment here since
            // mM_pReg pointer isn't volatile. (seems to do this
            // anyway).
            CMapperCache * /* volatile */ &pMapperCacheVol = mM_pReg;
            pMapperCacheVol = pMapperCacheTmp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    LeaveCriticalSection(&mM_CritSec);

    return hr;
}

void CFilterMapper2::BreakCacheIfNotBuildingCache()
{
    // Break our registry cache
    InvalidateCache();

    // Break the internal cache
    if (mM_pReg!=NULL) {
        mM_pReg->BreakCacheIfNotBuildingCache();
    }
}

STDMETHODIMP CFilterMapper2::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IFilterMapper3) {
        return GetInterface((IFilterMapper3 *)this, ppv);
    } if (riid == IID_IAMFilterData) {
        return GetInterface((IAMFilterData *)this, ppv);
    } else if (riid == IID_IFilterMapper2) {
        return GetInterface((IFilterMapper2 *)this, ppv);
    } else if (riid == IID_IFilterMapper) {
        return GetInterface((IFilterMapper *)this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}
#ifdef DEBUG
extern bool g_fUseKASSERT;
#endif

void CFilterMapper2::MapperInit(BOOL bLoading,const CLSID *rclsid)
{
    UNREFERENCED_PARAMETER(rclsid);
    if (bLoading) {
        InitializeCriticalSection(&mM_CritSec);

#ifdef DEBUG
        // don't put up assert message boxes if we're running stress
        // -- break into the debugger instead.
        g_fUseKASSERT = (GetFileAttributes(TEXT("C:/kassert")) != 0xFFFFFFFF);
#endif

    } else {
        DeleteCriticalSection(&mM_CritSec);
    }

}

CUnknown *CFilterMapper2::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CFilterMapper2(NAME("filter mapper2"),pUnk, phr);

    // The idea was to only ever have one mapper - but:
    // Suppose one thread creates the first (and only) one successfully.
    // Another thread then tries to create one and, seeing that one exists
    // it returns that one.  Meanwhile, before it returns, the original
    // thread Releases and thereby destroys The Only One, so that the second
    // thread, when it resumes, is now returning a freed object.
    // So we just have static data instead.

} // CFilterMapper::Createinstance

STDMETHODIMP CFilterMapper2::GetICreateDevEnum( ICreateDevEnum **ppEnum )
{
    CAutoLock cObjectLock(this);   // must lock?

    HRESULT hr = CreateEnumeratorCacheHelper();
    if(SUCCEEDED(hr)) {
        if (!mM_pReg->m_pCreateDevEnum) {
            hr = CoCreateInstance( CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                                   IID_ICreateDevEnum, (void**)&mM_pReg->m_pCreateDevEnum);
        }
    }

    if (SUCCEEDED(hr)) {
        *ppEnum = mM_pReg->m_pCreateDevEnum;
        (*ppEnum)->AddRef();
    }

    return hr;
}


#include "fil_data_i.c"
STDMETHODIMP CFilterMapper2::ParseFilterData(
    /* [in, size_is(cb)] */ BYTE *rgbFilterData,
    /* [in] */ ULONG cb,
    /* [out] */ BYTE **prgbRegFilter2)
{
    *prgbRegFilter2 = 0;

    REGFILTER2 *prf2;
    REGFILTER2 **pprf2 = &prf2;

    HRESULT hr = UnSquish(
        rgbFilterData, cb,
        &pprf2);


    ASSERT(hr != S_FALSE);      // undefined

    if(hr == S_OK)
    {
        // allocated with CoTaskMemAlloc above.
        *prgbRegFilter2 = (BYTE *)pprf2;
    }

    return hr;
}

STDMETHODIMP CFilterMapper2::CreateFilterData(
    /* [in] */ REGFILTER2 *prf2_nc,
    /* [out] */ BYTE **prgbFilterData,
    /* [out] */ ULONG *pcb)
{
    *pcb = 0;
    *prgbFilterData = 0;

    const REGFILTER2 *&prf2 = prf2_nc;

    // cbMax is set to the maxium size required
    ULONG cbMax = 0;
    HRESULT hr = RegSquish(0, &prf2, &cbMax);
    if(SUCCEEDED(hr))
    {
        BYTE *pbSquished = (BYTE *)CoTaskMemAlloc(cbMax);
        if(pbSquished)
        {
            // cbUsed is set to the exact size required
            ULONG cbUsed = cbMax;
            hr = RegSquish(pbSquished, &prf2, &cbUsed);
            if(hr == S_OK)
            {
                *prgbFilterData = pbSquished;
                *pcb = cbUsed;
            }
            else
            {
                DbgBreak("bug somewhere if this happens?");

                // S_FALSE means too few bytes -- shouldn't happen
                ASSERT(FAILED(hr));
                CoTaskMemFree(pbSquished);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\msgmutex.h ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved

//
//   Filter graph locking definitions
//

#ifndef MsgMutex_h
#define MsgMutex_h

// Special mutex style locking
class CMsgMutex
{
public:
    HANDLE m_hMutex;
    DWORD  m_dwOwnerThreadId;  //  Thread Id
    DWORD  m_dwRecursionCount;
    HWND   m_hwnd;
    UINT   m_uMsg;
    DWORD  m_dwWindowThreadId;

    CMsgMutex(HRESULT *phr);
    ~CMsgMutex();
    BOOL Lock(HANDLE hEvent = NULL);
    void Unlock();
    void SetWindow(HWND hwnd, UINT uMsg);
};

class CAutoMsgMutex
{
public:
    CAutoMsgMutex(CMsgMutex *pMutex) : m_pMutex(pMutex)
    {
        pMutex->Lock();
    }
    ~CAutoMsgMutex()
    {
        m_pMutex->Unlock();
    }

private:
    CMsgMutex * const m_pMutex;

};

#ifdef DEBUG
BOOL WINAPI CritCheckIn( const CMsgMutex *pMutex );
#endif // DEBUG

#endif // MsgMutex_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\mtutil.cpp ===
//==========================================================================;
//
//  Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "mtutil.h"

// const char c_szGuidFormat[] = L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}";

//==========================================================================
// MediaTypeToText
//
// set pText to point to QzTaskMemAlloc allocated storage, filled with an ANSI
// text representation of the media type.  At the moment, it's not fully ANSI
// because there's a binary format glob on the end.
//==========================================================================
HRESULT MediaTypeToText(CMediaType cmt, LPWSTR &pText)
{
    pText = (LPWSTR) QzTaskMemAlloc(MediaTypeTextSize(cmt));
    if (pText==NULL) {
        return E_OUTOFMEMORY;
    }
    LPWSTR p = pText;
    HRESULT hr = StringFromGUID2( cmt.majortype, p, CHARS_IN_GUID);
    if (SUCCEEDED(hr)) {
        // CHARS_IN_GUID allows for a trailing null, not there in a file format
        p += CHARS_IN_GUID-1;               // that's counting WCHARs of course
        *p = L' ';
        ++p;
        hr = StringFromGUID2( cmt.subtype, p, CHARS_IN_GUID);
        if (SUCCEEDED(hr)) {
            p += CHARS_IN_GUID-1;
            *p = L' ';
            ++p;
            *p = (cmt.bFixedSizeSamples ? L'1' : L'0');
            ++p;
            *p = L' ';
            ++p;
            *p = (cmt.bTemporalCompression ? L'1' : L'0');
            ++p;
            *p = L' ';
            ++p;
            wsprintfW(p, L"%010d ", cmt.lSampleSize);
            p += 11;
            hr = StringFromGUID2( cmt.formattype, p, CHARS_IN_GUID);
            if (SUCCEEDED(hr)) {
                p += CHARS_IN_GUID-1;
                *p = L' ';
                ++p;
                wsprintfW(p, L"%010d ", cmt.cbFormat);
                p += 11;
                // and the rest of the format is a binary glob
                // which may contain binary zeros, so don't try to print it!
                memcpy(p, cmt.pbFormat, cmt.cbFormat);
            }
        }
    }
    if (FAILED(hr)) {
        QzTaskMemFree(pText);
        pText = NULL;
    }
    return hr;
} // MediaTypeToText


// number of bytes in the string representation
int MediaTypeTextSize(CMediaType &cmt) {
    return
      sizeof(WCHAR)       // NOTE: WCHAR not TCHAR - always UNICODE
      * ( CHARS_IN_GUID   // majortype+space
        + CHARS_IN_GUID   // subtype+space
        + 1+1             // bFixedSizeSamples
        + 1+1             // bTemporalCompression
        + 10+1            // lSampleSize
        + CHARS_IN_GUID   // formattype+space
        + 0               // pUnk - not saved
        + 10+1            // cbFormat
        )
      + cmt.cbFormat       // *pbFormat
      +2;
    // The plus 2 on the end allows for a terminating UNICODE null
    // in the case where the format length is 0 and the
    // trailing null of the last wsprintf formatting never
    // gets overwritten, but pokes over the end.
}


//===========================================================================
// NHexToInt
//
// Convert cb UNICODE hex characters of pstr to an Int without dragging in C Runtime
// pstr must start with an integer which is terminated by white space or null
//===========================================================================
int NHexToInt(LPWSTR pstr, int cb, HRESULT &hr)
{
    int Res = 0;                // result
    hr = NOERROR;

    for( ; cb>0; --cb) {
        if (pstr[0]>=L'0' && pstr[0]<=L'9') {
            Res = 16*Res+(int)(pstr[0]-L'0');
        } else if ( pstr[0]>=L'A' && pstr[0]<=L'F') {
            Res = 16*Res+(int)(pstr[0]-L'A'+10);
        } else if ( pstr[0]>=L'a' && pstr[0]<=L'f') {
            Res = 16*Res+(int)(pstr[0]-L'a'+10);
        } else {
            hr = E_INVALIDARG;
            break;
        }
        ++pstr;
    }
    return Res;

} // NHexToInt


//===========================================================================
// StrToInt
//
// sort of stripped down atoi without dragging in C Runtime
// pstr must start with an integer which is terminated by white space or null
//===========================================================================
HRESULT StrToInt(LPWSTR pstr, int &n)
{
    int Sign = 1;
    n = 0;                // result wil be n*Sign

    if (pstr[0]==L'-'){
        Sign = -1;
        ++pstr;
    }

    for( ; ; ) {
        if (pstr[0]>=L'0' && pstr[0]<=L'9') {
            n = 10*n+(int)(pstr[0]-L'0');
        } else if (  pstr[0] == L' '
                  || pstr[0] == L'\t'
                  || pstr[0] == L'\r'
                  || pstr[0] == L'\n'
                  || pstr[0] == L'\0'
                  ) {
            break;
        } else {
            return E_INVALIDARG;
        }
        ++pstr;
    }
    return NOERROR;

} // StrToInt


//============================================================================
// CMediaTypeFromText
//
// Initialises cmt from the text string pstr.
// Does the inverse of CTextMediaType
//============================================================================
HRESULT CMediaTypeFromText(LPWSTR pstr, CMediaType &cmt)
{


    pstr[CHARS_IN_GUID-1] = L'\0';   // delimit the GUID
    HRESULT hr = QzCLSIDFromString(pstr, &(cmt.majortype));
    if (FAILED(hr)) {
        return VFW_E_INVALID_CLSID;
    }

    pstr += CHARS_IN_GUID;  // includes skipping delimiting NULL

    pstr[CHARS_IN_GUID-1] = L'\0';   // delimit the GUID
    hr = QzCLSIDFromString(pstr, &(cmt.subtype));
    if (FAILED(hr)) {
        return VFW_E_INVALID_CLSID;
    }

    pstr += CHARS_IN_GUID;  // includes delimiting NULL

    if (*pstr == L'0') {
        cmt.bFixedSizeSamples = FALSE;
    } else if (*pstr == L'1') {
        cmt.bFixedSizeSamples = TRUE;
    } else {
        return VFW_E_INVALID_MEDIA_TYPE;
    }

    pstr += 1+1;

    if (*pstr == L'0') {
        cmt.bTemporalCompression = FALSE;
    } else if (*pstr == L'1') {
        cmt.bTemporalCompression = TRUE;
    } else {
        return VFW_E_INVALID_MEDIA_TYPE;
    }

    pstr += 1+1;

    int n;
    hr = StrToInt(pstr, n);
    cmt.lSampleSize = n;

    pstr += 10+1;

    pstr[CHARS_IN_GUID-1] = L'\0';   // delimit the GUID
    hr = QzCLSIDFromString(pstr, &(cmt.formattype));
    if (FAILED(hr)) {
        return VFW_E_INVALID_CLSID;
    }

    pstr += CHARS_IN_GUID;  // includes delimiting NULL

    hr = StrToInt(pstr, n);

    // format byte count is exactly 10 digits followed by a single space
    pstr += 10+1;

    // we rely on the format block being empty because we don't always
    // set it.
    ASSERT(cmt.cbFormat == 0);

    // zero is a special case to CMediaType class meaning pbFormat has
    // not been allocated. allocating 0 bytes confuses it.
    if(n != 0)
    {
        if(!cmt.SetFormat((BYTE *)pstr, n)) {
            return E_OUTOFMEMORY;
        }
    }

    return NOERROR;
} // CMediaTypeFromText


#pragma warning(disable: 4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\resource.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
// resource ids
#ifndef __FILGRAPH_RESOURCE__
#define __FILGRAPH_RESOURCE__

#define IDS_ADDFFAIL          1001
#define IDS_ADDFSUC           1002
#define IDS_ADDINGF           1003
#define IDS_BACKOUTDISC       1004
#define IDS_BACKOUTLEV        1005
#define IDS_BACKOUTREMF       1006
#define IDS_BACKOUTSB             1060
#define IDS_BESTCANDO         1007
#define IDS_BESTCANDONE       1008
#define IDS_CONNFAIL          1009
#define IDS_CONNING           1010
#define IDS_DISCON            1011
#define IDS_FOUNDF                1064
#define IDS_FOUNDF1           1012
#define IDS_FOUNDF2           1013
#define IDS_FOUNDP                1063
#define IDS_FOUNDP1           1014
#define IDS_FOUNDP2           1015
#define IDS_GETFFAIL          1016
#define IDS_ORIGINALP         1017
#define IDS_REMOVE            1018
#define IDS_RENDFILE          1019
#define IDS_RENDADDEDSOURCE   1020
#define IDS_RENDADDFAIL       1021
#define IDS_RENDADDSOURCEFAIL 1022
#define IDS_RENDBESTCANDONEP  1023
#define IDS_RENDBESTCANDOP    1024
#define IDS_RENDBESTCANFAIL   1025
#define IDS_RENDCONFAIL       1026
#define IDS_RENDCONNED        1027
#define IDS_RENDERADDEDF      1028
#define IDS_RENDERPART        1029
#define IDS_RENDERSUCP        1030
#define IDS_RENDFAILTOT       1031
#define IDS_RENDGETMTFAIL     1032
#define IDS_RENDLOADFAIL      1033
#define IDS_RENDMAJTYPE       1034
#define IDS_RENDNOOUT         1035
#define IDS_RENDNOPIN         1036
#define IDS_RENDNOTCON        1037
#define IDS_RENDOUTP          1038
#define IDS_RENDOUTPFAIL      1039
#define IDS_RENDOUTPPART      1040
#define IDS_RENDOUTPSUC       1041
#define IDS_RENDP             1042
#define IDS_RENDPART          1043
#define IDS_RENDPARTSOURCEP   1044
#define IDS_RENDPINCON        1045
#define IDS_RENDQISFAIL       1046
#define IDS_RENDRETCODE       1047
#define IDS_RENDSEARCHINP     1048
#define IDS_RENDSEARCHOUTP    1049
#define IDS_RENDSOURCEP       1050
#define IDS_RENDSTGFAIL       1051
#define IDS_RENDENDSB         1052
#define IDS_RENDTOTFAILP      1053
#define IDS_RENDTRYF          1054
#define IDS_RENDTRYNEWF       1055
#define IDS_RENDTRYP          1056
#define IDS_RENDWORTHLESS     1057
#define IDS_RENDPINCONFAIL    1058
#define IDS_RENDSUC           1059
#define IDS_SBFAIL                1062
#define IDS_STREAMBUILDING        1061

#define IDS_CONNECT           2001
#define IDS_CONNECTSUC        2002
#define IDS_CONNECTFAIL       2003
#define IDS_CONTOODEEP        2004
#define IDS_CONTRYDIRECT      2005
#define IDS_CONDIRECTSUC      2006
#define IDS_CONCON            2007
#define IDS_CONINDIRECTSUC    2008
#define IDS_CONINDIRECTFAIL   2009
#define IDS_CONVIAREG         2010
#define IDS_CONLOADFAIL       2011
#define IDS_CONLOADSUC        2012
#define IDS_CONADDFAIL        2013
#define IDS_CONNOMT           2014
#define IDS_CONVIA            2015
#define IDS_CONTRYPINS        2016
#define IDS_CONDISUC          2017
#define IDS_CONDIFAIL         2018
#define IDS_CONCOMPLFAIL      2019
#define IDS_CONCOMPLSUC       2020
#define IDS_CONQICFAIL        2021
#define IDS_CONRECURSE        2022
#define IDS_CONTOOMANYOUTPINS 2023
#define IDS_CONNOOUTPINS      2024
#define IDS_CONRECURSESUC     2025
#define IDS_CONRECURSEFAIL    2026
#define IDS_CONNOMOREINPINS   2027
#define IDS_CONNOMOREOUTPINS  2028
#define IDS_CONQICTOOMANY     2029


#define IDS_UNKNOWNFILETYPE   2500
#define IDS_GETMEDIATYPEFAIL  2501
#define IDS_MEDIATYPEFILE     2502
#define IDS_SOURCEFILTERCLSID 2503
#define IDS_SOURCECREATEFAIL  2504
#define IDS_NOSOURCEINTFCE    2505
#define IDS_LOADFAIL          2507
#define IDS_LOADED            2508
#define IDS_ADDSOURCEOK       2509
#define IDS_ADDFILTERFAIL     2510
#define IDS_ADDFILTEROK       2511

#endif // __FILGRAPH_RESOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\rlist.cpp ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

//#include <windows.h>     already included in streams.h
#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include <rlist.h>

//========================================================================
//
// DoReconnect
//
// This is NOT a member of the class, because it is a thread procedure.
//
// Break the connection indicated by to lpv (which is really a ToDo *)
// and reconnect it with the same pins in the same filter graph.
// This is done "underneath" the filter graph.
//========================================================================

HRESULT CReconnectList::DoReconnect(IPin *pPin1, AM_MEDIA_TYPE const *pmt)
{
    Active();
    IPin *pPin2;

    HRESULT hr;                    // return code from things we call
    hr = pPin1->ConnectedTo(&pPin2);
    if (FAILED(hr)) {
        Passive();
        return hr;
    }

    //----------------------------------------------------------
    // find which pin is which, set ppIn, ppinOut
    //----------------------------------------------------------

    IPin * ppinIn;           // the input pin
    IPin * ppinOut;          // the output pin

    PIN_DIRECTION pd;
    hr = pPin1->QueryDirection(&pd);
    ASSERT(SUCCEEDED(hr));

    if (pd==PINDIR_INPUT) {
        ppinIn = pPin1;
        ppinOut = pPin2;
    } else {
        ppinOut = pPin1;
        ppinIn = pPin2;
    }

    // In debug builds show who is being reconnected to who

    #ifdef DEBUG

        PIN_INFO piInput,piOutput;
        WCHAR Format[128];
        CLSID FilterClsid;

        hr = ppinIn->QueryPinInfo(&piInput);
        ASSERT(SUCCEEDED(hr));
        hr = ppinOut->QueryPinInfo(&piOutput);
        ASSERT(SUCCEEDED(hr));

        DbgLog((LOG_TRACE,2,TEXT("Reconnecting pins")));
        DbgLog((LOG_TRACE,2,TEXT("Input pin name: %ws"),piInput.achName));
        DbgLog((LOG_TRACE,2,TEXT("Output pin name: %ws"),piOutput.achName));

        IPersist *pPersistInput = (IPersist *) piInput.pFilter;
        hr = pPersistInput->GetClassID(&FilterClsid);
        ASSERT(SUCCEEDED(hr));
        QzStringFromGUID2(FilterClsid,Format,128);
        DbgLog((LOG_TRACE,2,TEXT("Input pin CLSID: %ws"),Format));

        IPersist *pPersistOutput = (IPersist *) piOutput.pFilter;
        hr = pPersistOutput->GetClassID(&FilterClsid);
        ASSERT(SUCCEEDED(hr));
        QzStringFromGUID2(FilterClsid,Format,128);
        DbgLog((LOG_TRACE,2,TEXT("Output pin CLSID: %ws"),Format));

	QueryPinInfoReleaseFilter(piInput);
	QueryPinInfoReleaseFilter(piOutput);

    #endif // DEBUG

    //----------------------------------------------------------
    // Disconnect going upstream
    //----------------------------------------------------------

    hr = ppinIn->Disconnect();
    ASSERT(SUCCEEDED(hr));

    hr = ppinOut->Disconnect();
    ASSERT(SUCCEEDED(hr));

    //----------------------------------------------------------
    // reconnect - ask the output pin first.
    //----------------------------------------------------------
    hr = ppinOut->Connect(ppinIn, pmt);
    ASSERT (SUCCEEDED(hr));

    // Release everybody
    pPin2->Release();

    //
    // See if this caused any reconnections and do them if we
    // weren't previously in a reconnect sequence
    //
    Passive();

    // We didn't need to increment the filter graph's iVersion as the
    // filtergraph is back the way it was at least as far as topology goes.
    // However a media type has probably changed, so it's dirty.
    // Fortunately Connect already handled that.

    return 0;
} // DoReconnect



// Construct a CReconnectList in Passive mode
CReconnectList::CReconnectList()
              : m_lListMode(0)         // start in thread mode
              , m_RList(NULL)
{
} // CReconnectList constructor


// Destructor
// Free all the storage and Release all references.
// The filter graph is being destroyed, so abort it all.
CReconnectList::~CReconnectList()
{
    IPin *pPin;
    while (m_RList) {   // cast kills l4 warning
        DbgBreak("Reconnect list was not empty");
        RLIST_DATA *pData = m_RList;
        pData->pPin->Release();
        DeleteMediaType(pData->pmt);
        m_RList = pData->pNext;
        delete pData;
    }
} // ~CReconnectList



// Switch to Active (i.e. Reconnect-via-list) mode.
// The list is expected to be empty at this point.
void CReconnectList::Active()
{
    m_lListMode++;
} // Active



// Execute all the actions on the list
// Return to Passive (i.e. Reconnect-via-spawned thread) mode
void CReconnectList::Passive()
{
    m_lListMode--;
    ASSERT(m_lListMode >= 0);
    if (m_lListMode == 0) {
        IPin * pToDo;
        while (m_RList) {
            RLIST_DATA *pData = m_RList;
            m_RList = pData->pNext;
            DoReconnect(pData->pPin, pData->pmt);
            pData->pPin->Release();
            DeleteMediaType(pData->pmt);
            delete pData;
        }
    }
} // Passive



// Schedule a reconnection for pin pPin in the filter graph
// AddRef both pins (the one given and the other one) at once
// AddRef punk at once.
// Release it all when the reconnect is done
// (punk is the filter graph itself).
HRESULT CReconnectList::Schedule(IPin * pPin, AM_MEDIA_TYPE const *pmt)
{
     HRESULT hr;                       // return code from things we call

    //-----------------------------------------------------------------------
    // The pin must be connected (or else we won't be able to tell who to
    // reconnect it to)
    //-----------------------------------------------------------------------

    IPin *pConnected;
    hr = pPin->ConnectedTo(&pConnected);
    if (FAILED(hr)) return hr;
    pConnected->Release();

    if (m_lListMode) {

        RLIST_DATA *pData = new RLIST_DATA;
        if (pData == NULL) {
            return E_OUTOFMEMORY;
        }
        if (pmt) {
            pData->pmt = CreateMediaType(pmt);
            if (pData->pmt == NULL) {
                delete pData;
                return E_OUTOFMEMORY;
            }
        } else {
            pData->pmt = NULL;
        }

        pData->pNext = NULL;
        pData->pPin  = pPin;
        pPin->AddRef();

        //  Add it to the tail
        for (RLIST_DATA **ppDataSearch = &m_RList; *ppDataSearch != NULL;
             ppDataSearch = &(*ppDataSearch)->pNext) {
        }
        *ppDataSearch = pData;
        return NOERROR;
    } else {


        //-----------------------------------------------------------------------
        // Do it now
        //-----------------------------------------------------------------------

        DoReconnect(pPin, pmt);
        return NOERROR;
    }
} // Schedule


// Remove from the list any reconnects mentioning this pin
// Actually this will only be called for both pins
HRESULT CReconnectList::Purge(IPin * pPin)
{
    RLIST_DATA **ppData = &m_RList;
    while (*ppData!=NULL) {
        RLIST_DATA *pData = *ppData;
        IPin *pPin2;
        IPin *pPin1 = pData->pPin;
        HRESULT hr = pPin1->ConnectedTo(&pPin2);
        if (  FAILED(hr)
           || EqualPins(pPin1, pPin)
           || EqualPins(pPin2, pPin)
           ) {

            /*  Remove this entry */
            pPin1->Release();
            DeleteMediaType(pData->pmt);
            *ppData = pData->pNext;
            delete pData;
        } else {
            ppData = &pData->pNext;
        }
        if (SUCCEEDED(hr)) {
            pPin2->Release();
        }
    }
    return NOERROR;
} // Purge
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\mtutil.h ===
//==========================================================================;
//
//  Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


//==========================================================================
// MediaTypeToText
//
// set pText to point to QzTaskMemAlloc allocated storage, filled with an ANSI
// text representation of the media type.  At the moment, it's not fully ANSI
// because there's a binary format glob on the end which can be large (for
// instance it can include a whole palete).
//==========================================================================
HRESULT MediaTypeToText(CMediaType cmt, LPWSTR &pText);


// number of bytes in the string representation
int MediaTypeTextSize(CMediaType &cmt);


//============================================================================
// CMediaTypeFromText
//
// Initialises cmt from the UNICODE text string pstr.
// Does the inverse of CTextMediaType.
//============================================================================
HRESULT CMediaTypeFromText(LPWSTR pstr, CMediaType &cmt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\rlist.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.

// Filters are allowed to Reconnect, which breaks the current connection and remakes
// it with the same two filters.
// If two filters which are connected both did this simultaneously on their own
// threads then they could deadlock as each would already have the critical section
// for its one filter and would be asking for the CS of the other one.
// Therefore the filters do not do this themselves, they ask the filter graph
// to do it for them, and the worst that will happen is that the reconnect
// might get done twice.
// The filter graph cannot just do the reconnect on the thread that it is
// called on as that is (probably) a filter thread.  The obvious idea of
// spawning a separate thread and just doing the work there doesn't work
// either.  The following can (did!) occur:
//
// PROBLEM 1:
// A chain of filters were connected up in order to do an intelligent
// connection or Render.
// Call them A->B->C with B and C being added by the filter graph.
// A can accept types t1 or t2.
// B can also accept t1 or t1 so they agree on t1.
// C can only accept t2.
// B can accept that and sees that this is acceptable to A so agrees to
// connect to B with type t2 and asks to Reconnect the A->B link.
// The Reconnect thread is blocked because the filter graph is busy.
// The filter graph (possibly after adding other filters such as D,...)
// discovers that it cannot make the connection at all (or at least not
// that way) and BACKS OUT C AND B!!
// Eventually the connection either succeeds or fails, and the filter
// graph then attempts to reconnect A->B, but B is no longer there!
// At this point it access violates
//
// PROBLEM 2:
// Another awkward scenario is that we get a successful chain
// A->B->C with a reconnect scheduled for A->B.
// The filter graph returns and the application immediately asks the
// graph to Run. The Run occurs before the Reconnect thread gets in
// (this is a race) and the Reconnect fails because the graph is Running.
// Of course the Run fails because it's not properly connected!
//
// Some Possible alternatives:
// 1. Make Reconnect be robust about handling filters that have been Released
// (this would avoid the trap in the first scenario but nothing else)
//
// 2. When a Reconnect is scheduled (on the original thread) AddRef both
// ends of the connection.  This would stop the filters going away and would
// prevent the trap.  Better than solution 1, but doesn't solve problem 2.
//
// 3. Ensure that all Reconnects occur before anything else.  This means that
// we retain a list of pending Reconnects and complete these on the filter
// graph thread
//     A. Immediately before any back-out.
//     B. Immediately before returning.
// Filters are not allowed to call back to the filter graph (apart from
// Reconnect) so the filter graph will not be holding any embarrassing
// locks at those points.
//
// This is better than solution 2 as it has a crack at both problems,
// however it's wasting time doing Reconnects before backouts.  Those
// Reconnects should be thrown away.  It would be nice if we could just
// toss the whole list, but there's nothing to stop other filters from
// requesting a Reconnect during this time, and those have to be done.
//
// 4. (Variant on 3)
// Retain a list of Reconnects to be done, purge the list as part of
// Backout.  Execute whatever is left on the list on Return.
//
// Better still, but fails to handle "normal" Reconnects.  If a Reconnect
// comes in when the filter graph is NOT active, such a Reconnect must be
// done on a spawned thread.  This means that on return we have to switch
// from Reconnect-via-List to Reconnect-via-Thread mode.  Of course there
// can be a race or a window at that point, so we have to do the switch
// inside yet another critical section that Reconnect will also enter.
//
// 5. (The full solution)
// Retain a list of Reconnects which were requested when the filter graph
// was active.
// AddRef both pins when they go on the list, Release when reconnected
// AddRef the filter graph too the same way.
// Purge the list as part of Backout.
// Execute whatever is left on the list on Return.
// On Return, switch back to "normal" Reconnect-via-spawned-thread more.
// On Entry to the filter graph, switch to Reconnect-List mode.
// Have a Critical Section to control such switching.
//
// I expect the great majority of Reconnects to go via the List mechanism
// Most filter graph operations (AddFilter etc) are not affected by this.
// Only Connect(), Render() and RenderFile() are affected.
//
// This class implements it.

#ifndef __R_LIST__
#define __R_LIST__

typedef struct tagRLIST_DATA {
    struct tagRLIST_DATA *pNext;
    IPin                 *pPin;
    AM_MEDIA_TYPE        *pmt;
} RLIST_DATA;

//  there's no need for a lock here because the filter graph
//  is always locked when we consult the list
class CReconnectList
{
    public:
        // Constructor
        CReconnectList();

        // Destructor
        ~CReconnectList();

        // Make the list active - enter Reconnect-List mode
        void Active();

        // Execute all the actions on the list
        // Return to Reconnect-via-spawned thread mode
        void Passive();

        // Put an action on the list or spawn a thread according to mode
        HRESULT Schedule(IPin * pPin, AM_MEDIA_TYPE const *pmt);

        // Remove from the list any reconnects of this connection
        HRESULT Purge(IPin * pPin);

        // Actually do a reconnection
        HRESULT DoReconnect(IPin *pPin1, AM_MEDIA_TYPE const *pmt);

        LONG m_lListMode;        // ListMode == Active, non-list mode == Passive
    private:

        RLIST_DATA *m_RList;

}; // CReconnectList

#endif // __R_LIST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\sort.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

//===========================================================================
// Filter ordering.
// State changes have to be propagated upstream. To do this, make a list
// of all the nodes in the graph in an acceptable order.  "Upstream" is
// normally only a partial ordering of the nodes of the graph.
// The list is ordered as follows:
// Let a Root node be one that is maximally downstream (i.e.. has no nodes
// downstream of it)
// Find all root nodes
//     by starting from each node in turn and taking all possible downstream
//     branches until you reach the end of each branch.
//     Merge this node into the set of roots.
//     (This is like enumerating leaves in a tree)
// Set all the filter rank nu mbers to 0.
// For each root node
//     Work upstream taking all possible branches and number the node according
//     to the number of steps taken to get there.  If the node has already been
//     numbered, then if its number is >= the proposed number then leave it
//     alone and don't explore that branch further, otherwise write in the
//     proposed number and contiune exploring that branch.
// Reorder the list to get it into upstream order.
//     The sort algorithm is dead crude as the list is expected to be short
//     If they ever become long enough to worry about, use a mergesort.
//     (There's a special purpose merge sort in the mapper)
// Record the version number of the filter graph that the list applies to.
//
// The version number is incremented by Add, AddSource, Remove, ConnectDirect,
// Connect, Render and Disconnect.
// If the version numbers match the list can be reused.  For normal usage
// I hope that the list will only need to be sorted once.
//
// The connections list is sorted DOWNSTREAM (that's the other way).
// Connections are sorted by completely re-building the list of connections.
// First the filters are sorted, then the filters list is traversed and for
// each filter we find each input connection and add it to the HEAD of the
// connections list.

// The calling tree is:
//     UpstreamOrder
//     |   ClearRanks
//     |   MergeRootNodes
//     |   |   MergeRootsFrom
//     |   |   |   Merge
//     |   |   |   MergeRootsFrom (recursing)
//     |   NumberNodes
//     |   |   NumberNodesFrom
//     |   |   |   NumberNodesFrom (recursing)
//     |   SortList
//         RebuildConnectionList

#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include <hrExcept.h>

#include "distrib.h"
#include "fgenum.h"
#include "rlist.h"
#include "filgraph.h"

//===================================================================
//
// ClearRanks
//
// Set the Rank of every FilGen in cfgl to zero
//===================================================================

void CFilterGraph::ClearRanks( CFilGenList &cfgl)
{
    POSITION Pos;
    Pos = cfgl.GetHeadPosition();
    while(Pos!=NULL) {
        FilGen * pfg;
        pfg = cfgl.GetNext(Pos);    // side-efects Pos onto next
        pfg->Rank = 0;
    }
} // ClearRanks


//===================================================================
//
// Merge
//
// Merge this *filgen into the list of *filgen cfgl
// by AddTail-ing it if it isn't already there.
//===================================================================

void CFilterGraph::Merge( CFilGenList &cfgl, FilGen * pfg )
{
    // Run through the list.  If we find pfg then return
    // otherwise AddTail it to the list.

    POSITION Pos;
    Pos = cfgl.GetHeadPosition();
    while(Pos!=NULL) {
        FilGen * pfgCursor;
        pfgCursor = cfgl.GetNext(Pos);    // side-efects Pos onto next
        if (pfgCursor == pfg) {
            return;                        // we found it
        }
    }

    cfgl.AddTail(pfg);

} // Merge



//===================================================================
//
// MergeRootsFrom
//
// Merge into cfglRoots all the nodes which turn out to be
// maximally downstream, starting from pfg.  If pfg itself has
// no downstream connection then it gets merged in.
// Merging avoids adding duplicates.
// cfgAll is a list of all the FilGens in the graph.
// This is needed for mapping back from a filter to its FilGen.
// Rank fields must all be zero before calling this at the top level
// of recursion.
//===================================================================

HRESULT CFilterGraph::MergeRootsFrom
                     (CFilGenList &cfgAll, CFilGenList &cfglRoots, FilGen * pfg)
{
    // recursive tree walk

    // Circularity detection:
    // When we visit a node we decrement its Rank before exploring its branch.
    // When we leave it (unwinding the recursion) we increment it again.
    // Hitting a rank other than 0 means circularity.

    //------------------------------------------------------------------------
    // For pfgDownstream = each node which is a downstream connection from pfg
    //------------------------------------------------------------------------

    FilGen * pfgDownstream;

    int cDownstream;  // number of downstream connections found

    cDownstream = 0;
    --pfg->Rank;

    CEnumPin Next(pfg->pFilter, CEnumPin::PINDIR_OUTPUT);	// want output only
    IPin *pPin;

    while ((LPVOID) (pPin = Next())) {
        HRESULT hr;

        IPin *pConnected;
        hr = pPin->ConnectedTo( &pConnected );          // Get ConnectionInfo

        pPin->Release();

        if (SUCCEEDED(hr) && pConnected!=NULL) {          // if it's connected
            PIN_INFO PinInf;
            hr = pConnected->QueryPinInfo( &PinInf );   // Get PIN_INFO of peer
            pConnected->Release();
            ASSERT(SUCCEEDED(hr));

            pfgDownstream = cfgAll.GetByFilter(PinInf.pFilter);

            QueryPinInfoReleaseFilter(PinInf);

            // This error occurs when a filter which is in the filter graph is connected to
            // a filter which is not in the filter graph.  This can occur if the user uses 
            // IGraphConfig::RemoveFilterEx() to remove a filter without disconnecting its'
            // pins. 
            if( NULL == pfgDownstream ) {
                return VFW_E_NOT_IN_GRAPH;
            }

            if (pfgDownstream->Rank<0) {
                // It only SEEMS circular, it's not (or other code would
                // have prevented it from being built)
                //DbgBreak("Circular graph detected!");

                // The graph cannot be circular because CFilterGraph::ConnectDirectInternal()
                // will not connect two pins if connecting the pins would create a circular
                // filter graph.  CFilterGraph::ConnectDirectInternal() is the ONLY way to
                // legally connect two pins.  

                ++pfg->Rank;

                // We'll count the point we got to arbitrarily as a root.
		// This can't hurt because numbering nodes from here will never
		// give a higher score than numbering them from a REAL root.
                return S_OK;
            } else {
                //---------------------------------------------------------------
                // count it as a downstream connection and
                // merge its roots (recursively).
                //---------------------------------------------------------------
                ++cDownstream;                 // We are NOT maximally downstream
                HRESULT hr = MergeRootsFrom(cfgAll, cfglRoots, pfgDownstream);
                if( FAILED( hr ) ) {
                    return hr;
                }
            }
        }
    }
    ++pfg->Rank;        // restore it back to zero before we leave this branch

    if (cDownstream ==0) {
        Merge( cfglRoots, pfg );
    }
    return S_OK;
} // MergeRootsFrom



//===================================================================
//
// MergeRootNodes
//
// Merge into cfglRoots all the nodes in cfgl which are
// maximally downstream (i.e. have no downstream connections)
//===================================================================

HRESULT CFilterGraph::MergeRootNodes(CFilGenList & cfglRoots, CFilGenList &cfgl)
{
    FilGen * pfg;
    POSITION Pos;
    HRESULT hr;

    ClearRanks(cfgl);

    //-------------------------------------------------------------
    // for pfg = each node in cfgl
    //-------------------------------------------------------------
    Pos = cfgl.GetHeadPosition();
    while (Pos!=NULL) {
        pfg = cfgl.GetNext(Pos);

        //-------------------------------------------------------------
        // merge into cfglRoots all the roots found by starting from pfg
        //-------------------------------------------------------------
        hr = MergeRootsFrom(cfgl, cfglRoots, pfg);
        if( FAILED( hr ) ) {
            return hr;
        }
    }
    return S_OK;

} // MergeRootNodes



//===================================================================
//
// NumberNodesFrom
//
// Revise the Rank of all nodes reachable by upstream steps from pfg
// If we find the Rank of an immediately upstream node is set to >=cRank+1
// then we leave it alone.  Otherwise we set it to cRank+1 and recursively
// number the nodes on from it.
//===================================================================

HRESULT CFilterGraph::NumberNodesFrom( CFilGenList &cfgAll, FilGen * pfg, int cRank)
{
    // the 40000000 thing is to prevent infinite loops on cyclic-looking graphs
    // filters we've visited before won't be traversed past.
    pfg->Rank += 0x40000000;

    HRESULT hr;   // return code from things we call

    // recursive tree walk

    //------------------------------------------------------------------------
    // For pfgUpstream = each node which is an upstream connection from pfg
    //------------------------------------------------------------------------

    FilGen * pfgUpstream;

    CEnumPin Next(pfg->pFilter, CEnumPin::PINDIR_INPUT);	// input pins only
    IPin *pPin;

    while ((LPVOID) (pPin = Next())) {

        IPin *pConnected;
        hr = pPin->ConnectedTo( &pConnected );        // Get ConnectionInfo

        pPin->Release();

        if (SUCCEEDED(hr) && pConnected!=NULL) {      // if it's connected
            PIN_INFO PinInf;

            hr = pConnected->QueryPinInfo( &PinInf);  // Get PIN_INFO of peer
            pConnected->Release();
            ASSERT(SUCCEEDED(hr));

            pfgUpstream = cfgAll.GetByFilter(PinInf.pFilter);

            QueryPinInfoReleaseFilter(PinInf);

            // This error occurs when a filter which is in the filter graph is connected to
            // a filter which is not in the filter graph.  This can occur if the user uses 
            // IGraphConfig::RemoveFilterEx() to remove a filter without disconnecting its'
            // pins. 
            if( NULL == pfgUpstream ) {
                return VFW_E_NOT_IN_GRAPH;
            }

            //----------------------------------------------------------------
            // if it's worth numbering, Number on from pfgUpstream
            //----------------------------------------------------------------
            if (pfgUpstream->Rank < cRank+1) {
                pfgUpstream->Rank = cRank+1;
                HRESULT hr = NumberNodesFrom(cfgAll, pfgUpstream, cRank+1);
                if( FAILED( hr ) ) {
                    return hr;
                }
            } // worth numbering
        } //connected
    }

    pfg->Rank -= 0x40000000;

    return S_OK;
} // NumberNodesFrom




//===================================================================
//
// NumberNodes
//
// Store in the Rank of each node the maximum number of upstream steps
// from any node in cfglRoots
//===================================================================
HRESULT CFilterGraph::NumberNodes(CFilGenList &cfgl, CFilGenList &cfglRoots)
{
    HRESULT hr;
    POSITION Pos;

    // for pfg = each node in the graph
    Pos = cfglRoots.GetHeadPosition();;
    while (Pos!=NULL) {
        FilGen * pfg;
        pfg = cfglRoots.GetNext(Pos);

        hr = NumberNodesFrom(cfgl, pfg, 0);
        if( FAILED( hr ) ) {
            return hr;
        }
    }

    return S_OK;
} // NumberNodes



//===================================================================
//
// SortList
//
// sort cfgl so that lower Ranks appear before higher ones
// PRECONDITION: The ranks are all set to non-negative small numbers.
// If something has a rank of a few million it will go very slowly!
//===================================================================
void CFilterGraph::SortList( CFilGenList & cfgl )
{

    CFilGenList cfglGrow(NAME("Temporary filter sort list"), this);
    int iRank;


    //----------------------------------------------------------------
    // Make successive passes through cfgl pulling out all the nodes
    // with rank 1, then all with rank 2 etc.  AddTail these to the end of
    // the growing list and delete them from the original list.
    // Stop when they have all gone.
    //----------------------------------------------------------------

    for (iRank=0; cfgl.GetCount()>0; ++iRank) {
        POSITION Pos;
        Pos = cfgl.GetHeadPosition();;
        while (Pos!=NULL) {
            FilGen * pfg;
            POSITION OldPos = Pos;
            pfg = cfgl.GetNext(Pos);        // side-effect Pos onto the next
            if (pfg->Rank==iRank) {
               cfglGrow.AddTail( cfgl.Remove(OldPos) );
            }
        }
    }


    //----------------------------------------------------------------
    // cfglGrow now has everything in it in the right order
    // so copy them all back to cfgl and let cfglGrow destroy itself.
    //----------------------------------------------------------------

    cfgl.AddTail(&cfglGrow);

} // SortList




//===================================================================
//
// UpstreamOrder
//
// sort mFG_FilGenList into an order such that downstream nodes are
// always encountered before upstream nodes.  Sort the connections too.
// If there is a Storage, destroy and re-write the connections list to it.
//===================================================================
HRESULT CFilterGraph::UpstreamOrder()
{
    if (mFG_iVersion==mFG_iSortVersion) return NOERROR;

    MSR_INTEGER(mFG_idIntel, 2001);

    CFilGenList cfglRoots(NAME("List of root filters"), this);

    // Find all the root nodes.  (cfglRoots is initially empty)
    HRESULT hr = MergeRootNodes( cfglRoots, mFG_FilGenList);
    if( FAILED( hr ) ) {
        return hr;
    }

    // NOTE:  This leaves the graph with the old version set.
    // So we will continue trying to sort it.  We will not
    // Run or Pause without another go.  That will trap the error.

    // set all the ranks to zero (zero steps from a root)
    ClearRanks( mFG_FilGenList );

    // number all the nodes in the graph by distance from a root
    hr = NumberNodes( mFG_FilGenList, cfglRoots );
    if( FAILED( hr ) ) {
        return hr;
    }

    // Sort the list according to rank order
    SortList( mFG_FilGenList );

    mFG_iSortVersion = mFG_iVersion;

#ifdef THROTTLE
    FindRenderers();
#endif // THROTTLE

    return NOERROR;

} // UpstreamOrder


#ifdef THROTTLE
HRESULT CFilterGraph::FindPinAVType(IPin* pPin, BOOL &bAudio, BOOL &bVideo)
{
    bAudio = FALSE;
    bVideo = FALSE;

    CMediaType cmt;
    HRESULT hr = pPin->ConnectionMediaType(&cmt);

    if (FAILED(hr)) {
        // I guess we just plough on, feeling ill.
    } else {

        if (cmt.majortype==MEDIATYPE_Audio) {
            bAudio = TRUE;
        }
        if (cmt.majortype==MEDIATYPE_Video) {
            bVideo = TRUE;
        }
        FreeMediaType(cmt);
    }

    return NOERROR;
}
#endif // THROTTLE


#ifdef THROTTLE
//===============================================================================
// FindRenderers
//
// Find all the audio renderers;
// store a non-AddReffed IBaseFilter pointers in mFG_AudioRenderers<[]>.pf
// and an AddReffed IQualityControl* in mFG_AudioRenderers<[]>.piqc
//
// Find all the video renderers; store their AddReffed IQualityControl pointers
// in mFG_VideoRenderers<[]>.
//
// An Audio(/Video) renderer has an input pin that is connected with a type
// with majortype of MEDIATYPE_Audio(/MEDIATYPE_Video) and either has
// no output pins or the input pin supports QueryInternalConnections and
// goes nowhere.
// (Sigh) I suppose a filter could be both an audio and a video renderer.
// (Deep sigh) Multiple input pin audio renderers not supported.
//===============================================================================
HRESULT CFilterGraph::FindRenderers()
{
    HRESULT hr;
    ClearRendererLists();

    // for pfg->pFilter = each filter in the graph
    POSITION Pos = mFG_FilGenList.GetHeadPosition();
    while(Pos!=NULL) {
        // Make *pfg the current FilGen, side-effect Pos on to the next
        FilGen * pfg = mFG_FilGenList.GetNext(Pos);

        BOOL bHasOutputPin = FALSE;  // TRUE iff we ever find one
        BOOL bAudioRender = FALSE;   // TRUE<=>Found a pin that QIC says renders
        BOOL bVideoRender = FALSE;   // TRUE<=>Found a pin that QIC says renders
        BOOL bAudioPin = FALSE;      // TRUE<=>Found pin, but no QIC info
        BOOL bVideoPin = FALSE;      // TRUE<=>Found pin, but no QIC info

        // for pPin = each pin in pfg->pFilter
        //     (We could exit early if we have established already that it renders
        //      both types, but this is probably rare, so no early loop exits.)
        CEnumPin NextPin(pfg->pFilter);
        IPin *pPin;
        while ((LPVOID) (pPin = NextPin())) {

            // Check the direction
            PIN_DIRECTION pd;
            hr = pPin->QueryDirection(&pd);
            if (FAILED(hr)) {
                // Unknown direction!  really!!  Whatever next!!!
                // treat as output pin => we won't mess with it.
                bHasOutputPin = TRUE;
            } else if ( pd==PINDIR_OUTPUT ) {
                bHasOutputPin = TRUE;
            } 
            else {
                // it's an input pin
                BOOL bA;
                BOOL bV;
                hr = FindPinAVType(pPin, bA, bV);
                if ( (hr==NOERROR) && (bA || bV) ) {
                    // See if it is a pin that goes nowhere
                    ULONG nPin = 0;
                    hr = pPin->QueryInternalConnections(NULL, &nPin);
                    if (FAILED(hr)) {
                        if (bA) {
                            bAudioPin = TRUE; // wait to see if no output pins
                        }
                        if (bV) {
                            bVideoPin = TRUE; // wait to see if no output pins
                        }

                    } else if (hr==NOERROR) {
                        if (bA) {
                            bAudioRender = TRUE;
                        }
                        if (bV) {
                            bVideoRender = TRUE;
                        }
                    }
                }
            }

            pPin->Release();
        } // pins loop

        if (!bHasOutputPin) {
            if (bVideoPin) {
                bVideoRender = TRUE;
            }
            if (bAudioPin) {
                bAudioRender = TRUE;
            }
        }

        if (bAudioRender) {
            AudioRenderer* pAR = new AudioRenderer;
            if (pAR!=NULL) {
                pAR->pf = pfg->pFilter;

                hr = pAR->pf->QueryInterface( IID_IQualityControl
                                            , (void**)&pAR->piqc
                                            );
                if (SUCCEEDED(hr)) {
                    hr = pAR->piqc->SetSink(this);
                    ASSERT(SUCCEEDED(hr));
                    mFG_AudioRenderers.AddTail(pAR);
                } else {
                    // It's a dud - throw it all away
                    delete pAR;
                }
            }
        }

        if (bVideoRender) {
            IQualityControl * piqc;
            hr = pfg->pFilter->QueryInterface(IID_IQualityControl, (void**)&piqc);
            if (SUCCEEDED(hr)) {
                mFG_VideoRenderers.AddTail(piqc);
            }
        }
    } // filters loop

    return NOERROR;

} // FindRenderers


// Clear out anything that's in mFG_AudioRenderers and mFG_VideoRenderers
// Release any ref counts held
HRESULT CFilterGraph::ClearRendererLists()
{

    // for pAR = each audio renderer filter
    POSITION Pos = mFG_AudioRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        // Retrieve the current IBaseFilter, side-effect Pos on to the next
        // but remember where we were to delete it.
        POSITION posDel = Pos;
        AudioRenderer * pAR = mFG_AudioRenderers.GetNext(Pos);

        // Undo the SetSink
        if (pAR->piqc) {
            pAR->piqc->SetSink(NULL);
            pAR->piqc->Release();
            pAR->piqc = NULL;
        }

        mFG_AudioRenderers.Remove(posDel);
        delete pAR;
    }

    // for piqc = the IQualityControl interface on each video renderer filter
    Pos = mFG_VideoRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        // Retrieve the current IBaseFilter, side-effect Pos on to the next
        // but remember where we were to delete it.
        POSITION posDel = Pos;
        IQualityControl * piqc = mFG_VideoRenderers.GetNext(Pos);

        piqc->Release();
        mFG_VideoRenderers.Remove(posDel);
    }

    return NOERROR;

} // ClearRendererLists

#endif // THROTTLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\sprov.h ===
// Copyright (c)2000 Microsoft Corporation.  All Rights Reserved.

#ifndef __SPROV__H_
#define __SPROV__H_

/////////////////////////////////////////////////////////////////////////////
//  CServiceProvider
//
//      Maintains a map between a service identifier guid (SID), and an IUnknown.
//      Objects can register COM objects, and other com objects can extract them
//      later.  This makes cross object access easier.  Only one object with a
//      give SID can be registered at any one time.   Registering another one will
//      cause the first one to be released.
//
//      To use:
//          1) some main object hosts the CServiceProvider
//                  pUnkMain,,,
//          2) That object supports a way for other objects to access it.  It
//              is suggested that it aggregates with this one.
//          3) The object intializes the client site...
//                 pUnkMain->SetServiceProviderClientSite(),
//                probably done in the SetSite() method call...
//          4) Some object access the main object, and registers a sub-object via.
//                  IRegisterServiceProvider *pRSP;
//                  CRandomComObject    cObj;
//                  hr = pUnkMain->QueryInterface(IRegisterServiceProvider, &pRSP);
//                  if(!FAILED(hr)) {
//                      IRandomInterface *pIRI;
//                      hr = cObj->QueryInterface(IRandomInterface, &pIRI);
//                      pRSP->RegisterService(SID, pIRI);
//          5) Some final object access the main object to locate this one
//                  IServiceProvider *pSP;
//                  hr = pUnkMain->QueryInterface(IServiceProvider, &pRSP);
//                  if(!FAILED(hr)) {
//                      IRandomInterface *pIRI;
//                      hr = pRSP->QueryService(SID, IID_IRandomInterface, &pIRI);
//
//
//      To avoid ref-counting circular loops, objects should never register themselves (or
//      objects that hold reference counts back on them).  They should always register
//      sub-objects.  Either that, or the system must call UnregisterAllServices()
//      before it's final release.
//
//      Objects are reference counted inside this internal list. They must be either unregistered
//      (by registering them with same SID and a NULL value), the object m_filterGraph object
//      must be deleted cleanly, or the UnRegisterAll() method must be called.
//      (Use of UnRegisterAll is not suggested.   Instead, registered services should not
//      refcount the filter graph to avoid introducing circular reference countes in the first place.)
// -----------------------------------------------------------------------------

class CFilterGraph;

//  Container for IServiceProvider objects
class CServiceProvider : public IServiceProvider,
                         public IRegisterServiceProvider
{
    //  Members
    CCritSec m_cs;                      // not using?  Not implemented?
    struct ProviderEntry {
        struct ProviderEntry *pNext;
        CComPtr <IUnknown> pProvider;
        GUID               guidService;
        ProviderEntry(IUnknown *pUnk, REFGUID guid) :
            pProvider(pUnk), guidService(guid)
        {
        }
    } *m_List;

public:

    CServiceProvider() : m_List(NULL)
    {
    }

    ~CServiceProvider()                 // deletes all services
    {
        UnregisterAll();
    }

    //  IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid,
                              void **ppv);

    //  IRegisterServiceProvider
    STDMETHODIMP RegisterService(REFGUID guidService, IUnknown *pService)
    {
        CAutoLock lck(&m_cs);
        ProviderEntry **ppSearch = &m_List;
        while (*ppSearch) {
            if ((*ppSearch)->guidService == guidService) {
                break;
            }
            ppSearch = &(*ppSearch)->pNext;
        }
        if (pService) {
            if (*ppSearch) {
                return E_FAIL;
            } else {
                ProviderEntry *pEntry = new ProviderEntry(pService, guidService);
                if (NULL == pEntry) {
                    return E_OUTOFMEMORY;
                }
                pEntry->pNext = m_List;		// push new entry onto front of list...
                m_List = pEntry;
                return S_OK;
            }
        } else {
            if (*ppSearch) {
                ProviderEntry *pEntry = *ppSearch;
                *ppSearch = pEntry->pNext;
                delete pEntry;
            }
            return S_OK;
        }
    }



    STDMETHODIMP UnregisterAll()                        // deletes all services
    {
        while (m_List) {
            ProviderEntry *pEntry = m_List;
            m_List = m_List->pNext;
            delete pEntry;
        }
        return S_OK;
    }
};

#endif // __SPROV__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\stats.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <stats.h>
#include <statsif.h>
#include <math.h>

CStat::CStat(LPCWSTR lpszName)
{
    m_dMultiplier = 1.0;
    Reset();

    //  Save the name
    AMGetWideString(lpszName, &m_szName);
}

CStat::~CStat()
{
    CoTaskMemFree(m_szName);
}

void CStat::Reset()
{
    m_lCount = 0;
    m_dTotal = 0.0;
    m_dSumSq = 0.0;
    m_dMin   = 0.0;
    m_dMax   = 0.0;
    m_dLast  = 0.0;
}


CStats::CStats() :
    m_nEntries(0),
    m_ppStats(NULL)
{
}

void CStats::Init()
{
    LARGE_INTEGER Freq;
    QueryPerformanceFrequency(&Freq);
    m_QPFMultiplier = 1000.0 / (double)Freq.QuadPart;
}

CStats::~CStats()
{
    for (long i = 0; i < m_nEntries; i++) {
        delete m_ppStats[i];
    }
    delete [] m_ppStats;
}

void CStats::Reset()
{
    CAutoLock lck(&m_cs);

    //  Free all the entries
    for (long i = 0; i < m_nEntries; i++) {
        m_ppStats[i]->Reset();
    }
}

long CStats::Find(LPCWSTR lpszName, bool bCreate)
{
    CAutoLock lck(&m_cs);

    for (long i = 0; i < m_nEntries; i++) {
        if (0 == lstrcmpiWInternal(lpszName, m_ppStats[i]->m_szName)) {
            return i;
        }
    }
    if (!bCreate) {
        return -1;
    }
    CStat *pStat = new CStat(lpszName);
    if (NULL == pStat || pStat->m_szName == NULL) {
        delete pStat;
        return -1;
    }
    //  Check if we can extend the array
    if (0 == (m_nEntries % ALLOCATION_SIZE)) {
        CStat **ppNew = new PCSTAT[m_nEntries + ALLOCATION_SIZE];
        if (ppNew == NULL) {
            delete pStat;
            return -1;
        }
        CopyMemory(ppNew, m_ppStats, m_nEntries * sizeof(ppNew[0]));
        delete [] m_ppStats;
        m_ppStats = ppNew;
    }
    m_ppStats[m_nEntries++] = pStat;
    return m_nEntries - 1;
}

HRESULT CStats::GetValues(
        long iStat,
        BSTR *szName,
        long *lCount,
        double *dLast,
        double *dAverage,
        double *dStdDev,
        double *dMin,
        double *dMax
)
{
    CAutoLock lck(&m_cs);
    if (iStat >= m_nEntries || iStat < 0) {
        return E_INVALIDARG;
    }
    if (szName) {
        *szName = SysAllocString(m_ppStats[iStat]->m_szName);
        if (*szName == NULL) {
            return E_OUTOFMEMORY;
        }
    }
    CStat *pStat = m_ppStats[iStat];

    *lCount = pStat->m_lCount;
    if (pStat->m_lCount != 0) {
        *dAverage = pStat->m_dTotal / pStat->m_lCount;
    } else {
        *dAverage = 0.0;
    }
    if (pStat->m_lCount > 1) {
        *dStdDev = sqrt((pStat->m_dSumSq - pStat->m_lCount * (*dAverage * *dAverage)) / (pStat->m_lCount - 1));
    } else {
        *dStdDev = 0.0;
    }
    *dMin = pStat->m_dMin;
    *dMax = pStat->m_dMax;
    *dLast = pStat->m_dLast;
    return S_OK;
}

//  This is like an initialization method
void CStats::SetMultiplier(long iStat, double dMultiplier)
{
    CAutoLock lck(&m_cs);
    m_ppStats[iStat]->m_dMultiplier = dMultiplier;
}

bool CStats::NewValue(LPCWSTR lpszName, double dValue)
{
    long iStat = Find(lpszName);
    if (iStat >= 0) {
        NewValue(iStat, dValue);
        return true;
    } else {
        return false;
    }
}

bool CStats::NewValue(LPCWSTR lpszName, LONGLONG dValue)
{
    long iStat = Find(lpszName);
    if (iStat >= 0) {
        NewValue(iStat, dValue);
        return true;
    } else {
        return false;
    }
}
bool CStats::NewValue(long iStat, LONGLONG llValue)
{
    return NewValue(iStat, (double)llValue);
}
bool CStats::NewValue(long iStat, double dValue)
{
    CAutoLock lck(&m_cs);
    if (iStat < 0 || iStat >= m_nEntries) {
        return false;
    }
    ASSERT(iStat < m_nEntries);
    CStat *pStat = m_ppStats[iStat];
    dValue *= pStat->m_dMultiplier;
    pStat->m_dLast = dValue;
    if (pStat->m_lCount == 0) {
        pStat->m_dMin = dValue;
        pStat->m_dMax = dValue;
    }
    pStat->m_lCount++;
    pStat->m_dTotal += dValue;
    pStat->m_dSumSq += dValue * dValue;
    if (dValue < pStat->m_dMin) {
        pStat->m_dMin = dValue;
    } else {
        if (dValue > pStat->m_dMax) {
            pStat->m_dMax = dValue;
        }
    }
    return true;
}

double CStats::GetQPFMultiplier()
{
    return m_QPFMultiplier;
}

double CStats::GetTime()
{
    LARGE_INTEGER li;
    QueryPerformanceCounter(&li);
    return (double)li.QuadPart * m_QPFMultiplier;
}

//  Reset all stats
STDMETHODIMP CStatContainer::Reset()
{
    g_Stats.Reset();
    return S_OK;
}

//  Get number of stats collected
STDMETHODIMP CStatContainer::get_Count(LONG* plCount)
{
    if (plCount == NULL) {
        return E_POINTER;
    }
    *plCount = g_Stats.m_nEntries;
    return S_OK;
}

//  Pull out a specific value by position
STDMETHODIMP CStatContainer::GetValueByIndex(
                             long lIndex,
                             BSTR *szName,
                             long *lCount,
                             double *dLast,
                             double *dAverage,
                             double *dStdDev,
                             double *dMin,
                             double *dMax)
{
    if (NULL == ((DWORD_PTR)szName |
                 (DWORD_PTR)lCount |
                 (DWORD_PTR)dLast |
                 (DWORD_PTR)dAverage |
                 (DWORD_PTR)dStdDev |
                 (DWORD_PTR)dMin |
                 (DWORD_PTR)dMax)) {
        return E_POINTER;
    }
    return g_Stats.GetValues(lIndex, szName, lCount, dLast, dAverage, dStdDev, dMin, dMax);
}

//  Pull out a specific value by name
STDMETHODIMP CStatContainer::GetValueByName(BSTR szName,
                       long *plIndex,
                       long *lCount,
                       double *dLast,
                       double *dAverage,
                       double *dStdDev,
                       double *dMin,
                       double *dMax)
{
    if (NULL == ((DWORD_PTR)plIndex |
                 (DWORD_PTR)lCount |
                 (DWORD_PTR)dLast |
                 (DWORD_PTR)dAverage |
                 (DWORD_PTR)dStdDev |
                 (DWORD_PTR)dMin |
                 (DWORD_PTR)dMax)) {
        return E_POINTER;
    }

    long lIndex = g_Stats.Find(szName);
    if (lIndex < 0) {
        return E_INVALIDARG;
    }
    *plIndex = lIndex;
    g_Stats.GetValues(lIndex, NULL, lCount, dLast, dAverage, dStdDev, dMin, dMax);
    return S_OK;
}

//  Return the index for a string - optinally create
STDMETHODIMP CStatContainer::GetIndex(BSTR szName,
                                       long lCreate,
                                       long *plIndex)
{
    if (plIndex == NULL) {
        return E_POINTER;
    }
    long lIndex = g_Stats.Find(szName, lCreate != 0);
    if (lIndex < 0) {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
    *plIndex = lIndex;
    return S_OK;
}

//  Add a new value
STDMETHODIMP CStatContainer::AddValue(long lIndex,
                      double dValue)
{
    return g_Stats.NewValue(lIndex, dValue) ? S_OK : E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\statsif.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//  Container for stats info to expose it as an interface

class CStatContainer :
	public IDispatchImpl<IAMStats, &IID_IAMStats, &LIBID_QuartzTypeLib>,
	public CComObjectRootEx<CComMultiThreadModel>
{
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CStatContainer)
	COM_INTERFACE_ENTRY(IAMStats)
	COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    CStatContainer() {}

    //  Interface methods

    //  Reset all stats
    STDMETHODIMP Reset();

    //  Get number of stats collected
    STDMETHODIMP get_Count(LONG* plCount);

    //  Pull out a specific value by position
    STDMETHODIMP GetValueByIndex(long lIndex,
                                 BSTR *szName,
                                 long *lCount,
                                 double *dLast,
                                 double *dAverage,
                                 double *dStdDev,
                                 double *dMin,
                                 double *dMax);

    //  Pull out a specific value by name
    STDMETHODIMP GetValueByName(BSTR szName,
                           long *lIndex,
                           long *lCount,
                           double *dLast,
                           double *dAverage,
                           double *dStdDev,
                           double *dMin,
                           double *dMax);

    //  Return the index for a string - optinally create
    STDMETHODIMP GetIndex(BSTR szName,
                          long lCreate,
                          long *plIndex);

    STDMETHODIMP AddValue(long lIndex, double dValue);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\squish\regtypes.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#ifndef _REGTYPES_H
#define _REGTYPES_H

// // OK to have zero instances of pin In this case you will have to
// // Create a pin to have even one instance
// #define REG_PIN_B_ZERO 0x1

// // The filter renders this input
// #define REG_PIN_B_RENDERER 0x2

// // OK to create many instance of  pin
// #define REG_PIN_B_MANY 0x4

// // This is an Output pin
// #define REG_PIN_B_OUTPUT 0x8

// format used to store filters in the registry

typedef struct
{
    CLSID clsMedium;
    DWORD dw1;
    DWORD dw2;
} REGPINMEDIUM_REG;

// structure used to identify media types this pin handles. these look
// like the ones used by IFilterMapper2 but are used to read the info
// out of the registry
typedef struct
{
    DWORD dwSignature;          // '0ty2'
    DWORD dwReserved;           // 0
    DWORD dwclsMajorType;
    DWORD dwclsMinorType;
} REGPINTYPES_REG2;

typedef struct
{
    DWORD dwSignature;          // '0pi2'
    DWORD dwFlags;
    DWORD nInstances;

    DWORD nMediaTypes;
    DWORD nMediums;
    DWORD dwClsPinCategory;
    
} REGFILTERPINS_REG2;

typedef struct
{
    // must match REGFILTER_REG2
    DWORD dwVersion;            // 1 
    DWORD dwMerit;
    DWORD dwcPins;

} REGFILTER_REG1;

typedef struct
{
    // first three must match REGFILTER_REG1
    DWORD dwVersion;            // 2
    DWORD dwMerit;
    DWORD dwcPins;
    DWORD dwReserved;           // 0
} REGFILTER_REG2;

// from ie4

typedef struct
{
    DWORD dwSignature;          // '0typ'
    CLSID clsMajorType;
    CLSID clsMinorType;
} REGPINTYPES_REG1;

typedef struct
{
    DWORD dwSignature;          // '0pin'
    DWORD dwFlags;
    CLSID clsConnectsToFilter;
    UINT nMediaTypes;
    DWORD rgMediaType;
    DWORD strName;              // ansi strings
    DWORD strConnectsToPin;

} REGFILTERPINS_REG1;

typedef struct
{
    DWORD dwiPin;               // pin to which these mediums belongs
    DWORD dwcMediums;           // number of mediums in list
    // array of dwcMediums REGPINMEDIUM_REG structures follow
} REGMEDIUMSDATA_REG;


#endif // _REGTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\util.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1999 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef Utility_h
#define Utility_h

//  Useful pin list type
template<class _Class> class CInterfaceList : public CGenericList<_Class>
{
public:
    ~CInterfaceList() {
        while (0 != GetCount()) {
            RemoveTail()->Release();
        }
    }

    CInterfaceList() : CGenericList<_Class>(NAME("CInterfaceList")) {}

    //  Base class doesn't support GetPrev
    _Class *GetPrev(POSITION& rp) const
    {
        /* have we reached the end of the list */

        if (rp == NULL) {
            return NULL;
        }

        /* Lock the object before continuing */

        void *pObject;

        /* Copy the original position then step on */

        CNode *pn = (CNode *) rp;
        ASSERT(pn != NULL);
        rp = (POSITION) pn->Prev();

        /* Get the object at the original position from the list */

        pObject = pn->GetData();
        // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.
        return (_Class *)pObject;
    }
};

typedef CInterfaceList<IPin> CPinList;
typedef CInterfaceList<IBaseFilter> CFilterList;

// Pin Utility Functions
void GetFilter(IPin *pPin, IBaseFilter **ppFilter);
HRESULT GetFilterWhichOwnsConnectedPin(IPin* pPin, IBaseFilter** ppFilter);
int Direction(IPin *pPin);
bool IsConnected(IPin* pPin);

bool ValidateFlags( DWORD dwValidFlagsMask, DWORD dwFlags );

//  Registry helper to read DWORDs from the registry
//  Returns ERROR ... codes returned by registry APIs
LONG GetRegistryDWORD(HKEY hkStart, LPCTSTR lpszKey, LPCTSTR lpszValueName,
                      DWORD *pdwValue);

#endif // Utility_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\squish\squish.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <aviriff.h>

#include "regtypes.h"
#include "squish.h"
#include "malloc.h"

//  code to take the REGFILTER2 structure and generate a REGFILTER_REG
//  structure for the FilterData value in the registry.

/* allocate space sequentially in memory block for FilterData
   block. return byte offset */
DWORD CSquish::RgAlloc(DWORD cb)
{
    ASSERT(cb % sizeof(DWORD) == 0);

    // our code makes sure enough space is available before hand
    ASSERT(cb <= m_rgMemAlloc.cbLeft);

    DWORD ib = m_rgMemAlloc.ib;
    m_rgMemAlloc.cbLeft -= cb;
    m_rgMemAlloc.ib += cb;

    return ib;
}

// return a offset to the guid (re-using any existing, matching guid)
//
DWORD CSquish::AllocateOrCollapseGuid(const GUID *pGuid)
{
    if(pGuid == 0) {
        return 0;
    }

    for(UINT iGuid = 0; iGuid < m_cGuids; iGuid++)
    {
        if(m_pGuids[iGuid] == *pGuid)
        {
            return (DWORD)((BYTE *)&m_pGuids[iGuid] - m_rgMemAlloc.pb);
        }
    }

    DWORD dwi = RgAlloc(sizeof(GUID));
    if(m_cGuids == 0) {
        m_pGuids = (GUID *)(m_rgMemAlloc.pb + dwi);
    }
    else
    {
        ASSERT(m_rgMemAlloc.pb + dwi == (BYTE *)(m_pGuids + m_cGuids));
    }
    m_pGuids[m_cGuids++] = *pGuid;
    return dwi;
}

DWORD CSquish::AllocateOrCollapseMedium(const REGPINMEDIUM *pMedium)
{
    if(pMedium == 0) {
        return 0;
    }

    for(UINT iMedium = 0; iMedium < m_cMediums; iMedium++)
    {
        if(IsEqualMedium(&m_pMediums[iMedium], pMedium))
        {
            return (DWORD)((BYTE *)&m_pMediums[iMedium] - m_rgMemAlloc.pb);
        }
    }

    DWORD dwi = RgAlloc(sizeof(REGPINMEDIUM));
    if(m_cMediums == 0) {
        m_pMediums = (REGPINMEDIUM *)(m_rgMemAlloc.pb + dwi);
    }
    else
    {
        ASSERT(m_rgMemAlloc.pb + dwi == (BYTE *)(m_pMediums + m_cMediums));
    }
    m_pMediums[m_cMediums++] = *pMedium;
    return dwi;
}

/* access same member (must be the same type) in two structures
   depending on dwVersion. The compiler does realize they are at the
   same offset. but it appears to compute structure offset often
   though */

#define GetPinMember(prf, i, member) (                  \
    prf->dwVersion == 1 ? prf->rgPins[i].member :       \
    prf->rgPins2[i].member)

#define GetTypeMember(prf, iPin, iType, member) (                       \
    prf->dwVersion == 1 ? prf->rgPins[iPin].lpMediaType[iType].member : \
    prf->rgPins2[iPin].lpMediaType[iType].member)

ULONG CSquish::CbRequiredSquish(const REGFILTER2 *pregFilter)
{
    ULONG cb = sizeof(REGFILTER_REG2);
    ULONG cPins = pregFilter->cPins;
    ULONG iPin;

    ASSERT(cb % sizeof(DWORDLONG) == 0);
    ASSERT(sizeof(REGFILTERPINS_REG2) % sizeof(DWORDLONG) == 0);
    ASSERT(sizeof(REGPINTYPES_REG2) % sizeof(DWORDLONG) == 0);

    cb += cPins * sizeof(REGFILTERPINS_REG2);

    for(iPin = 0; iPin < cPins; iPin++)
    {
        ULONG iType;
        const WCHAR *wszTmp;
        const CLSID *pclsidTmp;

        if(pregFilter->dwVersion == 2)
        {
            const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];

            // space for the pointer and the medium for each medium
            cb += prfp2->nMediums *
                (sizeof(REGPINMEDIUM_REG) + sizeof(DWORD));

            if(prfp2->clsPinCategory) {
                cb += sizeof(GUID);
            }
        }

        // worst case: REGPINTYPES_REG struct + 2 guids per media type
        cb += (ULONG)(GetPinMember(pregFilter, iPin, nMediaTypes) *
            (sizeof(REGPINTYPES_REG2) + sizeof(GUID) * 2));
    }

    return cb;
}

// constructor
//
CSquish::CSquish() :
        m_pGuids(0),
        m_cGuids(0),
        m_pMediums(0),
        m_cMediums(0)
{

}

// fill out the bits. S_FALSE means caller needs to allocate *pcbUsed
// bytes in pb
// Filters are stored one after the other

HRESULT CSquish::RegSquish(
    BYTE *pb,
    const REGFILTER2 **ppregFilter,
    ULONG *pcbUsed,
    int nFilters
)
{
    HRESULT hr = S_OK;
    ULONG cbLeft;               /* bytes required */
    ULONG ib = 0;               /* current byte offset */

    if(pcbUsed == 0) {
        return E_POINTER;
    }

    // save pointer to the first pin for each filter
    REGFILTERPINS_REG2 **ppPinReg0 =
        (REGFILTERPINS_REG2 **)_alloca(nFilters * sizeof(REGFILTERPINS_REG2 *));

    // caller needs to know how much space to allocate. we don't care
    // much about performance registering filters; caller calls twice
    // per filter.
    cbLeft = 0;
    for (int i = 0; i < nFilters; i++) {
        cbLeft += CbRequiredSquish(ppregFilter[i]);
    }
    if(cbLeft > *pcbUsed)
    {
        *pcbUsed = cbLeft;
        return S_FALSE;
    }

    m_rgMemAlloc.ib = 0;
    m_rgMemAlloc.cbLeft = cbLeft;
    m_rgMemAlloc.pb = pb;

    for (int iFilter = 0; iFilter < nFilters; iFilter++) {
        const REGFILTER2 *pregFilter = ppregFilter[iFilter];
        if(pregFilter->dwVersion != 2 &&
           pregFilter->dwVersion != 1)
        {
            return E_INVALIDARG;
        }

        {
            DWORD dwi = RgAlloc(sizeof(REGFILTER_REG2));

            ((REGFILTER_REG2 *)(pb + dwi))->dwMerit = pregFilter->dwMerit;
            ((REGFILTER_REG2 *)(pb + dwi))->dwcPins = pregFilter->cPins;
            ((REGFILTER_REG2 *)(pb + dwi))->dwVersion = 2;
            ((REGFILTER_REG2 *)(pb + dwi))->dwReserved = 0;
        }


        UINT iPin;
        ULONG cPins = pregFilter->cPins;


        // first pass: allocate space for everything exceept the guids and
        // mediums at the end (the pins, mediatypes, and medium ptrs need
        // to be contiguous).

        for(iPin = 0; iPin < cPins; iPin++)
        {
            DWORD dwi = RgAlloc(sizeof(REGFILTERPINS_REG2));
            REGFILTERPINS_REG2 *pPinReg = (REGFILTERPINS_REG2 *)(pb + dwi);
            if(iPin == 0) {
                ppPinReg0[iFilter] = pPinReg;
            }

            {
                DWORD dwSig = FCC('0pi3');
                (*(BYTE *)&dwSig) += (BYTE)iPin;
                pPinReg->dwSignature = dwSig;
            }

            pPinReg->nMediaTypes = GetPinMember(pregFilter, iPin, nMediaTypes);
            RgAlloc(sizeof(REGPINTYPES_REG2) * pPinReg->nMediaTypes);

            if(pregFilter->dwVersion == 1)
            {
                const REGFILTERPINS *prfp = &pregFilter->rgPins[iPin];
                pPinReg->dwFlags =
                    (prfp->bRendered ? REG_PINFLAG_B_RENDERER : 0) |
                    (prfp->bOutput   ? REG_PINFLAG_B_OUTPUT   : 0) |
                    (prfp->bMany     ? REG_PINFLAG_B_MANY     : 0) |
                    (prfp->bZero     ? REG_PINFLAG_B_ZERO     : 0) ;

                pPinReg->nMediums = 0;
                pPinReg->nInstances = 0;
            }
            else
            {
                const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];
                pPinReg->dwFlags = prfp2->dwFlags & (
                    REG_PINFLAG_B_RENDERER |
                    REG_PINFLAG_B_OUTPUT  |
                    REG_PINFLAG_B_MANY    |
                    REG_PINFLAG_B_ZERO);

                pPinReg->nMediums = prfp2->nMediums;
                RgAlloc(sizeof(DWORD) * pPinReg->nMediums);

                pPinReg->nInstances = prfp2->cInstances;
            }
        }
    }


    for (iFilter = 0; iFilter < nFilters; iFilter++) {
        const REGFILTER2 *pregFilter = ppregFilter[iFilter];
        // 2nd pass: fill in the pointers for guids
        REGFILTERPINS_REG2 *pPinReg = ppPinReg0[iFilter];
        UINT iPin;
        ULONG cPins = pregFilter->cPins;
        for(iPin = 0; iPin < cPins; iPin++)
        {

            const REGPINTYPES *rgpt = GetPinMember(pregFilter, iPin, lpMediaType);
            UINT ctypes = GetPinMember(pregFilter, iPin, nMediaTypes);

            if(pregFilter->dwVersion == 2)
            {
                const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];
                pPinReg->dwClsPinCategory = AllocateOrCollapseGuid(prfp2->clsPinCategory);
            }
            else
            {
                pPinReg->dwClsPinCategory = 0;
            }

            // media types start immediately after pin this pin
            REGPINTYPES_REG2 *pmtReg = (REGPINTYPES_REG2 *)(pPinReg + 1);

            for(UINT imt = 0; imt < ctypes; imt++)
            {
                DWORD dwSig = FCC('0ty3');
                (*(BYTE *)&dwSig) += (BYTE)imt;
                pmtReg->dwSignature = dwSig;

                pmtReg->dwclsMajorType = AllocateOrCollapseGuid(rgpt[imt].clsMajorType);
                pmtReg->dwclsMinorType = AllocateOrCollapseGuid(rgpt[imt].clsMinorType);
                pmtReg->dwReserved = 0;
                pmtReg++;
            }


            // mediums start immediately after media types
            DWORD *pmedReg = (DWORD *)pmtReg;
            if(pregFilter->dwVersion == 2)
            {
                const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];
                UINT cMediums = prfp2-> nMediums;
                pmedReg += cMediums;
            }

            // then comes the next pin
            pPinReg = (REGFILTERPINS_REG2 *)pmedReg;
        }
    }

    for (iFilter = 0; iFilter < nFilters; iFilter++) {
        // 3rd pass: fill in the pointers for mediums
        const REGFILTER2 *pregFilter = ppregFilter[iFilter];
        REGFILTERPINS_REG2 *pPinReg = ppPinReg0[iFilter];
        UINT iPin;
        ULONG cPins = pregFilter->cPins;
        for(iPin = 0; iPin < cPins; iPin++)
        {
            // media types start immediately after pin
            REGPINTYPES_REG2 *pmtReg = (REGPINTYPES_REG2 *)(pPinReg + 1);
            UINT ctypes = GetPinMember(pregFilter, iPin, nMediaTypes);
            pmtReg += ctypes;

            // mediums start immediately after media types
            DWORD *pmedReg = (DWORD *)pmtReg;
            if(pregFilter->dwVersion == 2)
            {
                const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];
                UINT cMediums = prfp2->nMediums;
                const REGPINMEDIUM *rgrpm = prfp2->lpMedium;
                for(UINT iMed = 0; iMed < cMediums; iMed++)
                {
                    *pmedReg = AllocateOrCollapseMedium(rgrpm);
                    rgrpm++;
                    pmedReg++;
                }
            }

            // then comes the next pin
            pPinReg = (REGFILTERPINS_REG2 *)pmedReg;
        }
    }

    *pcbUsed = m_rgMemAlloc.ib;

    return hr;
}

HRESULT
RegSquish(
    BYTE *pb,
    const REGFILTER2 **ppregFilter,
    ULONG *pcbUsed,
    int nFilters
)
{
    CSquish rs;
    return rs.RegSquish(pb, ppregFilter, pcbUsed, nFilters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\squish\squish.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// code to convert between the REGFILTER2 structure (defined in
// axextend.idl) and the REGFILTER_REG structure (defined in
// regtypes.h).

// exported functions

HRESULT RegSquish(
    BYTE *pb,                   // REGFILTER_REG (version = 2) out; can be null
    const REGFILTER2 **ppregFilter, // in
    ULONG *pcbUsed,               // bytes necessary/used
    int nFilters = 1);            //

HRESULT UnSquish(
    BYTE *pbSrc, ULONG cbIn,    // REGFILTER_REG (1 or 2) in
    REGFILTER2 ***pppDest,        // out
    int nFilters = 1);


// private stuff

struct RgMemAlloc
{
    DWORD ib;                   /* current byte */
    DWORD cbLeft;               /* bytes left */
    BYTE *pb;                   /* beginning of block */
};


class CSquish
{
public:
    CSquish();
    HRESULT RegSquish(BYTE *pb, const REGFILTER2 **pregFilter, ULONG *pcbUsed, int nFilters);
private:

    RgMemAlloc m_rgMemAlloc;

    // pointer to first guid/medium
    GUID *m_pGuids;
    REGPINMEDIUM *m_pMediums;

    // # allocated in m_pGuids/mediums
    UINT m_cGuids;
    UINT m_cMediums;

    DWORD RgAlloc(DWORD cb);
    DWORD AllocateOrCollapseGuid(const GUID *pGuid);
    DWORD AllocateOrCollapseMedium(const REGPINMEDIUM *pMed);
    ULONG CbRequiredSquish(const REGFILTER2 *pregFilter);
};

class CUnsquish
{
public:
    HRESULT UnSquish(
        BYTE *pbSrc, ULONG cbIn,
        REGFILTER2 ***pppDest, int iFilters);

private:
    RgMemAlloc m_rgMemAlloc;

    HRESULT CUnsquish::CbRequiredUnquishAndValidate(
        const BYTE *pbSrc,
        ULONG *pcbOut, ULONG cbIn
        );

    inline void *RgAllocPtr(DWORD cb);
    HRESULT UnSquishPins(
        REGFILTER2 *prf2, const REGFILTER_REG1 **prfr1, const BYTE *pbSrc);

    HRESULT UnSquishTypes(
        REGFILTERPINS2 *prfp2,
        const REGFILTERPINS_REG1 *prfpr1,
        const BYTE *pbSrc);

};

static inline bool IsEqualMedium(
    const REGPINMEDIUM *rp1,
    const REGPINMEDIUM *rp2)
{
    return
        rp1->clsMedium == rp2->clsMedium &&
        rp1->dw1 == rp2->dw1 &&
        rp1->dw2 == rp2->dw2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\squish\unsquish.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <aviriff.h>

#include "regtypes.h"
#include "squish.h"

// code to parse the FilterData value in the registry and return the
// REGFILTER2 structure defined in axextend.idl

/* allocate space sequentially in memory block for a structure
   block. return pointer.  */
/* inline */ void *CUnsquish::RgAllocPtr(DWORD cb)
{

    // our code makes sure enough space is available before hand
    ASSERT(cb <= m_rgMemAlloc.cbLeft);
    ASSERT(cb % sizeof(DWORD) == 0);

    DWORD ib = m_rgMemAlloc.ib;
    m_rgMemAlloc.cbLeft -= cb;
    m_rgMemAlloc.ib += cb;

    return ib + m_rgMemAlloc.pb;
}

// for the REGFILTERPINS_REG1 (old format) of pins only: parse the
// media types.

HRESULT CUnsquish::UnSquishTypes(
    REGFILTERPINS2 *prfp2,
    const REGFILTERPINS_REG1 *prfpr1,
    const BYTE *pbSrc)
{
    UINT imt;
    UINT cmt = prfpr1->nMediaTypes;
    REGPINTYPES *prpt = (REGPINTYPES *)RgAllocPtr(sizeof(REGPINTYPES) * cmt);

    prfp2->lpMedium = 0;
    prfp2->nMediums = 0;

    prfp2->lpMediaType = prpt;
    prfp2->nMediaTypes = cmt;

    for(imt = 0; imt < cmt ; imt++)
    {
        REGPINTYPES_REG1 *prptr = (REGPINTYPES_REG1 *)(pbSrc + prfpr1->rgMediaType) + imt;

        prpt->clsMajorType = (CLSID *)RgAllocPtr(sizeof(CLSID));
        CopyMemory((void *)prpt->clsMajorType, &prptr->clsMajorType, sizeof(GUID));

        prpt->clsMinorType = (CLSID *)RgAllocPtr(sizeof(CLSID));
        CopyMemory((void *)prpt->clsMinorType, &prptr->clsMinorType, sizeof(GUID));

        prpt++;
    }


    return S_OK;
}

// parse the pins
//
HRESULT CUnsquish::UnSquishPins(
    REGFILTER2 *prf2,           /* output */
    const REGFILTER_REG1 **pprfr1,
    const BYTE *pbSrc)
{
    HRESULT hr = S_OK;
    ASSERT(pprfr1);              // from validate step
    const REGFILTER_REG1 *prfr1 = *pprfr1;

    /* beginning of the buffer read from the registry */
    if(prfr1->dwVersion == 0)
    {
        UINT cPins = prf2->cPins;

        REGFILTERPINS2 *prfp2 = (REGFILTERPINS2 *)RgAllocPtr(sizeof(REGFILTERPINS2) * cPins);
        prf2->rgPins2 = prfp2;

        // array of pins is immediately after the REGFILTER_REG
        // structure
        REGFILTERPINS_REG1 *prfpr = (REGFILTERPINS_REG1 *)(prfr1 + 1);

        for(UINT iPin = 0; iPin < cPins; iPin++, prfpr++)
        {
            prfp2->dwFlags = prfpr->dwFlags & (REG_PINFLAG_B_RENDERER |
                                               REG_PINFLAG_B_OUTPUT |
                                               REG_PINFLAG_B_MANY |
                                               REG_PINFLAG_B_ZERO);

            // not available in the old format
            prfp2->cInstances = 0;
            prfp2->clsPinCategory = 0;

            hr = UnSquishTypes(prfp2, prfpr, pbSrc);
            if(FAILED(hr)) {
                return hr;
            }

            // not available in the old format
            prfp2->nMediums = 0;
            prfp2->lpMedium = 0;

            prfp2++;
        }
    }
    else if(prfr1->dwVersion == 2)
    {
        // get a pointer to the beginning of the buffer passed in
        const REGFILTER_REG2 *prfr2 = (REGFILTER_REG2 *)prfr1;
        UINT cPinsFilterData = prf2->cPins;

        REGFILTERPINS2 *pDestPin = (REGFILTERPINS2 *)RgAllocPtr(sizeof(REGFILTERPINS2) * cPinsFilterData);
        prf2->rgPins2 = pDestPin;

        // first pin immediate after REGFILTER_REG struct
        REGFILTERPINS_REG2 *pRegPin = (REGFILTERPINS_REG2 *)(prfr2 + 1);

        for(UINT iPin = 0; iPin < cPinsFilterData; iPin++, pDestPin++)
        {
            pDestPin->dwFlags = pRegPin->dwFlags & (REG_PINFLAG_B_RENDERER |
                                                    REG_PINFLAG_B_OUTPUT |
                                                    REG_PINFLAG_B_MANY |
                                                    REG_PINFLAG_B_ZERO);

            pDestPin->cInstances = pRegPin->nInstances;

            if(pRegPin->dwClsPinCategory)
            {
                pDestPin->clsPinCategory = (GUID *)RgAllocPtr(sizeof(GUID));
                CopyMemory(
                    (void *)pDestPin->clsPinCategory,
                    pbSrc + pRegPin->dwClsPinCategory,
                    sizeof(GUID));
            }
            else
            {
                pDestPin->clsPinCategory = 0;
            }

            UINT cmt = pRegPin->nMediaTypes;
            pDestPin->nMediaTypes = cmt;

            // media types immediately after corresponding pin
            REGPINTYPES_REG2 *pRegMt = (REGPINTYPES_REG2 *)(pRegPin + 1);

            pDestPin->lpMediaType = (REGPINTYPES *)RgAllocPtr(sizeof(REGPINTYPES) * cmt);
            for(UINT imt = 0; imt < cmt; imt++, pRegMt++)
            {
                {
                    DWORD dwSig1 = FCC('0ty3');
                    (*(BYTE *)&dwSig1) += (BYTE)imt;
                    ASSERT(pRegMt->dwSignature == dwSig1);
                }

                REGPINTYPES *pmt = (REGPINTYPES *)&pDestPin->lpMediaType[imt];
                if(pRegMt->dwclsMajorType)
                {
                    pmt->clsMajorType = (GUID *)RgAllocPtr(sizeof(GUID));
                    CopyMemory(
                        (void *)pmt->clsMajorType,
                        pbSrc + pRegMt->dwclsMajorType,
                        sizeof(GUID));
                }
                else
                {
                    pmt->clsMajorType = 0;
                }

                if(pRegMt->dwclsMinorType)
                {
                    pmt->clsMinorType= (GUID *)RgAllocPtr(sizeof(GUID));
                    CopyMemory(
                        (void *)pmt->clsMinorType,
                        pbSrc + pRegMt->dwclsMinorType,
                        sizeof(GUID));
                }
                else
                {
                    pmt->clsMinorType = 0;
                }

            } // mt loop

            //
            // mediums - first medium is immediately after last media
            // type. also we need to find any mediums in the
            // MediumsData value that need to go on this pin.
            //
            const DWORD *prpm = (DWORD *)(pRegMt);// first medium
            UINT cmedFilterData = pRegPin->nMediums;
            UINT cmed = cmedFilterData;
            pDestPin->nMediums = cmed;
            pDestPin->lpMedium = (REGPINMEDIUM *)RgAllocPtr(sizeof(REGPINMEDIUM) * cmed);

            const REGPINMEDIUM *pmed = pDestPin->lpMedium;

            for(UINT imed = 0; imed < cmedFilterData; imed++, prpm++, pmed++)
            {
                if(prpm)
                {
                    CopyMemory((void *)pmed, pbSrc + *prpm, sizeof(REGPINMEDIUM));
                }
                else
                {
                    DbgBreak("null medium");
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
            } // medium loop

            // next pin is after last medium
            pRegPin = (REGFILTERPINS_REG2 *)prpm;

        } // pin loop
        *pprfr1 = (const REGFILTER_REG1 *)pRegPin;

    }

    return hr;
}

// find out how many bytes to allocate and validate that the structure
// is valid. mainly make sure we don't read unallocated memory
HRESULT CUnsquish::CbRequiredUnquishAndValidate(
    const BYTE *pbSrc,
    ULONG *pcbOut, ULONG cbIn
    )
{
    HRESULT hr = S_OK;
    ULONG cb = 0;
    *pcbOut = 0;

    const REGFILTER_REG1 *prfr1 = (REGFILTER_REG1 *)pbSrc;

    if(prfr1 == 0 ||( prfr1->dwVersion != 0 && prfr1->dwVersion != 2)) {
        DbgLog((LOG_ERROR, 0, TEXT("invalid version #")));
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    ASSERT(prfr1);
    cb += sizeof(REGFILTER2);

    if(prfr1->dwVersion == 0)
    {
        UINT cPins = prfr1->dwcPins; // # pins from FilterData
        cb += cPins * sizeof(REGFILTERPINS2);

        UINT iPin;

        if(sizeof(REGFILTER_REG1) + cPins * sizeof(REGFILTERPINS_REG1) > cbIn)
        {
            DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        // first pin is immediately after REGFILTER_REG structure
        const REGFILTERPINS_REG1 *prfp1 = (REGFILTERPINS_REG1 *)(prfr1 + 1);

        for(iPin = 0; iPin < cPins; iPin++, prfp1++)
        {
            DWORD dwSig1 = FCC('0pin');
            (*(BYTE *)&dwSig1) += (BYTE)iPin;

            if(prfp1->dwSignature != dwSig1)
            {
                DbgLog((LOG_ERROR, 0, TEXT("invalid pin signature")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            // ignore strName, strConnectsToPin
            //

            UINT cmt = prfp1->nMediaTypes;
            UINT imt;
            cb += cmt * sizeof(REGPINTYPES);

            if(prfp1->rgMediaType + cmt * sizeof(REGPINTYPES_REG1) > cbIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }


            // pointer to media types
            const REGPINTYPES_REG1 *prpt1 =
                (REGPINTYPES_REG1 *)(pbSrc + prfp1->rgMediaType);

            for(imt = 0; imt < cmt ; imt++, prpt1++)
            {
                DWORD dwSig1 = FCC('0typ');
                (*(BYTE *)&dwSig1) += (BYTE)imt;


                if(prpt1->dwSignature != dwSig1)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("invalid type signature")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }

                // major + minor type
                cb += sizeof(CLSID) * 2;

            } /* mt loop */

        } /* pin for loop */

    } // version 0
    else
    {
        ASSERT(prfr1->dwVersion == 2);

        UINT iPin;
        const REGFILTER_REG2 *prfr2 = (REGFILTER_REG2 *)pbSrc;
        UINT cPins = prfr2->dwcPins; // # pins from FilterData
        cb += cPins * sizeof(REGFILTERPINS2);

        // first pin is immediately after REGFILTER_REG structure
        const REGFILTERPINS_REG2 *pRegPin = (REGFILTERPINS_REG2 *)(prfr2 + 1);

        for(iPin = 0; iPin < cPins; iPin++)
        {
            if((BYTE *)(pRegPin + 1) - pbSrc > (LONG)cbIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            DWORD dwSig1 = FCC('0pi3');
            (*(BYTE *)&dwSig1) += (BYTE)iPin;

            if(pRegPin->dwSignature != dwSig1)
            {
                DbgLog((LOG_ERROR, 0, TEXT("invalid pin signature")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if(pRegPin->dwClsPinCategory)
            {
                if(pRegPin->dwClsPinCategory + sizeof(GUID) > cbIn) {
                    DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
                cb += sizeof(GUID);
            }

            UINT cmt = pRegPin->nMediaTypes;
            UINT imt;
            cb += cmt * sizeof(REGPINTYPES);

            // media types immediately after corresponding pin
            const REGPINTYPES_REG2 *pRegMt = (REGPINTYPES_REG2 *)(pRegPin + 1);

            if((BYTE *)(pRegMt + cmt) - pbSrc > (LONG)cbIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            for(imt = 0; imt < cmt ; imt++, pRegMt++)
            {
                DWORD dwSig1 = FCC('0ty3');
                (*(BYTE *)&dwSig1) += (BYTE)imt;

                if(pRegMt->dwSignature != dwSig1)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("invalid type signature")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }

                if(pRegMt->dwclsMajorType + sizeof(CLSID) > cbIn)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
                cb += pRegMt->dwclsMajorType ? sizeof(CLSID) : 0;
                if(pRegMt->dwclsMinorType + sizeof(CLSID) > cbIn)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
                cb += pRegMt->dwclsMinorType ? sizeof(CLSID) : 0;

            } /* mt loop */

            //
            // mediums - first medium is immediately after last media
            // type
            //
            const DWORD *prpm = (DWORD *)(pRegMt);
            UINT cmed = pRegPin->nMediums;
            for(UINT imed = 0; imed < cmed; imed++, prpm++)
            {
                if(*prpm + sizeof(REGPINMEDIUM_REG) > cbIn)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
            }

            cb += sizeof(REGPINMEDIUM) * cmed;

            // next pin is after last medium
            pRegPin = (REGFILTERPINS_REG2 *)prpm;

        } /* pin for loop */
    } // version 2

    *pcbOut = cb;
    return hr;
}

HRESULT UnSquish(
    BYTE *pbSrc,
    ULONG cbIn,
    REGFILTER2 ***pppbDest,
    int nFilters)
{
    for (int iFilter = 0; iFilter < nFilters; iFilter++) {
        *pppbDest[iFilter] = NULL;
    }
    CUnsquish unsquish;
    HRESULT hr = unsquish.UnSquish(pbSrc, cbIn, pppbDest, nFilters);
    if (FAILED(hr)) {
        for (int iFilter = 0; iFilter < nFilters; iFilter++) {
            CoTaskMemFree( (PBYTE)*(pppbDest[iFilter]));
        }
    }
    return hr;
}

HRESULT CUnsquish::UnSquish(
    BYTE *pbSrc, ULONG cbIn,
    REGFILTER2 ***pppbDest, int nFilters)
{
    HRESULT hr = S_OK;

    const REGFILTER_REG1 *prfr1 = (REGFILTER_REG1 *)pbSrc;
    for (int iFilter = 0; iFilter < nFilters; iFilter++) {
        ULONG cbReq;
        hr = CbRequiredUnquishAndValidate((const BYTE *)prfr1, &cbReq, cbIn);
        if(FAILED(hr)) {
            return hr;
        }

        BYTE *pbDest = (BYTE *)CoTaskMemAlloc(cbReq);
        if(pbDest == 0)
        {
            return E_OUTOFMEMORY;
        }

        m_rgMemAlloc.ib = 0;
        m_rgMemAlloc.cbLeft = cbReq;
        m_rgMemAlloc.pb = (BYTE *)pbDest;


        REGFILTER2 *prf2 =  (REGFILTER2 *)RgAllocPtr(sizeof(REGFILTER2));
        ASSERT(prfr1);

        // from CbRequiredUnquish
        ASSERT(prfr1 == 0 || prfr1->dwVersion == 0 || prfr1->dwVersion == 2);

        prf2->dwVersion = 2;
        prf2->dwMerit = prfr1->dwMerit;
        prf2->cPins = prfr1->dwcPins;

        hr = UnSquishPins(prf2, &prfr1, (const BYTE *)pbSrc);
        if(SUCCEEDED(hr))
        {
            ASSERT(m_rgMemAlloc.cbLeft == 0);
            *pppbDest[iFilter] = (REGFILTER2 *)pbDest;
        }
        else
        {
            CoTaskMemFree(pbDest);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\filgraph\filgraph\util.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1999 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <atlbase.h>
#include "util.h"

//=====================================================================
//  Get a pin's direction
//=====================================================================
int Direction(IPin *pPin)
{
    PIN_DIRECTION dir;
    if (SUCCEEDED(pPin->QueryDirection(&dir))) {
        return dir;
    } else {
        return -1;
    }
}

bool IsConnected( IPin* pPin )
{
    IPin* pConnectedPin;

    HRESULT hr = pPin->ConnectedTo( &pConnectedPin );

    // IPin::ConnectedTo() sets its' *ppPin parameter to NULL if an error
    // occurs or the pin is unconnected.  If IPin::ConnectedTo() succeedes,
    // the *ppPin contains a pointer to the connected pin.
    ASSERT( (FAILED( hr ) && (NULL == pConnectedPin)) ||
            (SUCCEEDED( hr ) && (NULL != pConnectedPin)) );

    if( FAILED( hr ) ) {
        return false;
    }

    pConnectedPin->Release();

    return true;
}

void GetFilter(IPin *pPin, IBaseFilter **ppFilter)
{
    PIN_INFO pi;
    if (SUCCEEDED(pPin->QueryPinInfo(&pi))) {
        *ppFilter = pi.pFilter;
    } else {
        *ppFilter = NULL;
    }
}

HRESULT GetFilterWhichOwnsConnectedPin( IPin* pPin, IBaseFilter** ppFilter )
{
    // Prevent the caller from accessing random memory.
    *ppFilter = NULL;

    CComPtr<IPin> pConnectedPin;

    HRESULT hr = pPin->ConnectedTo( &pConnectedPin );

    // IPin::ConnectedTo() sets its' *ppPin parameter to NULL if an error
    // occurs or the pin is unconnected.  If IPin::ConnectedTo() succeedes,
    // the *ppPin contains a pointer to the connected pin.
    ASSERT( (SUCCEEDED(hr) && pConnectedPin) ||
            (FAILED(hr) && !pConnectedPin) );

    if( FAILED( hr ) ) {
        return VFW_E_NOT_CONNECTED;
    }

    CComPtr<IBaseFilter> pFilterWhichOwnsConnectedPin;

    GetFilter( pConnectedPin, &pFilterWhichOwnsConnectedPin );
    if( !pFilterWhichOwnsConnectedPin ) { // NULL == pDownStreamFilter
        return E_FAIL;
    }

    *ppFilter = pFilterWhichOwnsConnectedPin;
    (*ppFilter)->AddRef();

    return S_OK;
}

bool ValidateFlags( DWORD dwValidFlagsMask, DWORD dwFlags )
{
    return ( (dwValidFlagsMask & dwFlags) == dwFlags );
}

//  Registry helper to read DWORDs from the registry
//  Returns ERROR ... codes returned by registry APIs
LONG GetRegistryDWORD(HKEY hkStart, LPCTSTR lpszKey, LPCTSTR lpszValueName,
                      DWORD *pdwValue)
{
    HKEY hk;
    LONG lResult = RegOpenKeyEx(hkStart, lpszKey, 0, KEY_READ, &hk);
    if (ERROR_SUCCESS == lResult) {
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hk, lpszValueName, NULL,
                                  &dwType, (LPBYTE)pdwValue, &dwSize);
        RegCloseKey(hk);
    }
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\ourcrt\ourcrt.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>

#ifndef USE_MSVCRT_IMPL
extern "C" const int _fltused = 0;
#endif

void * _cdecl operator new(size_t size)
{
    void * pv;
    pv = (void *)LocalAlloc(LMEM_FIXED, size);
    DbgLog((LOG_MEMORY, 4, TEXT("Allocating: %lx = %d"), pv, size));

    return pv;
}
void _cdecl operator delete(void *ptr)
{
    DbgLog((LOG_MEMORY, 4, TEXT("Freeing: %lx"), ptr));
    if (ptr)
	LocalFree(ptr);
}

/*
 * This function serves to avoid linking CRT code
 */

int __cdecl  _purecall(void)
{
#ifdef DEBUG
    DebugBreak();
#endif

    return(FALSE);
}

#if 0
#ifdef _X86_

// ---------------------------------------------------
//	asm_ftol()
// ---------------------------------------------------
extern "C" long __cdecl _ftol(float flX)
{
	long lResult;
	WORD wCW;
	WORD wNewCW;

	_asm
	{
		fld       flX			// Push the float onto the stack
		wait
		fnstcw    wCW			// Store the control word
		wait
		mov       ax,wCW		// Setup our rounding
		or        ah,0x0c
		mov       wNewCW,ax
		fldcw     wNewCW		// Set Control word to our new value
		fistp     lResult		// Round off top of stack into result
		fldcw     wCW			// Restore control word
		fnclex					// clear the status word of exceptions
	}

	return(lResult);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\strmaloc\code\stmalloc.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
    stmalloc.cpp

    CCircularBuffer

        A buffer with the start mapped at the end to provide contiguous
        access to a moving window of data

    CStreamAllocator

        Implements classes required to provide an allocator for an input
        pin which maps the samples to a circular buffer.

    CSubAllocator

        An allocator which gets its samples from the buffer in a
        CStreamAllocator object.

        This allows samples to be allocated on top of samples from
        an input pin which can be sent to an output pin.

*/


#include <streams.h>
#include <buffers.h>
#include <stmalloc.h>


/*  CStreamAllocator implementation */

CStreamAllocator::CStreamAllocator(
    TCHAR    * pName,
    LPUNKNOWN  pUnk,
    HRESULT  * phr,
    LONG       lMaxContig) :
    CBaseAllocator(pName, pUnk, phr),
    m_pBuffer(NULL),
    m_lMaxContig(lMaxContig),
    m_NextToAllocate(0),
#ifdef DEBUG
    m_bEventSet(FALSE),
#endif
    m_pSamples(NULL),
    m_bPositionValid(FALSE),
    m_bSeekTheReader(FALSE)
{
}

CStreamAllocator::~CStreamAllocator()
{
    DbgLog((LOG_TRACE, 3, TEXT("CStreamAllocator::~CStreamAllocator")));
    /*  Free our resources */
    EXECUTE_ASSERT(SUCCEEDED(Decommit()));
    ReallyFree();
}

/* CBaseAllocator overrides */
STDMETHODIMP CStreamAllocator::SetProperties(
    ALLOCATOR_PROPERTIES *pRequest,
    ALLOCATOR_PROPERTIES *pActual)
{
    if (NULL == pRequest || NULL == pActual) {
        return E_POINTER;
    }
    CAutoLock lck(this);
    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);

    DbgLog((LOG_TRACE, 4, TEXT("CStreamAllocator::SetProperties(%d,%d,%d,%d...)"),
            pRequest->cBuffers, pRequest->cbBuffer, pRequest->cbAlign));

    long alignmentRequest = pRequest->cbAlign;
    long sizeRequest = pRequest->cbBuffer;
    long countRequest = pRequest->cBuffers;

    if (pRequest->cbPrefix > 0) {
        return E_INVALIDARG;
    }

    /*  Check alignment request is a power of 2 */
    if ((-alignmentRequest & alignmentRequest) != alignmentRequest) {
        DbgLog((LOG_ERROR, 1, TEXT("Alignment 0x%x not a power of 2!"),
               alignmentRequest));
    }

    if (SysInfo.dwAllocationGranularity & (alignmentRequest - 1)) {
        DbgLog((LOG_ERROR, 1, TEXT("Alignment 0x%x requested too great!"),
               alignmentRequest));
        return E_INVALIDARG;
    }

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted == TRUE) {
        return E_ACCESSDENIED;
    }

    /*  Combine with any old values :
           Take the max of the aligments
           Take the max of the number of buffers
           Use the max of the total sizes
    */

    if (m_lCount > 0) {
        if (alignmentRequest < m_lAlignment) {
            alignmentRequest = m_lAlignment;
        }
        LONG lTotalSizeRequest = countRequest * sizeRequest;
        LONG lTotalSize        = m_lCount * m_lSize;
        LONG lMaxSize = max(lTotalSizeRequest, lTotalSize);
        countRequest = max(countRequest, m_lCount);
        sizeRequest = (lMaxSize + countRequest - 1) / countRequest;
    }

    /*  Align the size with the alignment */
    sizeRequest = (sizeRequest + alignmentRequest - 1) & ~(alignmentRequest - 1);

    HRESULT hr = CCircularBuffer::ComputeSizes(sizeRequest, countRequest, m_lMaxContig);
    if (SUCCEEDED(hr)) {
        m_lAlignment = alignmentRequest;
        m_lCount = countRequest;
        m_lSize = sizeRequest;

        pActual->cbAlign = m_lAlignment;

        /*  Make sure we reallocate our buffers next time round */
        m_bChanged = TRUE;

        /*  Allow for bad disks */
        #define DISK_READ_MAX_SIZE 32768
        if (m_lSize > DISK_READ_MAX_SIZE) {
            LONG lTotal = m_lSize * m_lCount;
            if ((lTotal & (DISK_READ_MAX_SIZE - 1)) == 0) {
                m_lSize = DISK_READ_MAX_SIZE;
                m_lCount = lTotal / DISK_READ_MAX_SIZE;
            }
        }
        pActual->cbBuffer = m_lSize;
        pActual->cBuffers = m_lCount;
    } else {
        DbgLog((LOG_ERROR, 2, TEXT("CStreamAllocator::SetProperties could not satisfy count %d, size %d"),
                countRequest, sizeRequest));
    }
    return hr;
}

// get container for a sample. Blocking, synchronous call to get the
// next free buffer (as represented by an IMediaSample interface).
// on return, the time etc properties will be invalid, but the buffer
// pointer and size will be correct.

HRESULT CStreamAllocator::GetBuffer(IMediaSample **ppBuffer,
                                    REFERENCE_TIME *pStartTime,
                                    REFERENCE_TIME *pEndTime,
                                    DWORD dwFlags)
{
    UNREFERENCED_PARAMETER(pStartTime);
    UNREFERENCED_PARAMETER(pEndTime);
    UNREFERENCED_PARAMETER(dwFlags);
    *ppBuffer = NULL;
    CMediaSample * pSample = NULL;

    while (TRUE) {
        {
            CAutoLock cObjectLock(this);

            /* Check we are committed */
            if (m_bCommitted == FALSE) {
                return E_OUTOFMEMORY;
            }

            CMediaSample *pSampleNext =
                (CMediaSample *) m_pSamples[m_NextToAllocate];

            /* Only return the one we want */
            pSample = m_lFree.Head();
            while (pSample) {
                if (pSampleNext == pSample) {
                    m_lFree.Remove(pSample);
                    /*  This is the point at which the data pointed to
                        by this sample becomes invalid.

                        We postpone until now to give us limited backward
                        seek capability which is essential for good
                        performance
                    */
                    PBYTE ptr;
                    pSample->GetPointer(&ptr);
                    m_pBuffer->Remove(ptr);
                    DbgLog((LOG_TRACE, 4,
                            TEXT("Stream allocator allocated buffer %p"),
                            ptr));

                    m_NextToAllocate++;
                    if (m_NextToAllocate == m_lCount) {
                        m_NextToAllocate = 0;
                    }
                    break;
                } else {
                    pSample = m_lFree.Next(pSample);
                }
            }
            if (pSample == NULL) {
#ifdef DEBUG
                DbgLog((LOG_TRACE, 4, TEXT("CStreamAllocator::GetBuffer() waiting - %d on list"),
                        m_lFree.GetCount()));
                m_bEventSet = FALSE;
                if (m_lFree.GetCount() == m_lAllocated) {
                    DbgLog((LOG_ERROR, 1, TEXT("Expected sample was %8.8X"), pSampleNext));
                    DbgLog((LOG_ERROR, 1, TEXT("Samples on list are :")));
                    CMediaSample *pSample = m_lFree.Head();
                    while(pSample) {
                        DbgLog((LOG_ERROR, 1, TEXT("    %8.8X"), pSample));
                        pSample = m_lFree.Next(pSample);
                    }
                }
#endif
                /*  If there were some samples but just not ours someone
                    else may be waiting
                */
                if (m_lFree.GetCount() != 0) {
                    NotifySample();
                }
                SetWaiting();
            }
        }

        if (pSample != NULL) {
            break;
        }

        EXECUTE_ASSERT(WaitForSingleObject(m_hSem, INFINITE) == WAIT_OBJECT_0);
    }

    /* Addref the buffer up to one. On release
       back to zero instead of being deleted, it will requeue itself by
       calling the ReleaseBuffer member function. NOTE the owner of a
       media sample must always be derived from CBaseAllocator */

    pSample->m_cRef = 1;
    *ppBuffer = pSample;

    // cause the start time on the returned buffer to be a file seek
    // position.  This causes the file reader to begin reading from
    // that position.
    //
    if (m_bSeekTheReader)
    {
        REFERENCE_TIME tSeek = CRefTime(m_llSeekTheReader * UNITS);
        (*ppBuffer)->SetTime(&tSeek, &tSeek);
        (*ppBuffer)->SetDiscontinuity(TRUE);
        m_bSeekTheReader = FALSE;
    }
    return S_OK;
}

BOOL CStreamAllocator::SeekTheReader(LONGLONG llPos)
{
   CAutoLock lck(this);
   m_bSeekTheReader = TRUE;
   m_llSeekTheReader = llPos;
   return TRUE;
}

//  Reset valid region.  This is called when some kind of disconinuity
//  occurs
void CStreamAllocator::ResetPosition()
{
    CAutoLock lck(this);
    if (m_lFree.GetCount() != m_lAllocated) {
        Advance(TotalLengthValid());
    }
    if (m_lFree.GetCount() == m_lAllocated) {
        m_NextToAllocate = 0;
    }
    m_pCurrent = NULL;
    m_bEmpty = TRUE;
    if (m_pBuffer != NULL) {
        m_pBuffer->Reset();
    }
}

//
//   Allocate our samples
//

HRESULT CStreamAllocator::Alloc()
{
    CAutoLock lck(this);

    DbgLog((LOG_TRACE, 3, TEXT("CStreamAllocator::Alloc()")));

    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
        return hr;
    }

    /* If the requirements haven't changed then don't reallocate */
    if (hr == S_FALSE) {
        ASSERT(m_pBuffer);
        /*  Reset the pointer in any case */
        ResetPosition();
        return NOERROR;
    }

    if (m_pBuffer != NULL) {
        ReallyFree();
    }

    m_pSamples = new PMEDIASAMPLE[m_lCount];
    if (m_pSamples == NULL) {
        return E_OUTOFMEMORY;
    }

    /*  Allocate our special circular buffer */
    m_pBuffer = new CCircularBufferList(m_lCount,
                                        m_lSize,
                                        m_lMaxContig,
                                        hr);
    if (m_pBuffer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr)) {
        delete m_pBuffer;
        delete [] m_pSamples;
        m_pBuffer = NULL;
        m_pSamples = NULL;
        return hr;
    }

    LPBYTE pNext = m_pBuffer->GetPointer();
    CMediaSample *pSample;


    ASSERT(m_lAllocated == 0);

    /* Create the new samples */
    for (; m_lAllocated < m_lCount; m_lAllocated++) {

        pSample = new CMediaSample(NAME("CStreamAllocator media sample"),
                                   this, &hr, pNext, m_lSize);

        DbgLog((LOG_TRACE, 4, TEXT("CStreamAllocator creating sample %8.8X"),
                pSample));

        if (FAILED(hr) || pSample == NULL) {
            return E_OUTOFMEMORY;
        }

        m_pSamples[m_lAllocated] = pSample;
        m_lFree.Add(pSample);
        pNext += m_lSize;
    }

    m_bChanged = FALSE;

    /*  Reset the pointer */
    ResetPosition();
    return NOERROR;
}


// override this to free up any resources we have allocated.
// called from the base class on Decommit when all buffers have been
// returned to the free list.
//
// caller has already locked the object.

// in our case, we keep the memory until we are deleted, so
// we do nothing here. The memory is deleted in the destructor by
// calling ReallyFree()

void
CStreamAllocator::Free(void)
{
    DbgLog((LOG_TRACE, 1, TEXT("CStreamAllocator::Free()")));

    /*  Advance our pointer */
    ResetPosition();
    return;
}

void
CStreamAllocator::ReallyFree()
{
    CAutoLock lck(this);
    DbgLog((LOG_TRACE, 1, TEXT("CStreamAllocator::ReallyFree()")));
    ASSERT(m_lFree.GetCount() == m_lAllocated);

    /*  Free the samples first */
    while (m_lFree.GetCount() != 0) {
        delete m_lFree.RemoveHead();
    }
    m_lAllocated = 0;
    delete m_pBuffer;
    m_pBuffer = NULL;
    delete [] m_pSamples;
    m_pSamples = NULL;
}

//
//  A sample is being returned to us in a Receive() call
//

HRESULT CStreamAllocator::Receive(PBYTE ptr, LONG lData)
{
    CAutoLock lck(this);

    DbgLog((LOG_TRACE, 4, TEXT("Stream allocator received buffer %p"),
           ptr));

    if (m_bPositionValid && m_pBuffer->Append(ptr, lData)) {
        if (m_pCurrent == NULL) {
            ASSERT(m_bEmpty);
            m_pCurrent = ptr;
        }
        if (lData != 0) {
            m_bEmpty = FALSE;
        }
        return S_OK;
    } else {
        if (!m_bPositionValid) {
            DbgLog((LOG_ERROR, 1, TEXT("CStreamAllocator::Receive() - position not valid")));
        } else {
            DbgLog((LOG_ERROR, 1, TEXT("CStreamAllocator::Receive() - Data after EOS")));
        }
        return E_UNEXPECTED;
    }
}

//
//  Set a new start position
//
void CStreamAllocator::SetStart(LONGLONG llPos)
{
    CAutoLock lck(this);
    ResetPosition();
    m_bPositionValid = TRUE;
    m_llPosition     = llPos;
}

// Lock data and get a pointer
// If we're at the end of the file cBytes can be modified.
// It's an error to ask for more than m_lMaxContig bytes
HRESULT CStreamAllocator::LockData(PBYTE pData, LONG& cBytes)
{
    CAutoLock lck(this);
    ASSERT(cBytes <= m_lMaxContig);
    pData = m_pBuffer->AdjustPointer(pData);
    LONG lOffset = m_pBuffer->Offset(pData);

    //  See if this many bytes are available or we're at the end of
    //  the file
    if (lOffset + cBytes > m_pBuffer->LengthValid()) {
        if (!m_pBuffer->EOS()) {
            return MAKE_HRESULT(SEVERITY_SUCCESS,
                                FACILITY_WIN32,
                                ERROR_MORE_DATA);
        } else {
            cBytes = m_pBuffer->LengthValid() - lOffset;
        }
    }

    /*  Find the start sample and lock down all the relevant
        samples
    */
    LockUnlock(pData, cBytes, TRUE);
    return S_OK;
}

HRESULT CStreamAllocator::UnlockData(PBYTE pData, LONG cBytes)
{
    CAutoLock lck(this);
    /*  pData can legitimately be beyond the end of the buffer */
    LockUnlock(m_pBuffer->AdjustPointer(pData), cBytes, FALSE);
    return S_OK;
}

/*
    CStreamAllocator

    LockUnlock

    Parameters:
        PBYTE pStart - start of area to lock or unlock
        LONG  cBytes - length to lock/unlock
        BOOL  bLock  - length to lock/unlock

    Note:
        The allocator must be locked before calling this
*/
void CStreamAllocator::LockUnlock(PBYTE pStart, LONG cBytes, BOOL bLock)
{
    DbgLog((LOG_TRACE, 4, TEXT("LockUnlock(%p, %X, %d)"),
            pStart, cBytes, bLock));

    ASSERT(cBytes != 0);
    int index = m_pBuffer->Index(pStart);
    CMediaSample *pSample = (CMediaSample *)m_pSamples[index];
    PBYTE pBuffer;
    pSample->GetPointer(&pBuffer);
    ASSERT(m_pBuffer->Index(pBuffer) == index);

    cBytes += (LONG)(pStart - pBuffer);

    /*  Can only LOCK buffers in the valid region,
        but buffers not in the valid region can be unlocked
    */
    ASSERT(!bLock || cBytes <= m_pBuffer->TotalLength());
    while (TRUE) {
        if (bLock) {
            pSample->AddRef();
            /*  Ugly hack - make sure it's not on the free list !!!
                This can happen if we reseek the allocator backwards.
                We should really just redesign all of this not to use lists

                We AddRef()'d it first so it's not going to pop straight
                back on the free list
            */
            CMediaSample *pListSample = m_lFree.Head();
            while (pListSample) {
                if (pSample == pListSample) {
                    m_lFree.Remove(pSample);
                    break;
                }
                pListSample = m_lFree.Next(pListSample);
            }
        } else {
            pSample->Release();
        }
        cBytes -= m_lSize;
        if (cBytes <= 0) {
            break;
        }
        if (++index == m_lCount) {
            index = 0;
        }
        pSample = (CMediaSample *)m_pSamples[index];
    }
}

// Seek to a given position
BOOL CStreamAllocator::Seek(LONGLONG llPos)
{
    CAutoLock lck(this);

    //  Can't seek if there's no buffer or we've got no data
    if (m_pBuffer == NULL || m_pCurrent == NULL) {
        DbgLog((LOG_TRACE, 2, TEXT("Allocator seek failed, no buffer")));
        return FALSE;
    }

    /*  Check the seek distance is reasonably short */
    LONGLONG llSeek       = llPos - m_llPosition;
    LONGLONG llBufferSize = (LONGLONG)m_pBuffer->TotalLength();
    BOOL bRc;
    if (llSeek <= llBufferSize && llSeek >= - llBufferSize) {
        bRc = Advance((LONG)llSeek);
    } else {
        /*  Do the best we can */
        if (llSeek > llBufferSize) {
            llSeek = llBufferSize;
            //ResetPosition();
        } else {
            llSeek = -llBufferSize;
        }
        bRc = FALSE;
    }
    if (bRc) {
        DbgLog((LOG_TRACE, 2, TEXT("Allocator seek to %s succeeded"),
                (LPCTSTR)CDisp(llPos, CDISP_HEX)));
    } else {
        DbgLog((LOG_TRACE, 2, TEXT("Allocator seek to %s failed"),
                (LPCTSTR)CDisp(llPos, CDISP_HEX)));
        /*  Seek to one end or the other */
        LONG lNewOffset = CurrentOffset() + (LONG)llSeek;
        if (lNewOffset < 0) {
            Advance((LONG)(-CurrentOffset()));
        } else {
            Advance(TotalLengthValid());
        }
    }
    return bRc;
}

// Advance our parsing pointer freeing data no longer needed
BOOL CStreamAllocator::Advance(LONG lAdvance)
{
    CAutoLock lck(this);
    /*  This is equivalent (though rather inefficiently) to

        Lock new range
        Unlock old range
    */
    if (m_pCurrent == NULL) {
        ASSERT(lAdvance == 0);
        return FALSE;
    }

    PBYTE pOldCurrent = m_pCurrent;
    ASSERT(m_llPosition >= 0);
    ASSERT(m_pCurrent != NULL);
    LONG lNewOffset = CurrentOffset() + lAdvance;
    if (lAdvance >= 0) {
        if (lNewOffset <= m_pBuffer->LengthValid()) {
            m_pCurrent = m_pBuffer->AdjustPointer(m_pCurrent + lAdvance);
            if (lNewOffset == m_pBuffer->LengthValid()) {
                if (lAdvance != 0) {
                    LockUnlock(pOldCurrent, lAdvance, FALSE);
                }
                m_bEmpty = TRUE;
            } else {
                ASSERT(LengthValid() > 0);
                LockUnlock(m_pCurrent, 1, TRUE);
                LockUnlock(pOldCurrent, lAdvance + 1, FALSE);
            }
            m_llPosition += lAdvance;
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        if (lNewOffset >= 0) {
            LONG lOldValid = LengthValid();
            m_pCurrent = m_pBuffer->GetBuffer(lNewOffset);
            if (lOldValid > 0) {
                ASSERT(!m_bEmpty);
                LockUnlock(m_pCurrent, -lAdvance + 1, TRUE);
                LockUnlock(pOldCurrent, 1, FALSE);
            } else {
                ASSERT(m_bEmpty);
                LockUnlock(m_pCurrent, -lAdvance, TRUE);
                m_bEmpty = FALSE;
            }
            m_llPosition += lAdvance;
            return TRUE;
        } else {
            return FALSE;
        }
    }
}

//
// implementation of CSubAllocator
//
// an allocator of IMediaSample objects, and implementation of IMemAllocator
// for streaming file-reading tasks, based on CFileReader.


CSubAllocator::CSubAllocator(TCHAR            * pName,
                             LPUNKNOWN          pUnk,
                             CStreamAllocator * pAllocator,
                             HRESULT          * phr) :
    CBaseAllocator(pName, pUnk, phr, FALSE),
    m_pStreamAllocator(pAllocator)
{
    pAllocator->AddRef();
}

CSubAllocator::~CSubAllocator()
{
    m_pStreamAllocator->Release();
}


// call this to get a CMediaSample object whose data pointer
// points directly into the read buffer for the given file position.
// The length must not be greater than MaxContig.
HRESULT
CSubAllocator::GetSample(PBYTE pData, LONG cBytes, IMediaSample** ppSample)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSubAllocator::GetSample")));
    *ppSample = 0;

    // is it a valid size - ie less than the max set by SetProperties?
    if (cBytes > m_lSize) {
	return E_INVALIDARG;
    }

    if (cBytes == 0) {
        DbgLog((LOG_ERROR, 1, TEXT("Getting sample with 0 bytes - pointer 0x%p"),
                pData));
    }

    // get a sample from the list

    // need to duplicate the code from CBaseAllocator::GetBuffer since
    // we need a CMediaSample * not an IMediaSample*

    // We allocate on the fly as needed
    //
    CAutoLock lock(this);

    // Check we are committed
    if (!m_bCommitted) {
	return VFW_E_NOT_COMMITTED;
    }

    CMediaSample* pSamp = m_lFree.RemoveHead();
    if (pSamp == NULL) {
        pSamp = NewSample();
        if (pSamp == NULL) {
            return E_OUTOFMEMORY;
        }
        m_lAllocated++;
    }

    // this is the bit we needed to insert into the CBaseAllocator code!
    pSamp->SetPointer(pData, cBytes);

    // when this addref is released to 0, the object will call
    // our ReleaseBuffer instead of just deleting itself.
    pSamp->m_cRef = 1;
    *ppSample = pSamp;

    // lock the data
#ifdef DEBUG
    LONG cBytesOld = cBytes;
#endif
    HRESULT hr = m_pStreamAllocator->LockData(pData, cBytes);
    ASSERT(cBytes == cBytesOld);
    if (FAILED(hr)) {
        pSamp->Release();
        delete pSamp;
        m_lAllocated--;
	return hr;
    }

    return S_OK;

}

// CBaseAllocator Overrides

// we have to be based on CBaseAllocator in order to use CMediaSample.
// we use CBaseAllocator to manage the list of CMediaSample objects, but
// override most of the functions as we dont support GetBuffer directly.

// pass hints as to size and count of samples to be used.
// we will take the smallest size  and smallest count of any call
// (resetting when a file is opened). The count we will use as the actual
// count of CMediaSample objects to use, and the size is the maximum
// size of GetSample request that will succeed. We also use the size
// as a hint to the file buffer allocator( to ensure that the minimum
// file buffer is this big).
STDMETHODIMP
CSubAllocator::SetProperties(
    ALLOCATOR_PROPERTIES * pRequest,
    ALLOCATOR_PROPERTIES * pActual
)
{
    if (NULL == pRequest || NULL == pActual) {
        return E_POINTER;
    }

    // since we are derived from CBaseAllocator, we can lock him
    CAutoLock lock(this);

    // Check no alignment is wanted (!)
    if (pRequest->cbAlign != 1) {
        DbgLog((LOG_ERROR, 1, TEXT("Wanted greater than 1 alignment 0x%x"),
               pRequest->cbAlign));
        return E_UNEXPECTED;
    }

    if (pRequest->cbPrefix > 0) {
        DbgLog((LOG_ERROR, 1, TEXT("Wanted %d prefix bytes"),
               pRequest->cbPrefix));
        return E_UNEXPECTED;
    }

    // take a copy so we can modify it
    ALLOCATOR_PROPERTIES prop;
    prop = *pRequest;


    // we take this as a hint, and use the smallest.
    if (m_lCount > 0) {
	prop.cBuffers = min(prop.cBuffers, m_lCount);
    }

    if (m_lSize > 0) {
	prop.cbBuffer = min(prop.cbBuffer, m_lSize);
    }

    return CBaseAllocator::SetProperties(
                                &prop,
                                pActual);
}

// returns an error always
STDMETHODIMP
CSubAllocator::GetBuffer(IMediaSample **ppBuffer,
                         REFERENCE_TIME *pStartTime,
                         REFERENCE_TIME *pEndTime,
                         DWORD dwFlags
                         )
{
    UNREFERENCED_PARAMETER(pStartTime);
    UNREFERENCED_PARAMETER(pEndTime);
    UNREFERENCED_PARAMETER(ppBuffer);
    UNREFERENCED_PARAMETER(dwFlags);
    return E_NOTIMPL;
}

// called by CMediaSample to return it to the free list and
// unblock block any pending GetSample call.
STDMETHODIMP
CSubAllocator::ReleaseBuffer(IMediaSample * pSample)
{
    // unlock the data area before putting on free list

    BYTE * ptr;
    HRESULT hr = pSample->GetPointer(&ptr);
    if (FAILED(hr)) {
	//!!!
	ASSERT(SUCCEEDED(hr));
    } else {

	hr = m_pStreamAllocator->UnlockData(ptr, pSample->GetActualDataLength());
	if (FAILED(hr)) {
	    //!!!
	    ASSERT(SUCCEEDED(hr));
	}
    }

    // pointer is no longer valid
    CMediaSample * pSamp = (CMediaSample *)pSample;
    pSamp->SetPointer(NULL, 0);

    return CBaseAllocator::ReleaseBuffer(pSample);
}

// free all the CMediaSample objects. Called from base class when
// in decommit state (after StopStreaming) when all the buffers
// are on the free list
void
CSubAllocator::Free(void)
{
    CAutoLock lck(this);

    // Should never be deleting this unless all buffers are freed
    ASSERT(m_lAllocated == m_lFree.GetCount());

    //* Free up all the CMediaSamples

    while (m_lFree.GetCount() != 0) {
        delete m_lFree.RemoveHead();
    }

    // empty the lists themselves
    m_lAllocated = 0;

    // Tell the base class
    m_bChanged = TRUE;

    // done
    return;
}	

//
//  Allocate our samples

HRESULT
CSubAllocator::Alloc(void)
{
    CAutoLock lck(this);

    DbgLog((LOG_TRACE, 3, TEXT("CSubAllocator::Alloc()")));

    // check with base that it is ok to do the alloc
    HRESULT hr = CBaseAllocator::Alloc();

    // Note that S_FALSE actually means that everthing is already
    // allocated and OK - see base class.
    if (hr != S_OK) {
	return hr;
    }

    ASSERT(m_lCount > 0);
    ASSERT(m_lAllocated == 0);

    m_bChanged = FALSE;

    return S_OK;
}

// this is called to create new CMediaSample objects. If you want to
// use objects derived from CMediaSample, override this to create them.
CMediaSample*
CSubAllocator::NewSample()
{
    HRESULT hr = S_OK;
    CMediaSample* pSamp = new CMediaSample(NAME("File media sample"), this, &hr);

    if (FAILED(hr)) {
	delete pSamp;
	return NULL;
    } else {
	return pSamp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\strmaloc\code\buffers.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
    CCircularBuffer

        A buffer with the start mapped at the end to provide contiguous
        access to a moving window of data

    CCircularBufferList

        Structure on top of CCircularBuffer for managing a list
        of buffers

    See buffers.h for a description
*/

#include <streams.h>
#include <buffers.h>

// !!! hacky win95 stuff, needs cleaning up!
int	crefVxD = 0;
HANDLE	hVxD = NULL;

#define VXD_NAME TEXT("\\\\.\\QUARTZ.VXD")
#define IOCTL_ALLOCALIASEDBUFFER    1
#define IOCTL_FREEALIASEDBUFFER     2
#ifndef PAGESIZE
#define PAGESIZE 4096
#endif

/*  CCircularBuffer implementation */

CCircularBuffer::~CCircularBuffer()
{
    if (m_pBuffer != NULL) {
	if (hVxD && hVxD != INVALID_HANDLE_VALUE) {
	    DWORD cbRet;
	
	    if (!DeviceIoControl(hVxD,
				 IOCTL_FREEALIASEDBUFFER,
				 &m_pBuffer,
				 sizeof(m_pBuffer),
				 NULL,
				 0,
				 &cbRet,
				 NULL)) {
		ASSERT(0);
	    }

            DbgLog((LOG_TRACE, 1, TEXT("VxD refcount-- = %d..."), crefVxD - 1));
	    if (--crefVxD == 0) {
                DbgLog((LOG_TRACE, 1, TEXT("Closing VxD")));
		CloseHandle(hVxD);
		hVxD = 0;
	    }
	} else {
	    EXECUTE_ASSERT(UnmapViewOfFile(m_pBuffer));
	    EXECUTE_ASSERT(UnmapViewOfFile((PVOID)((PBYTE)m_pBuffer + m_lTotalSize)));
	}
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("NULL pBuffer... in ~CCircularBuffer")));
    }
}

CCircularBuffer::CCircularBuffer(LONG lTotalSize,
                                 LONG lMaxContig,
                                 HRESULT& hr) :
    m_lTotalSize(lTotalSize),
    m_lMaxContig(lMaxContig),
    m_pBuffer(NULL)
{
    //  Check they used ComputeSizes
    if (!CheckSizes(lTotalSize, lMaxContig)) {
        hr = E_UNEXPECTED;
        return;
    }

    if (hVxD != INVALID_HANDLE_VALUE) {
	if (hVxD == 0) {
            DbgLog((LOG_TRACE, 1, TEXT("Loading VxD...")));
	    hVxD = CreateFile(
		VXD_NAME,
		GENERIC_WRITE,
		FILE_SHARE_WRITE,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL, // FILE_FLAG_GLOBAL_HANDLE???
		NULL);
	}

	if (hVxD == INVALID_HANDLE_VALUE) {
	    goto PerhapsWeAreOnNT;
	}

	crefVxD++;
        DbgLog((LOG_TRACE, 1, TEXT("VxD refcount++ = %d..."), crefVxD));
	
	DWORD dwPages = lTotalSize / PAGESIZE;
	DWORD cbRet;
	
	if (!DeviceIoControl(hVxD,
				IOCTL_ALLOCALIASEDBUFFER,
				&dwPages,
				sizeof(dwPages),
				&m_pBuffer,
				sizeof(m_pBuffer),
				&cbRet,
				NULL)) {
	    DbgLog((LOG_ERROR, 1, TEXT("DeviceIOControl failed")));
	    hr = E_OUTOFMEMORY;
	    return;
	}
	DbgLog((LOG_TRACE, 2, TEXT("Using VxD to allocate memory")));
    } else {
PerhapsWeAreOnNT:
	HANDLE hMapping;

	/*  Create a file mapping of the first buffer */
	hMapping = CreateFileMapping(
		       INVALID_HANDLE_VALUE,
		       NULL,
		       PAGE_READWRITE,
		       0,
		       m_lTotalSize,
		       NULL);

	if (hMapping == NULL) {
	    DWORD dwErr = GetLastError();
	    hr = AmHresultFromWin32(dwErr);
	    return;
	}


	/*  Try to create the mappings - this can fail due to bad luck
	    so try a few times
	*/
	for (int i = 0; i < 20; i++) {
	    hr = CreateMappings(hMapping);
	    if (SUCCEEDED(hr)) {
		break;
	    } else {
		DbgLog((LOG_TRACE, 1, TEXT("Create file mappings failed - %8.8X"),
		       hr));
	    }
	}

	/*  We don't need this handle any more.  The mapping will actually
	    close when we unmap all the views
	*/

	CloseHandle(hMapping);
    }
}

/*  Try to create the mapping objects */
HRESULT CCircularBuffer::CreateMappings(HANDLE hMapping)
{
    /*  Big hack */
    PVOID pData = VirtualAlloc(NULL,
                               m_lTotalSize + m_lMaxContig,
                               MEM_RESERVE,
                               PAGE_READWRITE);

    if (pData == NULL) {
        DWORD dwErr = GetLastError();
        DbgLog((LOG_ERROR, 1, TEXT("Could not allocate page space")));
        return AmHresultFromWin32(dwErr);
    }
    VirtualFree(pData, 0, MEM_RELEASE);

    /*  Now map the thing in two places */
    pData = MapViewOfFileEx(hMapping,
                            FILE_MAP_WRITE,
                            0,
                            0,
                            m_lTotalSize,
                            pData);

    if (pData == NULL) {
        DWORD dwErr = GetLastError();
        return AmHresultFromWin32(dwErr);
    }

    PVOID pRequired = (PVOID)((PBYTE)pData + m_lTotalSize);

    /*  We want to see lMaxContig bytes duplicated */

    PVOID pRest = MapViewOfFileEx(hMapping,
                                  FILE_MAP_WRITE,
                                  0,
                                  0,
                                  m_lMaxContig,
                                  pRequired);

    ASSERT(pRest == NULL || pRest == pRequired);

    if (pRest == NULL) {
        DWORD dwErr = GetLastError();
        UnmapViewOfFile(pData);
        return AmHresultFromWin32(dwErr);
    }

    m_pBuffer = (PBYTE)pData;

    return S_OK;
}

LONG CCircularBuffer::AlignmentRequired()
{
   SYSTEM_INFO SystemInfo;
   GetSystemInfo(&SystemInfo);
   return (LONG)SystemInfo.dwAllocationGranularity;
}

/*  Check the sizes we're going to use are valid */
BOOL CCircularBuffer::CheckSizes(LONG lTotalSize, LONG lMaxContig)
{
    return lTotalSize != 0 &&
           lMaxContig != 0 &&
           lMaxContig <= lTotalSize &&
           (lTotalSize & (AlignmentRequired() - 1)) == 0;
}

HRESULT CCircularBuffer::ComputeSizes(
    LONG& lSize,
    LONG& cBuffers,
    LONG  lMaxContig)
{
    /*  Now make fiddle the numbers upwards until :

        PAGE_SIZE | lSize * cBuffers
        lMaxContig <= lSize * cBuffers;

        DON'T cheat by making PAGE_SIZE | lSize

        We don't need to fiddle lMaxContig because it's just
        the amount of stuff we remap at the end.
    */

    /*  Work out what the alignment of the count is */
    ASSERT(cBuffers != 0);
    LONG lAlign = AlignmentRequired() / (cBuffers & -cBuffers);
    lSize = (lSize + lAlign - 1) & ~(lAlign - 1);
    ASSERT(CheckSizes(lSize * cBuffers, lMaxContig));
    return S_OK;
}

//
//  Return where our buffer starts
//

PBYTE CCircularBuffer::GetPointer() const
{
    return m_pBuffer;
}

/* CCirculareBufferList implementation */


CCircularBufferList::CCircularBufferList(
            LONG     cBuffers,
            LONG     lSize,
            LONG     lMaxContig,
            HRESULT& hr) :
    CCircularBuffer(cBuffers * lSize, lMaxContig, hr),
    CBaseObject(NAME("Circular buffer")),
    m_lSize(lSize),
    m_lCount(cBuffers),
    m_cValid(0),
    m_lValid(0),
    m_pStartBuffer(NULL),
    m_bEOS(FALSE)
{
    DbgLog((LOG_TRACE, 1, TEXT("Creating buffer list...")));
};

CCircularBufferList::~CCircularBufferList()
{
    DbgLog((LOG_TRACE, 1, TEXT("Destroying buffer list...")));
};

/*
    Add a buffer to the valid region
*/
BOOL CCircularBufferList::Append(PBYTE pBuffer, LONG lSize)
{
    ASSERT(!Valid(pBuffer));
    ASSERT(lSize <= m_lSize);
    if (m_bEOS) {
        DbgLog((LOG_ERROR, 2, TEXT("CCircularBufferList rejecting buffer because of EOS")));
        return FALSE;
    }
    if (m_cValid == 0) {
        m_pStartBuffer = pBuffer;
    } else {
        if (pBuffer == NextBuffer(LastBuffer())) {
            ASSERT(m_cValid < m_lCount);
        } else {
            DbgLog((LOG_TRACE, 2, TEXT("CCircularBufferList rejecting buffer %8.8p expected %8.8p"),
                    pBuffer, NextBuffer(LastBuffer())));
            return FALSE;
        }
    }
    m_cValid++;
    m_lValid += lSize;
    if (lSize != m_lSize) {
        m_bEOS = TRUE;
    }
    return TRUE;
};

/*
    Remove a buffer from the valid region
*/
LONG CCircularBufferList::Remove(PBYTE pBuffer)
{
    ASSERT(ValidBuffer(pBuffer));
    PBYTE pBuf = m_pStartBuffer;
    for (int i = 0; i < m_cValid; i++, pBuf = NextBuffer(pBuf)) {
        if (pBuffer == pBuf) {
            m_cValid -= i + 1;
            ASSERT(m_cValid >= 0);
            m_pStartBuffer = NextBuffer(pBuffer);
            m_lValid -= (i + 1) * m_lSize;
            if (m_lValid < 0) {
                ASSERT(m_bEOS);
                m_lValid = 0;
            }
            return (i + 1) * m_lSize;
        }
    }
    return 0;
};

/*
    Return offset of buffer within the valid region
*/
LONG CCircularBufferList::Offset(PBYTE pBuffer) const
{
    if (m_cValid == 0) {
        return 0;
    }
    ASSERT(m_pStartBuffer != 0);
    LONG lOffset = (LONG)(pBuffer - m_pStartBuffer);
    if (lOffset < 0) {
        lOffset += m_lTotalSize;
    }
    ASSERT(lOffset <= m_lValid);
    return lOffset;
};

/*
    Find the buffer corresponding to the given offset in the valid
    region
*/
PBYTE CCircularBufferList::GetBuffer(LONG lOffset) const
{
    ASSERT(lOffset >= 0);
    if (lOffset >= m_lValid) {
        return NULL;
    }
    return AdjustPointer(m_pStartBuffer + lOffset);
}

/*
    Return the size of each buffer
*/
LONG CCircularBufferList::BufferSize() const
{
    return m_lSize;
}

/*
    Return the length in bytes of the valid region
*/
LONG CCircularBufferList::LengthValid() const
{
    ASSERT(m_lValid >= 0 &&
           m_lValid <= m_cValid * m_lSize);
    return m_lValid;
}

/*
    Return the length that can be seen contigously from the current position
*/
LONG CCircularBufferList::LengthContiguous(PBYTE pb) const
{
    LONG lValid = m_lValid - Offset(pb);
    if (pb + lValid > (m_pBuffer + m_lTotalSize) + m_lMaxContig) {
        lValid = (LONG)(((m_pBuffer + m_lTotalSize) + m_lMaxContig) - pb);
    }
    ASSERT(lValid >= 0);
    return lValid;
}
/*
    Return whether we've received end of stream
*/
BOOL CCircularBufferList::EOS() const
{
    return m_bEOS;
};

/*
    Coerce a possibly aliased pointer to a real pointer
*/
PBYTE CCircularBufferList::AdjustPointer(PBYTE pBuf) const
{
    if (pBuf >= m_pBuffer + m_lTotalSize) {
        pBuf -= m_lTotalSize;
    }
    ASSERT(pBuf >= m_pBuffer && pBuf < m_pBuffer + m_lTotalSize);
    return pBuf;
};

/*
    Return whether a buffer is in the valid region
*/
BOOL CCircularBufferList::Valid(PBYTE pBuffer)
{
    PBYTE pBuf = m_pStartBuffer;
    ASSERT(ValidBuffer(pBuffer));
    for (int i = 0; i < m_cValid; i++, pBuf = NextBuffer(pBuf)) {
        if (pBuf == pBuffer) {
            return TRUE;
        }
    }
    return FALSE;
};
void CCircularBufferList::Reset()
{
    DbgLog((LOG_TRACE, 2, TEXT("On Reset() m_cValid = %d, m_lValid = %d"),
            m_cValid, m_lValid));
    m_cValid = 0;
    m_lValid = 0;
    m_pStartBuffer = NULL;
    m_bEOS = FALSE;
};

int CCircularBufferList::Index(PBYTE pBuffer)
{
    int index = (int)(pBuffer - m_pBuffer) / m_lSize;
    if (index >= m_lCount) {
        index -= m_lCount;
    }
    ASSERT(index < m_lCount);
    return index;
}

/*
    Step on to the next buffer
*/
PBYTE CCircularBufferList::NextBuffer(PBYTE pBuffer)
{
    ASSERT(ValidBuffer(pBuffer));
    PBYTE pNew = pBuffer + m_lSize;
    if (pNew == m_pBuffer + m_lTotalSize) {
        return m_pBuffer;
    } else {
        return pNew;
    }
};

/*
    Check the pointer is one of our buffers
*/
BOOL CCircularBufferList::ValidBuffer(PBYTE pBuffer) {
    if (pBuffer < m_pBuffer || pBuffer >= m_pBuffer + m_lTotalSize) {
        return FALSE;
    }
    if (((pBuffer - m_pBuffer) % m_lSize) != 0) {
        return FALSE;
    }
    return TRUE;
};

/*
    Return a pointer to the last buffer in the valid region
*/
PBYTE CCircularBufferList::LastBuffer() {
    ASSERT(m_lValid != 0);
    return AdjustPointer(m_pStartBuffer + m_lSize * (m_cValid - 1));
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\strmaloc\inc\buffers.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

/*

    File buffers.h

    Description

        Defines 2 classes :

           CCircularBuffer     - creates a circular buffer
           CCircularBufferList - creates a set of buffers mapped on a buffer


        CCircularBuffer
        ---------------

        The buffer created by CCircularBuffer looks as follows :


        <--------------- lTotalSize ------------------> <-- lMaxContig ----->
        ---------------------------------------------------------------------
       | abc ............pqr....................... xyz|abc ..............pqr|
        ---------------------------------------------------------------------

        A
        |

   GetPointer()


        Any data inserted at the start also appears just after the end.  This
        is done by making the page tables point twice at the same memory.

        GetPointer() returns the start of the buffer


        CCircularBufferList
        -------------------

        CCircularBufferList creates a circular buffer which is divided into
        a set of sub-buffers, all the same length, and implements a 'valid
        region' :

        ---------------------------------------------------------------------
       | buffer 0  | buffer 1  | buffer 2  | buffer 3  | shadow              |
        ---------------------------------------------------------------------

        The Append() method adds a buffer to the (end of) the valid region.
        If EOS is specified on Append() then the buffer appended can be
        non-full, otherwise it must be full.  No buffers are accepted after
        EOS is specified until Reset() is issued.

        The Remove() method removes a buffer from the valid region.

        Reset() removes the whole valid region.

        LengthValid() returns the total amount of data in the valid region.

        LengthContigous(pb) returns the amount of the valid region visible
        from pb.

        AdjustPointer(pb) maps a pointer (which may be in the shadow area) to
        its equvalent in the main buffer.

*/

#ifndef __BUFFERS_H__

#define __BUFFERS_H__

// CCircularBuffer
//
// Create a buffer which wraps on itself so you can always see
// at least a given amount of data
//
class CCircularBuffer
{
public:
    // Constructor and destructor

    CCircularBuffer(LONG lTotalSize,           // Total data size
                    LONG lMaxContig,           // How much contiguous?
                    HRESULT& hr);              // Check this return!
    ~CCircularBuffer();

    //  Use this static member so the allocator can precompute stuff
    //  for SetCountAndSize
    static HRESULT ComputeSizes(LONG& lSize, LONG& cBuffers, LONG lMaxContig);

    // Where the buffer starts
    PBYTE GetPointer() const;

private:
    static BOOL    CheckSizes(LONG lTotalSize, LONG lMaxConfig);
           HRESULT CreateMappings(HANDLE hMapping);
    static LONG    AlignmentRequired();

protected:
    /*  Data members */
          PBYTE  m_pBuffer;
    const LONG   m_lTotalSize;
    const LONG   m_lMaxContig;

};

/*  Build a class on top of the circular buffer which creates a list
    of equal sized buffers.

    The buffer is the unit of allocation for our allocator.
*/
class CCircularBufferList : public CCircularBuffer, public CBaseObject
{
public:
    CCircularBufferList(
                LONG     cBuffers,
                LONG     lSize,
                LONG     lMaxContig,
                HRESULT& hr);

    ~CCircularBufferList();

    int Index(PBYTE pBuffer);
    BOOL Append(PBYTE pBuffer, LONG lSize);
    LONG Remove(PBYTE pBuffer);
    LONG Offset(PBYTE pBuffer) const;
    PBYTE GetBuffer(LONG lOffset) const;
    LONG BufferSize() const;
    LONG LengthValid() const;
    LONG TotalLength() const
    {
        return m_lTotalSize;
    };
    LONG LengthContiguous(PBYTE pb) const;
    BOOL EOS() const;
    void SetEOS() { m_bEOS = TRUE; };
    PBYTE AdjustPointer(PBYTE pBuf) const;
    BOOL Valid(PBYTE pBuffer);
    void Reset();

private:
    PBYTE NextBuffer(PBYTE pBuffer);
    BOOL ValidBuffer(PBYTE pBuffer);
    PBYTE LastBuffer();

private:
    //  Remember our parameters
    const LONG  m_lSize;
    const LONG  m_lCount;

    //  Define the valid region of the buffer in terms start, buffers and
    //  length
    LONG        m_cValid;
    PBYTE       m_pStartBuffer;
    LONG        m_lValid;

    //  End of stream?
    BOOL        m_bEOS;
};

#endif // __BUFFERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\smarttee\smarttee.cpp ===
//depot/private/lab06_multimedia/multimedia/DShow/filters/core/smarttee/smarttee.cpp#4 - edit change 19434 (text)
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "smarttee.h"
#include <tchar.h>
#include <stdio.h>

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Video,        // Major CLSID
    &MEDIASUBTYPE_NULL       // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",             // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
    { L"Capture",           // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
    { L"Preview",           // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes }        // Pin information
};

const AMOVIESETUP_FILTER sudSmartTee =
{
    &CLSID_SmartTee,       // CLSID of filter
    L"Smart Tee",          // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    3,                      // Number of pins
    psudPins                // Pin information
};

#ifdef FILTER_DLL
//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] = 
{
    // --- Smart Capture Tee ---
    {L"Smart Tee",                         &CLSID_SmartTee,
        CSmartTee::CreateInstance, NULL, &sudSmartTee }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

// Using this pointer in constructor
#pragma warning(disable:4355)

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CSmartTee::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CSmartTee(NAME("Smart Tee Filter"), pUnk, phr);
}


// ================================================================
// CSmartTee Constructor
// ================================================================

CSmartTee::CSmartTee(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_OutputPinsList(NAME("Tee Output Pins list")),
    m_pAllocator(NULL),
    m_NumOutputPins(0),
    m_NextOutputPinNumber(0),
    m_Input(NAME("Input Pin"), this, phr, L"Input"),
    CBaseFilter(NAME("Smart Tee filter"), pUnk, this, CLSID_SmartTee)
{
    ASSERT(phr);

    // Create a single output pin at this time
    InitOutputPinsList();

    // Create the capture pin
    CSmartTeeOutputPin *pOutputPin = CreateNextOutputPin(this);
    if (pOutputPin != NULL )
    {
        m_NumOutputPins++;
        m_OutputPinsList.AddTail(pOutputPin);
        m_Capture = pOutputPin;
    }

    // Create the preview pin
    pOutputPin = CreateNextOutputPin(this);
    if (pOutputPin != NULL )
    {
        m_NumOutputPins++;
        m_OutputPinsList.AddTail(pOutputPin);
        m_Preview = pOutputPin;
    }
}


//
// Destructor
//
CSmartTee::~CSmartTee()
{
    InitOutputPinsList();
}


// tell the stream control stuff what clock to use
STDMETHODIMP CSmartTee::SetSyncSource(IReferenceClock *pClock)
{
    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->SetSyncSource(pClock);
        n--;
    }
    return CBaseFilter::SetSyncSource(pClock);
}


// tell the stream control stuff what sink to use
STDMETHODIMP CSmartTee::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    DbgLog((LOG_TRACE,1,TEXT("CSmartTee::JoinFilterGraph")));

    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);

    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->SetFilterGraph(m_pSink);
        n--;
    }
    return hr;
}

//
// If both output pins are connected to renderers, the preview pin will run
// as fast as the source can push (no time stamps) but the capture pin will
// only go as fast as the playback of the file is supposed to be.  Thus, 
// all buffers between us and the upstream filter are probably outstanding.
// Then when you go from RUN->PAUSE, the preview renderer will insist on 
// seeing another frame before pausing, which the upstream filter won't be
// able to send because all buffers are outstanding by the capture pin, which
// is blocked delivering to the renderer and can't free any.
// So we have to declare ourselves a "live graph" to avoid hanging when we are
// in the graph.  We do this by returning VFW_S_CANT_CUE in pause mode.
//
STDMETHODIMP CSmartTee::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused) {
        //DbgLog((LOG_TRACE,1,TEXT("*** Cant cue!")));
	return VFW_S_CANT_CUE;
    } else {
        return S_OK;
    }
}



//
// GetPinCount
//
int CSmartTee::GetPinCount()
{
    return (1 + m_NumOutputPins);
}


//
// GetPin
//
CBasePin *CSmartTee::GetPin(int n)
{
    if (n < 0)
        return NULL ;

    // Pin zero is the one and only input pin
    if (n == 0)
        return &m_Input;

    // return the output pin at position(n - 1) (zero based)
    return GetPinNFromList(n - 1);
}


//
// InitOutputPinsList
//
void CSmartTee::InitOutputPinsList()
{
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(pos)
    {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
        ASSERT(pOutputPin->m_pOutputQueue == NULL);
        delete pOutputPin;
    }
    m_NumOutputPins = 0;
    m_OutputPinsList.RemoveAll();

} // InitOutputPinsList


//
// CreateNextOutputPin
//
CSmartTeeOutputPin *CSmartTee::CreateNextOutputPin(CSmartTee *pTee)
{
    WCHAR *szbuf;    
    m_NextOutputPinNumber++;     // Next number to use for pin
    HRESULT hr = NOERROR;

    szbuf = ((m_NextOutputPinNumber == 1) ?  L"Capture" : L"Preview");

    CSmartTeeOutputPin *pPin = new CSmartTeeOutputPin(NAME("Tee Output"), pTee,
					    &hr, szbuf,
					    m_NextOutputPinNumber);

    if (FAILED(hr) || pPin == NULL) {
        delete pPin;
        return NULL;
    }

    return pPin;

} // CreateNextOutputPin


//
// GetPinNFromList
//
CSmartTeeOutputPin *CSmartTee::GetPinNFromList(int n)
{
    // Validate the position being asked for
    if (n >= m_NumOutputPins)
        return NULL;

    // Get the head of the list
    POSITION pos = m_OutputPinsList.GetHeadPosition();

    n++;       // Make the number 1 based

    CSmartTeeOutputPin *pOutputPin;
    while(n) {
        pOutputPin = m_OutputPinsList.GetNext(pos);
        n--;
    }
    return pOutputPin;

} // GetPinNFromList


//
// Stop
//
// Overriden to give new state to stream control
//
STDMETHODIMP CSmartTee::Stop()
{
    CAutoLock cObjectLock(m_pLock);

    // this will unblock Receive, which may be blocked in CheckStreamState
    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->NotifyFilterState(State_Stopped, 0);
        n--;
    }

    // Now make sure Receive is not using m_pOutputQueue right now.
    CAutoLock lock_4(&m_Input.m_csReceive);

    // Input pins are stopped before the output pins, because GetPin returns
    // our input pin first.  This will ensure that 1) Receive is never called
    // again, and 2) finally m_pOutputQueue will be destroyed
    return CBaseFilter::Stop();
}

//
// Pause
//
// Overriden to handle no input connections
//
STDMETHODIMP CSmartTee::Pause()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CBaseFilter::Pause();
    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->NotifyFilterState(State_Paused, 0);
        n--;
    }
    return hr;
}


//
// Run
//
// Overriden to handle no input connections
//
STDMETHODIMP CSmartTee::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CBaseFilter::Run(tStart);
    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->NotifyFilterState(State_Running, tStart);
        n--;
    }
    return hr;
}

// ================================================================
// CSmartTeeInputPin constructor
// ================================================================

CSmartTeeInputPin::CSmartTeeInputPin(TCHAR *pName,
                           CSmartTee *pTee,
                           HRESULT *phr,
                           LPCWSTR pPinName) :
    CBaseInputPin(pName, pTee, pTee, phr, pPinName),
    m_pTee(pTee),
    m_nMaxPreview(0)
{
    ASSERT(pTee);
}


#ifdef DEBUG
//
// CSmartTeeInputPin destructor
//
CSmartTeeInputPin::~CSmartTeeInputPin()
{
    //DbgLog((LOG_TRACE,2,TEXT("CSmartTeeInputPin destructor")));
    ASSERT(m_pTee->m_pAllocator == NULL);
}
#endif

//
// CheckMediaType
//
HRESULT CSmartTeeInputPin::CheckMediaType(const CMediaType *pmt)
{
    //DbgLog((LOG_TRACE,3,TEXT("Input::CheckMT %d bit"), HEADER(pmt->Format())->biBitCount));

    CAutoLock lock_it(m_pLock);

    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging perposes
    //!!!DisplayMediaType(TEXT("Input Pin Checking"), pmt);
#endif

    // The media types that we can support are entirely dependent on the
    // downstream connections. If we have downstream connections, we should
    // check with them - walk through the list calling each output pin

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            if (pOutputPin->m_Connected != NULL) {
                // The pin is connected, check its peer
                hr = pOutputPin->m_Connected->QueryAccept(pmt);
                if (hr != NOERROR) {
    		    //DbgLog((LOG_TRACE,3,TEXT("NOT ACCEPTED!")));
                    return VFW_E_TYPE_NOT_ACCEPTED;
		}
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }

    // Either all the downstream pins have accepted or there are none.
    //DbgLog((LOG_TRACE,3,TEXT("ACCEPTED!")));
    return NOERROR;

} // CheckMediaType


//
// BreakConnect
//
HRESULT CSmartTeeInputPin::BreakConnect()
{
    //DbgLog((LOG_TRACE,3,TEXT("Input::BreakConnect")));

    // Release any allocator that we are holding
    if (m_pTee->m_pAllocator)
    {
        m_pTee->m_pAllocator->Release();
        m_pTee->m_pAllocator = NULL;
    }
    return NOERROR;

} // BreakConnect


//
// NotifyAllocator
//
STDMETHODIMP
CSmartTeeInputPin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly)
{
    CAutoLock lock_it(m_pLock);
    if (pAllocator == NULL)
        return E_FAIL;

    // Free the old allocator if any
    if (m_pTee->m_pAllocator)
        m_pTee->m_pAllocator->Release();

    // Store away the new allocator
    pAllocator->AddRef();
    m_pTee->m_pAllocator = pAllocator;

    ALLOCATOR_PROPERTIES prop;
    HRESULT hr = m_pTee->m_pAllocator->GetProperties(&prop);
    if (SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE,2,TEXT("Allocator is using %d buffers, size %d"),
						prop.cBuffers, prop.cbBuffer));
	m_cBuffers = prop.cBuffers;
	m_cbBuffer = prop.cbBuffer;
    }

    // Notify the base class about the allocator
    return CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);

} // NotifyAllocator


//
// EndOfStream
//
HRESULT CSmartTeeInputPin::EndOfStream()
{
    // protect from m_pOutputQueue going away
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    //DbgLog((LOG_TRACE,3,TEXT("::EndOfStream")));

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverEndOfStream();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return(NOERROR);

} // EndOfStream


//
// BeginFlush
//
HRESULT CSmartTeeInputPin::BeginFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
	    pOutputPin->Flushing(TRUE);
            hr = pOutputPin->DeliverBeginFlush();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::BeginFlush();

} // BeginFlush


//
// EndFlush
//
HRESULT CSmartTeeInputPin::EndFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
	    pOutputPin->Flushing(FALSE);
            hr = pOutputPin->DeliverEndFlush();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::EndFlush();

} // EndFlush

//
// NewSegment
//
                    
HRESULT CSmartTeeInputPin::NewSegment(REFERENCE_TIME tStart,
                                 REFERENCE_TIME tStop,
                                 double dRate)
{
    // protect from m_pOutputQueue going away
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverNewSegment(tStart, tStop, dRate);
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::NewSegment(tStart, tStop, dRate);

} // NewSegment


//
// Receive
//
HRESULT CSmartTeeInputPin::Receive(IMediaSample *pSample)
{
    //DbgLog((LOG_TRACE,3,TEXT("SmartTee::Receive")));

    CAutoLock lock_it(&m_csReceive);
    int nQ = 0;

    // Check that all is well with the base class
    HRESULT hr = NOERROR;
    hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR) {
        //DbgLog((LOG_TRACE,1,TEXT("Base class ERROR!")));
        return hr;
    }

    // Walk through the output pins list, delivering to the first pin (capture)
    // and only delivering to the preview pin if it won't affect capture
    // performance. Send at least every 30th frame !!!

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
	    if (n == m_pTee->m_NumOutputPins) {
                hr = pOutputPin->Deliver(pSample);
		if (pOutputPin->m_pOutputQueue)
		    nQ = pOutputPin->m_pOutputQueue->GetThreadQueueSize();
    		DbgLog((LOG_TRACE,3,TEXT("Delivered CAPTURE: Queued=%d"), nQ));
	        // This will prevent us from receiving any more data!
                if (hr != NOERROR) {
    		    DbgLog((LOG_ERROR,1,TEXT("ERROR: failing Receive")));
                    return hr;
		}
	    } else {
		// here's the deal.  It's only OK to send something to the
		// preview pin if it won't hurt capture.  IE: never send more
		// than one at a time, wait until there are no outstanding
		// samples on the queue before sending another one. Also, if
		// the capture queue is getting full, that's another good reason
		// not to send a preview frame.  But, we will at least send
		// every 30th frame.
		m_nFramesSkipped++;
		int nOK = m_cBuffers < 8 ? 1 :
			(m_cBuffers < 16 ? 2 : 4);
		BOOL fOK = FALSE;
		if (pOutputPin->m_pOutputQueue)
		    fOK = pOutputPin->m_pOutputQueue->m_nOutstanding <= m_nMaxPreview;
		if ((m_nFramesSkipped >= 30 || nQ <= nOK) && fOK) {
                    hr = pOutputPin->Deliver(pSample);
		    if (hr != NOERROR)
    		        DbgLog((LOG_ERROR,1,TEXT("ERROR: delivering PREVIEW")));
		    else {
    		        DbgLog((LOG_TRACE,3,TEXT("Delivered PREVIEW")));
			pOutputPin->m_pOutputQueue->m_nOutstanding++;
		    }
		    m_nFramesSkipped = 0;	// reset AFTER DELIVER!
		    // don't bother to flag an error and halt capture just 
		    // because something went wrong with preview
		}
#if 0
                // else
                // {
                //     m_nDropped++;
                // }
                // m_nTotal++;
#endif
	    }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }

    return NOERROR;

} // Receive


//
// Completed a connection to a pin
//
HRESULT CSmartTeeInputPin::CompleteConnect(IPin *pReceivePin)
{
    //DbgLog((LOG_TRACE,1,TEXT("TT Input::CompleteConnect")));

    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
        return hr;
    }

    // Force any output pins to use our type

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            // Check with downstream pin
            if (pOutputPin->m_Connected != NULL) {
                if (m_mt != pOutputPin->m_mt) {
    		    //DbgLog((LOG_TRACE,1,TEXT("IN Connected: RECONNECT OUT")));
                    m_pTee->ReconnectPin(pOutputPin, &m_mt);
		}
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return S_OK;
}

//
// Active
//
// This is called when we transition from stop to paused. The purpose of
// this routine is to set m_nMaxPreview once for all. m_nMaxPreview is
// used in CSmartTeeInputPin::Receive, which queues a sample to the 
// preview pin iff the #samples currently in the preview pipe is no
// more than m_nMaxPreview. For Win9x and NT 4, m_nMaxPreview == 0 
// has worked well. For Win2K, in dv scenarios where the Smart Tee is used
// to capture+preview from msdv, dv frames are dropped causing audio 
// stuttering even when cpu consumption is low (~30%). See Manbugs 42032.
// Setting m_nMaxPreview to 2 in this case is a hack to work around 
// the problem.
//
HRESULT CSmartTeeInputPin::Active()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr;

    hr = CBaseInputPin::Active();
    m_nMaxPreview = 0;

    if (!IsConnected())
    {
        return hr;
    }
    if (!IsEqualGUID(*m_mt.FormatType(), FORMAT_DvInfo))
    {
        return hr;
    }

    
#if 0
    // @@@ For tuning only
    // HKEY hk;
    // if (RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Debug\\qcap.dll"), &hk) == ERROR_SUCCESS)
    // {
    //    DWORD type;
    //    int value;
    //    DWORD len = sizeof(value);
        
    //    if (RegQueryValueEx(hk, TEXT("MaxPreview"), 0, &type, (LPBYTE) (&value), &len) == ERROR_SUCCESS &&
    //        type == REG_DWORD && len == sizeof(value))
    //    {
    //        m_nMaxPreview = value;
    //        RegCloseKey(hk);
    //        return hr;
    //    }
    //    RegCloseKey(hk);
    // }
    // End - for tuning only.
#endif

    if (g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        g_osInfo.dwMajorVersion >= 5)
    {
        // For Win2K and future NT OS only:
        // 2 works better than 1 on P3/600 w/ full or half decode.
        // With 1, frames are occasionally dropped.
        m_nMaxPreview = 2;
    }

    return hr;

} // Active


// ================================================================
// CSmartTeeOutputPin constructor
// ================================================================

CSmartTeeOutputPin::CSmartTeeOutputPin(TCHAR *pName,
                             CSmartTee *pTee,
                             HRESULT *phr,
                             LPCWSTR pPinName,
                             int PinNumber) :
    CBaseOutputPin(pName, pTee, pTee, phr, pPinName) ,
    m_pOutputQueue(NULL),
    m_pTee(pTee)
{
    ASSERT(pTee);

    // capture is 1, preview is 2
    m_bIsPreview = (PinNumber == 2);
}



#ifdef DEBUG
//
// CSmartTeeOutputPin destructor
//
CSmartTeeOutputPin::~CSmartTeeOutputPin()
{
    ASSERT(m_pOutputQueue == NULL);
}
#endif


//
// DecideBufferSize
//
// This has to be present to override the PURE virtual class base function
//
HRESULT CSmartTeeOutputPin::DecideBufferSize(IMemAllocator *pMemAllocator,
                                        ALLOCATOR_PROPERTIES * ppropInputRequest)
{
    return NOERROR;

} // DecideBufferSize


//
// DecideAllocator
//
HRESULT CSmartTeeOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    ASSERT(m_pTee->m_pAllocator != NULL);
    *ppAlloc = NULL;

    // Tell the pin about our allocator, set by the input pin.
    // We always say the samples are READONLY because the preview pin is sharing
    // the data going out the capture pin, which better not be changed
    HRESULT hr = NOERROR;
    hr = pPin->NotifyAllocator(m_pTee->m_pAllocator, TRUE);
    if (FAILED(hr))
        return hr;

    // Return the allocator
    *ppAlloc = m_pTee->m_pAllocator;
    m_pTee->m_pAllocator->AddRef();
    return NOERROR;

} // DecideAllocator


//
// CheckMediaType
//
HRESULT CSmartTeeOutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);
    //DbgLog((LOG_TRACE,3,TEXT("TTOut: CheckMT %d bit"), HEADER(pmt->Format())->biBitCount));

    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging purposes
    //!!!DisplayMediaType(TEXT("Output Pin Checking"), pmt);
#endif

    // The input needs to have been connected first
    if (m_pTee->m_Input.m_Connected == NULL) {
        //DbgLog((LOG_TRACE,3,TEXT("FAIL: In not connected")));
        return VFW_E_NOT_CONNECTED;
    }

    // If it doesn't match our input type, the input better be willing to
    // reconnect, and the other output better be too
    if (*pmt != m_pTee->m_Input.m_mt) {
        //DbgLog((LOG_TRACE,3,TEXT("Hmmm.. not same as input type")));
	for (int z = 0; z < m_pTee->m_NumOutputPins; z++) {
	    CSmartTeeOutputPin *pOut = m_pTee->GetPinNFromList(z);
	    IPin *pCon = pOut->m_Connected;
	    if (pOut != this && pCon) {
	        if (pCon->QueryAccept(pmt) != S_OK) {
        	    //DbgLog((LOG_TRACE,3,TEXT("FAIL:Other out can't accept")));
		    return VFW_E_TYPE_NOT_ACCEPTED;
		}
	    }
	}
	hr = m_pTee->m_Input.m_Connected->QueryAccept(pmt);
	if (hr != S_OK) {
            //DbgLog((LOG_TRACE,3,TEXT("FAIL: In can't reconnect")));
            return VFW_E_TYPE_NOT_ACCEPTED;
	}
    }

    return NOERROR;

} // CheckMediaType


//
// EnumMediaTypes
//
STDMETHODIMP CSmartTeeOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(ppEnum);

    // Make sure that we are connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    return CBaseOutputPin::EnumMediaTypes (ppEnum);
} // EnumMediaTypes

//
// GetMediaType
//
HRESULT CSmartTeeOutputPin::GetMediaType(   
    int iPosition,
    CMediaType *pMediaType
    )
{
    // Make sure that we have an input connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    IEnumMediaTypes *pEnum;
    HRESULT hr;

    // the first thing we offer is the current type other pins are connected
    // with... because if one output pin is connected to a filter whose input
    // pin offers media types, the current connected type might not be in
    // the list we're about to enumerate!
    if (iPosition == 0) {
	*pMediaType = m_pTee->m_Input.m_mt;
	return S_OK;
    }

    // offer all the types the filter upstream of us can offer, because we
    // may be able to reconnect and end up using any of them.
    AM_MEDIA_TYPE *pmt;
    hr = m_pTee->m_Input.m_Connected->EnumMediaTypes(&pEnum);
    if (hr == NOERROR) {
        ULONG u;
        pEnum->Skip(iPosition - 1);
        hr = pEnum->Next(1, &pmt, &u);
        pEnum->Release();
	if (hr == S_OK) {
	    *pMediaType = *pmt;
	    DeleteMediaType(pmt);
	    return S_OK;
	} else {
	    return VFW_S_NO_MORE_ITEMS;
	}
    } else {
        return E_FAIL;
    }

} // GetMediaType

//
// SetMediaType
//
HRESULT CSmartTeeOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Display the format of the media for debugging purposes
    // !!! DisplayMediaType(TEXT("Output pin type agreed"), pmt);
#endif

    // Make sure that we have an input connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    // Make sure that the base class likes it
    HRESULT hr = NOERROR;
    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    return NOERROR;

} // SetMediaType


//
// CompleteConnect
//
HRESULT CSmartTeeOutputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = NOERROR;

    //DbgLog((LOG_TRACE,3,TEXT("Output::CompleteConnect %d bit"), HEADER(m_mt.Format())->biBitCount));

    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    // If the type is not the same as that stored for the input
    // pin then force the input pins peer to be reconnected

    if (m_mt != m_pTee->m_Input.m_mt)
    {
    	//DbgLog((LOG_TRACE,3,TEXT("OUT Connected: RECONNECT IN")));
        hr = m_pTee->ReconnectPin(m_pTee->m_Input.m_Connected, &m_mt);
        if(FAILED(hr)) {
            return hr;
        }
    }

    // We may need to reconnect the other output pin too
    for (int z = 0; z < m_pTee->m_NumOutputPins; z++) {
	CSmartTeeOutputPin *pOut = m_pTee->GetPinNFromList(z);
	if (pOut != this && pOut->m_Connected && pOut->m_mt != this->m_mt) {
    	    //DbgLog((LOG_TRACE,3,TEXT("OUT Connected: RECONNECT OUT")));
            hr = m_pTee->ReconnectPin(pOut, &m_mt);
            if(FAILED(hr)) {
                return hr;
            }
	}
    }

    return NOERROR;

} // CompleteConnect


//
// Active
//
// This is called when we transition from stop to paused. We create the
// output queue object to send data to our associated peer pin
//
HRESULT CSmartTeeOutputPin::Active()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    m_fLastSampleDiscarded = FALSE;

    // reset the skipped count to zero every time we start streaming
    m_pTee->m_Input.m_nFramesSkipped = 0;

    // Make sure that the pin is connected
    if (m_Connected == NULL)
        return NOERROR;

    // Create the output queue if we have to
    if (m_pOutputQueue == NULL)
    {
 	// ALWAYS use a separate thread... it's the only way we can tell
	// if we have time to preview
        m_pOutputQueue = new CMyOutputQueue(m_Connected, &hr, FALSE, TRUE);
        if (m_pOutputQueue == NULL)
            return E_OUTOFMEMORY;

        // Make sure that the constructor did not return any error
        if (FAILED(hr))
        {
            delete m_pOutputQueue;
            m_pOutputQueue = NULL;
            return hr;
        }
    }

    // Pass the call on to the base class
    CBaseOutputPin::Active();
    return NOERROR;

} // Active


//
// Inactive
//
// This is called when we stop streaming
// We delete the output queue at this time
//
HRESULT CSmartTeeOutputPin::Inactive()
{
    CAutoLock lock_it(m_pLock);

    // Delete the output queue associated with the pin.
    if (m_pOutputQueue)
    {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }

    CBaseOutputPin::Inactive();
    return NOERROR;

} // Inactive



// expose IAMStreamControl
//
STDMETHODIMP CSmartTeeOutputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IAMStreamControl) {
	return GetInterface((LPUNKNOWN)(IAMStreamControl *)this, ppv);
    }

    return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}

//
// Deliver
//
HRESULT CSmartTeeOutputPin::Deliver(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;

    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    if (CheckStreamState(pMediaSample) != STREAM_FLOWING) {
	m_fLastSampleDiscarded = TRUE;
	return S_OK;
    }

    if (m_fLastSampleDiscarded) {
	pMediaSample->SetDiscontinuity(TRUE);
    }
    m_fLastSampleDiscarded = FALSE;

    // capture pin? just give it to the queue
    if (!m_bIsPreview) {
        pMediaSample->AddRef();
        //DbgLog((LOG_TRACE,1,TEXT("Putting on capture Q")));
        return m_pOutputQueue->Receive(pMediaSample);
    }

    // For the preview pin, we need to remove the time stamps because preview
    // pin frames will always be late, and dropped by the renderer if they
    // are time stamped, since we don't know the latency of the graph.
    // We can't remove the time stamp on this sample, because the capture pin
    // is using it, so we make a new sample with the same data to use, which
    // will be identical except without time stamps, and when it is freed, we
    // release our ref count on the original sample (which has the data)

    CMyMediaSample *pNewSample = new CMyMediaSample(NAME("Preview sample"),
			(CBaseAllocator *)m_pTee->m_pAllocator, m_pOutputQueue,
			&hr);
    if (pNewSample == NULL || hr != NOERROR)
	return E_OUTOFMEMORY;
    pNewSample->AddRef();	// not done in constructor

    BYTE *pBuffer;
    hr = pMediaSample->GetPointer(&pBuffer);
    if (hr != NOERROR) {
	pNewSample->Release();
	return E_UNEXPECTED;
    }

    hr = pNewSample->SetPointer(pBuffer, pMediaSample->GetSize());
    if (hr != NOERROR) {
	pNewSample->Release();
	return E_UNEXPECTED;
    }
    pNewSample->SetTime(NULL, NULL);
    // did we send the last capture frame out the preview or not?
    pNewSample->SetDiscontinuity(m_pTee->m_Input.m_nFramesSkipped != 1);
    pNewSample->SetSyncPoint(pMediaSample->IsSyncPoint() == S_OK);
    pNewSample->SetPreroll(pMediaSample->IsPreroll() == S_OK);
    pNewSample->m_pOwnerSample = pMediaSample;
    pMediaSample->AddRef();
    //DbgLog((LOG_TRACE,1,TEXT("Putting on Receive Q")));
    return m_pOutputQueue->Receive(pNewSample);

} // Deliver


//
// DeliverEndOfStream
//
HRESULT CSmartTeeOutputPin::DeliverEndOfStream()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    //DbgLog((LOG_TRACE,1,TEXT("::DeliverEndOfStream")));

    m_pOutputQueue->EOS();
    return NOERROR;

} // DeliverEndOfStream


//
// DeliverBeginFlush
//
HRESULT CSmartTeeOutputPin::DeliverBeginFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->BeginFlush();
    return NOERROR;

} // DeliverBeginFlush


//
// DeliverEndFlush
//
HRESULT CSmartTeeOutputPin::DeliverEndFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->EndFlush();
    return NOERROR;

} // DeliverEndFlish

//
// DeliverNewSegment
//
HRESULT CSmartTeeOutputPin::DeliverNewSegment(REFERENCE_TIME tStart, 
                                         REFERENCE_TIME tStop,  
                                         double dRate)          
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->NewSegment(tStart, tStop, dRate);
    return NOERROR;

} // DeliverNewSegment


//
// Notify
//
STDMETHODIMP CSmartTeeOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    // Quality management is unneccessary with a live source
    return E_NOTIMPL;
} // Notify


#ifdef FILTER_DLL
//
// DllRegisterServer
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}


//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}
#endif



CMyOutputQueue::CMyOutputQueue(IPin *pInputPin, HRESULT *phr,
                 		BOOL bAuto, BOOL bQueue, LONG lBatchSize,
                 		BOOL bBatchExact, LONG lListSize,
                 		DWORD dwPriority) :
    COutputQueue(pInputPin, phr, bAuto, bQueue, lBatchSize, bBatchExact,
			lListSize, dwPriority)
{
    m_nOutstanding = 0;
}


CMyOutputQueue::~CMyOutputQueue()
{
}


// how many samples are queued but not sent?
int CMyOutputQueue::GetThreadQueueSize()
{
    if (m_List)
        return m_List->GetCount();
    else
	return 0;
}

CMyMediaSample::CMyMediaSample(TCHAR *pName, CBaseAllocator *pAllocator,
		CMyOutputQueue *pQ, HRESULT *phr, LPBYTE pBuffer, LONG length) :
	CMediaSample(pName, pAllocator, phr, pBuffer, length)
{
    m_pOwnerSample = NULL;
    m_pQueue = pQ;
}

CMyMediaSample::~CMyMediaSample()
{
}

STDMETHODIMP_(ULONG) CMyMediaSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
	    this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {

	// make a note that we're done with this sample
	m_pQueue->m_nOutstanding--;

        /* Free all resources */
        if (m_dwFlags & Sample_TypeChanged) {
            SetMediaType(NULL);
        }
        ASSERT(m_pMediaType == NULL);
#if 0
        m_dwFlags = 0;
        m_dwTypeSpecificFlags = 0;
        m_dwStreamId = AM_STREAM_MEDIA;
#endif

// we overrode this function to avoid this, because the memory actually belongs
// to another sample, so instead we do:
#if 0
        /* This may cause us to be deleted */
        // Our refcount is reliably 0 thus no-one will mess with us
        m_pAllocator->ReleaseBuffer(this);
#else
        if (m_pOwnerSample) {
	    m_pOwnerSample->Release();
	    m_pOwnerSample = NULL;
            DbgLog((LOG_TRACE,4,TEXT("Release Released OWNER sample")));
	}
#endif

        delete this;	// no allocator to do this for me
    }

    return (ULONG)lRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\strmaloc\inc\stmalloc.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

//
// CStreamAllocator
//
// an allocator of IMediaSample objects, and implementation of IMemAllocator
// for streaming file-reading tasks
//

// additionally, CStreamAllocator is an IMemAllocator implementation
// and provides support for
//  -- creating IMediaSample interfaces for specified regions of file
//  -- ensuring contiguity for IMediaSample-mapped regions
//
//

class CCircularBufferList;

class CStreamAllocator : public CBaseAllocator
{
public:

    // Constructor and Destructor
    CStreamAllocator(TCHAR *, LPUNKNOWN, HRESULT *, LONG lMaxContig);
    ~CStreamAllocator();

    // CBaseAllocator Overrides

    // we have to be based on CBaseAllocator in order to use CMediaSample.
    // we use CBaseAllocator to manage the list of CMediaSample objects, but
    // override most of the functions as we dont support GetBuffer directly.

    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES * pRequest,
        ALLOCATOR_PROPERTIES * pActual
    );

    //  Get the next buffer
    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                           REFERENCE_TIME *pStartTime,
                           REFERENCE_TIME *pEndTime,
                           DWORD dwFlags);

protected:
    // this is pure virtual in CBaseAllocator, and so we must override.
    virtual void    Free(void);
    virtual HRESULT Alloc(void);

public:
    // Stuff to generate samples for an output pin and to scan the
    // data without it going away

    // Lock data and get a pointer
    // If we're at the end of the file cBytes can be modified.
    // It's an error to ask for more than m_lMaxContig bytes
    HRESULT LockData(PBYTE pData, LONG& cBytes);

    // Unlock data
    HRESULT UnlockData(PBYTE ptr, LONG cBytes);

    // Get a buffer back from the upstream filter
    HRESULT Receive(PBYTE pData, LONG lData);

    // Set a new start position
    void SetStart(LONGLONG llPos);

    // End of stream
    void EndOfStream()
    {
        m_pBuffer->SetEOS();
    };

    PBYTE GetPosition() const
    {
        return m_pCurrent;
    };

    LONG CurrentOffset() const
    {
        return m_bEmpty ? m_pBuffer->LengthValid() :
                          m_pBuffer->Offset(m_pCurrent);
    };

    LONGLONG GetCurrentOffset() const
    {
        return m_llPosition;
    };

    void ResetPosition();

    LONG LengthValid() const
    {
        return m_bEmpty ? 0 : m_pBuffer->LengthContiguous(m_pCurrent);
    };

    LONG TotalLengthValid() const
    {
        return m_bEmpty ? 0 :
                   m_pBuffer->LengthValid() - m_pBuffer->Offset(m_pCurrent);
    };

    // Advance our parsing pointer, freeing data no longer needed
    BOOL Advance(LONG lAdvance);

    // Seek to a fixed position if the data is in the buffer
    BOOL Seek(LONGLONG llPos);

    // Request that the reeder seek
    //
    BOOL SeekTheReader(LONGLONG llPos);

    // Number of free buffers
    BOOL IsBlocked()
    {
        CAutoLock lck(this);
        return m_lWaiting != 0;
    }

private:
    void LockUnlock(PBYTE pData, LONG cBytes, BOOL Lock);
    void ReallyFree();

private:
    CCircularBufferList * m_pBuffer;         // Circular buffer
    const LONG            m_lMaxContig;      // Max contig requirement

    /*  Track position of samples received */
    int                   m_NextToAllocate;
    PBYTE                 m_pCurrent;
    BOOL                  m_bEmpty;          // m_pCurrent is just
                                             // after valid data
    LONGLONG              m_llPosition;      // Position in stream
    BOOL                  m_bPositionValid;  // Have we had a SetStart
                                             // since the last ResetPosition?

    BOOL                  m_bSeekTheReader;  // force reader to seek on next
    LONGLONG              m_llSeekTheReader; // get buffer

#ifdef DEBUG
    BOOL                  m_bEventSet;
#endif

    /*  Sample elements */
    IMediaSample       ** m_pSamples;
};

//  Minimal allocator so that we get a different ReleaseBuffer callback
//  Plus allocate samples on top of a CStreamAllocator's memory
//
// you can call GetSample to lock a range and get an IMediaSample* back that
// references this data. You can call SetProperties to set limits on the
// number of IMediaSamples available and the maximum size of each lock.
// Multiple successive calls to SetProperties will cause it to take the
// smallest value for each figure.
//

class CSubAllocator : public CBaseAllocator
{
public:
    CSubAllocator(TCHAR            * Name,
                  LPUNKNOWN          pUnk,
                  CStreamAllocator * pAllocator,
                  HRESULT          * phr);
    ~CSubAllocator();
    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES * pRequest,
        ALLOCATOR_PROPERTIES * pActual
    );

    // Just return an error
    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                           REFERENCE_TIME *pStartTime,
                           REFERENCE_TIME *pEndTime,
                           DWORD dwFlags);

    // called by CMediaSample to return it to the free list and
    // block any pending GetSample call.
    STDMETHODIMP ReleaseBuffer(IMediaSample * pSample);
    // obsolete: virtual void PutOnFreeList(CMediaSample * pSample);

    // call this to get a CMediaSample object whose data pointer
    // points directly into the read buffer for the given pointer.
    // The length must not be greater than MaxContig.
    HRESULT GetSample(PBYTE pData, LONG cBytes, IMediaSample** ppSample);

protected:
    // this is pure virtual in CBaseAllocator, and so we must override.
    virtual void Free(void);
    virtual HRESULT Alloc(void);

    // this is called to create new CMediaSample objects. If you want to
    // use objects derived from CMediaSample, override this to create them.
    virtual CMediaSample* NewSample();

private:
    CStreamAllocator * const m_pStreamAllocator;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\util\code\callback.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

#include <streams.h>
#include "callback.h"

const int LOG_CALLBACK_RELATED = 5 ;
const   int TGT_CALLBACK_TOKEN = 0x99999999 ;

// implementation of callback thread object

CCallbackThread::CCallbackThread(CCritSec* pCritSec)
  : m_pCritSec(pCritSec),
    m_hThread(NULL),
    m_evUser(0),
    m_pClock(NULL),
    m_fAbort(FALSE),	// thread carries on until this is set
    m_evSignalThread(TRUE),	// manual reset
    m_evAdvise(TRUE),	// manual reset
    m_Items(NAME("Callback Item list")),
    m_dwAdvise(0),
    m_dwTGTCallbackToken (0),
    m_fnTGTCallback (NULL),
    m_dwNextTGTCallback (0),
    m_dwTGTCallbackPeriod (0),
    m_dwScheduleCookie(0)
{

}

// should not be holding the critsec during this destructor
// in case the worker thread is attempting to lock it
CCallbackThread::~CCallbackThread()
{
    // cancel any advise with the clock
    CancelAdvise();

    //make sure the exits
    CloseThread();

    // clean up list of outstanding requests
    POSITION pos = m_Items.GetHeadPosition();
    while(pos) {
        CAdviseItem* pItem = m_Items.GetNext(pos);
        delete pItem;
    }
    m_Items.RemoveAll();

}

HRESULT
CCallbackThread::SetSyncSource(IReferenceClock* pClock)
{
    CAutoLock lock(m_pCritSec);

    // cancel existing advise
    CancelAdvise();

    // don't need to addref pClock since we will get a
    // SetSyncSource(NULL) before it goes away

    m_pClock = pClock;

    // set up advise on new clock
    SetAdvise();

    return S_OK;
}


// queue a request to callback a given function. returns a token that can
// be passed to Cancel.
//
// The token is actually a pointer to the CAdviseItem*

HRESULT
CCallbackThread::Advise(
    CCallbackAdvise fnAdvise,
    DWORD_PTR dwUserToken,
    REFERENCE_TIME rtCallbackAt,
    DWORD_PTR* pdwToken
)	
{
    // use this to lock all our structures as well as
    // callbacks
    CAutoLock lock(m_pCritSec);

    // need a clock to do this
    if (!m_pClock) {
        return VFW_E_NO_CLOCK;
    }

    // first create an item to hold the info
    ASSERT(rtCallbackAt > 0);
    CAdviseItem* pItem = new CAdviseItem(fnAdvise, dwUserToken, rtCallbackAt);
    if (!pItem) {
        return E_OUTOFMEMORY;
    }

    // cheap version: we don't sort the list -- we find the soonest
    // time whenever we need it.
    m_Items.AddTail(pItem);

    // force a recheck of the advise
    SetAdvise();

    // the token we return is a pointer to the object
    *pdwToken = (DWORD_PTR) pItem;
    return S_OK;
}

// AdvisePeriodicWithEvent is currently called by the DSound renderer to
// schedule a periodic callback that needs to happen irrespective of how
// the reference clock is behaving. We do not link this to the clock's
// callback mechanism, but handle this separately using timeGetTime. Refer
// to the ThreadProc code to see how this is done.
//
// We can deal with only one such event.
//
// The token returned is a magic signature.
//
// IF hUser is not null then also wait on this event handle, and call back
// the user's routine if the event fires.
//

HRESULT
CCallbackThread::AdvisePeriodicWithEvent(
    CCallbackAdvise fnAdvise,
    DWORD_PTR dwUserToken,
    REFERENCE_TIME rtPeriod,
    HANDLE hUser,
    DWORD_PTR* pdwToken
)	
{
    // use this to lock all our structures as well as
    // callbacks
    CAutoLock lock(m_pCritSec);

    // Ensure that a thread is there now.
    const HRESULT hr = EnsureThread();
    if (FAILED(hr)) return hr;

    DWORD rtNow;

    // we only allow one active user hEvent
    if (m_evUser && hUser) return E_FAIL;

    // we allow only one such event, period.
    if (m_dwTGTCallbackToken)
        return E_FAIL ;
    
    ASSERT(rtPeriod > 0);

    // get the time now.  the periodic advise is always from the last
    // wakeup point. Also we base this on the GetPrivateTime time as the
    // GetTime time can stall when the private time goes back. We will
    // set the  trigger based on private time and make adjustments to
    // the trigger time when private time is adjusted.

    rtNow = timeGetTime() ;
    m_dwTGTCallbackPeriod = DWORD(rtPeriod/10000) ;

    // set the time callback time.
    m_dwNextTGTCallback = rtNow + m_dwTGTCallbackPeriod ;

    // save the other callback parameters
    m_dwTGTUserToken = dwUserToken ;
    m_fnTGTCallback = fnAdvise ;
    
    // Make sure the thread wakes up if the event is signalled
    if (hUser) {
        m_evUser = hUser;
    }

    m_evSignalThread.Set();

    // the token we return is a magic signature.

    m_dwTGTCallbackToken = 0x99999999 ;
    *pdwToken = m_dwTGTCallbackToken ;

    return S_OK;
}

HRESULT CCallbackThread::ServiceClockSchedule
( CBaseReferenceClock * pClock
, CAMSchedule * pSchedule
, DWORD * dwCookie
)
{
    *dwCookie = 0;
    if (m_dwScheduleCookie != 0) return E_FAIL;

    // we need to make sure we have a thread now
    const HRESULT hr = EnsureThread();
    if (FAILED(hr)) return hr;

    m_pBaseClock = pClock;
    m_pSchedule = pSchedule;
    DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: Setting m_dwScheduleCookie")));
    m_dwScheduleCookie = 0xFFFFFFFF;
    *dwCookie = m_dwScheduleCookie;
    m_evSignalThread.Set();
    return S_OK;
}


HRESULT
CCallbackThread::Cancel(DWORD_PTR dwToken)
{
    // need to check for the object on our list
    CAutoLock lock(m_pCritSec);

    if (dwToken == m_dwScheduleCookie)
    {
        DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: Clearing m_dwScheduleCookie")));
        m_dwScheduleCookie = 0;
        return S_OK;
    }

    // special case the token for timeGetTime based callback
    if ((dwToken == 0x99999999) && (m_dwTGTCallbackToken == dwToken))
    {
        if (m_evUser)
        {
            // Get the thread to remove the event handle
            m_evSignalThread.Set();
            m_evUser = 0 ;
        }

        m_dwTGTCallbackToken = 0 ;
        return S_OK;
    }

    POSITION pos = m_Items.GetHeadPosition();
    while(pos) {
        // GetNext advances pos, so remember the
        // one we will delete
        POSITION posDel = pos;
        CAdviseItem*pItem = m_Items.GetNext(pos);

        if (pItem == (CAdviseItem*) dwToken)
        {
            m_Items.Remove(posDel);
            delete pItem;
            return S_OK;
        }
    }
    return VFW_E_ALREADY_CANCELLED;
}

void CCallbackThread::CancelAllAdvises()
{
    CloseThread();
}

// must hold critsec before checking this
HRESULT
CCallbackThread::EnsureThread()
{
    if (m_hThread) {
        return S_OK;
    }
    return StartThread();
}

// must hold critsec before checking this
HRESULT
CCallbackThread::StartThread()
{
    // call EnsureThread to start the thread
    ASSERT(!m_hThread);

    // clear the stop event before starting
    m_evSignalThread.Reset();

    DWORD dwThreadID;
    m_hThread = CreateThread(
                    NULL,
                    0,
                    InitialThreadProc,
                    this,
                    0,
                    &dwThreadID);
    if (!m_hThread)
    {
        DWORD dwErr = GetLastError();
        return AmHresultFromWin32(dwErr);
    }
    else
        SetThreadPriority( m_hThread, THREAD_PRIORITY_TIME_CRITICAL );


    return S_OK;

}

void
CCallbackThread::CloseThread()
{
    // signal the thread-exit object
    m_fAbort = TRUE;  // thread will now die when it wakes up
    m_evSignalThread.Set();

    if (m_hThread) {

        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }
}

// static function called as thread starts -
// param is actually a CCallbackThread*
DWORD
CCallbackThread::InitialThreadProc(void * pvParam)
{
    CCallbackThread* pThis = (CCallbackThread*)pvParam;
    ASSERT(pThis);
    return pThis->ThreadProc();
}

DWORD
CCallbackThread::ThreadProc(void)
{
    // the first-placed object will be reported if both are
    // set, so ordering is important - put the exit event first

    // rather than allowing multiple users, each with their own event,
    // we only allow one user to pass an event handle in.  Otherwise
    HANDLE ahev[4] = {m_evSignalThread, m_evAdvise};

    for(;;) {

        // The number of events can change on every iteration
        DWORD dwEventCount = 2;
        DWORD timeout = INFINITE;
        {
            CAutoLock lock(m_pCritSec);

            if (m_evUser) ahev[dwEventCount++] = m_evUser;
            if (m_dwScheduleCookie)
            {
                ahev[dwEventCount++] = m_pSchedule->GetEvent();
                const REFERENCE_TIME rtNow = m_pBaseClock->GetPrivateTime();
                if (m_pSchedule->GetAdviseCount() > 0 )
                {

                    // NB: Add in an extra millisecond to prevent thrashing
                    const REFERENCE_TIME rtNext = m_pSchedule->Advise(rtNow + 10000);
                    if ( rtNext != MAX_TIME ) timeout = DWORD((rtNext - rtNow)/10000);
                }
            }

            // if we have a TGT (timeGetTime based) advise event set, deal with it.
            if (m_dwTGTCallbackToken)
            {
                // get current time.
                DWORD t1 = timeGetTime () ;
                DWORD t2 ;

                // if it is time to callback the event, do so and set next callback time
                if (((long)(t1 - m_dwNextTGTCallback)) >= 0)
                {
                    DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: DS callback late %ums"), (t1 - m_dwNextTGTCallback)));
                    m_fnTGTCallback (m_dwTGTUserToken) ;
                    m_dwNextTGTCallback = t1 + m_dwTGTCallbackPeriod ;
                    t2 = m_dwTGTCallbackPeriod ;
                }
                else
                {
                    // figure out how much more to go till the TGT callback.
                    t2 = m_dwNextTGTCallback - t1 ;
                }
                // adjust time timeout to account for the TGT callback

                if (timeout > t2)
                    timeout = t2 ;
            }
        }


        DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: TimeOut = %u"), timeout));

        const DWORD dw = WaitForMultipleObjects(
                                            dwEventCount,
                                            ahev,
                                            FALSE,
                                            timeout);

        if (m_fAbort)
        {
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: Aborting...")));
            return 0;
        }

        switch (dw)
        {
        case WAIT_OBJECT_0:
            // We were woken up deliberately.  Probably
            // to re-evaluate the event handles
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: ReEvaluate")));
            m_evSignalThread.Reset();
            break;

        case WAIT_OBJECT_0 + 1:
            // requests need processing
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: ProcessRequest")));
            ProcessRequests();
            break;

        case WAIT_OBJECT_0 + 2:
            if (m_evUser)
            {
                // user passed event has been signalled. This is related to the
                // dsound callback.

                DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: User Signal")));
                ProcessUserSignal();
                break;
            }
            // Deliberate fall-through
        case WAIT_OBJECT_0 + 3:
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: Object+3")));
            break ;

        case WAIT_TIMEOUT:
            // no-op We'll Advise in the "if (m_dwScheduleCookie)" block.
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: TimeOut")));
            break;

        default:
            // What happened??
            DbgBreak("WaitForMultipleObjects failed or produced an unexpected return code.");
            return 0;
        }
    }
}

// Process the TGT callback via event.
void
CCallbackThread::ProcessUserSignal(void)
{
    // we take the lock while managing the lists as well as processing
    // the dispatches. This is the same lock any cancelling thread
    // will hold and the same lock that will be used to remove/set the clock
    CAutoLock lock(m_pCritSec);

    if (m_evUser && m_dwTGTCallbackToken)
    {
        m_fnTGTCallback (m_dwTGTUserToken) ;
        m_dwNextTGTCallback = timeGetTime() + m_dwTGTCallbackPeriod ;
    }
    else
    {
        // the user probably cancelled before we took the lock
    }
}

//loop through the list looking for any advises that are ready
void
CCallbackThread::ProcessRequests(void)
{
    // we take the lock while managing the lists as well as processing
    // the dispatches. This is the same lock any cancelling thread
    // will hold and the same lock that will be used to remove/set the clock
    CAutoLock lock(m_pCritSec);

    // we can't work without a clock
    ASSERT( (m_Items.GetCount() == 0) || (m_pClock));
    if (m_pClock) {

        REFERENCE_TIME rt  ;
        m_pClock->GetTime(&rt);

        POSITION pos = m_Items.GetHeadPosition();
        while (pos) {
            // remember location in case we need to dispatch it
            POSITION posDel = pos;
            CAdviseItem *pItem = m_Items.GetNext(pos);

            // is it ready?
            if (pItem->Time() <= rt) {
                BOOL fIsPeriodic;

                if (!(fIsPeriodic = pItem->UpdateTime(rt))) {
                    m_Items.Remove(posDel);
                }

                pItem->Dispatch();
                if (!fIsPeriodic) delete pItem;
            }
        }

        // reset the clock for next time
        SetAdvise();
    }
}


// find the earliest requested time
// simple implementation based on the assumption that there will at most
// one item on the list normally - search the list.
// returns S_OK if there is a item or S_FALSE if the list is empty.
HRESULT
CCallbackThread::GetSoonestAdvise(REFERENCE_TIME& rrtFirst)
{
    REFERENCE_TIME rtFirst;
    BOOL bSet = FALSE;

    POSITION pos = m_Items.GetHeadPosition();
    while(pos) {
        CAdviseItem* pItem = m_Items.GetNext(pos);

        REFERENCE_TIME rt = pItem->Time();
        if (!bSet || rt < rtFirst) {
            rtFirst = rt;
            bSet = TRUE;
        }
    }
    if (bSet) {
        rrtFirst = rtFirst;
        return S_OK;
    } else {
        return S_FALSE;
    }
}

// se.t up a new advise with the clock if needed
// must be called within the critsec
HRESULT
CCallbackThread::SetAdvise()
{
    if (!m_pClock) {
        return VFW_E_NO_CLOCK;
    }

    // always cancel the current advise first
    CancelAdvise();

    // work out what the new advise time should be
    REFERENCE_TIME rtFirst;
    HRESULT hr = GetSoonestAdvise(rtFirst);
    if (hr != S_OK) {
        return S_OK;
    }

    // we need to make sure we have a thread now
    hr = EnsureThread();
    if (FAILED(hr)) {
        return hr;
    }

    // request an advise (in reference time)
    hr = m_pClock->AdviseTime(
                        rtFirst,
                        TimeZero,
                        (HEVENT) HANDLE(m_evAdvise),
                        &m_dwAdvise);
    ASSERT(SUCCEEDED(hr));

    return hr;
}

void
CCallbackThread::CancelAdvise(void)
{
    if (m_dwAdvise) {
        m_pClock->Unadvise(m_dwAdvise);
        m_dwAdvise = 0;
    }
    m_evAdvise.Reset();
}


// --- implementation of CAdviseItem ---

CCallbackThread::CAdviseItem::CAdviseItem(
    CCallbackAdvise fnAdvise,
    DWORD_PTR dwUserToken,
    REFERENCE_TIME rtAt,
    REFERENCE_TIME rtPeriod,
    DWORD flags)
  : m_fnAdvise(fnAdvise)
  , m_dwUserToken(dwUserToken)
  , m_rtCallbackAt(rtAt)
  , m_rtPeriod(rtPeriod)
  , m_dwAdviseFlags (flags)
{

}

void
CCallbackThread::CAdviseItem::Dispatch()
{
    m_fnAdvise(m_dwUserToken);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\smarttee\smarttee.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __SMARTTEE__
#define __SMARTTEE__

extern const AMOVIESETUP_FILTER sudSmartTee;

class CSmartTee;
class CSmartTeeOutputPin;
class CMyOutputQueue;

// class for the Tee filter's Input pin

class CSmartTeeInputPin : public CBaseInputPin
{
    friend class CSmartTeeOutputPin;
    CSmartTee *m_pTee;                  // Main filter object

public:

    // Constructor and destructor
    CSmartTeeInputPin(TCHAR *pObjName,
                 CSmartTee *pTee,
                 HRESULT *phr,
                 LPCWSTR pPinName);

#ifdef DEBUG
    ~CSmartTeeInputPin();
#endif

    // Used to check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();
    HRESULT Active();

    // Reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    // Pass through calls downstream
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    // how many frames in a row were not sent out the preview pin
    int m_nFramesSkipped;

    int m_cBuffers;	    // number of buffers in allocator
    int m_cbBuffer;	    // size of the allocator buffers
    int m_nMaxPreview;      // The number of samples in the preview pipe
                            // must be at most this value for us to 
                            // queue another one. 
    CCritSec m_csReceive;

};


// Class for the Tee filter's Output pins.

class CSmartTeeOutputPin : public CBaseOutputPin, public CBaseStreamControl
{
    friend class CSmartTeeInputPin;
    friend class CSmartTee;

    CSmartTee *m_pTee;                  // Main filter object pointer
    CMyOutputQueue *m_pOutputQueue;  // Streams data to the peer pin
    BOOL m_bIsPreview;             // TRUE if Preview pin

    BOOL m_fLastSampleDiscarded;   // after discarding, next sample is discont

public:

    // Constructor and destructor

    CSmartTeeOutputPin(TCHAR *pObjName,
                   CSmartTee *pTee,
                   HRESULT *phr,
                   LPCWSTR pPinName,
                   INT PinNumber);

#ifdef DEBUG
    ~CSmartTeeOutputPin();
#endif

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    DECLARE_IUNKNOWN


    // Override to enumerate media types
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition,
                         CMediaType *pMediaType);

    // Negotiation to use our input pins allocator
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Used to create output queue objects
    HRESULT Active();
    HRESULT Inactive();

    // Overriden to create and destroy output pins
    HRESULT CompleteConnect(IPin *pReceivePin);

    // Overriden to pass data to the output queues
    HRESULT Deliver(IMediaSample *pMediaSample);
    HRESULT DeliverEndOfStream();
    HRESULT DeliverBeginFlush();
    HRESULT DeliverEndFlush();
    HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);


    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);
};


// Class for the Tee filter

class CSmartTee: public CCritSec, public CBaseFilter
{
    // Let the pins access our internal state
    friend class CSmartTeeInputPin;
    friend class CSmartTeeOutputPin;
    typedef CGenericList <CSmartTeeOutputPin> COutputList;

    // Declare an input pin.
    CSmartTeeInputPin m_Input;

    // And two output pins
    CSmartTeeOutputPin *m_Capture;
    CSmartTeeOutputPin *m_Preview;

    INT m_NumOutputPins;            // Current output pin count
    COutputList m_OutputPinsList;   // List of the output pins
    INT m_NextOutputPinNumber;      // Increases monotonically.
    IMemAllocator *m_pAllocator;    // Allocator from our input pin

public:

    CSmartTee(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CSmartTee();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    // Send EndOfStream if no input connection
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

    // override GetState to return VFW_S_CANT_CUE when pausing
    //
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

   // for IAMStreamControl
   STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
   STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

protected:

    // The following manage the list of output pins

    void InitOutputPinsList();
    CSmartTeeOutputPin *GetPinNFromList(int n);
    CSmartTeeOutputPin *CreateNextOutputPin(CSmartTee *pTee);
};


// overridden to get number of samples the thread has queued
//
class CMyOutputQueue: public COutputQueue
{

    friend class CSmartTeeOutputPin;

public:
    CMyOutputQueue(IPin    *pInputPin,          //  Pin to send stuff to
                 HRESULT   *phr,                //  'Return code'
                 BOOL       bAuto = TRUE,       //  Ask pin if blocks
                 BOOL       bQueue = TRUE,      //  Send through queue (ignored if
                                                //  bAuto set)
                 LONG       lBatchSize = 1,     //  Batch
                 BOOL       bBatchExact = FALSE,//  Batch exactly to BatchSize
                 LONG       lListSize =         //  Likely number in the list
                                DEFAULTCACHE,
                 DWORD      dwPriority =        //  Priority of thread to create
                                THREAD_PRIORITY_NORMAL
                );
    ~CMyOutputQueue();

    int GetThreadQueueSize();
    BOOL m_nOutstanding;	// # objects on queue not released yet
};


class CMyMediaSample: public CMediaSample
{
public:
    CMyMediaSample(
        TCHAR *pName,
        CBaseAllocator *pAllocator,
        CMyOutputQueue *pQ,
        HRESULT *phr,
        LPBYTE pBuffer = NULL,
        LONG length = 0);

    ~CMyMediaSample();

    STDMETHODIMP_(ULONG) Release();

    IMediaSample *m_pOwnerSample;
    CMyOutputQueue *m_pQueue;	// what queue gets these samples
};

#endif // __SMARTTEE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvdec\decprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// externs
extern const TCHAR *szSubKey;
extern const TCHAR *szPropValName;


// class definition
class CDVDecProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void    GetControlValues();
    HRESULT SavePropertyInRegistry();

    CDVDecProperties(LPUNKNOWN lpunk, HRESULT *phr);

    BOOL m_bIsInitialized;				// Used to ignore startup messages

    // Display state holders
    int     m_iPropDisplay;                             // holds the id of the property chosen
    BOOL    m_bSetAsDefaultFlag;                        // holds whether user chose to set the property as future default

    IIPDVDec *m_pIPDVDec;				// The custom interface on the filter
   //IIPDVDec *pIPDVDec(void) { ASSERT(m_pIPDVDec); return m_pIPDVDec; }


}; // DVDecProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvdec\decprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
//#include <initguid.h>

#include "DecProp.h"
#include "resource.h"

const TCHAR *szSubKey =
    TEXT("Software\\Microsoft\\DirectShow\\DVDecProperties");
const TCHAR *szPropValName =
    TEXT("PropDisplay");

//
// CreateInstance
//
// Used by the ActiveMovie base classes to create instances
//
CUnknown *CDVDecProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDVDecProperties(lpunk, phr);
    if (punk == NULL) {
	*phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//
// Constructor
//
CDVDecProperties::CDVDecProperties(LPUNKNOWN pUnk, HRESULT *phr) :
    CBasePropertyPage(NAME("DVDec Property Page"),
                      pUnk,IDD_DVDec,IDS_DECTITLE),
    m_pIPDVDec(NULL),
    m_bIsInitialized(FALSE)
{
    ASSERT(phr);

} // (Constructor)


//
// OnReceiveMessage
//
// Handles the messages for our property window
//
INT_PTR CDVDecProperties::OnReceiveMessage(HWND hwnd,
                                           UINT uMsg,
                                           WPARAM wParam,
                                           LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

} // OnReceiveMessage


//
// OnConnect
//
// Called when we connect to a transform filter
//
HRESULT CDVDecProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIPDVDec == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IIPDVDec, (void **) &m_pIPDVDec);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pIPDVDec);

    // Get the initial  property
    m_pIPDVDec->get_IPDisplay(&m_iPropDisplay);
    m_bIsInitialized = FALSE ;
    return NOERROR;

} // OnConnect


//
// OnDisconnect
//
// Likewise called when we disconnect from a filter
//
HRESULT CDVDecProperties::OnDisconnect()
{
    // Release of Interface after setting the appropriate old effect value

    if (m_pIPDVDec == NULL) {
        return E_UNEXPECTED;
    }

    m_pIPDVDec->Release();
    m_pIPDVDec = NULL;
    return NOERROR;

} // OnDisconnect


//
// OnActivate
//
// We are being activated
//
HRESULT CDVDecProperties::OnActivate()
{
    
    CheckRadioButton(m_Dlg, IDC_DEC720x480, IDC_DEC88x60, m_iPropDisplay);
    m_bIsInitialized = TRUE;
    return NOERROR;

} // OnActivate


//
// OnDeactivate
//
// We are being deactivated
//
HRESULT CDVDecProperties::OnDeactivate(void)
{
    ASSERT(m_pIPDVDec);
    m_bIsInitialized = FALSE;
    GetControlValues();
    return NOERROR;

} // OnDeactivate


//
// OnApplyChanges
//
// Apply any changes so far made 
//
HRESULT CDVDecProperties::OnApplyChanges()
{
    HRESULT hr = NOERROR;

    GetControlValues();

    // if user wants to save settings as default
    if(m_bSetAsDefaultFlag)
    {
        // try to save
        hr = SavePropertyInRegistry();
    }

    // try to apply settings to current video in all cases, and propagate error code
    return (hr | ( m_pIPDVDec->put_IPDisplay(m_iPropDisplay) ));
    
} // OnApplyChanges


//
// GetControlValues
//
// Get the values of the DlgBox controls
// and set member variables to their values
//
void CDVDecProperties::GetControlValues()
{
    ASSERT(m_pIPDVDec);

    // Find which special DVDec we have selected
    for (int i = IDC_DEC720x480; i <= IDC_DEC88x60; i++) {
       if (IsDlgButtonChecked(m_Dlg, i)) {
            m_iPropDisplay = i;
            break;
        }
    }

    // Find if the Save As Default button is checked or not
    m_bSetAsDefaultFlag = (IsDlgButtonChecked(m_Dlg, IDC_CHECKSAVEASDEFAULT) == BST_CHECKED);

    // if Save as default is checked, then clear it
    if(m_bSetAsDefaultFlag)
    {
        // this msg always returns 0, no need to error check
        SendDlgItemMessage(m_Dlg, IDC_CHECKSAVEASDEFAULT, BM_SETCHECK, (WPARAM) BST_UNCHECKED, 0);
    }
}


//
// SavePropertyInRegistry
//
// Save the m_iPropDispay to the registry
// so the correct default property can be loaded by the
// filter next time
//
HRESULT CDVDecProperties::SavePropertyInRegistry()
{
    HKEY    hKey = NULL;
    LRESULT lResult = 0;
    DWORD   dwStatus = 0;

    // just try to create the key everytime,
    // it will either open existing, or try to create a new one
    if((lResult = RegCreateKeyEx(HKEY_CURRENT_USER,             // open key
                                    szSubKey,                   // sub key string
                                    0,                          // reserved
                                    NULL,                       // class string
                                    REG_OPTION_NON_VOLATILE,    // special options
                                    KEY_WRITE,                  // Security access
                                    NULL,                       // default security descriptor
                                    &hKey,                      // resulting key handle
                                    &dwStatus                   // status of creation (new/old key)
                                    )) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    // now that we have a key, set the value for the key
    if((lResult = RegSetValueEx(hKey,                           // open key
                                szPropValName,                  // name of the value
                                0,                              // reserved
                                REG_DWORD,                      // type of the value
                                (const BYTE*) &m_iPropDisplay,  // pointer to value data
                                sizeof(m_iPropDisplay)          // sizeof data
                                )) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\util\code\geterror.cpp ===
//--------------------------------------------------------------------------;
//
//  File: geterror.cpp
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//       Functions to get the error text for a given HRESULT.
//
//  Contents:
//
//  History:
//      06/11/96 PeterGib   Moved from header file to be exported from DLL
//
//      09/08/96 StephenE   Added WINAPI calling convention and removed
//                          unecessary unicode quartz.dll string, also
//                          made string literal const.
//
//--------------------------------------------------------------------------;

#include <windows.h>

#define _AMOVIE_
#include "errors.h"


const char quartzdllname[] = "quartz.dll";

// We try to obtain resources strings in the languages shown below
LANGID Lang[] = {
    // Quartz is a system object, try the system default language first
    MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
    // Failing that try the users preferred language
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),     
    // Otherwise go for anything!
    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)     
};

const int iLangIds = sizeof Lang / sizeof Lang[0];


// Unicode Version..
// This function stores the requested message in the buffer passed.
//
// Inputs: HRESULT - the message id
//         WCHAR * - address of the buffer to store the message in.
//         DWORD   - length of the supplied buffer
// Output: DWORD   - the number of characters stored in the buffer.

DWORD WINAPI AMGetErrorTextW(HRESULT hr, WCHAR *pbuffer, DWORD MaxLen)
{
    HMODULE hMod = GetModuleHandleA(quartzdllname);
    DWORD result=0;
    int i=0;

    // Look for Quartz messages
    do {
        result = FormatMessageW(FORMAT_MESSAGE_IGNORE_INSERTS |
                               FORMAT_MESSAGE_FROM_HMODULE |
                               FORMAT_MESSAGE_FROM_SYSTEM,
                               hMod,
                               hr,
                               Lang[i++],
                               pbuffer,
                               MaxLen,
                               NULL);
    } while(result == 0 && i<iLangIds);

    // Failing that look for system messages
    for(i = 0; i<iLangIds && !result; i++)
        result = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                               NULL,
                               hr,
                               Lang[i++],
                               pbuffer,
                               MaxLen,
                               NULL);

    return result;
}




// ANSI version
// This function stores the requested message in the buffer passed.
//
// Inputs: HRESULT - the message id
//         char *  - address of the buffer to store the message in.
//         DWORD   - length of the supplied buffer
// Output: DWORD   - the number of bytes stored in the buffer.

DWORD WINAPI AMGetErrorTextA(HRESULT hr , char *pbuffer , DWORD MaxLen)
{
    HMODULE hMod = GetModuleHandleA(quartzdllname);
    DWORD result=0;
    int i=0;

    do {
        result = FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK |
                               FORMAT_MESSAGE_FROM_HMODULE |
                               FORMAT_MESSAGE_FROM_SYSTEM,
                               hMod,
                               hr,
                               Lang[i++],
                               pbuffer,
                               MaxLen,
                               NULL);
    } while(result == 0 && i<iLangIds);

    // Failing that look for system messages
    for(i = 0; i<iLangIds && !result; i++)
        result = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
                               NULL,
                               hr,
                               Lang[i++],
                               pbuffer,
                               MaxLen,
                               NULL);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\util\code\reader.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

/*

    File:  reader.cpp

    Description:

        Mini file reader class used by parsers to search for stream
        and duration information

*/

#include <streams.h>
#include <wxdebug.h>
#include "rdr.h"

/*  Constructor and destructor */
CReader::CReader() :
    m_pbBuffer(NULL)
{
}

/*  Initialize our mini-file reader class

    Parameters:

        lBufferSize - size of buffer we should create to read into
        lReadSize  - size of reads to do
        bSeekable - it it's seekable
        llFileSize - total file length

    Returns:
        Standard HRESULT - can fail because of problems with the stream or
        lack of memory

*/
HRESULT CReader::Init(
    LONG lBufferSize,
    LONG lReadSize,
    BOOL bSeekable,
    LONGLONG llFileSize
)
{
    m_lBufferSize = lBufferSize;
    m_lReadSize   = lReadSize;
    m_bSeekable   = bSeekable;
    m_llPosition  = 0;
    m_lValid      = 0;
    m_pbBuffer    = new BYTE[lBufferSize];

    if (m_pbBuffer == NULL) {
        return E_OUTOFMEMORY;
    }

    /*  Now to get the duration */
    if (bSeekable) {
        m_llSize = llFileSize;

        /*  Seek to 0 (important if we're reusing this stream!) */
        HRESULT hr = Seek((LONGLONG)0);
        if (FAILED(hr)) {
            return hr;
        }
        ASSERT(m_llPosition == 0);
    }

    return S_OK;
}

CReader::~CReader()
{
    if (m_pbBuffer) {
	delete [] m_pbBuffer;
    }
}

/*
    Seek the reader

    Parameters:
        llPos - where to seek to (absolute seek)

    The stream is seeked and our 'cache' in the buffer is discarded.
*/
HRESULT CReader::Seek(LONGLONG llPos)
{
    ASSERT(m_bSeekable);

    LONGLONG llNewPos;

    HRESULT hr = SeekDevice(llPos, &llNewPos);

    if (FAILED(hr)) {
        return hr;
    }
    m_llPosition = llNewPos;
    m_lValid     = 0;
    return S_OK;
}


/*
    Return the length of the stream we were given
*/
LONGLONG CReader::GetSize(LONGLONG *pllAvailable)
{
    ASSERT(m_bSeekable);
    if (pllAvailable != NULL) {
        *pllAvailable = m_llSize;
    }
    return m_llSize;
}

/*
    Get the current position parameters

    Returns pointer to the buffer of valid data

    Length of valid data returned in LengthValid

    Current file position as represented by the start of the buffer in llPos
*/
PBYTE CReader::GetCurrent(LONG& lLengthValid, LONGLONG& llPos) const
{
    lLengthValid = m_lValid;
    llPos        = m_llPosition;
    return m_pbBuffer;
};

/*
    Read more data from the stream

    Returns standard HRESULT
*/
HRESULT CReader::ReadMore()
{
    /*  See how much will fit */
    LONG lRemaining = m_lBufferSize - m_lValid;
    ASSERT(lRemaining >= 0);
    LONG lToRead;
    if (lRemaining < m_lReadSize) {
        lToRead = lRemaining;
    } else {
        lToRead = m_lReadSize;
    }

    DWORD dwRead;
    HRESULT hr = ReadFromDevice((PVOID)(m_pbBuffer + m_lValid),
                                  lToRead,
                                  &dwRead);
    if (FAILED(hr)) {
        return hr;
    }

    m_lValid += dwRead;
    return dwRead == 0 ? S_FALSE : S_OK;
}

/*
     Advance our pointer by lAdvance

     Implementation is to make m_pBuffer point to the start of any data
     still valid by shifting the remaining data to the front.
*/
void CReader::Advance(LONG lAdvance)
{
    ASSERT(m_lValid >= lAdvance);
    m_lValid      -= lAdvance;
    m_llPosition  += lAdvance;
    memmoveInternal((PVOID)m_pbBuffer, (PVOID)(m_pbBuffer + lAdvance), m_lValid);
    ASSERT(m_lValid >= 0);
}


// --- CReaderFromStream implementation ---

CReaderFromStream::CReaderFromStream()
  : m_pStream(NULL)
{
}

CReaderFromStream::~CReaderFromStream()
{
    if (m_pStream) {
	m_pStream->Release();
    }
}

HRESULT CReaderFromStream::Init(IStream *pStream, LONG lBufferSize, LONG lReadSize, BOOL bSeekable)
{
    m_pStream     = pStream;

    /*  Get the file stats */
    /*  Now to get the duration */
    LONGLONG llSize;
    if (bSeekable) {
        STATSTG statstg;
        HRESULT hr = m_pStream->Stat(&statstg, STATFLAG_NONAME);
        if (FAILED(hr)) {
            /*  We take this to mean the stream is not seekable */

            DbgLog((LOG_ERROR, 1, TEXT("Stat failed code 0x%8.8X"), hr));
            return hr;
        }
        llSize = (LONGLONG)statstg.cbSize.QuadPart;
    }

    return CReader::Init(
		    	lBufferSize,
			lReadSize,
			bSeekable,
			llSize);

}

HRESULT
CReaderFromStream::SeekDevice(LONGLONG llPos, LONGLONG* llNewPos)
{
    LARGE_INTEGER liSeekTo;
    ULARGE_INTEGER liNewPosition;
    liSeekTo.QuadPart = llPos;
    ASSERT(llPos >= 0 && llPos < GetSize());
    HRESULT hr = m_pStream->Seek(liSeekTo, STREAM_SEEK_SET, &liNewPosition);

    if (FAILED(hr)) {
	return hr;
    }

    *llNewPos = liNewPosition.QuadPart;
    return S_OK;
}

HRESULT
CReaderFromStream::ReadFromDevice(PVOID p, DWORD length, DWORD* pcbActual)
{
    return m_pStream->Read(p,
			     length,
			     pcbActual);
}


// --- CReaderFromAsync implementation ---

CReaderFromAsync::CReaderFromAsync()
  : m_pReader(NULL)
{
}

CReaderFromAsync::~CReaderFromAsync()
{
    if (m_pReader) {
	m_pReader->Release();
    }
}

HRESULT CReaderFromAsync::Init(IAsyncReader *pReader, LONG lBufferSize, LONG lReadSize, BOOL bSeekable)
{
    m_pReader     = pReader;


    // get the file length
    LONGLONG llSize, llCurrent;
    if (bSeekable) {

	HRESULT hr = m_pReader->Length(&llSize, &llCurrent);

	if (FAILED(hr)) {
	    return hr;
	}
	
	// !!! for now, ignore the current length and wait for the whole
	// lot if necessary
    }

    return CReader::Init(
		    	lBufferSize,
			lReadSize,
			bSeekable,
			llSize);

}

HRESULT
CReaderFromAsync::SeekDevice(LONGLONG llPos, LONGLONG* llNewPos)
{
    // need to keep our own seek pointer since base class refers to the
    // beginning of the buffer
    m_llNextRead = llPos;

    // do nothing to seek now - we will do it on the next read
    *llNewPos = llPos;
    return S_OK;
}


HRESULT
CReaderFromAsync::ReadFromDevice(PVOID p, DWORD length, DWORD* pcbActual)
{

    *pcbActual = 0;

    // check for past eof
    if (m_llNextRead + length >  m_llSize) {

	if (m_llNextRead >= m_llSize) {
	    return S_FALSE;
	}

	length = (DWORD) (m_llSize - m_llNextRead);
    }

    HRESULT hr = m_pReader->SyncRead(
			    	m_llNextRead,
				length,
				(LPBYTE) p);
    if (FAILED(hr)) {
	return hr;
    }

    *pcbActual = length;
    m_llNextRead += length;
    return S_OK;
}


/*
    Return the length of the stream we were given
*/
LONGLONG CReaderFromAsync::GetSize(LONGLONG *pllAvailable)
{
    ASSERT(m_bSeekable);
    if (pllAvailable != NULL) {
        LONGLONG llTotal;
        m_pReader->Length(&llTotal, pllAvailable);
        ASSERT(llTotal == m_llSize);
    }
    return m_llSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\util\code\creg.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

#include <windows.h>
#include <winreg.h>
#include <creg.h>

/*
    Registry access classes :

    CEnumKey
    CEnumValue
*/

CKey::CKey(HKEY hKey,
           LPCTSTR lpszKeyName,
           HRESULT *phr,
           BOOL bCreate,
           REGSAM Access) :
    m_hKey(NULL),
    m_lpszName(m_szName),
    m_dwIndex(0),
    m_cSubKeys(0),
    m_cValues(0)
{
    LONG lRc;
    if (bCreate) {
        lRc = RegCreateKeyEx(hKey,
                             lpszKeyName,
                             0,
                             NULL,
                             0,
                             Access,
                             NULL,
                             &m_hKey,
                             NULL);
    } else {
        lRc = RegOpenKeyEx(hKey,
                           lpszKeyName,
                           0,
                           Access,
                           &m_hKey);
    }
    if (NOERROR == lRc) {
        DWORD dwSecDescLen;      // Bounds checker likes to see this
        FILETIME ft;
        lRc = RegQueryInfoKey(m_hKey,
                        NULL,
                        NULL,
                        NULL,
                        &m_cSubKeys,
                        &m_cbMaxSubkeyLen,
                        NULL,
                        &m_cValues,
                        &m_cbMaxValueNameLen,
                        &m_cbMaxValueLen,
                        &dwSecDescLen,      // just to shut BC up
                        &ft);               // just to shut BC up
        if (NOERROR != lRc) {
	    // shame... but we need the key information to
	    // complete construction correctly...
            RegCloseKey(m_hKey);
            m_hKey = NULL;
        }
    }
    *phr = HRESULT_FROM_WIN32(lRc);
}
CKey::~CKey()
{
    if (m_hKey != NULL) {
        RegCloseKey(m_hKey);
    }
    if (m_lpszName != m_szName) {
        delete [] m_lpszName;
    }
}


CEnumKey::CEnumKey(HKEY hKey,
         LPCTSTR lpszKeyName,
         HRESULT *phr,
         BOOL bCreate,
         REGSAM Access) :
    CKey(hKey, lpszKeyName, phr, bCreate, Access | KEY_ENUMERATE_SUB_KEYS)
{
    if (FAILED(*phr)) {
        return;
    }
    if (m_cbMaxSubkeyLen + 1 > sizeof(m_szName) / sizeof(TCHAR)) {
        m_lpszName = new TCHAR[m_cbMaxSubkeyLen + 1];
        if (m_lpszName == NULL) {
            *phr = E_OUTOFMEMORY;
        }
    }
}
CEnumKey::~CEnumKey()
{
}

BOOL CEnumKey::Next()
{
    /*  Optimize */
    if (m_dwIndex >= m_cSubKeys) {
        return FALSE;
    }
    DWORD cbName = m_cbMaxSubkeyLen + 1;
    LONG lRc = RegEnumKeyEx(m_hKey,
                            m_dwIndex,
                            m_lpszName,
                            &cbName,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (NOERROR == lRc) {
        m_dwIndex++;
        return TRUE;
    }
    return FALSE;
}

CEnumValue::CEnumValue(HKEY hKey,
                       LPCTSTR lpszKeyName,
                       HRESULT *phr,
                       BOOL bCreate,
                       REGSAM Access) :
    CKey(hKey, lpszKeyName, phr, bCreate, Access | KEY_QUERY_VALUE),
    m_lpbData(m_bData),
    m_cbLen(0)
{
    if (FAILED(*phr)) {
        return;
    }
    if (m_cbMaxValueNameLen + 1 > sizeof(m_szName) / sizeof(TCHAR)) {
        m_lpszName = new TCHAR[m_cbMaxValueNameLen + 1];
        if (m_lpszName == NULL) {
            *phr = E_OUTOFMEMORY;
        }
    }
    if (m_cbMaxValueLen > sizeof(m_bData)) {
        m_lpbData = new BYTE[m_cbMaxValueLen];
        if (m_lpbData == NULL) {
            *phr = E_OUTOFMEMORY;
        }
    }
}

CEnumValue::~CEnumValue()
{
    if (m_lpbData != m_bData) {
        delete [] m_lpbData;
    }
}

BOOL CEnumValue::Next()
{
    if (m_dwIndex >= m_cValues) {
        return FALSE;
    }
    DWORD ccNameLen = m_cbMaxValueNameLen + 1;
    m_cbLen = m_cbMaxValueLen;
    LONG lRc = RegEnumValue(m_hKey,
                            m_dwIndex,
                            m_lpszName,
                            &ccNameLen,
                            NULL,
                            &m_dwType,
                            m_lpbData,
                            &m_cbLen);
    if (NOERROR == lRc) {
        m_dwIndex++;
        return TRUE;
    }
    return FALSE;
}

BOOL CEnumValue::Next(DWORD dwType)
{
    while (Next()) {
        if (m_dwType == dwType) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CEnumValue::Read(DWORD dwType, LPCTSTR lpszValueName)
{
    Reset();
    while (Next(dwType)) {
        if (lstrcmpi(lpszValueName, ValueName()) == 0) {
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\core\util\code\ftype.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
    Find the type of a file

*/

#include <windows.h>
#include <uuids.h>
#include <wxdebug.h>
#include <winreg.h>
#include <creg.h>
#include <ftype.h>
#include <comlite.h>
#include <errors.h>


BOOL ValueExists(HKEY hKey, LPCTSTR ValueName);

inline int ReadInt(const TCHAR * &sz)
{
    int i = 0;

    while (*sz && *sz >= TEXT('0') && *sz <= TEXT('9'))
    	i = i*10 + *sz++ - TEXT('0');
    	
    return i;    	
}

/*  Sort out class ids */
#ifdef UNICODE
#define CLSIDFromText CLSIDFromString
#define TextFromGUID2 StringFromGUID2
#else
HRESULT CLSIDFromText(LPCSTR lpsz, LPCLSID pclsid)
{
    WCHAR sz[100];
    if (MultiByteToWideChar(GetACP(), 0, lpsz, -1, sz, 100) == 0) {
        return E_INVALIDARG;
    }
    return QzCLSIDFromString(sz, pclsid);
}
HRESULT TextFromGUID2(REFGUID refguid, LPSTR lpsz, int cbMax)
{
    WCHAR sz[100];

    HRESULT hr = QzStringFromGUID2(refguid, sz, 100);
    if (FAILED(hr)) {
        return hr;
    }
    if (WideCharToMultiByte(GetACP(), 0, sz, -1, lpsz, cbMax, NULL, NULL) == 0) {
        return E_INVALIDARG;
    }
    return S_OK;
}
#endif

/*  Mini class for extracting quadruplets from a string */

// A quadruplet appears to be of the form <offset><length><mask><data>
// with the four fields delimited by a space or a comma with as many extra spaces
// as you please, before or after any comma.
// offset and length appear to be decimal numbers.
// mask and data appear to be hexadecimal numbers.  The number of hex digits in
// mask and data must be double the value of length (so length is bytes).
// mask appears to be allowed to be missing (in which case it must have a comma
// before and after e.g. 0, 4, , 000001B3) A missing mask appear to represent
// a mask which is all FF i.e. 0, 4, FFFFFFFF, 000001B3

class CExtractQuadruplets
{
public:
    CExtractQuadruplets(LPCTSTR lpsz) : m_psz(lpsz), m_pMask(NULL), m_pData(NULL)
    {};
    ~CExtractQuadruplets() { delete [] m_pMask; delete [] m_pData; };


    // This appears to
    BOOL Next()
    {
        StripWhite();
        if (*m_psz == TEXT('\0')) {
            return FALSE;
        }
        /*  Convert offset and length from base 10 tchar */
        m_Offset = ReadInt(m_psz);
        SkipToNext();
        m_Len = ReadInt(m_psz);
        if (m_Len <= 0) {
            return FALSE;
        }
        SkipToNext();

        /*  Allocate space for the mask and data */
        if (m_pMask != NULL) {
            delete [] m_pMask;
            delete [] m_pData;
        }

        m_pMask = new BYTE[m_Len];
        m_pData = new BYTE[m_Len];
        if (m_pMask == NULL || m_pData == NULL) {
            return FALSE;
        }
        /*  Get the mask */
        for (int i = 0; i < m_Len; i++) {
            m_pMask[i] = ToHex();
        }
        SkipToNext();
        /*  Get the data */
        for (i = 0; i < m_Len; i++) {
            m_pData[i] = ToHex();
        }
        SkipToNext();
        return TRUE;
    };
    PBYTE   m_pMask;
    PBYTE   m_pData;
    LONG    m_Len;
    LONG    m_Offset;
private:

    // move m_psz to next non-space
    void StripWhite() { while (*m_psz == TEXT(' ')) m_psz++; };

    // move m_psz past any spaces and up to one comma
    void SkipToNext() { StripWhite();
                        if (*m_psz == TEXT(',')) {
                            m_psz++;
                            StripWhite();
                        }
                      };

    BOOL my_isdigit(TCHAR ch) { return (ch >= TEXT('0') && ch <= TEXT('9')); };
    BOOL my_isxdigit(TCHAR ch) { return my_isdigit(ch) ||
			    (ch >= TEXT('A') && ch <= TEXT('F')) ||
			    (ch >= TEXT('a') && ch <= TEXT('f')); };

    // very limited toupper: we know we're only going to call it on letters
    TCHAR my_toupper(TCHAR ch) { return ch & ~0x20; };



    // This appears to translate FROM hexadecimal characters TO packed binary !!!!!
    // It appears to operate on m_psz which it side-effects past characters it recognises
    // as hexadecimal.  It consumes up to two characters.
    // If it recognises no characters then it returns 0xFF.
    BYTE ToHex()
    {
        BYTE bMask = 0xFF;

        if (my_isxdigit(*m_psz))
        {
            bMask = my_isdigit(*m_psz) ? *m_psz - '0' : my_toupper(*m_psz) - 'A' + 10;

            m_psz++;
            if (my_isxdigit(*m_psz))
            {
                bMask *= 16;
                bMask += my_isdigit(*m_psz) ? *m_psz - '0' : my_toupper(*m_psz) - 'A' + 10;
                m_psz++;
            }
        }
        return bMask;
    }

    LPCTSTR m_psz;
};


/* Compare pExtract->m_Len bytes of hFile at position pExtract->m_Offset
   with the data pExtract->m_Data.
   If the bits which correspond the mask pExtract->m_pMask differ
   then return S_FALSE else return S_OK. failure codes indicate unrecoverrable
   failures.
*/

HRESULT CompareUnderMask(HANDLE hFile, const CExtractQuadruplets *pExtract)
{
    /*  Read the relevant bytes from the file */
    PBYTE pbFileData = new BYTE[pExtract->m_Len];
    if (pbFileData == NULL) {
        return S_FALSE;
    }

    /*  Seek the file and read it */
    if (0xFFFFFFFF == (LONG)SetFilePointer(hFile,
                                           pExtract->m_Offset,
                                           NULL,
                                           pExtract->m_Offset < 0 ?
                                           FILE_END : FILE_BEGIN)) {
        delete pbFileData;
        return S_FALSE;
    }

    /*  Read the file */
    DWORD cbRead;
    BOOL fRead = ReadFile(hFile, pbFileData, (DWORD)pExtract->m_Len, &cbRead, NULL);
    if (!fRead || (LONG)cbRead != pExtract->m_Len)
    {
        delete pbFileData;
        if(!fRead && GetLastError() == ERROR_FILE_OFFLINE)
        {
            // abort if user canceled operation to fetch remote file
            return HRESULT_FROM_WIN32(ERROR_FILE_OFFLINE);
        }
        
        return S_FALSE;
    }

    /*  Now do the comparison */
    for (int i = 0; i < pExtract->m_Len; i++) {
        if (0 != ((pExtract->m_pData[i] ^ pbFileData[i]) &
                  pExtract->m_pMask[i])) {
            delete pbFileData;
            return S_FALSE;
        }
    }

    delete pbFileData;
    return S_OK;
}

/*
    See if a file conforms to a byte string

    hk is an open registry key
    lpszSubKey is the name of a sub key of hk which must hold REG_SZ data of the form
    <offset, length, mask, data>...
    offset and length are decimal numbers, mask and data are hexadecimal.
    a missing mask represents a mask of FF...
    (I'll call this a line of data).
    If there are several quadruplets in the line then the file must match all of them.

    There can be several lines of data, typically with registry names 0, 1 etc
    and the file can match any line.

    The same lpsSubKey should also have a value "Source Filter" giving the
    class id of the source filter.  If there is a match, this is returned in clsid.
    If there is a match but no clsid then clsid is set to CLSID_NULL
*/
HRESULT CheckBytes(HANDLE hFile, HKEY hk, LPCTSTR lpszSubkey, CLSID& clsid)
{
    HRESULT hr;
    CEnumValue EnumV(hk, lpszSubkey, &hr);
    if (FAILED(hr)) {
        return S_FALSE;
    }

    // for each line of data
    while (EnumV.Next(REG_SZ)) {
        /*  The source filter clsid is not a list of compare values */
        if (lstrcmpi(EnumV.ValueName(), SOURCE_VALUE) != 0) {
            DbgLog((LOG_TRACE, 4, TEXT("CheckBytes trying %s"), EnumV.ValueName()));

            /*  Check every quadruplet */
            CExtractQuadruplets Extract = CExtractQuadruplets((LPCTSTR)EnumV.Data());
            BOOL bFound = TRUE;

            // for each quadruplet in the line
            while (Extract.Next()) {
                /*  Compare a particular offset */
                HRESULT hrComp = CompareUnderMask(hFile, &Extract);
                if(FAILED(hrComp)) {
                    return hrComp;
                }
                if (hrComp != S_OK) {
                    bFound = FALSE;
                    break;
                }
            }

            if (bFound) {
                /*  Get the source */
                if (EnumV.Read(REG_SZ, SOURCE_VALUE)) {
                    return SUCCEEDED(CLSIDFromText((LPTSTR)EnumV.Data(),
                                                   &clsid)) ? S_OK : S_FALSE;
                } else {
                    clsid = GUID_NULL;
                    return S_OK;
                }
            }
        }
    }
    return S_FALSE;
}


//  Helper - find the extension (including '.') of a file
//  The extension is the string starting with the final '.'
LPCTSTR FindExtension(LPCTSTR pch)
{
    LPCTSTR pchDot = NULL;
    while (*pch != 0) {
        if (*pch == TEXT('.')) {
            pchDot = pch;
        }
        pch = CharNext(pch);
    }
    //  Avoid nasty things
    if (pch - pchDot > 50) {
        pchDot = NULL;
    }
    return pchDot;
}

// given a URL name, find a class id if possible.
// If the protocol specified has an Extensions key, then search for the
// extension of this file and use that CLSID. If not, look for the
// Source Filter named value which will give the class id.
//
// returns S_OK if found or an error otherwise.
HRESULT
GetURLSource(
    LPCTSTR lpszURL,        // full name
    int cch,                // character count of the protocol up to the colon
    CLSID* clsidSource      // [out] param for clsid.
)
{
    // make a copy of the protocol string from the beginning
    TCHAR* pch = new TCHAR[cch + 1];
    if (NULL == pch) {
        return E_OUTOFMEMORY;
    }
    for (int i = 0; i < cch; i++) {
        pch[i] = lpszURL[i];
    }
    pch[i] = '\0';

    // look in HKCR/<protocol>/
    HRESULT hr = S_OK;
    CEnumValue EnumV(HKEY_CLASSES_ROOT, pch, &hr);
    delete [] pch;

    CLSID clsid;

    if (SUCCEEDED(hr)) {

        // is there an Extensions subkey?
        hr = S_OK;
        CEnumValue eExtensions(EnumV.KeyHandle(), EXTENSIONS_KEY, &hr);
        if (SUCCEEDED(hr)) {

            // Set idx to point to the last dot (or -1 if none)
            LPCTSTR pchDot = FindExtension(lpszURL);

            if (pchDot != NULL) {

                // for each value, compare against current extension
                while (eExtensions.Next()) {
                    if (lstrcmpi(pchDot, eExtensions.ValueName()) == 0) {
                        hr = CLSIDFromText((LPTSTR)eExtensions.Data(),
                                                       &clsid);
                        if (SUCCEEDED(hr)) {
                            if (clsidSource) {
                                *clsidSource = clsid;
                            }
                        }

                        return hr;
                    }
                }
            }

        }

        // specific extension not found -- look for generic
        // source filter for this protocol

        if (EnumV.Read(REG_SZ, SOURCE_VALUE)) {
            hr = CLSIDFromText((LPTSTR)EnumV.Data(),
                                           &clsid);
            if (SUCCEEDED(hr)) {
                if (clsidSource) {
                    *clsidSource = clsid;
                }
                return hr;
            }
        }
    }

    // failed to find protocol reader - try generic URL reader??
    if (cch > 1) { // ignore 1-letter protocols, they're drive letters
	*clsidSource = CLSID_URLReader;
	return S_OK;
    }

    return E_FAIL;
}


//  Helper
BOOL ReadGUID(HKEY hKey, LPCTSTR lpszName, GUID *pGUID)
{
    TCHAR szClsid[50];
    DWORD dwType;
    DWORD dwSize = sizeof(szClsid);
    if (NOERROR == RegQueryValueEx(
                       hKey,
                       lpszName,
                       NULL,
                       &dwType,
                       (PBYTE)szClsid,
                       &dwSize)
        && S_OK == CLSIDFromText(szClsid, pGUID)) {
        return TRUE;
    } else {
        return FALSE;
    }
}
//  Helper
BOOL WriteGUID(HKEY hKey, LPCTSTR lpszName, const GUID *pGUID)
{
    TCHAR szClsid[50];
    TextFromGUID2(*pGUID, szClsid, 50);
    if (NOERROR == RegSetValueEx(
                       hKey,
                       lpszName,
                       0,
                       REG_SZ,
                       (PBYTE)szClsid,
                       sizeof(TCHAR) * (lstrlen(szClsid) + 1))) {
        return TRUE;
    } else {
        return FALSE;
    }
}


/* Get the media type and source filter clsid for a file
   Return S_OK if it succeeds else return an hr such that FAILED(hr)
   in which case the outputs are meaningless.
*/
//
// for URL names that may not be locally readable, find a source filter
// clsid for the given protocol and return that (leaving media type and
// subtype as GUID_NULL).

STDAPI GetMediaTypeFile(LPCTSTR lpszFile,    // [in] filename
                        GUID   *Type,        // [out] type
                        GUID   *Subtype,     // [out] subtype
                        CLSID  *clsidSource) // [out] clsid
{
    HRESULT hr;
    CLSID clsid;

    // search for a protocol name at the beginning of the filename
    // this will be any string (not including a \) that preceeds a :
    const TCHAR* p = lpszFile;
    while(*p && (*p != '\\') && (*p != ':')) {
	p = CharNext(p);
    }
    if (*p == ':') {
	// from lpszFile to p is potentially a protocol name.
	// see if we can find a registry entry for this protocol

	// make a copy of the protocol name string
	int cch = (int)(p - lpszFile);

#ifdef _WIN64
        //  Allow for weird overruns
        if (cch < 0) {
            return E_UNEXPECTED;
        }
#endif

        hr = GetURLSource(lpszFile, cch, clsidSource);
        if (S_OK == hr) {
            *Type = GUID_NULL;
            *Subtype = GUID_NULL;
            return hr;
        }
    }

    // search for extensions
    // Don't do this if clsidSource is not specified as for instance
    // when the source filter itself is trying to determine the type
    // from the checkbytes
    if (clsidSource) {
        const TCHAR *pPeriod = FindExtension(lpszFile);
        if (pPeriod) {
            TCHAR sz[100];
            lstrcpy(sz, TEXT("Media Type\\Extensions\\"));
            lstrcat(sz, pPeriod);
            HKEY hKey;
            if (0 == RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, KEY_READ, &hKey)) {
                BOOL bOK = ReadGUID(hKey, SOURCE_VALUE, clsidSource);
                if (bOK) {
                    *Type = GUID_NULL;
                    *Subtype = GUID_NULL;
                    ReadGUID(hKey, TEXT("Media Type"), Type);
                    ReadGUID(hKey, TEXT("Subtype"), Subtype);
                }
                RegCloseKey(hKey);

                if (bOK) {
                    return S_OK;
                }
            }
        }
    }

    /*  Check we can open the file */
    HANDLE hFile = CreateFile(lpszFile,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        LONG lResult = GetLastError();
        return HRESULT_FROM_WIN32(lResult);
    }

    /*  Now scan the registry looking for a match */
    // The registry looks like
    // ---KEY-----------------  value name    value (<offset, length, mask, data> or filter_clsid )
    // Media Type
    //    {clsid type}
    //        {clsid sub type}  0             4, 4,  , 6d646174
    //                          1             4, 8, FFF0F0F000001FFF , F2F0300000000274
    //                          Source Filter {clsid}
    //        {clsid sub type}  0             4, 4,  , 12345678
    //                          Source Filter {clsid}
    //    {clsid type}
    //        {clsid sub type}  0             0, 4,  , fedcba98
    //                          Source Filter {clsid}


    /*  Step through the types ... */

    CEnumKey EnumType(HKEY_CLASSES_ROOT, MEDIATYPE_KEY, &hr);
    if (FAILED(hr)) {
        CloseHandle(hFile);
        if (hr==HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
            hr = VFW_E_BAD_KEY;  // distinguish key from file
        }
        return hr;
    }

    // for each type
    while (EnumType.Next()) {

        /*  Step through the subtypes ... */
        CEnumKey EnumSubtype(EnumType.KeyHandle(), EnumType.KeyName(), &hr);
        if (FAILED(hr)) {
            CloseHandle(hFile);
            return hr;
        }

        // for each subtype
        while (EnumSubtype.Next()) {
            hr = CheckBytes(hFile,
                            EnumSubtype.KeyHandle(),
                            EnumSubtype.KeyName(),
                            clsid);
            if(hr == S_OK)
            {
                if (SUCCEEDED(CLSIDFromText((LPTSTR)EnumType.KeyName(),
                                            (CLSID *)Type)) &&
                    SUCCEEDED(CLSIDFromText((LPTSTR)EnumSubtype.KeyName(),
                                            (CLSID *)Subtype))) {
                    if (clsidSource != NULL) {
                        *clsidSource = clsid;
                    }
                    CloseHandle(hFile);
                    return S_OK;
                }
            }
            else if(FAILED(hr)) {
                CloseHandle(hFile);
                return hr;
            }
            
            // S_FALSE
        }
    }

    CloseHandle(hFile);

    /*  If we haven't found out the type return a wild card MEDIASUBTYPE_NULL
        and default the async reader as the file source

        The effect of this is that every parser of MEDIATYPE_Stream data
        will get a chance to connect to the output of the async reader
        if it detects its type in the file
    */

    *Type = MEDIATYPE_Stream;
    *Subtype = MEDIASUBTYPE_NULL;
    if (clsidSource != NULL) {
        *clsidSource = CLSID_AsyncReader;
    }
    return S_OK;
}

/*
**    Test if a value exists in a given key
*/

BOOL ValueExists(HKEY hKey, LPCTSTR ValueName)
{
    DWORD Type;

    return ERROR_SUCCESS ==
           RegQueryValueEx(hKey,
                           (LPTSTR)ValueName,
                           NULL,
                           &Type,
                           NULL,
                           NULL);
}

/*  Create the concatenated key name :
    Media Type\{Type clsid}\{Subtype clsid}
    if SubType is NULL we just return the path to the type subkey
*/
HRESULT GetMediaTypePath(const GUID *Type, const GUID *Subtype, LPTSTR psz)
{
    lstrcpy(psz, MEDIATYPE_KEY);
    lstrcat(psz, TEXT("\\"));
    HRESULT hr = TextFromGUID2(*Type, psz + lstrlen(psz), 100);
    if (FAILED(hr)) {
        return hr;
    }
    if (Subtype != NULL) {
        lstrcat(psz, TEXT("\\"));
        hr = TextFromGUID2(*Subtype, psz + lstrlen(psz), 100);
    }
    return hr;
}

/*  Add a media type entry to the registry */

STDAPI SetMediaTypeFile(const GUID *Type,
                        const GUID *Subtype,
                        const CLSID *clsidSource,
                        LPCTSTR lpszMaskAndData,
                        DWORD dwIndex)
{
    HKEY hKey;
    TCHAR sz[200];

    //  If starting on a new one remove the old
    if (dwIndex == 0) {
        DeleteMediaTypeFile(Type, Subtype);
    }
    HRESULT hr = GetMediaTypePath(Type, Subtype, sz);
    if (FAILED(hr)) {
        return hr;
    }
    /*  Check the source is value */
    TCHAR szSource[100];
    if (clsidSource != NULL) {
        hr = TextFromGUID2(*clsidSource, szSource, 100);
        if (FAILED(hr)) {
            return hr;
        }
    }

    /*  Open or create the key */
    LONG lRc = RegCreateKey(HKEY_CLASSES_ROOT, sz, &hKey);
    if (NOERROR != lRc) {
        return HRESULT_FROM_WIN32(lRc);
    }
    TCHAR ValueName[10];
    wsprintf(ValueName, TEXT("%d"), dwIndex);


    /*  Set the value */
    lRc = RegSetValueEx(hKey,
                        ValueName,
                        0,
                        REG_SZ,
                        (LPBYTE)lpszMaskAndData,
                        (lstrlen(lpszMaskAndData) + 1) * sizeof(TCHAR));
    /*  Set the source filter clsid */
    if (NOERROR == lRc && clsidSource != NULL) {
        lRc = RegSetValueEx(hKey,
                            SOURCE_VALUE,
                            0,
                            REG_SZ,
                            (LPBYTE)szSource,
                            (lstrlen(szSource) + 1) * sizeof(TCHAR));
    }
    RegCloseKey(hKey);
    return HRESULT_FROM_WIN32(lRc);
}

STDAPI DeleteMediaTypeFile(const GUID *Type, const GUID *Subtype)
{
    TCHAR sz[200];
    HRESULT hr = GetMediaTypePath(Type, Subtype, sz);
    if (FAILED(hr)) {
        return hr;
    }
    LONG lRc = RegDeleteKey(HKEY_CLASSES_ROOT, sz);
    if (NOERROR != lRc) {
        return HRESULT_FROM_WIN32(lRc);
    }
    /*  Now see if we should delete the key */
    hr = GetMediaTypePath(Type, NULL, sz);
    if (FAILED(hr)) {
        return hr;
    }

    /*  See if there is still a subkey (win95 RegDeleteKey will delete
        all subkeys!)
    */
    if (CEnumKey(HKEY_CLASSES_ROOT, sz, &hr).Next()) {
        return S_OK;
    }

    lRc = RegDeleteKey(HKEY_CLASSES_ROOT, sz);
    return HRESULT_FROM_WIN32(lRc);
}

/*  Register a file extension - must include leading "." */
HRESULT RegisterExtension(LPCTSTR lpszExt, const GUID *Subtype)
{
    HKEY hkey;
    const int cbKey = 200;
    TCHAR szKey[cbKey];
    
    // first assert that our predefined key name can never overrun this buffer 
    // (+ 2 TCHARS for '\', 4 min for extension, 1 for terminator => 7)
    ASSERT( cbKey >= (lstrlen(MEDIATYPE_KEY) + lstrlen(EXTENSIONS_KEY) + 7)); 
    lstrcpy(szKey, MEDIATYPE_KEY TEXT("\\") EXTENSIONS_KEY TEXT("\\"));
    
    // validate that lpszExt won't overrun the buffer
    if( cbKey < (lstrlen(szKey) + lstrlen(lpszExt) + 1))
    {
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }
    
    lstrcat(szKey, lpszExt);
    LONG lRc = RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkey);
    if (NOERROR == lRc) {
        if (WriteGUID(hkey, SOURCE_VALUE, &CLSID_AsyncReader)) {
            WriteGUID(hkey, TEXT("Media Type"), &MEDIATYPE_Stream);
            WriteGUID(hkey, TEXT("Subtype"), Subtype);
        }
        RegCloseKey(hkey);
    }
    return HRESULT_FROM_WIN32(lRc);
}


//  Add a protocol handler
HRESULT AddProtocol(LPCTSTR lpszProtocol, const CLSID *pclsidHandler)
{
    HKEY hkProtocol;

    HRESULT hr = S_OK;
    LONG lRc = RegOpenKey(HKEY_CLASSES_ROOT, lpszProtocol, &hkProtocol);
    if (NOERROR == lRc) {
        if (!WriteGUID(hkProtocol, SOURCE_VALUE, pclsidHandler)) {
            hr = E_ACCESSDENIED;
        }
        RegCloseKey(hkProtocol);
    } else {
        hr = HRESULT_FROM_WIN32(hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvdec\decode.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.

// flags for lFlags in codec capability
#define AM_DVDEC_Full		0x00000001
#define AM_DVDEC_Half		0x00000002
#define AM_DVDEC_Quarter	0x00000004
#define AM_DVDEC_DC	        0x00000008

#define AM_DVDEC_NTSC		0x00000010
#define AM_DVDEC_PAL		0x00000020

// This number includes on the Modes our code supports in it's current state.
// Currently these modes are YUY2 UYVY RGB24 RGB565 RGB555 RGB8 RGB32 ARGB32


#define AM_DVDEC_CSNUM  8               //Increment when adding a new color space below.



#define AM_DVDEC_YUY2		0x00000040
#define AM_DVDEC_UYVY		0x00000080
#define AM_DVDEC_RGB24		0x00000100
#define AM_DVDEC_RGB565		0x00000200
#define AM_DVDEC_RGB555		0x00000400
#define AM_DVDEC_RGB8		0x00000800
#define AM_DVDEC_Y41P		0x00001000
#define AM_DVDEC_RGB32		0X00001100
#define AM_DVDEC_ARGB32         0x00001200


#define AM_DVDEC_DVSD		0x00002000
#define AM_DVDEC_DVHD		0x00004000
#define AM_DVDEC_DVSL		0x00008000

#define AM_DVDEC_DV		0x00010000
#define AM_DVDEC_DVCPRO		0x00020000

#define AM_DVDEC_MMX		0x01000000
#define AM_DVDEC_DR219RGB	0x00100000
		
typedef unsigned long DWORD;



//extern "C" int	__fastcall DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );

extern "C" int __stdcall    DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, long lwidth, char *pMem);
//extern "C" int	__stdcall   DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem,
//					 unsigned int iWidth, unsigned char bFlag);
//extern "C" int	__cdecl DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );


int  InitMem4Decoder(char **ppMem,DWORD dwCodecReq);
void TermMem4Decoder(char *pMem);

DWORD GetCodecCapabilities(  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvdec\dvdec.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
/******************************Module*Header*******************************\
* Module Name: dvdec.cpp
*
* Implements a prototype DV Video AM filter.  
*
\**************************************************************************/
#include <streams.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <stddef.h>
#include <string.h>									    
#include <olectl.h>
#include <dvdmedia.h>       //VIDEOINFOHEADER2

#include "decode.h"
#include "Decprop.h"
#include "dvdec.h"
#include "resource.h"

#ifdef DEBUG
static long glGlobalSentCount = 0;
static long glGlobalRecvdCount = 0;
#endif

BOOL bMMXCPU = FALSE;

// serialize access to the decoder
//
CRITICAL_SECTION g_CritSec;

/***********************************************************************\
* IsMMXCPU
*
* Function to check if the current processor is an MMX processor.
*
\***********************************************************************/
BOOL IsMMXCPU() {
#ifdef _X86_

    //////////////////////////////////////////////////////
    // work around for Cyrix M2 hang (when MMX flag is on)
    // emit cpuid and detect Cyrix M2, if its present, then return FALSE
    // WARNING: This will not work in 64 bit architectures
    __try
    {
        DWORD   s1, s2, s3;     // temporary holders for the vendor name        

        __asm
        {
            // null out eax
            mov eax, 0x00;

            // load opcode CPUID == (0x0FA2)
            _emit 0x0f;
            _emit 0xa2;
            mov s1, ebx;    // copy "Cyri" (backwards)
            mov s2, edx;    // copy "xIns" (backwards)
            mov s3, ecx;    // copy "tead" (backwards)
        }

        DbgLog((LOG_TRACE, 1, TEXT("CPUID Instruction Supported")));

        // check Vendor Id
        if( (s1 == (('i' << 24) | ('r' << 16) | ('y' << 8) | ('C')))
            && (s2 == (('s' << 24) | ('n' << 16) | ('I' << 8) | ('x')))
            && (s3 == (('d' << 24) | ('a' << 16) | ('e' << 8) | ('t'))) )

        {
            DbgLog((LOG_TRACE, 1, TEXT("Cyrix detected")));
            return FALSE;
        }
        else
        {
            // otherwise it's some other vendor and continue with MMX detection
            DbgLog((LOG_TRACE, 1, TEXT("Cyrix not found, reverting to MMX detection")));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // log it and continue on to MMX detection sequence
        DbgLog((LOG_TRACE, 1, TEXT("CPUID instruction not supported, reverting to MMX detection")));
    }
    // END Cyrix M2 detection
    //////////////////////////////////////////////////////


    //
    // If this is an Intel platform we need to make sure that we
    // are running on a machine that supports MMX instructions
    //
    __try {

    __asm _emit 0fh;
    __asm _emit 77h;

    return TRUE;

    }
     __except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
#else

    // Note for IA64: return FALSE. MMX files are not compiled into the 
    // MEI codec libs for IA64
    return FALSE;
#endif
}


#define WRITEOUT(var)  hr = pStream->Write(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;

#define READIN(var)    hr = pStream->Read(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;


// 20( )63(c)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvc ' == MEDIASUBTYPE_dvc 
EXTERN_GUID(MEDIASUBTYPE_dvc,
0x20637664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);


// setup data
const AMOVIESETUP_MEDIATYPE
psudIpPinTypes[] = { { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvsd  }		// clsMinorType
                   , { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvc}		// clsMinorType
		   , { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvhd}		// clsMinorType
		   , { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvsl}		// clsMinorType
		     }; 

const AMOVIESETUP_MEDIATYPE
sudOpPinTypes = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN
psudPins[] = { { L"Input"            // strName
               , FALSE               // bRendered
               , FALSE               // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Output"           // strConnectsToPin
               , 2		     // nTypes, so far, only support dvsd and dvc
               , psudIpPinTypes }    // lpTypes
             , { L"Output"           // strName
               , FALSE               // bRendered
               , TRUE                // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Input"	     // strConnectsToPin
               , 1                   // nTypes
               , &sudOpPinTypes } }; // lpTypes

const AMOVIESETUP_FILTER
sudDVVideo = { &CLSID_DVVideoCodec	// clsID
               , L"DV Video Decoder"	// strName
               , MERIT_PREFERRED        // merit slightly higher than AVI Dec's (resolves 3rd Party DVDec issue), Bug 123862 Millen.
               , 2                      // nPins
               , psudPins };            // lpPin

//* -------------------------------------------------------------------------
//** CDVVideoCodec
//** -------------------------------------------------------------------------
CDVVideoCodec::CDVVideoCodec(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr
    )
    : CVideoTransformFilter(pName, pUnk, CLSID_DVVideoCodec),
    CPersistStream(pUnk, phr),
    m_fStreaming(0),
    m_iDisplay(IDC_DEC360x240),//m_iDisplay(IDC_DEC360x240), //m_iDisplay(IDC_DEC180x120), //m_iDisplay(IDC_DEC88x60),
    m_lPicWidth(360),//360),//180), //88	  
    m_lPicHeight(240), //240),//120),//60	  
    m_lStride(0),
    m_CodecCap(0),
    m_pMem(NULL),
    m_pMemAligned(NULL),
    m_CodecReq(0),
    m_bExamineFirstValidFrameFlag(FALSE),
    m_bQualityControlActiveFlag(FALSE),
    m_iOutX(4),							//Initial default values for Aspect Ratio
	m_iOutY(3),
    m_bRGB219(FALSE)
{
    // try to read previously saved default video settings
    // no need to error check this one
    ReadFromRegistry();

    //get decoder's abilities
    m_CodecCap=GetCodecCapabilities( );


}

CDVVideoCodec::~CDVVideoCodec(     )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::~CDVVideoCodec")));

#ifdef DEBUG
    DbgLog((LOG_TRACE, 1, TEXT("Recvd: %d, Sent: %d"), glGlobalRecvdCount, glGlobalSentCount));
#endif

}


/******************************Private*Routine*****************************\
* ReadFromRegistry
*
* Used to read default value of m_iDisplay from persistent registry
* and set m_lPicWidth and Height accordingly
* if the default doesn't exist, and the settings are not modified
*
* History
* dd-mm-99 - anuragsh - Created
\**************************************************************************/
void
CDVVideoCodec::ReadFromRegistry()
{
    // we know externs regarding SubKey string, and property value from Decprop.h

    HKEY    hKey = NULL;
    DWORD   dwType = REG_DWORD;
    DWORD   dwTempPropDisplay = 0;
    DWORD   dwDataSize = sizeof(dwTempPropDisplay);

    // try to open the key
    if(RegOpenKeyEx(HKEY_CURRENT_USER,
                    szSubKey,
                    0,
                    KEY_READ,
                    &hKey
                    ) != ERROR_SUCCESS)
    {
        return;
    }

    // try to read the value
    if(RegQueryValueEx(hKey,
                        szPropValName,
                        NULL,
                        &dwType,
                        (LPBYTE) &dwTempPropDisplay,
                        &dwDataSize
                        ) != ERROR_SUCCESS)
    {
        return;
    }

    // perform type checking on the data retrieved
    // it must be a DWORD
    if(dwType != REG_DWORD)
    {
        return;
    }

    // set our member variables correctly
    switch (dwTempPropDisplay)
    {
    case IDC_DEC360x240 :
        m_lPicHeight=240;
        m_lPicWidth=360;
        break;
    case IDC_DEC720x480 :
        m_lPicHeight=480;
        m_lPicWidth=720;
        break;
    case IDC_DEC180x120 :
        m_lPicHeight=120;
        m_lPicWidth=180;
        break;
    case IDC_DEC88x60 :
        m_lPicHeight=60;
        m_lPicWidth=88;
       	break;
    default:
        // error case
        return;
    }
    
    // if we are here, then we set m_lPicWidth and m_lPicHeight correctly
    // finally copy m_iDisplay
    m_iDisplay = dwTempPropDisplay;
    
    return;
}



/******************************Public*Routine******************************\
* InitClass
*
* Gets called for our class when the DLL gets loaded and unloaded
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
CDVVideoCodec::InitClass(
    BOOL bLoading,
    const CLSID *clsid
    )
{
    if (bLoading) {
        bMMXCPU = IsMMXCPU();
        InitializeCriticalSection(&g_CritSec);
    } else {
        DeleteCriticalSection(&g_CritSec);
    }

}

/******************************Public*Routine******************************\
* CreateInstance
*
* This goes in the factory template table to create new instances
*
\**************************************************************************/
CUnknown *
CDVVideoCodec::CreateInstance(
    LPUNKNOWN pUnk,
    HRESULT * phr
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::CreateInstance")));
    return new CDVVideoCodec(TEXT("DV Video codec filter"), pUnk, phr);
}


/******************************Public*Routine******************************\
* NonDelegatingQueryInterface
*
* Here we would reveal ISpecifyPropertyPages and IDVVideoDecoder if
* the framework had a property page.
*
\**************************************************************************/
STDMETHODIMP
CDVVideoCodec::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    if (riid == IID_IIPDVDec) {			    //X* talking with property page
        return GetInterface((IIPDVDec *) this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if(riid == IID_IPersistStream)
    {
        return GetInterface((IPersistStream *) this, ppv);
    } else if (riid == IID_IDVRGB219) {
        return GetInterface ((IDVRGB219 *) this, ppv);
    } else {
        return CVideoTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


HRESULT CDVVideoCodec::CheckBufferSizes(IMediaSample * pIn, IMediaSample *pOut)
{
    if ((pIn == NULL) || (pOut == NULL))
    {
        return E_POINTER;
    }


    BYTE * pSrc;
    HRESULT hr = pIn->GetPointer(&pSrc);
    if (FAILED(hr))
    {
         return hr;
    }

    LONG lActual = pIn->GetActualDataLength();
    if(lActual == 0) {
        // app compat for Sonic Foundry. manbugs 67277
        lActual = pIn->GetSize();
    }

    // Make sure we can at least read the NTSC/PAL flag
    if (lActual < 452)
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    // Check Input buffer
    //  Find out whether it is pal or ntsc from the frame.
    pSrc = pSrc + 448;  // Set it to beginning of Video Source Pack
    
    if(*pSrc==0x60)   //*X* check whether this byte is VAUX source pack
	{
		BYTE bPal = (*(pSrc+3)& (0x20))>> 5;

		if (bPal == 0)  
			//NTSC 
		{
			if(lActual < 120000)
			{
				return VFW_E_INVALIDMEDIATYPE;
			}
		}
		else 
			// PAL 
		{
			if(lActual < 144000)
			{
				return VFW_E_INVALIDMEDIATYPE;
			}
		}
	}
	//*X* else the decoder can handle it even this frame contains corrupted data


    // Check Output Buffer.

    if (pOut->GetSize() < (LONG) m_pOutput->CurrentMediaType().GetSampleSize())
    {
        return VFW_E_BUFFER_OVERFLOW;
    }

    return S_OK;
}








/******************************Public*Routine******************************\
* Transform
*
\**************************************************************************/
HRESULT CDVVideoCodec::Transform(IMediaSample * pIn, IMediaSample *pOut)
{
    unsigned char *pSrc, *pDst;
    HRESULT hr = S_OK;

    
    CAutoLock lck(&m_csReceive);

    hr = CheckBufferSizes(pIn, pOut);
    if (FAILED (hr))
    {
       return hr;
    }



    // get  output buffer
    hr = pOut->GetPointer(&pDst);
    if (FAILED(hr)) 
    {
        return hr;
    }
    ASSERT(pDst);
    
    // get the source buffer
    hr = pIn->GetPointer(&pSrc);
    if (FAILED(hr)) 
    {
	return hr;
    }
    ASSERT(pSrc);


    // DVCPRO PAL format discovery
    BYTE    *pBuf = NULL;

    // Do this for the first sample, after
    // StartStreaming() is called
    // if we should examine the first buffer
    // if buffer is valid,
    // and if we could get ptr to buffer's data area
    // and we managed to successfully get a pointer out
    if( (m_bExamineFirstValidFrameFlag)
        && (pIn->GetActualDataLength())
        && (SUCCEEDED(hr = pIn->GetPointer(&pBuf)))
        && (pBuf) )
    {
        // strategy:
        // look in the header of each sequence of the first track
        // for the first valid header check the
        // APT, AP1, AP2, AP3, lowest 3 bits of each
        // they should be "001" in case of DVCPRO
        // and "000" in all other cases
        // if no valid header is found, then look at the next frame
        
        // check to see if we are PAL or NTSC (by looking at DataLength
        const DWORD dwDIFBlockSize = 80;                    // DIF == 80 bytes
        const DWORD dwSeqSize = 150*dwDIFBlockSize;         // 150 DIF blocks per sequence
        DWORD       dwNumSeq = 0;                           // num sequences (10/12 == NTSC/PAL)
        DWORD       dwLen = pIn->GetActualDataLength();

        // detect NTSC/PAL
        if(dwLen == 10*dwSeqSize)
        {
            // NTSC
            dwNumSeq = 10;
        }
        else if(dwLen == 12*dwSeqSize)
        {
            // PAL
            dwNumSeq = 12;
        }
        // if dwLen != NTSC or PAL, then dwNumSeq == 0;

        // run through all the sequences
        for(DWORD i = 0; i < dwNumSeq; i++)
        {
            // make sure DIF ID == Header is valid
            // the first 3 bits should be "000"
            if( ((*pBuf) & 0xE0) == 0 )
            {
                // now check the APT, AP1, AP2, AP3, for DVCPRO signature
                if( ((*(pBuf + 4) & 0x03) == 0x01)       // APT Low 3 bits == "001"
                    && ((*(pBuf + 5) & 0x03) == 0x01)    // AP1 Low 3 bits == "001"
                    && ((*(pBuf + 6) & 0x03) == 0x01)    // AP2 Low 3 bits == "001"
                    && ((*(pBuf + 7) & 0x03) == 0x01) )  // AP3 Low 3 bits == "001"
                {
                    // this is a DVCPRO PAL format, turn on the DVCPRO flag
                    m_CodecReq |= AM_DVDEC_DVCPRO;
                }

                // turn flag off, because we examined a valid header
                m_bExamineFirstValidFrameFlag = FALSE;

                // no need to look at any other sequences or frames
                break;
            }
            
            // otherwise move to the Next Sequence
            pBuf += dwSeqSize;
        }// end for(all sequences)

    }// End DVCPRO detection
    //MEI's version 4.0 requires 440000 bytes memory 


    // ASSERT(m_pMem);
    // *m_pMem = 0;	//(3) 

    // need to serialize access to the decoder, since if you don't, it will crash. Looks like
    // somebody's using a global!
    //
    EnterCriticalSection( &g_CritSec );
    long result = DvDecodeAFrame(pSrc,pDst, m_CodecReq, m_lStride, m_pMemAligned);
    DbgLog((LOG_TRACE, 4, TEXT("m_CodecReq = %x\n"), m_CodecReq));
    LeaveCriticalSection( &g_CritSec );

    //m_lStride: positive is DirectDraw, negative is DIB
    if( result != S_OK )
	return E_FAIL;

    // DIBSIZE() might only work for RGB and we can output YUV
    LPBITMAPINFOHEADER lpbiDst ;
	if (!m_bUseVideoInfo2)
		lpbiDst = HEADER(m_pOutput->CurrentMediaType().Format());
	else
	{
		VIDEOINFOHEADER2 * pvi2 = (VIDEOINFOHEADER2 * )m_pOutput->CurrentMediaType().Format();
		lpbiDst =& (pvi2->bmiHeader);
	}

    // deal with alpha bits
    //
    if( *m_pOutput->CurrentMediaType( ).Subtype( ) == MEDIASUBTYPE_ARGB32 )
    {
        RGBQUAD * pDstQuad = (RGBQUAD*) pDst;

        for( long i = lpbiDst->biSizeImage / sizeof( RGBQUAD ) ; i > 0 ; i-- )
        {
            pDstQuad->rgbReserved = 255;
            pDstQuad++;
        }
    }

    pOut->SetActualDataLength(lpbiDst->biSizeImage);

    return hr;
}


/******************************Public*Routine******************************\
* Receive
*
\**************************************************************************/
HRESULT CDVVideoCodec::Receive(IMediaSample *pSample)
{
    // If the next filter downstream is the video renderer, then it may
    // be able to operate in DirectDraw mode which saves copying the data
    // and gives higher performance.  In that case the buffer which we
    // get from GetDeliveryBuffer will be a DirectDraw buffer, and
    // drawing into this buffer draws directly onto the display surface.
    // This means that any waiting for the correct time to draw occurs
    // during GetDeliveryBuffer, and that once the buffer is given to us
    // the video renderer will count it in its statistics as a frame drawn.
    // This means that any decision to drop the frame must be taken before
    // calling GetDeliveryBuffer.
    
    ASSERT(CritCheckIn(&m_csReceive));

#ifdef DEBUG
    glGlobalRecvdCount++;
    DbgLog((LOG_TRACE,1,TEXT("--------RECEIVED SAMPLE")));
#endif

    AM_MEDIA_TYPE *pmtOut, *pmt;
#ifdef DEBUG
    FOURCCMap fccOut;
#endif
    HRESULT hr;
    ASSERT(pSample);
    IMediaSample * pOutSample;

    // If no output pin to deliver to then no point sending us data
    ASSERT (m_pOutput != NULL) ;

    //ShouldSkipFrame(pSample)
    REFERENCE_TIME trStart, trStopAt;
    pSample->GetTime(&trStart, &trStopAt);
    int itrFrame = (int)(trStopAt - trStart);	//frame duration

    m_bSkipping =FALSE;
    // only drop frames if Quality Control is going on.
    if ( (m_bQualityControlActiveFlag) && (  m_itrLate > ( itrFrame - m_itrAvgDecode  ) ) )
    {
        MSR_NOTE(m_idSkip);
        m_bSampleSkipped = TRUE;
	m_bSkipping =TRUE;

        m_itrLate = m_itrLate - itrFrame;
    
	MSR_INTEGER(m_idLate, (int)m_itrLate/10000 ); // Note how late we think we are
	if (!m_bQualityChanged) {
            m_bQualityChanged = TRUE;
            NotifyEvent(EC_QUALITY_CHANGE,0,0);
        }

        DbgLog((LOG_TRACE,1,TEXT("--------DROPPED SAMPLE (Quality Control)")));

        return NOERROR;
    }


    // Set up the output sample
    hr = InitializeOutputSample(pSample, &pOutSample);

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,1,TEXT("--------DROPPED SAMPLE (Couldn't init output sample")));
        return hr;
    }

    m_bSampleSkipped = FALSE;


    // The source filter may dynamically ask us to start transforming from a
    // different media type than the one we're using now.  If we don't, we'll
    // draw garbage. (typically, this is a palette change in the movie,
    // but could be something more sinister like the compression type changing,
    // or even the video size changing)

#define rcS1 ((VIDEOINFOHEADER *)(pmt->pbFormat))->rcSource
#define rcT1 ((VIDEOINFOHEADER *)(pmt->pbFormat))->rcTarget

    pSample->GetMediaType(&pmt);
    if (pmt != NULL && pmt->pbFormat != NULL) {

	// spew some debug output
	ASSERT(!IsEqualGUID(pmt->majortype, GUID_NULL));
#ifdef DEBUG
        fccOut.SetFOURCC(&pmt->subtype);
	LONG lCompression = HEADER(pmt->pbFormat)->biCompression;
	LONG lBitCount = HEADER(pmt->pbFormat)->biBitCount;
	LONG lStride = (HEADER(pmt->pbFormat)->biWidth * lBitCount + 7) / 8;
	lStride = (lStride + 3) & ~3;
        DbgLog((LOG_TRACE,3,TEXT("*Changing input type on the fly to")));
        DbgLog((LOG_TRACE,3,TEXT("FourCC: %lx Compression: %lx BitCount: %ld"),
		fccOut.GetFOURCC(), lCompression, lBitCount));
        DbgLog((LOG_TRACE,3,TEXT("biHeight: %ld rcDst: (%ld, %ld, %ld, %ld)"),
		HEADER(pmt->pbFormat)->biHeight,
		rcT1.left, rcT1.top, rcT1.right, rcT1.bottom));
        DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld) Stride: %ld"),
		rcS1.left, rcS1.top, rcS1.right, rcS1.bottom,
		lStride));
#endif

	// now switch to using the new format.  I am assuming that the
	// derived filter will do the right thing when its media type is
	// switched and streaming is restarted.

        // DANGER DANGER - we've already called GetBuffer here so we
        // have the win16 lock - so we have to be VERY careful what we
        // do in StopStreaming

	StopStreaming();
	m_pInput->CurrentMediaType() = *pmt;
	DeleteMediaType(pmt);
	// not much we can do if this fails
	hr = StartStreaming();
    }

    // The renderer may ask us to on-the-fly to start transforming to a
    // different format.  If we don't obey it, we'll draw garbage

    pOutSample->GetMediaType(&pmtOut);
    if (pmtOut != NULL && pmtOut->pbFormat != NULL) {
        ASSERT(pmtOut->formattype!=FORMAT_None);
        m_bUseVideoInfo2 =  (pmtOut->formattype == FORMAT_VideoInfo2);
       
	// spew some debug output
	ASSERT(!IsEqualGUID(pmtOut->majortype, GUID_NULL));
#ifdef DEBUG
		// Different debug output according to whether we are using VIDEOINFOHEADER2 or VIDEOINFOHEADER
		// with the output pin
		VIDEOINFOHEADER *  pVIout = NULL;
		VIDEOINFOHEADER2 * pVIout2 = NULL;
		if (m_bUseVideoInfo2)
			pVIout2 = (VIDEOINFOHEADER2 *) pmtOut->pbFormat;
		else
			pVIout = (VIDEOINFOHEADER *) pmtOut->pbFormat;

		fccOut.SetFOURCC(&pmtOut->subtype);
		LONG lCompression = HEADER(pmtOut->pbFormat)->biCompression;
		LONG lBitCount = HEADER(pmtOut->pbFormat)->biBitCount;
		LONG lStride = (HEADER(pmtOut->pbFormat)->biWidth * lBitCount + 7) / 8;
		lStride = (lStride + 3) & ~3;
		DbgLog((LOG_TRACE,3,TEXT("*Changing output type on the fly to")));
		DbgLog((LOG_TRACE,3,TEXT("FourCC: %lx Compression: %lx BitCount: %ld"),
		fccOut.GetFOURCC(), lCompression, lBitCount));
		if (m_bUseVideoInfo2)
		{
			DbgLog((LOG_TRACE,3,TEXT("biHeight: %ld rcDst: (%ld, %ld, %ld, %ld)"),
				HEADER(pmtOut->pbFormat)->biHeight,
				pVIout2->rcTarget.left, pVIout2->rcTarget.top, pVIout2->rcTarget.right,
				pVIout2->rcTarget.bottom));
			DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld) Stride: %ld"),
				pVIout2->rcSource.left, pVIout2->rcSource.top, pVIout2->rcSource.right, 
				pVIout2->rcSource.bottom,lStride));
			DbgLog ((LOG_TRACE, 3, TEXT("Aspect Ratio: %d:%d"), pVIout2->dwPictAspectRatioX,
					pVIout2->dwPictAspectRatioY));
		}
		else
		{
			DbgLog((LOG_TRACE,3,TEXT("biHeight: %ld rcDst: (%ld, %ld, %ld, %ld)"),
				HEADER(pmtOut->pbFormat)->biHeight,
				pVIout->rcTarget.left, pVIout->rcTarget.top, pVIout->rcTarget.right,
				pVIout->rcTarget.bottom));
			DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld) Stride: %ld"),
				pVIout->rcSource.left, pVIout->rcSource.top, pVIout->rcSource.right, 
				pVIout->rcSource.bottom,lStride));
		
		}
#endif

	// now switch to using the new format.  I am assuming that the
	// derived filter will do the right thing when its media type is
	// switched and streaming is restarted.

	StopStreaming();
	m_pOutput->CurrentMediaType() = *pmtOut;
	DeleteMediaType(pmtOut);
	hr = StartStreaming();

	if (SUCCEEDED(hr)) {
 	    // a new format, means a new empty buffer, so wait for a keyframe
	    // before passing anything on to the renderer.
	    // !!! a keyframe may never come, so give up after 30 frames
            DbgLog((LOG_TRACE,3,TEXT("Output format change means we must wait for a keyframe")));
	    m_nWaitForKey = 30;
	}
    }

    // Start timing the transform (and log it if PERF is defined)

    if (SUCCEEDED(hr)) {

        		//Check for Aspect Ratio Changes
	

		if (m_bUseVideoInfo2)

		{	
			unsigned char *pSrc;
			hr = pSample->GetPointer(&pSrc);
			if (FAILED (hr))
            {   pOutSample->Release();
				return hr;
            }

			BYTE	bDisp, bBcsys;
			//Check Aspect Ratio
			BYTE * pSearch = NULL;
			pSearch = pSrc + 453;			//Location of the VAUX source control block in the frame   
			if (*pSearch == 0x061)
			{
				//Get the DISP	and BCSYS  fields from the VAUX
				DbgLog((LOG_TRACE,3,TEXT("Found the VAUX source control structure")));
				bDisp = *(pSearch+2) & 0x07;
				bBcsys= *(pSearch+3) & 0x03;

				DbgLog((LOG_TRACE,3,TEXT("BCSYS = %d   DISP = %d"),bBcsys,bDisp));
			
				//Compute the aspect ratio of frame
				int iFramex=0;
				int iFramey=0;
				switch (bBcsys)
				{
				case 0:
					switch (bDisp)
					{
					case 0:
						iFramex = 4;
						iFramey = 3;
						break;
					case 1:
					case 2:
						iFramex = 16;
						iFramey = 9;
						break;
					}
					break;
				case 1:
					switch (bDisp)
					{
					case 0:
						iFramex = 4;
						iFramey = 3;
						break;
					case 1:
					case 2:
					case 6:
						iFramex = 14;
						iFramey = 9;
						break;
					case 3:
					case 4:
					case 5:
					case 7:
						iFramex = 16;
						iFramey = 9;
						break;
					}
					break;

				}

				// Compare to the Aspect Ratio we are currently using and if different 
				// set aspect ratio to new value
				if (iFramex != 0)  //Means we were able to compute the Aspect Ratio
				{
					if ((iFramex != m_iOutX) || (iFramey != m_iOutY))   //Aspect Ratio has changed
					{
						//Set Aspect Ratio to new values
						m_iOutX = iFramex;
						m_iOutY = iFramey;
						
                        //Create the new media type structure
						AM_MEDIA_TYPE  Newmt ;
					
						CopyMediaType(&Newmt, (AM_MEDIA_TYPE *)&m_pOutput->CurrentMediaType());
						VIDEOINFOHEADER2 * pvi2 = (VIDEOINFOHEADER2 *)Newmt.pbFormat;
						pvi2->dwPictAspectRatioX = iFramex;
						pvi2->dwPictAspectRatioY = iFramey;
						
						
						IPinConnection * iPC;
                        IPin * pInput = m_pOutput->GetConnected();
                        
                        if (pInput)
                        {
						    hr = pInput->QueryInterface(IID_IPinConnection, (void **)&iPC);
						    if (SUCCEEDED (hr))
						    {   
							    hr = iPC->DynamicQueryAccept(&Newmt);
							    if (SUCCEEDED (hr))
								    pOutSample->SetMediaType(&Newmt);
													
							    iPC->Release();
						    }
                        }
						
						FreeMediaType(Newmt);
						
                   }
				}
			
			}
		}


        m_tDecodeStart = timeGetTime();
        MSR_START(m_idTransform);

        // have the derived class transform the data
        hr = Transform(pSample, pOutSample);

        // Stop the clock (and log it if PERF is defined)
        MSR_STOP(m_idTransform);
        m_tDecodeStart = timeGetTime()-m_tDecodeStart;
        m_itrAvgDecode = m_tDecodeStart*(10000/16) + 15*(m_itrAvgDecode/16);

        // Maybe we're waiting for a keyframe still?
        if (m_nWaitForKey)
            m_nWaitForKey--;
        if (m_nWaitForKey && pSample->IsSyncPoint() == S_OK)
	    m_nWaitForKey = FALSE;

        // if so, then we don't want to pass this on to the renderer
        if (m_nWaitForKey && hr == NOERROR) {
            DbgLog((LOG_TRACE,3,TEXT("still waiting for a keyframe")));
	    hr = S_FALSE;
	}
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,1,TEXT("--------DROPPED SAMPLE (Bad failure from Transform())")));
        DbgLog((LOG_TRACE,4,TEXT("Error from video transform")));
    }
    else
    {
        // the Transform() function can return S_FALSE to indicate that the
        // sample should not be delivered; we only deliver the sample if it's
        // really S_OK (same as NOERROR, of course.)
        // Try not to return S_FALSE to a direct draw buffer (it's wasteful)
        // Try to take the decision earlier - before you get it.

        if (hr == NOERROR)
        {
#ifdef DEBUG
            glGlobalSentCount++;
            DbgLog((LOG_TRACE,1,TEXT("--------SENT SAMPLE")));
#endif

    	    hr = m_pOutput->Deliver(pOutSample);

            if(FAILED(hr))
            {
	            DbgLog((LOG_TRACE,1,TEXT("--------SEND SAMPLE FAILED******")));
            }
        }
        else
        {
            DbgLog((LOG_TRACE,1,TEXT("--------DROPPED SAMPLE (S_FALSE from Transform())")));

            // S_FALSE returned from Transform is a PRIVATE agreement
            // We should return NOERROR from Receive() in this case because returning S_FALSE
            // from Receive() means that this is the end of the stream and no more data should
            // be sent.
            if (S_FALSE == hr)
            {
                //  We must Release() the sample before doing anything
                //  like calling the filter graph because having the
                //  sample means we may have the DirectDraw lock
                //  (== win16 lock on some versions)
                pOutSample->Release();
                m_bSampleSkipped = TRUE;

                if (!m_bQualityChanged)
                {
                    m_bQualityChanged = TRUE;
                    NotifyEvent(EC_QUALITY_CHANGE,0,0);
                }
                return NOERROR;
            }
        }
    }

    // release the output buffer. If the connected pin still needs it,
    // it will have addrefed it itself.
    pOutSample->Release();
    ASSERT(CritCheckIn(&m_csReceive));

    return hr;
}


/******************************Public*Routine******************************\
* CheckInputType
* TYPE:	    MEDIATYPE_Video
* SubType:  MEDIASUBTYPE_dvsd or MEDIASUBTYPE_dvhd or MEDIASUBTYPE_dvsl 
* FORMAT:   1.FORMAT_DvInfo (32 bytes DVINFO structure)
*	    2.FORMAT_VideoInfo
*		a. VIDEOINFO( does not contain DVINFO)
*		b. VIDEOINFO( contains DVINFO)
* is called by the CheckMediaType member function of the input pin to determine 
* whether the proposed media type is acceptable
\**************************************************************************/

HRESULT
CDVVideoCodec::CheckInputType(   const CMediaType* pmtIn    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::CheckInputType")));

    //
    //  Check for DV video streams
    //
    if (    (*pmtIn->Type()	== MEDIATYPE_Video)	&&
        (   (*pmtIn->Subtype()	== MEDIASUBTYPE_dvsd)	||
	    (*pmtIn->Subtype()	== MEDIASUBTYPE_dvc)	||
	    (*pmtIn->Subtype()	== MEDIASUBTYPE_dvhd)	||
 	   (*pmtIn->Subtype()	== MEDIASUBTYPE_dvsl) )  ) 
    {
       if(   (*pmtIn->FormatType() == FORMAT_VideoInfo ) )
       {

	 if (pmtIn->cbFormat < 0x20 ) //sizeof(BITMAPHEADER) )	    //SIZE_VIDEOHEADER  )
		return E_INVALIDARG;
       }
	
	if ( *pmtIn->Subtype()	== MEDIASUBTYPE_dvsd ||
                *pmtIn->Subtype()	== MEDIASUBTYPE_dvc) 
	{
	    if( !( m_CodecCap & AM_DVDEC_DVSD ) )
		return 	E_INVALIDARG;

	}
	else
	{
	    if ( *pmtIn->Subtype()	== MEDIASUBTYPE_dvhd) 
	    {
		if( !( m_CodecCap & AM_DVDEC_DVHD ) )
		    return 	E_INVALIDARG;
	    }
	    else if ( *pmtIn->Subtype()	== MEDIASUBTYPE_dvsl) 
	    {
		if( !( m_CodecCap & AM_DVDEC_DVSL ) )
		    return 	E_INVALIDARG;
	    }
	}

   }
   else
	return E_INVALIDARG;
 
   return S_OK;
}


/******************************Public*Routine******************************\
* CheckTransform				       
\**************************************************************************/
HRESULT
CDVVideoCodec::CheckTransform(
    const CMediaType* pmtIn,
    const CMediaType* pmtOut
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::CheckTransform")));


    // we only accept Video as  toplevel type.
    if ( (*pmtOut->Type() != MEDIATYPE_Video) && 
	 (*pmtIn->Type() != MEDIATYPE_Video) ) 
    {
        DbgLog((LOG_TRACE,4,TEXT("Output Major type %s"),GuidNames[*pmtOut->Type()]));
	DbgLog((LOG_TRACE,4,TEXT("Input Major type %s"),GuidNames[*pmtIn->Type()]));
	return E_INVALIDARG;
    }


    GUID guid=*pmtOut->Subtype();
    



    //check output subtype()

    if (guid == MEDIASUBTYPE_UYVY)
    {
         m_CodecReq |= AM_DVDEC_UYVY;
    }
    else if (guid == MEDIASUBTYPE_YUY2)
    {
        m_CodecReq |= AM_DVDEC_YUY2; 
    }
    else if (guid == MEDIASUBTYPE_RGB565)
    {
        m_CodecReq |= AM_DVDEC_RGB565;
    }
    else if (guid == MEDIASUBTYPE_RGB555)
    {
        m_CodecReq |= AM_DVDEC_RGB555; 
    }
    else if (guid == MEDIASUBTYPE_RGB24)
    {
        m_CodecReq |= AM_DVDEC_RGB24; 
    }
    else if (guid == MEDIASUBTYPE_RGB32)
    {
        m_CodecReq |= AM_DVDEC_RGB32;
    }
    else if (guid == MEDIASUBTYPE_ARGB32)
    {
        m_CodecReq |= AM_DVDEC_RGB32;
    }
    else if (guid == MEDIASUBTYPE_RGB8)
    {
         m_CodecReq |= AM_DVDEC_RGB8; 
    }
    else
    {
        DbgLog((LOG_TRACE,4,TEXT("subtype is wrong %s")));
		return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER or VIDEOINFOHEADER2 type
    if ((*pmtOut->FormatType() != FORMAT_VideoInfo) && 
		(*pmtOut->FormatType() != FORMAT_VideoInfo2))
	{
        DbgLog((LOG_TRACE,4,TEXT("Output formate is not videoinfo")));
	return E_INVALIDARG;
    }

    if ( (*pmtIn->FormatType() != FORMAT_VideoInfo) &&
	 (*pmtIn->FormatType() != FORMAT_DvInfo)  )
    {
        DbgLog((LOG_TRACE,4,TEXT("input formate is neither videoinfo no DVinfo")));
	return E_INVALIDARG;
    }

   
    ASSERT(pmtOut->Format());
    long biHeight, biWidth;
    
    
    //NTSC or PAL
    //get input format
    bool IsNTSC;
    VIDEOINFO * InVidInfo = (VIDEOINFO*) pmtIn->Format();
    LPBITMAPINFOHEADER lpbi = HEADER(InVidInfo);
    
    if( (lpbi->biHeight== 480) || (lpbi->biHeight== 240) ||(lpbi->biHeight== 120) || (lpbi->biHeight== 60) )
    {
        IsNTSC = TRUE;
	}
    else  if( (lpbi->biHeight== 576) || (lpbi->biHeight== 288) ||(lpbi->biHeight== 144) || (lpbi->biHeight== 72) )
    {
        IsNTSC = FALSE;
    }
	  else
	      return E_FAIL; 


	if (*pmtOut->FormatType() == FORMAT_VideoInfo2)
	{
		VIDEOINFOHEADER2 * pVidInfo2 = (VIDEOINFOHEADER2*) pmtOut->Format();
		
		//if rcSource is not empty, it must be the same as rcTarget, otherwise, FAIL
		if (!IsRectEmpty(&pVidInfo2->rcSource ))
		{
           if (     pVidInfo2->rcSource.left   !=  pVidInfo2->rcTarget.left
                ||  pVidInfo2->rcSource.top    !=  pVidInfo2->rcTarget.top
				||  pVidInfo2->rcSource.right  !=  pVidInfo2->rcTarget.right
                ||  pVidInfo2->rcSource.bottom !=  pVidInfo2->rcTarget.bottom ) 

            return VFW_E_INVALIDMEDIATYPE;
		}


    // if rcTarget is not empty, use its dimensions instead of biWidth and biHeight,
    // to see if it's an acceptable size.  Then use biWidth as the stride.  
    // Also, make sure biWidth and biHeight are bigger than the rcTarget size.
		if (!IsRectEmpty(&pVidInfo2->rcTarget) )
		{
			if(     abs(pVidInfo2->bmiHeader.biHeight) < abs(pVidInfo2->rcTarget.bottom-pVidInfo2->rcTarget.top)        
				||  abs(pVidInfo2->bmiHeader.biWidth) < abs(pVidInfo2->rcTarget.right-pVidInfo2->rcTarget.left) )
				return VFW_E_INVALIDMEDIATYPE;
			 else
			{
				biHeight=abs(pVidInfo2->rcTarget.bottom-pVidInfo2->rcTarget.top);
				biWidth=abs(pVidInfo2->rcTarget.right-pVidInfo2->rcTarget.left);
			}
		}
		else
		{
			biHeight=abs(pVidInfo2->bmiHeader.biHeight);
			biWidth=pVidInfo2->bmiHeader.biWidth;
		}

	}
	else
	{
		VIDEOINFOHEADER * pVidInfo = (VIDEOINFOHEADER*) pmtOut->Format();
		
		//if rcSource is not empty, it must be the same as rcTarget, otherwise, FAIL
		if (!IsRectEmpty(&pVidInfo->rcSource ))
		{
           if (     pVidInfo->rcSource.left   !=  pVidInfo->rcTarget.left
                ||  pVidInfo->rcSource.top    !=  pVidInfo->rcTarget.top
				||  pVidInfo->rcSource.right  !=  pVidInfo->rcTarget.right
                ||  pVidInfo->rcSource.bottom !=  pVidInfo->rcTarget.bottom ) 

            return VFW_E_INVALIDMEDIATYPE;
		}


    // if rcTarget is not empty, use its dimensions instead of biWidth and biHeight,
    // to see if it's an acceptable size.  Then use biWidth as the stride.  
    // Also, make sure biWidth and biHeight are bigger than the rcTarget size.
		if (!IsRectEmpty(&pVidInfo->rcTarget) )
		{
			if(     abs(pVidInfo->bmiHeader.biHeight) < abs(pVidInfo->rcTarget.bottom-pVidInfo->rcTarget.top)        
				||  abs(pVidInfo->bmiHeader.biWidth) < abs(pVidInfo->rcTarget.right-pVidInfo->rcTarget.left) )
				return VFW_E_INVALIDMEDIATYPE;
			 else
			{
				biHeight=abs(pVidInfo->rcTarget.bottom-pVidInfo->rcTarget.top);
				biWidth=abs(pVidInfo->rcTarget.right-pVidInfo->rcTarget.left);
			}
		}
		else
		{
			biHeight=abs(pVidInfo->bmiHeader.biHeight);
			biWidth=pVidInfo->bmiHeader.biWidth;
		}
	}
    
    
   
    //check down stream filter's require height and width
    if(   (IsNTSC &&(biHeight ==480 )) || (!IsNTSC &&(biHeight ==576)) )
    {
	if ( (biWidth !=720) || (!(m_CodecCap & AM_DVDEC_Full) ) )		
        {
            DbgLog((LOG_TRACE,4,TEXT("Format biWidth F W=%d, H=%d"),biWidth,biHeight));
	    return VFW_E_TYPE_NOT_ACCEPTED;
        }

    }
    else if(   (IsNTSC &&(biHeight ==240 )) || (!IsNTSC &&(biHeight ==288)) )
    {
	if ( (biWidth !=360) ||( !(m_CodecCap & AM_DVDEC_Half) )	)		
        {
            DbgLog((LOG_TRACE,4,TEXT("Format biWidth H W=%d,H=%d"),biWidth,biHeight));
	    return VFW_E_TYPE_NOT_ACCEPTED;
        }

    }
    else if(   (IsNTSC &&(biHeight ==120 )) || (!IsNTSC &&(biHeight ==144)) )
    {
	if ( (biWidth != 180) || ( !(m_CodecCap & AM_DVDEC_Quarter) ) )		
        {
	    DbgLog((LOG_TRACE,4,TEXT("Format biWidth Q W=%d,H=%d"),biWidth,biHeight));
	    return VFW_E_TYPE_NOT_ACCEPTED;
        }
	
    }
    else if( (   (IsNTSC &&(biHeight ==60 )) || (!IsNTSC &&(biHeight ==72)) ) )
    {
	if ( (biWidth != 88) || ( !(m_CodecCap & AM_DVDEC_DC) )	)		
        {
            DbgLog((LOG_TRACE,4,TEXT("Format biWidth E W=%d, H=%d"),biWidth,biHeight));
	    return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
    else
    {
        DbgLog((LOG_TRACE,4,TEXT("Format biWidth EE W=%d,H=%d"),biWidth,biHeight));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::CheckTransform, OK")));
   
    return S_OK;
}


/******************************Public*Routine******************************\
* SetMediaType
*
* Overriden to know when the media type is actually set
*
\**************************************************************************/
HRESULT
CDVVideoCodec::SetMediaType(   PIN_DIRECTION direction, const CMediaType *pmt    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::SetMediaType")));

    if (direction == PINDIR_INPUT) 
    {
	ASSERT( (*pmt->Subtype() == MEDIASUBTYPE_dvsd)  ||
		(*pmt->Subtype() == MEDIASUBTYPE_dvc)  ||
		(*pmt->Subtype() == MEDIASUBTYPE_dvhd)  ||
		(*pmt->Subtype() == MEDIASUBTYPE_dvsl)	);

	//if input video changed from PAL to NTSC, or NTSC to PAL
	// 1> reset m_lPicHeight 
	// 2> reconnect the output pin if the output pin is connected
	VIDEOINFO *InVidInfo = (VIDEOINFO *)pmt->Format();
	LPBITMAPINFOHEADER lpbi = HEADER(InVidInfo);
	BOOL fChanged=FALSE;
    	if( (lpbi->biHeight== 480) || (lpbi->biHeight== 240) ||(lpbi->biHeight== 120) || (lpbi->biHeight== 60) )
	{   
	    //PAL to NTSC changed
	    if ( m_lPicHeight!= 480 && m_lPicHeight!= 240 && m_lPicHeight!= 120 && m_lPicHeight!= 60)
	    {
		switch (m_iDisplay)
		{
		case IDC_DEC360x240 :
		    m_lPicHeight=240;
		    break;
		case IDC_DEC720x480 :
		    m_lPicHeight=480;
    		    break;
		case IDC_DEC180x120 :
		    m_lPicHeight=120;
		    break;
		case IDC_DEC88x60 :
		    m_lPicHeight=60;
       		    break;
		default:
		    break;
		}
		fChanged=TRUE;
	    }
	}
	else  if( (lpbi->biHeight== 576) || (lpbi->biHeight== 288) ||(lpbi->biHeight== 144) || (lpbi->biHeight== 72) )
	{
	    //NTSC to PAL changed
	    if ( m_lPicHeight!= 576 && m_lPicHeight!= 288 &&  m_lPicHeight!= 144 && m_lPicHeight!= 72 )
	    {
		switch (m_iDisplay)
		{
		case IDC_DEC360x240 :
		    m_lPicHeight=288;
		    break;
		case IDC_DEC720x480 :
		    m_lPicHeight=576;
    		    break;
		case IDC_DEC180x120 :
		    m_lPicHeight=144;
		    break;
		case IDC_DEC88x60 :
		    m_lPicHeight=72;
       		    break;
		default:
		    break;
		}
		fChanged=TRUE;
	    }
	}
	else
	    return VFW_E_INVALIDMEDIATYPE; 
   
	if( fChanged ==TRUE && m_pOutput->IsConnected() )
	    m_pGraph->Reconnect( m_pOutput );

    }
    else   //output direction
	{
		if (*pmt->FormatType() == FORMAT_VideoInfo2)
			m_bUseVideoInfo2 = TRUE;
		else m_bUseVideoInfo2 = FALSE;
	}
      
    return  CVideoTransformFilter::SetMediaType( direction,pmt    );
}


/******************************Public*Routine******************************\
* GetMediaType
*
* Return our preferred output media types (in order)
*
\**************************************************************************/
HRESULT
CDVVideoCodec::GetMediaType( int iPosition,  CMediaType *pmt )
{
    BOOL bUseVideoInfo2;
    VIDEOINFO   *pVideoInfo;
    CMediaType  cmt;

    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::GetMediaType")));

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    //
    // We copy the proposed output format so that we can play around with
    // it all we like and still leave the original preferred format
    // untouched.  We try each of the known BITMAPINFO types in turn
    // starting off with the best quality moving through to the worst
    // (palettised) format
    //

    //X* get current media type from input pin
    cmt = m_pInput->CurrentMediaType();

    if ( (*cmt.Type() != MEDIATYPE_Video)  ||  ((*cmt.Subtype() != MEDIASUBTYPE_dvsd) &&
                                                (*cmt.Subtype() != MEDIASUBTYPE_dvc)))
    	return VFW_S_NO_MORE_ITEMS;
    

   
   // Determine if we are currently looking at the VIDEOINFOHEADER2 modes or the VIDEOINFO modes
   // so if iPosition is in the first cModeCounter videomodes that means that it is using the 
   // VIDEOINFOHEADER2.  if it is greater than that it is either using the VIDEOINFO mode or 
   // it is an incorrect value
   if ( iPosition < AM_DVDEC_CSNUM )
	   bUseVideoInfo2 = TRUE;
   else
   {
	   iPosition = iPosition - AM_DVDEC_CSNUM;
	   bUseVideoInfo2 = FALSE;
   }

    //
    // Fill in the output format according to requested position
    //

    //looking for format flag

    DWORD  dw =0;
   
    //The cases below are the modes we currently support.
    // to add more, add a case below in the correct priority position
    // and increment the constant AM_DVDEC_CSNUM in decode.h
    switch (iPosition)  
    {
    case 0:
        dw = AM_DVDEC_YUY2;
        break;
    case 1:
        dw = AM_DVDEC_UYVY;
        break;
    case 2:
        dw = AM_DVDEC_RGB24;
        break;
    case 3:
        dw = AM_DVDEC_RGB32;
        break;
    case 4:
        dw = AM_DVDEC_ARGB32;
        break;
    case 5:
        dw = AM_DVDEC_RGB565;
        break;
    case 6:
        dw = AM_DVDEC_RGB555;
        break;
    case 7:
        dw = AM_DVDEC_RGB8;
        break;
    default:
   	    return VFW_S_NO_MORE_ITEMS;
    }
        

    switch (dw ) {

    case AM_DVDEC_YUY2:
        
	pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, MAKEFOURCC('Y','U','Y','2'), 16);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_YUY2);
        break;
    
    case AM_DVDEC_UYVY:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, MAKEFOURCC('U','Y','V','Y'), 16);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_UYVY);
        break;

    case AM_DVDEC_RGB24:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, BI_RGB, 24);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB24);
        break;
        
    case AM_DVDEC_RGB32:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, BI_RGB, 32);
        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB32);
        break;

    case AM_DVDEC_ARGB32:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, BI_RGB, 32);
        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_ARGB32);
        break;

    case AM_DVDEC_RGB565:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER +
                                                          SIZE_MASKS);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }

        InitDestinationVideoInfo(pVideoInfo, BI_BITFIELDS, 16);

        DWORD *pdw;
        pdw = (DWORD *)(HEADER(pVideoInfo) + 1);
        pdw[iRED]   = bits565[iRED];
        pdw[iGREEN] = bits565[iGREEN];
        pdw[iBLUE]  = bits565[iBLUE];

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB565);
        break;

    case AM_DVDEC_RGB555:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, BI_RGB, 16);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB555);
        break;

    case AM_DVDEC_RGB8:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER+SIZE_PALETTE);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
	    InitDestinationVideoInfo(pVideoInfo, BI_RGB, 8);
	
        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB8);
        break;
        
    case AM_DVDEC_Y41P:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, MAKEFOURCC('Y','4','1','P'), 12);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_Y41P);
        break;
 
    default:
        return VFW_S_NO_MORE_ITEMS;

    }

    //
    // This block assumes that lpbi has been set up to point to a valid
    // bitmapinfoheader and that cmt has been copied into *pmt.
    // This is taken care of in the switch statement above.  This should
    // kept in mind when new formats are added.
    //
    pmt->SetType(&MEDIATYPE_Video);
    pmt->SetFormatType(&FORMAT_VideoInfo);

    //
    // the output format is uncompressed
    //
    pmt->SetTemporalCompression(FALSE);
    pmt->SetSampleSize(HEADER(pVideoInfo)->biSizeImage);

    if (bUseVideoInfo2)
	{
		VIDEOINFOHEADER2 *pVideoInfo2;
		ConvertVideoInfoToVideoInfo2( pmt);
		pVideoInfo2 = (VIDEOINFOHEADER2 *)pmt->Format();
		pVideoInfo2->dwPictAspectRatioX =4;
		pVideoInfo2->dwPictAspectRatioY =3;
	 }

    return S_OK;
}


/*****************************Private*Routine******************************\
* InitDestinationVideoInfo
*
* Fills in common video and bitmap info header fields
*
\**************************************************************************/
void
CDVVideoCodec::InitDestinationVideoInfo(
    VIDEOINFO *pVideoInfo,
    DWORD dwComppression,
    int nBitCount
    )
{
    LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);
    lpbi->biSize          = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth         = m_lPicWidth;	
    lpbi->biHeight        = m_lPicHeight;	;
    lpbi->biPlanes        = 1;
    lpbi->biBitCount      = (WORD)nBitCount;
    lpbi->biXPelsPerMeter = 0;
    lpbi->biYPelsPerMeter = 0;
    lpbi->biCompression   = dwComppression;
    lpbi->biSizeImage     = GetBitmapSize(lpbi);
    //pVideoInfo->bmiHeader.biClrUsed = STDPALCOLOURS;
    //pVideoInfo->bmiHeader.biClrImportant = STDPALCOLOURS;
    if(nBitCount >8 ){
        lpbi->biClrUsed	    = 0;
    	lpbi->biClrImportant  = 0;
    }else if( nBitCount==8)
    {
	lpbi->biClrUsed = SIZE_PALETTE / sizeof(RGBQUAD);
	lpbi->biClrImportant = 0;
        
	RGBQUAD * prgb = (RGBQUAD *) (lpbi+1);

	// fixed PALETTE table	(0 <= i < 256)
	for(int i=0; i<256;i++)
	{
	    prgb[i].rgbRed	    = (i/64) << 6;
	    prgb[i].rgbGreen	    = ((i/4)%16) << 4;
	    prgb[i].rgbBlue	    = (i%4) << 6 ;
	    prgb[i].rgbReserved	    =0;
	}
    }
	
    pVideoInfo->rcSource.top = 0;
    pVideoInfo->rcSource.left = 0;
    pVideoInfo->rcSource.right = m_lPicWidth;			
    pVideoInfo->rcSource.bottom = m_lPicHeight;			
    if( m_lPicHeight== 576 || m_lPicHeight== 288 || m_lPicHeight== 144 || m_lPicHeight== 72 )
	pVideoInfo->AvgTimePerFrame =UNITS/25; //InVidInfo->AvgTimePerFrame;
    else
	pVideoInfo->AvgTimePerFrame =UNITS*1000L/29970L; //InVidInfo->AvgTimePerFrame;
    pVideoInfo->rcTarget = pVideoInfo->rcSource;

    //
    // The "bit" rate is image size in bytes times 8 (to convert to bits)
    // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
    // so we multiply by 10000000 to convert to bits per second, this multiply
    // is combined with "times" 8 above so the calculations becomes:
    //
    // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
    //
    LARGE_INTEGER li;
    li.QuadPart = pVideoInfo->AvgTimePerFrame;
    pVideoInfo->dwBitRate = MulDiv(lpbi->biSizeImage, 80000000, li.LowPart);
    pVideoInfo->dwBitErrorRate = 0L;
}


/******************************Public*Routine******************************\
* DecideBufferSize
*
* Called from CBaseOutputPin to prepare the allocator's count
* of buffers and sizes
*
\**************************************************************************/
HRESULT
CDVVideoCodec::DecideBufferSize(
    IMemAllocator * pAllocator,
    ALLOCATOR_PROPERTIES * pProperties
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::DecideBufferSize")));

    ASSERT(pAllocator);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    pProperties->cBuffers = 1;
    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize();
    pProperties->cbAlign = 1;
    pProperties->cbPrefix= 0;

    ASSERT(pProperties->cbBuffer);
    DbgLog((LOG_TRACE, 2, TEXT("Sample size = %ld\n"), pProperties->cbBuffer));

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    ASSERT(Actual.cbAlign == 1);
    ASSERT(Actual.cbPrefix == 0);

    if ((Actual.cbBuffer < pProperties->cbBuffer )||
        (Actual.cBuffers < 1 )) {
            // can't use this allocator
            return E_INVALIDARG;
    }
    return S_OK;
}


/******************************Public*Routine******************************\
* StartStreaming
* Before inputpin receive anything, StartStreaming is called
\**************************************************************************/
HRESULT
CDVVideoCodec::StartStreaming(    void    )
{
    CAutoLock   lock(&m_csReceive);
    GUID guid;

    // set the flag to look at the first valid frame, to detect DVCPRO format
    m_bExamineFirstValidFrameFlag = TRUE;

    // turn off Quality Control flag, because we have started streaming fresh.
    m_bQualityControlActiveFlag = FALSE;


    guid=*m_pOutput->CurrentMediaType().Subtype();    

     //reset m_CodecReq
    DWORD dwCodecReq=0;

    

    //check output subtype()
    if (  guid != MEDIASUBTYPE_UYVY  )
    {	
	if(guid != MEDIASUBTYPE_YUY2 )
	{
    	    if(guid != MEDIASUBTYPE_RGB565 )
	    {
		if(guid != MEDIASUBTYPE_RGB555 )
		{
		    if(guid != MEDIASUBTYPE_RGB24 )
		    {
			if(guid != MEDIASUBTYPE_RGB8 )
			{

			    if(guid != MEDIASUBTYPE_Y41P  )
                            {    
                                if (guid != MEDIASUBTYPE_RGB32 && guid != MEDIASUBTYPE_ARGB32)
                                    return E_INVALIDARG;
                                else dwCodecReq = AM_DVDEC_RGB32;
                            }
			    else
				dwCodecReq=AM_DVDEC_Y41P;	
			}
			else
			    dwCodecReq=AM_DVDEC_RGB8;
		    }
		    else
			dwCodecReq=AM_DVDEC_RGB24;	
		}
		else
		    dwCodecReq=AM_DVDEC_RGB555;	
	    }
	    else
	        dwCodecReq=AM_DVDEC_RGB565;	
	}
	else
	    dwCodecReq=AM_DVDEC_YUY2;
    }
    else
	dwCodecReq=AM_DVDEC_UYVY;

    // if we are using RGB 24 and the Dynamic Range 219 flag is set
    // then we update CodecRec telling the Decoder to use the following 
    // dynamic range (16,16,16)--(235,235,235)
    
    if (m_bRGB219 && (( dwCodecReq & AM_DVDEC_RGB24)|| (dwCodecReq &AM_DVDEC_RGB32) ))
        dwCodecReq |= AM_DVDEC_DR219RGB;


    guid=*m_pInput->CurrentMediaType().Subtype();

    //check input subtype()
    if (  guid != MEDIASUBTYPE_dvsd && guid != MEDIASUBTYPE_dvc )
    {
	if  (guid != MEDIASUBTYPE_dvhd) 
	{
	    if (guid != MEDIASUBTYPE_dvsl)  
		return E_INVALIDARG;
	    else
		dwCodecReq  = dwCodecReq | AM_DVDEC_DVSL;
	}
	else
    	    dwCodecReq  = dwCodecReq |AM_DVDEC_DVHD;
    }
    else
	dwCodecReq  = dwCodecReq | AM_DVDEC_DVSD;

	

    CMediaType* pmt;
    VIDEOINFO   *pVideoInfo;
	VIDEOINFOHEADER2 * pVideoInfo2;
	BITMAPINFOHEADER * pBmiHeader;
    pmt = &(m_pOutput->CurrentMediaType() );
	
	BOOL bUseVideoInfo2 = (*pmt->FormatType() == FORMAT_VideoInfo2);

	
	
	if (bUseVideoInfo2)
	{
		pVideoInfo2 = (VIDEOINFOHEADER2 * )pmt->pbFormat;
		pBmiHeader = &pVideoInfo2->bmiHeader;
		
	}
	else
	{
		pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
		pBmiHeader = &pVideoInfo->bmiHeader;
	}

    long biWidth=pBmiHeader->biWidth;
    
    //require decoding resolution
	
	if (bUseVideoInfo2)
	{
		if (!IsRectEmpty(&(pVideoInfo2->rcTarget)))
		{
		    long l1=pVideoInfo2->rcTarget.left;
            long l2=pVideoInfo2->rcTarget.right;
            biWidth=abs(l1-l2);
		}
	}
	else
	{
		if (!IsRectEmpty(&(pVideoInfo->rcTarget)))
		{
		    long l1=pVideoInfo->rcTarget.left;
            long l2=pVideoInfo->rcTarget.right;
            biWidth=abs(l1-l2);
		}
	}

    if(biWidth == 88 )
	dwCodecReq  = dwCodecReq | AM_DVDEC_DC;
    else if(biWidth== 180 )
	    dwCodecReq  = dwCodecReq | AM_DVDEC_Quarter; 
	  else if( biWidth == 360 )
		  dwCodecReq  = dwCodecReq | AM_DVDEC_Half;    
		else if(biWidth== 720 )
			dwCodecReq  = dwCodecReq | AM_DVDEC_Full;	
		    else
			  return E_INVALIDARG;

    //NTSC or PAL
    //get input format
    VIDEOINFO *InVidInfo = (VIDEOINFO *)m_pInput->CurrentMediaType().pbFormat;
    LPBITMAPINFOHEADER lpbi = HEADER(InVidInfo);
    
    if( (lpbi->biHeight== 480) || (lpbi->biHeight== 240) ||(lpbi->biHeight== 120) || (lpbi->biHeight== 60) )
	dwCodecReq  = dwCodecReq | AM_DVDEC_NTSC;	
    else  if( (lpbi->biHeight== 576) || (lpbi->biHeight== 288) ||(lpbi->biHeight== 144) || (lpbi->biHeight== 72) )
	    dwCodecReq  = dwCodecReq | AM_DVDEC_PAL;	
	  else
	      return E_FAIL; 
   
        
    if((bMMXCPU==TRUE) &&  (m_CodecCap & AM_DVDEC_MMX ) )
    	dwCodecReq|=AM_DVDEC_MMX;

    // finally update the member
    m_CodecReq=dwCodecReq;
    
    InitMem4Decoder( &m_pMem4Dec,  dwCodecReq );

    m_fStreaming=1;

    //m_lStride = ((pvi->bmiHeader.biWidth * pvi->bmiHeader.biBitCount) + 7) / 8;
    m_lStride = pBmiHeader->biWidth ;
    m_lStride = (m_lStride + 3) & ~3;
    if( ( pBmiHeader->biHeight <0)  || (pBmiHeader->biCompression > BI_BITFIELDS ) )
	m_lStride=ABSOL(m_lStride);	    //directDraw
    else
	m_lStride=-ABSOL(m_lStride);	    //DIB
    
    //memory for MEI's decoder
    ASSERT(m_pMem ==NULL);
    m_pMem = new char[440000+64];
    if(m_pMem==NULL)
	return E_OUTOFMEMORY;

    // Always align on an 8 byte boundary: the version 6.4 of the 
    // decoder does this (so as avoid an #ifdef WIN64)
    m_pMemAligned = (char*) (((UINT_PTR)m_pMem + 63) & ~63);
    *m_pMemAligned = 0;

    return CVideoTransformFilter::StartStreaming();

}


/******************************Public*Routine******************************\
* StopStreaming
\**************************************************************************/
HRESULT
CDVVideoCodec::StopStreaming(    void    )
{
    //  NOTE - this is called from Receive in this filter so we should
    //  never grab the filter lock.  However we grab the Receive lock so
    //  that when we're called from Stop we're synchronized with Receive().
    CAutoLock       lck(&m_csReceive);

    if(m_fStreaming)
    {

	m_fStreaming=0;

	TermMem4Decoder(m_pMem4Dec);
    }


    if(m_pMem)
    {
	delete []m_pMem;	//(2)
	m_pMem=NULL;
	m_pMemAligned=NULL;
    }


    return CVideoTransformFilter::StopStreaming();

}


/******************************Public*Routine******************************\
* 
*
* Handle quality control notifications sent to us
* ReActivated: anuragsh "Dec 16, 1999"
*
\**************************************************************************/
HRESULT
CDVVideoCodec::AlterQuality(Quality q)
{
    // turn on the Quality Control Flag so we can drop frames if needed in Receive()
    m_bQualityControlActiveFlag = TRUE;

    // call the parent's AlterQuality() so m_itrLate can be set appropriately
    return CVideoTransformFilter::AlterQuality(q);
}


//
// GetPages
//
// Returns the clsid's of the property pages we support
//
STDMETHODIMP CDVVideoCodec::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) 
    {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_DVDecPropertiesPage;
    return NOERROR;

} // GetPages

//
// get_IPDisplay
//
// Return the current effect selected
//
STDMETHODIMP CDVVideoCodec::get_IPDisplay(int *iDisplay)
{
    CAutoLock cAutolock(&m_DisplayLock);

    CheckPointer(iDisplay,E_POINTER);
    
    *iDisplay = m_iDisplay;
   
    return NOERROR;

} // get_IPDisplay


//
// put_IPDisplay
//
// Set the required video display
//
// if the isplay is changed, reconnect filters.
STDMETHODIMP CDVVideoCodec::put_IPDisplay(int iDisplay)
{
    CAutoLock cAutolock(&m_DisplayLock);
    BYTE bNTSC=TRUE;

    //check if display resolution change
    if(m_iDisplay == iDisplay)
        return NOERROR;

    //can not change property if m_fStreaming=1
    if(m_fStreaming)
	return E_FAIL;

    if (m_pInput == NULL) 
    {
	CTransformInputPin * pPin;
        pPin = (CTransformInputPin *)GetPin(0);
        ASSERT(m_pInput==pPin);
	ASSERT(m_pInput!=NULL);
    }
    if (m_pOutput == NULL) 
    {
	CTransformOutputPin * pPin;
        pPin = (CTransformOutputPin *)GetPin(1);
        ASSERT(m_pOutput==pPin);
	ASSERT(m_pOutput!=NULL);
    }

    // Ignore if we are not connected  to video render yet
    //CAutoLock cSampleLock(&m_RendererLock);
    if (m_pInput->IsConnected() == FALSE)  {
	m_iDisplay = iDisplay;
	//if it becomes PAL, SetMediaType will take care it when connected.
	switch (m_iDisplay)
	{
	case IDC_DEC360x240 :
	    m_lPicHeight=240;
	    m_lPicWidth=360;
	    break;
	case IDC_DEC720x480 :
	    m_lPicHeight=480;
    	    m_lPicWidth=720;
	    break;
	case IDC_DEC180x120 :
	    m_lPicHeight=120;
	    m_lPicWidth=180;
	    break;
	case IDC_DEC88x60 :
	    m_lPicHeight=60;
	    m_lPicWidth=88;
       	    break;
	default:
	    break;
	}
	return NOERROR;
    }
   

    //decide NTSC , PAL
    VIDEOINFO *InVidInfo = (VIDEOINFO *)m_pInput->CurrentMediaType().pbFormat;
    LPBITMAPINFOHEADER lpbi = HEADER(InVidInfo);
    if( (lpbi->biHeight== 480) || (lpbi->biHeight== 240) ||(lpbi->biHeight== 120) || (lpbi->biHeight== 60) )
	;
    else if( (lpbi->biHeight== 576) || (lpbi->biHeight== 288) ||(lpbi->biHeight== 144) || (lpbi->biHeight== 72) )
	    bNTSC=FALSE;
	  else
	      return E_FAIL; 
   
    //display resolution changed 
    if(iDisplay==IDC_DEC720x480){

	if ( !(m_CodecCap & AM_DVDEC_Full) )
	    return E_FAIL;

  	m_lPicWidth=720; 
	if(bNTSC==TRUE)
	    m_lPicHeight=480; 
	else
	    m_lPicHeight=576;
    }
    else if(iDisplay==IDC_DEC360x240){
	
	if ( !(m_CodecCap & AM_DVDEC_Half) )
	    return E_FAIL;
	m_lPicWidth=360; 
	if(bNTSC==TRUE)
	    m_lPicHeight=240;
	else
	    m_lPicHeight=288;
    }
    else if(iDisplay==IDC_DEC180x120){
	if ( !(m_CodecCap & AM_DVDEC_Quarter) )
	    return E_FAIL;
	m_lPicWidth=180; 
	if(bNTSC==TRUE)
	    m_lPicHeight=120;
	else
	    m_lPicHeight=144;
    }else if(iDisplay==IDC_DEC88x60){
	if ( !(m_CodecCap & AM_DVDEC_DC) )
	    return E_FAIL;
	m_lPicWidth=88; 
	if(bNTSC==TRUE)
	    m_lPicHeight=60;
	else
	    m_lPicHeight=72;
    }else{
	return E_FAIL;
    }

    m_iDisplay = iDisplay;
    if(m_pOutput->IsConnected())
    {	
        //reconnect, it would never fail
	m_pGraph->Reconnect( m_pOutput );

    }
    return NOERROR;
    
} // put_IPDisplay


//IPersistStream
//
// GetClassID
//
STDMETHODIMP CDVVideoCodec::GetClassID(CLSID *pClsid)
{
    *pClsid = CLSID_DVVideoCodec;
    return NOERROR;

} // GetClassID

HRESULT CDVVideoCodec::WriteToStream(IStream *pStream)
{
    PROP prop;
    HRESULT hr = S_OK;

    if( (hr = get_IPDisplay(&prop.iDisplay) ) == NOERROR )
    {
	ASSERT(prop.iDisplay==m_iDisplay);
	prop.lPicWidth=m_lPicWidth;
	prop.lPicHeight=m_lPicHeight;
        hr = pStream->Write(&prop, sizeof(PROP), 0);
    }

    return hr;
}

HRESULT CDVVideoCodec::ReadFromStream(IStream *pStream)
{
    PROP prop;
    HRESULT hr = S_OK;

    hr = pStream->Read(&prop, sizeof(PROP), 0);
    if(FAILED(hr))
        return hr;


    if(m_pOutput !=NULL)
    {
	int iDisplay=prop.iDisplay;
	hr = put_IPDisplay(iDisplay);

    }
    else
    {
	m_iDisplay=prop.iDisplay;
	m_lPicWidth=prop.lPicWidth;
	m_lPicHeight=prop.lPicHeight;
    }
    return hr;
}

int CDVVideoCodec::SizeMax()
{
    return sizeof(PROP);
}


STDMETHODIMP CDVVideoCodec::SetRGB219(BOOL bState)
// This method is used in the case of RGB24 to specify that the Dynamic
// Range to be used is (16,16,16)--(235,235,235)
{
    m_bRGB219 = bState;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvdec\pdecode.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "decode.h"

 int	InitMem4Decoder( char **ppMem, DWORD dwCodecReq )
 {
     *ppMem=NULL;
     return S_OK;
 }

 void	TermMem4Decoder(char *pMem)
 {
     if(pMem!=NULL)
	delete[] pMem;
 }

DWORD GetCodecCapabilities(  )
{

    DWORD cap;
    cap =   AM_DVDEC_DC	    | AM_DVDEC_Quarter | AM_DVDEC_Half | AM_DVDEC_Full | 
	    AM_DVDEC_NTSC   | AM_DVDEC_PAL	|
	    AM_DVDEC_RGB24  | AM_DVDEC_UYVY  | AM_DVDEC_YUY2 | AM_DVDEC_RGB565 | AM_DVDEC_RGB555 |
	    AM_DVDEC_RGB8   | 
            AM_DVDEC_DR219RGB |
	    AM_DVDEC_DVSD   | AM_DVDEC_MMX; 
    return cap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvenc\dvenc.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
/******************************Module*Header*******************************\
* Module Name: dvenc.cpp
*
* Implements a prototype DV Video Encoder AM filter.  
*
\**************************************************************************/
#include <streams.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <stddef.h>
#include <string.h>
#include <olectl.h>

#include <dv.h>
#include "encode.h"
#include "Encprop.h"
#include "dvenc.h"
#include "resource.h"

#define WRITEOUT(var)  hr = pStream->Write(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;

#define READIN(var)    hr = pStream->Read(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;


// setup data
const AMOVIESETUP_MEDIATYPE
psudOpPinTypes[] = { { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvsd  }		// clsMinorType
                   , { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvhd}		// clsMinorType
					, { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvsl}		// clsMinorType
		     }; 

const AMOVIESETUP_MEDIATYPE
sudIpPinTypes = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN
psudPins[] = { { L"Input"            // strName
               , FALSE               // bRendered
               , FALSE               // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Output"           // strConnectsToPin
               , 1                   // nTypes
               , &sudIpPinTypes }    // lpTypes
             , { L"Output"           // strName
               , FALSE               // bRendered
               , TRUE                // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Input"	     // strConnectsToPin
               , 1                   // nTypes
               , psudOpPinTypes } }; // lpTypes

const AMOVIESETUP_FILTER
sudDVEnc = { &CLSID_DVVideoEnc	// clsID
               , L"DV Video Encoder"	// strName
               , MERIT_DO_NOT_USE         // dwMerit
               , 2                      // nPins
               , psudPins };            // lpPin


//* -------------------------------------------------------------------------
//** CDVVideoEnc
//** -------------------------------------------------------------------------
CDVVideoEnc::CDVVideoEnc(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr
    )
    : CTransformFilter(pName, pUnk, CLSID_DVVideoEnc),
    CPersistStream(pUnk, phr),
    m_fStreaming(0),
    m_iVideoFormat(IDC_NTSC),
    m_iDVFormat(IDC_dvsd),
    m_iResolution(IDC_720x480),
    m_fDVInfo(FALSE),	//as default we are not going to output DVINFO structure
    m_fConvert (0),
    m_pMem4Convert (NULL),
    m_lPicWidth(0),
    m_lPicHeight(0),
    m_EncCap(0),
    m_EncReg(0),
    m_bRGB219(FALSE)
{
    //set DVInfo to 0xff
    memset(&m_sDVInfo, 0xff, sizeof(DVINFO) );

    //get encoder's abilities
    m_EncCap=GetEncoderCapabilities(  );

}

CDVVideoEnc::~CDVVideoEnc(     )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::~CDVVideoEnc")));

}

/******************************Public*Routine******************************\
* CreateInstance
*
* This goes in the factory template table to create new instances
*
\**************************************************************************/
CUnknown *
CDVVideoEnc::CreateInstance(
    LPUNKNOWN pUnk,
    HRESULT * phr
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::CreateInstance")));
    return new CDVVideoEnc(TEXT("DV Video Encoder filter"), pUnk, phr);
}

//=============================================================================

// IAMVideoCompression stuff


HRESULT CDVVideoEnc::GetInfo(LPWSTR pszVersion, int *pcbVersion, LPWSTR pszDescription, int *pcbDescription, long FAR* pDefaultKeyFrameRate, long FAR* pDefaultPFramesPerKey, double FAR* pDefaultQuality, long FAR* pCapabilities)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMVideoCompression::GetInfo")));

    // we can't do anything programmatically
    if (pCapabilities)
        *pCapabilities = 0;
    if (pDefaultKeyFrameRate)
        *pDefaultKeyFrameRate = 0;
    if (pDefaultPFramesPerKey)
        *pDefaultPFramesPerKey = 0;
    if (pDefaultQuality)
        *pDefaultQuality = 0;

    if (pcbVersion == NULL && pcbDescription == NULL)
	return NOERROR;

    
    // get the driver version and description
    #define DESCSIZE 80
    WCHAR wachVer[DESCSIZE], wachDesc[DESCSIZE];

    wsprintfW(wachVer, L"Ver02");
    wsprintfW(wachDesc, L"MEI DV Software Encoder");


    // copy 
    if (pszVersion && pcbVersion)
        lstrcpynW(pszVersion, wachVer, min(*pcbVersion / 2, DESCSIZE));
    if (pszDescription && pcbDescription)
        lstrcpynW(pszDescription, wachDesc, min(*pcbDescription / 2, DESCSIZE));

    // return the length in bytes needed (incl. NULL)
    if (pcbVersion)
	*pcbVersion = lstrlenW(wachVer) * 2 + 2;
    if (pcbDescription)
	*pcbDescription = lstrlenW(wachDesc) * 2 + 2;
    
    return NOERROR;
}

/******************************Public*Routine******************************\
* NonDelegatingQueryInterface
*
* Here we would reveal ISpecifyPropertyPages and IDVVideoDecoder if
* the framework had a property page.
*
\**************************************************************************/
STDMETHODIMP
CDVVideoEnc::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    if (riid == IID_IDVEnc) {			    
        return GetInterface((IDVEnc *) this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if (riid == IID_IAMVideoCompression) {
	return GetInterface((LPUNKNOWN)(IAMVideoCompression *)this, ppv);
    } else if(riid == IID_IPersistStream)
    {
        return GetInterface((IPersistStream *) this, ppv);
    } else if (riid == IID_IDVRGB219) {
        return GetInterface((IDVRGB219 *) this, ppv);
    } else {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }

}


HRESULT CDVVideoEnc::Transform(IMediaSample * pIn, IMediaSample *pOut)
{
    unsigned char *pSrc, *pDst;
    HRESULT hr = S_OK;
    
    CAutoLock lck(&m_csReceive);

    // get  output buffer
    hr = pOut->GetPointer(&pDst);
    if (FAILED(hr)) 
    {
        return NULL;
    }
    ASSERT(pDst);
    
    // get the source buffer
    hr = pIn->GetPointer(&pSrc);
    if (FAILED(hr)) 
    {
	return hr;
    }
    ASSERT(pDst);
    

    // if the source not standard 720*480 or 720*576, 
    // a convertion is nneded
    if( m_fConvert){

	// this code will stretch any RGB format, and the most popular YUV formats.
	// we stretch YUV by treating it as a 32-bit bitmap that's half as wide as the original. 
	
	CMediaType* pmtOut;
	pmtOut = &(m_pOutput->CurrentMediaType() );
	CMediaType* pmtIn;
	pmtIn = &(m_pInput->CurrentMediaType() );


	BITMAPINFOHEADER *pbiOut = HEADER(pmtOut->Format());
	BITMAPINFOHEADER *pbiIn = HEADER(pmtIn->Format());

	// normal RGB case
        DWORD dw1=pbiIn->biCompression;
	DWORD dw2=pbiOut->biCompression;
	pbiIn->biCompression = BI_RGB;
	pbiOut->biCompression = BI_RGB;

	StretchDIB(pbiOut, 
		m_pMem4Convert,
		0, 
		0, 
		pbiOut->biWidth, 
		pbiOut->biHeight,
		pbiIn,
		pSrc, 
		0, 
		0, 
		pbiIn->biWidth, 
		pbiIn->biHeight);

        //put original data back
        pbiIn->biCompression = dw1;
	pbiOut->biCompression = dw2;

	pSrc=(unsigned char *)m_pMem4Convert;
    }

    if( DvEncodeAFrame(pSrc,pDst, m_EncReg, m_pMem4Enc) != S_OK )
	return E_FAIL;

    if( m_iVideoFormat == IDC_NTSC )
	pOut->SetActualDataLength(120000);
    else
	pOut->SetActualDataLength(144000);


    return hr;
}

/******************************Public*Routine******************************\
* CheckInputType
* TYPE:	    MEDIATYPE_Video
* SubType:   
* FORMAT:   FORMAT_VideoInfo
\**************************************************************************/
HRESULT
CDVVideoEnc::CheckInputType(   const CMediaType* pmtIn    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::CheckInputType")));

    DWORD dwTmp=0;

    if ( *pmtIn->Type()	== MEDIATYPE_Video)	 
    {	
        if (*pmtIn->FormatType() != FORMAT_VideoInfo) 
        {
            return VFW_E_TYPE_NOT_ACCEPTED;
        }

    	
	if (  *pmtIn->Subtype()	 == MEDIASUBTYPE_UYVY  )
	{
	    dwTmp=AM_DVENC_UYVY	;
	}
	else if( *pmtIn->Subtype()	== MEDIASUBTYPE_YUY2 )
	{
	    dwTmp=AM_DVENC_YUY2;
	}
	else if(*pmtIn->Subtype()	== MEDIASUBTYPE_RGB565 )
	{
	    dwTmp=AM_DVENC_RGB565	;
	}
	else if(*pmtIn->Subtype()	== MEDIASUBTYPE_RGB555 )
	{
	    dwTmp=AM_DVENC_RGB565	;
	}
	else if(*pmtIn->Subtype()	== MEDIASUBTYPE_RGB24 )
	{
	    dwTmp=AM_DVENC_RGB24	;
	}
	else if(*pmtIn->Subtype()	== MEDIASUBTYPE_Y41P  )
    {
	    dwTmp=AM_DVENC_Y41P	;
    }
	else 
	    return VFW_E_TYPE_NOT_ACCEPTED;   //only converting RGB now.
			
	if( !(m_EncCap  & dwTmp) )
		return VFW_E_TYPE_NOT_ACCEPTED;   //only converting RGB now.



	//check image size
	VIDEOINFO *videoInfo = (VIDEOINFO *)pmtIn->pbFormat;
	
	m_lPicWidth	= videoInfo->bmiHeader.biWidth;
	m_lPicHeight	= videoInfo->bmiHeader.biHeight;

	if( ( ( m_lPicWidth == 720 ) && (m_lPicHeight == 480) && (m_iVideoFormat==IDC_NTSC) )  ||	
            ( ( m_lPicWidth == 720 ) && (m_lPicHeight == 576) && (m_iVideoFormat==IDC_PAL)  )   ||	
            ( m_EncCap & AM_DVENC_AnyWidHei ) 
          )
	    m_fConvert =0;
	else
	{
	    if (*pmtIn->Subtype() != MEDIASUBTYPE_RGB24 )
		return VFW_E_TYPE_NOT_ACCEPTED;   //only converting RGB now.
	    m_fConvert =1;
	}

    }
    else
	return VFW_E_TYPE_NOT_ACCEPTED;

	
   return S_OK;
}


/******************************Public*Routine******************************\
* CheckTransform				       
\**************************************************************************/
HRESULT
CDVVideoEnc::CheckTransform(
    const CMediaType* pmtIn,
    const CMediaType* pmtOut
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::CheckTransform")));


    // we only accept Video as  toplevel type.
    if (*pmtOut->Type() != MEDIATYPE_Video || *pmtIn->Type() != MEDIATYPE_Video)
    {
	return E_INVALIDARG;
    }

    if (*pmtOut->Subtype() != MEDIASUBTYPE_dvsd &&
    				*pmtOut->Subtype() != MEDIASUBTYPE_dvhd &&
    				*pmtOut->Subtype() != MEDIASUBTYPE_dvsl) {
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        return E_INVALIDARG;
    }

    if ( *pmtOut->FormatType() != FORMAT_VideoInfo) 
    {
        return E_INVALIDARG;
    }

    VIDEOINFO *videoInfo = (VIDEOINFO *)pmtIn->pbFormat;
	
    m_lPicWidth		= videoInfo->bmiHeader.biWidth;
    m_lPicHeight	= videoInfo->bmiHeader.biHeight;

    if( ( ( m_lPicWidth == 720 ) && (m_lPicHeight == 480) && (m_iVideoFormat==IDC_NTSC) )  ||	
            ( ( m_lPicWidth == 720 ) && (m_lPicHeight == 576) && (m_iVideoFormat==IDC_PAL)  )   ||	
            ( m_EncCap & AM_DVENC_AnyWidHei ) 
          )
    	m_fConvert =0;
    else
    {
    	if (*pmtIn->Subtype() != MEDIASUBTYPE_RGB24 )
	    return E_FAIL;
	m_fConvert =1;
    }

    return S_OK;
}


/******************************Public*Routine******************************\
* SetMediaType
*
* Overriden to know when the media type is actually set
*
\**************************************************************************/
HRESULT
CDVVideoEnc::SetMediaType(   PIN_DIRECTION direction, const CMediaType *pmt    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::SetMediaType")));

    if (direction == PINDIR_INPUT) 
    {
    }
    else 
    {
        SetOutputPinMediaType(pmt);
    }
    return S_OK;
}


/*****************************Private*Routine******************************\
* SetOutputPinMediaType
*
\**************************************************************************/
void
CDVVideoEnc::SetOutputPinMediaType(     const CMediaType *pmt    )
{    
	
    //
    // lStride is the distance between in bytes between a pel on the
    // screen and the pel directly underneath it.
    //
    VIDEOINFO   *pvi;
    LONG        lStride;
    LONG        lOffset;
    pvi = (VIDEOINFO *)pmt->pbFormat;
    lStride = ((pvi->bmiHeader.biWidth * pvi->bmiHeader.biBitCount) + 7) / 8;
    lStride = (lStride + 3) & ~3;


    //
    // lOffset is the distance in bytes from the top corner of the
    // target bitmap to the top corner of the video image.  When we are
    // using DIBs this value allways be zero.
    //
    // When we are using DCI/DirectDraw this value will only be zero if
    // we are drawing the video image at the top left hand corner of the
    // display.
    //

    lOffset = (((pvi->rcTarget.left * pvi->bmiHeader.biBitCount) + 7) / 8) +
                (pvi->rcTarget.top * lStride);

}

/******************************Public*Routine******************************\
* GetMediaType
*
* Return our preferred output media types (in order)
*
\**************************************************************************/
HRESULT
CDVVideoEnc::GetMediaType( int iPosition,  CMediaType *pmt )
{
    VIDEOINFO   *pVideoInfo;
    CMediaType  cmt;

    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::GetMediaType")));

    if (iPosition != 0) {
        return E_INVALIDARG;
    }
   

    //X* copy current media type from input pin
    cmt = m_pInput->CurrentMediaType();


    if  (*cmt.Type() != MEDIATYPE_Video)  
	return VFW_S_NO_MORE_ITEMS;

    //get input format
    VIDEOINFO *InVidInfo = (VIDEOINFO *)m_pInput->CurrentMediaType().pbFormat;

    //allocate memory for output format
    int iSize;

    //m_fDVInfo==TRUE;

    if(m_fDVInfo==TRUE)
	iSize=	SIZE_VIDEOHEADER+sizeof(DVINFO);
    else
	iSize=	SIZE_VIDEOHEADER;

    pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(iSize);
    if (pVideoInfo == NULL) {
        return E_OUTOFMEMORY;
    }
    

    LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);

    if(m_fDVInfo==TRUE)
	iSize=	sizeof(BITMAPINFOHEADER)+sizeof(DVINFO);
    else
	iSize=	sizeof(BITMAPINFOHEADER);

    lpbi->biSize          = (DWORD) iSize;

    lpbi->biWidth         = 720;	

    if( m_iVideoFormat == IDC_NTSC )
    	lpbi->biHeight        = 480;	
    else
	lpbi->biHeight        = 576;

    lpbi->biPlanes        = 1;
    lpbi->biBitCount      = 24;			//dvdecoder, avi mux or dv mux write do not matter, 24 for strechDIB func
    lpbi->biXPelsPerMeter = 0;
    lpbi->biYPelsPerMeter = 0;
    //lpbi->biCompression   = BI_RGB;		//dvdecoder,avi mux or dv mux write do not care, BI_RGB only for StrechDIB func
// how to build an explicit FOURCC
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

    lpbi->biCompression     =FCC('dvsd');       //7/19/20, Ivan maltz cares this in his application, we will set this to BI_RGB for stretchDIB and switch back.
    lpbi->biSizeImage     = GetBitmapSize(lpbi);

    
    if(m_fDVInfo==TRUE)
    {
	unsigned char *pc   =(unsigned char *)( lpbi+ sizeof(BITMAPINFOHEADER));
	unsigned char *pDV  =(unsigned char *)&m_sDVInfo;
	//copy DVINFO

	memcpy(pc,pDV,sizeof(DVINFO) ); 
    }
    
    //pVideoInfo->bmiHeader.biClrUsed = STDPALCOLOURS;
    //pVideoInfo->bmiHeader.biClrImportant = STDPALCOLOURS;
    	
    pVideoInfo->rcSource.top	= 0;
    pVideoInfo->rcSource.left	= 0;
    pVideoInfo->rcSource.right	= lpbi->biWidth;			
    pVideoInfo->rcSource.bottom = lpbi->biHeight;			
    pVideoInfo->AvgTimePerFrame = InVidInfo->AvgTimePerFrame;		//copy input's avgTimePerFrame
    pVideoInfo->rcTarget	= pVideoInfo->rcSource;

    //
    // The "bit" rate is image size in bytes times 8 (to convert to bits)
    // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
    // so we multiply by 10000000 to convert to bits per second, this multiply
    // is combined with "times" 8 above so the calculations becomes:
    //
    // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
    //
    LARGE_INTEGER li;
    li.QuadPart = pVideoInfo->AvgTimePerFrame;
    pVideoInfo->dwBitRate = MulDiv(lpbi->biSizeImage, 80000000, li.LowPart);
    pVideoInfo->dwBitErrorRate = 0L;


    *pmt = cmt;
    if(m_iDVFormat == IDC_dvsd)
	pmt->SetSubtype(&MEDIASUBTYPE_dvsd);
    else 	if(m_iDVFormat == IDC_dvhd)
	pmt->SetSubtype(&MEDIASUBTYPE_dvhd);
    else	if(m_iDVFormat == IDC_dvsl)
    	pmt->SetSubtype(&MEDIASUBTYPE_dvsl);
    else 
	ASSERT(m_iDVFormat== IDC_dvsd);
    
    //
    // This block assumes that lpbi has been set up to point to a valid
    // bitmapinfoheader and that cmt has been copied into *pmt.
    // This is taken care of in the switch statement above.  This should
    // kept in mind when new formats are added.
    //
    pmt->SetType(&MEDIATYPE_Video);
   
    pmt->SetFormatType(&FORMAT_VideoInfo);

    //150*80*10 or *12
    pmt->SetSampleSize(HEADER(pVideoInfo)->biSizeImage);

    return S_OK;
}



/******************************Public*Routine******************************\
* DecideBufferSize
*
* Called from CBaseOutputPin to prepare the allocator's count
* of buffers and sizes
*
\**************************************************************************/
HRESULT
CDVVideoEnc::DecideBufferSize(
    IMemAllocator * pAllocator,
    ALLOCATOR_PROPERTIES * pProperties
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::DecideBufferSize")));

    ASSERT(pAllocator);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    pProperties->cBuffers = 4;
	if(m_iVideoFormat == IDC_NTSC )
	     pProperties->cbBuffer = 150*80*10;
	else
	     pProperties->cbBuffer = 150*80*12;


    ASSERT(pProperties->cbBuffer);
    DbgLog((LOG_TRACE, 2, TEXT("Sample size = %ld\n"), pProperties->cbBuffer));

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    //ASSERT(Actual.cbAlign == 1);
    //ASSERT(Actual.cbPrefix == 0);

    if ((Actual.cbBuffer < pProperties->cbBuffer )||
        (Actual.cBuffers < 1 )) {
            // can't use this allocator
            return E_INVALIDARG;
    }
    return S_OK;
}


/******************************Public*Routine******************************\
* StartStreaming
* Before inputpin receive anything, StartStreaming is called
\**************************************************************************/
HRESULT
CDVVideoEnc::StartStreaming(    void    )
{
    CAutoLock   lock(&m_csFilter);
    GUID guid;

	//reset m_EncReg
    DWORD dwEncReq=0;
	
    //check output subtype()
    guid=*m_pOutput->CurrentMediaType().Subtype();
    if (  guid != MEDIASUBTYPE_dvsd  )
    {	
	if(guid != MEDIASUBTYPE_dvhd )
	{
	    if(guid != MEDIASUBTYPE_dvsl )
	       return E_INVALIDARG;
	    else
	        dwEncReq=AM_DVENC_DVSL;
	}
	else
	    dwEncReq=AM_DVENC_DVHD;	
    }
     else
	dwEncReq=AM_DVENC_DVSD;	


    //check input subtype()
    guid=*m_pInput->CurrentMediaType().Subtype();
    if (  guid != MEDIASUBTYPE_UYVY  )
    {	
	if(guid != MEDIASUBTYPE_YUY2 )
	{
	    if(guid != MEDIASUBTYPE_RGB565 )
	    {
		if(guid != MEDIASUBTYPE_RGB555 )
		{
		    if(guid != MEDIASUBTYPE_RGB24 )
		    {
			if(guid != MEDIASUBTYPE_Y41P  )
			   return E_INVALIDARG;
			else
			    dwEncReq |=AM_DVENC_Y41P;	
		    }
		    else
			dwEncReq |=AM_DVENC_RGB24;	
		}
		else
		    dwEncReq |=AM_DVENC_RGB555;	
	    }
	    else
		dwEncReq |=AM_DVENC_RGB565;	
	}
	else
	    dwEncReq |=AM_DVENC_YUY2;
    }
    else
		dwEncReq |=AM_DVENC_UYVY;
    
    if (m_bRGB219 && ( dwEncReq & AM_DVENC_RGB24))
        dwEncReq |= AM_DVENC_DR219RGB;

    //NTSC or PAL 		
    if(m_iVideoFormat == IDC_NTSC )
	dwEncReq  = dwEncReq | AM_DVENC_NTSC |AM_DVENC_DV;	
    else
	dwEncReq  = dwEncReq | AM_DVENC_PAL |AM_DVENC_DV;	

    //resolution
    if(m_iResolution ==  IDC_720x480 )
	dwEncReq |= AM_DVENC_Full;
    else if(m_iResolution ==  IDC_360x240 )
	dwEncReq |= AM_DVENC_Half;
    else if(m_iResolution ==  IDC_180x120 )
	dwEncReq |= AM_DVENC_Quarter;
    else if(m_iResolution ==  IDC_88x60 )
	dwEncReq |= AM_DVENC_DC;

    extern BOOL bMMXCPU;

    if( ( bMMXCPU==TRUE) && ( m_EncCap & AM_DVENC_MMX ) )
    	dwEncReq |= AM_DVENC_MMX;

    m_EncReg=dwEncReq;
    
    HRESULT hr;
	//Allocate memory for decoder												   
    if (FAILED (hr = InitMem4Encoder( &m_pMem4Enc,  dwEncReq )))
        return hr;


    //Allocate memory for converter
    ASSERT( m_pMem4Convert == NULL );
    if( m_fConvert )
    {	
	m_pMem4Convert =  new char [720*576*3 ];
    }
  
    m_fStreaming=1;
    return CTransformFilter::StartStreaming();

}


/******************************Public*Routine******************************\
* StopStreaming
\**************************************************************************/
HRESULT
CDVVideoEnc::StopStreaming(    void    )
{
    CAutoLock       lock(&m_csFilter);
    CAutoLock       lck(&m_csReceive);

    if(m_fStreaming)
    {

	m_fStreaming=0;

	TermMem4Encoder(m_pMem4Enc);

	//release converting memory													  
	if(m_pMem4Convert!= NULL){
	    delete[] m_pMem4Convert;
	    m_pMem4Convert=NULL;
	}
    }

    return CTransformFilter::StopStreaming();

}

STDMETHODIMP CDVVideoEnc::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) 
    {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_DVEncPropertiesPage;
    return NOERROR;

} // GetPages

//
// get_IPDisplay
//
// Return the current effect selected
//
STDMETHODIMP CDVVideoEnc::get_IFormatResolution(int *iVideoFormat, int *iDVFormat,int *iResolution, BYTE fDVInfo, DVINFO *psDvInfo)
{
    CAutoLock cAutolock(&m_DisplayLock);

    CheckPointer(iVideoFormat,E_POINTER);
    *iVideoFormat = m_iVideoFormat;

    CheckPointer(iDVFormat,E_POINTER);
    *iDVFormat = m_iDVFormat;

    CheckPointer(iResolution,E_POINTER);
    *iResolution = m_iResolution;
   
    if(fDVInfo==TRUE)
    {
	if( psDvInfo ==NULL)
	    return E_FAIL;
	else
	    //we do wnat get m_sDVInfo
	    *psDvInfo=m_sDVInfo;
    }
    return NOERROR;

} // get_IFormatResolution

//
// put_IFormatResolution
//
STDMETHODIMP CDVVideoEnc::put_IFormatResolution(int iVideoFormat, int iDVFormat, int iResolution, BYTE fDVInfo, DVINFO *psDvInfo)
{
    CAutoLock cAutolock(&m_DisplayLock);

    //check if display resolution change
    if( (m_iVideoFormat == iVideoFormat)	&&
	(m_iDVFormat	== iDVFormat)		&& 
	(m_iResolution == iResolution) 		&&
	(m_fDVInfo == fDVInfo)   )
	return NOERROR;

    //can not change property if m_fStreaming=1
    if(m_fStreaming)
	return E_FAIL;

    if (m_pOutput == NULL) 
    {
	CTransformOutputPin * pPin;
        pPin = (CTransformOutputPin *)GetPin(1);
        ASSERT(m_pOutput==pPin);
	ASSERT(m_pOutput!=NULL);
    }

    // Ignore if we are not connected  to video render yet
    //CAutoLock cSampleLock(&m_RendererLock);
    if (m_pOutput->IsConnected() == FALSE) {
	m_iVideoFormat	= iVideoFormat;
	m_iDVFormat	= iDVFormat;
	m_iResolution	= iResolution;
	return NOERROR;
    }
    
    //check iVideoformat
    if ( ( (iVideoFormat == IDC_NTSC) &&	(m_EncCap & AM_DVENC_NTSC )  ) ||
	 ( (iVideoFormat == IDC_PAL)  &&	(m_EncCap & AM_DVENC_PAL )    )	 )
	m_iVideoFormat = iVideoFormat;
    else 
    	return E_FAIL;

    //check iDVFormat
    if ( ( (iDVFormat == IDC_dvsd) &&	(m_EncCap & AM_DVENC_DVSD )  )		||
	 ( (iDVFormat == IDC_dvhd)  &&	(m_EncCap & AM_DVENC_DVHD )  )		||
	 ( (iDVFormat == IDC_dvsl) &&	(m_EncCap & AM_DVENC_DVSL )	 )		 )
	m_iDVFormat = iDVFormat;
    else 
    	return E_FAIL;

    //check resolution
    if ( ( ( iResolution== IDC_720x480) &&	(m_EncCap & AM_DVENC_Full )  ) ||
	 ( ( iResolution== IDC_360x240)  &&	(m_EncCap & AM_DVENC_Half )  )  ||
	 ( ( iResolution== IDC_180x120  &&	(m_EncCap & AM_DVENC_Quarter )  )  ||
	 ( ( iResolution== IDC_360x240)  &&	(m_EncCap & AM_DVENC_DC )  )  )  )
    {
	m_iResolution = iResolution;
    }
    else
	return E_FAIL;
	
    if(fDVInfo==TRUE)
    {
	if( psDvInfo==NULL )
	    return E_FAIL;
	else
	{   
	    m_fDVInfo=TRUE;
	    m_sDVInfo=*psDvInfo;
	}
    }
    else
        m_fDVInfo=FALSE;   //as default


    /*X*
    //make sure down stream filter accecpt us
    CMediaType* pmt;
    pmt = &(m_pOutput->CurrentMediaType() );
    if(m_pOutput->GetConnected()->QueryAccept(pmt) != S_OK)
    	return E_FAIL;
    *X*/
   
    //reconnect
    m_pGraph->Reconnect( m_pOutput );

    return NOERROR;
    
} // put_IFormatResolution


//
// ScribbleToStream
//
// Overriden to write our state into a stream
//
HRESULT CDVVideoEnc::WriteToStream(IStream *pStream)
{
    HRESULT hr;
    WRITEOUT(m_iVideoFormat);
    WRITEOUT(m_iDVFormat);
    WRITEOUT(m_iResolution);
    return NOERROR;

} // ScribbleToStream

//
// ReadFromStream
//
// Likewise overriden to restore our state from a stream
//
HRESULT CDVVideoEnc::ReadFromStream(IStream *pStream)
{
    HRESULT hr;
    READIN(m_iVideoFormat);
    READIN(m_iDVFormat);
    READIN(m_iResolution);
    return NOERROR;

} // ReadFromStream
			   

//
// GetClassID
// This is the only method of IPersist
//
STDMETHODIMP CDVVideoEnc::GetClassID(CLSID *pClsid)
{
    *pClsid = CLSID_DVVideoEnc;
    return NOERROR;

} // GetClassID

STDMETHODIMP CDVVideoEnc::SetRGB219(BOOL bState)
// This method is used in the case of RGB24 to specify that the Dynamic
// Range to be used is (16,16,16)--(235,235,235)
{
    m_bRGB219 = bState;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvdec\dvdec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
/******************************Module*Header*******************************\
* Module Name: DVVideo.h
*
* Prototype DV Video codec
*
\**************************************************************************/

#ifndef __DVDEC__
#define __DVDEC__

extern const AMOVIESETUP_FILTER sudDVVideo;

				
#define MAXSAMPLEQUEUE 20	// 20 is enough to hold half second worth video stream


#define FLUSH		   ((IMediaSample *)0xFFFFFFFC)  
#define STOPSTREAM	   ((IMediaSample *)0xFFFFFFFD)  
#define ENDSTREAM	   ((IMediaSample *)0xFFFFFFFE)  

		
#define DEFAULT_QUEUESIZE   2

typedef struct _PROP
{
    int iDisplay;
    long lPicWidth;
    long lPicHeight;
}PROP;

class CDVVideoCodec
	: public CVideoTransformFilter,
	  public IIPDVDec,
	  public ISpecifyPropertyPages,
	  public CPersistStream,
      public IDVRGB219

{

public:

    //
    // --- Com stuff ---
    //
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);
    static void InitClass(BOOL, const CLSID *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    DECLARE_IUNKNOWN;

    //
    // --- CVideoTransformFilter overrides ---
    //
    HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut);

    HRESULT CheckInputType(const CMediaType* mtIn);
    HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut);
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES * pProperties);
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT StartStreaming(void);
    HRESULT StopStreaming(void);
    HRESULT Receive(IMediaSample *pSample);


    // Quality control notifications sent to us
    HRESULT AlterQuality(Quality q);
    
    CDVVideoCodec(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *pHr);
    ~CDVVideoCodec();

    // CPersistStream override
    STDMETHODIMP GetClassID(CLSID *pClsid);
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

    // These implement the custom IIPDVDec interface
    STDMETHODIMP get_IPDisplay(int *iDisplay);
    STDMETHODIMP put_IPDisplay(int iDisplay);

    // ISpecifyPropertyPages interface
    STDMETHODIMP GetPages(CAUUID *pPages);

    // IDVRGB219 interface
    STDMETHODIMP SetRGB219 (BOOL bState);


private:
    char		*m_pMem4Dec;
    LPBYTE		m_pSample;
    int			m_perfidDVDeliver;

    CCritSec		m_DisplayLock;  // Private play critical section
    int			m_iDisplay;     // Which display are we processing
    long		m_lPicWidth;
    long		m_lPicHeight;

    void		InitDestinationVideoInfo(VIDEOINFO *pVI, DWORD Comp, int n);
    
    BOOL		m_fStreaming;   
    DWORD		m_CodecCap;	    //what the Codec can do 
    DWORD		m_CodecReq;     //what users want it to do
    long		m_lStride;
    
    int		    m_iOutX;		//X value of Aspect Ratio Displayed
	int		    m_iOutY;		//Y value of Aspect Ratio Displayed
    
    char	        *m_pMem;		//memory for MEI's decoder
    char	        *m_pMemAligned;		//m_pMem aligned on 8 byte boundary

    BOOL		m_bUseVideoInfo2;   //Indicates that we are using the VIDEOINFOHEADER2 structure with 
									// downstream filter
    BOOL        m_bRGB219;          // TRUE if the 219 range is required

    //////////////////////////////////////////////////////////////////////////
    // DVCPRO format detection variables
    // we set the m_bExamineFirstValidFrameFlag flag in StartStreaming()
    // and we check it in Transform() to see if we should parse the first frame
    // note: we don't check it in Receive(), because Receive() calls
    // StartStreaming() again.
    // and detect DVCPRO format
    // the flag is then cleared.
    //////////////////////////////////////////////////////////////////////////
    BOOL                m_bExamineFirstValidFrameFlag;    // look at the first frame

    //////////////////////////////////////////////////////////////////////////
    // strategy:
    // only perform quality control if AlterQuality() overloaded function has 
    // been called at least once. otherwise do not drop frames.
    //////////////////////////////////////////////////////////////////////////
    BOOL                m_bQualityControlActiveFlag;      // should we be performing quality control

    // private utility methods for registry reading
    void                ReadFromRegistry();
    HRESULT             CheckBufferSizes(IMediaSample * pIn, IMediaSample *pOut);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvdec\resource.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by display.rc
//
#define IDS_DECTITLE                    1
#define IDD_DVDec                       101
#define IDC_DEC720x480                  1000
#define IDC_DEC360x240                  1001
#define IDC_DEC180x120                  1002
#define IDC_DEC88x60                    1003
#define IDC_DISPLAY                     1004
#define IDC_CHECKSAVEASDEFAULT           1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvenc\encprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include <dv.h>
#include "EncProp.h"
#include "resource.h"

//
// CreateInstance
//
// Used by the ActiveMovie base classes to create instances
//
CUnknown *CDVEncProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDVEncProperties(lpunk, phr);
    if (punk == NULL) {
	*phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//
// Constructor
//
CDVEncProperties::CDVEncProperties(LPUNKNOWN pUnk, HRESULT *phr) :
	CBasePropertyPage	(NAME("DVenc Property Page"),
                      pUnk,IDD_DVEnc,IDS_TITLE),
    m_pIDVEnc(NULL),
    m_bIsInitialized(FALSE)
{
    ASSERT(phr);

} // (Constructor)


//
// OnReceiveMessage
//
// Handles the messages for our property window
//
INT_PTR CDVEncProperties::OnReceiveMessage(HWND hwnd,
                                          UINT uMsg,
                                          WPARAM wParam,
                                          LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

} // OnReceiveMessage


//
// OnConnect
//
// Called when we connect to a transform filter
//
HRESULT CDVEncProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIDVEnc == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IDVEnc, (void **) &m_pIDVEnc);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pIDVEnc);

    // Get the initial  property
    m_pIDVEnc->get_IFormatResolution(&m_iPropVidFormat,&m_iPropDVFormat, &m_iPropResolution, FALSE, NULL);

    m_bIsInitialized = FALSE ;
    return NOERROR;

} // OnConnect


//
// OnDisconnect
//
// Likewise called when we disconnect from a filter
//
HRESULT CDVEncProperties::OnDisconnect()
{
    // Release of Interface after setting the appropriate old effect value

    if (m_pIDVEnc == NULL) {
        return E_UNEXPECTED;
    }

    m_pIDVEnc->Release();
    m_pIDVEnc = NULL;
    return NOERROR;

} // OnDisconnect


//				
// OnActivate
//
// We are being activated
//
HRESULT CDVEncProperties::OnActivate()
{
    
    //Button_Enable(hwndCtl, fEnable);

    CheckRadioButton(m_Dlg, IDC_NTSC, IDC_PAL, m_iPropVidFormat);
    CheckRadioButton(m_Dlg, IDC_dvsd, IDC_dvsl, m_iPropDVFormat);
    CheckRadioButton(m_Dlg, IDC_720x480, IDC_88x60, m_iPropResolution);
    m_bIsInitialized = TRUE;
    return NOERROR;

} // OnActivate


//
// OnDeactivate
//
// We are being deactivated
//
HRESULT CDVEncProperties::OnDeactivate(void)
{
    ASSERT(m_pIDVEnc);
    m_bIsInitialized = FALSE;
    GetControlValues();
    return NOERROR;

} // OnDeactivate


//
// OnApplyChanges
//
// Apply any changes so far made 
//
HRESULT CDVEncProperties::OnApplyChanges()
{
    GetControlValues();
    return ( m_pIDVEnc->put_IFormatResolution(m_iPropVidFormat, m_iPropDVFormat, m_iPropResolution, FALSE, NULL ) );
} // OnApplyChanges


void CDVEncProperties::GetControlValues()
{
    int i;

    ASSERT(m_pIDVEnc);

    for (i = IDC_720x480; i <= IDC_88x60; i++) {
       if (IsDlgButtonChecked(m_Dlg, i)) {
            m_iPropResolution = i;
            break;
        }
    }

    for ( i = IDC_dvsd; i <= IDC_dvsl; i++) {
       if (IsDlgButtonChecked(m_hwnd, i)) {
            m_iPropDVFormat = i;
            break;
        }
    }


    for ( i = IDC_NTSC; i <= IDC_PAL; i++) {
	if (IsDlgButtonChecked(m_hwnd, i)){
                m_iPropVidFormat = i;
            break;
        }
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvenc\encode.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.

// flags for in encoder capability
#define AM_DVENC_Full		0x00000001
#define AM_DVENC_Half       0x00000002
#define AM_DVENC_Quarter    0x00000004
#define AM_DVENC_DC	        0x00000008

#define AM_DVENC_NTSC		0x00000010	    //encoder can output NTSC DV stream
#define AM_DVENC_PAL		0x00000020	    //encoder can output PAL DV stream

#define AM_DVENC_YUY2		0x00000040	    //encoder can take any YUY2 video as input
#define AM_DVENC_UYVY	    0x00000080	    //encoder can take any UYVY video as input
#define AM_DVENC_RGB24		0x00000100	    //encoder can take any RGB24 video as input
#define AM_DVENC_RGB565		0x00000200	    //encoder can take any RGB565 video as input
#define AM_DVENC_RGB555		0x00000400	    //encoder can take any RGB555 video as input
#define AM_DVENC_RGB8		0x00000800	    //encoder can take any RGB8 video as input

// Note: V6.4 of the codec has eliminated the #define for AM_DVENC_Y41
// altogether. If they ever add it back, verify that the value has not
// changed. (GetEncoderCapabilities() never did return this as a
// capability, so the capabilities of our filter haven't changed in 
// going to V6.4.)
#define AM_DVENC_Y41P		0x00001000	    //encoder can take any y41p video as input


#define AM_DVENC_DVSD		0x00002000	    //encoder can output dvsd
#define AM_DVENC_DVHD		0x00004000	    //encoder can output dvhd
#define AM_DVENC_DVSL		0x00008000	    //encoder can output dvsl


#define AM_DVENC_DV			0x00010000

#define AM_DVENC_DVCPRO		0x00020000

#define AM_DVENC_AnyWidHei	0x00040000	    //encoder can take any width and height input
#define AM_DVENC_MMX		0x01000000	
#define AM_DVENC_DR219RGB	0x00100000		

				
typedef unsigned long DWORD;

int  InitMem4Encoder(char **ppMem,DWORD dwEncReq);

void TermMem4Encoder(char *pMem);

DWORD GetEncoderCapabilities(  );


//extern "C" int	__fastcall DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );

extern "C" int	__stdcall DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );
//extern "C" int	__cdecl DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvenc\dvenc.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
/******************************Module*Header*******************************\
* Module Name: DVVideo.h
*
* Prototype DV Video codec
*
\**************************************************************************/

#ifndef __DVENC__
#define __DVENC__

extern const AMOVIESETUP_FILTER sudDVEnc;


// link to vfw32.lib to get this function....
extern "C" void WINAPI StretchDIB(
	LPBITMAPINFOHEADER biDst,   //	BITMAPINFO of destination
	LPVOID	lpDst,		    //	The destination bits
	int	DstX,		    //	Destination origin - x coordinate
	int	DstY,		    //	Destination origin - y coordinate
	int	DstXE,		    //	x extent of the BLT
	int	DstYE,		    //	y extent of the BLT
	LPBITMAPINFOHEADER biSrc,   //	BITMAPINFO of source
	LPVOID	lpSrc,		    //	The source bits
	int	SrcX,		    //	Source origin - x coordinate
	int	SrcY,		    //	Source origin - y coordinate
	int	SrcXE,		    //	x extent of the BLT
	int	SrcYE); 	    //	y extent of the BLT


class CDVVideoEnc
	: public CTransformFilter,
	  public IDVEnc,
	  public ISpecifyPropertyPages,
	  public CPersistStream,
	  public IAMVideoCompression,
      public IDVRGB219

{

public:

    //
    // --- Com stuff ---
    //
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
	DECLARE_IUNKNOWN;

    //
    // --- CVideoTransformFilter overrides ---
    //
    HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut);

    HRESULT CheckInputType(const CMediaType* mtIn);
    HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut);
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES * pProperties);
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT StartStreaming(void);
    HRESULT StopStreaming(void);


    // Quality control notifications sent to us
    //HRESULT AlterQuality(Quality q);

    CDVVideoEnc(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *pHr);
    ~CDVVideoEnc();

    // CPersistStream stuff
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);

    // CPersistStream override
    STDMETHODIMP GetClassID(CLSID *pClsid);

    // These implement the custom IDVEnc interface
    STDMETHODIMP get_IFormatResolution(int *iVideoFormat,int *iDVFormat, int *iResolution, BYTE fDVInfo, DVINFO *psDVInfo);
    STDMETHODIMP put_IFormatResolution(int iVideoFormat, int iDVFormat,int iResolution,BYTE fDVInfo, DVINFO *psDVInfo);

    // ISpecifyPropertyPages interface
    STDMETHODIMP GetPages(CAUUID *pPages);

    // IAMVideoCompression methods
    STDMETHODIMP put_KeyFrameRate(long KeyFrameRate) {return E_NOTIMPL;};
    STDMETHODIMP get_KeyFrameRate(long FAR* pKeyFrameRate) {return E_NOTIMPL;};
    STDMETHODIMP put_PFramesPerKeyFrame(long PFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP get_PFramesPerKeyFrame(long FAR* pPFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP put_Quality(double Quality) {return E_NOTIMPL;};
    STDMETHODIMP get_Quality(double FAR* pQuality) {return E_NOTIMPL;};
    STDMETHODIMP put_WindowSize(DWORDLONG WindowSize) {return E_NOTIMPL;};
    STDMETHODIMP get_WindowSize(DWORDLONG FAR* pWindowSize) {return E_NOTIMPL;};
    STDMETHODIMP OverrideKeyFrame(long FrameNumber) {return E_NOTIMPL;};
    STDMETHODIMP OverrideFrameSize(long FrameNumber, long Size)
			{return E_NOTIMPL;};
    STDMETHODIMP GetInfo(LPWSTR pstrVersion,
			int *pcbVersion,
			LPWSTR pstrDescription,
			int *pcbDescription,
			long FAR* pDefaultKeyFrameRate,
			long FAR* pDefaultPFramesPerKey,
			double FAR* pDefaultQuality,
			long FAR* pCapabilities);

    // IDVRGB219 interface
    STDMETHODIMP SetRGB219 (BOOL bState);


private:
    char		*m_pMem4Enc;
    LPBYTE		m_pSample;
    int			m_perfidDVDeliver;

    CCritSec		m_DisplayLock;  // Private play critical section
    int			m_iVideoFormat;
    int			m_iDVFormat;
    int			m_iResolution;
    BYTE		m_fDVInfo;
    DVINFO		m_sDVInfo;
    long		m_lPicWidth;
    long		m_lPicHeight;

    void		SetOutputPinMediaType(const CMediaType *pmt);


    BOOL		    m_fStreaming;
    DWORD		    m_EncCap;	    //what the Enc can do
    DWORD		    m_EncReg;	    //what users want it to do
    char		    m_fConvert;
    char *		    m_pMem4Convert;
    BOOL            m_bRGB219;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvenc\encprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

class CDVEncProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void    GetControlValues();

    CDVEncProperties(LPUNKNOWN lpunk, HRESULT *phr);

    BOOL m_bIsInitialized;				// Used to ignore startup messages
    int m_iPropDVFormat;
    int m_iPropVidFormat;
    int m_iPropResolution;

    IDVEnc *m_pIDVEnc;				// The custom interface on the filter


}; // DVDecProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvenc\pencode.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "encode.h"

int	InitMem4Encoder( char **ppMem, DWORD dwCodecReq )\
{
     *ppMem= new char[720*576*2];   //NULL;
     if (*ppMem)
     {
        **ppMem = 1;       // DvEncodeAFrame uses this field to determine if 
                            // it has initialized ppMem previously. Setting it
                            // to 1 forces the initialization.
        return S_OK;
     }
     else 
         return E_OUTOFMEMORY;
}

void	TermMem4Encoder(char *pMem)
{
     if(pMem!=NULL)
		delete [] pMem;
 }

DWORD GetEncoderCapabilities(  )
{

    DWORD cap;
    cap =   AM_DVENC_Full	|
	    AM_DVENC_DV		| 
	    AM_DVENC_DVCPRO	|
	    AM_DVENC_DVSD	|
	    AM_DVENC_NTSC	|
	    AM_DVENC_PAL	|
	    AM_DVENC_MMX	|
	    AM_DVENC_RGB24     |
            AM_DVENC_RGB565     |
            AM_DVENC_RGB555     |
            AM_DVENC_RGB8;

    return		 cap;
}
/**
int DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwEncReq, char *pMem)
{

	DWORD dwPanReq=0;

	if(dwEncReq & AM_DVENC_RGB24)
		dwPanReq=0x100;
	else
		return ERROR;

	if(dwEncReq & AM_DVENC_NTSC)
		dwPanReq |=0x10000;
	else
		return ERROR;

	if(dwEncReq & AM_DVENC_DVSD)
		dwPanReq |=0x100000;
	else
		return ERROR;


	dwPanReq |=0x10000000;


	yvutrans( (unsigned char * )pMem, pSrc, dwPanReq	);
	
	unsigned short *pTmp;

	pTmp = (unsigned short *)pDst;

	DvEncode(pTmp, (unsigned char * )pMem, dwPanReq	);

     return S_OK;
}
**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvenc\resource.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by display.rc
//
#define IDS_TITLE                       2
#define IDD_DVEnc                       201
#define IDC_NTSC                        2000
#define IDC_PAL                         2001
#define IDC_RESOLUTION                  2006
#define IDC_dvsd                        2007
#define IDC_dvhd                        2008
#define IDC_dvsl                        2009
#define IDC_DVFORMAT                    2010
#define IDC_VIDEOFORMAT                 2011
#define IDC_720x480                     2012
#define IDC_360x240                     2013
#define IDC_180x12                      2014
#define IDC_180x120                     2014
#define IDC_88x60                       2015
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvmux\resource.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by property.rc
//
//#define VERSION_RES_MINOR_VER           0
//#define VERSION_RES_BUILD               0
//#define VER_DEBUG                       0
//#define VERSION_RES_MAJOR_VER           3
#define IDS_DVMUXER_TITLE               3
#define IDD_DVMUX                       300
#define IDC_DVMUX_VIDFORMAT             3022
#define IDC_DVMUX_NTSC                  3023
#define IDC_DVMUX_PAL                   3024
#define IDC_DVMUX_DVFORMAT              3026
#define IDC_DVMUX_DVSD                  3027
#define IDC_DVMUX_DVHD                  3028
#define IDC_DVMUX_DVSL                  3029
//#define VERSION_RES_LANGUAGE            0x409
//#define VERSION_RES_CHARSET             3252
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvmux\dvmux.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


#include <streams.h>
#include <commctrl.h>
#if (1100 > _MSC_VER)
#include <olectlid.h>
#else
#include <olectl.h>
#endif
#include "dvmux.h"
#include "resource.h"


// setup data
const AMOVIESETUP_FILTER sudDVMux =
{ &CLSID_DVMux		// clsID
, L"DV Muxer"		// strName
, MERIT_UNLIKELY	// dwMerit
, 0			// nPins
, NULL   };		// lpPin



HRESULT Copy(
  IMediaSample *pDest,
  IMediaSample *pSource)
{
  {
    // Copy the sample data

    BYTE *pSourceBuffer, *pDestBuffer;
    long lSourceSize	= pSource->GetSize();
    long lDestSize	= pDest->GetSize();

    ASSERT(lDestSize >= lSourceSize);

    pSource->GetPointer(&pSourceBuffer);
    pDest->GetPointer(&pDestBuffer);

    CopyMemory( (PVOID) pDestBuffer, (PVOID) pSourceBuffer, lSourceSize );
  }
  {
    // copy the sample time

    REFERENCE_TIME TimeStart, TimeEnd;

    if (NOERROR == pSource->GetTime(&TimeStart, &TimeEnd)) {
	pDest->SetTime(&TimeStart, &TimeEnd);
    }
  }
  {
    // copy the media time

    REFERENCE_TIME TimeStart, TimeEnd;

    if (NOERROR == pSource->GetMediaTime(&TimeStart, &TimeEnd)) {
	pDest->SetMediaTime(&TimeStart, &TimeEnd);
    }
  }
  {
    // Copy the Sync point property

    HRESULT hr = pSource->IsSyncPoint();
    if (hr == S_OK)
    {
      pDest->SetSyncPoint(TRUE);
    }
    else if (hr == S_FALSE)
    {
      pDest->SetSyncPoint(FALSE);
    }
    else {	// an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }
  {
    // Copy the media type

    AM_MEDIA_TYPE *pMediaType;
    pSource->GetMediaType(&pMediaType);
    pDest->SetMediaType(pMediaType);
    DeleteMediaType( pMediaType );
  }
  {
    // Copy the preroll property

    HRESULT hr = pSource->IsPreroll();
    if (hr == S_OK)
    {
      pDest->SetPreroll(TRUE);
    }
    else if (hr == S_FALSE)
    {
      pDest->SetPreroll(FALSE);
    }
    else {	// an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }
  {
    // Copy the actual data length

    long lDataLength = pSource->GetActualDataLength();
    pDest->SetActualDataLength(lDataLength);
  }

  return NOERROR;
}



/******************************Public*Routine******************************\
* CreateInstance
*
* This goes in the factory template table to create new instances
*
\**************************************************************************/
CUnknown *
CDVMuxer::CreateInstance(
    LPUNKNOWN pUnk,
    HRESULT * phr
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVMuxer::CreateInstance")));
    return new CDVMuxer(TEXT("DV muxer filter"), pUnk,CLSID_DVMux, phr);
}


// =================================================================
// Implements the CDVMuxer class
// =================================================================

// CDVMuxer::CDVMuxer
//
CDVMuxer::CDVMuxer( TCHAR     *pName,
                LPUNKNOWN pUnk,
                CLSID     clsid,
                HRESULT   *phr )
    : CBaseFilter(pName, pUnk, &m_csFilter, clsid)
    , m_pOutput(NULL)				// Output pin
    , m_iInputPinCount(0 ) // Number of input pins, (1 )video pin+ 1 audio pin 
    , m_fMuxStreaming(FALSE)
    , m_iVideoFormat(IDC_DVMUX_NTSC)		//default, it gets reset in inputpin's SetMediatype(
    , m_fWaiting_Audio(FALSE)
    , m_fWaiting_Video(FALSE)
    , m_pExVidSample(NULL)
    , m_MediaTypeChanged(FALSE)
    , m_DVINFOChanged(FALSE)
    , m_TimeFormat(FORMAT_TIME)
    , m_fEOSSent(FALSE)				// Have we sent EOS?
{
    ASSERT(phr != NULL);
    m_LastVidTime=0;
    m_LastVidMediatime=0;

    FillMemory ( m_UsedAudSample, (DWORD)(DVMUX_MAX_AUDIO_PIN*sizeof(LONG)), 0); 

    InitDVInfo();

    for(int i=0; i<DVMUX_MAX_AUDIO_PIN; i++)
    {	
	m_wMinAudSamples[i] =0;
	m_wMaxAudSamples[i] =0;
    }

    if (*phr == NOERROR)
        *phr = CreatePins();
}

HRESULT CDVMuxer::pExVidSample(   IMediaSample ** ppSample, BOOL fEndOfStream )
{
    if(m_pExVidSample==NULL && fEndOfStream==FALSE) // TRUE may not mean 1.
    {
        HRESULT hr = m_pOutput->GetDeliveryBuffer(&m_pExVidSample,NULL,NULL,0);
	if ( FAILED(hr) ) 
	    return hr;

	ASSERT(m_pExVidSample);
    }

    *ppSample	= m_pExVidSample;
    return NOERROR;
}

HRESULT CDVMuxer::InitDVInfo()
{

	//for 1st 5/6 DIF seq.
	m_OutputDVFormat.dwDVAAuxSrc=AM_DV_DEFAULT_AAUX_SRC;
	m_OutputDVFormat.dwDVAAuxCtl=AM_DV_DEFAULT_AAUX_CTL;

	//for 2nd  5/6 DIF seq.
	m_OutputDVFormat.dwDVAAuxSrc1=AM_DV_DEFAULT_AAUX_SRC;
	m_OutputDVFormat.dwDVAAuxCtl1=AM_DV_DEFAULT_AAUX_CTL;

	//for video information
	m_OutputDVFormat.dwDVVAuxSrc=AM_DV_DEFAULT_VAUX_SRC;
	m_OutputDVFormat.dwDVVAuxCtl=AM_DV_DEFAULT_VAUX_CTL;

	return NOERROR;

}


//X
// CDVMuxer::CreatePins
//
// Creates the pins for the DVMux. Override to use different
// pins
HRESULT CDVMuxer::CreatePins()
{
    HRESULT hr = NOERROR;

    // Allocate the output pin
    m_pOutput = new CDVMuxerOutputPin(NAME("DVMuxer output pin"),
                                   this,          // Owner filter
                                   this,          // Route through here
                                   &hr,           // Result code
                                   L"Output");    // Pin name
    if (m_pOutput == NULL)
        hr = E_OUTOFMEMORY;
	
    // Allocate the input pin
    m_apInput = new CDVMuxerInputPin *[DVMUX_MAX_AUDIO_PIN + 1];
    if (m_apInput)
    {
        for (int i=0; i<(DVMUX_MAX_AUDIO_PIN + 1); i++)
	    m_apInput[i]=NULL;
    }
    
    // Allocate the input pin
    m_apInputPin = new CDVMuxerInputPin *[DVMUX_MAX_AUDIO_PIN + 1];
    if (m_apInputPin)
    {
        // Destructor relies on array element being NULL to 
        // determine whether to delete the pin
        for (int i=0; i<(DVMUX_MAX_AUDIO_PIN + 1); i++)
	    m_apInputPin[i]=NULL;
    }


    if ( (m_pOutput ==  NULL) || (m_apInput ==  NULL) || (m_apInputPin ==  NULL) )
        hr = E_OUTOFMEMORY;
    else 
    {
      	//Create One input pin
        m_apInputPin[0]=new CDVMuxerInputPin(NAME("DVMuxer Input pin"),
				    this,       // Owner filter
				    this,       // Route through here
                                    &hr,        // Result code
                                    L"Stream 0", // Pin Name
                                    0);         // Pin Number

        if (m_apInputPin[0] == NULL) 
	    hr = E_OUTOFMEMORY;
	else
    	    m_iInputPinCount++;
    }

    return hr;
}

//X
// destructor
CDVMuxer::~CDVMuxer()
{
    /* Delete the pins */
    if (m_apInputPin) {
	for (int i = 0; i < m_iInputPinCount; i++)
            if (m_apInputPin[i] != NULL)
                delete m_apInputPin[i];

        delete [] m_apInputPin;
	delete [] m_apInput;

    }

    if (m_pOutput)
        delete m_pOutput;

}

//X return the number of pins we provide
int CDVMuxer::GetPinCount()
{
    return m_iInputPinCount + 1;
}


//X return a non-addrefed CBasePin *
CBasePin * CDVMuxer::GetPin(int n)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::GetPin(%d)"), n));

    if (n > m_iInputPinCount) {
        DbgBreak("Bad pin requested");
        return NULL;
    } else if (n == m_iInputPinCount) { // our output pin
        return m_pOutput;
    } else {                            // we are dealing with an input pin
        return m_apInputPin[n];
    }
} // GetPin
//X
HRESULT CDVMuxer::StartStreaming()
{
    
    DbgLog((LOG_TRACE, 2, TEXT("CDVMuxer::StartStreaming()")));

    m_LastVidTime	=0;
    m_LastVidMediatime	=0;

    //Reset	Audio sample count
    FillMemory ( m_UsedAudSample, 
		(DWORD)(DVMUX_MAX_AUDIO_PIN*sizeof(LONG)),
		0); 
	
    m_fWaiting_Audio		=FALSE;
    m_fWaiting_Video            =FALSE;
    m_fEOSSent			= FALSE;

    m_fMuxStreaming		=TRUE;

    //to support audio longer then video case
    ASSERT(m_pExVidSample==NULL);

    for (int i = 0; i < m_iInputPinCount; i ++)
        ASSERT(! m_apInputPin[i]->SampleReady( 1 ) );
            
    for (int iPin=0; iPin < DVMUX_MAX_AUDIO_PIN; iPin++)
    {
	// Note: m_apInput[1..2] contain the audio pins
        // if they are connected. See CompleteConnect,
        // CheckMediaType and Disconnect in CDVMuxerInputPin

        // A call to Reset only serves to batch the same audio  
        // samples with the same DV frames if the file is replayed 
        // by stopping and starting the graph. (And it makes a 
        // difference only for the NTSC locked audio case.)
        // This call (and the Reset function itself) are not essential.

        if (m_apInput[iPin+1] != NULL)
	{
            m_AudSampleSequence[iPin].Reset(m_wMinAudSamples[iPin], m_wMaxAudSamples[iPin]);
        }
    }

    return NOERROR;


}

//X
HRESULT CDVMuxer::StopStreaming()
{
    // Free any media samples that we are holding on to
    // we need to have been locked for this operation
    // (done by Stop)

    CAutoLock waitUntilStoppedSending(&m_csMuxLock);

    DbgLog((LOG_TRACE, 2, TEXT("CDVMuxer::StopStreaming()")));

    ReleaseAllQueuedSamples();

    m_fMuxStreaming		=FALSE;
    m_fWaiting_Audio		=FALSE;
    m_fWaiting_Video            =FALSE;

    if(m_pExVidSample)
    {
	m_pExVidSample->Release();
	m_pExVidSample=NULL;
    }

    return NOERROR;
}

HRESULT CDVMuxer::Receive()
{
   
    IMediaSample    *pSampleOut;
    BYTE	    *pDst;
    CRefTime	    VidStart, VidStop;
    CRefTime	    AudStart[DVMUX_MAX_AUDIO_PIN], AudStop[DVMUX_MAX_AUDIO_PIN];
    BOOL	    fNoVideo=FALSE;
    HRESULT	    hr;
    BOOL	    fNot_VideoEOSReceived=TRUE;
    long lDataLength = 12*150*80;   //PAL
    REFERENCE_TIME TimeStart;

    CAutoLock lock(&m_csMuxLock);
	
    //*************************************************
    //Video has to be connected. Get dv video sample
    //*************************************************
    m_fWaiting_Video = FALSE;
    if (m_apInput[DVMUX_VIDEO_INPUT_PIN]->SampleReady( 1 ) )
    {

    	//get one dv video sample
    	pSampleOut=m_apInput[ DVMUX_VIDEO_INPUT_PIN ]->GetNthSample( 0 );
    	
	//get time stamp
    	pSampleOut->GetTime( (REFERENCE_TIME*)&VidStart,  (REFERENCE_TIME*)&VidStop);		    

	//get data pointer
	pSampleOut->GetPointer( &pDst );
    }
    else
    {
	if ( m_apInput[DVMUX_VIDEO_INPUT_PIN]->m_fEOSReceived)
	{
	    fNoVideo			=TRUE;

	    fNot_VideoEOSReceived	=FALSE;
	    HRESULT hr = m_pOutput->GetDeliveryBuffer(&pSampleOut,NULL,NULL,0);
	    if ( FAILED(hr) ) 
		return hr;

	    ASSERT(pSampleOut);
	    if( m_pExVidSample ==NULL)
            {
                // m_fWaiting_Video should probably be set to TRUE, but this 
                // is unlikely to happen - should happen only if there were 
                // other errors or no video has been received at all
                return NOERROR;
            }
	    else
	    {
		Copy(pSampleOut, m_pExVidSample);

		if( m_iVideoFormat==IDC_DVMUX_NTSC)
		{
		VidStop=m_LastVidTime+ UNITS*1000L/29970L;		//DV has to output 29.97frames/sec if it is NTSC,
		pSampleOut->SetTime( (REFERENCE_TIME*)&m_LastVidTime,  (REFERENCE_TIME*)&VidStop);
		}
		else
		{
		VidStop=m_LastVidTime+ UNITS/25;		//DV has to output 25frames/sec if it is PAL,
		pSampleOut->SetTime( (REFERENCE_TIME*)&m_LastVidTime,  (REFERENCE_TIME*)&VidStop);
		}

		//get time stamp
    		VidStart=m_LastVidTime;
	 
		//get data pointer
		pSampleOut->GetPointer( &pDst );
	    }
	}
	else
        {
	    m_fWaiting_Video = TRUE;
            return NOERROR;	    //waiting for more video
        }

    }



   //*************************************************
    //Audio does not have to be connected. 
    //get Audio Samples
    //*************************************************
    BYTE         *apAudData [DVMUX_MAX_AUDIO_PIN] [DVMUX_MAX_AUDIO_SAMPLES];
    IMediaSample *pAudSample [DVMUX_MAX_AUDIO_PIN] [DVMUX_MAX_AUDIO_SAMPLES ];
    WORD 	 wAudSampleSize [DVMUX_MAX_AUDIO_PIN] [DVMUX_MAX_AUDIO_SAMPLES];
    LONG         nUsedAudSample [DVMUX_MAX_AUDIO_PIN];
    WORD         wAudBlk [DVMUX_MAX_AUDIO_PIN];
    WORD 	 wTotalAudSamples [DVMUX_MAX_AUDIO_PIN];
    int          nNumSamplesProcessed [DVMUX_MAX_AUDIO_PIN];

    BOOL fAud_Mute[DVMUX_MAX_AUDIO_PIN];
    for(int iPin=1; iPin<= DVMUX_MAX_AUDIO_PIN; iPin++)
    {
	fAud_Mute[iPin-1]   = FALSE;
        wTotalAudSamples[iPin-1] = 0;

	//since max audio sample needed per frame=48000*4/30=6400byte
	//init
	for(int j=0; j<DVMUX_MAX_AUDIO_SAMPLES; j++)
	{	
	    apAudData[iPin-1][j]=NULL;
	    wAudSampleSize[iPin-1][j]=0;
	    pAudSample[iPin-1][j]=NULL;
	}

	if ( m_apInput[iPin]!= NULL)
	{
	    ASSERT(m_apInput[iPin]->IsConnected() );

            //fetch enough audio data
	    WAVEFORMATEX *pWave =(WAVEFORMATEX *)m_apInput[iPin]->CurrentMediaType().pbFormat ;

            nUsedAudSample[iPin-1] = m_UsedAudSample[iPin-1];

            // @@@ jaisri:Isn't it safer to use pWave->nBlockAlign?
            wAudBlk[iPin-1] = (pWave->wBitsPerSample) * (pWave->nChannels) >> 3 ;

	    int Ind;
    	    int j=0; // j is an alias for nNumSamplesProcessed[iPin-1]; we
                     // could have declared: int& j = nNumSamplesProcessed[iPin-1]; j = 0;
                     // but this is probably clearer.
            nNumSamplesProcessed[iPin-1] = 0; 

	    do
	    {
FETCH_AGAIN:
		if( m_apInput[iPin]->SampleReady( j+1 )  )
		{
                    if(j)
                       nUsedAudSample[iPin-1]=0;
                                  
		    m_fWaiting_Audio	= FALSE;
		    pAudSample[iPin-1][j]	= m_apInput[ iPin ]->GetNthSample( j );
		    ASSERT( pAudSample[iPin-1][j] !=  NULL);
		
		    int DataLenght=pAudSample[iPin-1][j]->GetActualDataLength();

		    if(!DataLenght)
		    {
			// jaisri: Note: this if clause was added to fix bug 32702 or bug 33821
                        // in some database. Which one? (in v38 of \\faulty\slm, amovie\filters\dv\dvmux.)
                        // Ideally, this this condition should be handled
                        // below rather than being special cased.

                        //this is zero length audio bufer. It just tells us that there 
			// is no audio during AudStart[iPin-1], VidStart 
			pAudSample[iPin-1][j]->GetTime( (REFERENCE_TIME*)&AudStart[iPin-1],  (REFERENCE_TIME*)&AudStop[iPin-1] );

			//release all audio samples before this one and this one
			m_UsedAudSample[iPin-1] = nUsedAudSample[iPin-1] = 0;
			m_apInput[ iPin ]->ReleaseNSample(j+1);
			
		    	if( AudStart[iPin-1] >= VidStart ) 
			{			    
                            // @@@ jaisri: How is this justified if j > 0?
                            // And shouldn't the comparison be with VidStop?

                            //if audio start is later than video start , there is no audio for this dv frame			//video should always continoues(no time gap)
		    	    fAud_Mute[iPin-1]=TRUE;
			    break;      // goto SET_AAUX;
			}
			else
			{
			    // @@@ jaisri: Shouldn't we check AudStop[iPin-1] v/s VidStart if j == 0?
                            goto WAITING_AUDIO; 
			    //allow video waiting longer for more audio
			}
		    }

		    ASSERT( DataLenght >= nUsedAudSample[iPin-1] );

		    //get audio data buffer
		    pAudSample[iPin-1][j]->GetPointer( &apAudData[iPin-1][j] );

	    
		    if(!j){	    //get rid of already muxed audio samples
			pAudSample[iPin-1][j]->GetTime( (REFERENCE_TIME*)&AudStart[iPin-1],  (REFERENCE_TIME*)&AudStop[iPin-1] );
			apAudData[iPin-1][j] += nUsedAudSample[iPin-1] ;
			if( nUsedAudSample[iPin-1] )
			    AudStart[iPin-1] += ( nUsedAudSample[iPin-1] *(AudStop[iPin-1]-AudStart[iPin-1]) /pAudSample[iPin-1][j]->GetActualDataLength() ); 

			//if audio is much later than video , do not mux audio in this DV frame frame
			//video should always continoues(no time gap)
		    	if( AudStart[iPin-1] >= VidStop ) 
			{
			    ASSERT(nUsedAudSample[iPin-1] == 0);
                            fAud_Mute[iPin-1]=TRUE;
			    break;                  // goto SET_AAUX;
			}
			//if audio is much earlier than video, release this sample
			//get another one
			if( AudStop[iPin-1] <= VidStart)
			{
	    		    m_apInput[ iPin ]->ReleaseNSample(1);
			    m_UsedAudSample[iPin-1] = nUsedAudSample[iPin-1] = 0;

                            // Manbugs # 32869
                            apAudData[iPin-1][0] = NULL;
                            pAudSample[iPin-1][0] = NULL;
			    goto FETCH_AGAIN;
			}
		
		    }

		    //get audio samples left in the buffer 
		    if(!j)  //first sample
		    {
			wTotalAudSamples[iPin-1]=(WORD) ( (pAudSample[iPin-1][j]->GetActualDataLength() - nUsedAudSample[iPin-1])/wAudBlk[iPin-1] );
			wAudSampleSize[iPin-1][j] = wTotalAudSamples[iPin-1];
		    }
		    else    //2nd sample or 3rd sample
		    {
	    		wAudSampleSize[iPin-1][j] =(WORD) ( pAudSample[iPin-1][j]->GetActualDataLength()/wAudBlk[iPin-1] );
			wTotalAudSamples[iPin-1] += wAudSampleSize[iPin-1][j];
		    }

		    //how many samples we need
		    if(  ( wTotalAudSamples[iPin-1] >= m_wMinAudSamples[iPin-1] ) &&  ( wTotalAudSamples[iPin-1] <=	m_wMaxAudSamples[iPin-1] ) )
		    {
		        //Sample rate is right, we take all samples
		        nUsedAudSample[iPin-1]  = 0;
			break;
		    }
		    else if(   wTotalAudSamples[iPin-1] > m_wMaxAudSamples[iPin-1] )
		    {
		        //too many audio samples
			WORD wTmp;
			if(!j)
			{	
			    // @@@ jaisri: makes more sense to compare AudStop[iPin-1] and VidStop??
                            if( (VidStart >= AudStart[iPin-1] ) ) // || ( AudStop[iPin-1] <= VidStop ) )
			        wAudSampleSize[iPin-1][j]=m_wMaxAudSamples[iPin-1];	    //lot of audio sample are needed to be muxed
			    else
			        wAudSampleSize[iPin-1][j]=m_wMinAudSamples[iPin-1];
				
			    nUsedAudSample[iPin-1] +=(wAudSampleSize[iPin-1][j]*wAudBlk[iPin-1]);   //can not use wTmp because it may not wAudBlk[iPin-1] Aligned
			    ASSERT( pAudSample[iPin-1][j]->GetActualDataLength() > nUsedAudSample[iPin-1] );
			    wTotalAudSamples[iPin-1]=wAudSampleSize[iPin-1][j];
				
			}
			else
			{
			   
                            if( (VidStart >= AudStart[iPin-1] ) ) // || ( AudStop[iPin-1] <= VidStop ) ) - note AudStop[iPin-1] is not currently updated for j = 1, 2, ...
			    {
			        wAudSampleSize[iPin-1][j]=m_wMaxAudSamples[iPin-1]-(wTotalAudSamples[iPin-1] -wAudSampleSize[iPin-1][j]);
			    }
			    else
			    {
				wAudSampleSize[iPin-1][j]=m_wMinAudSamples[iPin-1] -(wTotalAudSamples[iPin-1] -wAudSampleSize[iPin-1][j]);
			    }
				
			    ASSERT(wAudSampleSize[iPin-1][j]>0);

			    nUsedAudSample[iPin-1]  =wAudSampleSize[iPin-1][j]*wAudBlk[iPin-1];
			    ASSERT( pAudSample[iPin-1][j]->GetActualDataLength() >= nUsedAudSample[iPin-1] );
			    if( pAudSample[iPin-1][j]->GetActualDataLength() ==nUsedAudSample[iPin-1])
			        nUsedAudSample[iPin-1]=0;

			    Ind=0;
			    wTotalAudSamples[iPin-1]=0;
			    do
			    {
				wTotalAudSamples[iPin-1]+=wAudSampleSize[iPin-1][Ind];
			    } while(Ind++<j);
			}
			break;
	    	    }
		    else
		    {
			//not enough sample
			//nUsedAudSample[iPin-1]=0;
			ASSERT(  wTotalAudSamples[iPin-1] < m_wMaxAudSamples[iPin-1]  );
		    }
		}
		else  //if( m_apInput[iPin]->SampleReady( j+1 )  )
		{
		    if( m_apInput[ iPin ]->m_fEOSReceived)
		    {
		    	m_fWaiting_Audio=TRUE;
	   		if(j)	 //if we are fetch (j+1) nd sample, 
			{
			    // jaisri: Following assertion will not hold for locked audio.
                            // For unlocked audio, all audio samples will typically be used
                            // since each DV frame can hold a range of samples. For locked 
                            // audio, each DV frame can hold only a fixed number of samples.
                            // So a few samples could be bumped at the end of the stream.

                            // We should really keep a member variable that tells us if
                            // audio is locked - could add "m_bLocked ||" to this assertion

                            // ASSERT( apAudData[iPin-1][0] !=NULL   &&  !nUsedAudSample[iPin-1]  );

			    m_UsedAudSample[iPin-1] = nUsedAudSample[iPin-1] = 0;
			    //since it is end of Received release existing samples
			    m_apInput[ iPin ]->ReleaseNSample(j);
			}
			else
			{
			    ASSERT(!j);
			    ASSERT(apAudData[iPin-1][0]==NULL);
			}
			    
			//this audio pin is not going to receive audio anymore 			
			fAud_Mute[iPin-1]=TRUE;
			if(m_apInput[DVMUX_VIDEO_INPUT_PIN]->m_fEOSReceived)
                        {
			    // @@@ jaisri: hr is not initialized and is returned.
                            // Note that m_fWaiting_Audio is set to TRUE.

                            // Don't understand why this is done anyway. What if
                            // the other pin has audio to be processed?
                            // goto RELEASE;

                            // ============ Changed to following:

                            // jaisri: The goto RELEASE caused an infinite loop: Pin 1 has got 
                            // end of stream, Pin 2 just received end of stream and
                            // is calling this function from CDVMuxerInputPin::EndOfStream

                            // The worst thing that can happen if we remove this goto
                            // is that one extra video frame gets delivered, and, in 
                            // the case that only 1 pin is connected, it has no audio.

                            break;  // This is equivalent to the old "goto SET_AAUX"
                        }
			else
                        {
			    break;  // goto SET_AAUX;
                        }
		    }
		    else
		    {	
WAITING_AUDIO:
			//not enough audio for this frame, have to wait for more audio
			m_fWaiting_Audio=TRUE;
			if(fNot_VideoEOSReceived==FALSE)
			    pSampleOut->Release();

		    	return Waiting_Audio;
		    }
		}

                // @@@ jaisri: What is the rationale for choosing 
                // DVMUX_MAX_AUDIO_SAMPLES = 3? Also, what's the
                // guarantee that j won't become DVMUX_MAX_AUDIO_SAMPLES
                // and we drop out of the loop here when we don't
                // have the minimum number of samples for the video 
                // frame?

		j++;
                nNumSamplesProcessed[iPin-1]++;

	    } while (j< DVMUX_MAX_AUDIO_SAMPLES);

        } // if ( m_apInput[i]->IsConnected() )

    } // for iPin

    // We now have determined that we have sufficient
    // audio samples (for both pins) for this DV frame
    for(int iPin=1; iPin<= DVMUX_MAX_AUDIO_PIN; iPin++)
    {
	if ( m_apInput[iPin]!= NULL)
	{
	    int j = nNumSamplesProcessed[iPin-1];

            //*************************************************
	    //we do get enough audio sample for this frame
	    //*************************************************
	    
            m_UsedAudSample[iPin-1] = nUsedAudSample[iPin-1];

	    if (!fAud_Mute[iPin-1])
            {
                //*************************************************
	        //mux audio from the audio pin(iPin) to the dv video sample
	        //*************************************************
	        ASSERT( AudStop[iPin-1] > VidStart);    //check audio sample rate is too heigh
	        ASSERT( VidStop > AudStart[iPin-1]);    //check whether audio sample rate is too low
	        ASSERT( ( wTotalAudSamples[iPin-1] >= m_wMinAudSamples[iPin-1] ) &&  ( wTotalAudSamples[iPin-1] <= m_wMaxAudSamples[iPin-1] ) );

                ScrambleAudio(pDst, apAudData[iPin-1], (iPin-1), wAudSampleSize[iPin-1]);

                #if defined(DEBUG) && (DVMUX_MAX_AUDIO_SAMPLES != 3)
                #error DbgLog assumes DVMUX_MAX_AUDIO_SAMPLES is 3; change it.
                #endif

                DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Receive: iPin=%d, Delivered %d=%d+%d+%d samples"),
                        iPin, wTotalAudSamples[iPin-1], wAudSampleSize[iPin-1][0], wAudSampleSize[iPin-1][1], wAudSampleSize[iPin-1][2]
                        ));

                //*************************************************
	        //release audio samples
	        // we have j+1 audio media samples will be used by muxing
	        // when we have one sample,j=0
	        // when we have n sample, j=n-1;
	        //*************************************************
	        if( !m_UsedAudSample[iPin-1] )
	        {	
		    //all audio in j+1 samples will be used, release all of them
    		    ASSERT(apAudData[iPin-1][j] !=NULL );
	            m_apInput[ iPin ]->ReleaseNSample(j+1); 

                    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Receive: iPin=%d, No unused samples"), iPin));
	        }
	        else
	        {
		    //only used j+1-1 sample

                    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Receive: iPin=%d, %d unused samples, j = %d"),
                        iPin, (pAudSample[iPin-1][j]->GetActualDataLength()-m_UsedAudSample[iPin-1])/wAudBlk[iPin-1], j));


                    if( (j-1) >= 0 )  //when j=0, we do not release sample
	    	        m_apInput[ iPin ]->ReleaseNSample(j);
	        }	     
            }
        }
    }

// SET_AAUX:   // label is no longer used

    // Manbugs 47563. Sonic Foundry relied on the DV mux not clobbering the audio in the
    // DV stream when no audio pins were connected. This was the pre-DX8 behavior. The
    // if below restores that behavior.
    //
    // Note that, if the output is played on the PC, there won't be audio - this is 
    // determined by the output pin's connection format, not by the DV stream headers.
    // This is the way it has always been.
    if (m_apInput[1] != NULL || m_apInput[2] != NULL)
    {
        // Manbugs 37710:If we don't write audio to an audio block, make sure
        // that we zap the audio headers. This is a departure from Win ME and 
        // previous versions of the mux (which never zapped the header if no 
        // audio pins were connected and sometimes did it wrong if an audio pin
        // was connected). If we didn't do this and played this dv to a camcorder, 
        // it would still see the old audio (i.e., the audio that was in the video stream).
        // On the PC, the connection format is used to determine the audio 
        // streams, and the "old" (unzapped) audio in the video stream is totally 
        // masked out. So we had conflicting behavior if the dv was rendered to a 
        // camcorder v/s rendered on the PC.
        //
        // While we are at it, we've removed a few deviations from the Blue Book that
        // the code previously had, fixed the bug mentioned above and one other, and 
        // simplified the code some. Note that we always write the pack headers to all 
        // DIF sequences now, independent of pin connections.

        //*************************************************
        //set audio sample size(AAUX source pack)
        //*************************************************    

        int iPos=0;
        int DifCnt=10;
        if ((m_OutputDVFormat.dwDVVAuxSrc & AM_DV_AUDIO_5060))
        {
	    // PAL
            DifCnt=12;
        }

        // Write AuxSrc and AuxCtl to each DIF sequence in the first audio block. The first audio 
        // block contains half the DIF sequences. Note: The terms "track" (which is extensively
        // used in the Blue Book) and "DIF sequence" are synonymous - see Table 42 in Part 2 of 
        // the Blue Book.

        DWORD dwAAuxSrc = m_OutputDVFormat.dwDVAAuxSrc;
        DWORD dwAAuxCtl = m_OutputDVFormat.dwDVAAuxCtl;
        DWORD dwNumSamples = 0;

        // Make sure that AF_SIZE is not set in m_OutputDVFormat.dwDVAAuxSrc
        ASSERT((dwAAuxSrc & AM_DV_AUDIO_AFSIZE) == 0);
        dwAAuxSrc &= ~AM_DV_AUDIO_AFSIZE; // zap it if it is

        // Determine if the first audio block is muted. Note that
        // the first audio block's audio is got from 
        // m_apInput[DVMUX_VIDEO_INPUT_PIN+1] if that pin is connected.
        // If it is not connected and m_apInput[DVMUX_VIDEO_INPUT_PIN+2]
        // has stereo, 16 bit 44.1 or 48KHz audio, it is got from the second pin.
        // (Note that 32K, 16 bit stereo audio is recorded in SD 4ch mode.)

        if (m_apInput[DVMUX_VIDEO_INPUT_PIN+1] == NULL)
        {
            // The pin is not connected
            if ((dwAAuxSrc & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO)
            {
                // The audio block is determined by the other audio pin
                fAud_Mute[0] = fAud_Mute[1];

	        if (!fAud_Mute[0])
	        {
                    ASSERT( wTotalAudSamples[1] >= m_wMinAudSamples[1]  );
                    ASSERT( wTotalAudSamples[1] <=	m_wMaxAudSamples[1]  );
                    dwNumSamples = wTotalAudSamples[1] - m_wAudSamplesBase[1];  		
	        }
	        else
	        {
                    // dwNumSamples is not used even for the JVC camera workaround
                    // because both audio blocks are muted. Anyway, assert it is 0.
                    ASSERT(dwNumSamples == 0);
	        }       

            }
            else
            {
                // The audio block has no audio, so we are muted
                fAud_Mute[0] = TRUE;

                // dwNumSamples is unused

                // Now it is used for the JVC camera workaround - see
                // below. The value should be 0.

                ASSERT(dwNumSamples == 0);
            }

        }
        else
        {
            // Assert we have audio in this block if the pin is connected
            ASSERT((dwAAuxSrc & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO);

            // The pin is connected. fAud_Mute[0] has been set correctly
            if (!fAud_Mute[0])
            {
	        ASSERT( wTotalAudSamples[0] >= m_wMinAudSamples[0]  );
	        ASSERT( wTotalAudSamples[0] <=	m_wMaxAudSamples[0]  );
                dwNumSamples = wTotalAudSamples[0] - m_wAudSamplesBase[0];
            }
            else
            {
                // dwNumSamples is unused

                // Now it is used for the JVC camera workaround - see
                // below. The value should be 0.

                ASSERT(dwNumSamples == 0);
            }
        }

        // Update the src and ctl packs
        if (fAud_Mute[0])
        {
            dwAAuxSrc |= AM_DV_AUDIO_NO_AUDIO;
            dwAAuxCtl |= AM_DV_AAUX_CTL_IVALID_RECORD; // REC_MODE = 0x111
        }
        else
        {
            // Set AF_SIZE in the source pack
            dwAAuxSrc |= dwNumSamples;
        }

        for (int i = 0; i < DifCnt/2; i++)
        {
	    unsigned char *pbTmp;

	    pbTmp = pDst + 483 + i*12000;  //6*80+3=483, 150*80=12000

	    if (i % 2)
            {
                // Odd track. Src goes in pack 0 and Ctl in pack 1
            
                // We leave this in for compatibility with the old code;

                // Check if pack 3 has Aux source
                if ( *(pbTmp + 3*16*80) == 0x50 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 3*16*80, 0xff, 5);
                }
            
                // Check if pack 4 has Aux control
                if ( *(pbTmp + 4*16*80) == 0x51 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 4*16*80, 0xff, 5);
                }
            }
            else
            {
                // Even track. Src goes in pack 3, Ctl in pack 4.

                // We leave this in for compatibility with the old code;

                // Check if pack 0 has Aux source
                if ( *(pbTmp) == 0x50 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp, 0xff, 5);
                }
            
                // Check if pack 1 has Aux control
                if ( *(pbTmp + 1*16*80) == 0x51 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 1*16*80, 0xff, 5);
                }

                // Position at pack 3
                pbTmp += 3*16*80;
            }

	    // Set Src pack
            *pbTmp=0x50;
	    *(pbTmp+1)=(BYTE)(  dwAAuxSrc	& 0xff );
	    *(pbTmp+2)=(BYTE)( (dwAAuxSrc >>8)	& 0xff );
	    *(pbTmp+3)=(BYTE)( (dwAAuxSrc >>16)	& 0xff );
	    *(pbTmp+4)=(BYTE)( (dwAAuxSrc >>24)	& 0xff );

	    // Set Ctl pack
	    pbTmp += (16*80);

            *pbTmp=0x51;
	    *(pbTmp+1)=(BYTE)(  dwAAuxCtl	& 0xff );
	    *(pbTmp+2)=(BYTE)( (dwAAuxCtl >>8)	& 0xff );
	    *(pbTmp+3)=(BYTE)( (dwAAuxCtl >>16)	& 0xff );
	    *(pbTmp+4)=(BYTE)( (dwAAuxCtl >>24)	& 0xff );	
        }

        // Now write AuxSrc and AuxCtl to each DIF sequence in the second audio block. 

        dwAAuxSrc = m_OutputDVFormat.dwDVAAuxSrc1;
        dwAAuxCtl = m_OutputDVFormat.dwDVAAuxCtl1;

        // Manbugs 44568. In the case that audio block 1 has audio and audio
        // block 2 has no audio, JVCs want the number of audio samples (the AF_SIZE
        // field) in the audio two blocks to be the same, else they stutter.
        // Don't know what they do if there are two independent tracks and 
        // each has a different number of audio samples. Anyway, work around
        // their bug in the case we can.
        //
        // (Note that we don't allow audio block 2 to have audio if audio block
        // 1 has no audio. So we don't need to worry about setting the AF_SIZE
        // field of audio block 1 to the number of samples in audio block 2.)

        DWORD dwNumSamplesFirstAudioBlock = dwNumSamples;

        dwNumSamples = 0;

        // Make sure that AF_SIZE is not set in m_OutputDVFormat.dwDVAAuxSrc1
        ASSERT((dwAAuxSrc & AM_DV_AUDIO_AFSIZE) == 0);
        dwAAuxSrc &= ~AM_DV_AUDIO_AFSIZE; // zap it if it is

        // Determine if the second audio block is muted. Note that
        // the second audio block's audio is got from 
        // m_apInput[DVMUX_VIDEO_INPUT_PIN+2] if that pin is connected.
        // If it is not connected and m_apInput[DVMUX_VIDEO_INPUT_PIN+1]
        // has stereo, 16 bit 44.1 or 48KHz audio, it is got from the first pin.
        // (Note that 32K, 16 bit stereo audio is recorded in SD 4ch mode.)

        if (m_apInput[DVMUX_VIDEO_INPUT_PIN+2] == NULL)
        {
            // The pin is not connected
            if ((dwAAuxSrc & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO)
            {
                // The audio block is determined by the other audio pin
                fAud_Mute[1] = fAud_Mute[0];

	       if (!fAud_Mute[1])
	        {
		        ASSERT( wTotalAudSamples[0] >= m_wMinAudSamples[0]  );
		        ASSERT( wTotalAudSamples[0] <=	m_wMaxAudSamples[0]  );
		        dwNumSamples = wTotalAudSamples[0] - m_wAudSamplesBase[0];  	
	        }
	        

        }
        else
        {
            // The audio block has no audio, so we are muted
            fAud_Mute[1] = TRUE;
            // dwNumSamples is unused
        }


        }
        else
        {
            // Assert we have audio in this block if the pin is connected
            ASSERT((dwAAuxSrc & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO);

            // The pin is connected. fAud_Mute[1] has been set correctly
            if (!fAud_Mute[1])
            {
	        ASSERT( wTotalAudSamples[1] >= m_wMinAudSamples[1]  );
	        ASSERT( wTotalAudSamples[1] <=	m_wMaxAudSamples[1]  );
                dwNumSamples = wTotalAudSamples[1] - m_wAudSamplesBase[1];
            }
            else
            {
                // dwNumSamples is unused
            }
        }

        // Update the src and ctl packs
        if (fAud_Mute[1])
        {
            // OR'ing dwNumSamplesFirstAudioBlock is for JVCs and Thomsons,
            // see note above.

            dwAAuxSrc |= AM_DV_AUDIO_NO_AUDIO | dwNumSamplesFirstAudioBlock;
            dwAAuxCtl |= AM_DV_AAUX_CTL_IVALID_RECORD; // REC_MODE = 0x111
        }
        else
        {
            // Set AF_SIZE in the source pack
            dwAAuxSrc |= dwNumSamples;
        }

        ASSERT(i == DifCnt/2);
        for (; i < DifCnt; i++)
        {
	    unsigned char *pbTmp;

	    pbTmp = pDst + 483 + i*12000;  //6*80+3=483, 150*80=12000

	    if (i % 2)
            {
                // Odd track. Src goes in pack 0 and Ctl in pack 1
            
                // We leave this in for compatibility with the old code;

                // Check if pack 3 has Aux source
                if ( *(pbTmp + 3*16*80) == 0x50 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 3*16*80, 0xff, 5);
                }
            
                // Check if pack 4 has Aux control
                if ( *(pbTmp + 4*16*80) == 0x51 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 4*16*80, 0xff, 5);
                }
            }
            else
            {
                // Even track. Src goes in pack 3, Ctl in pack 4.

                // We leave this in for compatibility with the old code;

                // Check if pack 0 has Aux source
                if ( *(pbTmp) == 0x50 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp, 0xff, 5);
                }
            
                // Check if pack 1 has Aux control
                if ( *(pbTmp + 1*16*80) == 0x51 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 1*16*80, 0xff, 5);
                }

                // Position at pack 3
                pbTmp += 3*16*80;
            }

	    // Set Src pack
            *pbTmp=0x50;
	    *(pbTmp+1)=(BYTE)(  dwAAuxSrc	& 0xff );
	    *(pbTmp+2)=(BYTE)( (dwAAuxSrc >>8)	& 0xff );
	    *(pbTmp+3)=(BYTE)( (dwAAuxSrc >>16)	& 0xff );
	    *(pbTmp+4)=(BYTE)( (dwAAuxSrc >>24)	& 0xff );

	    // Set Ctl pack
	    pbTmp += (16*80);

            *pbTmp=0x51;
	    *(pbTmp+1)=(BYTE)(  dwAAuxCtl	& 0xff );
	    *(pbTmp+2)=(BYTE)( (dwAAuxCtl >>8)	& 0xff );
	    *(pbTmp+3)=(BYTE)( (dwAAuxCtl >>16)	& 0xff );
	    *(pbTmp+4)=(BYTE)( (dwAAuxCtl >>24)	& 0xff );	
        }
    }


    
    // in the future, vidaux or audaux or text can be muxed in

    //in order to hear audio when we dump these DV frame to camcorder, 
    //VAUX's contrl REC MODE can no be 0x111
    
    if( (*(pDst+3*80+3) != 0x60 ) && ( *(pDst+5*80+3+9*5)!=0x60 ) )//VAUX source pack header
    {
	DWORD dwAAuxSrc;
	unsigned char *pbTmp;
	pbTmp=pDst+3*80+3;
	*pbTmp=0x60;

	dwAAuxSrc=m_OutputDVFormat.dwDVVAuxSrc;		    

	*(pbTmp+1)=(BYTE)(  dwAAuxSrc	& 0xff );
	*(pbTmp+2)=(BYTE)( (dwAAuxSrc >>8)	& 0xff );
	*(pbTmp+3)=(BYTE)( (dwAAuxSrc >>16)	& 0xff );
	*(pbTmp+4)=(BYTE)( (dwAAuxSrc >>24)	& 0xff );

	*(pbTmp+5)=0x61;

	dwAAuxSrc=m_OutputDVFormat.dwDVVAuxCtl;		    
	*(pbTmp+6)=(BYTE)(  dwAAuxSrc	& 0xff );
	*(pbTmp+7)=(BYTE)( (dwAAuxSrc >>8)	& 0xff );
	*(pbTmp+8)=(BYTE)( (dwAAuxSrc >>16)	& 0xff );
	*(pbTmp+9)=(BYTE)( (dwAAuxSrc >>24)	& 0xff );
    }
    
    //for audio is longer then video case
    if(	( fNoVideo == TRUE  )					    &&    //no video
	( (m_apInput[DVMUX_VIDEO_INPUT_PIN+1] ==NULL ) ||  fAud_Mute[0] ) &&
	( (m_apInput[DVMUX_VIDEO_INPUT_PIN+2] ==NULL ) ||  fAud_Mute[1] ) )
    {
	if(fNot_VideoEOSReceived==FALSE)
	    pSampleOut->Release();

	return NOERROR;

    }

	
    //deliver muxed sample
    pSampleOut->SetSyncPoint(TRUE);	//to let AVI muxer know that very frame is a key frame


    if( m_MediaTypeChanged )
    {
	CMediaType cmt(m_pOutput->CurrentMediaType());
	DVINFO *pdvi = (DVINFO *) cmt.AllocFormatBuffer(sizeof(DVINFO));
	if (NULL == pdvi) {
	    if(fNot_VideoEOSReceived==FALSE)
		pSampleOut->Release();

	    return(E_OUTOFMEMORY);
	}

	memcpy(pdvi, &m_OutputDVFormat, sizeof(DVINFO));

	pSampleOut->SetMediaType(&cmt);
	m_MediaTypeChanged=FALSE;
    }

    //SET data length
    if( m_iVideoFormat==IDC_DVMUX_NTSC)
	lDataLength = 10*150*80;    //NTSC

    pSampleOut->SetActualDataLength(lDataLength);

    //set mediatime
    TimeStart=m_LastVidMediatime++;
    pSampleOut->SetMediaTime(&TimeStart, &m_LastVidMediatime);
    
    //if this is first sample and AAUX is difference than default
    if (m_DVINFOChanged==TRUE) 
    {
	CMediaType cmt(m_pOutput->CurrentMediaType());
	//set audio mediatype 
	pSampleOut->SetMediaType(&cmt);
	m_DVINFOChanged=FALSE;
    }
	
		
    hr = m_pOutput->Deliver(pSampleOut);

    for (iPin=0; iPin < DVMUX_MAX_AUDIO_PIN; iPin++)
    {
	// Note: m_apInput[1..2] contain the audio pins
        // if they are connected. See CompleteConnect,
        // CheckMediaType and Disconnect in CDVMuxerInputPin

        if (m_apInput[iPin+1] != NULL)
	{
            m_AudSampleSequence[iPin].Advance(m_wMinAudSamples[iPin], m_wMaxAudSamples[iPin]);
        }
    }

// RELEASE:     // label not used any more
    //release video sample from list
    if(fNot_VideoEOSReceived==TRUE )	    //release sample in the queue
	m_apInput[ DVMUX_VIDEO_INPUT_PIN ]->ReleaseNSample(1);
    else
    {	//release sample which we just copied from m_pExVidSample
	m_LastVidTime =VidStop;
	pSampleOut->Release();
    }

    return hr;
}

// ReleaseAllQueuedSamples
// - release all samples which are held on our input pins
HRESULT CDVMuxer::ReleaseAllQueuedSamples(void)
{
    // Calls ReleaseHeadSample (as opposed to m_SampleList.RemoveAll)
    // to ensure that we actually release the sample
    for (int i = 0; i < m_iInputPinCount; i ++)
        while (m_apInputPin[i]->SampleReady( 1 ))
	    m_apInputPin[i]->ReleaseNSample(1);

    return NOERROR;
}

//X
HRESULT CDVMuxer::DeliverEndOfStream()
{
    if( m_fEOSSent )
        return NOERROR;

    CAutoLock lock(&m_csMuxLock);

    ASSERT(m_apInput[DVMUX_VIDEO_INPUT_PIN]->m_fEOSReceived);
    ASSERT( !m_apInput[DVMUX_VIDEO_INPUT_PIN]->SampleReady( 1 ) ); //no input dv video sample in the queue
    m_pOutput->DeliverEndOfStream();
    m_fEOSSent = TRUE;

    return NOERROR;
}

//X
// only input video pin call this func to pass flush to down stream .
// filter enter flush state. Receives already blocked
HRESULT CDVMuxer::BeginFlush(void)
{
    // check we are able to receive commands
    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        return hr;
    }

    // call downstream
    return m_pOutput->DeliverBeginFlush();
}

//X
// leave flush state.
HRESULT CDVMuxer::EndFlush(void)
{
    // check we are able to receive commands

    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        return hr;
    }

    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::EndFlush()")));
    // sync with pushing thread -- we have no worker thread

    // caller (the input pin's method) will unblock Receives

    // call EndFlush on downstream pins
    return m_pOutput->DeliverEndFlush();

}


//X check we are in a position to change state
HRESULT CDVMuxer::CanChangeState()
{
    // check we have a valid input connection(s)

    // we don't lock. If the caller requires the state not to change
    // after the check then they must provide the lock

    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::CanChangeState(...)")));

    //if at lease one iput pin is connected and the output pin is also connected, 
    // video pin has to be connected and
    // video's input format has to be correct, 
    if ( ( ( m_apInput[DVMUX_VIDEO_INPUT_PIN +1] != NULL ) ||
	   ( m_apInput[DVMUX_VIDEO_INPUT_PIN+2]	!= NULL )  ||
	   ( m_apInput[DVMUX_VIDEO_INPUT_PIN]	!= NULL )     ) &&   //at least one input pin is connected
	 ( m_pOutput->IsConnected()			      ) &&   //output pin is connected
	 ( ( m_apInput[DVMUX_VIDEO_INPUT_PIN] == NULL ) ||
	   ( !m_apInput[DVMUX_VIDEO_INPUT_PIN]->m_mt.IsValid()) )
	)
        return E_FAIL;


    // check we have a valid output connection if output is connected
    if ( m_pOutput->IsConnected()    &&
	 (!m_pOutput->m_mt.IsValid()   )  )
        return E_FAIL;

    return NOERROR;
}


//X
STDMETHODIMP CDVMuxer::Stop()
{
    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Stop(...)")));
    CAutoLock l(&m_csFilter);

    // Is there any change needed
    if (m_State == State_Stopped) {
        return NOERROR;
    }

    // Succeed the Stop if we are not completely connected
    if( !m_pOutput || !m_pOutput->IsConnected() ){
        m_State = State_Stopped;
        return NOERROR;
    }

    // decommit the input pins before locking or we can deadlock
    for( int iPin = 0; iPin < m_iInputPinCount; iPin++ )
    {
	    if(m_apInputPin[iPin]->IsConnected())
	    {    
            m_apInputPin[iPin]->Inactive();
            m_apInputPin[iPin]->m_fEOSReceived =TRUE;
        }
    }

    // synchronize with Receive calls
    m_pOutput->Inactive();
    
    //input pin's 
    for( iPin = 0; iPin < m_iInputPinCount; iPin++ )
    {
	if(m_apInputPin[iPin]->IsConnected())
	{
	    CAutoLock lck2(&m_apInputPin[iPin]->m_csReceive);
	}
    }


    // check we can change state
    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        return hr;
    }

    // allow a class derived from CDVMuxer
    // to know about starting and stopping streaming
    hr = StopStreaming();
    if (FAILED(hr)) {
        return hr;
    }

    // reset m_iLeadPin in case it changed
    //m_iLeadPin = m_iStartingLeadPin;

    // do the state transition
    return CBaseFilter::Stop();
}


STDMETHODIMP CDVMuxer::Pause()
{
    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Pause(...)")));
    CAutoLock l(&m_csFilter);

    // Is there any change needed
    if (m_State == State_Paused) {
        return NOERROR;
    }

    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Pause(...)")));

    //if any input pin is connected and output pin is also connected, 
    //video pin is no connected, refuse muxing
    if( ( (m_apInput[DVMUX_VIDEO_INPUT_PIN+1] !=NULL) ||
	  (m_apInput[DVMUX_VIDEO_INPUT_PIN+2] !=NULL) ||
	  (m_apInput[DVMUX_VIDEO_INPUT_PIN]   !=NULL)   )  &&
	( m_pOutput->IsConnected()		        )  &&
	( m_apInput[DVMUX_VIDEO_INPUT_PIN] ==NULL)
      )
	return VFW_E_NOT_CONNECTED;

    // Manbugs 37710. If the audio mode of the first audio block (CH1) is
    // 0xf (first audio block has no audio), the audio mode of the second audio 
    // block (CH2) must also be 0xf (per the Blue Book).
    //
    // For us, m_iPinNo == DVMUX_VIDEO_INPUT_PIN+1 has the first audio block
    // and DVMUX_VIDEO_INPUT_PIN+2 has the second audio block. The only exception
    // to this is when DVMUX_VIDEO_INPUT_PIN+1 is not connected and 
    // DVMUX_VIDEO_INPUT_PIN+2 carries 16 bit, stereo, 48KHz or 44.1KHz audio
    // (Note that we always write 32KHz 16 bit stereo audio in SD 4ch mode.)
    // Rather than mess with checking pin connections, we look directly at m_OutputDVFormat.
    // Note that, since the video input pin and the output pins are both 
    // connected, m_OutputDVFormat must be legit (see the note in 
    // CDVMuxerInputPin::Disconnect)
    //
    // Note that it is easier to fail the Pause here rather than build the logic
    // into CDVMuxerInputPin::CheckMediaType(). Otherwise, if the user connected
    // both audio pins and temporarily disconnected the first, we'd have to forcibly 
    // disconnect the second one. (Here "first" and "second" mean first connected
    // and second connected audio pins - not first created and second created.)
    //
    // @@@ When we clean up dynamic format changes, ensure that this condition is
    // met by checking for it in CheckMediaType. Clearly, dynamic format changes
    // are going to be an issue for the mux because the format changes on the 
    // input audio pins must be processed "together". 
    
    if ((m_OutputDVFormat.dwDVAAuxSrc  & AM_DV_AUDIO_MODE) == AM_DV_AUDIO_NO_AUDIO &&
        (m_OutputDVFormat.dwDVAAuxSrc1 & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO)
    {
        // Assert that the "first connected" audio pin is now 
        // disconnected and the second connected one is connected.
        ASSERT(m_apInput[DVMUX_VIDEO_INPUT_PIN+1] == NULL);
	ASSERT(m_apInput[DVMUX_VIDEO_INPUT_PIN+2] != NULL);
        return VFW_E_NOT_CONNECTED;
    }



    // check we can change state

    // @@@ jaisri: Never understood the logic behind this.
    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        if (m_pOutput) {
            m_pOutput->DeliverEndOfStream();
        }
        return hr;
    }

    // allow CDVMuxer
    // to know about starting and stopping streaming

    if (m_State == State_Stopped) {
        hr = StartStreaming();
        if (FAILED(hr)) {
            return hr;
        }
    }
    return CBaseFilter::Pause();
}


STDMETHODIMP CDVMuxer::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Run(...)")));
    CAutoLock l(&m_csFilter);

    // Is there any change needed
    if (m_State == State_Running) {
        return NOERROR;
    }

    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        return hr;
    }

    // This will call CDVMuxer::Pause if necessary, so we don't
    // need to call StartStreaming here.
    m_cNTSCSample = 1;

    return CBaseFilter::Run(tStart);
}

/******* Media Type Handling ******/
//
// CheckInputType
//
// check the input type is OK. We only accept video input, with the same format on
// each pin.
//
// Unlike CTransform derived classes, CheckMediaType is called for the output pin
// as well the input pin. (this removes the need for CheckTransform, which is a bit
// tricky when we have more than one input pin! )
//
/*X*

//X* 
//X* 77 bytes Audio in A-DIF block:
//X* Audio Aux(5 byte) + audio data(72 bytes) on tape
//X* 9 audio block/DIF
//X* 10 or 12 DIF /frame
//X* 2 bytes for evry audio sample at 48k, 44.1k or 32k_1ch
//X*	48k requires  48000*2/30= 3200 bytes/frame 
//X*	48k requires  48000*2/25= 3840 bytes/frame
//X* MAX(10): 72*9*5=3240 bytes/frame	==	1620 samples/frame
//X* MAX(12): 72*9*6=3888 bytes/frame	==	1944 samples/frame
//X* see table 18 and 19 in part2 sepc for audio sampels/frame
//X*
//X* Agri:
//X*			iDIFBlkNum=(n/3)+2
//*X*
/*X*
typedef struct Tag_DVAudInfo
{
	BYTE	bAudStyle[2];		
	//LSB 6 bits for starting DIF sequence number
	//MSB 2 bits: 0 for mon. 1: stereo in one 5/6 DIF sequences, 2: stereo audio in both 5/6 DIF sequences
	//example: 0x00: mon, audio in first 5/6 DIF sequence
	//		   0x05: mon, audio in 2nd 5 DIF sequence
	//		   0x15: stereo, audio only in 2nd 5 DIF sequence
	//		   0x10: stereo, audio only in 1st 5/6 DIF sequence
	//		   0x20: stereo, left ch in 1st 5/6 DIF sequence, right ch in 2nd 5/6 DIF sequence
	//		   0x26: stereo, rightch in 1st 6 DIF sequence, left ch in 2nd 6 DIF sequence
	BYTE	bAudQu[2];			//qbits, only support 12, 16, 		
		
	BYTE	bNumAudPin;			//how many pin(language)
	WORD	wAvgBytesPerSec[2];	//
	WORD	wBlkMode;			//45 for NTSC, 54 for PAL
	WORD	wDIFMode;			//5  for NTSC, 6 for PAL
	WORD	wBlkDiv;			//15  for NTSC, 18 for PAL
} DVAudInfo;
*X*/
//
//  pSrc: pointer to begining of one frame's 16 bits mono/stereo PCM audio	
//  pDst: point to one frame DV buffer which contains 10/12 DIF sequences
//  bAudPinInd:  it can support up to two language
//  wSampleSixe: how many samples from this frame
//
HRESULT CDVMuxer::ScrambleAudio(BYTE *pDst, BYTE **ppSrc, int bAudPinInd, WORD *wSampleSize)
{
    // @@@ jaisri: This function should convert 16 bit audio samples with
    // the value 0x8000 and 12 bit audio samples with the value 0x800 to
    // 0x8001 and 0x801 respectively. See p18, Sec 6.4.3 of the Blue Book.

    BYTE *pTDst;	//temp point
    WORD *pwSize;
    INT iDIFPos;																	
    INT iBlkPos;
    INT iBytePos;
    short sI;
    INT n;
    INT iShift;
    INT iPos;
    INT ind;
    WORD wStart[DVMUX_MAX_AUDIO_SAMPLES];
    WORD wEnd[DVMUX_MAX_AUDIO_SAMPLES];
    WORD wBlkMode,wDIFMode,	wBlkDiv;

    //pointer to Desg
    pTDst		= pDst;

    //point to size
    pwSize		= wSampleSize;

    //pointers to input audio source
    wStart[0]		= 0;
    wEnd[0]		= pwSize[0];
    for(ind=1; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
    {
    	wStart[ind]	= wEnd[ind-1];
    	wEnd[ind]	= wStart[ind] + pwSize[ind];
    }


    // So much for maintaining m_OutputDVFormat!
    DVINFO *pDVInfo =(DVINFO *)m_pOutput->CurrentMediaType().pbFormat;
    ASSERT(memcmp(&m_OutputDVFormat, pDVInfo, sizeof(DVINFO)) == 0);

    //PAL or NTSC
    if(	pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 )
    {  	//PAL
	wBlkMode=54;
        wDIFMode=6;
        wBlkDiv=18;
    }
    else
    {    //525_60, NTSC
        wBlkMode=45;
        wDIFMode=5;
        wBlkDiv=15;
    }
		
    //current pin's audio format				
    WAVEFORMATEX *pWave =(WAVEFORMATEX *)m_apInput[bAudPinInd+1]->CurrentMediaType().pbFormat ;
    
    if( pWave->wBitsPerSample == 16 )
    {
	//X******* 16 bits /sample input audio
	//X*******  support 
	//	    Case 1. 16bits, 48K, 32K , 44.1K mono
	//	    Case 2. 16bits-32K-stereo
	//	    Case 3. 16bits, 48K or 44.k stereo
	if( pWave->nChannels==1)
	{
	    //CASE 1
	    //16 bits Mono. audio only in one of 5/6 DIF sequencec
	    if(bAudPinInd)
		iPos=( pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 ) ? (6*150*80) : (5*150*80);
	    else
		iPos=0;

	    // Manbugs 37710. We have to step down the 16 bit to 12 bit if
            // we are outputting SD 4ch audio
            BOOL bStepDown = 0;
            if (pWave->nSamplesPerSec == 32000)
            {
                DWORD dwAuxSrc = bAudPinInd? pDVInfo->dwDVAAuxSrc1 : pDVInfo->dwDVAAuxSrc; 
                bStepDown = ((dwAuxSrc & AM_DV_AUDIO_QU) == AM_DV_AUDIO_QU12)? 1 : 0;
            }

            if (bStepDown)
            {
                // This is the same as the 32K stero code below except that
                // we set the unused channel (Chb or Chd) to silence, Blue Book
                // specifies that we should either set it to silence or copy the value
                // we put in Cha/Chc.

	        int Mask	=0x20;
	        int Cnt	=6;
	        int Shift=1;

	        for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	        {
	          BYTE *pTSrc=&*ppSrc[ind];
	          for( n=wStart[ind]; n< wEnd[ind]; n++)
	          {
		    
		    //
		    //calc buffer location to put audio
		    //
		    iDIFPos=( (n/3)+2*(n%3) )%wDIFMode;	//0-4 for NTSC, 0-5 for PAl
		    iBlkPos= 3*(n%3)+(n%wBlkMode)/wBlkDiv;	//0-9 
		    iBytePos=8+3*(n/wBlkMode);
		    pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		    
		    //	pTDst			=  pDst+ iDIFPos*150*80 + 6*80 + 16*iBlkPos*80 + iBytePos;
		    //	iDIFPos*150*80	-> skip iDIFPos number DIF sequence
		    //	6*80			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		    //	16*iBlkPos*80	-> skip 16 blk for evrey iBLkPos audio
	            //	iPos: 0 if this audio in 1st 5/6 DIF sequences, 5(or 6)*150*80 for 2nd DIF seq
		    //
	            //#######we do convertion from 16bits to 12 bits######
	    	    //
		    

	            // Left Sample
		    sI=  pTSrc[0] | (  pTSrc[1]  << 8  );
	            pTSrc +=2;

            if ((sI & 0x8000) && !(sI & 0x7FC0))
            {
                sI = 0x0801;
            }
            else
            {
                iShift	=sI <0 ?  (-(sI+1)) >> 9  :  sI >> 9  ;	
    		    if( iShift )
    		    {
    		    
    		        Mask    =0x20;
    		        Cnt	    =6;
    		        while( ! (Mask & iShift) )
    		        {
    			    Cnt--;
    			    Mask>>=1;
    		        }
    		        iShift=Cnt;
    		    }
    
    		    sI =sI<0 ? ( ( (sI +1) >> iShift   ) -(256*iShift+1) )   :	//negitive
    			       ( (    sI   >> iShift ) + 256*iShift );		//positive
            }
		    pTDst[0]= (unsigned char)( ( sI & 0xff0) >>4  );	//most significant 8 bits
		    pTDst[2]= (unsigned char)( ( sI & 0xf) <<4 );		//lese significant 4 bits

		    // Right Sample - silence
                    pTDst[1] = 0;
                    // The lower nibble of pTDst[2] is already 0.

	          } //for( n=wStart[ind]; n< wEnd[ind]; n++)
	        } //for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
            }
            else
            {
                for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	        {	
		    BYTE *pTSrc=&(*ppSrc[ind]);
		    for( n=wStart[ind]; n< wEnd[ind]; n++)
		    {
	    	        iDIFPos=( (n/3)+2*(n%3) )%wDIFMode;	//0-4 for NTSC, 0-5 for PAL
		        iBlkPos= 3*(n%3)+(n%wBlkMode)/wBlkDiv; //0-9 
		        iBytePos=8+2*(n/wBlkMode);					//

		        pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		        //	iDIFPos*150*80=12000iDIFPos	-> skip iDIFPos number DIF sequence
		        //	6*80=480			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		        //	16*iBlkPos*80=1280*iBlkPos	-> skip 16 blk for evrey iBLkPos audio
		        //	iPos:				=0 if this audio in 1st 5/6 DIF sequences, =5(or 6)*150*80 for 2nd DIF seq

		        pTDst[1]=*pTSrc++;	//lease significant byte
		        *pTDst=*pTSrc++;	//most significant byte
		    }
	        }
            }
	}
	else if( ( pWave->nSamplesPerSec == 32000) &&
		 ( pWave->nChannels == 2)
		)
	{
	    //CASE 2
	    //32K stereo audio
	    if(bAudPinInd)
	    {	
		ASSERT( pDVInfo->dwDVAAuxSrc1 & AM_DV_AUDIO_CHN2);
		ASSERT( pDVInfo->dwDVAAuxSrc1 & AM_DV_AUDIO_QU12);
		iPos=( pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 ) ? (6*150*80) : (5*150*80);
	    }
	    else
	    {
		ASSERT( pDVInfo->dwDVAAuxSrc & AM_DV_AUDIO_CHN2);
		ASSERT( pDVInfo->dwDVAAuxSrc & AM_DV_AUDIO_QU12);
		iPos=0;
	    }

	    int Mask	=0x20;
	    int Cnt	=6;
	    int Shift=1;

	    for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	    {
	      BYTE *pTSrc=&*ppSrc[ind];
	      for( n=wStart[ind]; n< wEnd[ind]; n++)
	      {
		
		//
		//calc buffer location to put audio
		//
		iDIFPos=( (n/3)+2*(n%3) )%wDIFMode;	//0-4 for NTSC, 0-5 for PAl
		iBlkPos= 3*(n%3)+(n%wBlkMode)/wBlkDiv;	//0-9 
		iBytePos=8+3*(n/wBlkMode);
		pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		
		//	pTDst			=  pDst+ iDIFPos*150*80 + 6*80 + 16*iBlkPos*80 + iBytePos;
		//	iDIFPos*150*80	-> skip iDIFPos number DIF sequence
		//	6*80			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		//	16*iBlkPos*80	-> skip 16 blk for evrey iBLkPos audio
	        //	iPos: 0 if this audio in 1st 5/6 DIF sequences, 5(or 6)*150*80 for 2nd DIF seq
		//
	        //#######we do convertion from 16bits to 12 bits######
	    	//
		

	        // Left Sample
		sI=  pTSrc[0] | (  pTSrc[1]  << 8  );
	        pTSrc +=2;

       
        if ((sI & 0x8000) && !(sI & 0x7FC0))
        {
            // This special case is a fix for the case of values which are near the lower
            // limit of possible 16 bit values in which case the code below would produce the 
            // 12 bit value 0x7FF instead of the correct 0x801
            // The case we handle here is inputs in the range starting 0x8000 to 0x803F
            sI = 0x0801;
        }
        else
        {

            // This code converts 16 bit to NON LINEAR 12 bit which is why it could not be simplified
            // to just shift right four bits.  so the farther away you are from the zero line, the more
            // your 16 bit values are compressed... So if your input is a 16 bit sine wav
            // the output would look more square like.
            iShift	=sI <0 ?  (-(sI+1)) >> 9  :  sI >> 9  ;	
    		if( iShift )
    		{
    		
    		    Mask    =0x20;
    		    Cnt	    =6;
    		    while( ! (Mask & iShift) )
    		    {
    			Cnt--;
    			Mask>>=1;
    		    }
    		    iShift=Cnt;
    		}
    
    		sI =sI<0 ? ( ( (sI +1) >> iShift   ) -(256*iShift+1) )   :	//negitive
    			   ( (    sI   >> iShift ) + 256*iShift );		//positive
        }
		pTDst[0]= (unsigned char)( ( sI & 0xff0) >>4  );	//most significant 8 bits
		pTDst[2]= (unsigned char)( ( sI & 0xf) <<4 );		//lese significant 4 bits

		// Right Sample
		sI=  pTSrc[0] | (  pTSrc[1]  << 8  );
		pTSrc +=2;


        if ((sI & 0x8000) && !(sI & 0x7FC0))
        {
            sI = 0x0801;
        }
        else
        {
            iShift	=sI<0 ?  (-(sI+1)) >> 9  : ( sI >> 9 ) ;	
    		if( iShift )
    		{
    		
    		    Mask    =0x20;
    		    Cnt	    =6;
    		    while( ! (Mask & iShift) )
    		    {
    			Cnt--;
    			Mask>>=1;
    		    }
    		    iShift=Cnt;
    		}
    
    		sI =sI<0 ? ( ( (sI +1) >> iShift   ) -(256*iShift+1) )   :	//negitive
    			   ( (    sI   >> iShift ) + 256*iShift );		//positive
        }

		pTDst[1]= (unsigned char)( ( sI & 0xff0) >>4  );	//most significant 8 bits
		pTDst[2] |= (unsigned char)( ( sI & 0xf) );			//lese significant 4 bits
	      } //for( n=wStart[ind]; n< wEnd[ind]; n++)
	    } //for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	}
	else 
	{
	    //CASE 3
	    //one 48K or 44.1K stereo audio
	    //16 bits stereo audio in all 10 or 12 DIF sequences
	    //left Channel always in 1st 5/6 DIF
	    iPos = 0;
	    INT iRPos =	(pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 ) ? 6*150*80 : 5*150*80;
	  
	    for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	    {
	        BYTE *pTSrc=&*ppSrc[ind];
	        for( n=wStart[ind]; n< wEnd[ind]; n++)
	        {
	    	    iDIFPos=( (n/3)+2*(n%3) )%wDIFMode;	//0-4 for NTSC, 0-5 for PAL
		    iBlkPos= 3*(n%3)+(n%wBlkMode)/wBlkDiv; //0-9 
		    iBytePos=8+2*(n/wBlkMode);					//

		    //Left first
		    pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		    //iDIFPos*150*80=12000iDIFPos		-> skip iDIFPos number DIF sequence
		    //	6*80=480					-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		    //	16*iBlkPos*80=1280*iBlkPos	-> skip 16 blk for evrey iBLkPos audio
		    //  iPos: =0 if this audio in 1st 5/6 DIF sequences, =5(or 6)*150*80 for 2nd DIF seq
		    pTDst[1]=*pTSrc++;	//lease significant byte
		    *pTDst=*pTSrc++;	//most significant byte

		    //Right second
		    pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iRPos;
		    pTDst[1]=*pTSrc++;	//lease significant byte
		    *pTDst=*pTSrc++;	//most significant byte
			
		}
	    }
	}												
	return NOERROR;
    }
    else{
        //only support 16 bits/samples
        return VFW_E_INVALIDMEDIATYPE;
    }
    return NOERROR;
}


// =================================================================
// Implements the CDVMuxerInputPin class
// =================================================================


// constructor

CDVMuxerInputPin::CDVMuxerInputPin(
                            TCHAR *pObjectName,
                            CBaseFilter *pBaseFilter,
                            CDVMuxer *pDVMux,
                            HRESULT * phr,
                            LPCWSTR pName,
                            int iPinNo)
    : CBaseInputPin(pObjectName, pBaseFilter, &pDVMux->m_csFilter, phr, pName)
    , m_SampleList(NAME("CDVMuxInpuPin::m_SampleList"))
    , m_iPinNo(iPinNo)
    , m_pDVMuxer(pDVMux)
    , m_fCpyAud(FALSE)
    , m_PinVidFrmCnt(0)
    , m_pLocalAllocator(NULL)
{
    DbgLog((LOG_TRACE,4,TEXT("CDVMuxerInputPin::CDVMuxerInputPin")));
}


// destructor

CDVMuxerInputPin::~CDVMuxerInputPin()
{
    DbgLog((LOG_TRACE,4,TEXT("CDVMuxerInputPin::~CDVMuxerInputPin")));

    if (m_pLocalAllocator)
    {
        m_pLocalAllocator->Release();
        m_pLocalAllocator = NULL;
    }
}


IMediaSample *CDVMuxerInputPin::GetNthSample( int i )
{
    int k=m_SampleList.GetCount();

    if ( m_SampleList.GetCount() < ( i +1 ) )
		return NULL;
    else
    {
	POSITION pos = m_SampleList.GetHeadPosition();
	while (i ) {
	    pos=m_SampleList.Next(pos);
	    i--;
	}

	IMediaSample *tmp;
	tmp=m_SampleList.Get( pos ) ;
	int j=m_SampleList.GetCount();
	return tmp;
    }
}

void CDVMuxerInputPin::ReleaseNSample( int n  )
{

    ASSERT( m_SampleList.GetCount() >=   n  );

    DbgLog((LOG_TRACE, 4, TEXT("CDVMuxerInputPin::ReleaseNSample() on pin %d"), m_iPinNo));

    for( int  i =0; i<  n; i++)
    {
	m_SampleList.Get(m_SampleList.GetHeadPosition())->Release();
	m_SampleList.RemoveHead();
    }

}


BOOL CDVMuxerInputPin::SampleReady( int i)
{
    if(this)
	return m_SampleList.GetCount() >= i;
    else
	return FALSE;
}

HRESULT CDVMuxerInputPin::SetMediaType(const CMediaType *pmt)
{

    // Set the base class media type (should always succeed)
    HRESULT hr = CBasePin::SetMediaType(pmt);
    if( SUCCEEDED(hr) )
    {
	 
	if(m_iPinNo==DVMUX_VIDEO_INPUT_PIN )	    //DV video pin
	{	
	    VIDEOINFO *pVideoInfo;
	    pVideoInfo=(VIDEOINFO *)pmt->pbFormat;
	    LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);
    	    if( lpbi->biHeight  != 480 )
    		m_pDVMuxer->m_iVideoFormat=IDC_DVMUX_PAL;
	    else
		m_pDVMuxer->m_iVideoFormat=IDC_DVMUX_NTSC;
	}
	
	//if out putpin is already connected, reconnected based on new audio or video
	if(   m_pDVMuxer->m_pOutput->IsConnected()	)
	    m_pDVMuxer->m_pGraph->Reconnect( m_pDVMuxer->m_pOutput );
	
    }
    return hr;
}

/*  Disconnect */
STDMETHODIMP CDVMuxerInputPin::Disconnect()
{
  HRESULT hr = CBaseInputPin::Disconnect();

  // @@@ jaisri: This is correct as it stands, but
  // it's probably safer to do this in BreakConnect

  //make sure m_apInput[m_iPinNo]==NULL if it is not connected
  m_pDVMuxer->m_apInput[m_iPinNo] =NULL;

  // Manbugs 37710. m_OutputDVFormat and the output pin's format
  // must be updated here. (m_OutputDVFormat and the output 
  // pin's format must always be the same, ScrambleAudio assumes that.)
  //
  // Otherwise, consider the following sequence of actions:
  // (a) An input pin is connected to the video source and >= 1 input
  // pins are connected to audio sources (b) The output pin is 
  // connected (c) One of the audio input pins is disconnected
  // (d) The graph is played. (In step (c), disconnect the audio pin
  // that was last connected, i.e., the one whose m_iPinNo = DVMUX_VIDEO_INPUT_PIN+1.
  // Otherwise, Pause might fail anyway.)
  //
  // m_OutputDVFormat is never updated and the format of the output pin is
  // bogus.
  //
  // Since Pause fails if the video input pin is not connected or the output
  // pin is not connected, it suffices to do this only if both these pins
  // are connected.
  //
  if (SUCCEEDED(hr) &&
      m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN] != NULL &&
      m_pDVMuxer->m_pOutput->IsConnected())
  {
      CMediaType pmt;

      EXECUTE_ASSERT(SUCCEEDED(m_pDVMuxer->m_pOutput->GetMediaType(0, &pmt)));
      EXECUTE_ASSERT(SUCCEEDED(m_pDVMuxer->m_pOutput->SetMediaType(&pmt)));
  }

  return hr;
}


// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.
// ------------------------------------------------------------------------
HRESULT
CDVMuxerInputPin::CompleteConnect(IPin *pReceivePin)
{
  HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
  {
      m_pDVMuxer->m_apInput[m_iPinNo] =NULL;
      return hr;
  }

  //set up		
  m_pDVMuxer->m_apInput[m_iPinNo] = this;
  
  //X* now Create next input pin
  if( m_pDVMuxer->m_iInputPinCount <= DVMUX_MAX_AUDIO_PIN  )
  {
     
	WCHAR szbuf[20];             // Temporary scratch buffer
	wsprintfW(szbuf, L"Stream %d", m_pDVMuxer->m_iInputPinCount);


	m_pDVMuxer->m_apInputPin[m_pDVMuxer->m_iInputPinCount]=new CDVMuxerInputPin(NAME("DVMuxer Input pin"),
				    m_pDVMuxer,		// Owner filter
				    m_pDVMuxer,		// Route through here
                                    &hr,		// Result code
                                    szbuf,	// Pin Name
                                    m_pDVMuxer->m_iInputPinCount); // Pin Number

	if (m_pDVMuxer->m_apInputPin[m_pDVMuxer->m_iInputPinCount] != NULL) 
	    m_pDVMuxer->m_iInputPinCount++;
  }

  return hr;
}

// check whether we can support a given input media type
HRESULT CDVMuxerInputPin::CheckMediaType(const CMediaType* pmt)
{
    ASSERT( m_iPinNo < m_pDVMuxer->m_iInputPinCount );
    
    if(  *pmt->Type() == MEDIATYPE_Video   ) 
    {
        if(  (	IsEqualGUID( *pmt->Subtype(), MEDIASUBTYPE_dvsd) 
    	 // |	IsEqualGUID( *pmt->Subtype(), MEDIASUBTYPE_dvhd )  //do not support dvhd yet
	 // |	IsEqualGUID( *pmt->Subtype(), MEDIASUBTYPE_dvsl )  //do not support dvhd yet
	 )
	 &&  ( *pmt->FormatType() == FORMAT_VideoInfo )	)
	{
	    if( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN] ==NULL )
	    {
		m_iPinNo    = DVMUX_VIDEO_INPUT_PIN;
		return NOERROR;
	    }
	    else if( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN] != this ) 
	    {
		//only support one video pin
		ASSERT( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN]->IsConnected() );
		return E_INVALIDARG;		//we already has a video pin
	    }
	    else
	    {
		if( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN]->IsConnected() )
		{
		    // m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN] == this
		    // media type changed from NTSC to PAL
		    // does not support video type change on fly yet!
		    //if video does changed from NTSC to PAL or PAL to NTSC
		    if( HEADER( (VIDEOINFO *)( pmt->Format()  ) )->biHeight != 
			HEADER( (VIDEOINFO *)( m_mt.pbFormat) )->biHeight )
		    {
			return E_INVALIDARG;
		    }
		}

		return NOERROR;
	    }
	}
    }
    //PCM audio input pin(s)
    else if( IsEqualGUID( *pmt->Type(), MEDIATYPE_Audio ) )
	 {

	    if(   ( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN +1 ] == this )  
	       || ( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN +2 ] == this ) ) 
	    {
		// @@@ jaisri. Why are the checks below bypassed?
                // If we are streaming how can we be sure that the 
                // new mediatype is consistent with the spec, 
                // particularly for 4 channel audio output?
                
                if( IsConnected() )
		    //allow audio mediatype change on fly
		    return NOERROR;
	    }


	    if( (( *pmt->Subtype() == MEDIASUBTYPE_PCM ) ||  ( *pmt->Subtype()==GUID_NULL ) )
	        && (*pmt->FormatType() == FORMAT_WaveFormatEx)  )
	    {
		//get format
	   	WAVEFORMATEX *pwfx=(WAVEFORMATEX *)pmt->pbFormat;
		int OtherAudPin;

                
                if( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN +1 ] != NULL )
		{
		    // Note that the audio pin connected LAST has the 
                    // index DVMUX_VIDEO_INPUT_PIN +2; the one connected
                    // before that has the index DVMUX_VIDEO_INPUT_PIN +1.
                    //
                    // DVMUX_VIDEO_INPUT_PIN +1 has the first audio block
                    // and DVMUX_VIDEO_INPUT_PIN +2 the second. 
                    //
                    // Again, note that which pin has the first audio block and
                    // which the second is determined by pin connection order,
                    // NOT pin creation order.
                    //
                    // We could just change all this to create 3 pins up front,
                    // force the first to be the video, second to be the audio pin
                    // that creates the first audio block and the third to be the
                    // audio pin that creates the second audio block. However, this
                    // could break some ISV apps, so swing the proposal by them first! @@@
                    //
		    m_iPinNo	=  DVMUX_VIDEO_INPUT_PIN +2;
		    OtherAudPin	=  DVMUX_VIDEO_INPUT_PIN +1;
		}
		else
		{
		    m_iPinNo	=  DVMUX_VIDEO_INPUT_PIN +1;
		    OtherAudPin	=  DVMUX_VIDEO_INPUT_PIN +2;
		}
	
		//check whether another audio pin is connected
		if( m_pDVMuxer->m_apInput[ OtherAudPin ]!=NULL )
		{    
		    ASSERT( m_pDVMuxer->m_apInput[OtherAudPin]->IsConnected() );
	
		    //##########yes this audio pin is connected########
		    
		    //fetch another audio pin's media format
		    WAVEFORMATEX *pwfxTmp = (WAVEFORMATEX *)(m_pDVMuxer->m_apInput[ OtherAudPin ]->CurrentMediaType().pbFormat);
		    
                    // @@@ jaisri:
                    // Note: The Blue Book does not permit sampling rates
                    // to be mixed. Also, it does not allow CH1 to be 
                    // recorded in 12 bit and CH2 in 16 bit (which is 
                    // what we do in the 32K stereo + mono case).
                    // Finally we should allow the second channel to have 
                    // 32K 12 bit mono.

		    if (pwfx->nSamplesPerSec != 32000 &&
			pwfx->nSamplesPerSec != 44100 &&
			pwfx->nSamplesPerSec != 48000 
                       )
                    {
                        return E_FAIL;
                    }
                    
                    // wBitsPerSample must be 8 or 16, see note in mono case below.
                    // Blue Book requires sampling rate on the 2 tracks to be 
                    // identical
                    if (pwfx->wBitsPerSample    != 16    ||
                        pwfxTmp->wBitsPerSample != 16    ||
                        pwfxTmp->nSamplesPerSec != pwfx->nSamplesPerSec
                       )
                    {
                        return E_FAIL;
                    }

                    if (pwfx->nChannels == 1 && pwfxTmp->nChannels == 1)
                    {
                        // mono on each track, we are ok
                    }
                    else if (pwfx->nChannels > 2 || pwfxTmp->nChannels > 2)
                    {
                        // @@@ jaisri
                        // Blue Book requires us to support 3/1 stereo for 32KHz but does
                        // Windows support this?

                        return E_FAIL;
                    }
                    else if (pwfx->nSamplesPerSec != 32000)
                    {
                        // Only 32K can have stereo muxed with another audio input
                        return E_FAIL;
                    }
		}
		else
		{
		    //##########not, another audio pin is not connected####
		    if(  pwfx->wBitsPerSample	==16	    &&
			(pwfx->nSamplesPerSec	== 48000 || 
			 pwfx->nSamplesPerSec	== 44100 ||  
			 pwfx->nSamplesPerSec	== 32000 )  
		      ) ;//if 16bits goes with 32K, 44.1K and 48K
            else 
    			return E_FAIL;
		}
		    
	  	return NOERROR;
	    }
	}

    return E_FAIL;
}

HRESULT CDVMuxerInputPin::Active()
{
    m_fEOSReceived = FALSE;
    m_PinVidFrmCnt=0;
    if( m_fCpyAud )
    {
	if (m_pAllocator)
        {
            // Not clear that we should do this, but it doesn't hurt
            EXECUTE_ASSERT(SUCCEEDED(m_pAllocator->Commit()));
        }
        ASSERT(m_pLocalAllocator);
        return m_pLocalAllocator->Commit();
    }
    else
	return NOERROR;

 }

HRESULT CDVMuxerInputPin::Inactive()
{
    if( m_fCpyAud )
    {
        ASSERT(m_pLocalAllocator);
        return m_pLocalAllocator->Decommit();
    }
    else
	return NOERROR;

 }

// =================================================================
// Implements IMemInputPin interface
// =================================================================

// put EOS to video or audio queue
STDMETHODIMP CDVMuxerInputPin::EndOfStream(void)
{
    CAutoLock lck(&m_csReceive);

    HRESULT hr = CheckStreaming();

    // @@@ This function has numerous race conditions when the 
    // graph is stopped, many leading to infinite loops. Consider
    // restructuring it.

    if (S_OK == hr) {

        // @@@ jaisri: Note: This member is set after obtaining 
        // m_csReceive for this input pin. However, m_fEOSReceived 
        // of other input pins are accessed without acquiring 
        // m_csReceive of those pins later in this function and 
        // in CDVMuxer::Receive

	//refuse any more sample on this pin
	m_fEOSReceived = TRUE;
	m_PinVidFrmCnt=0;
    }
    
    if( m_iPinNo !=DVMUX_VIDEO_INPUT_PIN )
    {
	//no more audio from this audio pin
	int iPin=m_iPinNo+1;	    // this pin is first audio pin, iPin is 2nd audio pin
	if(m_iPinNo==(DVMUX_VIDEO_INPUT_PIN+2) )
	   //this pin is second audio pin, iPin is 1st audio pin
	    iPin= m_iPinNo-1;

	//what is index for m_apInputPin[]
	if( ( m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN  ]->m_fEOSReceived ) &&
	    ( (m_pDVMuxer->m_apInput[ iPin  ] ==NULL)	   ||  
	      (m_pDVMuxer->m_apInput[ iPin  ]->m_fEOSReceived == TRUE) )
	  )
	{    
	    //no more sample from any input pin
	    for (int i = 0; i < m_pDVMuxer->m_iInputPinCount; i ++)
	    {
		//use all samples in the queue
		while ( m_pDVMuxer->m_apInput[ i ]->SampleReady( 1 ) )
		{
		    hr = m_pDVMuxer->Receive(  );
		    ASSERT(hr!=Waiting_Audio);
                    if (FAILED(hr))
                    {
                        // Happens when graph is stopped and Receive returns
                        // VFW_E_NOT_COMMITTED (0x80040211). Don't know if
                        // we should do this for other errors (e.g., Waiting_Audio)
                        break;
                    }
		}
	    }

            // jaisri: Should m_pExVidSample be set to NULL here?
            // (StopStreaming releases it again)
            // jaisri: Let StopStreaming do this - it's safer from a concurrency 
            // standpoint (not sure which locks are held to access this member 
            // variable - other pins could be executing CDVMuxer::Receive)
            // IMediaSample* p;
	    // hr=m_pDVMuxer->pExVidSample(&p, TRUE);
	    // if(hr==NOERROR && p!=NULL)
	    //     p->Release();


	    m_pDVMuxer->ReleaseAllQueuedSamples();	
	    hr=m_pDVMuxer->DeliverEndOfStream();
	}
	else
	{
	    //use all video samples in the queue 
	    while ( m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN ]->SampleReady( 1 ) )
	    {
	        hr = m_pDVMuxer->Receive(  );

                // We get this status back if the 
                // other audio pin has not received EOS
	        // ASSERT(hr!=Waiting_Audio);
	    }
	    hr=NOERROR;
	}    
   }
   else
   {
 
       //no more video
       if(     ( (m_pDVMuxer->m_apInput[1]==NULL ) || ( m_pDVMuxer->m_apInput[ 1]->m_fEOSReceived) )
	    && ( (m_pDVMuxer->m_apInput[2]==NULL ) || ( m_pDVMuxer->m_apInput[ 2]->m_fEOSReceived) ) 
	 )
       {
	    
	   //no more audio sample from any input pin
	    for (int i = 0; i < m_pDVMuxer->m_iInputPinCount; i ++)
	    {
		//use all samples in the queue
		while ( m_pDVMuxer->m_apInputPin[ i ]->SampleReady( 1 ) )
		{
		    hr = m_pDVMuxer->Receive(  );
		    ASSERT(hr!=Waiting_Audio);
		}
	    }

            // jaisri: Should m_pExVidSample be set to NULL here?
            // (StopStreaming releases it again)
            // jaisri: Let StopStreaming do this - it's safer from a concurrency 
            // standpoint (not sure which locks are held to access this member 
            // variable - other pins could be executing CDVMuxer::Receive)
            // IMediaSample* p;
	    // hr=m_pDVMuxer->pExVidSample(&p, TRUE);
	    // if(hr==NOERROR && p!=NULL )
	    //     p->Release();
	    m_pDVMuxer->ReleaseAllQueuedSamples();	
	    hr=m_pDVMuxer->DeliverEndOfStream();
       }
       else
       {
	   //mux all video samples in the queue because it is possible that audio buffers are used up 
	   //at this moment, If we do not mux audio with video, audio input can not input more audio data.
	    while (	(hr = m_pDVMuxer->Receive(  ) )!= Waiting_Audio  && 
			SUCCEEDED(hr)  )
	    {
		if(    ( (m_pDVMuxer->m_apInput[1]==NULL ) || ( m_pDVMuxer->m_apInput[ 1]->m_fEOSReceived ) )
		    && ( (m_pDVMuxer->m_apInput[2]==NULL ) || ( m_pDVMuxer->m_apInput[ 2]->m_fEOSReceived  )  )
		)
       		    break;
	    }
	    hr=NOERROR;
	}
   }


   return hr;
}


// X
// if it is the input video pin, flush  video pin's queue and pass flush to down stream Enter flushing state. 
// else it(they) is(are) auido input pin(s), flush auido pin's queue, does not pass down stream enter flushing state
// this input pin's Receives already blocked
// Call default handler to block Receives, 
// flush all samples on the its queue, if this is video input pin, 
// pass to dvmux filter to flush outputpin
//
STDMETHODIMP CDVMuxerInputPin::BeginFlush(void)
{

    // Call default handler to block Receives, 
    HRESULT hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr)) {
        return hr;
    }

    // Need to lock to make sure that we don't flush away something
    // that is being used.
    CAutoLock lock(&m_pDVMuxer->m_csMuxLock);
	
    //flush all samples on the queus
    while ( SampleReady( 1 ) )
        ReleaseNSample( 1 );

    //if it is video, pass flush to down stream
    if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
	return m_pDVMuxer->BeginFlush();
    else
	return NOERROR;
}

//X
// leave flushing state.
STDMETHODIMP CDVMuxerInputPin::EndFlush(void)
{

    m_PinVidFrmCnt=0;
    
    //if it is video, pass endflush to down stream
    if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
    {
   
	HRESULT hr = m_pDVMuxer->EndFlush();
	if (FAILED(hr)) {
	    return hr;
	}
    }
   
    m_fEOSReceived = FALSE; 
    return CBaseInputPin::EndFlush();
}

//X
// receive on sample from upstream
HRESULT CDVMuxerInputPin::Receive(IMediaSample * pSample)
{
    CRefTime	Stop, VidStart, VidStop;

    ASSERT(pSample!=NULL);
    HRESULT hr;

    CAutoLock lock(&m_csReceive);

    // ...or we'll crash
    if (!m_pDVMuxer->m_pOutput->IsConnected())
	return VFW_E_NOT_CONNECTED;

    DbgLog((LOG_TRACE, 4, TEXT("CDVMuxerInputPin::Receive(..) on pin %d"), m_iPinNo));

    //input video pin has to be connected
    if ( !m_pDVMuxer->InputVideoConnected() )
    {
        DbgLog((LOG_TRACE, 2, TEXT("CDVMuxerInputPin::Receive() without video pin connected!")));
        return S_FALSE;
    }

    // check all is well with the base class
    hr = CBaseInputPin::Receive(pSample);
    if (FAILED(hr)) {
        return hr;
    }

    if( m_fEOSReceived )
    {
        // @@@ jaisri: Why do we have this? Is it legit for a pin to send a sample
        // after delivering EOS (what will the sample have)? Is this just defensive 
        // programming?

        if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
	{
	    //end of video
	    if(!SampleReady( 1 ))
	    {
		// @@@ jaisri: This doesn't seem right. What about audio after video ends?
                m_pDVMuxer->ReleaseAllQueuedSamples();	
		m_pDVMuxer->DeliverEndOfStream();
	    }
	    else if(   ( (m_pDVMuxer->m_apInput[1]==NULL ) || ( m_pDVMuxer->m_apInput[ 1]->m_fEOSReceived ) )
		    && ( (m_pDVMuxer->m_apInput[2]==NULL ) || ( m_pDVMuxer->m_apInput[ 2]->m_fEOSReceived ) )
		 )

	    {
		//No more audio neither
		
		//deliver everything left in the bother Queue
                hr=NOERROR;
		while( SampleReady( 1 ) && (hr==NOERROR) )  
		    hr = m_pDVMuxer->Receive(  );
	
		m_pDVMuxer->ReleaseAllQueuedSamples();	
		m_pDVMuxer->DeliverEndOfStream();
	    }
	    else //refuse any more samples this pin, waiting audio's EOS
	    {
		hr = m_pDVMuxer->Receive(  );
	    }
	    
	}
	else
	{
	    int pin;
	    if( m_iPinNo == 1 ) 
		pin=2;
	    else
		pin=1;

	    //end of audio, Audio can not do m_pDVMuxer->DeliverEndOfStream() without deliver all video frame
	    if( m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN  ]->m_fEOSReceived )
	    {
		 if( !m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN  ]->SampleReady( 1 ) )
		 {
		    m_pDVMuxer->ReleaseAllQueuedSamples();	
		    m_pDVMuxer->DeliverEndOfStream();
		 }
		 else if ( (m_pDVMuxer->m_apInput[pin]==NULL ) || ( m_pDVMuxer->m_apInput[ pin]->m_fEOSReceived ) )
		 {
		    //not going to receive any more video sample neither 
		    //if another audio pin will not receive any sample neither
            hr=NOERROR;
		    while ( m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN  ]->SampleReady( 1 )  && (hr==NOERROR))
		    {
			hr = m_pDVMuxer->Receive(  );
			ASSERT(hr!=Waiting_Audio);
		    }
		    m_pDVMuxer->ReleaseAllQueuedSamples();	
		    m_pDVMuxer->DeliverEndOfStream();
		}
		else
		{
		    hr = m_pDVMuxer->Receive(  );
	   	}
		
	    }
	    else //refuse any more samples on this pin, waiting video's EOS
	    {
		hr = m_pDVMuxer->Receive(  );
	    }
	    
	}

	//refuse accept any more samples on this pin
	return S_FALSE;
    }
    

    // If a graph is stopped and a late sample comes along,
    // then we need to reject the sample. If we don't, we'll end up
    // with a sample with a late time stamp hanging around in our
    // buffers, and that will mess up the algorithm in MixAndOutputSamples
    if (m_pDVMuxer->m_State == State_Stopped) {
        DbgLog((LOG_ERROR, 1, TEXT("Receive while stopped!")));
        return VFW_E_WRONG_STATE;
    }
  
    if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
    {
	//This is video input pin
	//Figure out how many time this frame has to be copied
	pSample->GetTime( (REFERENCE_TIME*)&VidStart,  (REFERENCE_TIME*)&VidStop);		    

	//How many DV frames do we need to copy
	int FrmCnt=0;
	if( m_pDVMuxer->m_iVideoFormat==IDC_DVMUX_NTSC)
	{
            FrmCnt= (int)( (VidStart*29970/1000 + 0xff)/UNITS );
	    if( m_PinVidFrmCnt < FrmCnt )
		FrmCnt= FrmCnt - m_PinVidFrmCnt +(int)( (VidStop*29970/1000+0xff)/UNITS );
	    else
		FrmCnt= (int)( (VidStop*29970/1000+0xff)/UNITS );
	}
	else
	{
	    FrmCnt= (int)( (VidStart*25+0xff)/UNITS );
	    if( m_PinVidFrmCnt < FrmCnt )
		FrmCnt= FrmCnt - m_PinVidFrmCnt +(int)( (VidStop*25+0xff)/UNITS );
	    else
		FrmCnt= (int)( (VidStop*25+0xff)/UNITS );
	}

	//in order to support audio is longer then video
	IMediaSample    *pOut;
	if( !FAILED( m_pDVMuxer->pExVidSample(  &pOut,FALSE ) ) )
	    Copy( pOut, pSample);



	IMediaSample    *pOutSample;
	unsigned char *pDst, *pSrc;

	HRESULT Mux_hr=NOERROR;

	for(int i=m_PinVidFrmCnt; i<FrmCnt; i++)
	{
	    // get output media sample 
	    hr = m_pDVMuxer->m_pOutput->GetDeliveryBuffer(&pOutSample,NULL,NULL,0);
	    if ( FAILED(hr) ) 
		return hr;


	    ASSERT(pOutSample);
	    //fetch output buffer
	    hr = pOutSample->GetPointer(&pDst);
	    if( FAILED( hr ) )
                return hr;
	    ASSERT(pDst);

	    //fetch input  buffer
	    hr = pSample->GetPointer(&pSrc);
	    if( FAILED( hr ) )
                return hr;
	    ASSERT(pSrc);

      	    //copy input DV frame data to output buffer
	    if( m_pDVMuxer->m_iVideoFormat==IDC_DVMUX_NTSC)
	    {
		memcpy(pDst,pSrc,120000);		//80*150*10
		//update time stampe
		Stop=m_pDVMuxer->m_LastVidTime+ UNITS*1000L/29970L;		//DV has to output 30frames/sec if it is NTSC,
            if (m_pDVMuxer->m_cNTSCSample %3 == 0)
                Stop = Stop - 1;
            m_pDVMuxer->m_cNTSCSample++;

		pOutSample->SetTime( (REFERENCE_TIME*)&m_pDVMuxer->m_LastVidTime,  (REFERENCE_TIME*)&Stop);
	    }
	    else
	    {
		memcpy(pDst,pSrc,144000);	//80*150*12
		//update time stampe
		Stop=m_pDVMuxer->m_LastVidTime+ UNITS/25;		//DV has to output 30frames/sec if it is NTSC,
		pOutSample->SetTime( (REFERENCE_TIME*)&m_pDVMuxer->m_LastVidTime,  (REFERENCE_TIME*)&Stop);
	    }
	 
	    m_pDVMuxer->m_LastVidTime =Stop;
	    
      	    // add this video sample to sample list
	    //pOutSample->AddRef();	//since  GetDeliveryBuffe(), we have to release pOutSample.
	    m_SampleList.AddTail(pOutSample);

	    //try to mux this sample with other samples to build 10 DV DIF sequences (one frame)
	    if(Mux_hr==NOERROR)
	    {
		Mux_hr = m_pDVMuxer->Receive(  );
		if( Mux_hr!=Waiting_Audio )
		    if (FAILED(hr)) 
			 return hr;
	    }
	    //else maybe nor audio

    	    m_PinVidFrmCnt++;

	}

    }
    else
    {
	// alway copy audio since the AVI splitter can not guarant to diliver if this filter holds one buffer
	IMediaSample * pAudSample=NULL;

	ASSERT( m_fCpyAud );
	ASSERT(m_pLocalAllocator != NULL);
	
        // @@@ jaisri: So if an audio sample comes in before a video sample
        // (and video has not flagged end of stream) and video and audio are
        // delivered by the  same thread, we are going to sit in an infinite 
        // loop here? See ManBugs # 35432.
        //
        // The m_fWaiting_Video is an attempt to fix this. However, note that
        // there are several other code segments (e.g., in CDVMuxerInputPin::EndOfStream)
        // that also loop over Receive. These may need to be modified as well.

        hr=NOERROR;
	while(   ( m_SampleList.GetCount() >= 1) 
	      && ( m_pDVMuxer->m_fWaiting_Audio == FALSE   )  
	      && ( m_pDVMuxer->m_fWaiting_Video == FALSE   )  
              &&  (hr==NOERROR) )
	    //try not let m_pLocalAllocator->GetBuffer( &pAudSample, NULL, NULL , 0 ) wait
	    //and if audio sample changed format type in this justed received sample,
	    //m_pDVMuxer->m_MediaTypeChanged will be set just at right time for changing
	    hr = m_pDVMuxer->Receive(  );

        if ( FAILED(hr) && 	m_fEOSReceived )
        {
            m_pDVMuxer->ReleaseAllQueuedSamples();	
	    m_pDVMuxer->DeliverEndOfStream();
            //refuse accept any more samples on this pin
	    return S_FALSE;
        }

		
	hr = m_pLocalAllocator->GetBuffer( &pAudSample, NULL, NULL , 0 );

	if ( FAILED(hr) ) 
	    return hr;
	   
	ASSERT(pAudSample != NULL);

	//check if format is changed
	AM_MEDIA_TYPE *pmt=NULL;
	pSample->GetMediaType(&pmt);
    
	if (pmt != NULL && pmt->pbFormat != NULL) 
	{
            // @@@ jaisri: All this should be done when the
            // sample is processed in CDVMuxer::Receive(), not here
            // since m_SampleList.GetCount() could be > 0 still

	    ASSERT(m_mt.subtype	    == pmt->subtype);
	    ASSERT(m_mt.majortype   == pmt->majortype);
	    ASSERT(m_mt.formattype  == pmt->formattype	);
	    ASSERT(m_mt.cbFormat    == pmt->cbFormat );

	    memcpy(m_mt.pbFormat, pmt->pbFormat, sizeof(WAVEFORMATEX) );

	    m_pDVMuxer->m_MediaTypeChanged=TRUE;

	    // *************************
	    // BUILD NEW AAUX, ONLY SUPPORT AUDIO sample rate change 
	    // 48000,44100,32000, CHANGE ON FLY
	    // ***************************
	    
	    //get input video Mediatype
	    CMediaType *pInputVidMediaType = &m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN]->CurrentMediaType();
	    VIDEOINFO *pVideoInfo;
	    pVideoInfo=(VIDEOINFO *)pInputVidMediaType->pbFormat;
	    LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);
    
	    //get input audio Mediatype
	    CMediaType *ppInputAudMediaType[DVMUX_MAX_AUDIO_PIN];
	    //get input Audio's information
	    WAVEFORMATEX *ppwfx[DVMUX_MAX_AUDIO_PIN];

	    //how many language							 
	    int cnt=0;
	    for(int k=1; k <= DVMUX_MAX_AUDIO_PIN; k++)
		if( m_pDVMuxer->m_apInput[k] !=NULL)
		{
		    ASSERT(m_pDVMuxer->m_apInput[k]->IsConnected() );
		    if( m_pDVMuxer->m_apInput[k] != this )
		    {
			ppInputAudMediaType[k-1] = &m_pDVMuxer->m_apInput[k]->CurrentMediaType();
			ppwfx [k-1] = (WAVEFORMATEX *)ppInputAudMediaType[k-1]->pbFormat;
		    }
		    else
		    {
			ppwfx [k-1] = (WAVEFORMATEX *)pmt->pbFormat;
		    }
		    cnt++;  
		}
		else
		    ppwfx [k-1]=NULL;
        {
            CAutoLock lock(&m_pDVMuxer->m_csMuxLock);
	        // build new DVINFO
	        hr=BuildDVINFO(&m_pDVMuxer->m_OutputDVFormat,
    			    ppwfx,
    			    lpbi, 
    			    cnt,
                                m_pDVMuxer->m_AudSampleSequence,
    			    m_pDVMuxer->m_wMinAudSamples, 
    			    m_pDVMuxer->m_wMaxAudSamples,
                                m_pDVMuxer->m_wAudSamplesBase);
        }

	    //set new output format
            // @@@ jaisri: Safer to call SetMediaType or set m_pOutput->m_mt??
	    memcpy( m_pDVMuxer->m_pOutput->CurrentMediaType().pbFormat, &m_pDVMuxer->m_OutputDVFormat, sizeof(DVINFO) );


	} //end of media type change

	Copy(pAudSample,pSample);

	m_SampleList.AddTail(pAudSample);

#ifdef DEBUG
        WAVEFORMATEX *pWave =(WAVEFORMATEX *) CurrentMediaType().pbFormat ;

	int nSamples = pAudSample->GetActualDataLength()/pWave->nBlockAlign;

        DbgLog((LOG_TRACE, 3, TEXT("CDVMuxerInputPin::Receive: m_iPinNo=%d got %d samples"),
                m_iPinNo, nSamples));

#endif // ifdef DEBUG
        
	//try mux this audio sample with video data to build 10 DV DIF sequences (one frame)
	hr = m_pDVMuxer->Receive(  );
    }
    
    if(hr==Waiting_Audio)
	 return NOERROR;
    else
	 return hr;
}


STDMETHODIMP CDVMuxerInputPin::GetAllocatorRequirements(
    ALLOCATOR_PROPERTIES *pProps
)
{
    /*  Go for 4 0.5 second buffers - 8 byte aligned */

    // Manbugs 41398: This is a workaround in the case that the
    // MSDV vid only pin is connected to the dv mux. 
    // MSDV is hardcoded to having a max of 8 buffers. 
    pProps->cBuffers =  m_iPinNo ==DVMUX_VIDEO_INPUT_PIN? 8 : 10;
    pProps->cbBuffer = 1024*8;
    pProps->cbAlign = 4;
    pProps->cbPrefix = 0;
    return S_OK;
}

/* Get told which allocator the upstream output pin is actually going to use */
STDMETHODIMP CDVMuxerInputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
    	;
    else
    {
	ALLOCATOR_PROPERTIES propActual, Prop;
        HRESULT hr;
	
	//  always Copy audio
	m_fCpyAud=TRUE;
        CheckPointer(pAllocator,E_POINTER);
        ValidateReadPtr(pAllocator,sizeof(IMemAllocator));
        

        // @@@ jaisri: Why do we copy audio samples? 
        // There're some comments in CDVMuxerInputPin::Receive
        // about AVI splitter not liking us holding on to 
        // an audio sample, is this still true?

        // Note that, pre-DX8, m_pAllocator was used instead of
        // m_pLocalAllocator. If the muxer's audio pin was connected to 
        // a Ksproxy'd filter's pin, CDVMuxerInputPin::Receive hung 
        // when it received the first audio sample. KsProxy::Active
        // grabs all the allocator's buffers and hands it off to the device.
        // CDVMuxerInputPin::Receive then called m_pAllocator->GetBuffer
        // (so that it could copy the audio sample) and hung.
        //
        // Dazzle reported this problem - Manbugs 41400
        //
        // Post-DX8: re-examine why we are copying audio samples at all
        // and why we need this allocator.
        
        if( m_pLocalAllocator==NULL)
        {
            HRESULT hr = ::CreateMemoryAllocator(&m_pLocalAllocator);
	    if (FAILED(hr)) 
	        return hr;
	}

	hr = pAllocator->GetProperties( &Prop );
        ASSERT(SUCCEEDED(hr));
	    
	hr = m_pLocalAllocator->SetProperties(&Prop, &propActual);
	if (FAILED(hr)) 
	{
	    return hr;
	}

	if (propActual.cbBuffer < Prop.cbBuffer ) {
	    ASSERT(propActual.cbBuffer >= Prop.cbBuffer );
	    return E_INVALIDARG;
	}

        // All this should not be necessary since the output pin's DecideBufferSize
        // should have called SetProperties on m_pAllocator if it was the one
        // actually used to transfer samples. However, do this here to minimize the
        // risk of regressions in DX8 since the code was doing this before.
        if (m_pAllocator)
        {
            // Call GetProperties again just in case the previous call to SetProperties
            // changed *Prop - though it has no business doing that.
            hr = pAllocator->GetProperties( &Prop );
            ASSERT(SUCCEEDED(hr));

            hr = m_pAllocator->SetProperties(&Prop, &propActual);
	    if (FAILED(hr)) 
	    {
	        return hr;
	    }

	    if (propActual.cbBuffer < Prop.cbBuffer ) {
	        ASSERT(propActual.cbBuffer >= Prop.cbBuffer );
	        return E_INVALIDARG;
	    }
        }

	return NOERROR;
    }

    return  CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);
} // NotifyAllocator


//X 
HRESULT CDVMuxerInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    return VFW_S_NO_MORE_ITEMS;
}


// =================================================================
// Implements the CDVMuxerOutputPin class
// =================================================================
// constructor

CDVMuxerOutputPin::CDVMuxerOutputPin(
    TCHAR *pObjectName,
    CBaseFilter *pBaseFilter,
    CDVMuxer *pDVMux,
    HRESULT * phr,
    LPCWSTR pPinName)
    : CBaseOutputPin(pObjectName, pBaseFilter, &pDVMux->m_csFilter, phr, pPinName)
    //m_iOutputPin(pDVMux->m_iInputPinCount)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVMuxerOutputPin::CDVMuxerOutputPin")));
    m_pDVMuxer = pDVMux;

}

// destructor

CDVMuxerOutputPin::~CDVMuxerOutputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVMuxerOutputPin::~CDVMuxerOutputPin")));

}


//
// Called after we have agreed a media type to actually set it in which case
// we run the CheckTransform function to get the output format type again
//
HRESULT CDVMuxerOutputPin::SetMediaType(const CMediaType* pmtOut)
{
    HRESULT hr = NOERROR;
    
    if( (pmtOut->majortype == MEDIATYPE_Interleaved)							    &&
	(pmtOut->subtype   ==  MEDIASUBTYPE_dvsd )							    &&
	(pmtOut->formattype==FORMAT_DvInfo	)							    && 
	(pmtOut->cbFormat  == sizeof(DVINFO)	)							    &&	
	(pmtOut->pbFormat   != NULL		) 
	//(m_pDVMuxer->InputVideoConnected() )							    
       )
    {
	// Set the base class media type (should always succeed)
	hr = CBasePin::SetMediaType(pmtOut);
	ASSERT(SUCCEEDED(hr));
	m_pDVMuxer->m_OutputDVFormat=*( (DVINFO *) pmtOut->pbFormat );

	return hr;
    }	 //if'iavs'
    else 
	return E_UNEXPECTED;
}
//
// Input dv video pin has to be connected
// if output is 'iavs' stream, both audio and video have to be connected
//
HRESULT CDVMuxerOutputPin::CheckMediaType(const CMediaType* pmtOut)
{
    //insist its own mediatype
    CMediaType TmpMt;
    HRESULT hr = NOERROR;

    if(FAILED(hr = GetMediaType(0, &TmpMt)))
    {
        // couldn't get valid media type
        return hr;
    }
    
    if(TmpMt== *pmtOut)
	return NOERROR;
    else
	return E_FAIL;
}
	 
//X The Input dv video pin has to be connected before the output pin can be connected.
HRESULT CDVMuxerOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{								  

    if(iPosition != 0)
	return E_INVALIDARG;

    if(iPosition > 0)
	return VFW_S_NO_MORE_ITEMS;;

    DVINFO DVInfo;
    FillMemory ( &DVInfo, sizeof(DVINFO), 0); 
	
    //make outputpin's mediatype
    //'iavs' type
    pMediaType->majortype		= MEDIATYPE_Interleaved;
    pMediaType->bFixedSizeSamples	= 1;	//X* 1 for lSampleSize is not 0 and fixed
    pMediaType->bTemporalCompression	= FALSE; //no I frame exists
    pMediaType->formattype		= FORMAT_DvInfo; 
    pMediaType->cbFormat		= sizeof(DVINFO);
    if( m_pDVMuxer->m_iVideoFormat==IDC_DVMUX_PAL)
	pMediaType->lSampleSize = 140000L;
    else
	pMediaType->lSampleSize = 120000L;

	    
    if( m_pDVMuxer->InputVideoConnected()== FALSE )
    {
	pMediaType->subtype		= MEDIASUBTYPE_dvsd;

    	//give a defaul one, even video is no connected, we use default one to make connection
	DVInfo.dwDVAAuxSrc	= 0xc0c000d6;           // audio is locked
	DVInfo.dwDVAAuxCtl	= AM_DV_DEFAULT_AAUX_CTL;
	DVInfo.dwDVAAuxSrc1	= 0xc0c001d6;           // audio is locked
	DVInfo.dwDVAAuxCtl1	= AM_DV_DEFAULT_AAUX_CTL;
	DVInfo.dwDVVAuxSrc	= 0xff00ffff;
	DVInfo.dwDVVAuxCtl	= 0xfffcc83f;
	
    }
    else
    {	//build DVInfo according to input pin

	//##############get input video's information##############
	//get input video Mediatype
	CMediaType *pInputVidMediaType = &m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN]->CurrentMediaType();
	VIDEOINFO *pVideoInfo;
	pVideoInfo=(VIDEOINFO *)pInputVidMediaType->pbFormat;
	LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);
    
	//get input audio Mediatype
	CMediaType *ppInputAudMediaType[DVMUX_MAX_AUDIO_PIN];
	//get input Audio's information
	WAVEFORMATEX *ppwfx[DVMUX_MAX_AUDIO_PIN];

	//how many language							 
	int cnt=0;
	for(int k=1; k <= DVMUX_MAX_AUDIO_PIN; k++)
	    if( m_pDVMuxer->m_apInput[k] !=NULL)
	    {
		ASSERT(m_pDVMuxer->m_apInput[k]->IsConnected() );
		ppInputAudMediaType[k-1] = &m_pDVMuxer->m_apInput[k]->CurrentMediaType();
		ppwfx [k-1] = (WAVEFORMATEX *)ppInputAudMediaType[k-1]->pbFormat;
		cnt++;
	    }
	    else
		ppwfx [k-1]=NULL;

	//build DVINFO
	HRESULT hr=BuildDVINFO(&DVInfo, ppwfx,lpbi, cnt,
                               m_pDVMuxer->m_AudSampleSequence,
                               m_pDVMuxer->m_wMinAudSamples, m_pDVMuxer->m_wMaxAudSamples,
                               m_pDVMuxer->m_wAudSamplesBase);
	
        // @@@ jaisri: The way m_DVINFOChanged is used makes little sense.
        // First, we should never get NOERROR here (if we cleaned up the 
        // dynamic format change code). Second, even if we did, wouldn't the
        // connection of the output pin fail? We don't reset this variable
        // till a sample is sent on the output pin.

        //so, output sample can be set
	if(hr!=NOERROR)
	    m_pDVMuxer->m_DVINFOChanged=TRUE;
   
	pMediaType->subtype	= pInputVidMediaType->subtype;
    
	if(hr!=NOERROR)
	   return hr;
    }

     if(pMediaType->pbFormat==NULL)
	 pMediaType->pbFormat=(PBYTE)CoTaskMemAlloc( sizeof(DVINFO) );

    pMediaType->SetFormat ((unsigned char *)&DVInfo, sizeof(DVINFO) );

	    

    return NOERROR;
}

//----------------------------------------------------------------------------
// CDVMuxerOutputPin::DecideBufferSize
// X* called by DecideAllocate
// let get 10 buffers from down stream filter 
//----------------------------------------------------------------------------
HRESULT CDVMuxerOutputPin::DecideBufferSize (IMemAllocator *pMemAllocator,
                                         ALLOCATOR_PROPERTIES * pProp)
{
    // set the size of buffers based on the expected output frame size, and
    // the count of buffers to 1.
    //
    pProp->cBuffers = 10;			//10 DIF sequence per frame
    
    if(m_pDVMuxer->m_iVideoFormat==IDC_DVMUX_NTSC)
	pProp->cbBuffer =120000 ;	//*X* return m_mt.lSampleSize *X
    else
	pProp->cbBuffer =144000 ;	/*X* return m_mt.lSampleSize *X*/

    pProp->cbAlign = 4;
    pProp->cbPrefix = 0;
   	   
  
    ALLOCATOR_PROPERTIES propActual;
    HRESULT hr = m_pAllocator->SetProperties(pProp, &propActual);
    if (FAILED(hr)) {
        return hr;
    }

    if (propActual.cbBuffer < pProp->cbBuffer ) {
	ASSERT(propActual.cbBuffer >= pProp->cbBuffer );
        return E_INVALIDARG;
    }

    return S_OK;
}

// rMin, rMax set to min, max audio samples for first DV frame.
// rBase has the value that must be added to the AF_SIZE field.
// Init should be called after a format change and before the 
// first DV frame is delivered with the new format.
void CAudioSampleSizeSequence::Init(BOOL bLocked, BOOL bNTSC, 
                                    DWORD nSamplingFrequency,
                                    WORD& rMin, WORD& rMax,
                                    WORD& rBase)
{
    m_nCurrent = 1;
    if (bLocked && bNTSC)
    {
        if (nSamplingFrequency == 48000)
        {
            m_nSequenceSize = 5;
            rMin = rMax = 1600;
            rBase = 1580;
        }
        else
        {
            ASSERT(nSamplingFrequency == 32000 && bNTSC && bLocked);
            m_nSequenceSize = 15;
            rMin = rMax = 1066;
            rBase = 1053;
        }
    }
    else if (bLocked)
    {
        // PAL
        m_nSequenceSize = 1;
        switch (nSamplingFrequency)
        {
            case 48000:
                rMin = rMax = 1920;
                rBase = 1896;
                break;

            case 32000:
                rMin = rMax  = 1280;
                rBase = 1264;
                break;

            default:
		ASSERT(nSamplingFrequency==32000 && !bNTSC && bLocked);
                break;
        }
    }
    else
    {
        // Unlocked.
        m_nSequenceSize = 1;
        switch (nSamplingFrequency)
        {
            case 48000:
                rMin = bNTSC? 1580 : 1896;
                rMax = bNTSC? 1620 : 1944;
                rBase = rMin;
                break;

            case 44100:
                rMin = bNTSC? 1452 : 1742;
                rMax = bNTSC? 1489 : 1786;
                rBase = rMin;
                break;

            case 32000:
                rMin = bNTSC? 1053 : 1264;
                rMax = bNTSC? 1080 : 1296;
                rBase = rMin;
                break;

            default:
		ASSERT(nSamplingFrequency==32000);
                break;
        }
        
    }
} // CAudioSampleSizeSequence::Init()


// Called after each frame is delivered. Sets the min/max audio 
// samples for the next DV frame.
void CAudioSampleSizeSequence::Advance(WORD& rMin, WORD& rMax)
{
    ASSERT(m_nSequenceSize > 0);
    ASSERT(m_nCurrent > 0 && m_nCurrent <= m_nSequenceSize);

    if (m_nSequenceSize > 1)
    {
        // We use the sequence size to infer the frequency
        // to eliminate saving the frequency as a member var
        if (m_nSequenceSize == 5)
        {
            // NTSC, Sampling Frequency = 48000
            if (++m_nCurrent > m_nSequenceSize)
            {
                m_nCurrent = 1;
                rMin = rMax = 1600;
            }
            else
            {
                rMin = rMax = 1602;
            }
        }
        else
        {
            ASSERT(m_nSequenceSize == 15);

            // NTSC, Sampling Frequency == 32000
            if (++m_nCurrent > m_nSequenceSize)
            {
                m_nCurrent = 1;
                rMin = rMax = 1066;
            }
            else if (m_nCurrent == 8)
            {
                rMin = rMax = 1066;
            }
            else 
            {
                rMin = rMax = 1068;
            }
        }
    }
} // CAudioSampleSizeSequence::Advance()

// Called to reset counter to 1, typically on restarting the graph.
// Same as Init except that only rMin and rMax have to be changed
// and there is no need to supply the other input arguments.
void CAudioSampleSizeSequence::Reset(WORD& rMin, WORD& rMax)
{
    ASSERT(m_nSequenceSize > 0);
    ASSERT(m_nCurrent > 0 && m_nCurrent <= m_nSequenceSize);

    if (m_nSequenceSize > 1)
    {
        // We use the sequence size to infer the frequency
        // to eliminate saving the frequency as a member var
        if (m_nSequenceSize == 5)
        {
            // NTSC, Sampling Frequency = 48000
            m_nCurrent = 1;
            rMin = rMax = 1600;
        }
        else
        {
            ASSERT(m_nSequenceSize == 15);

            // NTSC, Sampling Frequency == 32000
            m_nCurrent = 1;
            rMin = rMax = 1066;
        }
    }
} // CAudioSampleSizeSequence::Reset()

  
/*X###################################################################
Accepted input audio formats
    pin	    stereo	Freqeuncy	    bits
    	    yes		32K, 44.1K, 48K	    16bits or 32K 12bits
    1	    ----
	    no		32K, 44.1K, 48K	    16bits only	
    -----------------------------------------------------------
	    yes		both pins=32K only  16bits or 12 bits
    2	    ----
	    no		32K, 44.1K, 48K     16 bits only
	    ----
	    mix		stereo pin ==32K	16 bits or 
			mon pin=32K,44.K,48K	16 bits only
Accepted video format
    biHeight  = 480(NTSC) or 576(PAL)
    will oupt dvsp only
######################################################################X*/
HRESULT BuildDVINFO(DVINFO *pDVInfo,
		    WAVEFORMATEX **ppwfx, 
		    LPBITMAPINFOHEADER lpbi, 
		    int cnt,
                    CAudioSampleSizeSequence* pAudSampleSequence,
		    WORD *wpMinAudSamples, 
		    WORD *wpMaxAudSamples,
                    WORD *wpAudSamplesBase)
{
    int k;

    //set 1st 5/6 DIF's reserved bits
    pDVInfo->dwDVAAuxSrc    = 0x00800040 | AM_DV_AUDIO_EF | AM_DV_AUDIO_ML|AM_DV_AUDIO_LF;  //no multiple lang. 
    pDVInfo->dwDVAAuxCtl    = AM_DV_DEFAULT_AAUX_CTL; 

    //set 2nd 5/6 DIF's reserved bits
    pDVInfo->dwDVAAuxSrc1   = 0x00800040 |AM_DV_AUDIO_EF | AM_DV_AUDIO_ML|AM_DV_AUDIO_LF;
    pDVInfo->dwDVAAuxCtl1    = AM_DV_DEFAULT_AAUX_CTL; 

    pDVInfo->dwDVVAuxSrc =AM_DV_DEFAULT_VAUX_SRC;
    pDVInfo->dwDVVAuxCtl =AM_DV_DEFAULT_VAUX_CTL;

    //set 50/60 and STYPE: PAL or NTSC
    if( lpbi->biHeight  != 480 )
    {
	//PAL
        //set 1st 5/6 DIF's 50/60
        pDVInfo->dwDVAAuxSrc |= AM_DV_AUDIO_5060; 
        //set 2nd 5/6 DIF's 50/60
        pDVInfo->dwDVAAuxSrc1 |= AM_DV_AUDIO_5060;

        pDVInfo->dwDVVAuxSrc |=AM_DV_AUDIO_5060;
    }
	

    switch ( cnt )
    {
	case 0:	    //no audio
	    pDVInfo->dwDVAAuxSrc	|= AM_DV_AUDIO_NO_AUDIO;
	    pDVInfo->dwDVAAuxSrc1	|= AM_DV_AUDIO_NO_AUDIO;
	    pDVInfo->dwDVAAuxCtl	|= AM_DV_AAUX_CTL_IVALID_RECORD;
	    pDVInfo->dwDVAAuxCtl1	|= AM_DV_AAUX_CTL_IVALID_RECORD ;
	    break;

	case 1:	    //one audio
		    //RULE: audio pin1 goes to 1st 5/6 DIF, Audio pin2 goes to 2nd 5/6 DIF, 
		    //Always!!!, even audio pin1 is not connected, audio pin2 still goes to 2nd 5/6  DIF
	    //which pin
	    if( ppwfx[0]!=NULL )
	    {
		ASSERT(ppwfx[1]==NULL);
		k=0;
	    }
	    else
	    {
		k=1;
		ASSERT(ppwfx[0]==NULL);
	    }
		
    	    //sample rate
	    switch  (	ppwfx [k]->nSamplesPerSec )
	    { 
		case 48000:
		    pDVInfo->dwDVAAuxSrc	|= AM_DV_AUDIO_SMP48;
		    pDVInfo->dwDVAAuxSrc1	|= AM_DV_AUDIO_SMP48;
		    pDVInfo->dwDVAAuxSrc        &= ~AM_DV_AUDIO_LF;     // turn audio locking on
		    pDVInfo->dwDVAAuxSrc1       &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[k].Init(1, lpbi->biHeight == 480, 48000,                                           
                                               wpMinAudSamples[k], wpMaxAudSamples[k],
                                               wpAudSamplesBase[k]); 
		    break;
		case 44100:
		    pDVInfo->dwDVAAuxSrc	|= AM_DV_AUDIO_SMP44;
		    pDVInfo->dwDVAAuxSrc1	|= AM_DV_AUDIO_SMP44;
                    pAudSampleSequence[k].Init(0, (lpbi->biHeight == 480 ), 44100,
                                               wpMinAudSamples[k], wpMaxAudSamples[k],
                                               wpAudSamplesBase[k]); 
		    break;
		case 32000:
		    // Note that 32K stereo is recorded in SD 4 ch mode (i.e., as 12 bit), so the PA bit is turned on.
                    // The Blue Book does not require this; but the comments below state that DV camcorders
                    // support only 12 bits for 32KHz audio. That is not easily verified, but we don't want a major 
                    // regression, so go with this. - jaisri
		    pDVInfo->dwDVAAuxSrc	|= ( AM_DV_AUDIO_SMP32 | AM_DV_AUDIO_EF |AM_DV_AUDIO_PA);
		    pDVInfo->dwDVAAuxSrc1	|= ( AM_DV_AUDIO_SMP32 | AM_DV_AUDIO_EF |AM_DV_AUDIO_PA);
		    pDVInfo->dwDVAAuxSrc        &= ~AM_DV_AUDIO_LF;     // turn audio locking on
		    pDVInfo->dwDVAAuxSrc1       &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[k].Init(1, (lpbi->biHeight == 480 ), 32000,
                                               wpMinAudSamples[k], wpMaxAudSamples[k],
                                               wpAudSamplesBase[k]); 
		    break;
		default:
		    ASSERT(ppwfx [k]->nSamplesPerSec==32000 ||
                           ppwfx [k]->nSamplesPerSec==44100 ||
                           ppwfx [k]->nSamplesPerSec==48000
                          );
		    return E_INVALIDARG;
	    }

	    //bits/samples
	    if ( ppwfx [k]->wBitsPerSample ==16 )
	    {
		if( ppwfx [k]->nChannels ==2 )
		{
		    if( ppwfx [k]->nSamplesPerSec == 32000 )
		    {
			//32k, has to convert  to 12 bits, the DV camcorder does not support
			//32k-16bits, 7-14-98
			if(!k)
			{
			    // Note the Blue Book (Table 16 or the second table on page 265) does
                            // not specify this combination. If SD 4ch has only stereo, the stereo
                            // should go in CH1, not CH2. But this has always been this way, so
                            // don't change it now - jaisri
			    pDVInfo->dwDVAAuxSrc |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
			    pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_NO_AUDIO | AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
		    	    pDVInfo->dwDVAAuxCtl1 |= AM_DV_AAUX_CTL_IVALID_RECORD;
        		}
			else{
			    pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
			    pDVInfo->dwDVAAuxSrc |= ( AM_DV_AUDIO_NO_AUDIO |AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
		    	    pDVInfo->dwDVAAuxCtl |= AM_DV_AAUX_CTL_IVALID_RECORD;
			}
		    }
		    else
		    {
			//left in 1st 5/6 DIF , CHN=0
			pDVInfo->dwDVAAuxSrc	|=  ( AM_DV_AUDIO_MODE0| AM_DV_AUDIO_QU16 );
			//right in 2nd 5/6 DIF, CHN=0
			pDVInfo->dwDVAAuxSrc1	|= ( AM_DV_AUDIO_MODE1 | AM_DV_AUDIO_QU16 );
		    }
		}
		else
		{
		    // Note that 32K 16 bit mono is recorded in SD 2 ch mode
                    // (i.e., as 16 bit rather than 12 bit) notwithstanding
                    // the "cameras cannot record 32K 16bit" comment.
                    // Always has been this way - jaisri

		    //if mono. one of following  will be set to AM_DV_AUDIO_NO_AUDIO later.
		    pDVInfo->dwDVAAuxSrc	|=  ( AM_DV_AUDIO_MODE2| AM_DV_AUDIO_QU16 | AM_DV_AUDIO_PA);
		    //right in 2nd 5/6 DIF, CHN=0
		    pDVInfo->dwDVAAuxSrc1	|= ( AM_DV_AUDIO_MODE2 | AM_DV_AUDIO_QU16 | AM_DV_AUDIO_PA);
		}
	    }
            else
            {
                ASSERT(ppwfx[k]->wBitsPerSample ==16);
		return E_INVALIDARG;
            }

	    //mono or stereo
	    if( ppwfx [k]->nChannels ==1 ) 
	    {
	        if(!k)
	        {   //audio pin1 is connected
		    //no audio in 2nd 5/6 DIF
		    pDVInfo->dwDVAAuxSrc1 |= ( AM_DV_AUDIO_NO_AUDIO | AM_DV_AUDIO_PA );
	    	    pDVInfo->dwDVAAuxCtl1 |= AM_DV_AAUX_CTL_IVALID_RECORD;
		}
		else
		{
		    //audio pin2 is connected, no audio in 1st 5/6 DIF
		    pDVInfo->dwDVAAuxSrc |= (AM_DV_AUDIO_NO_AUDIO  | AM_DV_AUDIO_PA);
	    	    pDVInfo->dwDVAAuxCtl |= AM_DV_AAUX_CTL_IVALID_RECORD;
		}
	    }
	    break;

	case 2: //both pins connected
	    //ML: multi-language
	    pDVInfo->dwDVAAuxSrc	&= (~AM_DV_AUDIO_ML);
	    pDVInfo->dwDVAAuxSrc1	&= (~AM_DV_AUDIO_ML);

	    //independent channel
	    pDVInfo->dwDVAAuxSrc	|= AM_DV_AUDIO_PA;
	    pDVInfo->dwDVAAuxSrc1	|= AM_DV_AUDIO_PA;

            if (ppwfx[0]->nSamplesPerSec != 32000 &&
                ppwfx[0]->nSamplesPerSec != 44100 &&
                ppwfx[0]->nSamplesPerSec != 48000)
            {
                ASSERT(ppwfx[0]->nSamplesPerSec == 32000 ||
                       ppwfx[0]->nSamplesPerSec == 44100 ||
                       ppwfx[0]->nSamplesPerSec == 48000);
                return E_INVALIDARG;
            }
	    
	    if (ppwfx[0]->nSamplesPerSec != ppwfx[1]->nSamplesPerSec)
            {
                ASSERT(ppwfx[0]->nSamplesPerSec == ppwfx[1]->nSamplesPerSec);
                return E_INVALIDARG;
            }

            if (ppwfx[0]->wBitsPerSample != 16)
            {
                ASSERT(ppwfx[0]->wBitsPerSample == 16);
                return E_INVALIDARG;
            }
            if (ppwfx[1]->wBitsPerSample != 16)
            {
	        ASSERT(ppwfx[1]->wBitsPerSample == 16);
                return E_INVALIDARG;
            }

            //###########sample rate
	    switch  (ppwfx[0]->nSamplesPerSec )
	    { 
		case 48000:
		    pDVInfo->dwDVAAuxSrc |= AM_DV_AUDIO_SMP48;
		    pDVInfo->dwDVAAuxSrc &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[0].Init(1, lpbi->biHeight == 480, 48000,                                           
                                               wpMinAudSamples[0], wpMaxAudSamples[0],
                                               wpAudSamplesBase[0]); 
		    pDVInfo->dwDVAAuxSrc1 |= AM_DV_AUDIO_SMP48;
		    pDVInfo->dwDVAAuxSrc1 &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[1].Init(1, lpbi->biHeight == 480, 48000,
                                               wpMinAudSamples[1], wpMaxAudSamples[1],
                                               wpAudSamplesBase[1]); 
		    break;
		case 44100:
		    pDVInfo->dwDVAAuxSrc |= AM_DV_AUDIO_SMP44;
                    pAudSampleSequence[0].Init(0, lpbi->biHeight == 480, 44100,
                                               wpMinAudSamples[0], wpMaxAudSamples[0],
                                               wpAudSamplesBase[0]); 
		    pDVInfo->dwDVAAuxSrc1 |= AM_DV_AUDIO_SMP44;
                    pAudSampleSequence[1].Init(0, lpbi->biHeight == 480, 44100,
                                               wpMinAudSamples[1], wpMaxAudSamples[1],
                                               wpAudSamplesBase[1]); 
		    break;
		case 32000:
		    pDVInfo->dwDVAAuxSrc |= (AM_DV_AUDIO_SMP32| AM_DV_AUDIO_EF |AM_DV_AUDIO_PA);
		    pDVInfo->dwDVAAuxSrc &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[0].Init(1, lpbi->biHeight == 480, 32000,
                                               wpMinAudSamples[0], wpMaxAudSamples[0],
                                               wpAudSamplesBase[0]); 
		    pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_SMP32| AM_DV_AUDIO_EF |AM_DV_AUDIO_PA);
		    pDVInfo->dwDVAAuxSrc1 &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[1].Init(1, lpbi->biHeight == 480, 32000,
                                               wpMinAudSamples[1], wpMaxAudSamples[1],
                                               wpAudSamplesBase[1]); 
		    break;
	    }

	    //#######bits/samples
	    if( ppwfx [0]->nChannels	==2		&& 
		ppwfx [1]->nChannels	==2		&&
		ppwfx[0]->nSamplesPerSec == 32000)
	    {
		//if both stereo audio, 32K is required
		pDVInfo->dwDVAAuxSrc  |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_QU12);
	    	pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_QU12);
	    }
	    else if(ppwfx[1]->nChannels	==1		&& 
		    ppwfx[0]->nChannels	==2		&&
		    ppwfx[0]->nSamplesPerSec    == 32000
		   ) 
	    {
		//if one is stereo audio, 32K is required
		pDVInfo->dwDVAAuxSrc	|= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_QU12);
		pDVInfo->dwDVAAuxSrc1	|= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE1 | AM_DV_AUDIO_QU12 );
	    }
	    else if(ppwfx[0]->nChannels	==1		&& 
		    ppwfx[1]->nChannels	==2		&&
		    ppwfx[0]->nSamplesPerSec    == 32000
		   ) 
	    {
		//if one is stereo audio, 32K is required
		pDVInfo->dwDVAAuxSrc1	|= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_QU12);
		pDVInfo->dwDVAAuxSrc	|= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE1 | AM_DV_AUDIO_QU12 );
	    }
	    else if(ppwfx[0]->nChannels	==1		&& 
		    ppwfx[1]->nChannels	==1		
		    )
	    {
		pDVInfo->dwDVAAuxSrc	|= ( AM_DV_AUDIO_MODE2 | AM_DV_AUDIO_QU16 );
		pDVInfo->dwDVAAuxSrc1	|= ( AM_DV_AUDIO_MODE2 | AM_DV_AUDIO_QU16 );
	    }
	    else
            {
		ASSERT(0);
                return E_INVALIDARG; 
            }
	    break;

        default:
            ASSERT(0);
	    return E_INVALIDARG;
    } //switch ( cnt )

    return NOERROR;
}   //end BuildDVINFO()

//IMediaSeeking
HRESULT CDVMuxer::IsFormatSupported(const GUID * pFormat)
{
  return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CDVMuxer::QueryPreferredFormat(GUID *pFormat)
{
  *pFormat = TIME_FORMAT_MEDIA_TIME;
  return S_OK;
}

HRESULT CDVMuxer::SetTimeFormat(const GUID * pFormat)
{
  HRESULT hr = S_OK;
  if(*pFormat == TIME_FORMAT_MEDIA_TIME)
    m_TimeFormat = FORMAT_TIME;

  return hr;
}

HRESULT CDVMuxer::IsUsingTimeFormat(const GUID * pFormat)
{
  HRESULT hr = S_OK;
  if (m_TimeFormat == FORMAT_TIME && *pFormat == TIME_FORMAT_MEDIA_TIME)
    ;
  else
    hr = S_FALSE;

  return hr;
}

HRESULT CDVMuxer::GetTimeFormat(GUID *pFormat)
{
  *pFormat = TIME_FORMAT_MEDIA_TIME ;

  return S_OK;
}

HRESULT CDVMuxer::GetDuration(LONGLONG *pDuration)
{
  HRESULT hr = S_OK;
  CAutoLock lock(&m_csFilter);

  if(m_TimeFormat == FORMAT_TIME)
  {
    *pDuration = 0;
    for(int i = 0; i < m_iInputPinCount; i++)
    {

      if(m_apInputPin[i]->IsConnected())
      {
        IPin *pPinUpstream;
        if(m_apInputPin[i]->ConnectedTo(&pPinUpstream) == S_OK)
        {
          IMediaSeeking *pIms;
          hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
          if(SUCCEEDED(hr))
          {
            LONGLONG dur = 0;
	    LONGLONG stop = 0;
            hr = pIms->GetPositions(&dur, &stop);

            if(SUCCEEDED(hr))
              *pDuration = max(stop, *pDuration);

            pIms->Release();
          }

          pPinUpstream->Release();
        }
      }

      if(FAILED(hr))
        break;
    }
  }
  else
  {
    *pDuration = 0;
    return E_UNEXPECTED;
  }

  return hr;
}

HRESULT CDVMuxer::GetStopPosition(LONGLONG *pStop)
{
  return E_NOTIMPL;
}

HRESULT CDVMuxer::GetCurrentPosition(LONGLONG *pCurrent)
{
  CheckPointer(pCurrent, E_POINTER);

  if(m_TimeFormat == FORMAT_TIME)
      *pCurrent = m_LastVidTime;
    
  return S_OK;
}

HRESULT CDVMuxer::GetCapabilities( DWORD * pCapabilities )
{
  CAutoLock lock(&m_csFilter);
  *pCapabilities = 0;

  // for the time format, we can get a duration by asking the upstream
  // filters
  if(m_TimeFormat == FORMAT_TIME)
  {
    *pCapabilities |= AM_SEEKING_CanGetDuration;
    for(int i = 0; i < m_iInputPinCount; i++)
    {
      if(m_apInputPin[i]->IsConnected())
      {
        IPin *pPinUpstream;
        if(m_apInputPin[i]->ConnectedTo(&pPinUpstream) == S_OK)
        {
          IMediaSeeking *pIms;
          HRESULT hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
          if(SUCCEEDED(hr))
          {
            hr = pIms->CheckCapabilities(pCapabilities);
            pIms->Release();
          }

          pPinUpstream->Release();
        }
      }
    }
  }

  // we always know the current position
  *pCapabilities |= AM_SEEKING_CanGetCurrentPos ;

  return S_OK;
}

HRESULT CDVMuxer::CheckCapabilities( DWORD * pCapabilities )
{
  DWORD dwMask = 0;
  GetCapabilities(&dwMask);
  *pCapabilities &= dwMask;

  return S_OK;
}


HRESULT CDVMuxer::ConvertTimeFormat(
  LONGLONG * pTarget, const GUID * pTargetFormat,
  LONGLONG    Source, const GUID * pSourceFormat )
{
  return E_NOTIMPL;
}


HRESULT CDVMuxer::SetPositions(
  LONGLONG * pCurrent,  DWORD CurrentFlags,
  LONGLONG * pStop,  DWORD StopFlags )
{
  // not yet implemented. this might be how we append to a file. and
  // how we write less than an entire file.
  return E_NOTIMPL;
}


HRESULT CDVMuxer::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
  HRESULT hr;
  if( pCurrent )
    *pCurrent = m_LastVidTime;
  
  hr=GetDuration( pStop);
  
  return hr;
}

HRESULT CDVMuxer::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
  return E_NOTIMPL;
}

HRESULT CDVMuxer::SetRate( double dRate)
{
  return E_NOTIMPL;
}

HRESULT CDVMuxer::GetRate( double * pdRate)
{
  return E_NOTIMPL;
}

HRESULT CDVMuxer::GetPreroll(LONGLONG *pPreroll)
{
  return E_NOTIMPL;
}

//
// NonDelegatingQueryInterface
//
//
STDMETHODIMP
CDVMuxer::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
  if(riid == IID_IMediaSeeking)
  {
    return GetInterface((IMediaSeeking *)this, ppv);
  }
  else
  {
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvsp\dvsp.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <tchar.h>
#include <stdio.h>
#include "dvsp.h"
// how to build an explicit FOURCC
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))


HRESULT BuildDVAudInfo(DVINFO *InputFormat, WAVEFORMATEX **ppwfx, DVAudInfo *pDVAudInfo);
HRESULT BuildAudCMT(DVINFO *pDVInfo, CMediaType **ppOutCmt);
HRESULT BuildVidCMT(DVINFO *pDvinfo, CMediaType *pOutCmt);

// ------------------------------------------------------------------------
// setup data

const AMOVIESETUP_MEDIATYPE sudDVSPIpPinTypes[] =
{
    {&MEDIATYPE_Interleaved,       // MajorType
    &MEDIASUBTYPE_dvsd},         // MinorType
    {&MEDIATYPE_Interleaved,       // MajorType
    &MEDIASUBTYPE_dvhd},         // MinorType
    {&MEDIATYPE_Interleaved,       // MajorType
    &MEDIASUBTYPE_dvsl}         // MinorType

};

const AMOVIESETUP_MEDIATYPE sudDVSPOpPinTypes =
{
    &MEDIATYPE_Video,             // MajorType
    &MEDIASUBTYPE_NULL            // MinorType
};

const AMOVIESETUP_MEDIATYPE sudDVSPAudioOutputType =
{
    &MEDIATYPE_Audio, 
    &MEDIASUBTYPE_PCM 
};


const AMOVIESETUP_PIN psudDVSPPins[] =
{
  { L"Input",                     // strName
    FALSE,                        // bRendererd
    FALSE,                        // bOutput
    FALSE,                        // bZero
    FALSE,                        // bMany
    &CLSID_NULL,                  // connects to filter 
    NULL,                         // connects to pin
    NUMELMS(sudDVSPIpPinTypes),   // nMediaTypes
    sudDVSPIpPinTypes  }          // lpMediaType
,
    { L"Audio Output",
      FALSE,                               // bRendered
      TRUE,                                // bOutput
      TRUE,                                // bZero
      FALSE,                               // bMany
      &CLSID_NULL,                         // clsConnectsToFilter
      NULL,                                // ConnectsToPin
      1,				    // Number of media types
      &sudDVSPAudioOutputType    }
,
    { L"Video Output",
      FALSE,                               // bRendered
      TRUE,                                // bOutput
      TRUE,                                // bZero
      FALSE,                               // bMany
      &CLSID_NULL,                         // clsConnectsToFilter
      NULL,                                // ConnectsToPin
      1,				   // Number of media types
      &sudDVSPOpPinTypes }		   // lpMediaType
};


const AMOVIESETUP_FILTER sudDVSplit =
{
    &CLSID_DVSplitter,		// clsID
    L"DV Splitter",		// strName
    MERIT_NORMAL,               // dwMerit
    3,                          // nPins
    psudDVSPPins                // lpPin
};
// nothing to say about the output pin





CUnknown *CDVSp::CreateInstance (LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CDVSp (NAME("DV Splitter Filter"), pUnk, phr) ;
}

//for calc audio samples /frame
int aiAudSampPerFrmTab[2][3]={{1580,1452,1053},{1896,1742,1264}};
int aiAudSampFrq[3]={48000,44100,32000};

//----------------------------------------------------------------------------
// CDVSp::NonDelegatingQueryInterface
//----------------------------------------------------------------------------
STDMETHODIMP CDVSp::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IDVSplitter)
    {
        DbgLog((LOG_TRACE,5,TEXT("CDVSp: QId for IDVSplitter")));
        return GetInterface(static_cast<IDVSplitter*>(this), ppv);
    }
    else
    {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

//----------------------------------------------------------------------------
// CDVSp::DiscardAlternateVideoFrames
//----------------------------------------------------------------------------
STDMETHODIMP CDVSp::DiscardAlternateVideoFrames(int nDiscard)
{
    CAutoLock lck(m_pLock);

    if (m_State != State_Stopped)
    {
        DbgLog((LOG_TRACE,5,TEXT("CDVSp: Error: IDVSplitter::DiscardVideo called while graph not stopped; nDiscard=%d"), nDiscard));
        return E_UNEXPECTED;
    }

    DbgLog((LOG_TRACE,5,TEXT("CDVSp: IDVSplitter::DiscardVideo called: nDiscard=%d, m_b15fps was %d"), nDiscard, m_b15FramesPerSec));

    m_b15FramesPerSec = nDiscard != 0;

    // Don't need this since we allow this only in the Stopped state
    // and Pause toggles this to TRUE
    // if (!nDiscard)
    // {
    //     m_bDeliverNextFrame = TRUE;
    // }
    return S_OK;
}


//----------------------------------------------------------------------------
// CDVSp constructor
//----------------------------------------------------------------------------
#pragma warning(disable:4355) // using THIS pointer in constructor for base objects
CDVSp::CDVSp (TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
 : m_lCanSeek (TRUE),
   m_pAllocator (NULL),
   m_NumOutputPins(0),
   m_Input (NAME("Input Pin"), this, phr, L"Input"),
   m_pVidOutputPin(NULL),
   m_AudioStarted(1),
   m_bNotSeenFirstValidFrameFlag(TRUE),
   m_bFirstValidSampleSinceStartedStreaming(TRUE),
   m_b15FramesPerSec(FALSE),
   m_bDeliverNextFrame(TRUE),                      
   CBaseFilter (NAME("DVSp Tee Filter"), pUnk, this, CLSID_DVSplitter)	//,phr)
{
	
    DbgLog((LOG_TRACE,2,TEXT("CDVSp constructor")));

    ASSERT (phr) ;

    for(int i=0; i<2; i++)
    {
	m_pAudOutputPin[i]	=NULL;
   	m_pAudOutSample[i]	=NULL;
    	m_MuteAud[i]		=FALSE;
	m_Mute1stAud[i]		=FALSE;
    }
    
    m_tStopPrev =0;

}
#pragma warning(default:4355)

//----------------------------------------------------------------------------
// CDVSp destructor
//----------------------------------------------------------------------------
CDVSp::~CDVSp()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSp destructor")));
    RemoveOutputPins();
}

// Return our current state and a return code to say if it's stable
// If we're splitting multiple streams see if one is potentially stuck
// and return VFW_S_CANT_CUE
STDMETHODIMP
CDVSp::GetState(DWORD dwMSecs, FILTER_STATE *pfs)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer( pfs, E_POINTER );
    ValidateReadWritePtr(pfs,sizeof(FILTER_STATE));

    *pfs = m_State;
    if (m_State == State_Paused) {
        return CheckState();
    } else {
        return S_OK;
    }
}

/* Check if a stream is stuck - filter locked on entry

   Returns S_OK           if no stream is stuck
           VFW_S_CANT_CUE if a stream is stuck

   A stream is stuck if:
	  // @@@ jaisri Why is it stuck if there is no audio in the 
          // first frame??? And, anyway, m_Mute1stAud[i] is set to 
          // TRUE for any frame, not just the first frame.
          Audio pin is connected && there is no audio in the first DV frame 

  A single stream can't get stuck because if all its data has been
   processed the allocator will have free buffers
*/
HRESULT CDVSp::CheckState()
{
    if (m_NumOutputPins <= 1) {
        /*  Can't stick on one pin */
        return S_OK;
    }

    if( m_Mute1stAud[0]==TRUE || m_Mute1stAud[1]==TRUE  )
        return VFW_S_CANT_CUE;
    else
	return S_OK;
}

//----------------------------------------------------------------------------
// CDVSp::GetPinCount, *X*
//----------------------------------------------------------------------------
int CDVSp::GetPinCount()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSp::GetPinCount")));
   
    return 1 + m_NumOutputPins;
}
 
// Stop
STDMETHODIMP CDVSp::Stop()
{
  {
  
    CAutoLock lckFilter(m_pLock);

    CDVSpOutputPin *pOutputPin;
    for(int i=DVSP_VIDOUTPIN; i<=DVSP_AUDOUTPIN2; i++)
    {
    pOutputPin=(CDVSpOutputPin *)GetPin(i);
    if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
    {
        if(pOutputPin->m_pOutputQueue!=NULL)
        {
        pOutputPin->m_pOutputQueue->BeginFlush();
        pOutputPin->m_pOutputQueue->EndFlush();
        }
            pOutputPin->CBaseOutputPin::Inactive();
    }
    }

    for(i=0; i<2; i++)
    {
        m_Mute1stAud[i]		=FALSE;
    }
    
    // re-init
    m_tStopPrev =0;
    m_bNotSeenFirstValidFrameFlag = TRUE;
    // m_bDeliverNextFrame = TRUE; Not necessary - this is set in Pause

    //release the filter Critical Section first
  }

  // tell each pin to stop
  CAutoLock lck(&m_csReceive);
  
  
  
  HRESULT hr = CBaseFilter::Stop();
  
  // Reset the Dropped Frame flag
  m_Input.m_bDroppedLastFrame = FALSE;

  return hr;

}

// Pause
STDMETHODIMP
CDVSp::Pause()
{
    HRESULT hr = NOERROR;
    CAutoLock lck(m_pLock); 

    // this is to help dynamic format changes happen when we are
    // stopped in the middle of one.
    // set our flag so we can send a media type on the first sample
    // but only do this if we are starting to stream
    if(m_State == State_Stopped)
    {
        m_bFirstValidSampleSinceStartedStreaming = TRUE;
        m_bDeliverNextFrame = TRUE;
    }

    // call base class pause()
    hr = CBaseFilter::Pause();

    return hr;
}

//----------------------------------------------------------------------------
// CDVSp::GetPin, *X*
// n=0: input pin
// n=1: videopin
// n=2: audio1
// n=3: audio2
//#define DVSP_INPIN 0
//#define DVSP_VIDOUTPIN    1
//#define DVSP_AUDOUTPIN1   2
//#define DVSP_AUDOUTPIN2   3
//----------------------------------------------------------------------------
CBasePin *CDVSp::GetPin(int n)
{
    
    DbgLog((LOG_TRACE,2,TEXT("CDVSp::GetPin")));

    // CAutoLock lck(m_pLock); // Removed as per RobinSp's code review comment
      
    // get the head of the list
   
    CDVSpOutputPin *pOutputPin ;
    
	if( n>m_NumOutputPins )
		return NULL ;

	switch(n){
	case DVSP_INPIN:
		return &m_Input;
	case 1:
		pOutputPin=m_pVidOutputPin;
		break;
	case 2:
		pOutputPin=	m_pAudOutputPin[0];
		break;
	case 3:
		pOutputPin=	m_pAudOutputPin[1];
		break;
	default:
		DbgLog((LOG_TRACE,2,TEXT("CDVSp::GetPin's n>NumOutputPins")));
		return NULL ;
	}
	return pOutputPin ;
}

//----------------------------------------------------------------------------
// CDVSp::RemoveOutputPins() *X*
//----------------------------------------------------------------------------
HRESULT CDVSp::RemoveOutputPins()
{
    CDVSpOutputPin *pPin;

    for(int i=0; i< m_NumOutputPins; i++)
    {
	pPin=NULL;

	if( i==VIDEO_OUTPIN)
	{
	    pPin=m_pVidOutputPin;
	    m_pVidOutputPin=NULL;
	}
	else if(i==AUDIO_OUTPIN1)
	    {
		pPin=m_pAudOutputPin[0];
		m_pAudOutputPin[0]=NULL;
	    }
	    else if(i==AUDIO_OUTPIN2)
		{
		    pPin=m_pAudOutputPin[1];
		    m_pAudOutputPin[1]=NULL;
		}

	if(pPin!=NULL){	
	    // If this pin holds the seek interface release it
	    if (pPin->m_bHoldsSeek) {
		InterlockedExchange(&m_lCanSeek, FALSE);
		pPin->m_bHoldsSeek = FALSE;
		delete pPin->m_pPosition;
	    }

	    IPin *pPeer = pPin->GetConnected();
	    if(pPeer != NULL)
	    {
    		pPeer->Disconnect();
		pPin->Disconnect();
	    }
		
	    pPin->Release();
	}
    }
    m_NumOutputPins=0;

    return S_OK;
}

/*X/----------------------------------------------------------------------------
// CDVSp::CreatOutputPins. The InputPin should not creat outputpin directly
//----------------------------------------------------------------------------*X*/
HRESULT 
CDVSp::CreateOrReconnectOutputPins()
{
	// Check inputpin's mediatype to decider 
	// how many out output pins we need

	WCHAR szbuf[20];                        // scratch buffer
	TCHAR tchar[20];
	ULONG uTmp=100;
	CDVSpOutputPin *pPin;
	CMediaType  *paCmt[2], Cmt[2];
        CMediaType& Inmt = m_Input.m_mt;
	HRESULT hr=E_FAIL;
	
	paCmt[0] =&Cmt[0];	
	paCmt[1] =&Cmt[1];	

	//rebuild m_sDVAudInfo based on new input media type
	hr=BuildDVAudInfo((DVINFO *)Inmt.pbFormat,NULL, &m_sDVAudInfo);
	if(m_sDVAudInfo.bNumAudPin)
	{
    	    BuildAudCMT((DVINFO *)Inmt.pbFormat, paCmt);
	}

	//*X*****************Video Pin****************************************
	if( m_pVidOutputPin == NULL )
        {
	    //X***************** creat a VIDEO putput pin **********************
            lstrcpyW(szbuf, L"DVVidOut0");
	    lstrcpy(tchar, TEXT("DV Video Output0"));
	    HRESULT hr = NOERROR ;
	    pPin = new CDVSpOutputPin ( tchar, 
				this,
				&hr, 
				szbuf);

	    if (!FAILED (hr) && pPin)
	    {
		uTmp=pPin->AddRef () ;
		m_NumOutputPins++;
		m_pVidOutputPin=pPin;
	    }
	}
	else
	{
	    //X****** if Video pin was connected and media type changed, reconnect
	    if( m_pVidOutputPin->IsConnected() )
	    {
		CMediaType cmType;

		hr=BuildVidCMT((DVINFO *)Inmt.pbFormat, &cmType);

		if( cmType != m_pVidOutputPin->m_mt )
		{
		    hr=ReconnectPin( m_pVidOutputPin,&cmType);
		}
	    }	
	}


	//*X*****************Audio Pins****************************************

	// jaisri: CDVSpInputPin::CheckMediaType has already verified that
        // any existing audio pin connections are compatible with the new
        // input pin connection (it calls QueryAccept on the connected pin)
        int cnt=m_sDVAudInfo.bNumAudPin;
	for(int i=0; i<2; i++)
	{
	    if( i >= cnt )
	    {
 	   	//do not need this pin anymore
		if(m_pAudOutputPin[i])
		{
		    // jaisri: The pin cannot be connected - this follows 
                    // from the comment just before the for loop. However,
                    // leave the code as is - to be safe.
                    //
                    // Specifically, what this means is that once a pin is
                    // created, it is never deleted (and m_pAudOutputPin[i]
                    // is never reset to NULL) until RemoveOutputPins is called.
                    // Currently, RemoveOutputPins is called only from the 
                    // destructor for CDVSp.
                    //
                    // Since m_pAudOutputPin[0] is created before m_pAudOutputPin[1],
                    // this also means that m_pAudOutputPin[0] cannot be
                    // NULL if m_pAudOutputPin[1] is not NULL.
            
            if( m_pAudOutputPin[i]->IsConnected() ) 
		    {		
    			IPin *pPeer = m_pAudOutputPin[i]->GetConnected();
    			if(pPeer != NULL)
    			{
        			    pPeer->Disconnect();
    			    m_pAudOutputPin[i]->Disconnect();
    			    m_pAudOutputPin[i]->Release();
    			    m_pAudOutputPin[i]	=NULL;
    			}
    			else
    			    ASSERT(pPeer);
		    }
            else
            {
                // jaisri: We could delete the audio pin. However, since
                // the mediatype returned by CDVSpOutputPin::GetMediaType
                // will be invalid, it won't be possible to connect it 
                // to anything. So, let it remain.
            }
		}
	    }
	    else
	    {
		//yes we want this pin
		if( m_pAudOutputPin[i] == NULL )
		{
		    //X***************** creat a audio putput pin **********************
		    
		    lstrcpy(tchar, TEXT("Audio Output 00"));
		    tchar[13] += i / 10;
		    tchar[14] += i % 10;
		    lstrcpyW(szbuf, L"AudOut00");
		    szbuf[6] += i / 10;
		    szbuf[7] += i % 10;
		    hr = NOERROR ;
		    pPin = new CDVSpOutputPin (	tchar, 
					this,
					&hr, 
					szbuf);

		    if (!FAILED (hr) && pPin){
	    		uTmp=pPin->AddRef () ;
			m_NumOutputPins++;
			m_pAudOutputPin[i]=pPin;
		    }
		}
		else
		{
		    //X****** the audio pin already existed, check whether we need to reconnected
		    if( m_pAudOutputPin[i]->IsConnected() )
		    {
			if( Cmt[i] != m_pAudOutputPin[i]->m_mt )
			    hr=ReconnectPin( m_pAudOutputPin[i],&Cmt[i]);
		    }
		}	
	    }
    	}
	
	return S_OK;
}


/*X/--------------------------z--------------------------------------------------
// CDVSp::NotifyInputConnected(), called by CDVSpInputPin::CompleteConnect()
//----------------------------------------------------------------------------*X*/
HRESULT CDVSp::NotifyInputConnected()
{
    // these are reset when disconnected
    //X8 10-30-97 EXECUTE_ASSERT(m_NumOutputPins == 0);

    //creat output pins	
    HRESULT hr = this->CreateOrReconnectOutputPins();

    return hr;
}

//----------------------------------------------------------------------------
// HRESULT CDVSp::DecodingDeliveAudio(IMediaSample *pSample) 
//----------------------------------------------------------------------------
//
// Please refer to these BlueBook pages when reading these functions
// BlueBook Part2
// pp. 16-21 (Audio Signal Processing)
// pp. 68-75 (shuffling patterns for audio)
// pp. 109 - 117 (Basic DV Frame Data Structures)
// pp. 262 - 268 (AAUX Source and Source Control Packet spec.)
//
// General Algorithm:
// 1) Figure out how many streaming audio output pins we have
// 2) Try to detect a format change (do a QueryAccept downstream and change our output pin's media type)
// 3) Compute size of outgoing sample
// 4) Descramble the audio to construct the output sample
// 5) If format change is occuring or if this is the first sample since we started streaming
//      slap on the current output media type.
// 7) Deliver Sample to output queue
HRESULT CDVSp::DecodeDeliveAudio(IMediaSample *pSample) 
{
    HRESULT hr=NOERROR;
    CMediaType mt;

    BYTE	*pSrc;
    BYTE	*pDst;
    BYTE	bTmp;
    BYTE	*pbTmp;
    long	lBytesPerFrm;
    BYTE	bConnectedAudPin;
    BYTE	bAudPinInd;
    BYTE	bAudInDIF;
    INT		iPos;
    AM_MEDIA_TYPE   *pmt	=NULL;
    WAVEFORMATEX    *pawfx[2];
    CMediaType	    cmType[2];
    BYTE	    fAudFormatChanged[2]={FALSE, FALSE};

    // used to deliver silence for this sample in case this is a bad frame (with garbage data)
    BOOL        bSilenceThisSampleFlag = FALSE;
    

    //X* how many pin is conneced
    if ( m_pAudOutputPin[0] && m_pAudOutputPin[0]->IsConnected() )
    {
	if ( !m_pAudOutputPin[1] || !m_pAudOutputPin[1]->IsConnected() )
	{
	    //only pin 1 connected
	    bConnectedAudPin=1;
	    bAudPinInd=0;
	}
	else if ( m_pAudOutputPin[1]  && m_pAudOutputPin[1]->IsConnected() )
        {
            //pin1 and pin2 both connected
            bConnectedAudPin=2;
            bAudPinInd=0;
        }

    }
    else if ( m_pAudOutputPin[1] && m_pAudOutputPin[1]->IsConnected() )
    {
        //only pin 2 connected
        bConnectedAudPin=1;
        bAudPinInd=1; 
    }
    else
    {
        // no audio pins connected
        // don't care about invalid frames any more (no audio format changes will be happening)
        m_bNotSeenFirstValidFrameFlag = FALSE;
        m_AudioStarted=1;
        goto RETURN;
    }

  
    
    //X* get the source buffer which contains 10/12 DIF sequences
    hr = pSample->GetPointer(&pSrc);
    if (FAILED(hr)) {
        goto RETURN;
    }

    
    //*******check if format is changed*****
    pSample->GetMediaType(&pmt);
    if (pmt != NULL && pmt->pbFormat != NULL )
    {
	//******the upstream pin tells us audio format is changed.******
	pawfx[0] = (WAVEFORMATEX *)cmType[0].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
	pawfx[1] = (WAVEFORMATEX *)cmType[1].ReallocFormatBuffer(sizeof(WAVEFORMATEX));

        // set "Not seen valid first frame" flag to false, because we can assume that this is a valid frame
        if(m_bNotSeenFirstValidFrameFlag)
        {
            m_bNotSeenFirstValidFrameFlag = FALSE;
        }
        
	//rebuild  DVAudInfo m_sDVAudInfo;
	DVINFO *InputFormat=(DVINFO *)pmt->pbFormat;

        DVAudInfo dvaiTemp;
        hr = BuildDVAudInfo( InputFormat, pawfx, &dvaiTemp) ;

        // only perform a format change downstream if
        // 1) We could build a valid DVAudInfo
        // 2) The new DVAudInfo is different from the current one
        // 3) the new format is different from the current format
        if( (SUCCEEDED(hr))
            && (memcmp((void*) &m_sDVAudInfo, (void*) &dvaiTemp, sizeof(DVAudInfo))) )
        {

            // copy new DVINFO (because it may change even if output AM_MEDIA_TYPE doesn't change
            memcpy((void*) &m_sDVAudInfo, (void*) &dvaiTemp, sizeof(DVAudInfo));
	    memcpy((unsigned char *)&m_LastInputFormat,(unsigned char *)InputFormat,sizeof(DVINFO) );

	    //*X* 3/2/99, we do not support audio change from one language to two on fly
	    if( (dvaiTemp.bNumAudPin ==2) && 
		    (m_pAudOutputPin[1] ==NULL) )
	    {
		    //audio change from one lanquage to two
		    //we can only care one now
		    dvaiTemp.bNumAudPin=1;
	    }

	    for(int i=0; i<dvaiTemp.bNumAudPin; i++) 
	    {
	        //Create mediatype for audio
	        cmType[i].majortype=MEDIATYPE_Audio; //streamtypeAUDIO
	        cmType[i].subtype=MEDIASUBTYPE_PCM; 
	        cmType[i].bFixedSizeSamples=1;	//X* 1 for lSampleSize is not 0 and fixed
	        cmType[i].bTemporalCompression=0; 
	        cmType[i].formattype=FORMAT_WaveFormatEx;
	        cmType[i].cbFormat=sizeof(WAVEFORMATEX); /*X* for audio render connection *X*/
    	        cmType[i].lSampleSize   =(dvaiTemp.wAvgSamplesPerPinPerFrm[i] + 50) << pawfx[i]->nChannels; //max sample for all case is < m_sDVAudInfo.wAvgSamplesPerPinPerFrm[i] + 50
	        //copy audio format
	        cmType[i].SetFormat ((BYTE *)pawfx[i], sizeof(WAVEFORMATEX));
	        
	        if( (NULL != m_pAudOutputPin[i]) && m_pAudOutputPin[i]->IsConnected() )
	        {
                    // only change media types if types actually changed

                    if (m_pAudOutputPin[i]->m_mt != cmType[i])
                    {
                        // if the downstream pin likes the new type, and we can set it on our output pin
                        // than change formats
		        if( S_OK != m_pAudOutputPin[i]->GetConnected()->QueryAccept((AM_MEDIA_TYPE *)&cmType[i]) )
                        {
	    	            m_MuteAud[i]=TRUE;
                        }
		        else if( SUCCEEDED(m_pAudOutputPin[i]->SetMediaType(&(cmType[i]))) )
                        {
		            fAudFormatChanged[i]   = TRUE;
                        }

                    }// endif Mediatype really changed

	        }// endif pin-connected
	    }
        }
        else if(FAILED(hr))
        {
            // otherwise if we couldnt' build a DVAudInfo, then silence this sample
            // because it has a bad format
            bSilenceThisSampleFlag = TRUE;
        }
    }
    else
    {	
	//*****support audio change in AAUX soruce pack even pmt==NULL********
	//***** Using this, the type-1 DV file can have difference audio in one file

	//*X search  first 5/6 DIF sequences's AAUX source pack
	//try audio block 0, 6->skip first 6 BLK, 3->3 byts BLK ID*X*/
	pbTmp=pSrc+483;		    //6*80+3=483
	if(*pbTmp!=0x50)
	{
	    //*try audio block 3, skip first 54 BLK, 3->3 byts BLK ID *
	    pbTmp=pSrc+4323;	    // 54*80+3=4323
	}
	
	//*X search  2nd 5/6 DIF sequences's AAUX source pack
	//try audio block 0, 6->skip first 6 BLK, 3->3 byts BLK ID*X*/
	BYTE *pbTmp1;
	pbTmp1=pSrc+483 + m_sDVAudInfo.wDIFMode*80*150; 
	if(*pbTmp1!=0x50)
	{
	    //*try audio block 3, skip first 54 BLK, 3->3 byts BLK ID *
	    pbTmp1=pSrc+4323+ m_sDVAudInfo.wDIFMode*80*150;
	}

        // if we haven't seen valid AAUX headers in a frame yet, check now
        if(m_bNotSeenFirstValidFrameFlag)
        {
            // if headers are valid, then we have now seen a valid frame
            if( (*pbTmp == 0x50) && (*pbTmp1 == 0x50) )
            {
                m_bNotSeenFirstValidFrameFlag = FALSE;
            }
            else
            {
                // otherwise garbage data again, do not deliver
                return S_FALSE;
            }
        }


        // make sure that headers are valid
        if (*pbTmp == 0x50 && *pbTmp1 == 0x50)
        {

            //***** check if audio keeps same format
                            
            DVINFO dviInputFormat;
            DVAudInfo dvaiTemp;
            HRESULT hr_BuildDVAudInfo;
            BOOL bBuilt = FALSE; // If TRUE dvaiTemp does not need to be rebuilt
            BOOL bCalled = FALSE; // If TRUE, BuildDVAudInfo has been called.
            int nNumAudPin = 0;

            if (m_pAudOutputPin[0]) nNumAudPin++;
            if (m_pAudOutputPin[1]) nNumAudPin++;

            ASSERT(nNumAudPin);         // If there are no pins, we bail out at the start of this function

            // If Pin 1 exists, Pin 0 exists - not really important for the following
            // but we should know if this is not true.
            ASSERT(!m_pAudOutputPin[1] || m_pAudOutputPin[0]);

            DWORD dwCurrentSrc  = m_LastInputFormat.dwDVAAuxSrc;
            DWORD dwCurrentSrc1 = m_LastInputFormat.dwDVAAuxSrc1;
            DWORD dwNewSrc =  ( *(pbTmp+4) <<24)  | (*(pbTmp+3) <<16)  |
                            ( *(pbTmp+2) <<8)   |  *(pbTmp+1);
            DWORD dwNewSrc1 = ( *(pbTmp1+4) <<24)  | (*(pbTmp1+3) <<16) | 
                            ( *(pbTmp1+2) <<8)   | *(pbTmp1+1);

            // Attempt a format change if there
            // are differences in the rest of the source pack

            // jaisri: However, when determining if there are differences:
            // (a) ignore the AF_SIZE field since this field only has the number
            //     of audio samples in the DV frame. This eliminates needless
            //     format changes. While we are at it, we may as well ignore
            //     the LF (audio locked) bit as well.

            dwNewSrc        &= 0xffffff40;
            dwNewSrc1       &= 0xffffff40;
            dwCurrentSrc    &= 0xffffff40;
            dwCurrentSrc1   &= 0xffffff40;

#ifdef DEBUG
            // Used in assertions
            DWORD dwNewSrcOrig = dwNewSrc;
            DWORD dwNewSrcOrig1 = dwNewSrc1;
#endif


            // and (b): (Manbugs 36729) if the AUDIO_MODE field in the DV frame is
            // indistinguishable (0xE) or no information (0xF), we replace it
            // with the corresponding field from m_LastInputFormat. (Note that
            // we ignore this field only when we are inspecting the DV data
            // for format changes. If the media sample flagged a format 
            // change, we just use the one it provides.)  The reason for this
            // is that the DV Mux uses this field to indicate silence in cases
            // that the audio starts after the video or if there are
            // intermediate periods of silence during the video. If we use
            // this field and pass 0xF (no info) in this field to BuildDVAudInfo
            // things can go very wrong:
            // - The call to BuildDVAudInfo below will tell us that the the 
            //   number of audio pins has reduced to 1 or to 0 when it really
            //   has not changed
            // - We save the new src pack info away in m_LastInputFormat.
            //   Subsequent calls to CDVSpOutputPin::GetMediaType supplies
            //   m_LastInputFormat to BuildDVAudInfo to determine the number
            //   of audio pins. This number would have reduced. So if
            //   the graph is stopped and we disconnect the audio pin and
            //   try to reconnect it, the connection fails
            // - Subsequent calls to DescrambleAudio fail. DescrambleAudio
            //   asserts m_sDVAudInfo.bAudQu for the pin we just lost is
            //   neither 32KHz nor 48KHz. (Detail: Actually, if we have 
            //   two pins and the AUDIO_MODE for the first one is 0,
            //   BuildDVAudInfo "redirects" the output that would normally go
            //   to the second pin to the first pin. So m_sDVAudInfo.bAudQu[0]
            //   is initialized by that function, but not m_sDVAudInfo.bAudQu[1].
            //   So DescrambleAudio asserts only for the second pin. However,
            //   the first pin's audio is not played any more, instead the 
            //   first pin carries the second pin's audio.)

            if ((pbTmp[2] & 0xe) == 0xe && 
                (dwCurrentSrc & 0xe00) != 0xe00 // Small opt for mono channel dv - AUD_MODE will be 0xf
               )
            {
                // The lower nibble of the byte is 0xE (indistinguishable) or
                // 0xF (no information). Replace AUDIO_MODE in dwNewSrc with
                // the AUDIO_MODE field in dwCurrentSrc
                
                // And now for some exceptions. Manbugs 40975.
                // Scenario: Panasonic DV400D plays a tape that has 16 bit 32K mono audio.
                // Use a preview graph in graphedt. Stop the tape. (Do not change graph's state.)
                // Restart it. Often, there is no audio after that. Does not repro w/
                // Sony TRV 10. Does not repro w/ Win Millenium Edition qdv and earlier (since 
                // this code wasn't there).
                //
                // Initially, the setting is CH=0, PA=1 and AUDIO_MODE (AM) = 2 (for Aux Src)
                // and 0xF (for aux src 1). After the tape is resumed, the Panasonic first sends a 
                // DV frame with CH=0, PA = 0 and AM = 0, 1. (Aux Src and Aux Src1.) This 
                // corresponds to stereo audio. Then it fixes things in the next frame by
                // sending CH=0, PA=1 and AM = 2, 0xf. Without the workaround, we leave AM as 2, 1
                // which is invalid and the rest of the audio is silenced.
                //
                // This scenario also repros if we play a tape (or a type 1 avi file) that has
                // 3 recorded segments: first has Mono 16 bit (I used 32K0, second has stereo 16 bit
                // (used 48K) and the third has mono 16 bit (used 32K)
                // 
                // All we care about is whether the number of audio tracks has decreased. So, we 
                // call BuidDVAudInfo with the NewSrc's and find the new number of
                // audio tracks. If it hasn't decreased, there is no change, we don't need to copy
                // To eliminate the perf hit, we ensure that we call BuildDVAudInfo at most
                // twice
                

                pawfx[0] = (WAVEFORMATEX *)cmType[0].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
                pawfx[1] = (WAVEFORMATEX *)cmType[1].ReallocFormatBuffer(sizeof(WAVEFORMATEX));

                dviInputFormat =  m_LastInputFormat;
                
                dviInputFormat.dwDVAAuxSrc    = dwNewSrc;
                dviInputFormat.dwDVAAuxSrc1   =	dwNewSrc1;

                //rebuild  DVAudInfo with new audio source pack

                hr_BuildDVAudInfo = BuildDVAudInfo(&dviInputFormat, pawfx, &dvaiTemp);
                bCalled = TRUE;

                if (SUCCEEDED(hr_BuildDVAudInfo) && dvaiTemp.bNumAudPin >= nNumAudPin)
                {
                    // We are not going to reduce the number of pins
                    // Don't copy
                    bBuilt = TRUE;
                }
                else
                {
                    // Copy
                    dwNewSrc = (~DV_AUDIOMODE & dwNewSrc) | 
                                            (dwCurrentSrc & DV_AUDIOMODE);
                }

            }
            if (!bBuilt /* We know # of audio pins does not drop if bBuilt is TRUE */ && 
                (pbTmp1[2] & 0xe) == 0xe  && 
                (dwCurrentSrc1 & 0xe00) != 0xe00 // Small opt for mono channel dv - AUD_MODE will be 0xf
               )
            {
                // The lower nibble of the byte is 0xE (indistinguishable) or
                // 0xF (no information). Replace AUDIO_MODE in dwNewSrc1 with
                // the AUDIO_MODE field in dwCurrentSrc1

                if (!bCalled)
                {
                    pawfx[0] = (WAVEFORMATEX *)cmType[0].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
                    pawfx[1] = (WAVEFORMATEX *)cmType[1].ReallocFormatBuffer(sizeof(WAVEFORMATEX));

                    dviInputFormat =  m_LastInputFormat;
            
                    ASSERT (dwNewSrc = dwNewSrcOrig);
                    ASSERT (dwNewSrc1 = dwNewSrcOrig1);
                            
                    dviInputFormat.dwDVAAuxSrc    = dwNewSrc;
                    dviInputFormat.dwDVAAuxSrc1   = dwNewSrc1;

                    //rebuild  DVAudInfo with new audio source pack

                    hr_BuildDVAudInfo = BuildDVAudInfo(&dviInputFormat, pawfx, &dvaiTemp);
                    bCalled = TRUE;
                }
                else
                {
                    // We know we have to copy since bBuilt = FALSE.
                    // Let's assert it.

                    ASSERT(FAILED(hr_BuildDVAudInfo) || 
                           dvaiTemp.bNumAudPin < nNumAudPin);
                }

                if (SUCCEEDED(hr_BuildDVAudInfo) && dvaiTemp.bNumAudPin >= nNumAudPin)
                {
                    // We are not going to reduce the number of pins
                    // Don't copy
                    bBuilt = TRUE;
                }
                else
                {
                    dwNewSrc1 = (~DV_AUDIOMODE & dwNewSrc1) | 
                                            (dwCurrentSrc1 & DV_AUDIOMODE);
                }
            }

            if (dwCurrentSrc != dwNewSrc || dwCurrentSrc1 != dwNewSrc1) 
            {
                //******the upstream pin tells us audio format is changed.******
                    
                if (bBuilt)
                {
                    // We used dwNewSrcOrig and dwNewSrcOrig1 
                    // to build the first time. Assert that 
                    // a rebuild is unnecessary since they 
                    // have not changed.
                    ASSERT (dwNewSrc = dwNewSrcOrig);
                    ASSERT (dwNewSrc1 = dwNewSrcOrig1);
                }
                else
                {
                    if (!bCalled)
                    {
                        pawfx[0] = (WAVEFORMATEX *)cmType[0].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
                        pawfx[1] = (WAVEFORMATEX *)cmType[1].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
                    }
                    
                    dviInputFormat =  m_LastInputFormat;
            
                    dviInputFormat.dwDVAAuxSrc    = dwNewSrc;
                    dviInputFormat.dwDVAAuxSrc1   = dwNewSrc1;

                    //rebuild  DVAudInfo with new audio source pack

                    hr_BuildDVAudInfo = BuildDVAudInfo(&dviInputFormat, pawfx, &dvaiTemp);
                }

                // only perform a format change downstream if
                // 1) We could build a valid DVAudInfo
                // 2) The new DVAudInfo is different from the current one
                // 2) the new format is different from the current format
                if( (SUCCEEDED(hr_BuildDVAudInfo))
                    && ( memcmp((void*) &m_sDVAudInfo, (void*) &dvaiTemp, sizeof(DVAudInfo)) ) )

                {
                    // now a format change may have occured
                    // create a CMediaType, and see if its different than the currently connected mediatype

                    // copy new DVINFO (because it may change even if output AM_MEDIA_TYPE doesn't change
                    memcpy((void*) &m_sDVAudInfo, (void*) &dvaiTemp, sizeof(DVAudInfo));
                    memcpy((unsigned char *)&m_LastInputFormat,(unsigned char *)&dviInputFormat,sizeof(DVINFO) );
                    //*X* 3/2/99, we do not support audio change from one language to two on fly
                    if( (dvaiTemp.bNumAudPin ==2) && 
                            (m_pAudOutputPin[1] ==NULL) )
                    {
                        //audio change from one lanquage to two
                        //we can only care one now
                        dvaiTemp.bNumAudPin=1;
                    }

                    for(int i=0; i<dvaiTemp.bNumAudPin; i++) 
                    {
                        //Create mediatype for audio
                        cmType[i].majortype=MEDIATYPE_Audio; //streamtypeAUDIO
                        cmType[i].subtype=MEDIASUBTYPE_PCM; 
                        cmType[i].bFixedSizeSamples=1;	//X* 1 for lSampleSize is not 0 and fixed
                        cmType[i].bTemporalCompression=0; 
                        cmType[i].formattype=FORMAT_WaveFormatEx;
                        cmType[i].cbFormat=sizeof(WAVEFORMATEX); /*X* for audio render connection *X*/
                        cmType[i].lSampleSize   =(dvaiTemp.wAvgSamplesPerPinPerFrm[i] + 50) << pawfx[i]->nChannels; //max sample for all case is < m_sDVAudInfo.wAvgSamplesPerPinPerFrm[i] + 50
                        //copy audio format
                        cmType[i].SetFormat ((BYTE *)pawfx[i], sizeof(WAVEFORMATEX));	            

                        if(  (NULL != m_pAudOutputPin[i]) && m_pAudOutputPin[i]->IsConnected() )
                        {
                            // only change media types if types actually changed

                            if (m_pAudOutputPin[i]->m_mt != cmType[i])
                            {
                                // if the downstream pin likes the new type, and we can set it on our output pin
                                // than change formats
                                if( S_OK != m_pAudOutputPin[i]->GetConnected()->QueryAccept((AM_MEDIA_TYPE *)&cmType[i]) )
                                {
                                    m_MuteAud[i]=TRUE;
                                }
                                else if( SUCCEEDED(m_pAudOutputPin[i]->SetMediaType(&(cmType[i]))) )
                                {                               
                                    fAudFormatChanged[i]   = TRUE;
                                }

                            }// endif Mediatype really changed

                        }// endif pin connected
                    }
                }
                else if(FAILED(hr_BuildDVAudInfo))
                {
                    // otherwise if we couldnt' build a DVAudInfo, then silence this sample
                    // because it has a bad format
                    bSilenceThisSampleFlag = TRUE;
                }
            }
        }
     }
    //X*******get exactly wAvgBytesPerSec for this frame's audio
    //X* search for audio source AAUX source data from  A0 or A2
	
    //deshuffle  audio for  1 or 2 connected pin(s)
    while(bConnectedAudPin )
    {
    if( m_MuteAud[bAudPinInd]!=TRUE )
    {
	//get right output pin
	CDVSpOutputPin *pAudOutputPin;
	pAudOutputPin = m_pAudOutputPin[bAudPinInd];
	
	//this pin's audio in one or both 5/6 DIF sequences
	if( ( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xc0 ) ==0x80 )
	{
	    //one pin's audio in both 5/6 DIF sequences
	    bAudInDIF=2;
	    iPos=0;
	}
	else
	{
	    bAudInDIF=1;

	    //one pin's audio only in one 5/6 DIF sequences 
	    //find which one
	    if( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x3f )
	    {
		//in 2nd 5/6 DIF sequence
		iPos=m_sDVAudInfo.wDIFMode*80*150;
	    }
	    else //in 1st 5/6 DIF sequences
		iPos=0;
	}
	
	//ouput auduio sample buffer pointer
	IMediaSample    *pOutSample=NULL;
	
        CRefTime        tStart;
	CRefTime        tStop;			   //CRefTime in millisecond

	//GET TIME STAMP FROM VIDEO FRAME
	pSample->GetTime((REFERENCE_TIME*)&tStart, (REFERENCE_TIME*)&tStop);

	//X********cacl sample size
	WORD wTmp=0;
        BYTE *pbTempVaux = NULL;
	do{
	    //*X search 1st 5/6 DIF sequences's AAUX source pack
	    //try audio block 0, 6->skip first 6 BLK, 3->3 byts BLK ID*X*/
	    bTmp=*(pSrc+6*80+3+iPos);
	    if(bTmp!=0x50)
	    {
		//*try audio block 3, skip first 54 BLK, 3->3 byts BLK ID *
		bTmp=*(pSrc+54*80+3+iPos);
		pbTmp=pSrc+54*80+3+iPos;
//		ASSERT( *pbTmp==0x50);

                // refer to bluebook spec Part2 pp.99-100, 109-110, 286
                // access VA2, 3 for id, and 39'th pack, Source Control (40)
                pbTempVaux = pSrc + 5*80 + 3 + 9*5 + iPos + 5;
	    }
	    else
	    {
	        pbTmp=pSrc+6*80+3+iPos;

                // refer to bluebook spec Part2 pp.99-100, 109-110, 286
                // access VA0, 3 for id, and 0'th pack, Source Control (1st)
                pbTempVaux = pSrc + 3*80 + 3 + iPos + 5;
	    }

            DbgLog((LOG_TRACE,2,TEXT("Header: %x, Source PC2: %x, Header: %x, Source Control PC3: %x"), *pbTmp, *(pbTmp + 2), *pbTempVaux, *(pbTempVaux + 3)));

	    //check if audio is muted in this frame
            // if audio is muted then we will first insert handle any discontinuities
            // and then send out the correct amount of silence for this sample
            // based on start, stop times, and avg. bytes per second.
            // MUTE Detection:
            // 1) If We have already detected bad data and want to insert silence for this sample
            // 2) If we detect Bad AAUX pack right now
            // 3) If the camera is paused then we mute the audio for this frame.
            //    - the VAUX Source Control pack valid
            //    - and if FF and FS of VAUX Source Control are both 0, then it is a mute condition
            // 4) If the Audio frame contains no information then we mute audio for this frame
            //    - if the AUDIO MODE in the AAUX source is all 1's i.e. AUDIO MODE == 0x0F
            if( (bSilenceThisSampleFlag)
                || ( (*pbTmp) != 0x50)
                || ( ( (*pbTempVaux) == 0x61) && ( ((*(pbTempVaux + 3)) & 0xC0) == 0x00) )
                || ( ((*(pbTmp + 2)) & 0x0F) == 0x0F) )
	    {
                // WARNING: Is this necessary?
                // @@@ jaisri: Don't think so.
		m_Mute1stAud[bAudPinInd]=TRUE;

                // deliver a silence sample downstream
		if ( pAudOutputPin->IsConnected() )
		{
		    hr = pAudOutputPin->GetDeliveryBuffer(&pOutSample,NULL,NULL,0);
    
		    if ( FAILED(hr) ) 
	    		goto RETURN;
	    
		    ASSERT(pOutSample);

                    if(m_bFirstValidSampleSinceStartedStreaming == TRUE)
                    {
                        // otherwise if we are the first valid sample, then
                        // pretend a dynamic format change is happening because we may
                        // have been stopped in the middle of a format changed last time we
                        // started streaming.

                        m_bFirstValidSampleSinceStartedStreaming = FALSE;
                        pOutSample->SetMediaType(&m_pAudOutputPin[bAudPinInd]->m_mt);
                    }
                    else if (fAudFormatChanged[bAudPinInd] == TRUE) 
                    {
                        //if audio format changed		
	                //set audio mediatype 
	                pOutSample->SetMediaType(&cmType[bAudPinInd]);
      
                    }

                    // set discontinuity
                    if(pSample->IsDiscontinuity() == S_OK)
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("Sample is a discontinuity")));

                        // handle the discontinuity, by inserting silence
                        pOutSample->SetDiscontinuity(TRUE);
                                           
                    }

                    // for this sample output silence becuase its muted
                    // calculate bytes of silence = (time difference in 100ns) * (avg. bytes / 100ns)
                    // and block align
                    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)pAudOutputPin->m_mt.pbFormat;
                    LONG         cbSilence = (LONG) ((tStop - tStart) * (((double)pwfx->nAvgBytesPerSec) / UNITS));
                    cbSilence -= (cbSilence % pwfx->nBlockAlign);

                    DbgLog((LOG_TRACE, 1, TEXT("This sample silence count: %d"), cbSilence));

                    // output
                    hr = InsertSilence(pOutSample, tStart, tStop, cbSilence, pAudOutputPin);
                    if(FAILED(hr))
                    {
                        goto RETURN;
                    }

                    DbgLog((LOG_TRACE,
                            1,
                            TEXT("Previous Sample Stop: %d, This Sample {%d , %d}"),
                            (int)m_tStopPrev.GetUnits(),
                            (int)tStart.GetUnits(),
                            (int)tStop.GetUnits()));

                    // update previous stop
		    m_tStopPrev = tStop;

		    m_AudioStarted=1;
		}// endif send silence

		goto MUTED_PIN;
	    }// endif mute detection
	  
	    bAudInDIF--;
	    if( !wTmp )
		wTmp = ( ( m_sDVAudInfo.wAvgSamplesPerPinPerFrm[bAudPinInd]  + ( *(pbTmp+1) & 0x3f)  )  ) ;  
//	    else if( wTmp && !bAudInDIF )	//for audio in both 5/6 DIF, check to make sure sample number is same
//	        ASSERT( wTmp ==  ( m_sDVAudInfo.wAvgSamplesPerPinPerFrm[bAudPinInd]  + ( *(pbTmp+1) & 0x3f)  ) );

	    if(bAudInDIF==1)
	    {
		    //one pin's audio in both 5/6 DIF block
		ASSERT(iPos==0);
		iPos=m_sDVAudInfo.wDIFMode*80*150; //for search second 5/6's AAUX source pack
	    }
			
	}while(bAudInDIF);

	//BYTES/FRAME
	if( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xc0 )
	    lBytesPerFrm = wTmp <<2;		//mon. shift 1->16 bits/8, stereo shift 2->2ch +16 bits/8
	else
	    lBytesPerFrm = wTmp <<1;
			
	//X********de-shuffle audio
	//X* since we deliver audio every DV frame,
	// we need to get another output buffer to hold descramble audio
	hr = pAudOutputPin->GetDeliveryBuffer(&pOutSample,NULL,NULL,0);
	
	if ( FAILED(hr) ) 
	    goto RETURN;
	    
	ASSERT(pOutSample);

	hr = pOutSample->GetPointer(&pDst);
	if ( FAILED(hr) ) 
	    goto RETURN;
	ASSERT(pDst);

        m_pAudOutSample[bAudPinInd]=pOutSample;

	hr=DescrambleAudio(pDst, pSrc , bAudPinInd, wTmp);

	if ( !FAILED(hr) ) 
	//if(m_AudLenLeftInBuffer[bAudPinInd] < (DWORD)lBytesPerFrm )
	{
	    //X* the buffer is almost full, delive it
	    if ( pAudOutputPin->IsConnected() )
	    {
		// pass call to it.
		long lActual = lBytesPerFrm;
		pOutSample->SetActualDataLength(lActual);
	
   		//put time stamp into audio buffer
		pOutSample->SetTime((REFERENCE_TIME*)&tStart,
			(REFERENCE_TIME*)&tStop);
		
                if(m_bFirstValidSampleSinceStartedStreaming == TRUE)
                {
                    // otherwise if we are the first valid sample, then
                    // pretend a dynamic format change is happening because we may
                    // have been stopped in the middle of a format changed last time we
                    // started streaming.

                    m_bFirstValidSampleSinceStartedStreaming = FALSE;
                    pOutSample->SetMediaType(&m_pAudOutputPin[bAudPinInd]->m_mt);
                }
		else if (fAudFormatChanged[bAudPinInd]==TRUE) 
		{
                    //if audio format changed		
		    //set audio mediatype 
		    pOutSample->SetMediaType(&cmType[bAudPinInd]);
		  
		}

                if(pSample->IsDiscontinuity() == S_OK)
                {
                    DbgLog((LOG_TRACE, 1, TEXT("Sample is a discontinuity")));

                    pOutSample->SetDiscontinuity(true);

                    // insert silence for the discontinuity

                }

		hr=pAudOutputPin->m_pOutputQueue->Receive(pOutSample);

                DbgLog((LOG_TRACE,
                        1,
                        TEXT("Previous Sample Stop: %d, This Sample {%d , %d}"),
                        (int)m_tStopPrev.GetUnits(),
                        (int)tStart.GetUnits(),
                        (int)tStop.GetUnits()));

                // update stop time
                m_tStopPrev = tStop;
		
		//GetState(0, &State);
		//DbgLog((LOG_TRACE, 2, TEXT("Deliver_aUD s1=%d\n"), State));

		m_AudioStarted=1;

		//
		// m_pOutputQueue will release the pOutSample
		//
		m_pAudOutSample[bAudPinInd]=NULL;

		if (hr != NOERROR)
		    goto RETURN;
	    }

	    //
	    // m_pOutputQueue will release the pOutSample
	    //
	    m_pAudOutSample[bAudPinInd]=NULL;
	} //end if(!FAIL())
    }// end if (m_MuteAud[bAudPinInd]!=TRUE )	

MUTED_PIN:
    bConnectedAudPin--;
    bAudPinInd++;
	
    }//end while(bConnectedAudPin) 

RETURN:
    if(pmt!=NULL) 
	DeleteMediaType(pmt);
    
    return hr;
}


// Please refer to these BlueBook pages when reading these functions
// BlueBook Part2
// pp. 16-21 (Audio Signal Processing)
// pp. 68-75 (shuffling patterns for audio)
// pp. 109 - 117 (Basic DV Frame Data Structures)
// pp. 262 - 268 (AAUX Source and Source Control Packet spec.)
//X* 
//X* 77 bytes Audio in A-DIF block:
//X* Audio Aux(5 byte) + audio data(72 bytes) on tape
//X* 9 audio block/DIF
//X* 10 or 12 DIF /frame
//X* 2 bytes for evry audio sample at 48k, 44.1k or 32k_1ch
//X*	48k requires  48000*2/30= 3200 bytes/frame 
//X*	48k requires  48000*2/25= 3840 bytes/frame
//X* MAX(10): 72*9*5=3240 bytes/frame	==	1620 samples/frame
//X* MAX(12): 72*9*6=3888 bytes/frame	==	1944 samples/frame
//X* see table 18 and 19 in part2 sepc for audio sampels/frame
//X*
//X* Agri:
//X*			iDIFBlkNum=(n/3)+2
//*X*
/*X*
typedef struct Tag_DVAudInfo
{
	BYTE	bAudStyle[2];		
	//LSB 6 bits for starting DIF sequence number
	//MSB 2 bits: 0 for mon. 1: stereo in one 5/6 DIF sequences, 2: stereo audio in both 5/6 DIF sequences
	//example: 0x00: mon, audio in first 5/6 DIF sequence
	//		   0x05: mon, audio in 2nd 5 DIF sequence
	//		   0x15: stereo, audio only in 2nd 5 DIF sequence
	//		   0x10: stereo, audio only in 1st 5/6 DIF sequence
	//		   0x20: stereo, left ch in 1st 5/6 DIF sequence, right ch in 2nd 5/6 DIF sequence
	//		   0x26: stereo, rightch in 1st 6 DIF sequence, left ch in 2nd 6 DIF sequence
	BYTE	bAudQu[2];			//qbits, only support 12, 16, 		
		
	BYTE	bNumAudPin;			//how many pin(language)
	WORD	wAvgBytesPerSec[2];	//
	WORD	wBlkMode;			//45 for NTSC, 54 for PAL
	WORD	wDIFMode;			//5  for NTSC, 6 for PAL
	WORD	wBlkDiv;			//15  for NTSC, 18 for PAL
} DVAudInfo;
*X*/

HRESULT CDVSp::DescrambleAudio(BYTE *pDst, BYTE *pSrc, BYTE bAudPinInd, WORD wSampleSize)
{
    BYTE *pTDst; //temp point
    BYTE *pTSrc; //temp point
    INT iDIFPos;
    INT iBlkPos;
    INT iBytePos;
    short sI;
    INT n;
    INT iShift;
    INT iPos;

    pTDst=pDst;
    if( m_sDVAudInfo.bAudQu[bAudPinInd] ==16 )
    {
	//X* 16 bits /sample
	if( !(m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xC0))
	{

	    //16 bits MOn. audio only in one of 5/6 DIF sequencec
	    iPos=(m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x3f)*150*80;

	    //for n=0, we need to treat it seperately 
	    //iDIFPos=0;	
	    //iBlkPos=0; 
	    //iBytePos=8;
	    BOOL bCorrupted1stLeftAudio=FALSE;
	    pTSrc=pSrc+480+8+iPos;
            // @@@ jaisri: Compare with 0x8000 on bigendian platforms
	    if(*((short *)pTSrc) ==0x0080 )
	    { 
		bCorrupted1stLeftAudio=TRUE;
    		pTDst+= 2;
	    }
	    else
	    {
	        *pTDst++=pTSrc[1];	//lease significant byte
	        *pTDst++=*pTSrc;	//most significant byte
	    }

	    for( n=1; n<wSampleSize; n++)
	    {

		iDIFPos=( (n/3)+2*(n%3) )%m_sDVAudInfo.wDIFMode;	//0-4 for NTSC, 0-5 for PAL
		iBlkPos= 3*(n%3)+(n%m_sDVAudInfo.wBlkMode)/m_sDVAudInfo.wBlkDiv; //0-9 
		iBytePos=8+2*(n/m_sDVAudInfo.wBlkMode);					//

		pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		//	iDIFPos*150*80=12000*iDIFPos	-> skip iDIFPos number DIF sequence
		//	6*80=480			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		//	16*iBlkPos*80=1280*iBlkPos	-> skip 16 blk for evrey iBLkPos audio
		//	iPos:				=0 if this audio in 1st 5/6 DIF sequences, =5(or 6)*150*80 for 2nd DIF seq
		if(*((short *)pTSrc) ==0x0080 )
		{ 
		    //corrupted audio, copy previous audio
		    *((short*)pTDst)=*((short*)(pTDst-2));
		    pTDst+= 2;
		}
		else
		{
		    *pTDst++=pTSrc[1];	//lease significant byte
		    *pTDst++=*pTSrc;	//most significant byte
		}
	    }
	    
	    //update n=0 sample if needed
	    if( bCorrupted1stLeftAudio==TRUE)
		*((short *)pDst)=*((short *)(pDst+2));

	 }//end if (bAudInDIF
	 else
	 {

	    //16 bits stereo audio in all 10 or 12 DIF sequences
	    ASSERT( (m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xC0) ==0x80 );


	    //looking for left Channel 
	    iPos = m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x3f;
	    INT iRPos;
	    if( !iPos )
	    {
		//left in 1st 5/6 DIF
		iRPos=m_sDVAudInfo.wDIFMode*150*80;
	    }
	    else{
		  iPos=iPos*150*80;
		  iRPos=0;
	    }

	    //for n=0, we need to treat it seperately 
	    //iDIFPos=0;	
	    //iBlkPos=0; 
	    //iBytePos=8;
	    BOOL bCorrupted1stLeftAudio=FALSE;
	    BOOL bCorrupted1stRightAudio=FALSE;

	    //n=0 sample's left
	    pTSrc=pSrc+480+8+iPos;
	    if(*((short *)pTSrc) ==0x0080 )
	    { 
		bCorrupted1stLeftAudio=TRUE;
    		pTDst+= 2;
	    }
	    else
	    {
	        *pTDst++=pTSrc[1];	//lease significant byte
	        *pTDst++=*pTSrc;	//most significant byte
	    }

	    //n=0 sample's right
	    pTSrc=pSrc+480+8+iRPos;
	    if(*((short *)pTSrc) ==0x0080 )
	    { 
	    	bCorrupted1stRightAudio=TRUE;
    		pTDst+= 2;
	    }
	    else
	    {
	        *pTDst++=pTSrc[1];	//lease significant byte
	        *pTDst++=*pTSrc;	//most significant byte
	    }


	    for( n=1; n<wSampleSize; n++)
	    {
	    	iDIFPos=( (n/3)+2*(n%3) )%m_sDVAudInfo.wDIFMode;	//0-4 for NTSC, 0-5 for PAL
		iBlkPos= 3*(n%3)+(n%m_sDVAudInfo.wBlkMode)/m_sDVAudInfo.wBlkDiv; //0-9 
		iBytePos=8+2*(n/m_sDVAudInfo.wBlkMode);					//

		//Left first
		pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		//	iDIFPos*150*80=12000*iDIFPos		-> skip iDIFPos number DIF sequence
		//	6*80=480					-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		//	16*iBlkPos*80=1280*iBlkPos	-> skip 16 blk for evrey iBLkPos audio
		//  iPos: =0 if this audio in 1st 5/6 DIF sequences, =5(or 6)*150*80 for 2nd DIF seq
		if(*((short *)pTSrc) ==0x0080 )
		{ 
		    //bad audio, copy pre-frame's audio
		    *((short*)pTDst)=*( (short *)(pTDst-4));
		    pTDst+=2;
	    	}
		else
		{
		    *pTDst++=pTSrc[1];	//lease significant byte
		    *pTDst++=*pTSrc;	//most significant byte
		}

		//Right second
		pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iRPos;
		if(*((short *)pTSrc) ==0x0080 )
		{ 
		    //bad audio, copy pre-frame's audio
		    *((short*)pTDst)=*( (short *)(pTDst-4));
		    pTDst+=2;
		}
		else
		{
		    *pTDst++=pTSrc[1];	//lease significant byte
		    *pTDst++=*pTSrc;	//most significant byte
		}
	    }

	    //fix n=0 sample if needed
	    if( bCorrupted1stLeftAudio==TRUE)
		*((short *)pDst)=*((short *)(pDst+4));
	    if( bCorrupted1stRightAudio==TRUE )
		*((short *)(pDst+2))=*((short *)(pDst+6));

	}
	  
    }
    else if( m_sDVAudInfo.bAudQu[bAudPinInd] ==12 )
    {		

        //X* 12 bits per sample
        iPos=(m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x3f)*150*80;

        if( ( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xc0) == 0x40)
        {
            //for n=0, we need to treat it seperately 
            //iDIFPos=0;	
            //iBlkPos=0; 
            //iBytePos=8;
            BOOL bCorrupted1stLeftAudio=FALSE;
            BOOL bCorrupted1stRightAudio=FALSE;

            //n=0 sample's left
            pTSrc=pSrc+480+8+iPos;
            //X* convert 12bits to 16 bits
            sI= ( pTSrc[0] << 4 ) | ( ( pTSrc[2] &0xf0) >>4 );  //X* 1st 12 bits
            if(sI==0x800)
            {
                //bad audio, copy last audio
                bCorrupted1stLeftAudio=TRUE;
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if(iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }

            //n=0 sample's right
            sI= ( pTSrc[1] << 4 ) | ( pTSrc[2] &0x0f) ;			//X* 2nd 12 bits
            if(sI==0x800)
            {
                //bad audio
                bCorrupted1stRightAudio=TRUE;
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if( iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }

            //stereo audio
            for( n=1; n<wSampleSize; n++)
            {

            iDIFPos=( (n/3)+2*(n%3) )%m_sDVAudInfo.wDIFMode;	//0-4 for NTSC, 0-5 for PAl
            iBlkPos= 3*(n%3)+(n%m_sDVAudInfo.wBlkMode)/m_sDVAudInfo.wBlkDiv;	//0-9 
            iBytePos=8+3*(n/m_sDVAudInfo.wBlkMode);
            pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
            //pTSrc=pSrc+ iDIFPos*150*80 + 6*80 + 16*iBlkPos*80 + iBytePos;
            //	iDIFPos*150*80	-> skip iDIFPos number DIF sequence
            //	6*80			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
            //	16*iBlkPos*80	-> skip 16 blk for evrey iBLkPos audio
            //  iPos: 0 if this audio in 1st 5/6 DIF sequences, 5(or 6)*150*80 for 2nd DIF seq


            //X* convert 12bits to 16 bits
            sI= ( pTSrc[0] << 4 ) | ( ( pTSrc[2] &0xf0) >>4 );  //X* 1st 12 bits
        
            if(sI==0x800)
            {
                //bad audio, copy pre-frame's audio
                *((short*)pTDst)=*( (short *)(pTDst-4));
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if(iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }
            sI= ( pTSrc[1] << 4 ) | ( pTSrc[2] &0x0f) ;			//X* 2nd 12 bits

            if(sI==0x800)
            {
                //bad audio, copy pre-frame's audio
                *((short*)pTDst)=*( (short *)(pTDst-4));
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if( iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }

        } //for( n=0; n<Info->SamplesIn1ChPerFrame; n++)
                    //fix n=0 sample if needed
        if( bCorrupted1stLeftAudio==TRUE)
            *((short *)pDst)=*((short *)(pDst+4));
        if( bCorrupted1stRightAudio==TRUE)
            *((short *)(pDst+2))=*((short *)(pDst+6));

    } //end if( ( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x80) == 0x40)
    else
    {
        ASSERT( !( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x80) );
        //mon. 12 bits

        // Manbugs 40935

        //for n=0, we need to treat it seperately 
        //iDIFPos=0;	
        //iBlkPos=0; 
        //iBytePos=8;
        BOOL bCorrupted1stLeftAudio=FALSE;

        //n=0 sample's left
        pTSrc=pSrc+480+8+iPos;
        //X* convert 12bits to 16 bits
        sI= ( pTSrc[0] << 4 ) | ( ( pTSrc[2] &0xf0) >>4 );  //X* 1st 12 bits
        if(sI==0x800)
        {
            //bad audio, copy last audio
            bCorrupted1stLeftAudio=TRUE;
            pTDst+=2;
        }
        else
        {
            iShift=(sI>>8);	
            if( iShift<8 ){ //X* positive
                if(iShift>1){
                    iShift--;
                    sI=(-256*iShift+sI)<<iShift;
                }
            }else{			//X* negtive
                //X* make it 16 bits based negative
                sI= 0xf000 | sI; 
                if(iShift<14 ){
                    iShift=14-iShift;
                    sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                }
            }
    
            *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
            *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
        }

        //mono audio
        for( n=1; n<wSampleSize; n++)
        {

            iDIFPos=( (n/3)+2*(n%3) )%m_sDVAudInfo.wDIFMode;	//0-4 for NTSC, 0-5 for PAl
            iBlkPos= 3*(n%3)+(n%m_sDVAudInfo.wBlkMode)/m_sDVAudInfo.wBlkDiv;	//0-9 
            iBytePos=8+3*(n/m_sDVAudInfo.wBlkMode);
            pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
            //pTSrc=pSrc+ iDIFPos*150*80 + 6*80 + 16*iBlkPos*80 + iBytePos;
            //	iDIFPos*150*80	-> skip iDIFPos number DIF sequence
            //	6*80			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
            //	16*iBlkPos*80	-> skip 16 blk for evrey iBLkPos audio
            //  iPos: 0 if this audio in 1st 5/6 DIF sequences, 5(or 6)*150*80 for 2nd DIF seq


            //X* convert 12bits to 16 bits
            sI= ( pTSrc[0] << 4 ) | ( ( pTSrc[2] &0xf0) >>4 );  //X* 1st 12 bits
        
            if(sI==0x800)
            {
                //bad audio, copy pre-frame's audio
                *((short*)pTDst)=*( (short *)(pTDst-4));
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if(iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }

        } //for( n=0; n<Info->SamplesIn1ChPerFrame; n++)

        //fix n=0 sample if needed
        // @@@ jaisri What if that is also corrupted. What's the 
        // point of this anyway? What about corrupted samples
        // detected in the for loop?
        if( bCorrupted1stLeftAudio==TRUE)
            *((short *)pDst)=*((short *)(pDst+2));

        }
    } //end if( m_sDVAudInfo.bAudQu[bAudPinInd] ==12 )
    else{
	//only support 12 bits or 16 bits/samples
	ASSERT(m_sDVAudInfo.bAudQu[bAudPinInd] ==12 ||
	       m_sDVAudInfo.bAudQu[bAudPinInd] ==16);
	return E_UNEXPECTED;
    }

    return NOERROR;
}


//----------------------------------------------------------------------------
    // HRESULT CDVSp::DeliveVideo(IMediaSample *pSample) 
//----------------------------------------------------------------------------
HRESULT CDVSp::DeliveVideo(IMediaSample *pSample) 
{    
    
    HRESULT hr = NOERROR;

     // pass call to it.
    if (  m_AudioStarted && m_pVidOutputPin ->IsConnected() )
    {
	//What is going to happen if the upstream filter does not set sample time stamp right?
	//get time 
	//REFERENCE_TIME trStart, trStopAt;
	//pSample->GetTime(&trStart, &trStopAt);	

        BOOL bDeliverFrame = m_bDeliverNextFrame;

        if (!bDeliverFrame && pSample->IsDiscontinuity() == S_OK)
        {
            bDeliverFrame = TRUE;
        }
        
        if (bDeliverFrame)
        {
            pSample->AddRef();	    //m_pOutputQueu will do release
            hr = m_pVidOutputPin->m_pOutputQueue->Receive(pSample);
        }
        if (m_b15FramesPerSec)
        {
            m_bDeliverNextFrame = !bDeliverFrame;
        }
    }
    
    return hr;
}

//----------------------------------------------------------------------------
// InsertSilence
//
// notes:
//      assumption is that DV has 16 bits per sample, and silence == 0x0000
//      however "lActualDataLen" is already the correct number of bytes
//----------------------------------------------------------------------------
HRESULT
CDVSp::InsertSilence(IMediaSample *pOutSample,
                     REFERENCE_TIME rtStart,
                     REFERENCE_TIME rtStop,
                     long lActualDataLen,
                     CDVSpOutputPin *pAudOutPin)
{
    // error check
    if( (!pOutSample) || (!pAudOutPin) )
    {
        return E_INVALIDARG;
    }


    HRESULT         hr = NOERROR;
    BYTE            *pBuf = NULL;

    // checking type
    if(pAudOutPin->m_mt.formattype != FORMAT_WaveFormatEx)
    {
        DbgLog((LOG_TRACE,2,TEXT("Format Type not WaveFormatEx")));
        ASSERT(pAudOutPin->m_mt.formattype == FORMAT_WaveFormatEx);
        return E_FAIL;
    }

    // check audio sample size
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)pAudOutPin->m_mt.pbFormat;
    if(pwfx->wBitsPerSample != 16)
    {
        DbgLog((LOG_TRACE,2,TEXT("Bits per sample is not 16, it is: %d"), (int)pwfx->wBitsPerSample));
        ASSERT(pwfx->wBitsPerSample == 16);
        return E_FAIL;
    }

    // error check
    if( ((long)pOutSample->GetSize()) < lActualDataLen )
    {
        DbgLog((LOG_TRACE,2,TEXT("Sample Buffer not big enough, need: %d bytes"), lActualDataLen));
        ASSERT( ((long)pOutSample->GetSize()) >= lActualDataLen );
        return E_FAIL;
    }

    // get "write" pointer
    if(FAILED(hr = pOutSample->GetPointer(&pBuf)))
    {
        DbgLog((LOG_TRACE,2,TEXT("GetDeliveryBuffer Error: %x"), hr));
        ASSERT(SUCCEEDED(hr));
        return hr;
    }

    // silence
    ZeroMemory((LPVOID)pBuf, lActualDataLen);

    // set times
    if(FAILED(hr = pOutSample->SetTime(&rtStart, &rtStop)))
    {
        DbgLog((LOG_TRACE,2,TEXT("SetTime Error: %x"), hr));
        ASSERT(SUCCEEDED(hr));
        return hr;
    }

    // set actual length
    if(FAILED(hr = pOutSample->SetActualDataLength(lActualDataLen)))
    {
        DbgLog((LOG_TRACE,2,TEXT("SetActualDataLength Error: %x"), hr));
        ASSERT(SUCCEEDED(hr));
        return hr;
    }

    // send
    if(FAILED(hr = pAudOutPin->m_pOutputQueue->Receive(pOutSample)))
    {
        DbgLog((LOG_TRACE,2,TEXT("Receive, Error: %x"), hr));

        return hr;
    }

    // SUCCEEDED(hr)
    return hr;
}



/*  Send EndOfStream */
void CDVSp::EndOfStream()      
{
    
    // walk through the output pins list, sending EndofStream message to downstream filters.
  
    //X* have to clean audio here because after audiorender get EndofStream()
    //X* message, we can not deliver any audio to it.
    //DeliveLastAudio(); 
    
    CDVSpOutputPin *pOutputPin;
    for(int i=DVSP_VIDOUTPIN; i<=DVSP_AUDOUTPIN2; i++)
    {
	pOutputPin=(CDVSpOutputPin *)GetPin(i);
	// There will be no output q if we're stopped
	if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() &&
			pOutputPin->m_pOutputQueue)
	{
	    pOutputPin->m_pOutputQueue->EOS();
	}
    }

}
   
/*  Send BeginFlush() */
HRESULT CDVSp::BeginFlush()
{
    CAutoLock lck(m_pLock);
    
    ASSERT (m_NumOutputPins) ;

    HRESULT hr = NOERROR ;

    // FLUSH, don't deliver undelivered data.  If we do, we DIE. (unsynchronized
    // race condition with receive delivering the same data)
    // DeliveLastAudio();
    
    CDVSpOutputPin *pOutputPin;
    for(int i=DVSP_VIDOUTPIN; i<=DVSP_AUDOUTPIN2; i++)
    {
	pOutputPin=(CDVSpOutputPin *)GetPin(i);
	if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
	{
	    pOutputPin->m_pOutputQueue->BeginFlush();
	}
    }

    m_tStopPrev =0;

    return S_OK;
}

/*  Send EndFlush() */
HRESULT CDVSp::EndFlush()
{
    CDVSpOutputPin *pOutputPin;

    for(int i=DVSP_VIDOUTPIN; i<=DVSP_AUDOUTPIN2; i++)
    {
	pOutputPin=(CDVSpOutputPin *)GetPin(i);
	if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
	{
           pOutputPin->m_pOutputQueue->EndFlush();
	}
    }

 
    for(i=0; i<2; i++)
    {
	m_Mute1stAud[i]		=FALSE;
    }
    
    m_bDeliverNextFrame = TRUE;

    // Reset the Dropped Frame flag
    m_Input.m_bDroppedLastFrame = FALSE;


    return S_OK;

}

//----------------------------------------------------------------------------
// CDVSpInputPin constructor
//----------------------------------------------------------------------------

CDVSpInputPin::CDVSpInputPin (TCHAR *pName, CDVSp *pDVSp, HRESULT *phr,
                           LPCWSTR pPinName)
 :  CBaseInputPin (pName, pDVSp, pDVSp, phr, pPinName),
    m_pDVSp (pDVSp),
    m_bDroppedLastFrame(FALSE)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin constructor")));
	ASSERT (m_pFilter == pDVSp) ;
    ASSERT (pDVSp) ;
}

//----------------------------------------------------------------------------
// CDVSpInputPin destructor
//----------------------------------------------------------------------------

CDVSpInputPin::~CDVSpInputPin ()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin destructor")));
    ASSERT (m_pDVSp->m_pAllocator == NULL) ;
}


STDMETHODIMP CDVSpInputPin::NewSegment(REFERENCE_TIME tStart,
				    REFERENCE_TIME tStop, double dRate)
{ 
    
    CAutoLock lck(&m_pDVSp->m_csReceive);

    DbgLog((LOG_TRACE,4,TEXT("NewSegment called %ld %ld"),long(tStart/10000),long(tStop/10000) ));

    if (m_pDVSp->m_pVidOutputPin)
	m_pDVSp->m_pVidOutputPin->DeliverNewSegment(tStart, tStop, dRate);
    for (int z = 1; z < m_pDVSp->m_NumOutputPins; z++) {
	if (m_pDVSp->m_pAudOutputPin[z-1])
	    m_pDVSp->m_pAudOutputPin[z-1]->DeliverNewSegment(tStart, tStop,
									dRate);
    }
    return CBasePin::NewSegment(tStart, tStop, dRate);
}


//----------------------------------------------------------------------------
// CDVSpInputPin GetAllocator
//----------------------------------------------------------------------------

STDMETHODIMP
CDVSpInputPin::GetAllocator(
    IMemAllocator **ppAllocator)
{
    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);

    if(m_pAllocator == NULL)
    {
	*ppAllocator =NULL; 
	return E_FAIL;
    }
    else
    {
        m_pAllocator->AddRef();
	*ppAllocator =m_pAllocator; 
	return NOERROR;
    }

}


//----------------------------------------------------------------------------
// DisplayMediaType -- DEBUG ONLY HELPER FUNCTION
//----------------------------------------------------------------------------
void DisplayMediaType(TCHAR *pDescription,const CMediaType *pmt)
{
#ifdef DEBUG

    // Dump the GUID types and a short description

    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%s"),pDescription));
    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("Media Type Description")));
    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype description %s"),GetSubtypeName(pmt->Subtype())));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->cbFormat));

    // Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));

#endif
}

//----------------------------------------------------------------------------
// CDVSpInputPin::CheckMediaType
//----------------------------------------------------------------------------
/*X* pmt is the upstream filter output Pin's mediatype, mt is CDVSpInputPin's media type *X*/
HRESULT CDVSpInputPin::CheckMediaType (const CMediaType *pmt)
{

    DVINFO *InputFormat=(DVINFO *)pmt->Format();
    if(InputFormat==NULL )
	return S_FALSE;
	
    if ( *pmt->Type() ==MEDIATYPE_Interleaved &&
         *pmt->Subtype() ==MEDIASUBTYPE_dvsd   &&
	 *pmt->FormatType() == FORMAT_DvInfo	&&
	 pmt->FormatLength() == sizeof(DVINFO)  )   //*X 1/9/97 ask Syon put FORMAT_DVInfo support in FileReader and avi splitter
    {
       //10-30-97 if outputpin(s) is still connected, Check if output pins are happy with this new format
       //10-30-97 video outpin
	CDVSpOutputPin *pOutputPin;
	pOutputPin=(CDVSpOutputPin *)m_pDVSp->GetPin(DVSP_VIDOUTPIN);
	if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
	{    
	    //build new video format
	    CMediaType Cmt;
	    BuildVidCMT(InputFormat, &Cmt);

            CMediaType& Outmt = pOutputPin->m_mt;
	
	    //if video does changed from NTSC to PAL or PAL to NTSC
	    if( HEADER( (VIDEOINFO *)( Cmt.Format()  ) )->biHeight != 
		HEADER( (VIDEOINFO *)( Outmt.pbFormat) )->biHeight )
		if( S_OK != pOutputPin->GetConnected()->QueryAccept((AM_MEDIA_TYPE *)&Cmt) )
		    return S_FALSE;
	}

       //10-30-97 audio outpins
       	//new audio format
	CMediaType mt[2], *pamt[2];
	pamt[0]= &mt[0];
	pamt[1]= &mt[1];
	BuildAudCMT(InputFormat, pamt);
	
	for(int i=DVSP_AUDOUTPIN1; i<=DVSP_AUDOUTPIN2; i++)
	{
	    pOutputPin=(CDVSpOutputPin *)m_pDVSp->GetPin(i);
	    if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
	    {    
		if( S_OK != pOutputPin->GetConnected()->QueryAccept((AM_MEDIA_TYPE *)&mt[i-DVSP_AUDOUTPIN1]) )
		    return S_FALSE;
	    }
	}

	return S_OK;
    }

    return S_FALSE;
}

//----------------------------------------------------------------------------
// CDVSpInputPin::SetMediaType
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::SetMediaType (const CMediaType *pmt)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::SetMediaType pmt = %lx"), pmt));

    CAutoLock lock_it (m_pLock) ;

    HRESULT hr = NOERROR ;

    // make sure that the base class likes it
    hr = CBaseInputPin::SetMediaType (pmt) ; /*X* CBasePin:: m_mt=*pmt *X*/
    if (FAILED (hr))
        return hr ;
    else
	memcpy((unsigned char *)(&m_pDVSp->m_LastInputFormat),(unsigned char *)(pmt->pbFormat),sizeof(DVINFO) );

    ASSERT (m_Connected != NULL) ;

    return hr ;
}

//----------------------------------------------------------------------------
// CDVSpInputPin::BreakConnect
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::BreakConnect ()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::BreakConnect")));

    // release any allocator that we are holding.
    if (m_pDVSp->m_pAllocator)
    {
        m_pDVSp->m_pAllocator->Release () ;
        m_pDVSp->m_pAllocator = NULL ;
    }

    //X* when inputpin is disconnected, we have to disconnect and remove all ouputpins
    //X* 10-30-97, Rethinking about this , we do remove output pins 
    //X* 10-30-97 m_pDVSp->RemoveOutputPins();

    return CBaseInputPin::BreakConnect(); 
    
}

//----------------------------------------------------------------------------
// CDVSpInputPin::NotifyAllocator,connected upstream outputpin's DecideAllocat() calls it
//----------------------------------------------------------------------------
STDMETHODIMP
CDVSpInputPin::NotifyAllocator (IMemAllocator *pAllocator, BOOL bReadOnly)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::NotifyAllocator ptr = %lx"), pAllocator));

    CAutoLock lock_it (m_pLock) ;

    if (pAllocator == NULL)		//X* DVSp does not allocate any memory
        return E_FAIL ;             

    // free the old allocator if any.
    if (m_pDVSp->m_pAllocator)
        m_pDVSp->m_pAllocator->Release () ;

    // store away the new allocator
    pAllocator->AddRef () ;              // since we are stashing away the ptr
    m_pDVSp->m_pAllocator = pAllocator ; // save the new allocator

    // notify the base class about the allocator.
    return CBaseInputPin::NotifyAllocator (pAllocator,bReadOnly) ;
}

//----------------------------------------------------------------------------
// CDVSpInputPin::EndOfStream
//X*  do nothing except passing this message to downstream filters input pins.
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::EndOfStream ()
{

    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::EndOfStream")));
    CAutoLock lck_it(&m_pDVSp->m_csReceive);


    m_pDVSp->EndOfStream();

       	
    // !!! Why are we NOT passing this on to the base pin when we do it for
    // BeginFlush and EndFlush
    // return CBasePin::EndOfStream () ;
    return (NOERROR) ;
}

//----------------------------------------------------------------------------
// CDVSpInputPin::BeginFlush
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::BeginFlush ()
{
    CAutoLock lck(m_pLock);

    FILTER_STATE state;
    m_pDVSp->GetState(0, &state);

    if( state == State_Stopped) {
        return S_OK;
    }

    CBaseInputPin::BeginFlush();

    // can't flush the allocator here - need to sync with receive
    // thread, so do it in EndFlush
      /*  call the downstream pins  */
    return m_pDVSp->BeginFlush();
}

//----------------------------------------------------------------------------
// CDVSpInputPin::EndFlush
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::EndFlush ()
{
    CAutoLock lck(m_pLock);
    
    if (!IsFlushing()) {
      return S_OK;
    }

    FILTER_STATE state;
    m_pDVSp->GetState(0, &state);
    
    if( state != State_Stopped) {
        m_pDVSp->EndFlush();
    }
    
    return CBaseInputPin::EndFlush();
}

//---------------------------------------------------------------------------
// CDVSPInputPin::DetectChanges
// This function keeps the m_mt structure on the input pin always up to date
// to the changes on the incoming pin as another internal variable is used for
// all other work so m_mt never gets update although it is used by the property page
// in graph edit
//---------------------------------------------------------------------------


DWORD GetDWORD(const BYTE *pbData)
{
    return (pbData[3] << 24) + (pbData[2] << 16) + (pbData[1] << 8) + pbData[0];
}
BOOL FindDWORDAtOffset(const BYTE * pbStart, BYTE bSearch, DWORD dwOffset1, DWORD dwOffset2, DWORD *pdwData)
{
    const BYTE *pbTmp;
    if (pbStart[dwOffset1] == bSearch) {
        pbTmp = pbStart + dwOffset1;
    } else if (pbStart[dwOffset2] == bSearch) {
        pbTmp = pbStart + dwOffset2;
    } else {
        return FALSE;
    }
    *pdwData = GetDWORD(pbTmp + 1);
    return TRUE;
}

void CDVSpInputPin::DetectChanges(IMediaSample *pSample)
{
    DVINFO temp;
    ZeroMemory (&temp,sizeof (DVINFO));
    BYTE * pSrc;

    pSample->GetPointer(&pSrc);  //Obtain pointer to buffer

    const BYTE* pbTmp;
    const DWORD dwTemp = m_pDVSp->m_sDVAudInfo.wDIFMode * 80 * 150; 

    
    if (FindDWORDAtOffset(pSrc, 0x50, 483, 4323, &temp.dwDVAAuxSrc) &&
        FindDWORDAtOffset(pSrc, 0x50, 483 + dwTemp, 4323 + dwTemp, 
                          &temp.dwDVAAuxSrc1) &&
        FindDWORDAtOffset(pSrc, 0x51, 1763, 5603, &temp.dwDVAAuxCtl) &&
        FindDWORDAtOffset(pSrc, 0x51, 1763 + dwTemp, 5603 + dwTemp, &temp.dwDVAAuxCtl1) &&
        FindDWORDAtOffset(pSrc, 0x60, 448, 448, &temp.dwDVVAuxSrc) &&
        FindDWORDAtOffset(pSrc, 0x61, 453, 453, &temp.dwDVVAuxCtl)) 
    {
        DVINFO * dvFormat = (DVINFO * ) m_mt.pbFormat;
        *dvFormat = temp;
    }
                                      
    return;
}








//----------------------------------------------------------------------------
// CDVSpInputPin::Receive
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::Receive (IMediaSample *pSample)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::pSample ptr = %lx"), pSample));

    CAutoLock lck(&m_pDVSp->m_csReceive);

    // error check
    if(!pSample)
    {
        return E_INVALIDARG;
    }

    long lActual = (long) pSample->GetActualDataLength();
    
    // We need to check if the length of the sample is zero
    // Zero means that msdv detected a corrupt sample and changed the length 
    // so that downstream filters would ignore it.
    if (0 == lActual)
    {
        m_bDroppedLastFrame = TRUE;
        return S_OK;
    }

    if (m_bDroppedLastFrame)
    {
        // We need to set a discontinuity flag now...
        pSample->SetDiscontinuity(TRUE);
        m_bDroppedLastFrame = FALSE;
    }

    // format and sample size check
    // m_sDVAudInfo format has some some information that is constant
    // and different between NTSC and PAL.
    // please see defn. of "DVAudInfo" structure
    if( (m_pDVSp->m_sDVAudInfo.wBlkMode == 45)
         && (m_pDVSp->m_sDVAudInfo.wDIFMode == 5)
         && (m_pDVSp->m_sDVAudInfo.wBlkDiv == 15) )
    {
        // NTSC 120K buffers (tolerate some sizing error, i.e. -10,000 bytes)
        // some sizes of < 120,000 have been noticed sometimes for NTSC frames
        if( (lActual < 110000) || (lActual > 120000) )
        {
            m_pDVSp->NotifyEvent(EC_ERRORABORT, (long) E_INVALIDARG, 0);
            m_pDVSp->EndOfStream();
            return E_FAIL;
        }
    }
    else if( (m_pDVSp->m_sDVAudInfo.wBlkMode == 54)
              && (m_pDVSp->m_sDVAudInfo.wDIFMode == 6)
              && (m_pDVSp->m_sDVAudInfo.wBlkDiv == 18) )
    {
        // PAL 144K buffers (tolerate some sizing error, i.e. -10,000 bytes)
        if( (lActual < 140000) || (lActual > 144000) )
        {
            m_pDVSp->NotifyEvent(EC_ERRORABORT, (long) E_INVALIDARG, 0);
            m_pDVSp->EndOfStream();
            return E_FAIL;
        }
    }
    else
    {
        // bad audio info structure
        ASSERT( (m_pDVSp->m_sDVAudInfo.wBlkMode == 45) || (m_pDVSp->m_sDVAudInfo.wBlkMode == 54) \
                         && (m_pDVSp->m_sDVAudInfo.wDIFMode == 5) || (m_pDVSp->m_sDVAudInfo.wDIFMode == 6) \
                         && (m_pDVSp->m_sDVAudInfo.wBlkDiv == 15) || (m_pDVSp->m_sDVAudInfo.wBlkDiv == 18));
        m_pDVSp->NotifyEvent(EC_ERRORABORT, (long) E_INVALIDARG, 0);
        m_pDVSp->EndOfStream();
        return E_FAIL;
    }


    // check that all is well with the base class
    HRESULT hr = NOERROR;
    HRESULT hrAud = NOERROR;
    HRESULT hrVid = NOERROR;
    

    hr = CBaseInputPin::Receive (pSample);
    if (hr != NOERROR)
        return hr ;

    //skip invalid frame
    unsigned char *pSrc;
    // get input buffer
    hr = pSample->GetPointer(&pSrc);
    if (FAILED(hr)) 
    {
        return NULL;
    }
    ASSERT(pSrc);

    DetectChanges(pSample);

    hrAud = m_pDVSp->DecodeDeliveAudio(pSample);

    // if we have not seen a valid frame than do not deliver video either
    // if there are no audio pins connected then we will always set this flag to FALSE
    // and therefore we will always deliver video
    if(m_pDVSp->m_bNotSeenFirstValidFrameFlag)
    {
        // and we haven't addref'ed any samples yet, so no need to release
        // there won't be any filtergraph (sample delivery) related failures if this flag is TRUE
        // so we don't need to check for them
        return NOERROR;
    }


    //X* deliver pSample buffer to the dv video decoder through the video output pin
    AM_MEDIA_TYPE   *pmt = NULL;
    pSample->GetMediaType(&pmt);
    if (pmt != NULL && pmt->pbFormat != NULL) 
    {
	if(    ( ((DVINFO*)(m_mt.pbFormat))->dwDVAAuxSrc & AUDIO5060)
	    == ( ((DVINFO*)(pmt->pbFormat))->dwDVAAuxSrc & AUDIO5060) )
	    //only audio type changed
	{
	    if(pmt!=NULL) 
		DeleteMediaType(pmt);
    	    pmt=NULL;
	}
	
    }
    pSample->SetMediaType(pmt);    
    if(pmt!=NULL) 
	DeleteMediaType(pmt);

    hrVid = m_pDVSp->DeliveVideo(pSample);

    // analyze failure cases
    // either both pins succeeded
    // or one failed with VFW_E_NOT_CONNECTED
    if( ((SUCCEEDED(hrAud)) && (SUCCEEDED(hrVid)))
        || ((SUCCEEDED(hrAud)) && (hrVid == VFW_E_NOT_CONNECTED))
        || ((SUCCEEDED(hrVid)) && (hrAud == VFW_E_NOT_CONNECTED)) )
    {
        // only one of them or neither or them failed with VFW_E_NOT_CONNECTED
        hr = (SUCCEEDED(hrAud)) ? hrAud : hrVid;
    }
    else
    {
        // a failure happened on either one or both pins
        int             beginRange = 0;
        int             endRange = -1;      // -1 so if both pins failed, we don't send EOS in for-loop
        CDVSpOutputPin  *pOutputPin = NULL;

        // init'ed in case both failed
        hr = hrAud;

        // chose pin that did not fail
        if(SUCCEEDED(hrAud))
        {
            // EOS on connected Audio pins
            beginRange = DVSP_AUDOUTPIN1;
            endRange = DVSP_AUDOUTPIN2;

            // hrAud is success, it means hrVid is definitely fail
            hr = hrVid;
        }
        else if(SUCCEEDED(hrVid))
        {
            // EOS on Video pin
            beginRange = endRange = DVSP_VIDOUTPIN;
        }

        // send EOS on chosen pins
        for(int i = beginRange; i <= endRange; i++)
        {
            pOutputPin = (CDVSpOutputPin*) m_pDVSp->GetPin(i);
            if( (pOutputPin) && pOutputPin->IsConnected() && pOutputPin->m_pOutputQueue )
            {
                pOutputPin->m_pOutputQueue->EOS();
            }
        }
    }
    
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin receive() return: %x"), hr));
    return hr;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.
// ------------------------------------------------------------------------
HRESULT
CDVSpInputPin::CompleteConnect(IPin *pReceivePin)
{
  HRESULT hr = CBasePin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
    return hr;

  //X* now we are definitely connected. We notyify the DVSp to creat output pins we need
  hr = m_pDVSp->NotifyInputConnected();
  
  return hr;
}


//----------------------------------------------------------------------------
// CDVSpOutputPin constructor
//----------------------------------------------------------------------------
CDVSpOutputPin::CDVSpOutputPin (TCHAR *pName, CDVSp *pDVSp, HRESULT *phr,
                            LPCWSTR pPinName /*X , int PinNumber *X*/)
 : CBaseOutputPin (pName, pDVSp, pDVSp, phr, pPinName) ,
 m_bHoldsSeek (FALSE),
 m_pPosition (NULL),
 m_pDVSp (pDVSp),
 m_pOutputQueue(NULL)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin constructor")));
    ASSERT (pDVSp) ;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin destructor
//----------------------------------------------------------------------------
CDVSpOutputPin::~CDVSpOutputPin ()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin destructor")));
}


/* CBasePin methods  */

HRESULT CDVSpOutputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    // if the input pin is not connected, we do not know output pin's media type.
    if ( m_pDVSp->m_Input.m_Connected == NULL)
	return E_INVALIDARG;

    if (!iPosition) 
    {
        CMediaType Inmt(m_pDVSp->m_Input.m_mt);
	CMediaType *pamt[2];

    
    // 7/26/99 xuping wu, qbug 42119
    // 1. Build a graph to playback a dv type1 file(with audio type change on fly)
    //    connection(32K), actual(48K)
    // 2. play this graph a couple seconds
    // 3. stop the graph
    // 4. disconnect audio render 
    // 5. reconnect audio render, audio sounds bad. It is caused by m_LastInputFormat was set to last 
    // dv sample's format(48K), and CDVSpOutputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
    // uses m_pDVSp->m_Input.m_mt (32k) to make connection,
    memcpy((unsigned char *)Inmt.pbFormat, (unsigned char *)&(m_pDVSp->m_LastInputFormat),sizeof(DVINFO) );
    // end 7/26/99
    
	ASSERT( (DVINFO *)Inmt.pbFormat );

	//build output pin's media type according to input pin
	if( (CDVSpOutputPin *)m_pDVSp->GetPin(DVSP_VIDOUTPIN) == this )
	    BuildVidCMT((DVINFO *)Inmt.pbFormat,pMediaType);
	else if( (CDVSpOutputPin *)m_pDVSp->GetPin(DVSP_AUDOUTPIN1)== this )
	    {
		pamt[0] =pMediaType;
		pamt[1] =NULL;
		BuildAudCMT((DVINFO *)Inmt.pbFormat,pamt);
	    }else if (  (CDVSpOutputPin *)m_pDVSp->GetPin(DVSP_AUDOUTPIN2)== this ) 
		{
		    pamt[1] =pMediaType;
		    pamt[0] =NULL;
		    BuildAudCMT((DVINFO *)Inmt.pbFormat,pamt);
	    }
		else
		    return E_INVALIDARG;
    }	
    else if (iPosition>0) 
    {
	return VFW_S_NO_MORE_ITEMS;
    }else
	return E_INVALIDARG;
	   					
    return S_OK;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin::NonDelegatingQueryInterface
//
// This function is overwritten to expose IMediaPosition and IMediaSelection
// Note that only one output stream can be allowed to expose this to avoid
// conflicts, the other pins will just return E_NOINTERFACE and therefore
// appear as non seekable streams. We have a LONG value that if exchanged to
// produce a TRUE means that we have the honor. If it exchanges to FALSE then
// someone is already in. If we do get it and error occurs then we reset it
// to TRUE so someone else can get it.
//----------------------------------------------------------------------------
STDMETHODIMP CDVSpOutputPin::NonDelegatingQueryInterface (REFIID riid, void **ppv)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::NonDelegatingQI" )));

    CheckPointer(ppv,E_POINTER);
    ASSERT (ppv) ;
    *ppv = NULL ;
    HRESULT hr = NOERROR ;

    // see what interface the caller is interested in.
    if (riid == IID_IMediaPosition || riid ==IID_IMediaSeeking )  //IID_IMediaSelection)
    {
        if (m_pPosition==NULL)
        {
	// Create implementation of this dynamically as sometimes we may never
	// try and seek. The helper object implements IMediaPosition and also
	// the IMediaSelection control interface and simply takes the calls
	// normally from the downstream filter and passes them upstream

	CPosPassThru *pMediaPosition = NULL ;
	CDVSp	*pSp ;                  // ptr to the owner filter class
	pSp=m_pDVSp;
	IPin *pIPin;
	pIPin=	(IPin*) &m_pDVSp->m_Input,
	pMediaPosition = new CDVPosPassThru (NAME("DVSP CPosPassThru"), 
				    GetOwner(),
				    &hr,
				    pIPin,
				    pSp) ;
	if (pMediaPosition == NULL)
	    return E_OUTOFMEMORY ;
	
	m_pPosition = pMediaPosition ;
	//X* m_pPosition->AddRef () ;
	}
	m_bHoldsSeek = TRUE ;
	return m_pPosition->NonDelegatingQueryInterface (riid, ppv) ;
        
    }
    else
        return CBaseOutputPin::NonDelegatingQueryInterface (riid, ppv) ;

}

//----------------------------------------------------------------------------
// CDVSpOutputPin::DecideBufferSize
// X* called by DecideAllocate
//*X* for the Audio Output Pin,let get 10 buffers from the audio render or allocate by 
//*X* for the Video Output Pin,this is never got called.
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::DecideBufferSize (IMemAllocator *pMemAllocator,
                                         ALLOCATOR_PROPERTIES * pProp)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::DecideBufferSize ptr = %lx"), pMemAllocator));

    // set the size of buffers based on the expected output frame size, and
    // the count of buffers to 1.
    //
    ALLOCATOR_PROPERTIES propActual;
    pProp->cbAlign = 4;
    pProp->cbPrefix= 0;
    pProp->cBuffers = 20;			/*X* 10 match avi splitter *X*/ 
    pProp->cbBuffer = 1024*8;
    //pProp->cbBuffer = m_mt.GetSampleSize(); /*X* return m_mt.lSampleSize *X*/
    DbgLog((LOG_TRACE, 2, TEXT("DVSp Sample size = %ld\n"), pProp->cbBuffer));

    ASSERT(pProp->cbBuffer > 0);

    HRESULT hr = pMemAllocator->SetProperties(pProp, &propActual);
    if (FAILED(hr)) {
        return hr;
    }

    DbgLog((LOG_TRACE, 2, TEXT("DVSP Actul. buf size = %ld\n"), propActual.cbBuffer));

    //if (propActual.cbBuffer < (LONG)(21*1028)) {
    if (propActual.cbBuffer < (LONG)m_mt.GetSampleSize() ) {
	ASSERT(propActual.cbBuffer >=(LONG)m_mt.GetSampleSize() );
        // can't use this allocator
        return E_INVALIDARG;
    }


    return S_OK;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin::DecideAllocator
//*X* called by CompleteConnection()
//*X* for the Audio Output Pin, we get allocator from the audo render
//*X* for the Video Output Pin, we pass the current allocator to the connected filter
//*X* DecideAllocator is called by CDVSpPutputPin's CompleteConnect()
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::DecideAllocator (IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::DecideAllocator ptr = %lx"), pPin));

    ASSERT ( m_pDVSp->m_pAllocator != NULL ) ;

    /*X* CBaseMedia m_mt is a number of the CBasePin *X*/
    if ( *m_mt.Type() == MEDIATYPE_Video  )
    {      
	*ppAlloc = NULL ;
	// tell the connected pin about our allocator, set by the input pin.
	HRESULT hr = NOERROR ;
	hr = pPin->NotifyAllocator (m_pDVSp->m_pAllocator,TRUE) ;
	if (FAILED (hr))
	    return hr ;

	// return the allocator
	*ppAlloc = m_pDVSp->m_pAllocator ;
	m_pDVSp->m_pAllocator->AddRef () ;
    }
    else if( *m_mt.Type() ==  MEDIATYPE_Audio ) {	//X* ask render for allocator
	HRESULT hr = NOERROR ;
	hr = CBaseOutputPin::DecideAllocator(pPin,ppAlloc);
	if (FAILED (hr))
	    return hr ;
    }
    else
	return E_FAIL ;	


    return NOERROR ;
}


//----------------------------------------------------------------------------
// CDVSpOutputPin::CheckMediaType
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::CheckMediaType (const CMediaType *pmt)
{
    CMediaType mt;
    HRESULT hr = GetMediaType(0, &mt);	
    if (FAILED(hr)) {
	return hr;
    }
    if (    *pmt->Type() == *mt.Type() 
	&&  *pmt->Subtype() == *mt.Subtype()  
	&&  *pmt->FormatType() == *mt.FormatType()  ) 
    {
	if( *mt.Subtype() == MEDIASUBTYPE_PCM )
            // jaisri: Note that, for audio pins,  mt.lSampleSize is set in the 
            // CMediaType constructor to 1 and is not changed by GetMediaType or 
            // the functions it calls, viz. BuildAudCMT()
	     if( mt.lSampleSize > pmt->lSampleSize )
		 return VFW_E_TYPE_NOT_ACCEPTED;

	return NOERROR ;
    }else
	return VFW_E_TYPE_NOT_ACCEPTED ;
 }


//----------------------------------------------------------------------------
// CDVSpOutputPin::SetMediaType
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::SetMediaType (const CMediaType *pmt)
{
    CAutoLock lock_it (m_pLock) ;


    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::SetMediaType ptr = %lx"), pmt));

    // display the format of the media for debugging purposes
    DisplayMediaType (TEXT("Output pin type agreed"), pmt) ;

    // make sure that we have an input connected.
    if (m_pDVSp->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED ;

    // make sure that the base class likes it.
    HRESULT hr = NOERROR ;
    hr = CBaseOutputPin::SetMediaType (pmt) ;
    if (FAILED (hr))
        return hr ;

    return NOERROR ;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin::Active *X*
//
// This is called when we start running or go paused. We create the output queue
// object to send data to our associated peer pin.
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::Active ()
{

    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::Active")));
    //CAutoLock lck(m_pLock);

    /*  If we're not connected we don't participate so it's OK */
    if (!IsConnected()) {
        return S_OK;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
        return hr;
    }

    /*  Create our batch list */
    ASSERT(m_pOutputQueue == NULL);

    hr = S_OK;
    m_pOutputQueue = new COutputQueue(GetConnected(), // input pin
                                      &hr,            // return code
                                      TRUE,	//FALSE,          // Auto detect
                                      FALSE,	//TRUE,           // ignored
                                      1,             // batch size
                                      FALSE,    //TRUE,       // exact batch
                                      15);           // queue size
    if (m_pOutputQueue == NULL) {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }
    return hr;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin::Inactive *X*
//
// This is called when we stop streaming. We delete the output queue at this
// time.
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::Inactive ()
{
    //CAutoLock lock_it (m_pLock) ;
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::Inactive")));

    /*  If we're not involved just return */
    if (!IsConnected()) {
        return S_OK;
    }

    delete m_pOutputQueue;
    m_pOutputQueue = NULL;
    return S_OK;
}


// put the NewSegment on the output Q
//
HRESULT CDVSpOutputPin::DeliverNewSegment(REFERENCE_TIME tStart,
					REFERENCE_TIME tStop, double dRate)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->NewSegment(tStart, tStop, dRate);
    return NOERROR;

}

//X**************************************************************************************
//X*  Utilities
//X**************************************************************************************
//
// -------------------------------------------------------------------------------------
// Please refer to these BlueBook pages when reading these functions
// BlueBook Part2
// pp. 16-21 (Audio Signal Processing)
// pp. 68-75 (shuffling patterns for audio)
// pp. 109 - 117 (Basic DV Frame Data Structures)
// pp. 262 - 268 (AAUX Source and Source Control Packet spec.)
//
// -------------------------------------------------------------------------------------
// General Algorithm:
// The audio for the DV Frame can be either mono or stereo (Please see pp. 265)
// it can be in either just one block or both block
// an audio block consists of 5 or 6 DIF sequences
// note: NTSC has 10 DIF sequences so each audio block is 5 DIF sequences,
// PAL has 12 DIF sequences so each audio block is 6 DIF sequences
// each audio block has its own AAUX Source Pack which is passed in as "DVINFO *InputFormat"
// -------------------------------------------------------------------------------------
// 1) Try to see if we are at least seeing PAL or NTSC data
// 2) because if the AUDIOMODE == NOINFO 0xff, we should at least deliver video correctly
// 3) Then check to see if either audio mode is NOINFO
// otherwise for each DIF block's audio mode: (refer to BlueBook pp. 262)
// 4) initialize 50/60 flag (or PAL or NTSC Flag)
// 5) initialize the audio frequency
// 6) initialize audio bits (16 or 12)
// 7) initialize DIF Block data depending on if Format is PAL or NTSC
// 8) setup the DVAudInfo, depending on what the audio mode of each of the AAUX's of each of the Audio blocks is
//  (see pp. 265)
// 9) Setup the WaveFormatEX
//
// Caveat: ppwfx[i] is intialized iff pInfo->bNumAudPin > i. So, if there is only
// one audio pin ppwfx[1] is not initialized. 
HRESULT BuildDVAudInfo(DVINFO *InputFormat, WAVEFORMATEX **ppwfx, DVAudInfo *pDVAudInfo) 
{
    DVAudInfo *pInfo;
    
    //to avoid change InoutFormat contains
    DVINFO tDvInfo;
    DVAudInfo tmpDVAudInfo;
    WAVEFORMATEX *tmpWaveFormatArray[2]={NULL,NULL};
    WAVEFORMATEX tmpWaveFormat;

    CopyMemory(&tDvInfo, InputFormat, sizeof(DVINFO));

    
    if( pDVAudInfo == NULL )
    {
	pInfo	= &tmpDVAudInfo;
    }
    else
	pInfo   =pDVAudInfo;

    //-----------------------------------------------------------
    // 1) Try to see if we are at least seeing PAL or NTSC data
    // 2) because if the AUDIOMODE == NOINFO 0xff, we should at least deliver video correctly

    // init DVAudInfo with some information in case we fail out later
    pInfo->bNumAudPin=0;

    // and set the DIF Mode flags
    if(( InputFormat->dwDVAAuxSrc & AUDIO5060 ) == ( InputFormat->dwDVAAuxSrc1 & AUDIO5060 ))
    {
        // Manbugs # 35117
        BYTE bTemp = (BYTE) (( InputFormat->dwDVAAuxSrc & AUDIO5060 ) >> 21); 
        if(!bTemp)
        {
            // 525_60
            // NTSC
            pInfo->wBlkMode=45;
            pInfo->wDIFMode=5;
            pInfo->wBlkDiv=15;
        }
        else
        {
            // 625_50
            // PAL
            pInfo->wBlkMode=54;
            pInfo->wDIFMode=6;
            pInfo->wBlkDiv=18;
        }
    }
    else
    {
        // make sure they do not denote PAL or NTSC
        pInfo->wBlkMode=0;
        pInfo->wDIFMode=0;
        pInfo->wBlkDiv=0;
    }


    if(ppwfx==NULL )
    {
	ppwfx = tmpWaveFormatArray;
    }
    

    for(int i=0; i<2; i++)
    {
        // if the caller does not want this returned,
        // it's ok to use the same array for both audio pins
        // because we only set the member sof ppwfx[i]
        if( ppwfx[i]==NULL )
	    ppwfx[i] = &tmpWaveFormat;
    }

    //---------------------------------------------------------------------
    // 3) Then check to see if either audio mode is NOINFO

    //Audio look up table's index
    BYTE bSMP[2];
    BYTE b50_60=0xff;	//first 5/6 DIF sequences's 50/60 must equal 2nd 5/6 DIF seqeences 
    BYTE bQU[2]={0xff, 0xff};

    //check 1st 5/6 DIF's SM and CHN
    DWORD dwSMCHN=0xffff;
    DWORD dwAUDMOD=InputFormat->dwDVAAuxSrc & AUDIOMODE;
    if( dwAUDMOD==0x00000f00)
    {
        //no audio
	//audio source	NTSC 0xc0c00fc0
	//PC1   1 1 0 0 0 0 0 0	    0xc0
	//PC2   0 0 0 0 1 1 1 1	    0x0f
	//PC3   1 1 0 0 0 0 0 0	    0xc0
	//PC4   1 1 0 0 0 0 0 0	    0xc0
	// PAL   0xc0e00fc0
	//PC1   1 1 0 0 0 0 0 0	    0xc0
	//PC2   0 0 0 0 1 1 1 1	    0x0f
	//PC3   1 1 1 0 0 0 0 0	    0xe0
	//PC4   1 1 0 0 0 0 0 0	    0xc0

	//control 0xffffff3f
	//PC1   0 0 1 1 1 1 1 1	    0x3f
	//PC2   1 1 1 1 1 1 1 1	    0xff
	//PC3   1 1 1 1 1 1 1 1	    0xff
	//PC4   1 1 1 1 1 1 1 1	    0xff
	if(  InputFormat->dwDVAAuxSrc & AUDIO5060  )
	    //PAL
	    tDvInfo.dwDVAAuxSrc=0xc0e00fc0;
	else
        {
            // NTSC
	    tDvInfo.dwDVAAuxSrc=0xc0c00fc0;
        }

	tDvInfo.dwDVAAuxCtl=0xffffff3f;
    }
    else
    {
        // AUDIO DIF Block 1 (from 0th DIF sequence onwards)
        // (refer to BlueBook pp 109 and pp. 262)
        // This is the SMCHN data
	dwSMCHN=InputFormat->dwDVAAuxSrc & SMCHN;

        // PAL or NTSC
	b50_60=(BYTE)( ( InputFormat->dwDVAAuxSrc & AUDIO5060 ) >> 21 );

        // audio frequency
	bSMP[0]=(BYTE)( ( InputFormat->dwDVAAuxSrc & AUDIOSMP ) >> 27 );
        ASSERT(bSMP[0] <= 0x02);
        if(bSMP[0] > 0x02)
        {
            // SMP-> 0=48K, 1=44.1K, 2=32K, everything else invalid
            return E_FAIL;
        }
	    	
	//how any audio bits
	if( !( InputFormat->dwDVAAuxSrc & AUDIOQU )  )
	{
	    bQU[0]=16;
	}
	else if( ( InputFormat->dwDVAAuxSrc & AUDIOQU ) == 0x01000000  )
	{
	    bQU[0]=12;
	}
	else
        {
	    //not support 20 bits
	    ASSERT(bQU[0]==0xff);
            return E_FAIL;
        }
    }
	
	
    //check 2nd 5/6 DIF's SM and CHN
    DWORD dwSMCHN1=0xffff;
    DWORD dwAUDMOD1=InputFormat->dwDVAAuxSrc1 & AUDIOMODE;
    if( dwAUDMOD1==0x00000f00)
    {
	if(  InputFormat->dwDVAAuxSrc1 & AUDIO5060  )
	    //PAL
	    tDvInfo.dwDVAAuxSrc1=0xc0e00fc0;
	else
        {
            // NTSC
	    tDvInfo.dwDVAAuxSrc1=0xc0c00fc0;
        }

	tDvInfo.dwDVAAuxCtl1=0xffffff3f;
    }
    else
    {
        // AUDIO DIF Block 2 (from (5th if NTSC) or (6th if PAL) DIF sequence onwards)
        // (refer to BlueBook pp 109 and pp. 262)
        dwSMCHN1=InputFormat->dwDVAAuxSrc1 & SMCHN;

        // make sure that Both audio modes are either PAL or NTSC
        // we cannot have one say NTSC and the other say PAL
        // or vice-versa
        if(b50_60==0xff)
        {
            // 1st mode invalid
	    b50_60 =(BYTE)(  ( InputFormat->dwDVAAuxSrc1 & AUDIO5060 ) >> 21 );
        }
	else
        {
            // if the other audio mode is valid than these two should match
            if(b50_60 !=(BYTE)( ( InputFormat->dwDVAAuxSrc1 & AUDIO5060 ) >> 21 ) )
            {
       	        ASSERT( b50_60 ==(BYTE)( ( InputFormat->dwDVAAuxSrc1 & AUDIO5060 ) >> 21 ) );
                return E_FAIL;
            }
	}

        // audio frequency
	bSMP[1]=(BYTE)( ( InputFormat->dwDVAAuxSrc1 & AUDIOSMP ) >> 27 );
        ASSERT(bSMP[1] <= 0x02);
        if(bSMP[1] > 0x02)
        {
            // SMP-> 0=48K, 1=44.1K, 2=32K, everything else invalid
            return E_FAIL;
        }
	
	//how any audio bits
	if( !( InputFormat->dwDVAAuxSrc1 & AUDIOQU )  )
        {
	    bQU[1]=16;
	}
        else if( ( InputFormat->dwDVAAuxSrc1 & AUDIOQU )==0x01000000  )
        {
	    bQU[1]=12;
        }
	else
        {
	    //not support 20 bits
	    ASSERT(bQU[1]==0xff);
            return E_FAIL;
        }
    }

    //---------------------------------------------------------------------
    // 7) initialize DIF Block data depending on if Format is PAL or NTSC    
    
    // either b50_60 is valid, here, or both Audio modes are 0x0f00
    if(b50_60 == 0xff)
    {
        // both blocks bad, both modes == 0x0f00
        return E_FAIL;
    }
    if(!b50_60)
    {
        //525_60
        // NTSC
        pInfo->wBlkMode=45;
        pInfo->wDIFMode=5;
        pInfo-> wBlkDiv=15;
    }
    else
    {
        //625_50
        // PAL
        pInfo->wBlkMode=54;
        pInfo->wDIFMode=6;
        pInfo-> wBlkDiv=18;
    }

    //--------------------------------------------------------------------
    // 8) setup the DVAudInfo, depending on what the audio mode of each of the AAUX's of each of the Audio blocks is
    //************************init DVAudioInfo*******************
    if ( ( (InputFormat->dwDVAAuxSrc  & AUDIOMODE) != 0x00000f00 ) && 
	 ( (InputFormat->dwDVAAuxSrc1 & AUDIOMODE) != 0x00000f00 )  )
    {
        // make sure that the audio quality is only 12 or 16
        if( ( (bQU[0] != 12) && (bQU[0] != 16) ) ||
            ( (bQU[1] != 12) && (bQU[1] != 16) ) )
        {
            return E_FAIL;
        }

        //audio data in all 10/12 DIF sequence
        if ((!dwSMCHN) && (!dwSMCHN1) && ( ( (!dwAUDMOD) && (dwAUDMOD1 == 0x00000100) ) ||  ( (!dwAUDMOD1) && (dwAUDMOD == 0x00000100) ) ) )
        {
    	    //**** 1 language
    	    //mode 1, SM=0,and CHN=0,
            // AUDIOMODE=0000 and AUDIOMODE=0001 or AUDIOMODE=0001 and AUDIOMODE=0000. 
            // Blue book doesn't allow AUDIOMODE=0001 and AUDIOMODE=0000.
    	    pInfo->bAudStyle[0]=0x80;
	    ASSERT(bQU[0]==bQU[1]);
	    pInfo->bAudQu[0]=bQU[0];
	    pInfo->bNumAudPin=1;
	    ppwfx[0]->nChannels        = 2;	//X* if stereo, then 2 
	}
	else if( (dwSMCHN&0x002000) && (dwSMCHN1&0x002000) && !dwAUDMOD && !dwAUDMOD1 )
	{
	    // stereo + stereo
            //**** 2 languages
	    //mode 5-> two stereo : SM=0 and CHN=1,AUDIOMODE=0000 in both 5/6 DIF seq
	    pInfo->bAudStyle[0]=0x40;
	    pInfo->bAudStyle[1]=0x40 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
	    pInfo->bAudQu[0]=bQU[0];
	    pInfo->bAudQu[1]=bQU[1];
	    pInfo->bNumAudPin=2;
	    ppwfx[0]->nChannels        = 2;	//X* if stereo, then 2 
	    ppwfx[1]->nChannels        = 2;	//X* if stereo, then 2 
	}
        else if( (!dwSMCHN) && (!dwSMCHN1) && (dwAUDMOD == 0x00000200) && (dwAUDMOD1 == 0x00000200))
	{	
	    //**** 2 languages
	    //mode 3-> two mon:		SM=0 and CHN=0,AUDIOMODE=0010 in both 5/6 DIF seq
	    pInfo->bAudStyle[0]=0x00;
	    pInfo->bAudStyle[1]=0x00 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
	    pInfo->bAudQu[0]=bQU[0];
	    pInfo->bAudQu[1]=bQU[1];
	    pInfo->bNumAudPin	=2;
	    ppwfx[0]->nChannels        = 1;	//X* if stereo, then 2 
	    ppwfx[1]->nChannels        = 1;	//X* if stereo, then 2 
	}
        else if( (dwSMCHN & 0x002000) && (dwSMCHN1 & 0x002000)
                 && ( ((dwAUDMOD <= 0x0200) && (dwAUDMOD1 <= 0x0600))       // AudMod == Ch(a,b), AudMod1 == Ch(c,d)
                      || ((dwAUDMOD <= 0x0600) && (dwAUDMOD1 <= 0x0200)) ) )// AudMod == Ch(c,d), AudMod1 == Ch(a,b)
        {
	    // **** 2 languages
	    // SM=0/1, PA= 0/1 and CHN=1 (in both blocks' AAUX's)
            // and the audio modes != 0x0F, and != 0x0E
            // we will treat this as a 2, 12 bit stereo tracks case
            // please see Bluebook, Part2 Page 265, part2 page 70, part2 pages 16-21

            // @@@ jaisri: This is bogus. This handles:
            // Stereo + 1 ch mono  - second audio pin nChannels should be set to 1 (fixed 7/12/00)
            // 1 ch mono + stereo - first audio pin should have nChannels set to 1 (fixed 7/12/00)
            // Stereo + 2 ch mono  - really requires 3 audio pins
            // 2 ch mono + Stereo - requires 3 audio pins
            // 4 ch mono - requires 4 audio pins
            // 3 ch mono case 1, 3 ch mono case 2: requires 3 audio pins
            // 2 ch mono case 2 - both audio pins should have nChannels set to 1
            // 3/1 stereo, 3/0 stereo + 1 ch mono, 3/0 stereo and 2/2 stereo
	    pInfo->bAudQu[0]=bQU[0];
	    pInfo->bAudQu[1]=bQU[1];
	    pInfo->bNumAudPin=2;

            if (dwAUDMOD == 0 && dwAUDMOD1 == 0x0100)
            {
                // stereo + 1 ch mono
                pInfo->bAudStyle[0]=0x40;
                pInfo->bAudStyle[1]=0x00 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
                ppwfx[0]->nChannels        = 2;	//X* if stereo, then 2 
                ppwfx[1]->nChannels        = 1;	//X* if stereo, then 2
            }
            else if (dwAUDMOD1 == 0 && dwAUDMOD == 0x0100)
            {
                // 1 ch mono + stereo
                pInfo->bAudStyle[0]=0x00;
                pInfo->bAudStyle[1]=0x40 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
                ppwfx[0]->nChannels        = 1;	//X* if stereo, then 2 
                ppwfx[1]->nChannels        = 2;	//X* if stereo, then 2
            }
            else
            {
                // Code as it was before
                pInfo->bAudStyle[0]=0x40;
                pInfo->bAudStyle[1]=0x40 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
                ppwfx[0]->nChannels        = 2;	//X* if stereo, then 2 
                ppwfx[1]->nChannels        = 2;	//X* if stereo, then 2
            }
        }
        else	
	{
	    //error
	    return E_FAIL;
	}
    }
    else
    {
        // Ignore Audiomodes = 1110 binary, and Audiomodes = 1111 binary
        // see Bluebook Part2 page 265
        if( ( ( (dwAUDMOD) != 0x00000E00 ) &&
              ( (dwAUDMOD1) != 0x00000E00 ) )
              &&
            ( ( (dwAUDMOD) != 0x00000f00 ) ||
              ( (dwAUDMOD1) != 0x00000f00 ) ) )
        {
            // which audio mode is the good one

            // jaisri: Note: The blue book requires that the first of the two 
            // audio blocks always have good audio (see tables on pg 265), so 
            // we really don't have to handle the case when dwAUDMOD is 
            // and 0x00000f00 and dwAUDMOD1 is not. In that case (i.e.
            // if the first pin has no audio), this code "redirects" audio from
            // the second block to the first audio pin.

            int     iGoodIndex     = (dwAUDMOD != 0x00000f00) ? 0 : 1;
            WORD    wDIFMode       = (dwAUDMOD != 0x00000f00) ? 0 : pInfo->wDIFMode;
            DWORD   dwGoodAudMod   = (dwAUDMOD != 0x00000f00) ? dwAUDMOD : dwAUDMOD1;
            DWORD   dwGoodSMCHN    = (dwAUDMOD != 0x00000f00) ? dwSMCHN : dwSMCHN1;

            // make sure that the audio quality is only 12 or 16
            if( (bQU[iGoodIndex] != 12) && (bQU[iGoodIndex] != 16) )
            {
                return E_FAIL;
            }

            // always copy the good block's sampling frequency
            bSMP[0] = bSMP[iGoodIndex];

            // now we have 4 cases:
            // 1ch Mono (with 16 bit channel in the audio block)
            // with 12 bit channel in audio block
            // Stereo
            // 2ch Mono, case 1
            // 1ch Mono

            if(!dwGoodSMCHN)
            {
                // we are in 1 channel per audio block, i.e. 16 bit mode

                // this is the only valid, 1 channel scenario
                if(dwGoodAudMod == 0x0200)
                {
                    // 1ch Mono
                    pInfo->bAudStyle[0] = (BYTE) wDIFMode;     // 0, or 5/6 depending on which block is good
                    pInfo->bAudQu[0] = bQU[iGoodIndex];
                    pInfo->bNumAudPin = 1;
                    ppwfx[0]->nChannels = 1;    // mono
                }
                else
                {
                    // invalid mode
                    return E_FAIL;
                }
            }
            else
            {
                // we are in 2 channel per audio block mode
                if(!dwGoodAudMod)
                {
                    // stereo in 1 one of the 5/6 DIF blocks
                    pInfo->bAudStyle[0] = 0x40 | wDIFMode;     // 0, or 5/6 depending on which block is good
                    pInfo->bAudQu[0] = bQU[iGoodIndex];
                    pInfo->bNumAudPin = 1;
                    ppwfx[0]->nChannels = 2;    // stereo
                }
                else if(dwGoodAudMod == 0x0200)
                {
                    // 2ch mono, case 1
                    // we will treat this as stereo for now
                    // @@@ jaisri: This is wrong. Should set
                    // pInfo->bNumAudPin = 2, with each being mono
                    pInfo->bAudStyle[0] = 0x40 | wDIFMode;     // 0, or 5/6 depending on which block is good
                    pInfo->bAudQu[0] = bQU[iGoodIndex];
                    pInfo->bNumAudPin = 1;
                    ppwfx[0]->nChannels = 2;    // stereo
                }
                else if(dwGoodAudMod == 0x0100)
                {
                    // 1ch mono
                    // again, we will treat this as stereo for now
                    pInfo->bAudStyle[0] = 0x40 | wDIFMode;     // 0, or 5/6 depending on which block is good
                    pInfo->bAudQu[0] = bQU[iGoodIndex];
                    pInfo->bNumAudPin = 1;
                    // @@@ jaisri: Should set nChannels to 1.
                    ppwfx[0]->nChannels = 2;    // stereo
                }
                else
                {
                    // invalid mode
                    return E_FAIL;
                }

            }// endif (dwGoodSMCHN)
        }
	else
	{
            // both tracks are either indistinguishable (audio modes == 0x0E,
            // or have No info (audiomodes == 0x0F)
            return E_FAIL;

	}// endif (both tracks are bad)

    }// endif (at least one of the tracks is bad)


    //-----------------------------------------------------------------
    // 9) Setup the WaveFormatEX

    for(i=0; i<pInfo->bNumAudPin; i++) 
    {
	pInfo->wAvgSamplesPerPinPerFrm[i]=(WORD)aiAudSampPerFrmTab[b50_60][bSMP[i]] ;
	ppwfx[i]->nSamplesPerSec   = aiAudSampFrq[bSMP[i]];	
	ppwfx[i]->wFormatTag	   = WAVE_FORMAT_PCM;
	ppwfx[i]->wBitsPerSample   = 16;
	ppwfx[i]->nBlockAlign      = (ppwfx[i]->wBitsPerSample * ppwfx[i]->nChannels) / 8;
	ppwfx[i]->nAvgBytesPerSec  = ppwfx[i]->nSamplesPerSec * ppwfx[i]->nBlockAlign;
	ppwfx[i]->cbSize           = 0;
    }
	
    return NOERROR;
}


//build audio outpin (s)'s media type according to input pin's media type
HRESULT BuildAudCMT(DVINFO *pDVInfo, CMediaType **ppOutCmt)
{
    HRESULT hr=E_FAIL;

    if( pDVInfo ==NULL )
	return E_OUTOFMEMORY;

    WAVEFORMATEX *ppwfx[2];

    for(int i=0; i<2; i++)
    {
	ppwfx[i]=NULL;
	if(ppOutCmt[i] !=NULL)
	{   
	    ppwfx[i] = (WAVEFORMATEX *)ppOutCmt[i]->Format();
	    if(ppwfx[i]==NULL || ppOutCmt[i]->cbFormat != sizeof(WAVEFORMATEX) )
	    {
		// jaisri - this potentially leaks memory - see the 
                // implementation of CMediaType::ReallocFormatBuffer
                // ppOutCmt[i]->cbFormat = 0;

		ppwfx[i] = (WAVEFORMATEX *)ppOutCmt[i]->ReallocFormatBuffer(sizeof(WAVEFORMATEX));
		
                // jaisri - Wrong. We don't know what size was alloc'd,
                // so don't change this
                // ppOutCmt[i]->cbFormat = sizeof(WAVEFORMATEX);
	    }
	    
	    ppOutCmt[i]->majortype		    =MEDIATYPE_Audio; //streamtypeAUDIO
	    ppOutCmt[i]->subtype		    =MEDIASUBTYPE_PCM; 
	    ppOutCmt[i]->bFixedSizeSamples	    =1;	//X* 1 for lSampleSize is not 0 and fixed
	    ppOutCmt[i]->bTemporalCompression	    =0; 
	    ppOutCmt[i]->formattype		    =FORMAT_WaveFormatEx;
	}
    }

    DVAudInfo tmpDVAudInfo;

    //build pwfx
    hr=BuildDVAudInfo(pDVInfo, ppwfx, &tmpDVAudInfo);

    for(int i=1; i >= tmpDVAudInfo.bNumAudPin; i--)
    {
        // Since ppwfx[i] is not initialized, undo our initialization
        // Without this, we were relying on an uninitialized value of
        // nChannels to cause connections to the audio pin to be rejected,
        // e.g., see the call to this function from CDVSpInputPin::CheckMediaType
        // and from CDVSpOutputPin::GetMediaType

        if(ppOutCmt[i] !=NULL)
	{   
	    ppOutCmt[i]->majortype		    =GUID_NULL;
	    ppOutCmt[i]->subtype		    =GUID_NULL; 
	    ppOutCmt[i]->formattype		    =GUID_NULL;
	}
    }

    return hr;
}

//build outpin's media type according to input pin's media type
HRESULT BuildVidCMT(DVINFO *pDvinfo, CMediaType *pOutCmt)
{
    if( pDvinfo ==NULL )
	return E_OUTOFMEMORY;

    pOutCmt->majortype	    =MEDIATYPE_Video; 
    pOutCmt->subtype	    =MEDIASUBTYPE_dvsd;
    pOutCmt->formattype     =FORMAT_VideoInfo;
    pOutCmt->cbFormat	    =0;

    VIDEOINFO *pVideoInfo;
    pVideoInfo = (VIDEOINFO *)pOutCmt->Format();
    if(pVideoInfo==NULL)
    {
	pVideoInfo = (VIDEOINFO *)pOutCmt->ReallocFormatBuffer(SIZE_VIDEOHEADER);
	pOutCmt->cbFormat = SIZE_VIDEOHEADER;
    }
    else if(  pOutCmt->cbFormat != SIZE_VIDEOHEADER )
    {
	ASSERT( pDvinfo !=NULL);
	ASSERT( pVideoInfo != NULL);
	ASSERT( pOutCmt->cbFormat == SIZE_VIDEOHEADER);
	return E_UNEXPECTED;
    }

    //dvdec does not use this information yet.  3-28-97
    LPBITMAPINFOHEADER lpbi	= HEADER(pVideoInfo);
    lpbi->biSize		= sizeof(BITMAPINFOHEADER);

    if( ! ( ( pDvinfo->dwDVVAuxSrc & AUDIO5060 ) >> 21 )  )
    {  
	//525_60
	lpbi->biHeight		    = 480;
	pVideoInfo->AvgTimePerFrame = UNITS*1000L/29970L;
    }
    else
    {
	lpbi->biHeight		    = 576;
	pVideoInfo->AvgTimePerFrame = UNITS/25;
    }


    lpbi->biWidth		= 720;	
    lpbi->biPlanes		= 1;
    lpbi->biBitCount		= 24;
    lpbi->biXPelsPerMeter	= 0;
    lpbi->biYPelsPerMeter	= 0;
    lpbi->biCompression		= FCC('dvsd');
    lpbi->biSizeImage		=(lpbi->biHeight== 480 )? 120000:144000; //GetBitmapSize(lpbi);
    lpbi->biClrUsed		= 0;
    lpbi->biClrImportant	= 0;
    pVideoInfo->rcSource.top	= 0;
    pVideoInfo->rcSource.left	= 0;
    pVideoInfo->rcSource.right	= lpbi->biWidth;			
    pVideoInfo->rcSource.bottom = lpbi->biHeight;			
    
    pVideoInfo->rcTarget	= pVideoInfo->rcSource;
    LARGE_INTEGER li;
    li.QuadPart			= pVideoInfo->AvgTimePerFrame;
    pVideoInfo->dwBitRate	= MulDiv(lpbi->biSizeImage, 80000000, li.LowPart);
    pVideoInfo->dwBitErrorRate	= 0L;

    return NOERROR;
}


CDVPosPassThru::CDVPosPassThru(const TCHAR *pName,
			   LPUNKNOWN pUnk,
			   HRESULT *phr,
			   IPin *pPin,
			   CDVSp *pDVSp) 
    : CPosPassThru(pName,pUnk, phr,pPin),
      m_pPasDVSp (pDVSp)
{}
//----------------------------------------------------------------------------
// CDVSpOutputPin destructor
//----------------------------------------------------------------------------
CDVPosPassThru::~CDVPosPassThru ()
{
}


STDMETHODIMP
CDVPosPassThru::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
	return CPosPassThru::SetPositions(pCurrent, CurrentFlags, pStop, StopFlags);

    // EHR: what was this code? (Danny says this will make us laugh someday)
    //
    if (InterlockedExchange (&m_pPasDVSp->m_lCanSeek, FALSE) == FALSE)
	return CPosPassThru::SetPositions(pCurrent, CurrentFlags, pStop, StopFlags);
    else
       return S_OK ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvsp\dvsp.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


#ifndef __DVSP__
#define __DVSP__

#include <dv.h>

extern const AMOVIESETUP_FILTER sudDVSplit;


#define SMCHN		0x0000e000
#define AUDIOMODE	0x00000f00
#define AUDIO5060	0x00200000
#define AUDIOSMP	0x38000000
#define AUDIOQU		0x07000000
#define	NTSC525_60	0
#define	PAL625_50	1

#define DVSP_INPIN		0
#define DVSP_VIDOUTPIN	1
#define DVSP_AUDOUTPIN1 2
#define DVSP_AUDOUTPIN2 3

#define VIDEO_OUTPIN	0
#define AUDIO_OUTPIN1	1
#define AUDIO_OUTPIN2	2

//----------------------------------------------------------------------------
// forward reference to classes defined later
//----------------------------------------------------------------------------

class CDVSp ;
class CDVSpOutputPin ;

//----------------------------------------------------------------------------
// CDVspInputPin. class for the DVSpliter filter's Input pin.
//----------------------------------------------------------------------------
class CDVSpInputPin : public CBaseInputPin
{
    friend class CDVSpOutputPin ;
    friend class CDVSp ;

public:
    // constructor and destructor
    CDVSpInputPin (TCHAR *pObjName, CDVSp *pDVsp, HRESULT *phr, LPCWSTR pPinName) ;
    ~CDVSpInputPin () ;

    // Used to check the input pin connection
    HRESULT CheckMediaType (const CMediaType *pmt) ;
    HRESULT SetMediaType (const CMediaType *pmt) ;
    HRESULT BreakConnect () ;
    STDMETHODIMP NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop,
                    					double dRate);
    // reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
    STDMETHODIMP NotifyAllocator (IMemAllocator *pAllocator, BOOL bReadOnly);

    // pass throughs
    STDMETHODIMP EndOfStream () ;
    STDMETHODIMP BeginFlush () ;
    STDMETHODIMP EndFlush () ;

    // handles the next block of data from the stream
    STDMETHODIMP Receive (IMediaSample *pSample) ;

   	
private:
    void  DetectChanges(IMediaSample *pSample);
    CDVSp *m_pDVSp ;                 // ptr to the owner filter class
    BOOL m_bDroppedLastFrame;

} ;


//----------------------------------------------------------------------------
// CTeeOutputPin. class for the Tee filter's Output pins.
//----------------------------------------------------------------------------
class CDVSpOutputPin : public CBaseOutputPin
{
    friend class CDVSpInputPin ;
    friend class CDVSp ;

    DWORD		m_AudAvgBytesPerSec;

    CDVSp		*m_pDVSp ;                  // ptr to the owner filter class
    CPosPassThru	*m_pPosition ;     // pass seek calls upstream
    BOOL		m_bHoldsSeek ;             // is this the one seekable stream
    COutputQueue	*m_pOutputQueue;

public:

    // constructor and destructor
    CDVSpOutputPin (TCHAR *pObjName, 
			CDVSp *pDVSp, 
			HRESULT *phr, 
			LPCWSTR pPinName);

    ~CDVSpOutputPin () ;

    // Override to expose IMediaPosition
    STDMETHODIMP NonDelegatingQueryInterface (REFIID riid, void **ppvoid) ;

    // Override since the life time of pins and filters are not the same.
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(){
	  return CUnknown::NonDelegatingAddRef(); 
    };
    STDMETHODIMP_(ULONG) NonDelegatingRelease(){
	  return CUnknown::NonDelegatingRelease(); 
    };

    HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Check that we can support an output type
    HRESULT CheckMediaType (const CMediaType *pmt) ; 
    HRESULT SetMediaType (const CMediaType *pmt) ;
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);
    
    // Negotiation to use our input pins allocator
    HRESULT DecideAllocator (IMemInputPin *pPin, IMemAllocator **ppAlloc) ;
    HRESULT DecideBufferSize (IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Used to create output queue objects
    HRESULT Active () ;
    HRESULT Inactive () ;

    
    inline DWORD GetAudAvgBytesPerSec(){return m_AudAvgBytesPerSec; };
    inline void  PutAudAvgBytesPerSec(DWORD x){ m_AudAvgBytesPerSec=x;};
};

//----------------------------------------------------------------------------
// CDVSp. class for the DV splitter filter
//----------------------------------------------------------------------------

class CDVSp: public CCritSec, public CBaseFilter, public IDVSplitter
{
    // let the pins access our internal state.
    friend class CDVSpInputPin ;
    friend class CDVSpOutputPin ;
    friend class CDVPosPassThru ;

public:
    CDVSp (TCHAR *pName, LPUNKNOWN pUnk, HRESULT *hr) ; // constructore
    ~CDVSp() ;						// destructor

    // CBaseFilter override
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

    /*  Send EndOfStream downstream */
    void    EndOfStream();

    /*  Send BeginFlush() downstream */
    HRESULT BeginFlush();

    /*  Send EndFlush() downstream */
    HRESULT EndFlush();


    CBasePin *GetPin (int n) ;                         // gets a pin ptr
    //CDVSpOutputPin	*GetPin (int n) ;
    int GetPinCount () ;                               // rets # pins.


    // function needed for the class factory
    static CUnknown *CreateInstance (LPUNKNOWN pUnk, HRESULT *phr) ;

    HRESULT NotifyInputConnected();
    HRESULT CreateOrReconnectOutputPins();
    HRESULT RemoveOutputPins();
   
    HRESULT DeliveVideo(IMediaSample *pSample); 
    HRESULT DecodeDeliveAudio(IMediaSample *pSample); 
    HRESULT DescrambleAudio(BYTE *pDst, BYTE *pSrc, BYTE bAudPinInd, WORD wSampleSize);
    HRESULT CheckState();
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *pfs);

public:
    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // IDVSplitter method
    STDMETHODIMP DiscardAlternateVideoFrames(int nDiscard);

protected:

   
    HRESULT InsertSilence(IMediaSample *pOutSample,
                                REFERENCE_TIME rtStart,
                                REFERENCE_TIME rtStop,
                                long lActualDataLen,
                                CDVSpOutputPin *pAudOutPin);

    // Flag to denote that we haven't seen the first good frame yet.
    // this to help capture scenario involving AVI Mux (which doesn't handle dynamic format changes)
    BOOL            m_bNotSeenFirstValidFrameFlag;

    // This flag will propogate a Media type downstream even if we were stopped
    // during the middle of a dynamic format change.
    BOOL            m_bFirstValidSampleSinceStartedStreaming;

private:
    CCritSec    m_csReceive;

    // declare a input pin.
    CDVSpInputPin	m_Input ;

    DVINFO		m_LastInputFormat;

    DVAudInfo		m_sDVAudInfo;

    // declare a list to keep a list of all the output pins.
    INT m_NumOutputPins ;
    INT m_AudioStarted ;
    inline void CleanAudioStarted(){ m_AudioStarted=0;};
    //inline CDVSpOutputPin *CDVSp::GetAudOutputPin();
    typedef CGenericList <CDVSpOutputPin> COutputList ;
    //COutputList m_OutputPinsList ;
    INT m_NextOutputPinNumber ;     // increases monotonically.

    // other assorted data members.
    volatile LONG	    m_lCanSeek ;               // seekable output pin (only one is..)
    IMemAllocator   *m_pAllocator ;   // Allocator from our input pin

   
    //X* for quick delive audio and video
    CDVSpOutputPin  *m_pVidOutputPin;
    CDVSpOutputPin  *m_pAudOutputPin[2];
    
    //HRESULT	    DeliveLastAudio();
    IMediaSample    *m_pAudOutSample[2];
    BYTE	    m_MuteAud[2];
    BYTE	    m_Mute1stAud[2];
    //X* de-scramble audio sample stamp
    CRefTime	    m_tStopPrev;

    // To support a video output of 15 fps
    BOOL m_b15FramesPerSec;
    BOOL m_bDeliverNextFrame;
} ;

//----------------------------------------------------------------------------
// CDVPosPassThru
//----------------------------------------------------------------------------
class CDVPosPassThru : public CPosPassThru
{
    friend class CDVSp ;
    CDVSp	*m_pPasDVSp ;                  // ptr to the owner filter class
    
public:
    CDVPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *, CDVSp *);
    ~CDVPosPassThru() ;											// destructor
    STDMETHODIMP SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags
			     , LONGLONG * pStop,  DWORD StopFlags );
};

#endif // DVST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dvdgb3\dvdgb.cpp ===
// Copyright (c) 1994 - 2000  Microsoft Corporation.  All Rights Reserved.

#include <streams.h>
#include <vfwmsgs.h>

#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include <dvdmedia.h>
#include <IL21Dec.h>
#include "dvdgb.h"
#include "..\image2\inc\vmrp.h"

// setup data

#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    { L"DVD Graph Builder"
        , &CLSID_DvdGraphBuilder
        , CDvdGraphBuilder::CreateInstance
        , NULL
        , NULL }    // self-registering info
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}
#endif



CDvdGraphBuilder::CDvdGraphBuilder(TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr)
: CUnknown(pName, pUnk),
m_pGB(NULL),
m_pMapper(NULL),
m_ListFilters(20, 10),
m_ListHWDecs(10, 10),
m_pDVDNav(NULL),
m_pOvM(NULL),
m_pAR(NULL),
m_pVR(NULL),
m_pVMR(NULL),
m_pVPM(NULL),
m_pL21Dec(NULL),
m_bGraphDone(FALSE),
m_bUseVPE(TRUE),
m_bPinNotRendered(FALSE),
m_bDDrawExclMode(FALSE),
m_bTryVMR(TRUE)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::CDvdGraphBuilder()"))) ;

    *phr = CreateGraph() ;
}


CDvdGraphBuilder::~CDvdGraphBuilder(void)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::~CDvdGraphBuilder() entering"))) ;

    // If we have a graph object
    if (m_pGB)
    {
        StopGraph() ;  // make sure the graph is REALYY stopped

        // Break the connections and remove all the filters we added from the graph
        ClearGraph() ;

        // Remove and release OverlayMixer now, if it was there
        if (m_pOvM)
        {
            EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pOvM))) ;
            m_pOvM->Release() ;
            m_pOvM = NULL ;
        }

        // Remove and release VMR, if it was there
        if (m_pVMR)
        {
            EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pVMR))) ;
            m_pVMR->Release() ;
            m_pVMR = NULL ;
        }

        m_pGB->Release() ;  // free it
        m_pGB = NULL ;
    }

    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::~CDvdGraphBuilder() ending"))) ;
}


// this goes in the factory template table to create new instances
CUnknown * CDvdGraphBuilder::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CDvdGraphBuilder(TEXT("DVD Graph Builder II"), pUnk, phr) ;
}


STDMETHODIMP CDvdGraphBuilder::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::NonDelegatingQueryInterface()"))) ;
    if (ppv)
        *ppv = NULL;

    if (riid == IID_IDvdGraphBuilder)
    {
        DbgLog((LOG_TRACE, 5, TEXT("QI for IDvdGraphBuilder"))) ;
        return GetInterface((IDvdGraphBuilder *) this, ppv) ;
    }
    else // more interfaces
    {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv) ;
    }
}


// -----------------------------
//  IDvdGraphBuilder stuff ....
// -----------------------------

//
// What filtergraph is graph building being done in?
//
HRESULT CDvdGraphBuilder::GetFiltergraph(IGraphBuilder **ppGB)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetFiltergraph(0x%lx)"), ppGB)) ;

    if (ppGB == NULL)
        return E_POINTER ;

    EnsureGraphExists() ;

    *ppGB = m_pGB ;
    if (NULL == m_pGB)
    {
        return E_UNEXPECTED ;
    }
    m_pGB->AddRef() ;   // app owns a copy now
    return NOERROR ;
}

DEFINE_GUID(IID_IDDrawNonExclModeVideo,
            0xec70205c, 0x45a3, 0x4400, 0xa3, 0x65, 0xc4, 0x47, 0x65, 0x78, 0x45, 0xc7) ;

DEFINE_GUID(IID_IAMSpecifyDDrawConnectionDevice,
            0xc5265dba, 0x3de3, 0x4919, 0x94, 0x0b, 0x5a, 0xc6, 0x61, 0xc8, 0x2e, 0xf4) ;

//
// Get a specified interface off of a filter in the DVD playback graph
//
HRESULT CDvdGraphBuilder::GetDvdInterface(REFIID riid, void **ppvIF)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetDvdInterface(%s, 0x%lx)"),
        (LPCTSTR)CDisp(riid), ppvIF)) ;

    HRESULT  hr ;

    if (IsBadWritePtr(ppvIF, sizeof(LPVOID)))
        return E_INVALIDARG ;
    *ppvIF =  NULL ;

    // We should be able to provide the IDDrawExclModeVideo interface even
    // before the graph is built so that apps can specify their own DDraw
    // params to be used by OvMixer to build the graph.
    if (IID_IDDrawExclModeVideo == riid ||
        IID_IDDrawNonExclModeVideo == riid ||
        IID_IAMSpecifyDDrawConnectionDevice == riid)
    {
        if (NULL == m_pVMR)  // if we are already NOT using VMR
        {
            hr = EnsureOverlayMixerExists() ;
            ASSERT(SUCCEEDED(hr) && m_pOvM) ;
            if (SUCCEEDED(hr)  &&  m_pOvM)
            {
                SetVMRUse(FALSE) ;  // can't use VMR anymore
                return m_pOvM->QueryInterface(riid, (LPVOID *)ppvIF) ;
            }
        }
        return E_NOINTERFACE ;
    }

    // We should be able to provide the IVMR* interfaces even before the graph
    // is built so that apps can specify their own rendering settings to be
    // used by VMR whille building the graph.
    if (IID_IVMRMixerBitmap       == riid ||
        IID_IVMRFilterConfig      == riid ||
        IID_IVMRWindowlessControl == riid ||
        IID_IVMRMonitorConfig     == riid)
    {
        if (NULL == m_pOvM)  // if we are already NOT using OvMixer
        {
            hr = EnsureVMRExists() ;
            ASSERT(SUCCEEDED(hr) && m_pVMR) ;
            if (SUCCEEDED(hr)  &&  m_pVMR)
            {
                // SetVMRUse(TRUE) ;  // should try to use VMR for sure
                return m_pVMR->QueryInterface(riid, (LPVOID *)ppvIF) ;
            }
        }
        return E_NOINTERFACE ;
    }

    // We don't return IVMRPinConfig pointer.  If needed the app can get the
    // VMR interface and get the pin config interface for the needed pin.

    // We can't return ANY OTHER internal filter interface pointers before
    // building the whole graph.
    if (! m_bGraphDone )
        return VFW_E_DVD_GRAPHNOTREADY ;

    if (IID_IDvdControl == riid)
    {
        return m_pDVDNav->QueryInterface(IID_IDvdControl, (LPVOID *)ppvIF) ;
    }
    else if (IID_IDvdControl2 == riid)
    {
        return m_pDVDNav->QueryInterface(IID_IDvdControl2, (LPVOID *)ppvIF) ;
    }
    else if (IID_IDvdInfo == riid)
    {
        return m_pDVDNav->QueryInterface(IID_IDvdInfo, (LPVOID *)ppvIF) ;
    }
    else if (IID_IDvdInfo2 == riid)
    {
        return m_pDVDNav->QueryInterface(IID_IDvdInfo2, (LPVOID *)ppvIF) ;
    }
    else if (IID_IVideoWindow == riid)
    {
        if (m_pVR || m_pVMR)
            return m_pGB->QueryInterface(IID_IVideoWindow, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IBasicVideo == riid)
    {
        if (m_pVR)
            return m_pVR->QueryInterface(IID_IBasicVideo, (LPVOID *)ppvIF) ;
        else if (m_pVMR)
            return m_pVMR->QueryInterface(IID_IBasicVideo, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IBasicAudio == riid)
    {
        return m_pGB->QueryInterface(IID_IBasicAudio, (LPVOID *)ppvIF) ;
    }
    else if (IID_IAMLine21Decoder == riid)
    {
        if (m_pL21Dec)
            return m_pL21Dec->QueryInterface(IID_IAMLine21Decoder, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IMixerPinConfig == riid  ||  IID_IMixerPinConfig2 == riid)
    {
        // First check if VMR is already being used.  In that case we don't use
        // OvMixer, and hence no such interface.
        if (m_pVMR)
        {
            DbgLog((LOG_TRACE, 3, TEXT("VMR being used. Can't get IMixerPinConfig(2)."))) ;
            return E_NOINTERFACE ;
        }

        // In all likelihood, this app wants to use the OvMixer. So we'll go on
        // that path (create OvMixer, if it's not there) and return the interface.
        *ppvIF = NULL ;  // initially
        hr = EnsureOverlayMixerExists() ;
        ASSERT(SUCCEEDED(hr) && m_pOvM) ;
        if (SUCCEEDED(hr)  &&  m_pOvM)
        {
            IEnumPins     *pEnumPins ;
            IPin          *pPin = NULL ;
            PIN_DIRECTION  pd ;
            ULONG          ul ;
            hr = m_pOvM->EnumPins(&pEnumPins) ;
            ASSERT(SUCCEEDED(hr) && pEnumPins) ;
            // Get the 1st input pin
            while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
            {
                pPin->QueryDirection(&pd) ;
                if (PINDIR_INPUT == pd)
                {
                    hr = pPin->QueryInterface(riid, (LPVOID *)ppvIF) ;
                    pPin->Release() ;
                    break ;  // we got it
                }
                pPin->Release() ;
            }
            pEnumPins->Release() ;  // release before returning
            if (*ppvIF)
                return S_OK ;
        }
        return E_NOINTERFACE ;
    }
    else
        return E_NOINTERFACE ;
}


//
// Build the whole graph for playing back the specifed or default DVD volume
//
HRESULT CDvdGraphBuilder::RenderDvdVideoVolume(LPCWSTR lpcwszPathName, DWORD dwFlags,
                                               AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::RenderDvdVideoVolume(0x%lx, 0x%lx, 0x%lx)"),
        lpcwszPathName, dwFlags, pStatus)) ;

    HRESULT    hr ;

    hr = EnsureGraphExists() ;  // make sure that a graph exists; if not create one
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't create a filter graph object"))) ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    if (m_bGraphDone)  // if graph was built before,
        StopGraph() ;  // just make sure the graph is in Stopped state first

    ClearGraph() ;
    m_bPinNotRendered = FALSE ;  // reset the flag

    ZeroMemory(pStatus, sizeof(AM_DVD_RENDERSTATUS)) ;  // clear status
    m_bUseVPE = (0 == (dwFlags & AM_DVD_NOVPE)) ;       // is VPE needed?
    DbgLog((LOG_TRACE, 3, TEXT("Flag: VPE is '%s'"), m_bUseVPE ? "On" : "Off")) ;
    dwFlags &= DVDGRAPH_FLAGSVALIDDEC ;                 // mask off the VPE flag now

    if (0 == dwFlags) // 0 by default means HW max
    {
        DbgLog((LOG_TRACE, 3, TEXT("dwFlags specified as 0x%lx; added .._HWDEC_PREFER"), dwFlags)) ;
        dwFlags |= AM_DVD_HWDEC_PREFER ;  // use HW Decs maxm
    }

    if (AM_DVD_HWDEC_PREFER != dwFlags && AM_DVD_HWDEC_ONLY != dwFlags &&
        AM_DVD_SWDEC_PREFER != dwFlags && AM_DVD_SWDEC_ONLY != dwFlags)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Invalid dwFlags (0x%lx) specified "), dwFlags)) ;
        return E_INVALIDARG ;
    }

    HRESULT    hrFinal = S_OK ;

    m_ListFilters.SetGraph(m_pGB) ;  // specify graph in which all filters will be added

    CheckDDrawExclMode() ;   // check if we are building for DDraw exclusive mode

    // If we are in DDraw (non-)exclusive mode, we are supposed to use only
    // the OvMixer, and not the VMR.  We update the flag here and check it in
    // the stream render functions.
    SetVMRUse(GetVMRUse() && !IsDDrawExclMode()) ;

    //
    // Instantiate DVD Nav filter first
    //
    hr = CreateFilterInGraph(CLSID_DVDNavigator, L"DVD Navigator", &m_pDVDNav) ;
    if (FAILED(hr)  ||  NULL == m_pDVDNav)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: DVD Nav couldn't be instantiated (Error 0x%lx)"), hr)) ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    //
    // If .._SWDEC_ONLY flag was NOT specified, instantiate all the useful HW
    // decoders and maintain a list.
    //
    if (AM_DVD_SWDEC_ONLY != dwFlags)
    {
        DbgLog((LOG_TRACE, 5, TEXT(".._SWDEC_ONLY flag has NOT been specified. Enum-ing HW dec filters..."))) ;
        hr = CreateDVDHWDecoders() ;
        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE, 5, TEXT("HW DVD decoder enumeration failed (Error 0x%lx)"), hr)) ;
        }
    }

    // Create filter mapper here to use it in the following calls
    hr = CoCreateInstance(CLSID_FilterMapper, NULL, CLSCTX_INPROC,
        IID_IFilterMapper, (LPVOID *)&m_pMapper) ;
    ASSERT(SUCCEEDED(hr)  &&  m_pMapper) ;

    // First render the video stream
    hr = RenderNavVideoOutPin(dwFlags, pStatus) ;
    if (S_OK != hr)   // everything isn't good
    {
        //
        //  Video stream rendering also includes line21 rendering.  If that
        //  fails due to any reason, including the reason that video decoder
        //  doesn't have a line21 output pin, we don't want to mark it as a
        //  video stream rendering failure.  The line21 rendering failure
        //  flags are set deep inside. We set the video decode/render failure
        //  flags also in the video decode/rendering code. We just downgrade
        //  the overall result here.
        //
        DbgLog((LOG_TRACE, 3, TEXT("Something wrong with video stream rendering"))) ;
        if (SUCCEEDED(hrFinal))  // was perfect so far
        {
            DbgLog((LOG_TRACE, 3, TEXT("Overall result downgraded from 0x%lx to 0x%lx"), hrFinal, hr)) ;
            hrFinal = hr ;
        }
    }

    // Then render the subpicture stream
    hr = RenderNavSubpicOutPin(dwFlags, pStatus) ;
    if (S_OK != hr)
    {
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_SUBPIC ;
        if (SUCCEEDED(hrFinal))  // was perfect so far
        {
            DbgLog((LOG_TRACE, 3, TEXT("Overall result downgraded from 0x%lx to 0x%lx"), hrFinal, hr)) ;
            hrFinal = hr ;
        }
    }

    // And then render the audio stream
    hr = RenderNavAudioOutPin(dwFlags, pStatus) ;
    if (S_OK != hr)
    {
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_AUDIO ;
        if (SUCCEEDED(hrFinal))  // was perfect so far
        {
            DbgLog((LOG_TRACE, 3, TEXT("Overall result downgraded from 0x%lx to 0x%lx"), hrFinal, hr)) ;
            hrFinal = hr ;
        }
    }
    DbgLog((LOG_TRACE, 5, TEXT("Setting number of DVD streams to 3"))) ;
    pStatus->iNumStreams = 3 ;  // so far 3 DVD streams

    //
    // In case any output pin was not rendered because we had more than one decoded
    // output pin for one stream, we try to locate that pin and render it as a last
    // ditch effort.
    //
    if (m_bPinNotRendered)
    {
        hr = RenderRemainingPins() ;
        if (S_OK != hr)  // some problem in rendering
        {
            if (SUCCEEDED(hrFinal))  // was perfect so far
            {
                DbgLog((LOG_TRACE, 3, TEXT("Overall result downgraded from 0x%lx to 0x%lx"), hrFinal, hr)) ;
                hrFinal = hr ;
            }
        }
    }

    //
    // Now render any additional streams, e.g, the ASF stream, if any.
    //
    // Currently does NOT do anything.
    //
    hr = RenderNavASFOutPin(dwFlags, pStatus) ;
    ASSERT(SUCCEEDED(hr)) ;
    hr = RenderNavOtherOutPin(dwFlags, pStatus) ;
    ASSERT(SUCCEEDED(hr)) ;

    // Done with the filter mapper. Let it go now.
    m_pMapper->Release() ;
    m_pMapper = NULL ;

    m_ListHWDecs.ClearList() ;  // don't need the extra HW filters anymore

    if (pStatus->iNumStreamsFailed >= pStatus->iNumStreams)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Failed to render %d out of %d main DVD streams (Error 0x%lx)"),
            pStatus->iNumStreamsFailed, pStatus->iNumStreams, hrFinal)) ;
        return VFW_E_DVD_DECNOTENOUGH;  // VFW_E_DVD_RENDERFAIL ;
    }

    if (FAILED(hrFinal))
    {
        DbgLog((LOG_TRACE, 1, TEXT("DVD graph building failed with error 0x%lx"),
            hrFinal)) ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    //
    // Set the specified root file name/DVD volume name (even NULL because
    // that causes the DVD Nav to search for one)
    //
    IDvdControl  *pDvdC ;
    hr = m_pDVDNav->QueryInterface(IID_IDvdControl, (LPVOID *)&pDvdC) ;
    if (FAILED(hr) || NULL == pDvdC)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get IDvdControl interface (Error 0x%lx)"), hr)) ;
        return hr ;
    }

    //
    // Set the specified DVD volume path
    //
    // Does the SetRoot() function handle the NULL properly?
    //
    hr = pDvdC->SetRoot(lpcwszPathName) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 2,
            TEXT("IDvdControl::SetRoot(%S) call couldn't use specified volume (Error 0x%lx)"),
            lpcwszPathName ? L"NULL" : lpcwszPathName, hr)) ;
        if (lpcwszPathName)
            pStatus->bDvdVolInvalid = TRUE ;
        else
            pStatus->bDvdVolUnknown = TRUE ;
        if (SUCCEEDED(hrFinal))  // if we were so far perfect, ...
            hrFinal = S_FALSE ;  // ...we aren't so anymore
    }

    pDvdC->Release() ;  // done with this interface

    // Only if we haven't entirely failed, set the graph built flag and
    // return overall result.
    if (SUCCEEDED(hrFinal))
        m_bGraphDone = TRUE ;

    m_bPinNotRendered = FALSE ;  // should reset on success too

    return hrFinal ;
}


//    private: internal helper methods

//
// Make sure a filter graph has been created; if not create one here
//
HRESULT CDvdGraphBuilder::EnsureGraphExists(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnsureGraphExists()"))) ;

    if (m_pGB)
        return S_OK ;

    return CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
        IID_IGraphBuilder, (LPVOID *)&m_pGB) ;
}



//
// Make sure OverlayMixer has been created; if not create one here.
//
HRESULT CDvdGraphBuilder::EnsureOverlayMixerExists(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnsureOverlayMixerExists()"))) ;

    if (m_pOvM)
        return S_OK ;

    return CreateFilterInGraph(CLSID_OverlayMixer, L"Overlay Mixer", &m_pOvM) ;
}


//
// Make sure VMR has already been created; if not create one here.
//
HRESULT CDvdGraphBuilder::EnsureVMRExists(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnsureVMRExists()"))) ;

    if (m_pVMR)
        return S_OK ;

    HRESULT  hr ;
    hr = CreateFilterInGraph(CLSID_VideoMixingRenderer, L"Video Mixing Renderer", &m_pVMR) ;
    ASSERT(m_pVMR) ;
    if (SUCCEEDED(hr))
    {
        IVMRFilterConfigInternal* pVMRConfigInternal;

        hr = m_pVMR->QueryInterface(IID_IVMRFilterConfigInternal, (void **) &pVMRConfigInternal);
        if( SUCCEEDED( hr )) {
            pVMRConfigInternal->SetAspectRatioModePrivate( VMR_ARMODE_LETTER_BOX );
            pVMRConfigInternal->Release();
        }

        // Create three in pins for VMR
        hr = CreateVMRInputPins() ;
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't ensure VMR's 3 in pins"))) ;
            SetVMRUse(FALSE) ;  // we shouldn't use VMR as it cannot go into mixing mode.
            // Should we return some error code to help the app indicate this to the user??
            hr = S_FALSE ;  // a little problem at least
        }
    }

    return hr ;
}


#define ATI_VENDOR_CODE                     0x1002

#define ATI_RAGE_PRO_DEVICE_CODE            0X4742
#define ATI_RAGE_MOBILITY_DEVICE_CODE       0x4C4D

#define INTEL_VENDOR_CODE                   0x8086
#define INTEL_810_DEVICE_CODE_1             0x1132
#define INTEL_810_DEVICE_CODE_2             0x7121
#define INTEL_810_DEVICE_CODE_3             0x7123
#define INTEL_810_DEVICE_CODE_4             0x7125


const GUID  OUR_IID_IDirectDraw7 =
{
    0x15e65ec0, 0x3b9c, 0x11d2,
    {
        0xb9, 0x2f, 0x00, 0x60, 0x97, 0x97, 0xea, 0x5b
    }
};

HRESULT CheckVGADriverIsVMRFriendly(
    IBaseFilter* pVMR
    )
{
    IVMRMonitorConfig* pMon;
    if (S_OK != pVMR->QueryInterface(IID_IVMRMonitorConfig, (LPVOID*)&pMon)) {
        return E_FAIL;
    }

    const DWORD dwMAX_MONITORS = 8;
    VMRMONITORINFO mi[dwMAX_MONITORS];
    DWORD dwNumMonitors;


    //
    // Get information about all the monitors in the system.
    //

    if (S_OK != pMon->GetAvailableMonitors(mi, dwMAX_MONITORS, &dwNumMonitors)) {
        pMon->Release();
        return E_FAIL;
    }


    //
    // Get the current monitors GUID.
    //

    VMRGUID gu;
    HRESULT hr = pMon->GetMonitor(&gu);
    pMon->Release();
    if (S_OK != hr) {
        return E_FAIL;
    }


    //
    // Search for the current monitor in the array of available monitors
    //

    VMRMONITORINFO* pmi = &mi[0];
    for (DWORD i = 0; i < dwNumMonitors; i++, pmi++) {

        if (gu.pGUID == NULL && pmi->guid.pGUID == NULL) {
            break;
        }

        if (gu.pGUID != NULL && pmi->guid.pGUID != NULL) {
            if (gu.GUID == pmi->guid.GUID) {
                break;
            }
        }
    }


    //
    // Make sure we found a monitor - we should always find a monitor!
    //

    if (i == dwNumMonitors) {

        return E_FAIL;
    }


    //
    // ATi chip sets that don't work with the VMR for DVD playback.
    //
    if (pmi->dwVendorId == ATI_VENDOR_CODE)
    {
        switch(pmi->dwDeviceId) {
        case ATI_RAGE_PRO_DEVICE_CODE:
            return E_FAIL;

        case ATI_RAGE_MOBILITY_DEVICE_CODE:
            {
                IVMRMixerControl* lpMixControl = NULL;
                hr = pVMR->QueryInterface(IID_IVMRMixerControl, (LPVOID*)&lpMixControl);
                if (SUCCEEDED(hr)) {
                    DWORD dw;
                    hr = lpMixControl->GetMixingPrefs(&dw);
                    if (SUCCEEDED(hr)) {
                        dw &= ~ MixerPref_FilteringMask;
                        dw |= MixerPref_PointFiltering;
                        hr = lpMixControl->SetMixingPrefs(dw);
                    }
                    lpMixControl->Release();
                }

            }
            break;
        }
    }


    //
    // Intel chip sets that don't work well with the VMR for DVD playback.
    // These chipsets do work but the VMR needs to be configured correctly
    // to get the best perf form the chipset.
    //

    else if (pmi->dwVendorId == INTEL_VENDOR_CODE)
    {
        switch(pmi->dwDeviceId) {
        case INTEL_810_DEVICE_CODE_1:
        case INTEL_810_DEVICE_CODE_2:
        case INTEL_810_DEVICE_CODE_3:
        case INTEL_810_DEVICE_CODE_4:
            {
                //
                // We should check the processor speed before
                // using the VMR - we need at least 500MHz for
                // good quality playback.
                //

                IVMRMixerControl* lpMixControl = NULL;
                hr = pVMR->QueryInterface(IID_IVMRMixerControl, (LPVOID*)&lpMixControl);
                if (SUCCEEDED(hr)) {
                    DWORD dw;
                    hr = lpMixControl->GetMixingPrefs(&dw);
                    if (SUCCEEDED(hr)) {
                        dw &= ~ MixerPref_RenderTargetMask;
                        dw |= MixerPref_RenderTargetIntelIMC3;
                        hr = lpMixControl->SetMixingPrefs(dw);
                    }
                    lpMixControl->Release();
                }
            }
            break;
        }
    }

    return S_OK;
}

//
// Make sure VMR has at least 3 in pins.
//
HRESULT CDvdGraphBuilder::CreateVMRInputPins(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateVMRInputPins()"))) ;

    if (NULL == m_pVMR)
        return E_UNEXPECTED ;

    // Create three (3) in pins for the VMR so that it can accommodate video,
    // SP and CC streams coming in. By default VMR has only one in pin.
    HRESULT  hr ;
    IVMRFilterConfig  *pVMRConfig ;
    hr = m_pVMR->QueryInterface(IID_IVMRFilterConfig, (LPVOID *) &pVMRConfig) ;
    if (SUCCEEDED(hr))
    {
        DWORD  dwStreams = 0 ;
        pVMRConfig->GetNumberOfStreams(&dwStreams) ;
        if (dwStreams < 3)  // if not enough in pins...
        {
            hr = pVMRConfig->SetNumberOfStreams(3) ;
            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE, 3, TEXT("Couldn't create 3 in pins for VMR"))) ;
                hr = E_FAIL ;  // This is possible now. We need to turn off VMR use...
            }
        }
        pVMRConfig->Release() ;

        if (SUCCEEDED(hr)) {
            hr = CheckVGADriverIsVMRFriendly(m_pVMR);
            if (FAILED(hr)) {
                 DbgLog((LOG_TRACE, 3, TEXT("This VGA driver is not compatible with the VMR"))) ;
                 hr = E_FAIL ;  // This is not possible now. We need to turn off VMR use...
            }
        }
    }
    else
    {
        ASSERT(pVMRConfig) ;
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't get IVMRFilterConfig from VMR!!!"))) ;
        hr = S_FALSE ;  // a little problem at least
    }

    return hr ;
}


//
// Create a fresh filter graph
//
HRESULT CDvdGraphBuilder::CreateGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateGraph()"))) ;

    return CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
        IID_IGraphBuilder, (LPVOID *)&m_pGB) ;
}


//
// Delete the existing filter graph's contents
//
HRESULT CDvdGraphBuilder::DeleteGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::DeleteGraph()"))) ;

    m_pGB->Release() ;
    m_pGB = NULL ;
    return NOERROR ;
}


//
// Clear all the existing filters from the graph
//
HRESULT CDvdGraphBuilder::ClearGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ClearGraph()"))) ;

    // Just paranoia...
    if (NULL == m_pGB)
    {
        ASSERT(FALSE) ;  // so that we know
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: How are we Clearing w/o a graph???"))) ;
        return E_FAIL ;
    }

    // If by any chance, the filter mapper object remained, delete it now
    if (m_pMapper)
    {
        m_pMapper->Release() ;
        m_pMapper = NULL ;
    }

#pragma message("WARNING: Should we remove the decoder filters first?")
    // Remove all filters in our list from the graph
    // m_ListFilters.RemoveAllFromGraph() ;

    HRESULT     hr ;
    IEnumPins  *pEnumPins ;
    IPin       *pPin ;
    IPin       *pPin2 ;
    ULONG       ul ;

    //
    // Remove the filters we know about specifically
    //

    // We don't want to remove OvMixer -- it may have external DDraw params set.
    // Just break the connections.
    if (m_pOvM)
    {
        hr = m_pOvM->EnumPins(&pEnumPins) ;
        ASSERT(SUCCEEDED(hr) && pEnumPins) ;
        while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
        {
            hr = pPin->ConnectedTo(&pPin2) ;
            if (SUCCEEDED(hr) && pPin2)
            {
                hr = m_pGB->Disconnect(pPin) ;
                ASSERT(SUCCEEDED(hr)) ;
                hr = m_pGB->Disconnect(pPin2) ;
                ASSERT(SUCCEEDED(hr)) ;
                pPin2->Release() ;
            }
            pPin->Release() ;  // done with this pin
        }
        pEnumPins->Release() ;
    }

    if (m_pDVDNav)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pDVDNav))) ;
        m_pDVDNav->Release() ;
        m_pDVDNav = NULL ;
    }

    // We don't want to remove VMR (only), because it might have been instantiated
    // for an app when it QI-ed for a VMR interface -- just like OvMixer case.
    if (m_pVMR)
    {
        hr = m_pVMR->EnumPins(&pEnumPins) ;
        ASSERT(SUCCEEDED(hr) && pEnumPins) ;
        while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
        {
            hr = pPin->ConnectedTo(&pPin2) ;
            if (SUCCEEDED(hr) && pPin2)
            {
                hr = m_pGB->Disconnect(pPin) ;
                ASSERT(SUCCEEDED(hr)) ;
                hr = m_pGB->Disconnect(pPin2) ;
                ASSERT(SUCCEEDED(hr)) ;
                pPin2->Release() ;
            }
            pPin->Release() ;  // done with this pin
        }
        pEnumPins->Release() ;
    }
    if (m_pVPM)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pVPM))) ;
        m_pVPM->Release() ;
        m_pVPM = NULL ;
    }
    if (m_pL21Dec)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pL21Dec))) ;
        m_pL21Dec->Release() ;
        m_pL21Dec = NULL ;
    }
    if (m_pAR)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pAR))) ;
        m_pAR->Release() ;
        m_pAR = NULL ;
    }
    if (m_pVR)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pVR))) ;
        m_pVR->Release() ;
        m_pVR = NULL ;
    }

    // Remove all filters in our list from the graph
    m_ListFilters.RemoveAllFromGraph() ;

    // Enumerate any remaining filters and remove them -- make sure to skip OvMixer
    IEnumFilters  *pEnumFilters ;
    // ULONG          ul ; -- defined at the top
    IBaseFilter   *pFilter ;
    m_pGB->EnumFilters(&pEnumFilters) ;
    ASSERT(pEnumFilters) ;
    while (S_OK == pEnumFilters->Next(1, &pFilter, &ul)  &&  1 == ul)
    {
        if (m_pOvM  &&  IsEqualObject(m_pOvM, pFilter)  ||
            m_pVMR  &&  IsEqualObject(m_pVMR, pFilter))
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("Got OverlayMixer/VMR through filter enum. Not removing from graph."))) ;
        }
        else
        {
            EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(pFilter))) ;
        }
        pFilter->Release() ;   // done with this filter
    }
    pEnumFilters->Release() ;  // done enum-ing

    m_bGraphDone = FALSE ;  // reset the "graph already built" flag

    return NOERROR ;
}



void CDvdGraphBuilder::StopGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::StopGraph()"))) ;

    // Just paranoia
    if (NULL == m_pGB)
    {
        ASSERT(FALSE) ;  // so that we know
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: How are we doing a Stop w/o a graph???"))) ;
        return ;
    }

    //
    // Check that the graph has stopped; otherwise stop it here. Because a
    // playing graph can't be cleaned up or rebuilt.
    //
    IMediaControl  *pMC ;
    LONG            lState ;
    HRESULT hr = m_pGB->QueryInterface(IID_IMediaControl, (LPVOID *)&pMC) ;
    ASSERT(SUCCEEDED(hr) && pMC) ;
    pMC->GetState(INFINITE, &lState) ;
    if (State_Stopped != lState)
    {
        hr = pMC->Stop() ;
        ASSERT(SUCCEEDED(hr)) ;
        while (State_Stopped != lState)
        {
            Sleep(10) ;
            hr = pMC->GetState(INFINITE, &lState) ;
            ASSERT(SUCCEEDED(hr)) ;
        }
    }
    pMC->Release() ;
    DbgLog((LOG_TRACE, 4, TEXT("DVD-Video playback graph has stopped"))) ;
}


// 5 output pins of decoder of matching type is enough
#define MAX_DEC_OUT_PINS   5

void CDvdGraphBuilder::ResetPinInterface(IPin **apPin, int iCount)
{
    for (int i = 0 ; i < iCount ; i++)
        apPin[i] = NULL ;
}


void CDvdGraphBuilder::ReleasePinInterface(IPin **apPin)
{
    // Done with decoded video pin(s) -- release it/them
    int  i = 0 ;
    while (apPin[i])
    {
        apPin[i]->Release() ;
        i++ ;
    }
}


HRESULT CDvdGraphBuilder::RenderNavVideoOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavVideoOutPin(0x%lx, 0x%lx)"),
        dwDecFlag, pStatus)) ;

    HRESULT     hr ;
    IPin       *pPin ;
    IPin       *apPinOutDec[MAX_DEC_OUT_PINS + 1] ;  // 1 for terminating NULL

    ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ;

    hr = FindMatchingPin(m_pDVDNav, AM_DVD_STREAM_VIDEO, PINDIR_OUTPUT, TRUE, 0, &pPin) ;
    if (FAILED(hr)  ||  NULL == pPin)
    {
        DbgLog((LOG_ERROR, 1, TEXT("No open video output pin found on the DVDNav"))) ;
        return VFW_E_DVD_RENDERFAIL ;
    }
    // The dwDecFlag out param is largely ignored, except being passed as an in
    // param to the method RenderDecodedVideo() to indicate if the video is
    // decoded in HW, so that VPM is used before VMR.
    hr = DecodeDVDStream(pPin, AM_DVD_STREAM_VIDEO, &dwDecFlag, pStatus, apPinOutDec) ;
    pPin->Release() ;  // release DVDNav's video out pin

    if (FAILED(hr))   // couldn't find video decoder
    {
        DbgLog((LOG_TRACE, 1, TEXT("Could not find a decoder for video stream!!!"))) ;
        // For video stream, any decode/rendering problem has to be flagged here
        // as we just downgrade the final result in the caller, but not set any
        // flag there.
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return S_FALSE ;  // just a stream will not be rendered
    }

    //
    // Decoding the video stream succeeded. Now if we got a decoded output pin,
    // we need to render that too.
    //
    HRESULT   hrFinal = S_OK ;
    if (apPinOutDec[0])  // if video decoding is handled and we got a valid output pin
    {
        //
        // Render the decoded video stream (and line21) ONLY IF the user wants that
        //
        if (m_bUseVPE)
        {
            hr = RenderDecodedVideo(apPinOutDec, pStatus, dwDecFlag) ;
            //
            // If the above rendering attempt is successful then we'll
            // try to render the line21 output.  If the the video decoder
            // doesn't have a video output pin, then there is very little
            // chance, well no chance, of having a line21 output.
            //
            if (SUCCEEDED(hr))
            {
                //
                // The Line21 data comes out of the video decoder filter.
                // So get the filter from the above decoded video output
                // pin and then get to the line21 output pin.
                //

                //
                // We render the line21 out pin of the video decoder
                // ONLY IF we are NOT in DDraw exclusive mode.
                //
                if (IsDDrawExclMode())
                {
                    DbgLog((LOG_TRACE, 3, TEXT("*** Line21 out pin is not rendered in DDraw excl mode"))) ;
                    pStatus->bNoLine21In  = FALSE ;  // no problem with line21
                    pStatus->bNoLine21Out = FALSE ;  // ... ... ... ... ...
                }
                else   // normal mode
                {
                    // Now we are free to render the line21 out pin...
                    IPin *pPinL21Out ;
                    PIN_INFO  pi ;
                    hr = apPinOutDec[0]->QueryPinInfo(&pi) ;  // the first out pin is fine
                    ASSERT(SUCCEEDED(hr) && pi.pFilter) ;
                    hr = FindMatchingPin(pi.pFilter, AM_DVD_STREAM_LINE21,
                        PINDIR_OUTPUT, TRUE, 0, &pPinL21Out) ;
                    if (SUCCEEDED(hr) && pPinL21Out)
                    {
                        pStatus->bNoLine21In = FALSE ;  // there is line21 output pin
                        hr = RenderLine21Stream(pPinL21Out, pStatus) ;
                        if (SUCCEEDED(hr))
                            pStatus->bNoLine21Out = FALSE ;  // line21 rendering is OK
                        else
                        {
                            pStatus->bNoLine21Out = TRUE ;   // line21 rendering failed
                            hrFinal = S_FALSE ;  // not complete success
                        }
                        pPinL21Out->Release() ;  // done with line21 pin -- release it now
                    }
                    else  // video decoder doesn't have line21 output at all
                    {
                        DbgLog((LOG_TRACE, 3, TEXT("No line21 output pin on the video decoder."))) ;
                        pStatus->bNoLine21In = TRUE ;    // no line21 data from video decoder
                        hrFinal = S_FALSE ;              // not complete success
                    }
                    pi.pFilter->Release() ;  // otherwise we'll leak it
                }
            }  // end of if (SUCCEEDED(hr))
            else
            {
                DbgLog((LOG_TRACE, 3, TEXT("Rendering video stream failed (Error 0x%lx)"), hr)) ;
                hrFinal = S_FALSE ;     // major problem -- video stream failed to render
            }
        }  // end of if (m_bUseVPE)
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("Video Stream: RenderDvdVideoVolume() was called with no VPE flag"))) ;
        }

        ReleasePinInterface(apPinOutDec) ;  // done with decoded video pin(s) -- release it
    }

    return hrFinal ;
}


HRESULT CDvdGraphBuilder::RenderNavAudioOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavAudioOutPin(0x%lx, 0x%lx)"),
        dwDecFlag, pStatus)) ;

    HRESULT     hr ;
    IPin       *pPin ;
    IPin       *apPinOutDec[MAX_DEC_OUT_PINS + 1] ;  // 1 for terminating NULL

    ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ;

    hr = FindMatchingPin(m_pDVDNav, AM_DVD_STREAM_AUDIO, PINDIR_OUTPUT, TRUE, 0, &pPin) ;
    if (FAILED(hr)  ||  NULL == pPin)
    {
        DbgLog((LOG_ERROR, 1, TEXT("No audio output pin found on the DVDNav"))) ;
        return VFW_E_DVD_RENDERFAIL ;
    }
    hr = DecodeDVDStream(pPin, AM_DVD_STREAM_AUDIO, &dwDecFlag, // we ignore returned dwDecFlag here
        pStatus, apPinOutDec) ;
    pPin->Release() ;  // release DVDNav's audio out pin

    if (FAILED(hr))   // couldn't find audio decoder
    {
        DbgLog((LOG_TRACE, 1, TEXT("Could not find a decoder for audio stream!!!"))) ;
        return S_FALSE ;  // just a stream will not be rendered
    }

    //
    // Decoding the audio stream succeeded. Now if we got a decoded output pin,
    // we need to render that too.
    //
    if (apPinOutDec[0])  // if audio decoding is handled and we got a valid output pin
    {
        hr = RenderDecodedAudio(apPinOutDec, pStatus) ;
        if (S_OK != hr)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Could not render decoded audio stream"))) ;
            hr = S_FALSE ;  // partial failure to be returned
        }
        ReleasePinInterface(apPinOutDec) ;  // done with decoded audio pin -- release it
    }

    return hr ;
}


HRESULT CDvdGraphBuilder::RenderNavSubpicOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavSubpicOutPin(0x%lx, 0x%lx)"),
        dwDecFlag, pStatus)) ;

    HRESULT     hr ;
    IPin       *pPin ;
    IPin       *apPinOutDec[MAX_DEC_OUT_PINS + 1] ;  // 1 for terminating NULL

    ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ;

    hr = FindMatchingPin(m_pDVDNav, AM_DVD_STREAM_SUBPIC, PINDIR_OUTPUT, TRUE, 0, &pPin) ;
    if (FAILED(hr)  ||  NULL == pPin)
    {
        DbgLog((LOG_ERROR, 1, TEXT("No subpicture output pin found on the DVDNav"))) ;
        return VFW_E_DVD_RENDERFAIL ;
    }
    // Pass dwDecFlag as a in/out param to get back what kind of SP decoder was
    // actually used.  We'll use that to hack below.
    hr = DecodeDVDStream(pPin, AM_DVD_STREAM_SUBPIC, &dwDecFlag,
        pStatus, apPinOutDec) ;
    pPin->Release() ;  // release DVDNav's subpic out pin

    if (FAILED(hr))   // couldn't find SP decoder
    {
        DbgLog((LOG_TRACE, 1, TEXT("Could not find a decoder for SP stream!!!"))) ;
        return S_FALSE ;  // just a stream will not be rendered
    }

    //
    // Decoding the SP stream succeeded. Now if we got a decoded output pin,
    // we need to render that too.
    //
    if (apPinOutDec[0])  // there is a decoded SP out pin
    {
        hr = RenderDecodedSubpic(apPinOutDec, pStatus) ;

        //
        // HACK HACK HACK:
        // In general HW decoders mix the SP and video in HW rather than popping a
        // SP output pin. We may land up getting a (seemingly) video out pin, which
        // for SW decoders may mean a decoded SP output pin, but for HW decoders it's
        // certainly some other thing (c-cube DVXplorer) and it will not connect to
        // OvMixer/VPM+VMR.
        // We don't avoid trying to connect such a pin to OvMixer/VPM+VMR (done above),
        // but in case it fails (as it is expected to), we just ignore the error and do
        // NOT consider it as a SP stream rendering failure.
        //
        if (AM_DVD_HWDEC_ONLY == dwDecFlag)  // here means HW decoder was used for SP
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("SP stream is decoded in HW. We ignore any error in rendering (0x%lx)"),
                hr)) ;
            hr = S_OK ;
        }
        else  // for SW decoder
        {
            if (FAILED(hr))  // connection to renderer's in pin failed => no SP
            {
                DbgLog((LOG_TRACE, 3, TEXT("Decoded SP out pin could NOT connect to renderer"))) ;
                // propagate only S_FALSE to the caller
                hr = S_FALSE ;  // because just a stream is not rendered right
            }
        }

        ReleasePinInterface(apPinOutDec) ;  // done with decoded SP pin -- release it
    }

    return hr ;
}


//
// *** NOT YET IMPLEMENTED ***
//
HRESULT CDvdGraphBuilder::RenderNavASFOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavASFOutPin(0x%lx, 0x%lx) -- ** Not Implemented **"),
        dwDecFlag, pStatus)) ;

    return S_OK ;
}


//
// *** NOT YET IMPLEMENTED ***
//
HRESULT CDvdGraphBuilder::RenderNavOtherOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavOtherOutPin(0x%lx, 0x%lx) -- ** Not Implemented **"),
        dwDecFlag, pStatus)) ;

    return S_OK ;
}


HRESULT CDvdGraphBuilder::RenderRemainingPins(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderRemainingPins() -- ** Not Implemented **"))) ;

    ASSERT(FALSE) ;   // so that we know about it

    return S_FALSE ;  // so that graph building doesn't fail completely
}


HRESULT CDvdGraphBuilder::DecodeDVDStream(IPin *pPinOut, DWORD dwStream, DWORD *pdwDecFlag,
                                          AM_DVD_RENDERSTATUS *pStatus, IPin **apPinOutDec)
{
    DbgLog((LOG_TRACE, 4,
        TEXT("CDvdGraphBuilder::DecodeDVDStream(%s, 0x%lx, 0x%lx, 0x%lx, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), dwStream, *pdwDecFlag, pStatus, apPinOutDec)) ;

    HRESULT    hr ;
    IPin      *pPinIn ;  // the (end) pin we finally connected to
    DWORD      dwNewDecFlag = *pdwDecFlag ;  // let's start with what we have

    // ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ;

    //
    // We'll note what decoder option we actually use, but will not update the
    // value at the passed in pointer until we have checked that the stream has
    // really been decoded completely.  So the new flag is assigned way below
    // when we verify that the output stream gives decoded output.
    //
    // Also H/SWDecodeDVDStream() methods will try to detect if the video/SP
    // decoder is VMR-compatible, and if not, set a flag (m_bTryVMR to FALSE),
    // so that RenderDecodedVideo() method can determine which renderer to use.
    //
    switch (*pdwDecFlag)  // based on the user-specified decoding option
    {
    case AM_DVD_HWDEC_ONLY:
        hr = HWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
        if (FAILED(hr))
            return hr ;
        // *pdwDecFlag = AM_DVD_HWDEC_ONLY ; -- unchanged
        break ;

    case AM_DVD_HWDEC_PREFER:
        hr = HWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
        if (FAILED(hr))  // if didn't succeed, try SW decode too
        {
            hr = SWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
            if (FAILED(hr))  // now we give up
                return hr ;
            else
                dwNewDecFlag = AM_DVD_SWDEC_ONLY ;  // we preferred HW, but did it in SW
        }
        else
            dwNewDecFlag = AM_DVD_HWDEC_ONLY ;  // we preferred HW and got HW

        break ;

    case AM_DVD_SWDEC_ONLY:
        hr = SWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
        if (FAILED(hr))
            return hr ;
        break ;

    case AM_DVD_SWDEC_PREFER:
        hr = SWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
        if (FAILED(hr))  // if didn't succeed, try SW decode too
        {
            hr = HWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
            if (FAILED(hr))  // now we give up
                return hr ;
            else
                dwNewDecFlag = AM_DVD_HWDEC_ONLY ;  // we preferred SW, but got HW
        }
        else
            dwNewDecFlag = AM_DVD_SWDEC_ONLY ;  // we preferred SW and got SW
        break ;

    default:
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: How did dwFlags=0x%lx get passed in?"), *pdwDecFlag)) ;
        return E_INVALIDARG ;
    }  // end of switch(*pdwDecFlag)

    //
    // Now see if the stream has been completely decoded
    //
    ASSERT(pPinIn) ;  // so that otherwise we know
    if (NULL == pPinIn)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: How can the connected to pin be NULL after connection?"))) ;
        return E_FAIL ;
    }

    IPin  *pPinOut2 ;
    PIN_INFO  pi ;
    pPinIn->QueryPinInfo(&pi) ;
    pPinIn->Release() ;  // don't need the in pin anymore

    DWORD  dw ;			 // temp variable for stream type
    int    iPos = 0 ;    // which instance of pin of the filter
    int    iCount = 0 ;  // how many decoded output pins have we found (expected only 1)
    while (SUCCEEDED(hr = FindMatchingPin(pi.pFilter, 0, PINDIR_OUTPUT, TRUE, iPos, &pPinOut2)) &&
        NULL != pPinOut2)
    {
        if (dwStream != (dw = GetPinStreamType(pPinOut2)))
        {
            //
            // Hack: The mediatype for decoded subpicture is video. So while rendering
            // the subpicture stream, if we don't find a subpicture out pin, look for a
            // video out pin too.
            //
            if (AM_DVD_STREAM_SUBPIC == dwStream)
            {
                DbgLog((LOG_TRACE, 3, TEXT("No open out pin for SP stream"))) ;
                //
                // If the output pin is of type video then it's OK --
                // it's the out pin for decoded SP content.
                //
                if (AM_DVD_STREAM_VIDEO != dw)
                {
                    DbgLog((LOG_TRACE, 3,
                        TEXT("*** Could NOT find open out pin #%d of type 0x%lx for filter of pin %s (SP) ***"),
                        iPos, dw, (LPCTSTR)CDisp(pPinIn))) ;
                    pPinOut2->Release() ;  // otherwise we'll leak!!!
                    iPos++ ;
                    continue ;  // check for other out pins
                }
                DbgLog((LOG_TRACE, 3, TEXT("Found open video out pin %s for the SP stream"),
                    (LPCTSTR)CDisp(pPinOut2))) ;
            }  // end of if (subpic)
            else  // non-subpicture stream
            {
                DbgLog((LOG_TRACE, 1,
                    TEXT("*** Could NOT find open out pin #%d of type 0x%lx for filter of pin %s ***"),
                    iPos, dw, (LPCTSTR)CDisp(pPinIn))) ;
                pPinOut2->Release() ;  // otherwise we'll leak!!!
                iPos++ ;
                continue ;  // check for other out pins
            }
        }
        else
            DbgLog((LOG_TRACE, 3, TEXT("Found open out pin %s of matching type 0x%lx"),
            (LPCTSTR)CDisp(pPinOut2), dwStream)) ;

        // Is the output decoded now?
        if (IsOutputDecoded(pPinOut2))
        {
            DbgLog((LOG_TRACE, 1,
                TEXT("Pin %s is going to be returned as decoded out pin #%ld of stream type %ld"),
                (LPCTSTR)CDisp(pPinOut2), iCount+1, dwStream)) ;
            if (iCount < MAX_DEC_OUT_PINS)
            {
                apPinOutDec[iCount] = pPinOut2 ;
                iCount++ ;

                //
                // This is the right place to update the actually used decoder flag
                //
                // NOTE: There is this bleak chance of having multiple output pins etc.
                // but that's a pathological case and we do this for the SP stream only.
                //
                if (*pdwDecFlag != dwNewDecFlag)
                {
                    DbgLog((LOG_TRACE, 2,
                        TEXT("Decoding option changed from 0x%lx to 0x%lx for stream 0x%lx on out pin %s"),
                        *pdwDecFlag, dwNewDecFlag, dwStream, (LPCTSTR)CDisp(pPinOut2))) ;
                    *pdwDecFlag = dwNewDecFlag ;
                }
            }
            else
            {
                DbgLog((LOG_TRACE, 1, TEXT("WARNING: Way too many out pins to be returned. Ignoring now..."))) ;
            }
        }
        else  // not yet fully decoded -- try more
        {
            hr = DecodeDVDStream(pPinOut2, dwStream, pdwDecFlag, pStatus, apPinOutDec) ;
            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE, 3, TEXT("Decoding of pin %s failed (Error 0x%lx)"),
                    (LPCTSTR)CDisp(pPinOut2), hr)) ;
                pPinOut2->Release() ;
                pi.pFilter->Release() ;  // else we leak!!!
                return hr ;
            }
            pPinOut2->Release() ;  // done with this pin
        }

        iPos++ ;  // look for the next open out pin
        DbgLog((LOG_TRACE, 5, TEXT("Going to look for open out pin #%d..."), iPos)) ;
    }  // end of while (FindMatchingPin()) loop

    pi.pFilter->Release() ;  // else we leak!!!

    return S_OK ;  // success!!!
}


//
// There is an assumption in this function that we don't need to create multiple
// instances of a WDM filter to get a suitable input pin on it.  If we have to
// ever do that there has to be substantial changes in this function and/or
// CreateDVDHWDecoders() function.
//
HRESULT CDvdGraphBuilder::HWDecodeDVDStream(IPin *pPinOut, DWORD dwStream, IPin **ppPinIn,
                                            AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4,
        TEXT("CDvdGraphBuilder::HWDecodeDVDStream(%s, 0x%lx, 0x%lx, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), dwStream, ppPinIn, pStatus)) ;

    *ppPinIn = NULL ;  // to start with

    int  iCount = m_ListHWDecs.GetCount() ;
    if (0 == iCount)
        return VFW_E_DVD_DECNOTENOUGH ;

    HRESULT   hr ;
    BOOL      bConnected = FALSE ;  // to start with

    int          i ;
    int          j ;
    BOOL		 bNewlyAdded ;
    LPWSTR       lpszwName ;
    IBaseFilter *pFilter ;
    IPin        *pPinIn ;
    for (i = 0 ; !bConnected  &&  i < iCount ; i++)
    {
        // Get the next HW decoder filter
        if (! m_ListHWDecs.GetFilter(i, &pFilter, &lpszwName) )
        {
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: m_ListHWDecs.GetFilter(%d, ...) failed"), i)) ;
            ASSERT(FALSE) ;  // so we don't ignore itd
            break ;
        }
        DbgLog((LOG_TRACE, 3, TEXT("HW Dec filter %S will be tried."), lpszwName)) ;

        // If this HW decoder filter is already not in the graph, add it
        if (! m_ListFilters.IsInList(pFilter) )
        {
            DbgLog((LOG_TRACE, 5, TEXT("Filter %S is NOT already in use"), lpszwName)) ;
            hr = m_pGB->AddFilter(pFilter, lpszwName) ;
            ASSERT(SUCCEEDED(hr)) ;
            bNewlyAdded = TRUE ;
        }
        else
            bNewlyAdded = FALSE ;

        // Try every input pin of the required mediatype
        j = 0 ;
        while ( //  !bConnected  &&  -- we 'break' out of this loop on connection
            SUCCEEDED(hr = FindMatchingPin(pFilter, dwStream, PINDIR_INPUT,
            TRUE, j, &pPinIn))  &&
            pPinIn)
        {
            // We got an input pin of the required mediatype
            hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
            if (SUCCEEDED(hr))
            {
                if (bNewlyAdded)
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Filter %S added to list of filters"), lpszwName)) ;
                    m_ListFilters.AddFilter(pFilter, lpszwName, NULL) ;  // add to list
                    pFilter->AddRef() ;  // we need an extra AddRef() here
                }
                EnumFiltersBetweenPins(dwStream, pPinOut, pPinIn, pStatus) ;
                *ppPinIn = pPinIn ;  // return this input pin to the caller
                bConnected = TRUE ;
                break ;   // connected -- get out of this loop
                // REMEMBER: release the returned pin in the caller
            }

            pPinIn->Release() ;  // done with this in pin
            j++ ;   // go for the next pin...
        }  // end of while (!bConnected && FindMatchingPin())

        // If we couldn't make any connection in the above while() loop then
        // remove the filter, ONLY IF it was added just before the loop.
        if (!bConnected && bNewlyAdded)
        {
            DbgLog((LOG_TRACE, 5,
                TEXT("Couldn't connect to newly added filter %S. Removing it."), lpszwName)) ;
            hr = m_pGB->RemoveFilter(pFilter) ;
            ASSERT(SUCCEEDED(hr)) ;
        }
    }  // end of for (i)

    if (! bConnected )
        return VFW_E_DVD_DECNOTENOUGH ;

    return S_OK ;  // success!!
}


HRESULT CDvdGraphBuilder::SWDecodeDVDStream(IPin *pPinOut, DWORD dwStream, IPin **ppPinIn,
                                            AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4,
        TEXT("CDvdGraphBuilder::SWDecodeDVDStream(%s, 0x%lx, 0x%lx, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), dwStream, ppPinIn, pStatus)) ;

    HRESULT          hr ;
    IBaseFilter     *pFilter ;
    IEnumRegFilters *pEnumFilters ;
    REGFILTER       *pRegFilter ;
    IEnumMediaTypes *pEnumMT ;
    AM_MEDIA_TYPE   *pmt = NULL;
    IPin            *pPinIn ;
    BOOL             bConnected = FALSE ;  // to start with
    BOOL             bNewlyAdded ;
    ULONG            ul ;
    int              iPos ;
    int              j ;
    PIN_INFO         pi ;

    *ppPinIn = NULL ;  // to start with

    pPinOut->EnumMediaTypes(&pEnumMT) ;
    ASSERT(pEnumMT) ;

    // HACK (kind of) to avoid the Duck filter getting picked up for the SP decoding.
    // First try the existing filters in the graph to see if any of those will take
    // this output pin.
    hr = pPinOut->QueryPinInfo(&pi) ;
    ASSERT(SUCCEEDED(hr)) ;
    while (!bConnected  &&
        S_OK == pEnumMT->Next(1, &pmt, &ul)  &&  1 == ul)
    {
        if (pPinIn = GetFilterForMediaType(dwStream, pmt, pi.pFilter))
        {
            hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;  // .._DIRECTFIRST
            if (SUCCEEDED(hr))
            {
                bConnected = TRUE ;
                *ppPinIn = pPinIn ;  // return this input pin to the caller
            }
            else
                pPinIn->Release() ;  // release interface only if connection failed
        }
        DeleteMediaType(pmt) ;  // done with this mediatype
        pmt = NULL;
    }  // end of while() loop

    if (pi.pFilter)     // just being cautious
        pi.pFilter->Release() ;  // release now; else we leak.
    if (bConnected)     // if succeeded in connecting, we are done here
    {
        pEnumMT->Release() ;     // done with the MT enumerator
        return S_OK ;            // success!!!
    }

    //
    // This output pin does NOT connect to any of the existing filters in the graph.
    // Try to pick one from the regsitry, i.e., the standard process.
    //
    pEnumMT->Reset() ;   // start from the beginning again
    while (!bConnected  &&
        S_OK == pEnumMT->Next(1, &pmt, &ul)  &&  1 == ul)
    {
        hr = m_pMapper->EnumMatchingFilters(&pEnumFilters, MERIT_DO_NOT_USE+1,
            TRUE, pmt->majortype, pmt->subtype,
            FALSE, TRUE, GUID_NULL, GUID_NULL) ;
        if (FAILED(hr) || NULL == pEnumFilters)
        {
            DbgLog((LOG_ERROR, 1, TEXT("ERROR: No matching filter enum found (Error 0x%lx)"), hr)) ;
            DeleteMediaType(pmt) ;
            return VFW_E_DVD_RENDERFAIL ;
        }

        while (!bConnected  &&
            S_OK == pEnumFilters->Next(1, &pRegFilter, &ul)  &&  1 == ul)
        {
            bNewlyAdded = FALSE ;  // to start the loop with...
            iPos = 0 ;

            // Until connected and we can locate an existing (in use) filter from our list
            while (!bConnected  &&
                m_ListFilters.GetFilter(&pRegFilter->Clsid, iPos, &pFilter))  // already in use
            {
                j = 0 ;
                while (SUCCEEDED(hr = FindMatchingPin(pFilter, 0, PINDIR_INPUT, TRUE, j, &pPinIn)) &&
                    pPinIn)  // got an(other) open in pin
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Got in pin %s (%d) of filter %S (old). Try to connect..."),
                        (LPCTSTR)CDisp(pPinIn), j, pRegFilter->Name)) ;
                    hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;  // .._DIRECTFIRST
                    if (SUCCEEDED(hr))
                    {
                        if (bNewlyAdded)
                            m_ListFilters.AddFilter(pFilter, NULL, &(pRegFilter->Clsid)) ;
                        // Don't need AddRef() here as it has just been CoCreateInstance()-ed above
                        // and is NOT shared between 2 lists.
                        bConnected = TRUE ;
                        // pPinIn->Release() ;  // done with this pin -- release in the caller
                        *ppPinIn = pPinIn ;  // return this input pin to the caller
                        break ;  // connection happened -- out of this loop
                        // REMEMBER: Release the returned pin in the caller function
                    }
                    else       // couldn't connect
                    {
                        pPinIn->Release() ;  // done with this pin
                        j++ ;  // try next in pin of this filter
                    }
                }  // end of while ()
                iPos++ ;     // for next filter in list
            }

            if (bConnected)  // already succeeded -- we are done!!!
            {
                CoTaskMemFree(pRegFilter) ;
                break ;
            }

            DbgLog((LOG_TRACE, 5, TEXT("Instance %d of filter %S is being created"),
                iPos, pRegFilter->Name)) ;
            hr = CreateFilterInGraph(pRegFilter->Clsid, pRegFilter->Name, &pFilter) ;
            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE, 3, TEXT("Failed to create filter %S (Error 0x%lx)"), pRegFilter->Name, hr)) ;
                CoTaskMemFree(pRegFilter) ;  // release this reg filter's info
                continue ;  // try the next one
            }
            bNewlyAdded = TRUE ;

            j = 0 ;
            while (!bConnected  &&    // not connected  AND ...
                SUCCEEDED(hr = FindMatchingPin(pFilter, 0, PINDIR_INPUT, TRUE, j, &pPinIn))  &&
                pPinIn)            // ...got an open in pin
            {
                DbgLog((LOG_TRACE, 5, TEXT("Got in pin %s (%d) of filter %S (new). Try to connect..."),
                    (LPCTSTR)CDisp(pPinIn), j, pRegFilter->Name)) ;
                hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;  // .._DIRECTFIRST
                if (SUCCEEDED(hr))
                {
                    if (bNewlyAdded)
                        m_ListFilters.AddFilter(pFilter, NULL, &(pRegFilter->Clsid)) ;
                    // Don't need AddRef() here as it has just been CoCreateInstance()-ed above
                    // and is NOT shared between 2 lists.
                    bConnected = TRUE ;
                    *ppPinIn = pPinIn ;  // return this input pin to the caller
                    // REMEMBER: release the returned pin in the caller function
                }
                else  // couldn't connect
                {
                    pPinIn->Release() ;  // done with this pin
                    j++ ;  // try next in pin of this filter
                }

                // pPinIn->Release() ;  // done with this pin
            }  // end of while (FindMatchingPin())

            if (bConnected)  // Nav -> Filter (this) succeeded
            {
                // Video and SP stream: check for VMR compatibility
                if (AM_DVD_STREAM_VIDEO  == dwStream ||
                    AM_DVD_STREAM_SUBPIC == dwStream)
                {
                    // Filter, hopefully decoder, has been connected to the Nav.
                    // Now check if it's VMR ompatible.
                    BOOL  bUseVMR = IsFilterVMRCompatible(pFilter) ;
                    SetVMRUse(GetVMRUse() && bUseVMR) ;
                    DbgLog((LOG_TRACE, 3, TEXT("Filter %S is %s VMR compatible"),
                        pRegFilter->Name, bUseVMR ? TEXT("") : TEXT("*NOT*"))) ;
                }
            }
            else  // connection failed
            {
                // If the failed filter was just added then remove it from
                // graph and release it now.
                if (bNewlyAdded)
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Couldn't connect to filter %S. Removing it."),
                        pRegFilter->Name)) ;
                    m_pGB->RemoveFilter(pFilter) ;  // not in this graph
                    pFilter->Release() ;  // don't need this filter
                }
            }

            CoTaskMemFree(pRegFilter) ;  // done with this registered filter

        }  // end of while (!bConnected && pEnumFilters->Next())

        pEnumFilters->Release() ;  // done with filter enumerator
        // release last media type
        DeleteMediaType(pmt) ;
        pmt = NULL;
    }  // end of while (enum MTs)
    pEnumMT->Release() ;  // done with the MT enumerator

    if (!bConnected)
        return VFW_E_DVD_DECNOTENOUGH ;

    return S_OK ;  // success!!
}


BOOL CDvdGraphBuilder::IsFilterVMRCompatible(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::IsFilterVMRCompatible(0x%lx)"), pFilter)) ;

    BOOL  bResult = FALSE ;  // assume old decoder

    //
    // Updated DVD decoders implement IAMDecoderCaps interface to indicate their
    // VMR compatibility.
    //
    IAMDecoderCaps  *pDecCaps ;
    HRESULT  hr = pFilter->QueryInterface(IID_IAMDecoderCaps, (LPVOID *) &pDecCaps) ;
    if (SUCCEEDED(hr))
    {
        DWORD  dwCaps = 0 ;
        hr = pDecCaps->GetDecoderCaps(AM_GETDECODERCAP_QUERY_VMR_SUPPORT, &dwCaps) ;
        if (SUCCEEDED(hr))
        {
            bResult = (dwCaps & VMR_SUPPORTED) != 0 ;
        }
        else
            DbgLog((LOG_TRACE, 1, TEXT("IAMDecoderCaps::GetDecoderCaps() failed (error 0x%lx)"), hr)) ;

        pDecCaps->Release() ;  // done with it
    }
    else
        DbgLog((LOG_TRACE, 5, TEXT("(Old) Decoder does NOT support IAMDecoderCaps interface"))) ;


    return bResult ;
}


#if 0
void PrintPinRefCount(LPCSTR lpszStr, IPin *pPin)
{
#pragma message("WARNING: Should we remove PrintPinRefCount()?")
#pragma message("WARNING: or at least #ifdef DEBUG?")
    pPin->AddRef() ;
    LONG l = pPin->Release() ;
    DbgLog((LOG_TRACE, 5, TEXT("Ref Count of %s -- %hs: %ld"),
        (LPCTSTR) CDisp(pPin), lpszStr, l)) ;
}
#endif // #if 0


HRESULT CDvdGraphBuilder::ConnectPins(IPin *pPinOut, IPin *pPinIn, DWORD dwOption)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ConnectPins(%s, %s, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn), dwOption)) ;

    // #pragma message("WARNING: Should we remove calls to PrintPinRefCount()?")
    //     PrintPinRefCount("Before connection", pPinOut) ;
    //     PrintPinRefCount("Before connection", pPinIn) ;

    HRESULT   hr ;

    switch (dwOption)
    {
    case AM_DVD_CONNECT_DIRECTONLY:
    case AM_DVD_CONNECT_DIRECTFIRST:
        hr = m_pGB->ConnectDirect(pPinOut, pPinIn, NULL) ;
        if (SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE, 3, TEXT("Pin %s *directly* connected to pin %s"),
                (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
            //             PrintPinRefCount("After connection", pPinOut) ;
            //             PrintPinRefCount("After connection", pPinIn) ;
            return hr ;
        }
        else  // couldn't connect directly
        {
            if (AM_DVD_CONNECT_DIRECTONLY == dwOption)
            {
                //                 PrintPinRefCount("After connection failed", pPinOut) ;
                //                 PrintPinRefCount("After connection failed", pPinIn) ;
                return hr ;
            }
            // else let it fall through to try indirect connect next
        }

    case AM_DVD_CONNECT_INDIRECT:
        hr = m_pGB->Connect(pPinOut, pPinIn) ;
        if (SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE, 3, TEXT("Pin %s *indirectly* connected to pin %s"),
                (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Pin %s did NOT even *indirectly* connect to pin %s"),
                (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
        }
        //         PrintPinRefCount("After connection attempt", pPinOut) ;
        //         PrintPinRefCount("After connection attempt", pPinIn) ;
        return hr ;  // whatever it is

    default:
        return E_UNEXPECTED ;
    }
}


HRESULT CDvdGraphBuilder::RenderVideoUsingOvMixer(IPin **apPinOut,
                                                  AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderVideoUsingOvMixer(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    IPin     *pPinIn ;
    BOOL      bConnected = FALSE ;  // until connects

    //
    // If VMR has somehow been instantiated, we need to remove and release it now.
    //
    if (m_pVMR)
    {
        DbgLog((LOG_TRACE, 3, TEXT("VMR was somehow created and not in use. Removing it..."))) ;
        // Remove it from graph and release it
        m_pGB->RemoveFilter(m_pVMR) ;
        m_pVMR->Release() ;
        m_pVMR = NULL ;
    }

    // IMPORTANT NOTE:
    // For video stream, any decode/rendering problem has to be flagged here
    // as we just downgrade the final result in the caller, but not set any
    // flag there.  Also in RenderDecodedVideo(), we may try to use VMR, and
    // if that fails, we fall back on OvMixer.  If rendering through OvMixer
    // also fails, then only we set the rendering error status and code.
    //

    hr = EnsureOverlayMixerExists() ;
    if (FAILED(hr))
    {
        // pStatus->hrVPEStatus = hr ; -- actually VPE/Overlay wasn't tried even
        DbgLog((LOG_TRACE, 3, TEXT("Overlay Mixer couldn't be started!!!"))) ;
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    // Connect given output pin to OverlayMixer's first input pin
    hr = FindMatchingPin(m_pOvM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: No open input pin found on OverlayMixer (Error 0x%lx)"), hr)) ;
        ASSERT(FALSE) ;  // so that we know of this weird case
        DbgLog((LOG_TRACE, 3, TEXT("No input pin found on Overlay Mixer!!!"))) ;
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    int  i = 0 ;
    while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
    {
        hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
        if (FAILED(hr))
        {
            pStatus->hrVPEStatus = hr ;
            i++ ;
            ASSERT(i <= MAX_DEC_OUT_PINS) ;
        }
        else
        {
            bConnected = TRUE ;
            pStatus->hrVPEStatus = S_OK ;  // make sure we don't return any error code
        }
    }

    pPinIn->Release() ;  // done with the pin

    if (!bConnected)  // if connection to OvMixer's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 3, TEXT("None of the %d video output pins could be connected to OvMixer"), i)) ;
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return S_FALSE ;
    }

    // Now see if OverlayMixer has an output pin (no out pin in DDraw excl mode).
    // If it has, connect that to the Video Renderer.
    IPin   *pPinOutOvM ;
    hr = FindMatchingPin(m_pOvM, 0, PINDIR_OUTPUT, TRUE, 0, &pPinOutOvM) ;
    if (FAILED(hr)  ||  NULL == pPinOutOvM)
    {
        DbgLog((LOG_TRACE, 1, TEXT("No output pin of OverlayMixer -- in DDraw excl mode?"))) ;
        //ASSERT(IsDDrawExclMode()) ;
        return S_OK ;  // nothing more to do
    }

    // Create the Video Renderer filter and connect OvMixer's out pin to that
    bConnected = FALSE ;   // until connected
    hr = CreateFilterInGraph(CLSID_VideoRenderer, L"Video Renderer", &m_pVR) ;
    if (SUCCEEDED(hr) && m_pVR)
    {
        hr = FindMatchingPin(m_pVR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;  // Caution: re-using pPinIn
        if (SUCCEEDED(hr)  &&  pPinIn)
        {
            hr = ConnectPins(pPinOutOvM, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
            if (FAILED(hr))  // what?!?
            {
                ASSERT(FALSE) ;  // so that we notice
                DbgLog((LOG_TRACE, 1, TEXT("No video out pin connected to pin %s -- no video on screen"),
                    (LPCTSTR)CDisp(pPinIn))) ;
            }
            else
            {
                bConnected = TRUE ;
            }
            pPinIn->Release() ;      // done with VR's in pin
        }
        else   // what?!?
        {
            DbgLog((LOG_TRACE, 1, TEXT("No input pin of VideoRenderer?!?"))) ;
            // Remove it from graph; else a useless window will pop up
            m_pGB->RemoveFilter(m_pVR) ;
            m_pVR->Release() ;
            m_pVR = NULL ;
        }
    }
    else   // what?!?
    {
        ASSERT(FALSE) ;  // so that we notice
        DbgLog((LOG_TRACE, 1,
            TEXT("WARNING: Can't start Video Renderer (Error 0x%lx) -- no video on screen"),
            hr)) ;
        // bConnected = FALSE ;
    }
    pPinOutOvM->Release() ;  // done with OvMixer's out pin

    if (! bConnected )  // if connection to OvMixer's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Couldn't render Video stream using OvMixer"))) ;
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return S_FALSE ;
    }

    return S_OK ;
}


HRESULT CDvdGraphBuilder::RenderVideoUsingVMR(IPin **apPinOut,
                                              AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderVideoUsingVMR(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    IPin     *pPinIn ;
    BOOL      bConnected = FALSE ;  // until connects

    //
    // If OvMixer has somehow been instantiated, we need to remove and release it now.
    //
    if (m_pOvM)
    {
        DbgLog((LOG_TRACE, 3, TEXT("OvMixer was somehow created. Can't use VMR now."))) ;
		return E_FAIL ;

        // DbgLog((LOG_TRACE, 3, TEXT("OvMixer was somehow created and not in use. Removing it..."))) ;
        // Remove it from graph and release it
        // m_pGB->RemoveFilter(m_pOvM) ;
        // m_pOvM->Release() ;
        // m_pOvM = NULL ;
    }

    //
    // Now instantiate VMR and try to render using it
    //
    hr = EnsureVMRExists() ;
    if (S_OK != hr)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Video Mixing Renderer couldn't be started or configured"))) ;
        // pStatus->iNumStreamsFailed++ ;
        // pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return E_FAIL ; // caught by RenderDecodedVideo()
    }

    // Connect given output pin to VMR's first input pin
    hr = FindMatchingPin(m_pVMR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: No open input pin found on VMR (Error 0x%lx)"), hr)) ;
        ASSERT(FALSE) ;  // so that we know of this weird case
        // Remove it from graph; it's useless now
        m_pGB->RemoveFilter(m_pVMR) ;
        m_pVMR->Release() ;
        m_pVMR = NULL ;
        // pStatus->iNumStreamsFailed++ ;
        // pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return E_UNEXPECTED ;  // caught by RenderDecodedVideo(), but unexpected
    }

    // Try to connect the first out pin of the video decoder to VMR's 1st in pin
    int  i = 0 ;
    while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
    {
        hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
        if (FAILED(hr))
        {
            pStatus->hrVPEStatus = hr ;
            i++ ;
            ASSERT(i <= MAX_DEC_OUT_PINS) ;
        }
        else
        {
            bConnected = TRUE ;
            pStatus->hrVPEStatus = S_OK ;  // make sure we don't return any error code
        }
    }

    pPinIn->Release() ;  // done with the pin

    if (! bConnected )  // if connection to VMR's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Couldn't render Video stream using VMR"))) ;
        // Remove it from graph; it's useless now
        m_pGB->RemoveFilter(m_pVMR) ;
        m_pVMR->Release() ;
        m_pVMR = NULL ;
        // pStatus->iNumStreamsFailed++ ;
        // pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return E_UNEXPECTED ;  // S_FALSE ;
    }

    return S_OK ;
}


HRESULT CDvdGraphBuilder::RenderVideoUsingVPM(IPin **apPinOut,
                                              AM_DVD_RENDERSTATUS *pStatus,
                                              IPin **apPinOutVPM)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderVideoUsingVPM(0x%lx, 0x%lx, 0x%lx)"),
        apPinOut, pStatus, apPinOutVPM)) ;

    HRESULT   hr ;
    IPin     *pPinIn ;
    IPin     *pPinOut ;
    BOOL      bConnected = FALSE ;  // until connects

    // Filter, hopefully decoder, has been connected to the Nav.
    // Now try to connect it to VPM (and later to VMR).
    ASSERT(NULL == m_pVPM) ;
    // *apPinOutVPM = NULL ;  // to start with
    hr = CreateFilterInGraph(CLSID_VideoPortManager, L"Video Port Manager", &m_pVPM) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 3, TEXT("VPM couldn't be started!!!"))) ;
        return E_FAIL ; // caught by RenderDecodedVideo()
    }

    // Connect given output pin to VPM's first input pin
    hr = FindMatchingPin(m_pVPM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: No open input pin found on VPM (Error 0x%lx)"), hr)) ;
        ASSERT(FALSE) ;  // so that we know of this weird case
        // Remove it from graph; it's useless now
        m_pGB->RemoveFilter(m_pVPM) ;
        m_pVPM->Release() ;
        m_pVPM= NULL ;
        return E_UNEXPECTED ;  // caught by RenderDecodedVideo()
    }

    // Try to connect the first out pin of the HW video decoder to VPM's in pin
    int  i = 0 ;
    while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
    {
        hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
        if (FAILED(hr))
        {
            pStatus->hrVPEStatus = hr ;
            i++ ;
            ASSERT(i <= MAX_DEC_OUT_PINS) ;
        }
        else
        {
            bConnected = TRUE ;
            pStatus->hrVPEStatus = S_OK ;  // make sure we don't return any error code
        }
    }

    pPinIn->Release() ;  // done with the pin

    if (! bConnected )  // if connection to VPM's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Couldn't render (HW) Video stream using VPM"))) ;
        // Remove it from graph; it's useless now
        m_pGB->RemoveFilter(m_pVPM) ;
        m_pVPM->Release() ;
        m_pVPM = NULL ;
        return E_FAIL ;
    }

    // Connected!! Now find the first out pin of the VPM (to connect to VMR).
    hr = FindMatchingPin(m_pVPM, 0, PINDIR_OUTPUT, TRUE, 0, &pPinOut) ;
    ASSERT(SUCCEEDED(hr)) ;

    apPinOutVPM[0] = pPinOut ;  // only one pin returned; release in the caller

    return hr ;
}


HRESULT CDvdGraphBuilder::RenderDecodedVideo(IPin **apPinOut,
                                             AM_DVD_RENDERSTATUS *pStatus,
                                             DWORD dwDecFlag)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderDecodedVideo(0x%lx, 0x%lx, 0x%lx)"),
        apPinOut, pStatus, dwDecFlag)) ;

    HRESULT  hr = S_OK ;

    // SWDecodeDVDStream() method tried to detect if the video/SP decoder is
    // VMR-compatible. If not, it has set a flag (m_bTryVMR to FALSE), so here
    // we know which renderer to use.
    //
    // For hardware decoders that work with VPE, we don't check the VMR-compatibility.
    // We just try to connect it to VPM and VMR. If that doesn't work, use OvMixer. We
    // avoid trying to connect the non-VPE decoders to VPM, because we know that DXR2,
    // which uses analog overlay, gets completely messed up if it's even attempted to
    // connect to VPM (which fails anyway).
    //

    // We first try to use VMR, if we are supposed to, i.e.,
    //   a) DDraw (non-)exclusive mode is NOT being used
    //   b) the decoder(s) is VMR compatible
    //   c) no one has asked us not to (in some other way)
    // If that succeeds, Great!!!  Otherwise we fall back on using OvMixer, so
    // that we can at least play the DVD.
    // In case we try to use OvMixer, and that for some reason fails to connect,
    // the error flags and code are set in RenderVideoUsingOvMixer() method.
    //
    if (GetVMRUse())  // VMR can be used (so far)
    {
        //
        // We should try to use VMR first....
        //
        // If HW decoder filter is being used, we check if the output type is VPVideo,
        // and then only we'll try to use VPM for VMR first.  If that works, we'll
        // return the out pin of VPM.  If it fails, we'll set a flag so that
        // RenderDecodedVideo() method knows and uses OvMixer as a fallback option.
        // If the output mediatype is non-VPE (e.g., analog overlay), we do NOT even
        // try to connect to VPM, and fall back to OvMixer.
        //
        if (AM_DVD_HWDEC_ONLY == dwDecFlag)  // video decoded in HW
        {
            DbgLog((LOG_TRACE, 5, TEXT("HW decoder used for Video. Is it VMR-compatible?"))) ;
            if (IsOutputTypeVPVideo(apPinOut[0]))  // output type is VPE => use VPM
            {                       // Checking the first out pin should be fine
                // VPVideo stream: Try to use VPM and VMR for rendering
                DbgLog((LOG_TRACE, 5, TEXT("HW decoder with VPE -- connect to VPM+VMR"))) ;
                IPin  *apPinOutVPM[2] ;  // There is only one out pin of VPM (one for NULL)
                ResetPinInterface(apPinOutVPM, NUMELMS(apPinOutVPM)) ;
                hr = RenderVideoUsingVPM(apPinOut, pStatus, apPinOutVPM) ;  // returns VPM's out pin

                // If the success status is still maintained, use the VMR.
                if (SUCCEEDED(hr))
                {
                    DbgLog((LOG_TRACE, 5, TEXT("HW decoder connected to VPM. Now connect to VMR."))) ;
                    hr = RenderVideoUsingVMR(apPinOutVPM, pStatus) ;  // render VPM's out pin via VMR
                    ReleasePinInterface(apPinOutVPM) ;  // done with VPM out pin interface
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("VPM - VMR connection failed.  Removing VPM..."))) ;
                        if (m_pVPM)
                        {
                            EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pVPM))) ;
                            m_pVPM->Release() ;
                            m_pVPM = NULL ;
                        }
                    }
                }
                else
                {
                    ReleasePinInterface(apPinOutVPM) ;  // shouldn't be needed, but...
                }
            }  // end of if (VPVideo)
            else  // output type is not VPE => use OvMixer (Not VPM+VMR)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Non-VPE HW decoder -- didn't try VPM+VMR"))) ;
                hr = E_FAIL ;  // set failure code so that it's tried with OvMixer below
            }
        }  // end of if (HW decoder used)
        else  // we are using SW video decoder -- render directly using VMR
        {
            DbgLog((LOG_TRACE, 5, TEXT("HW decoder not used. Directly connect to VMR..."))) ;
            hr = RenderVideoUsingVMR(apPinOut, pStatus) ;
        }

        // In case anything above failed, ditch VMR, and go for OvMixer.
        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE, 4, TEXT("Render using VMR failed. Falling back on OvMixer..."))) ;
            //
            // NOTE: If we can't use VMR for video, no point trying it for SP stream
            //
            SetVMRUse(FALSE) ;

            hr = RenderVideoUsingOvMixer(apPinOut, pStatus) ;
        }
    }
    else  // we are not supposed to use VMR; that means use OvMixer
    {
        hr = RenderVideoUsingOvMixer(apPinOut, pStatus) ;
    }

    return hr ;
}


HRESULT CDvdGraphBuilder::RenderDecodedAudio(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderDecodedAudio(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    HRESULT   hrFinal = S_OK ;
    BOOL      bConnected = FALSE ;   // until connected
    IPin     *pPinIn = NULL ;

    ASSERT(NULL == m_pAR) ;  // so that we know

    // Create the Audio Renderer filter and connect decoder's audio out pin to that
    hr = CreateFilterInGraph(CLSID_DSoundRender, L"DSound Renderer", &m_pAR) ;
    if (SUCCEEDED(hr))
    {
        // Get an input pin to Audio Renderer
        hr = FindMatchingPin(m_pAR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
        ASSERT(SUCCEEDED(hr) && pPinIn) ;
    }
    else
    {
        ASSERT(! TEXT("Coundn't start Audio Renderer") ) ;  // so that we notice
        DbgLog((LOG_TRACE, 1,
            TEXT("WARNING: Can't start Audio Renderer (Error 0x%lx) -- no audio from speakers"),
            hr)) ;
        hrFinal = S_FALSE ;  // no audio from speakers -- result downgraded
    }

    //
    // We'll try to render all the decoded audio out pins
    //
    for (int i = 0 ; i < MAX_DEC_OUT_PINS  &&  apPinOut[i]; i++)
    {
        if (pPinIn)  // if we have an open input pin of Audio Renderer
        {
            hr = m_pGB->Connect(apPinOut[i], pPinIn) ;
            if (SUCCEEDED(hr))  // decoded audio connected to audio renderer
            {
                DbgLog((LOG_TRACE, 5, TEXT("Pin %s connected to pin %s"),
                    (LPCTSTR)CDisp(apPinOut[i]), (LPCTSTR)CDisp(pPinIn))) ;
                EnumFiltersBetweenPins(AM_DVD_STREAM_AUDIO, apPinOut[i], pPinIn, pStatus) ;

                bConnected = TRUE ;
                pPinIn->Release() ;  // done with this pin interface
                pPinIn = NULL ;

                // Let's try the next out pin, if any...
                continue ;
            }

            ASSERT(!TEXT("Couldn't connect audio pin")) ;  // so that we notice
            DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT connect to pin %s"),
                (LPCTSTR)CDisp(apPinOut[i]), i, (LPCTSTR)CDisp(pPinIn))) ;
        }

        //
        //  We could come here, because either
        //  1. DSound Renderer didn't start (no audio device)
        //  2. we couldn't get an in pin to DSound Renderer (impossible, but...)
        //
        //  Couldn't connect the outout pin to a known renderer. Let's try to
        //  just render, and see if any filter (S/PDIF?) connects to it.
        //
        hr = m_pGB->Render(apPinOut[i]) ;
        if (FAILED(hr))
        {
            ASSERT(!TEXT("Audio out pin didn't render at all")) ;  // so that we notice
            DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT render at all"),
                (LPCTSTR)CDisp(apPinOut[i]), i)) ;
        }

        // Now onto the next decoded audio out pin, if any...

    }  // end of while (i ...) loop

    if (! bConnected )  // connection to Audio Renderer failed => no audio on speakers
    {
        DbgLog((LOG_TRACE, 1,
            TEXT("No decoded audio pin connect to AudioRenderer -- no audio from speakers"))) ;

        if (m_pAR)  // if we had an Audio Renderer
        {
            if (pPinIn)  // if we had an in pin that we couldn't connect to,
                pPinIn->Release() ;      // let it go now.

            // Remove Audio Renderer from graph
            m_pGB->RemoveFilter(m_pAR) ;
            m_pAR->Release() ;
            m_pAR = NULL ;
        }
        hrFinal = S_FALSE ;
    }

    return hrFinal ;
}


HRESULT CDvdGraphBuilder::RenderSubpicUsingOvMixer(IPin **apPinOut,
                                                   AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderSubpicUsingOvMixer(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    BOOL      bConnected = FALSE ;   // until connected
    IPin     *pPinIn ;
    int       i = 0 ;

    ASSERT(m_pOvM) ;  // it must be there, if video stream was rendered

    // Now connect the given out pin to the next available in pin of OvMixer
    hr = FindMatchingPin(m_pOvM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (SUCCEEDED(hr)  &&  pPinIn)
    {
        while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
        {
            hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
            if (FAILED(hr))  // what?!?
            {
                // ASSERT(FALSE) ;  // so that we notice
                DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT connect to pin %s -- no SP"),
                    (LPCTSTR)CDisp(apPinOut[i]), i, (LPCTSTR)CDisp(pPinIn))) ;
                i++ ;
                ASSERT(i <= MAX_DEC_OUT_PINS) ;
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("Pin %s is directly connected to pin %s"),
                    (LPCTSTR)CDisp(apPinOut[i]), (LPCTSTR)CDisp(pPinIn))) ;
                bConnected = TRUE ;
            }
        }
        pPinIn->Release() ;      // done with OvMixer's in pin
    }
    else   // what?!?
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: No more input pin of OverlayMixer?!?"))) ;
    }

    return (bConnected ? S_OK : hr) ;  // this should be the same as "return hr ;"
}


HRESULT CDvdGraphBuilder::RenderSubpicUsingVMR(IPin **apPinOut,
                                               AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderSubpicUsingVMR(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    BOOL      bConnected = FALSE ;   // until connected
    IPin     *pPinIn ;
    int       i = 0 ;

    ASSERT(m_pVMR) ;  // it must be there, if video stream was rendered

    // Now connect the given out pin to the next available in pin of VMR
    hr = FindMatchingPin(m_pVMR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (SUCCEEDED(hr)  &&  pPinIn)
    {
        while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
        {
            hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
            if (FAILED(hr))  // what?!?
            {
                // ASSERT(FALSE) ;  // so that we notice
                DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT connect to pin %s -- no SP"),
                    (LPCTSTR)CDisp(apPinOut[i]), i, (LPCTSTR)CDisp(pPinIn))) ;
                i++ ;
                ASSERT(i <= MAX_DEC_OUT_PINS) ;
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("Pin %s is directly connected to pin %s"),
                    (LPCTSTR)CDisp(apPinOut[i]), (LPCTSTR)CDisp(pPinIn))) ;
                bConnected = TRUE ;
            }
        }
        pPinIn->Release() ;      // done with VMR's in pin
    }
    else   // what?!?
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: No more input pin of VMR?!?"))) ;
    }

    return (bConnected ? S_OK : hr) ;  // this should be the same as "return hr ;"
}


HRESULT CDvdGraphBuilder::RenderDecodedSubpic(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderDecodedSubpic(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;

    //
    // Render the decoded subpicture stream ONLY IF the user wants that
    //
    if (!m_bUseVPE  ||  IsDDrawExclMode())
    {
        DbgLog((LOG_TRACE, 1, TEXT("SP Stream: RenderDvdVideoVolume() skipped for %s and %s"),
            m_bUseVPE ? "VPE" : "no VPE", IsDDrawExclMode() ? "DDraw excl mode" : "normal mode")) ;
        return S_OK ;
    }

    // We have already attempted to render the video straem.  If that has failed,
    // there is no point trying to render the subpicture stream -- just indicate
    // that this stream didn't render and return.
    if (pStatus->dwFailedStreamsFlag & AM_DVD_STREAM_VIDEO)
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Video stream didn't render. Skipping SP rendering."))) ;
        return S_FALSE ;
    }

    if (GetVMRUse())  // if VMR is to be used
    {
        DbgLog((LOG_TRACE, 5, TEXT("Rendering SP stream using VMR"))) ;
        hr = RenderSubpicUsingVMR(apPinOut, pStatus) ;
    }
    else  // OvMixer is being used
    {
        DbgLog((LOG_TRACE, 5, TEXT("Rendering SP stream using OvMixer"))) ;
        hr = RenderSubpicUsingOvMixer(apPinOut, pStatus) ;
    }

    //
    // We don't set the following flag and values anymore as part of the hack
    // to ignore failure to connect *some* decoded-SP-ish out pin in the case
    // of HW decoders. The caller of this method knows if the decoder being
    // used is HW or SW and based on that it will ignore any failure or not.
    //
    if (FAILED(hr))  // if connection to OvMixer's in pin failed => no SP (weird!!)
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Subpic pin could NOT connect to renderer"))) ;
        return hr ; // S_FALSE ;
    }

    return S_OK ;  // complete success!!!
}


HRESULT CDvdGraphBuilder::RenderLine21Stream(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderLine21Stream(%s, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), pStatus)) ;

    HRESULT   hr ;
    BOOL      bConnected = FALSE ;   // until connected
    IPin     *pPinIn ;

    ASSERT(NULL == m_pL21Dec) ;  // so that we know

    //
    // Create the Line21 Decoder filter and connect given out pin to that
    //
    if (GetVMRUse())  // for VMR use Line21 Decoder2
    {
        hr = CreateFilterInGraph(CLSID_Line21Decoder2, L"Line21 Decoder2", &m_pL21Dec) ;
    }
    else  // for OvMixer, keep using the old one
    {
        hr = CreateFilterInGraph(CLSID_Line21Decoder, L"Line21 Decoder", &m_pL21Dec) ;
    }
    if (SUCCEEDED(hr))
    {
        hr = FindMatchingPin(m_pL21Dec, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
        if (SUCCEEDED(hr)  &&  pPinIn)
        {
            hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
            if (FAILED(hr))  // what?!?
            {
                ASSERT(FALSE) ;
                DbgLog((LOG_TRACE, 1, TEXT("Pin %s did NOT connect to pin %s -- no CC"),
                    (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
                pPinIn->Release() ;  // release pin before removing filter
                m_pGB->RemoveFilter(m_pL21Dec) ;
                m_pL21Dec->Release() ;
                m_pL21Dec = NULL ;
            }
            else
            {
                bConnected = TRUE ;
                pPinIn->Release() ;   // because we do so for the failure case
            }
        }
        else   // what?!?
        {
            DbgLog((LOG_TRACE, 1, TEXT("No input pin of Line21 Decoder(2)?!?"))) ;
            // Remove it from graph
            m_pGB->RemoveFilter(m_pL21Dec) ;
            m_pL21Dec->Release() ;
            m_pL21Dec = NULL ;
        }
    }
    else   // what?!?
    {
        // ASSERT(FALSE) ;  // so that we notice -- not until lin21dec2 is done
        DbgLog((LOG_TRACE, 1,
            TEXT("WARNING: Can't start Line21 Decoder(2) (Error 0x%lx) -- no CC"),
            hr)) ;
    }

    if (! bConnected )  // if connection to OvMixer's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Pin %s could NOT connect to Line21 Decoder(2)"),
            (LPCTSTR)CDisp(pPinOut))) ;
        return hr ;
    }

    // Now connect line21 decoder(2)'s output to OvMixer/VMR's in pin
    bConnected = FALSE ;  // until connected again
    IPin   *pPinOutL21 ;
    hr = FindMatchingPin(m_pL21Dec, 0, PINDIR_OUTPUT, TRUE, 0, &pPinOutL21) ;
    ASSERT(SUCCEEDED(hr)) ;

    if (GetVMRUse())  // find VMR's in pin
    {
        hr = FindMatchingPin(m_pVMR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;  // Caution: reusing pPinIn
    }
    else              // find OvMixer's in pin
    {
        hr = FindMatchingPin(m_pOvM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;  // Caution: reusing pPinIn
    }
    ASSERT(SUCCEEDED(hr)) ;
    if (pPinOutL21  &&  pPinIn)
    {
        hr = ConnectPins(pPinOutL21, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
        if (FAILED(hr))  // what?!?
        {
            ASSERT(FALSE) ;  // so that we notice
            DbgLog((LOG_TRACE, 1, TEXT("Pin %s did NOT connect to pin %s -- no CC"),
                (LPCTSTR)CDisp(pPinOutL21), (LPCTSTR)CDisp(pPinIn))) ;
            pPinOutL21->Release() ;  // release pin before removing filter
            m_pGB->RemoveFilter(m_pL21Dec) ;
            m_pL21Dec->Release() ;
            m_pL21Dec = NULL ;
        }
        else
        {
            bConnected = TRUE ;
            pPinOutL21->Release() ;  // because we do so in the failure case
        }
        pPinIn->Release() ;      // done with OvMixer's in pin
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Couldn't get necessary in/out pin"))) ;
        if (pPinIn)
            pPinIn->Release() ;
        if (pPinOutL21)
            pPinOutL21->Release() ;
        // Remove it from graph
        m_pGB->RemoveFilter(m_pL21Dec) ;
        m_pL21Dec->Release() ;
        m_pL21Dec = NULL ;
    }

    if (! bConnected )  // if connection to OvMixer's in pin failed => no CC
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Line21Dec output could NOT connect to OvMixer/VMR"))) ;
        return hr ;
    }

    return S_OK ;  // complete success!!!
}


BOOL CDvdGraphBuilder::IsOutputDecoded(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::IsOutputDecoded(%s)"),
        (LPCTSTR)CDisp(pPinOut))) ;

    HRESULT          hr ;
    IEnumMediaTypes *pEnumMT ;
    AM_MEDIA_TYPE   *pmt ;
    ULONG            ul ;
    BOOL             bMTDecoded = FALSE ;  // unless found otherwise

    hr = pPinOut->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    while ( !bMTDecoded &&
        S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul)
    {
#if 1  // we'll use the following procedure
        bMTDecoded = (MEDIATYPE_Video == pmt->majortype &&              // major type Video,
            MEDIASUBTYPE_MPEG2_VIDEO != pmt->subtype &&       // subtype is NOT MPEG2Video
            MEDIASUBTYPE_DVD_SUBPICTURE != pmt->subtype) ||   // subtype is NOT DVDSubPicture  OR

            (MEDIATYPE_Audio == pmt->majortype &&              // major type Audio
            MEDIASUBTYPE_MPEG2_AUDIO != pmt->subtype &&       // subtype is NOT MPEG2Audio
            MEDIASUBTYPE_DOLBY_AC3 != pmt->subtype &&         // subtype is NOT Dolby AC3
            MEDIASUBTYPE_DVD_LPCM_AUDIO != pmt->subtype) ||   // subtype is NOT DVD-LPCMAudio

            (MEDIATYPE_AUXLine21Data == pmt->majortype) ;      // majortype is Line21
#else  // not this procedure
        bMTDecoded = (MEDIATYPE_DVD_ENCRYPTED_PACK != pmt->majortype && // majortype is NOT DVD_ENCRYPTED_PACK
            MEDIATYPE_MPEG2_PES != pmt->majortype &&          // majortype is NOT MPEG2_PES

            MEDIASUBTYPE_MPEG2_VIDEO != pmt->subtype &&       // subtype is NOT MPEG2Video

            MEDIASUBTYPE_MPEG2_AUDIO != pmt->subtype &&       // subtype is NOT MPEG2Audio
            MEDIASUBTYPE_DOLBY_AC3 != pmt->subtype &&         // subtype is NOT DolbyAC3
            MEDIASUBTYPE_DVD_LPCM_AUDIO != pmt->subtype &&    // subtype is NOT DVD_LPCMAudio

            MEDIASUBTYPE_DVD_SUBPICTURE != pmt->subtype) ;    // subtype is NOT DVD_SUBPICTURE
#endif // #if 1
        DeleteMediaType(pmt) ;  // otherwise
    }
    pEnumMT->Release() ;

    return bMTDecoded ;
}


BOOL CDvdGraphBuilder::IsOutputTypeVPVideo(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::IsOutputTypeVPVideo(%s)"),
        (LPCTSTR)CDisp(pPinOut))) ;

    HRESULT          hr ;
    IEnumMediaTypes *pEnumMT ;
    AM_MEDIA_TYPE   *pmt ;
    ULONG            ul ;
    BOOL             bVPVideo = FALSE ;  // unless found otherwise

    hr = pPinOut->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    while ( !bVPVideo  &&
           S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul)
    {
        bVPVideo = MEDIATYPE_Video      == pmt->majortype &&  // major type Video,
                   MEDIASUBTYPE_VPVideo == pmt->subtype ;     // subtype is VPVideo
        DeleteMediaType(pmt) ;  // otherwise
    }
    pEnumMT->Release() ;

    return bVPVideo ;
}


//
// Create a filter and add it to the filter graph
//
HRESULT CDvdGraphBuilder::CreateFilterInGraph(CLSID Clsid,
                                              LPCWSTR lpszwFilterName,
                                              IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateFilterInGraph(%s, %S, 0x%lx)"),
        (LPCTSTR) CDisp(Clsid), lpszwFilterName, ppFilter)) ;

    if (NULL == m_pGB)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Filter graph object hasn't been created yet"))) ;
        return E_FAIL ;
    }

    HRESULT   hr ;
    hr = CoCreateInstance(Clsid, NULL, CLSCTX_INPROC, IID_IBaseFilter,
        (LPVOID *)ppFilter) ;
    if (FAILED(hr) || NULL == *ppFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't create filter %s (Error 0x%lx)"),
            (LPCTSTR)CDisp(Clsid), hr)) ;
        return hr ;
    }

    // Add it to the filter graph
    hr = m_pGB->AddFilter(*ppFilter, lpszwFilterName) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't add filter %s to graph (Error 0x%lx)"),
            (LPCTSTR)CDisp(Clsid), hr)) ;
        (*ppFilter)->Release() ;  // release filter too
        *ppFilter = NULL ;      // and set it to NULL
        return hr ;
    }

    return NOERROR ;
}



//
// Instantiate all the HW decoders registered under DVD Hardware Decoder
// group under the Active Filters category.
//
// Qn: Do we need to also pick up the HW filters under any other category,
// specially for filters like the external AC3 decoder etc.?
//
HRESULT CDvdGraphBuilder::CreateDVDHWDecoders(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateDVDHWDecoders()"))) ;

    HRESULT  hr ;
    ICreateDevEnum *pCreateDevEnum ;
    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
        IID_ICreateDevEnum, (void**)&pCreateDevEnum) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't create system dev enum (Error 0x%lx)"), hr)) ;
        return hr ;
    }

    IEnumMoniker *pEnumMon ;
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_DVDHWDecodersCategory,
        &pEnumMon, 0) ;
    pCreateDevEnum->Release() ;

    if (S_OK != hr)
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("WARNING: Couldn't create class enum for DVD HW Dec category (Error 0x%lx)"),
            hr)) ;
        return E_FAIL ;
    }

    hr = pEnumMon->Reset() ;

    ULONG     ul ;
    IMoniker *pMon ;

    while (S_OK == pEnumMon->Next(1, &pMon, &ul) && 1 == ul)
    {
#ifdef DEBUG
        WCHAR   *wszName ;
        pMon->GetDisplayName(0, 0, &wszName) ;
        DbgLog((LOG_TRACE, 5, TEXT("Moniker enum: %S"), wszName)) ;
        CoTaskMemFree(wszName) ;
#endif  // DEBUG

        IBaseFilter *pFilter ;
        hr = pMon->BindToObject(0, 0, IID_IBaseFilter, (void**)&pFilter) ;
        if (FAILED(hr) ||  NULL == pFilter)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't create HW dec filter (Error 0x%lx)"), hr)) ;
            pMon->Release() ;
            continue ;
        }
        DbgLog((LOG_TRACE, 5, TEXT("HW decoder filter found"))) ;

        IPropertyBag *pPropBag ;
        pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag) ;
        if(pPropBag)
        {
#ifdef DEBUG
            {
                VARIANT var ;
                var.vt = VT_EMPTY ;
                hr = pPropBag->Read(L"DevicePath", &var, 0) ;
                ASSERT(SUCCEEDED(hr)) ;
                DbgLog((LOG_TRACE, 5, TEXT("DevicePath: %S"), var.bstrVal)) ;
                VariantClear(&var) ;
            }

            {
                VARIANT var ;
                var.vt = VT_EMPTY ;
                hr = pPropBag->Read(L"CLSID", &var, 0) ;
                ASSERT(SUCCEEDED(hr)) ;
                DbgLog((LOG_TRACE, 5, TEXT("CLSID: %S"), var.bstrVal)) ;
                VariantClear(&var) ;
            }
#endif // DEBUG

            {
                VARIANT var ;
                var.vt = VT_EMPTY ;
                hr = pPropBag->Read(L"FriendlyName", &var, 0) ;
                if (SUCCEEDED(hr))
                {
                    DbgLog((LOG_TRACE, 5, TEXT("FriendlyName: %S"), var.bstrVal)) ;

                    //
                    // We have got a device under the required category. The proxy
                    // for it is already instantiated. So add to the list of HW
                    // decoders to be used for building the graph.
                    //
                    m_ListHWDecs.AddFilter(pFilter, var.bstrVal, NULL) ;
                    VariantClear(&var) ;
                }
                else
                {
                    DbgLog((LOG_ERROR, 1, TEXT("WARNING: Failed to get FriendlyName (Error 0x%lx)"), hr)) ;
                    ASSERT(SUCCEEDED(hr)) ;  // so that we know
                }
            }

            pPropBag->Release() ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: BindToStorage failed"))) ;
        }

        pMon->Release() ;
    }  // end of while()

    pEnumMon->Release() ;

    DbgLog((LOG_TRACE, 5, TEXT("Found total %d HW decoders"), m_ListHWDecs.GetCount())) ;

    return NOERROR ;

}



HRESULT CDvdGraphBuilder::FindMatchingPin(IBaseFilter *pFilter, DWORD dwStream, PIN_DIRECTION pdWanted,
                                          BOOL bOpen, int iIndex, IPin **ppPin)
{
    DbgLog((LOG_TRACE, 4,
        TEXT("CDvdGraphBuilder::FindMatchingPin(0x%lx, 0x%lx, %s, %s, %d, 0x%lx)"),
        pFilter, dwStream, pdWanted == PINDIR_INPUT ? "In" : "Out",
        bOpen ? "T" : "F", iIndex, ppPin)) ;

    HRESULT         hr = E_FAIL ;
    IEnumPins      *pEnumPins ;
    IPin           *pPin ;
    IPin           *pPin2 ;
    PIN_DIRECTION   pdFound ;
    ULONG           ul ;

    *ppPin = NULL ;

    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't find a pin from NULL filter!!!"))) ;
        return E_INVALIDARG ;
    }

    EXECUTE_ASSERT(SUCCEEDED(pFilter->EnumPins(&pEnumPins))) ;
    ASSERT(pEnumPins) ;

    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
    {
        EXECUTE_ASSERT(SUCCEEDED(pPin->QueryDirection(&pdFound))) ;
        if (pdWanted != pdFound)
        {
            pPin->Release() ;     // don't need this pin
            continue ;
        }
        HRESULT  hr1 = pPin->ConnectedTo(&pPin2) ;
        ASSERT((SUCCEEDED(hr1) && pPin2) || (FAILED(hr1) && !pPin2)) ;
        if (bOpen)   // we looking for an open pin
        {
            if (SUCCEEDED(hr1) && pPin2)  // pin already connected -- skip it
            {
                pPin2->Release() ; // not interested in this pin actually
                pPin->Release() ;  // this pin is already connected -- skip it
                continue ;         // try next one
            }
            // Otherwise we have got an open pin -- onto the mediatypes...
            // Check mediatype only if a streamtype was specified
            if (0 != dwStream  &&  dwStream != GetPinStreamType(pPin) )  // not a mediatype match
            {
                DbgLog((LOG_TRACE, 5, TEXT("Pin %s is not of stream type 0x%lx"),
                    (LPCTSTR) CDisp(pPin), dwStream)) ;
                pPin->Release() ;     // this pin is already connected -- skip it
                continue ;            // try next one
            }
        }
        else         // we looking for a connected pin
        {
            if (FAILED(hr1) || NULL == pPin2)  // pin NOT connected -- skip it
            {
                pPin->Release() ; // this pin is NOT connected -- skip it
                continue ;        // try next one
            }
            // Otherwise we have got a connected pin
            pPin2->Release() ;  // else we leak!!!

            // Check mediatype only if a streamtype was specified
            if (0 != dwStream)
            {
                AM_MEDIA_TYPE  mt ;
                pPin->ConnectionMediaType(&mt) ;
                if (dwStream != GetStreamFromMediaType(&mt))
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Pin %s is not of stream type 0x%lx"),
                        (LPCTSTR) CDisp(pPin), dwStream)) ;
                    FreeMediaType(mt) ;  // else we leak
                    pPin->Release() ;     // this pin is already connected -- skip it
                    continue ;            // try next one
                }
                FreeMediaType(mt) ;  // anyway have to free this
            }
        }
        if (0 == iIndex)
        {
            // Got the reqd pin in the right direction
            *ppPin = pPin ;
            hr = S_OK ;
            break ;
        }
        else  // some more to go
        {
            iIndex-- ;            // one more down...
            pPin->Release() ;     // this is not the pin we are looking for
        }
    }
    pEnumPins->Release() ;
    return hr ;  // whatever it is

}


DWORD CDvdGraphBuilder::GetStreamFromMediaType(AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetStreamFromMediaType(0x%lx)"), pmt)) ;

    DWORD  dwStream = 0 ;

    // Decipher the mediatype
    if (pmt->majortype == MEDIATYPE_MPEG2_PES  ||
        pmt->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Mediatype is MPEG2_PES/DVD_ENCRYPTED_PACK"))) ;

        if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is DOLBY_AC3"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_Subpicture"))) ;
            dwStream = AM_DVD_STREAM_SUBPIC ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Unknown subtype %s"),
                (LPCTSTR) CDisp(pmt->subtype))) ;
        }
    }
    else if (pmt->majortype == MEDIATYPE_Video)  // elementary stream
    {
        DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Video elementary"))) ;

        if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_SUBPICTURE"))) ;
            dwStream = AM_DVD_STREAM_SUBPIC ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_RGB8   ||
            pmt->subtype == MEDIASUBTYPE_RGB565 ||
            pmt->subtype == MEDIASUBTYPE_RGB555 ||
            pmt->subtype == MEDIASUBTYPE_RGB24  ||
            pmt->subtype == MEDIASUBTYPE_RGB32)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is RGB8/16/24/32"))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Unknown subtype %s for Video -- assuming decoded video"),
                (LPCTSTR) CDisp(pmt->subtype))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
    }
    else if (pmt->majortype == MEDIATYPE_Audio)  // elementary stream
    {
        DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Audio elementary"))) ;

        if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is AC3"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        if (pmt->subtype == MEDIASUBTYPE_MPEG2_AUDIO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_AUDIO"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        if (pmt->subtype == MEDIASUBTYPE_DVD_LPCM_AUDIO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_LPCM Audio"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Unknown subtype %s for Audio -- assuming decoded audio"),
                (LPCTSTR) CDisp(pmt->subtype))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
    }
    else if (pmt->majortype == MEDIATYPE_AUXLine21Data)  // line21 stream
    {
        ASSERT(pmt->subtype == MEDIASUBTYPE_Line21_GOPPacket) ; // just checking
        DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Line21 GOPPacket"))) ;
        dwStream = AM_DVD_STREAM_LINE21 ;
    }
    else if (pmt->majortype == MEDIATYPE_Stream)         // some stream format
    {
        if (pmt->subtype == MEDIASUBTYPE_Asf)  // ASF stream
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ASF stream"))) ;
            dwStream = AM_DVD_STREAM_ASF ;
        }
        else                                   // some other stream format
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is some OTHER stream format"))) ;
            dwStream = AM_DVD_STREAM_ADDITIONAL ;
        }
    }
    //
    // There is a chance that some IHV/ISV creates a private mediatype
    // (major or sub) as in the case of IBM (for CSS filter). We have to
    // search the parts of the mediatype to locate something we recognize.
    //
    else
    {
        DbgLog((LOG_TRACE, 2,
            TEXT("Unknown mediatype %s:%s. But we won't give up..."),
            (LPCTSTR) CDisp(pmt->majortype), (LPCTSTR) CDisp(pmt->subtype))) ;
        if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3 ||
            pmt->subtype == MEDIASUBTYPE_MPEG2_AUDIO ||
            pmt->subtype == MEDIASUBTYPE_DVD_LPCM_AUDIO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Audio"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Video"))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Subpicture"))) ;
            dwStream = AM_DVD_STREAM_SUBPIC ;
        }
        else
        {
            DbgLog((LOG_TRACE, 2, TEXT("WARNING: Unknown mediatype. Couldn't detect at all."))) ;
        }
    }

    return dwStream ;
}


DWORD CDvdGraphBuilder::GetPinStreamType(IPin *pPin)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetPinStreamType(%s)"),
        (LPCTSTR) CDisp(pPin))) ;

    DWORD             dwStream = 0 ;
    AM_MEDIA_TYPE    *pmt ;
    IEnumMediaTypes  *pEnumMT ;
    ULONG             ul ;

    HRESULT hr = pPin->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    while (0 == dwStream  &&
        S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul) // more mediatypes
    {
        dwStream = GetStreamFromMediaType(pmt) ;		
        DeleteMediaType(pmt) ;
    }  // end of while()

    pEnumMT->Release() ;

    return dwStream ;  // whatever we found

}


HRESULT CDvdGraphBuilder::GetFilterCLSID(IBaseFilter *pFilter, DWORD dwStream,
                                         LPCWSTR lpszwName, GUID *pClsid)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetFilterCLSID(0x%lx, 0x%lx, %S, 0x%lx)"),
        pFilter, dwStream, lpszwName, pClsid)) ;

    HRESULT          hr ;
    IEnumRegFilters *pEnumFilters ;
    REGFILTER       *pRegFilter ;
    IEnumMediaTypes *pEnumMT ;
    AM_MEDIA_TYPE    mtIn ;
    AM_MEDIA_TYPE    mtOut ;
    IPin            *pPinIn ;
    IPin            *pPinOut ;
    ULONG            ul ;
    DWORD            dw ;
    int              iPos ;
    BOOL             bInOK  = FALSE ;  // initially
    BOOL             bOutOK = FALSE ;  // initially
    BOOL             bFound = FALSE ;  // initially

    *pClsid = GUID_NULL ;  // to start with

    // First get the in and out pins' mediatypes
    iPos = 0 ;
    do {  // for Input pin
        hr = FindMatchingPin(pFilter, 0, PINDIR_INPUT, FALSE, iPos, &pPinIn) ;   // want connected in pin
        if (FAILED(hr) || NULL == pPinIn)
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("No connected In pin #%d for intermediate filter %S"),
                iPos, lpszwName)) ;
            return E_UNEXPECTED ;  // no point trying anymore
        }
        pPinIn->ConnectionMediaType(&mtIn) ;
        dw = GetStreamFromMediaType(&mtIn) ;
        if (dwStream != dw)
        {
            DbgLog((LOG_TRACE, 3, TEXT("In pin %s is of stream type 0x%lx; looking for 0x%lx"),
                (LPCTSTR) CDisp(pPinIn), dw, dwStream)) ;
            FreeMediaType(mtIn) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("In pin %s matches required stream type 0x%lx"),
                (LPCTSTR) CDisp(pPinIn), dwStream)) ;
            bInOK = TRUE ;
        }

        pPinIn->Release() ;  // don't need it anymore
        iPos++ ;             // try the next pin
    } while (!bInOK) ;
    // If we come here, we must have got a matching connected input pin

    iPos = 0 ;
    do {  // for Output pin
        hr = FindMatchingPin(pFilter, 0, PINDIR_OUTPUT, FALSE, iPos, &pPinOut) ; // want connected out pin
        if (FAILED(hr) || NULL == pPinOut)
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("No connected Out pin #%d for intermediate filter %S"),
                iPos, lpszwName)) ;
            FreeMediaType(mtIn) ;  // else we leak!!!
            return E_UNEXPECTED ;  // no point trying anymore
        }
        pPinOut->ConnectionMediaType(&mtOut) ;
        dw = GetStreamFromMediaType(&mtOut) ;
        if (dwStream != dw)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Out pin %s is of stream type 0x%lx; looking for 0x%lx"),
                (LPCTSTR) CDisp(pPinOut), dw, dwStream)) ;
            FreeMediaType(mtOut) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("Out pin %s matches required stream type 0x%lx"),
                (LPCTSTR) CDisp(pPinOut), dwStream)) ;
            bOutOK = TRUE ;
        }

        pPinOut->Release() ;  // don't need it anymore
        iPos++ ;              // try the next pin
    } while (!bOutOK) ;
    // If we come here, we must have got a matching connected output pin

    // Get the filter enumerator based on the in and out mediatypes
    hr = m_pMapper->EnumMatchingFilters(&pEnumFilters, MERIT_DO_NOT_USE+1,
        TRUE, mtIn.majortype, mtIn.subtype,
        FALSE, TRUE, mtOut.majortype, mtOut.subtype) ;
    if (FAILED(hr) || NULL == pEnumFilters)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: No matching filter enum found (Error 0x%lx)"), hr)) ;
        FreeMediaType(mtIn) ;
        FreeMediaType(mtOut) ;
        return E_UNEXPECTED ;
    }

    // Now pick the right filter (we only have the "Name" to do the matching)
    while (! bFound  &&
        S_OK == pEnumFilters->Next(1, &pRegFilter, &ul)  &&  1 == ul)
    {
        if (0 == lstrcmpW(pRegFilter->Name, lpszwName))  // we got a match!!!
        {
            DbgLog((LOG_TRACE, 3, TEXT("Found a matching registered filter for %S"), lpszwName)) ;
            *pClsid = pRegFilter->Clsid ;
            bFound = TRUE ;
        }
        CoTaskMemFree(pRegFilter) ;  // done with this filter's info
    }

    // Now release everything (whether we got anything or not)
    pEnumFilters->Release() ;
    FreeMediaType(mtIn) ;
    FreeMediaType(mtOut) ;

    return bFound ? S_OK : E_FAIL ;
}


HRESULT CDvdGraphBuilder::RenderIntermediateOutPin(IBaseFilter *pFilter, DWORD dwStream,
                                                   AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderIntermediateOutPin(0x%lx, 0x%lx, 0x%lx)"),
        pFilter, dwStream, pStatus)) ;

    HRESULT   hr ;
    IPin     *pPinOut ;
    IPin     *apPinOutDec[MAX_DEC_OUT_PINS + 1] ;  // 1 for terminating NULL
    IPin     *pPinIn ;
    ULONG     ul ;
    DWORD     dwDecFlag ;
    HRESULT   hrFinal = S_OK ;
    BOOL      bConnected ;

    while (SUCCEEDED(hr = FindMatchingPin(pFilter, dwStream, PINDIR_OUTPUT, TRUE, 0, &pPinOut)))
    {
        DbgLog((LOG_TRACE, 3, TEXT("Open out pin %s found on intermediate filter"),
            (LPCTSTR) CDisp(pPinOut))) ;

        ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ; // set i/f ptrs to NULL
        dwDecFlag = AM_DVD_SWDEC_PREFER ;  // we intentionally prefer SWDEC here

        hr = DecodeDVDStream(pPinOut, dwStream, &dwDecFlag, pStatus, apPinOutDec) ;
        if (SUCCEEDED(hr) && apPinOutDec[0])  // first element is good enough
        {
            DbgLog((LOG_TRACE, 3, TEXT("Out pin %s is %s decoded (to out pin %s) (stream 0x%lx)"),
                (LPCTSTR) CDisp(pPinOut), AM_DVD_SWDEC_ONLY == dwDecFlag ? TEXT("SW") : TEXT("HW"),
                (LPCTSTR) CDisp(apPinOutDec[0]), dwStream)) ;
            switch (dwStream)
            {
            case AM_DVD_STREAM_VIDEO:
                DbgLog((LOG_TRACE, 5, TEXT("Going to render intermediate filter's additional 'Video' stream"))) ;
                // So far I don't know of anyone coming here.  But IBM's stuff
                // goes to the audio case. So I am not ignoring the video case,
                // just in case someone is that much insane!!!
                //
                // Only if we have been able to render primary video...
                if (0 == (pStatus->dwFailedStreamsFlag & AM_DVD_STREAM_VIDEO))
                {
                    pPinIn = NULL ;
                    hr = E_FAIL ;  // assume we'll fail
                    if (m_pOvM)       // ... using OvMixer
                    {
                        hr = FindMatchingPin(m_pOvM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
                    }
                    else if (m_pVMR)  // ... using VMR
                    {
                        hr = FindMatchingPin(m_pVMR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
                    }
                    // ASSERT(SUCCEEDED(hr) && pPinIn) ;
                    if (SUCCEEDED(hr) && pPinIn)
                    {
                        bConnected = FALSE ;  // reset flag every time
                        int  i = 0 ;
                        while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOutDec[i])
                        {
                            hr = ConnectPins(apPinOutDec[i], pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
                            if (FAILED(hr))  // what?!?
                            {
                                DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT connect to pin %s"),
                                    (LPCTSTR)CDisp(apPinOutDec[i]), i, (LPCTSTR)CDisp(pPinIn))) ;
                                i++ ;
                                ASSERT(i <= MAX_DEC_OUT_PINS) ;
                            }
                            else
                            {
                                DbgLog((LOG_TRACE, 5, TEXT("Pin %s connected to pin %s"),
                                    (LPCTSTR)CDisp(apPinOutDec[i]), (LPCTSTR)CDisp(pPinIn))) ;
                                // Intentionally ignoring any intermediate filters coming in here -- I am tired
                                // EnumFiltersBetweenPins(dwStream, pPinOut, pPinIn, pStatus) ;
                                bConnected = TRUE ;
                            }
                        }  // end of while (!bConnected ...)

                        if (!bConnected)
                        {
                            DbgLog((LOG_TRACE, 3, TEXT("Couldn't connect any of the %d intermediate video out pins"), i)) ;
                            hrFinal = hr ;  // last error is good enough
                        }
                        pPinIn->Release() ;  // done with the pin
                    }
                }  // end of if (0 == (pStatus->dwFailedStreamsFlag ...))
                else
                {
                    ASSERT(FALSE) ;  // so that we know about it
                    DbgLog((LOG_TRACE, 5, TEXT("OvM/VMR is not usable. Will skip rendering this stream."))) ;
                    hrFinal = E_UNEXPECTED ;
                }
                break ;

            case AM_DVD_STREAM_AUDIO:
                DbgLog((LOG_TRACE, 5, TEXT("Going to render intermediate filter's additional 'Audio' stream"))) ;
                hr = RenderDecodedAudio(apPinOutDec, pStatus) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Couldn't connect the intermediate audio out pin"))) ;
                    hrFinal = hr ;
                }
                else
                    DbgLog((LOG_TRACE, 5, TEXT("XXX's SW AC3 must have been rendered now"))) ; // XXX = IBM
                break ;

            case AM_DVD_STREAM_SUBPIC:
                DbgLog((LOG_TRACE, 5, TEXT("Skip rendering intermediate filter's additional 'Subpicture' stream"))) ;
                // hr = RenderDecodedSubpic(apPinOutDec, pStatus) ;
                ASSERT(FALSE) ;  // not expected here at all
                break ;

            case AM_DVD_STREAM_LINE21:
                DbgLog((LOG_TRACE, 5, TEXT("Skip rendering intermediate filter's additional 'CC' stream"))) ;
                // hr = RenderLine21Stream(apPinOutDec[0], pStatus) ;  -- hopefully only one L21 out pin
                ASSERT(FALSE) ;  // not expected here at all
                break ;
            }  // end of switch()

            ReleasePinInterface(apPinOutDec) ;  // done with the decoded out pin(s)
        }  // end of if (SUCCEEDED(hr) && apPinOutDec[0])
        else
            DbgLog((LOG_TRACE, 1, TEXT("Intermediate out pin %s could NOT decoded (stream 0x%lx)"),
            (LPCTSTR) CDisp(pPinOut), dwStream)) ;

        pPinOut->Release() ;  // done with the pin
    }  // end of while ()

    return hrFinal ;
}


HRESULT CDvdGraphBuilder::EnumFiltersBetweenPins(DWORD dwStream, IPin *pPinOut, IPin *pPinIn,
                                                 AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnumFiltersBetweenPins(0x%lx, Out=%s, In=%s, 0x%lx)"),
        dwStream, (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn), pStatus)) ;

    if (NULL == pPinOut || NULL == pPinIn)  // what!!!
        return E_UNEXPECTED ;

    GUID         Clsid ;
    int          iCount = 0 ;
    PIN_INFO     pi ;
    FILTER_INFO  fi ;
    IEnumPins   *pEnumPins ;
    IBaseFilter *pFilter  = NULL ;
    IPin        *pPinIn2  = NULL ;  // init so that we don't have junk
    IPin        *pPinOut2 = NULL ;  // init so that we don't have junk
    HRESULT  hr = pPinIn->ConnectedTo(&pPinOut2) ;
    while (SUCCEEDED(hr)  &&  pPinOut2  &&  !IsEqualObject(pPinOut, pPinOut2))
    {
        pPinOut2->QueryPinInfo(&pi) ;
        pFilter = pi.pFilter ;
        ASSERT(pFilter && PINDIR_OUTPUT == pi.dir) ;
        //
        // We intentionally keep the extra ref count because this is an intermediate
        // filter and other intermediate filters picked up through registry based
        // filter enum (for SW decoding case) will have the extra ref count.  We
        // release the IBaseFilter interface pointer in CListFilters::ClearList() or
        // CListFilters::RemoveAllFromGraph() and if we don't keep this extra ref
        // count here, we'll fault.  On the other hand we must do Release() on
        // CListFilters elements, because SW enum-ed filters will not otherwise be
        // unloaded.
        //
        // if (pi.pFilter)
        //     pi.pFilter->Release() ;  // it has an extra ref count from QueryPinInfo()

        pFilter->QueryFilterInfo(&fi) ;
        if (! m_ListFilters.IsInList(pFilter) )  // not yet in list
        {
            hr = GetFilterCLSID(pFilter, dwStream, fi.achName, &Clsid) ;
            ASSERT(SUCCEEDED(hr)) ;
            m_ListFilters.AddFilter(pFilter, NULL /* fi.achName */, &Clsid) ;  // presumably it's a SW filter
            DbgLog((LOG_TRACE, 5, TEXT("Intermediate filter %S added to our list"), fi.achName)) ;
        }
        else
            DbgLog((LOG_TRACE, 5, TEXT("Intermediate filter %S is already in our list"), fi.achName)) ;

        fi.pGraph->Release() ; // else we leak!!
        pPinOut2->Release() ;  // done with the pin for now
        pPinOut2 = NULL ;
        iCount++ ;

        // Check for any open out pin on the intermediate filter. We may find
        // one such on IBM's CSS filter for the SW AC3 decoder.
        hr = RenderIntermediateOutPin(pFilter, dwStream, pStatus) ;
        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("Failed to render intermediate filter's open out pin of type 0x%lx (Error 0x%lx)"),
                dwStream, hr)) ;
            ASSERT(FALSE) ;  // so that we know of this weird case
        }

        // Now get the (stream-matching) input pin of this filter to traverse the chain
        hr = FindMatchingPin(pFilter, dwStream, PINDIR_INPUT, FALSE, 0, &pPinIn2) ; // want connected pin
        if (FAILED(hr) || NULL == pPinIn2)
        {
            DbgLog((LOG_ERROR, 1, TEXT("Filter %S does NOT have any connected pin of type 0x%lx"),
                fi.achName, dwStream)) ;
            ASSERT(pPinIn2) ;
            DbgLog((LOG_TRACE, 5, TEXT("(Incomplete) %d filter(s) found between pin %s and pin %s"),
                iCount, (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
            return hr ;  // we are hopefully not leaking anything
        }

        hr = pPinIn2->ConnectedTo(&pPinOut2) ;
        pPinIn2->Release() ; // done with this in pin
    }  // end of while () loop
    if (pPinOut2)              // if valid IPin interface
        pPinOut2->Release() ;  // release it

    DbgLog((LOG_TRACE, 5, TEXT("Total %d filter(s) found between pin %s and pin %s"),
        iCount, (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
    return S_OK ;  // successfuly done
}


void CDvdGraphBuilder::CheckDDrawExclMode(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CheckDDrawExclMode()"))) ;

    HRESULT  hr ;

#if 0
    hr = EnsureOverlayMixerExists() ;
    if (FAILED(hr))
    {
        return ;
    }
    ASSERT(m_pOvM) ;
#endif // #if 0

    // If OvMixer has already been created, it's most probably by a query for
    // the DDraw (non-)exclusive mode interfaces. Otherwise the app doesn't
    // want to use those interfaces, and hence it does NOT need OvMixer.
    if (NULL == m_pOvM)
    {
        DbgLog((LOG_TRACE, 5,
            TEXT("CheckDDrawExclMode(): OverlayMixer does NOT exist => no excl mode."))) ;
        m_bDDrawExclMode = FALSE ;
        return ;
    }

    // Get the IDDrawExclModeVideo interface
    IDDrawExclModeVideo  *pDDXMV ;
    hr = m_pOvM->QueryInterface(IID_IDDrawExclModeVideo, (LPVOID *) &pDDXMV) ;
    if (FAILED(hr) || NULL == pDDXMV)
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("WARNING: Can't get IDDrawExclModeVideo on OverlayMixer (Error 0x%lx)"), hr)) ;
        return ;
    }

    // Get the DDraw object and surface info from OverlayMixer (and release too)
    IDirectDraw          *pDDObj ;
    IDirectDrawSurface   *pDDSurface ;
    BOOL                  bExtDDObj ;
    BOOL                  bExtDDSurface ;
    hr = pDDXMV->GetDDrawObject(&pDDObj, &bExtDDObj) ;
    ASSERT(SUCCEEDED(hr)) ;
    hr = pDDXMV->GetDDrawSurface(&pDDSurface, &bExtDDSurface) ;
    ASSERT(SUCCEEDED(hr)) ;
    if (pDDObj)
        pDDObj->Release() ;
    if (pDDSurface)
        pDDSurface->Release() ;
    pDDXMV->Release() ;  // release before returning

    // Both true means we are really in excl mode
    m_bDDrawExclMode = bExtDDObj && bExtDDSurface ;
}


IPin * CDvdGraphBuilder::GetFilterForMediaType(DWORD dwStream, AM_MEDIA_TYPE *pmt, IBaseFilter *pOutFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetFilterForMediaType(0x%lx, 0x%lx, 0x%lx)"),
        dwStream, pmt, pOutFilter)) ;

    IBaseFilter *pInFilter ;
    IPin        *pPinIn ;
    LPWSTR       lpszwName ;
    HRESULT      hr ;

    for (int i = 0 ; i < m_ListFilters.GetCount() ; i++)
    {
        // I could have checked if the filter from list is a HW filter, but I decided not to.

        m_ListFilters.GetFilter(i, &pInFilter, &lpszwName) ;
        // Don't want to connect to the out pin's filter's in pin (cyclic graph)
        if (pOutFilter  &&  IsEqualObject(pOutFilter, pInFilter))
            continue ;

        hr = FindMatchingPin(pInFilter, dwStream, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
        if (SUCCEEDED(hr)  &&  pPinIn)
        {
            hr = pPinIn->QueryAccept(pmt) ;
            if (SUCCEEDED(hr))   // input pin seems to accept mediatype
            {
                DbgLog((LOG_TRACE, 5, TEXT("Input pin %s of type %d matches mediatype"),
                    (LPCTSTR)CDisp(pPinIn), dwStream)) ;
                return pPinIn ;  // return matching in pin
            }

            // Otherwise not a matching mediatype -- skip this one.
            DbgLog((LOG_TRACE, 5, TEXT("Input pin %s of type %d didn't like mediatype"),
                (LPCTSTR)CDisp(pPinIn), dwStream)) ;
            pPinIn->Release() ;
            pPinIn = NULL ;
        }
        else
            DbgLog((LOG_TRACE, 5, TEXT("No open input pin of type %d found on %S"),
            dwStream, lpszwName)) ;
    }  // end of for (i)

    return NULL ;  // didn't match any
}




// ---------------------------------------------
//  Implementation of the CListFilters class...
// ---------------------------------------------

CListFilters::CListFilters(int iMax /* = FILTERLIST_DEFAULT_MAX*/ ,
                           int iInc /* = FILTERLIST_DEFAULT_INC */)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::CListFilters(%d, %d)"), iMax, iInc)) ;

    m_iCount   = 0 ;
    m_iMax     = iMax ;
    m_iInc     = iInc ;
    m_pGraph   = NULL ;
    m_pFilters = new CFilterData [m_iMax] ;
    ASSERT(m_pFilters) ;
}


CListFilters::~CListFilters(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::~CListFilters()"))) ;

    if (m_pFilters)
        delete [] m_pFilters ;
    m_iCount   = 0 ;
}


void CListFilters::RemoveAllFromGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::RemoveAllFromGraph()"))) ;

    IBaseFilter  *pFilter ;
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (pFilter = m_pFilters[i].GetInterface())
        {
#ifdef DEBUG
            FILTER_INFO  fi ;
            pFilter->QueryFilterInfo(&fi) ;
            DbgLog((LOG_TRACE, 5, TEXT("Removing filter %S..."), fi.achName)) ;
            if (fi.pGraph)
                fi.pGraph->Release() ;
#endif // DEBUG

            EXECUTE_ASSERT(SUCCEEDED(m_pGraph->RemoveFilter(pFilter))) ;
            // pFilter->Release() ;  -- done in ResetElement() below
            m_pFilters[i].ResetElement() ;
        }
    }
    m_iCount = 0 ;
    m_pGraph = NULL ;  // no filter in list, why have the graph??
}


BOOL CListFilters::AddFilter(IBaseFilter *pFilter, LPCWSTR lpszwName, GUID *pClsid)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::AddFilter(0x%lx, %S, 0x%lx)"),
        pFilter, lpszwName ? lpszwName : L"NULL", pClsid)) ;

    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Internal Error: NULL pFilter param passed to AddFilter()"))) ;
        return FALSE ;
    }
    if (m_iCount >= m_iMax)
    {
        if (! ExpandList() )  // couldn't expand list
        {
            DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: Too many filters added to CListFilters"))) ;
            return FALSE ;
        }
        DbgLog((LOG_TRACE, 5, TEXT("CListFilters list has been extended"))) ;
    }

    m_pFilters[m_iCount].SetElement(pFilter, lpszwName, pClsid) ;
    m_iCount++ ;

    return TRUE ;
}


BOOL CListFilters::GetFilter(int iIndex, IBaseFilter **ppFilter, LPWSTR *lpszwName)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::GetFilter(%d, 0x%lx, 0x%lx)"),
        iIndex, ppFilter, lpszwName)) ;

    if (iIndex > m_iCount)
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("INTERNAL ERROR: Bad index (%d) for CListDecoders::GetFilter()"), iIndex)) ;
        *ppFilter = NULL ;
        return FALSE ;
    }

    *ppFilter = m_pFilters[iIndex].GetInterface() ;
    *lpszwName = m_pFilters[iIndex].GetName() ;
    return TRUE ;
}


BOOL CListFilters::GetFilter(GUID *pClsid, int iIndex, IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::GetFilter(0x%lx, %d, 0x%lx)"),
        pClsid, iIndex, ppFilter)) ;

    GUID  *pFilterClsid ;
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if ((pFilterClsid = m_pFilters[i].GetClsid())  &&
            IsEqualGUID(*pClsid, *pFilterClsid))
        {
            if (0 == iIndex)
            {
                *ppFilter = m_pFilters[i].GetInterface() ;
                return TRUE ;
            }
            else  // skip this one -- we want a later one
                iIndex-- ;
        }
    }

    *ppFilter = NULL ;
    return FALSE ;
}


BOOL CListFilters::IsInList(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::IsInList(0x%lx)"), pFilter)) ;

    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_pFilters[i].GetInterface()))
            return TRUE ;
    }

    return FALSE ;  // didn't match any
}


void CListFilters::ClearList(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::ClearList()"))) ;

    for (int i = 0 ; i < m_iCount ; i++)
    {
#ifdef DEBUG
        FILTER_INFO  fi ;
        m_pFilters[i].GetInterface()->QueryFilterInfo(&fi) ;
        DbgLog((LOG_TRACE, 5, TEXT("Removing filter %S..."), fi.achName)) ;
        if (fi.pGraph)
            fi.pGraph->Release() ;
#endif // DEBUG

        m_pFilters[i].ResetElement() ;
    }
    m_iCount = 0 ;
}


BOOL CListFilters::ExpandList(void)
{
    return FALSE ;   // not implemented for now
}




// -------------------------------------
//  CFilterData class implementation...
// -------------------------------------

CFilterData::CFilterData(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CFilterData::CFilterData()"))) ;

    m_pFilter   = NULL ;
    m_lpszwName = NULL ;
    m_pClsid    = NULL ;
}


CFilterData::~CFilterData(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CFilterData::~CFilterData()"))) ;

    ResetElement() ;
}


void CFilterData::SetElement(IBaseFilter *pFilter, LPCWSTR lpszwName, GUID *pClsid)
{
    DbgLog((LOG_TRACE, 4, TEXT("CFilterData::SetElement(0x%lx, 0x%lx, 0x%lx)"),
        pFilter, lpszwName, pClsid)) ;

    m_pFilter = pFilter ;  // should we AddRef() too?
    if (lpszwName)
    {
        m_lpszwName = new WCHAR [sizeof(WCHAR) * (lstrlenW(lpszwName) + 1)] ;
        ASSERT(m_lpszwName) ;
        if (NULL == m_lpszwName)    // bad situation...
            return ;                // ...just bail out
        lstrcpyW(m_lpszwName, lpszwName) ;
    }

    if (pClsid)
    {
        m_pClsid = (GUID *) new BYTE[sizeof(GUID)] ;
        ASSERT(m_pClsid) ;
        if (NULL == m_pClsid)       // bad situation...
            return ;                // ...just bail out
        *m_pClsid = *pClsid ;
    }
}


void CFilterData::ResetElement(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CFilterData::ResetElement()"))) ;

    LONG         l ;

    if (m_pFilter)
    {
        l = m_pFilter->Release() ;
        DbgLog((LOG_TRACE, 3, TEXT("post Release() ref count is %ld"), l)) ;
        m_pFilter = NULL ;
    }
    if (m_lpszwName)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Filter %S has just been released"), m_lpszwName)) ;
        delete [] m_lpszwName ;
        m_lpszwName = NULL ;
    }
    if (m_pClsid)
    {
        delete [] ((BYTE *) m_pClsid) ;
        m_pClsid = NULL ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dv\dvmux\dvmux.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __DVDVMuxer__
#define __DVDVMuxer__

#include <dv.h>



#define Waiting_Audio  0xfffffff6


#define AM_DV_AUDIO_AFSIZE		0x3f
#define AM_DV_AUDIO_LF			0x80       // bit set ==> audio is NOT locked
#define AM_DV_AUDIO_MODE		0x0f00
#define AM_DV_AUDIO_MODE0		0x0000
#define AM_DV_AUDIO_MODE1		0x0100
#define AM_DV_AUDIO_MODE2		0x0200
#define AM_DV_AUDIO_NO_AUDIO		0x0f00
#define AM_DV_AUDIO_PA			0x1000
#define AM_DV_AUDIO_CHN1		0x0000
#define AM_DV_AUDIO_CHN2		0x2000
#define AM_DV_AUDIO_SM			0x8000
#define AM_DV_AUDIO_QU			0x07000000

//#define AM_DV_AUDIO_STYPE		0x8000
#define AM_DV_AUDIO_ML			0x400000    //bit set means NO multiple language
#define AM_DV_AUDIO_SMP48		0x0
#define AM_DV_AUDIO_SMP44		0x08000000
#define AM_DV_AUDIO_SMP32		0x10000000
#define AM_DV_AUDIO_QU16		0x0
#define AM_DV_AUDIO_QU12		0x01000000
#define AM_DV_AUDIO_QU20		0x02000000

#define AM_DV_AUDIO_EF			0xc0000000  //EF: off: TC: 50/15us
#define AM_DV_AUDIO_5060		0x00200000


//AUDIO source control
// Note: Speed must be set to 0x78 to record to DVCPro NTSC and 0x64 to record to DVCPro PAL
// MSDV does this.
#define AM_DV_DEFAULT_AAUX_CTL		0xffa0cf3f	
//					   | | | |---no info. about 1.src and recorded situation 2.num. of times of compress 3. input src of just previus recording
//					   | | |---1>no info. about insert ch, 2> original recording mode 3. not recording start point 4. not recording end point 
//					   | |--forward direction (1 bit - MSB), normal playback speed (7 bits = 0x40)
//					   |--no info. about the category fo the audio src
#define AM_DV_DEFAULT_AAUX_SRC		0x00800f40

#define AM_DV_DEFAULT_VAUX_SRC		0xff80ffff
#define AM_DV_DEFAULT_VAUX_CTL		0xfffcc83f
#define AM_DV_AAUX_CTL_IVALID_RECORD	0x3800	//recodrede auduio data are not cared


class CAudioSampleSizeSequence;

HRESULT BuildDVINFO(DVINFO *pDVInfo, WAVEFORMATEX **ppwfx, LPBITMAPINFOHEADER lpbi, 
		    int cnt, 
                    CAudioSampleSizeSequence* pAudSampleSequence,
                    WORD *wpMinAudSamples, WORD *rMaxAudSamples,
                    WORD *wpAudSamplesBase);


extern const AMOVIESETUP_FILTER sudDVMux;

#define DVMUX_AUDIO_DEFAULT	0xffffffff

#define DVMUX_MAX_AUDIO_SAMPLES 3
#define DVMUX_VIDEO_INPUT_PIN 0
#define DVMUX_MAX_AUDIO_PIN  2



// We export this:
class CDVMuxer;
class CDVMuxerInputPin;
class CDVMuxerOutputPin;

// ==================================================
// Implements the input pins
// ==================================================

class CDVMuxerInputPin : public CBaseInputPin
{
    friend class CDVMuxer;

    // owning DV DVMuxerer
protected:
    CDVMuxer *m_pDVMuxer;
    IMemAllocator *m_pLocalAllocator;

public:
    CDVMuxerInputPin(
        TCHAR *pObjectName,
        CBaseFilter *pBaseFilter,
        CDVMuxer *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName,
        int iPinNo);

    ~CDVMuxerInputPin();

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* mtIn);

    HRESULT CompleteConnect(IPin *pReceivePin);
    STDMETHODIMP Disconnect();

    // set the connection media type
    HRESULT SetMediaType(const CMediaType *pmt);

    // upstream filter get media type
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    //use video input pin's allocator 
    STDMETHODIMP NotifyAllocator (IMemAllocator *pAllocator, BOOL bReadOnly);

    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);


    // --- IMemInputPin -----

    // here's the next block of data from the stream.
    STDMETHODIMP Receive(IMediaSample * pSample);

    // provide EndOfStream
    STDMETHODIMP EndOfStream(void);

    // passes it to CDVMuxer::BeginFlush
    STDMETHODIMP BeginFlush(void);

    // passes it to CDVMuxer::EndFlush
    STDMETHODIMP EndFlush(void);

    
    // Called when the stream goes active
    HRESULT Active(void);
    HRESULT Inactive(void);
    
    // The samples are held in a First in, First Out queue.
    // They are expected to arrive in order
protected:
    CGenericList<IMediaSample> m_SampleList;

    //HRESULT Copy(  IMediaSample *pDest,  IMediaSample *pSource);

    // Sample access procedures
public:
    // Is there a sample available?
    BOOL SampleReady( int n );

    // Gets the first sample in the queue
    IMediaSample *GetNthSample( int n );

    //X Releases n samples
    void ReleaseNSample( int n );

    // Releases all samples before a certain time
    //void ReleaseAllBefore( CRefTime rtTime );

    // Media type
public:
    CMediaType& CurrentMediaType() { return m_mt; };

    // Connected pin
public:
    IPin *	CurrentPeer() { return m_Connected; };

   // Attributes
protected:
    int	    m_iPinNo;             // Identifying number of this pin
    int	    m_PinVidFrmCnt ;
    BOOL    m_fCpyAud;
    CCritSec m_csReceive;           // input wide receive lock
    
public:
    BOOL    m_fEOSReceived;            // Received an EOS yet?


};

// ==================================================
// Implements the output pin
// ==================================================

class CDVMuxerOutputPin : public CBaseOutputPin
{
    //const int m_iOutputPin;             // CDVMuxer's identifier for this pin
    friend class CDVMuxer;

    // Owning DV DVMuxerer
protected:
    CDVMuxer *m_pDVMuxer;

public:

    CDVMuxerOutputPin(
        TCHAR *pObjectName,
        CBaseFilter *pBaseFilter,
        CDVMuxer *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName);

    ~CDVMuxerOutputPin();

    // --- CBaseOutputPin ------------

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* mtOut);

    // set the connection media type
    HRESULT SetMediaType(const CMediaType *pmt);

    // get  media type
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // called from CBaseOutputPin during connection to ask for
    // the count and size of buffers we need.
    HRESULT DecideBufferSize (IMemAllocator *pMemAllocator,
                                         ALLOCATOR_PROPERTIES * pProp);
        
    // Media type
public:
    CMediaType& CurrentMediaType() { return m_mt; };

    // Connected pin
public:
    IPin *	CurrentPeer() { return m_Connected; };

};


// Helper for locked audio, designed with the intent of minimizing 
// changes to the existing code to add the audio lock feature.

class CAudioSampleSizeSequence 
{
public:
    CAudioSampleSizeSequence() : m_nCurrent(0), m_nSequenceSize(0) {}

    // rMin, rMax set to min, max audio samples for first DV frame.
    // rBase has the value that must be added to the AF_SIZE field.
    // Init should be called after a format change and before the 
    // first DV frame is delivered with the new format.
    void Init(BOOL bLocked, BOOL bNTSC, DWORD nSamplingFrequency,
              WORD& rMin, WORD& rMax, WORD& rBase);


    // Called after each frame is delivered. Sets the min/max audio 
    // samples for the next DV frame.
    void Advance(WORD& rMin, WORD& rMax);

    // Called to reset counter to 1, typically on restarting the graph.
    // Same as Init except that only rMin and rMax have to be changed
    // and there is no need to supply the other input arguments.
    void Reset(WORD& rMin, WORD& rMax);

private:
    DWORD   m_nCurrent;
    DWORD   m_nSequenceSize;
};

/*
 * Define our DV DVMuxerer
 */

class CDVMuxer  :   public CBaseFilter,
		    public IMediaSeeking

{
    friend class CDVMuxerInputPin;
    friend class CDVMuxerOutputPin;

public:

    HRESULT InitDVInfo();


    //
    // --- COM Stuff ---
    //

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
  

    // Have we connected all input and output pins
    virtual HRESULT CanChangeState();

    // map getpin/getpincount for base enum of pins to owner
    // override this to return more specialised pin objects
    virtual int GetPinCount();
    virtual CBasePin * GetPin(int n);

    // override state changes to allow derived filters
    // to control streaming start/stop
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // IMediaSeeking. currently used for a progress bar (how much have
      // we written?)
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );

    STDMETHODIMP ConvertTimeFormat(
	LONGLONG * pTarget, const GUID * pTargetFormat,
	LONGLONG    Source, const GUID * pSourceFormat );

    STDMETHODIMP SetPositions(
	LONGLONG * pCurrent,  DWORD CurrentFlags,
	LONGLONG * pStop,  DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

 	// Construction / destruction
public:
    CDVMuxer(TCHAR *, LPUNKNOWN, CLSID clsid, HRESULT * );
    ~CDVMuxer();

// Definitions
protected:
    
    // DVMuxer dv video with audio and add AUX blocks  and header block
    HRESULT DVMuxerSamples( IMediaSample *pSampleOut ) ;

    // check if you can support this format
    HRESULT CanDVMuxerType(const CMediaType* mtIn) ;

    // create input video and audio pin
    virtual HRESULT CreatePins();

    // =================================================================
    // ----- End of DV DVMuxerer supplied functions -----------------------
    // =================================================================
    
    // contril streaming
    virtual HRESULT StartStreaming();
    virtual HRESULT StopStreaming();

    HRESULT DeliverEndOfStream();

    // chance to customize the DVMuxer process
    virtual HRESULT Receive( void );

    // Stream flushing
    virtual HRESULT BeginFlush(void);
    virtual HRESULT EndFlush(void);
    virtual HRESULT ReleaseAllQueuedSamples( void );

    HRESULT pExVidSample(   IMediaSample ** ppSample , BOOL fEndOfStream);

    // Critical sections
protected:
    CCritSec m_csFilter;                // filter wide lock
    CCritSec m_csMuxLock;               // mix lock
    CCritSec m_DisplayLock;

    // Pins
protected:
    int m_iInputPinCount;               // number of input pins
    int m_iInputPinsConnected;          // number connected
    CDVMuxerInputPin **m_apInput;// Array of input pin pointers
    CDVMuxerInputPin **m_apInputPin;// Array of input pin pointers
    CDVMuxerOutputPin *m_pOutput;// output pin

    // When do we send an end of stream signal?
protected:
	//DVmux only stop when the DV video input pin stop
	//   enum { StopWhenAllPinsStop, StopWhenFirstPinStops } m_StopMode;
    BOOL m_fEOSSent;

    // Current frame that we are working on
protected:
    //CRefTime    m_rtThisFrame;          // when will we mix?
    //CRefTime    m_rtNextFrame;          // this frame stop/next frame start

    // implement IMediaPosition by passing upstream
//protected:
    //CMultiPinPosPassThru * m_pPosition;
    //
    // --- CBaseVideoMixer Overrides --
    //

protected:
    HRESULT MixSamples( IMediaSample *pSampleOut );

private:
    enum TimeFormat
    {
	FORMAT_TIME
    } m_TimeFormat;


    CAudioSampleSizeSequence m_AudSampleSequence[DVMUX_MAX_AUDIO_PIN];

    WORD m_wMinAudSamples[DVMUX_MAX_AUDIO_PIN]; 
                // Min audio samples needed in current DV frame
    WORD m_wMaxAudSamples[DVMUX_MAX_AUDIO_PIN]; 
                // Max audio samples allowed in current DV frame
    WORD m_wAudSamplesBase[DVMUX_MAX_AUDIO_PIN];
                // The value added to the AF_SIZE field in the AAUX source pack to get the number of
                // audio samples in a DV frame

    CRefTime		m_LastVidTime;
    REFERENCE_TIME	m_LastVidMediatime;
    IMediaSample	*m_pLastVidSample;

    DVINFO		m_OutputDVFormat;


    LONG m_UsedAudSample[DVMUX_MAX_AUDIO_PIN];
		
    //shuffle audio
    HRESULT ScrambleAudio(BYTE *pDst, BYTE **pSrc, int  bAudPinInd, WORD *wSampleSize );

    	
    //input DV video has to be connected before muxing with audio
    BYTE    InputVideoConnected( void ) { if( m_apInput[DVMUX_VIDEO_INPUT_PIN] !=NULL ) return (BYTE)m_apInput[DVMUX_VIDEO_INPUT_PIN]->IsConnected(); else return NULL;};
    
    int	    m_iVideoFormat;


    BYTE    m_fWaiting_Audio;
    BYTE    m_fWaiting_Video;
    BYTE    m_fMuxStreaming;
    IMediaSample    *m_pExVidSample;
    BOOL    m_MediaTypeChanged;
    BOOL    m_DVINFOChanged; 
    DWORD   m_cNTSCSample;
    
};

#endif /* __DVDVMuxer__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\dvdgb3\dvdgb.h ===
// Copyright (c) Microsoft Corporation 1994-2000. All Rights Reserved

//
// A class managing list of HW and/or SW decoders used to build the DVD
// playback graph.
//
#define FILTERLIST_DEFAULT_MAX        10
#define FILTERLIST_DEFAULT_INC        10

class CFilterData {
    public:
        CFilterData(void) ;
        ~CFilterData(void) ;
        
        inline IBaseFilter * GetInterface(void)  { return m_pFilter ; } ;
        inline BOOL          IsHWFilter(void)    { return NULL == m_lpszwName ; } ;
        inline LPWSTR        GetName(void)       { return m_lpszwName ; } ;
        inline GUID        * GetClsid(void)      { return m_pClsid ; } ;
        void   SetElement(IBaseFilter *pFilter, LPCWSTR lpszwName, GUID *pClsid) ;
        void   ResetElement(void) ;

    private:
        IBaseFilter   *m_pFilter ;   // filter pointer
        LPWSTR         m_lpszwName ; // filter name (NULL for SW filters)
        GUID          *m_pClsid ;    // filter CLSID pointer
} ;

class CListFilters {

    public:  // class interface

        CListFilters(int iMax = FILTERLIST_DEFAULT_MAX, 
                     int iInc = FILTERLIST_DEFAULT_INC) ;
        ~CListFilters() ;

        BOOL AddFilter(IBaseFilter *pFilter, LPCWSTR lpszwName, GUID *pClsid) ;
        BOOL GetFilter(int iIndex, IBaseFilter **ppFilter, LPWSTR *lpszName) ;
        BOOL GetFilter(GUID *pClsid, int iIndex, IBaseFilter **ppFilter) ;
        BOOL IsInList(IBaseFilter *pFilter) ;
        void ClearList(void) ;
        void RemoveAllFromGraph(void) ;
        int  GetCount(void)                     { return m_iCount ; } ;
        void SetGraph(IGraphBuilder *pGraph)    { m_pGraph = pGraph ; } ;

    private:  // internal helper method

        BOOL ExpandList(void) ;

    private:  // internal data

        int             m_iCount ;    // number of filters (HW/SW) in the list
        int             m_iMax ;      // current max capacity of the list
        int             m_iInc ;      // increment for max capacity of list
        CFilterData    *m_pFilters ;  // list of filters
        IGraphBuilder  *m_pGraph ;    // filter graph pointer
} ;


//
// An internally defined stream flag to check line21 data rendering.
// Leave enough space for future stream flags.
//
#define AM_DVD_STREAM_LINE21      0x0080
// move the following two to dvdif.idl
#define AM_DVD_STREAM_ASF         0x0008
#define AM_DVD_STREAM_ADDITIONAL  0x0010

#define DVDGRAPH_FLAGSVALIDDEC    0x000F

//
// A set of internal flags to connect pins in various ways
//
#define AM_DVD_CONNECT_DIRECTONLY      0x01
#define AM_DVD_CONNECT_DIRECTFIRST     0x02
#define AM_DVD_CONNECT_INDIRECT        0x04

//
// The actual class object implementing IDvdGraphBuilder interface
//
class CDvdGraphBuilder : public CUnknown, public IDvdGraphBuilder
{

    public:  // methods

        CDvdGraphBuilder(TCHAR *, LPUNKNOWN, HRESULT *) ;
        ~CDvdGraphBuilder() ;

        DECLARE_IUNKNOWN

        // this goes in the factory template table to create new instances
        static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *) ;
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv) ;

        // IDvdGraphBuilder stuff
        STDMETHODIMP GetFiltergraph(IGraphBuilder **ppGB) ;
        STDMETHODIMP GetDvdInterface(REFIID riid, void **ppvIF) ;
        STDMETHODIMP RenderDvdVideoVolume(LPCWSTR lpcwszPathName, DWORD dwFlags,
                                          AM_DVD_RENDERSTATUS *pStatus) ;
#if 0
        STDMETHODIMP SetFiltergraph(IGraphBuilder *pGB) ;
#endif // #if 0

    private:  // internal helper methods

        HRESULT EnsureGraphExists(void) ;
        HRESULT CreateGraph(void) ;
        HRESULT DeleteGraph(void) ;
        HRESULT ClearGraph(void) ;
        void    StopGraph(void) ;
        // HRESULT RemoveAllFilters(void) ;
        HRESULT ResetDDrawParams(void) ;
        HRESULT EnsureOverlayMixerExists(void) ;
        HRESULT EnsureVMRExists(void) ;
        HRESULT CreateVMRInputPins(void) ;
        
        HRESULT RenderNavVideoOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderNavAudioOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderNavSubpicOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderNavASFOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderNavOtherOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT DecodeDVDStream(IPin *pPinOut, DWORD dwStream, DWORD *pdwDecFlag,
                                AM_DVD_RENDERSTATUS *pStatus, IPin **apPinOutDec) ;
        HRESULT HWDecodeDVDStream(IPin *pPinOut, DWORD dwStream, IPin **pPinIn,
                                   AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT SWDecodeDVDStream(IPin *pPinOut, DWORD dwStream, IPin **pPinIn,
                                   AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT ConnectPins(IPin *pPinOut, IPin *pPinIn, DWORD dwOption) ;
        HRESULT RenderDecodedVideo(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus,
                                   DWORD dwDecFlag) ;
        HRESULT RenderDecodedAudio(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderDecodedSubpic(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderLine21Stream(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderRemainingPins(void) ;
        BOOL    IsOutputDecoded(IPin *pPinOut) ;
        BOOL    IsOutputTypeVPVideo(IPin *pPinOut) ;

        HRESULT CreateFilterInGraph(CLSID Clsid,
                                    LPCWSTR lpszwFilterName, 
                                    IBaseFilter **ppFilter) ;
        HRESULT CreateDVDHWDecoders(void) ;
        HRESULT FindMatchingPin(IBaseFilter *pFilter, DWORD dwStream, 
                                PIN_DIRECTION pdWanted, BOOL bOpen, 
                                int iIndex, IPin **ppPin) ;
        DWORD GetStreamFromMediaType(AM_MEDIA_TYPE *pmt) ;
        DWORD   GetPinStreamType(IPin *pPin) ;
        HRESULT GetFilterCLSID(IBaseFilter *pFilter, DWORD dwStream, LPCWSTR lpszwName,
                               GUID *pClsid) ;
        HRESULT EnumFiltersBetweenPins(DWORD dwStream, IPin *pPinOut, IPin *pPinIn,
                                       AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderIntermediateOutPin(IBaseFilter *pFilter, DWORD dwStream, 
                                         AM_DVD_RENDERSTATUS *pStatus) ;
        void    CheckDDrawExclMode(void) ;
        inline  BOOL  IsDDrawExclMode(void)   { return m_bDDrawExclMode ; } ;
        IPin *  GetFilterForMediaType(DWORD dwStream, AM_MEDIA_TYPE *pmt, 
                                      IBaseFilter *pOutFilter) ;
        void ResetPinInterface(IPin **apPin, int iCount) ;
        void ReleasePinInterface(IPin **apPin) ;
        BOOL IsFilterVMRCompatible(IBaseFilter *pFilter) ;
        inline  BOOL  GetVMRUse(void)   { return m_bTryVMR ; } ;
        inline  void  SetVMRUse(BOOL bState)   { m_bTryVMR = bState ; } ;
        HRESULT RenderVideoUsingOvMixer(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderVideoUsingVMR(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderSubpicUsingOvMixer(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderSubpicUsingVMR(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderVideoUsingVPM(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus,
                                    IPin **ppPinOut) ;

    private:  // internal data

        IGraphBuilder *m_pGB ;        // the filter graph we are using
        IFilterMapper *m_pMapper ;    // filter mapper object pointer
        IBaseFilter   *m_pDVDNav ;    // our default DVD source -- DVD Nav
        IBaseFilter   *m_pOvM ;       // OverlayMixer filter
        IBaseFilter   *m_pL21Dec ;    // Line21 decoder filter
        IBaseFilter   *m_pAR ;        // Audio Renderer filter
        IBaseFilter   *m_pVR ;        // Video Renderer filter
        IBaseFilter   *m_pVPM ;       // Video Port Manager filter
        IBaseFilter   *m_pVMR ;       // Video Mixing Renderer filter

        CListFilters   m_ListHWDecs ; // list of WDM DVD decoder filters
        CListFilters   m_ListFilters ;// list of all decoder(-type) filters

        BOOL           m_bGraphDone ;  // has DVD graph been already built?
        BOOL           m_bUseVPE ;     // user wants to use VPE output?
        BOOL           m_bPinNotRendered ; // any out pin not rendered in normal run?
        BOOL           m_bDDrawExclMode ;  // building graph for DDraw exclusive mode?
        BOOL           m_bTryVMR ;     // try to VMR filter rather than OvM+VR?
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\attrib\mediaattrib.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        MediaAttrib.h

    Abstract:

        This module contains the IMediaSampleTagged declarations

    Author:

        John Bradstreet (johnbrad)

    Revision History:

        19-Mar-2002    created

  
	These interfaces stolen from: 
		F:\nt1\multimedia\Published\DXMDev\dshowdev\base\amfilter.h
		F:\nt1\multimedia\Published\DXMDev\dshowdev\base\amfilter.cpp

    Note to myself.
        Take a look at :
            class CImageSample : public CMediaSample
            class CImageAllocator : public CBaseAllocator

    in winutil.h and 

    
--*/

#ifndef __EncDec__MediaAttrib_h
#define __EncDec__MediaAttrib_h



//  ============================================================================
//      CMedSampAttr
//  ============================================================================



class CMedSampAttr
{
private:
    GUID            m_guidAttribute ;
    CComBSTR		m_spbsAttributeData ;
    DWORD           m_dwAttributeSize ;

public :

        CMedSampAttr *    m_pNext ;

        CMedSampAttr (
            ) ;

        ~CMedSampAttr(
            );

        HRESULT
        SetAttributeData (
            IN  GUID    guid,
            IN  LPVOID  pvData,
            IN  DWORD   dwSize
            ) ;

        BOOL
        IsEqual (
            IN  REFGUID rguid
            ) ;

        HRESULT
        GetAttribute (
            IN      GUID    guid,
            IN OUT  LPVOID  pvData,
            IN OUT  DWORD * pdwDataLen
            ) ;

        HRESULT
        GetAttributeData (
            OUT     GUID *  pguid,
            IN OUT  LPVOID  ppvData,
            IN OUT  DWORD * pdwDataLen
            ) ;
} ;
//  ============================================================================
//      CMedSampAttrList
//  ============================================================================

class CMedSampAttrList 
{
private:
    CMedSampAttr * m_pAttribListHead ;
    LONG            m_cAttributes ;

    CMedSampAttr *
    PopListHead_ (
        ) ;

    CMedSampAttr *
    FindInList_ (
        IN  GUID    guid
        ) ;

    CMedSampAttr *
    GetIndexed_ (
        IN  LONG    lIndex
        ) ;

    void
    InsertInList_ (
        IN  CMedSampAttr *
        ) ;

    virtual
    CMedSampAttr * NewObj_ (
        )
    {
        return new CMedSampAttr ;
    }

	virtual void
	Recycle_(CMedSampAttr *pObj)
	{
		delete pObj;
	}

public :

    CMedSampAttrList (
        ) ;

    ~CMedSampAttrList (
        ) ;

    HRESULT
    AddAttribute (
        IN  GUID    guid,
        IN  LPVOID  pvData,
        IN  DWORD   dwSize
        ) ;

    HRESULT
    GetAttribute (
        IN      GUID    guid,
        OUT     LPVOID  pvData,
        IN OUT  DWORD * pdwDataLen
        ) ;

    HRESULT
    GetAttributeIndexed (
        IN  LONG    lIndex,
        OUT GUID *  pguidAttribute,
        OUT LPVOID  pvData,
        IN OUT      DWORD * pdwDataLen
        ) ;

    LONG GetCount ()    { return m_cAttributes ; }

    void
    Reset (
        ) ;
} ;

//  ============================================================================
//  CAttributedMediaSample
//  ============================================================================

//  shamelessly stolen  dvrutil.h, which stole it from amfilter.h & amfilter.cpp

class CAttributedMediaSample :
        public CMediaSample,
        public IAttributeSet,
        public IAttributeGet
{

protected:
    CMedSampAttrList	m_MediaSampleAttributeList ;

public:
    CAttributedMediaSample(TCHAR			*pName,
						CBaseAllocator	*pAllocator,
						HRESULT			*pHR,
						LPBYTE			pBuffer,
						LONG			length);

    virtual ~CAttributedMediaSample();


    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
  
//    DECLARE_IATTRIBUTESET () ;
	STDMETHODIMP SetAttrib (GUID, BYTE *, DWORD);

//    DECLARE_IATTRIBUTEGET () ;
	STDMETHODIMP GetCount (LONG *) ;
	STDMETHODIMP GetAttribIndexed (LONG, GUID *, BYTE *, DWORD *) ; 
	STDMETHODIMP GetAttrib (GUID , BYTE *, DWORD *) ;


    //  ========================================================================

    HRESULT
    Wrap (IMediaSample *pSample, int cbNewOffset=0, int cbNewValidLength=-1);       // actually works better if it's IMediaSample2

private:
    LONG                m_cRef;
    IMediaSample        *m_pSampleOriginal;
};

    //  ========================================================================

class CAMSAllocator :
//	public IMemAllocator,
	public CBaseAllocator
{
private:
	BYTE *m_pBuffer;

public:
	CAMSAllocator(TCHAR * pName,LPUNKNOWN lpUnk,HRESULT * phr ); 
	CAMSAllocator(CHAR * pName,LPUNKNOWN lpUnk,HRESULT * phr ); 
	~CAMSAllocator();

	static CUnknown *CreateInstance(LPUNKNOWN pUnk,HRESULT *phr );
	HRESULT Alloc();
	void Free(void); 
	void ReallyFree (void);

	// IMemAllocator
	STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES * pRequest,ALLOCATOR_PROPERTIES * pActual );
};


#endif //#define __EncDec__MediaAttrib_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dll\encdec.cpp ===
/*++

    Copyright (c) 2002 Microsoft Corporation

    Module Name:

        EncDec.cpp

    Abstract:

        This module contains Encrypter/Decrypter filter
        registration data and entry points

    Author:

        John Bradstreet  (johnbrad)

    Revision History:

        07-Mar-2002     created

--*/

#define INITGUID_FOR_ENCDEC   //  cause CLSIDs to get linked in...
#include "EncDecAll.h"

#include "ETFilter.h"       // encrypter-tagger filter
#include "ETFiltProps.h"    // encrypter-tagger property pages

#include "DTFilter.h"       // decrypter-tagger filter
#include "DTFiltProps.h"    // decrypter-tagger property pages

#include "XDSCodec.h"       // XDS Codec filter
#include "XDSCodecProps.h"  // XDS Codec property pages

#include "RegKey.h"         // add in the Registry code

#include "uuids.h"          // CLSID_ActiveMovieCategories

//#include "TvRatings_i.c"  // CLSID_XDSToRat and IID_IXDSToRat (TODO: remove when move)
//#include "EncDec_i.c"     // CLSID_XDSCodec, ETFilter, DTFilter, and IID's of same

#include "DRMSecure.h"       // to get SID_DRM... defined into the EncDec.dll

#ifdef EHOME_WMI_INSTRUMENTATION
#include <dxmperf.h>
#endif

            // I'm not sure where tehse end up bing displayed
#define CLSID_CPCAFiltersCategory_NAME  L"BDA CP/CA Filters"

#define ETFILTER_DISPLAY_NAME               L"Encrypt/Tag"
#define ETFILTER_ENC_PROPPAGE_NAME          L"Encrypt"
#define ETFILTER_TAG_PROPPAGE_NAME          L"Tags"

#define DTFILTER_DISPLAY_NAME               L"Decrypt/Tag"
#define DTFILTER_DEC_PROPPAGE_NAME          L"Decrypt"
#define DTFILTER_TAG_PROPPAGE_NAME          L"Tags"


#define XDSCODEC_DISPLAY_NAME               L"XDS Codec"
#define XDSCODEC_PROPPAGE_NAME              L"Properties"
#define XDSCODEC_TAG_PROPPAGE_NAME          L"Tags"

// -----------------------------
//  registration templates (DShow's version of CoClasses)

static WCHAR g_wszCategory[] = CLSID_CPCAFiltersCategory_NAME;

#define USE_CATEGORIES

CFactoryTemplate
g_Templates[] = {

    //  ========================================================================
    //  Encypter-Tagger Filter
    //  code in ..\ETFilter

    {   ETFILTER_DISPLAY_NAME,                      //  display name
        & CLSID_ETFilter,                           //  CLSID
        CETFilter::CreateInstance,                  //  called for each filter created
        CETFilter::InitInstance,                    //  called once on DLL created
        & g_sudETFilter
    },

    // Encrypter-Tagger property page
    {
        ETFILTER_ENC_PROPPAGE_NAME,                 // display name
        & CLSID_ETFilterEncProperties,              // CLSID
        CETFilterEncProperties::CreateInstance,     
        NULL,                                       //
        NULL                                        //  not dshow related
    },

    // Encrypter-Tagger property page
    {
        ETFILTER_TAG_PROPPAGE_NAME,                 // display name
        & CLSID_ETFilterTagProperties,              // CLSID
        CETFilterTagProperties::CreateInstance,
        NULL,                                       //
        NULL                                        //  not dshow related
    },

    //  ========================================================================
    //  Decypter-Tagger Filter
    //  code in ..\DTFilter

        {   DTFILTER_DISPLAY_NAME,                      //  display name
        & CLSID_DTFilter,                           //  CLSID
        CDTFilter::CreateInstance,                  //  CreateInstance method
        CDTFilter::InitInstance,                    //  called once on DLL created
        & g_sudDTFilter
    },

    // Decrypter-Tagger property page
    {
        DTFILTER_DEC_PROPPAGE_NAME,                 // display name
        & CLSID_DTFilterEncProperties,              // CLSID
        CDTFilterEncProperties::CreateInstance,     
        NULL,                                       //
        NULL                                        //  not dshow related
    },

    // Decrypter-Tagger property page
    {
        DTFILTER_TAG_PROPPAGE_NAME,                 // display name
        & CLSID_DTFilterTagProperties,              // CLSID
        CDTFilterTagProperties::CreateInstance,
        NULL,                                       //
        NULL                                        //  not dshow related
    },

    //  ========================================================================
    //  XDS Codec Filter
    //  code in ..\XDSCodec

        {   XDSCODEC_DISPLAY_NAME,                      //  display name
        & CLSID_XDSCodec,                           //  CLSID
        CXDSCodec::CreateInstance,                  //  CreateInstance method
        NULL,
        & g_sudXDSCodec
    },

    // Decrypter-Tagger property page
    {
        XDSCODEC_PROPPAGE_NAME,                     // display name
        & CLSID_XDSCodecProperties,                 // CLSID
        CXDSCodecProperties::CreateInstance,        
        NULL,                                       //
        NULL                                        //  not dshow related
    },

    // Decrypter-Tagger property page
    {
        XDSCODEC_TAG_PROPPAGE_NAME,                 // display name
        & CLSID_XDSCodecTagProperties,              // CLSID
        CXDSCodecTagProperties::CreateInstance,
        NULL,                                       //
        NULL                                        //  not dshow related
    }
};      // end of g_Templates

int g_cTemplates = NUMELMS(g_Templates);

REGFILTER2  rf2CACPins =
{
    1,                  // version
    MERIT_DO_NOT_USE,   // merit
    0,                  // number of pins
    NULL
};


// -------------------------------------------------------------------
//  Utility Methods
BOOL
IsXPe (
    )
{
    OSVERSIONINFOEX Version ;
    BOOL            r ;

    Version.dwOSVersionInfoSize = sizeof OSVERSIONINFOEX ;

    ::GetVersionEx (reinterpret_cast <LPOSVERSIONINFO> (& Version)) ;

    r = ((Version.wSuiteMask & VER_SUITE_EMBEDDEDNT) ? TRUE : FALSE) ;

    return r ;
}

BOOL
CheckOS ()
{
    BOOL    r ;

#ifdef XPE_ONLY
    #pragma message("XPe bits only")
    r = ::IsXPe () ;
#else
    r = TRUE ;
#endif

    return r ;
}

// -------------------------------------------------------------------
//
// DllRegisterSever
//
// Handle the registration of this filter
//
STDAPI DllRegisterServer()
{
    HRESULT hr = S_OK;

    CComPtr<IFilterMapper2> spFm2;

    if (!::CheckOS ()) {
        return E_UNEXPECTED ;
    }

    hr = AMovieDllRegisterServer2 (TRUE);
    if(FAILED(hr))
        return hr;

#ifdef USE_CATEGORIES
    hr = CoCreateInstance( CLSID_FilterMapper2,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IFilterMapper2,
                             (void **)&spFm2
                             );

    if(FAILED(hr))
        return hr;

    hr = spFm2->CreateCategory(CLSID_CPCAFiltersCategory,
                               MERIT_NORMAL,
                               g_wszCategory
                             );
    if( FAILED(hr) )
        return hr;


    hr = spFm2->RegisterFilter(
                        CLSID_ETFilter,
                        ETFILTER_DISPLAY_NAME,              // name shown to the user
                        0,                                  // device moniker
                        &CLSID_CPCAFiltersCategory,
                        ETFILTER_DISPLAY_NAME,              // unique instance name
                        &rf2CACPins
                        );
    if( FAILED(hr) )
        return hr;

    hr = spFm2->RegisterFilter(
                        CLSID_DTFilter,
                        DTFILTER_DISPLAY_NAME,              // name shown to the user
                        0,                                  // device moniker
                        &CLSID_CPCAFiltersCategory,
                        DTFILTER_DISPLAY_NAME,              // unique instance name
                        &rf2CACPins
                        );
    if( FAILED(hr) )
        return hr;

    hr = spFm2->RegisterFilter(
                        CLSID_XDSCodec,
                        XDSCODEC_DISPLAY_NAME,              // name shown to the user
                        0,                                  // device moniker
                        &CLSID_CPCAFiltersCategory,
                        XDSCODEC_DISPLAY_NAME,              // unique instance name
                        &rf2CACPins
                        );
    if( FAILED(hr) )
        return hr;

            // now remove them from the DSHOW category
     hr = spFm2->UnregisterFilter(
                         &CLSID_LegacyAmFilterCategory,
                         NULL, //ETFILTER_DISPLAY_NAME,              // name shown to the user
                         CLSID_ETFilter
                        );

     hr = spFm2->UnregisterFilter(
                         &CLSID_LegacyAmFilterCategory,
                         NULL, //DTFILTER_DISPLAY_NAME,              // name shown to the user
                         CLSID_DTFilter
                        );

     hr = spFm2->UnregisterFilter(
                         &CLSID_LegacyAmFilterCategory,
                         NULL, //XDSCODEC_DISPLAY_NAME,              // name shown to the user
                         CLSID_XDSCodec
                        );
        // ignore errors in above Unregister calls (is this wise?)
     hr = S_OK;

#endif



    DWORD dwCSFlags = DEF_CSFLAGS_INITVAL;
#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS

#ifdef REGISTRY_KEY_DEFAULT_IS_CS_OFF
    dwCSFlags = DEF_CS_DEBUG_DOGFOOD_ENC_VAL;       // 0x0
#else
    dwCSFlags = DEF_CS_DEBUG_DRM_ENC_VAL;           // 0x1
#endif

#ifdef DREGISTRY_KEY_DEFAULT_IS_TRUST_ANY_SERVER
    dwCSFlags |= DEF_CS_DONT_AUTHENTICATE_SERVER;   // 0x00
#else
    dwCSFlags |= DEF_CS_DO_AUTHENTICATE_SERVER;     // 0x10
#endif

#endif

     DWORD dwRatFlag = DEF_CSFLAGS_INITVAL;      // INITVAL means don't write the flags
#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_RATINGS
#ifdef REGISTRY_KEY_DEFAULT_IS_RATINGS_OFF
    dwRatFlag = DEF_DONT_DO_RATINGS_BLOCK;          // 0
#else
    dwRatFlag = DEF_DO_RATINGS_BLOCK;               // 1
#endif
#endif

                // what's currently out there...
    DWORD dwCSFlags_Curr = DEF_CSFLAGS_INITVAL;
    DWORD dwRatFlag_Curr = DEF_CSFLAGS_INITVAL;
    hr = Get_EncDec_RegEntries(NULL, 0, NULL, &dwCSFlags_Curr, &dwRatFlag_Curr);

                // if not the default values, then overwrite them...
    if(dwCSFlags_Curr == DEF_CSFLAGS_INITVAL &&
       dwCSFlags      != DEF_CSFLAGS_INITVAL)
        Set_EncDec_RegEntries(NULL, 0, NULL, dwCSFlags, DEF_CSFLAGS_INITVAL);

    if(dwRatFlag_Curr == DEF_CSFLAGS_INITVAL &&
       dwRatFlag      != DEF_CSFLAGS_INITVAL)
        Set_EncDec_RegEntries(NULL, 0, NULL, DEF_CSFLAGS_INITVAL, dwRatFlag);

    return hr;
}

//
// DllUnregsiterServer
//
STDAPI DllUnregisterServer()
{

    HRESULT hr = S_OK;

    if (!::CheckOS ()) {
        return E_UNEXPECTED ;
    }

#ifdef USE_CATEGORIES
    CComPtr<IFilterMapper2> spFm2;
    hr = CoCreateInstance( CLSID_FilterMapper2,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IFilterMapper2,
                             (void **)&spFm2
                             );

    if(FAILED(hr))
        return hr;

     hr = spFm2->UnregisterFilter(
                         &CLSID_CPCAFiltersCategory,
                         ETFILTER_DISPLAY_NAME,              // name shown to the user
                         CLSID_ETFilter
                        );

     hr = spFm2->UnregisterFilter(
                         &CLSID_CPCAFiltersCategory,
                         DTFILTER_DISPLAY_NAME,              // name shown to the user
                         CLSID_DTFilter
                        );

     hr = spFm2->UnregisterFilter(
                         &CLSID_CPCAFiltersCategory,
                         XDSCODEC_DISPLAY_NAME,              // name shown to the user
                         CLSID_XDSCodec
                        );


     // ignore the return value here.. don't care if it fails or not (I think!)
#endif

    Remove_EncDec_RegEntries();     // do I really want to remove the KID?

    return AMovieDllRegisterServer2 (FALSE);
}

//  ============================================================================
//  perf-related follows (largely stolen from quartz.cpp)

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);

BOOL
WINAPI
DllMain (
    HINSTANCE   hInstance,
    ULONG       ulReason,
    LPVOID      pv
    )
{
    switch (ulReason)
    {
        case DLL_PROCESS_ATTACH :
//            EncDecPerfInit () ;

#ifdef EHOME_WMI_INSTRUMENTATION
            PERFLOG_LOGGING_PARAMS       Params;
            Params.ControlGuid = GUID_DSHOW_CTL;
            Params.OnStateChanged = NULL;
            Params.NumberOfTraceGuids = 1;
            Params.TraceGuids[0].Guid = &GUID_STREAMTRACE;
            PerflogInitIfEnabled( hInstance, &Params );
#endif
            break;

        case DLL_PROCESS_DETACH:
//            EncDecPerfUninit () ;
#ifdef EHOME_WMI_INSTRUMENTATION
              PerflogShutdown();
#endif
            break;
    }

    return DllEntryPoint (
                hInstance,
                ulReason,
                pv
                ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\encdec.inc ===
!if 0
Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
!endif

# ---------------------------------------------
#  encdec.inc
#  
#     Common configuration parameters for the whole encdec project
#
#------------------------------------------------
    # We want the XP version of the code, not the Win2K one.  
    #   The problem is that the !include $(ROOT)\common.inc  line in the 'sources' files
    #   are pulling the DShow version, which is defining it as 0x500.
WIN32_WINNT_VERSION = 0x0501

#------------------------------------------------
    # set to 0 to not use DRM (won't be able to debug if using DRM)
    # - in shipping app, this should be =1

!if $(IA64) || $(AMD64)             #don't do DRM or Obfuscate IA64 builds, we don't have libs for it yet
BUILD_WITH_DRM = 0      
BUILD_WITH_OBFUS = 0    
!else

!if !$(FREEBUILD)       # debug build

#BUILD_WITH_DRM=0        # (provided for testing)
BUILD_WITH_DRM=1        #debug build - use DRM
BUILD_WITH_OBFUS=0		# don't obfuscate in debug build, lots of errors

!else                   # retail build

#BUILD_WITH_DRM=0        # (provided for testing)
BUILD_WITH_DRM=1        # retail build, require DRM 
BUILD_WITH_OBFUS=0      # don't obfuscate in retail build yet - perf problems

!endif
!endif

#-----------------------------------------------
	#   To obfuscate the code, we need to do a couple of things
	#	At this level, need to build with /Zi (Codeview debugging information)
	#     for more details in the dll\Sources file
	#   Obfuscation controled by the following variable(s)


						    # turn on security/buffer-overflow checks
!if $(BUILD_WITH_OBFUS)
C_DEFINES=$(C_DEFINES) -DOBFUS 

!undef NO_STRING_POOLING	# turn on /GF (see  i386mk.inc)		
!endif

#------------------------------------------------
#  All builds
						    # turn on /GS  (see http://swiweb/bufferoverruns/gs.html)
BUFFER_OVERFLOW_CHECKS=1

	# set the maximum time to use any one license (in hours) - must be at least 1, or not defined at all (infinity)
	# - in shipping app, should be 2-4 weeks 
C_DEFINES    = $(C_DEFINES) -DMAX_LICENSE_AGE_IN_HRS=(24*7*2)

#------------------------------------------------
#   DRM turned on ? (all builds)

!if $(BUILD_WITH_DRM)   # -------------------------- DRM Only
C_DEFINES	= $(C_DEFINES)  -DBUILD_WITH_DRM

    # set this comment to make the default case ((when registy key support is allowed) to trust any server, rather than authenticated ones
    # - in shipping app, this doesn't matter. In pre-shipping, this should be commented out
#C_DEFINES    = $(C_DEFINES) -DREGISTRY_KEY_DEFAULT_IS_TRUST_ANY_SERVER

    # set this comment to use the test (7001) certificate with EncDec.  Else use real (7002) one
    # -- in shipping app, should be commented out  (See inc\DrmKeys.h for it's use)
#C_DEFINES    = $(C_DEFINES) -DUSE_TEST_DRM_CERT

    # remove comment not require decrypter filter to verify it's running in a trusted app (fails in Connect)
    # - in shipping app, should be commented 
#C_DEFINES   = $(C_DEFINES) -DFILTERS_CAN_CREATE_THEIR_OWN_TRUST

    # remove comment if want to allow non-DRM encryption when DRM is turned on
    # - in shipping app, should be commented out..
#C_DEFINES    = $(C_DEFINES) -DALLOW_NON_DRM_ENCRYPTION


!else                   # ---------------------------- No DRM
    
    # allows non-drm encryption...
    # - leave in for shipping app, the BUILD_WITH_DRM turns it off
C_DEFINES    = $(C_DEFINES) -DALLOW_NON_DRM_ENCRYPTION

!endif                  

#------------------------------------------------
#   Checked builds

!if !$(FREEBUILD)       # ---------------------------- Checked Build Only

!if $(BUILD_WITH_DRM)           # -------- (if DRM allowed, set key)
    # set this comment to allow a registry entry to turn on/off CS (DRM) in running code so we can debug it
    # - in shipping app, should be commented out

C_DEFINES    = $(C_DEFINES) -DSUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS

    # set this comment to make the default case (when registy key support is allowed) to use dogfood rather than DRM
    # - in shipping app, this doesn't matter. In pre-shipping, this should be commented out
#C_DEFINES    = $(C_DEFINES) -DREGISTRY_KEY_DEFAULT_IS_CS_OFF
!endif                          # -------- 

    # must be defined if allow Key to turn off CS.  Else encrypter fails
C_DEFINES    = $(C_DEFINES) -DALLOW_NON_DRM_ENCRYPTION

    # set this comment to allow a registry entry to turn on ratings blocking
    # - in shipping app, should be commented
C_DEFINES    = $(C_DEFINES) -DSUPPORT_REGISTRY_KEY_TO_TURN_OFF_RATINGS

    # set this comment to make the default case (when registy key support is allowed) to use dogfood rather than DRM
    # - in shipping app, this doesn't matter. In pre-shipping, this should be commented out
#C_DEFINES    = $(C_DEFINES) -DREGISTRY_KEY_DEFAULT_IS_RATINGS_OFF

!endif  

#------------------------------------------------
#   Old stuff

	# remove comment if trying to connect to PVR without Matthijs's media SDK changes
    # leave comment if have got his new code...
    # - in shipping app, should be commented 
#C_DEFINES   = $(C_DEFINES) -DDONT_CHANGE_EDTFILTER_MEDIATYPE

#------------------------------------------------

    # define to pull out the DropQueue
    # - in shipping app, should be commented out
#C_DEFINES	= $(C_DEFINES)  -DSIMPLIFY_THINGS

# ----------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dll\packtvrat.cpp ===
/*++

    Copyright (c) 2002 Microsoft Corporation

 
    Module Name:

        PackTvRat.cpp

    Abstract:

        methods to convert between 3-part rating format and the packed format
    Author:

        John Bradstreet  (johnbrad)

    Revision History:

        15-Mar-2002     created

--*/

#include "EncDecAll.h"
#include "TvRatings.h"
#include "EncDec.h"         // just to get PackedTvRating TypeDef.  Seems overkill
#include "PackTvRat.h"

HRESULT 
UnpackTvRating(
			IN	PackedTvRating			    TvRating,
			OUT	EnTvRat_System			    *pEnSystem,
			OUT	EnTvRat_GenericLevel	    *pEnLevel,
			OUT	LONG                    	*plbfEnAttributes    // BfEnTvRat_GenericAttributes	
			)
{
	if(NULL == pEnSystem || NULL == pEnLevel || NULL == plbfEnAttributes)
		return E_POINTER;

	UTvRating um;
	memset((void *) &um, 0, sizeof(UTvRating));

	if(um.sr.s_System >= TvRat_kSystems &&
		um.sr.s_System != TvRat_SystemDontKnow) return E_INVALIDARG;
	if(um.sr.s_Level  >= TvRat_kLevels &&
		um.sr.s_Level != TvRat_LevelDontKnow)  return E_INVALIDARG;

	um.pr = TvRating;
	*pEnSystem			= (EnTvRat_System) um.sr.s_System;
	*pEnLevel			= (EnTvRat_GenericLevel) um.sr.s_Level;
	*plbfEnAttributes	= (DWORD)  um.sr.s_Attributes;
	return S_OK;
}

HRESULT
PackTvRating(
			IN	EnTvRat_System			    enSystem,
			IN	EnTvRat_GenericLevel	    enLevel,
			IN	LONG                    	lbfEnAttributes, // BfEnTvRat_GenericAttributes
			OUT PackedTvRating			    *pTvRating
			)
{
	if(NULL == pTvRating)
		return E_POINTER;

	UTvRating um;
	memset((void *) &um, 0, sizeof(UTvRating));
	um.sr.s_System = TvRat_SystemDontKnow;
	um.sr.s_Level  = TvRat_LevelDontKnow;

	if(enSystem >= TvRat_kSystems &&
		enSystem != TvRat_SystemDontKnow) return E_INVALIDARG;
	if(enLevel  >= TvRat_kLevels &&
		enLevel != TvRat_LevelDontKnow)  return E_INVALIDARG;

	um.sr.s_System		= enSystem;
	um.sr.s_Level		= enLevel;
	um.sr.s_Attributes	= lbfEnAttributes;

	*pTvRating = um.pr;

	return S_OK;

}


// ---------------------------------------------------------

HRESULT
RatingToString( IN	EnTvRat_System              enSystem,
                IN	EnTvRat_GenericLevel        enLevel,
                IN	LONG                    	lbfEnAttributes, // BfEnTvRat_GenericAttributes
                IN  TCHAR	*pszBuff,
                IN  int		cBuff)
{
	if(pszBuff == NULL)
		return E_POINTER;

	if(cBuff < 64) 
		return E_INVALIDARG;		// always make it's large enough..

	int cMaxChars = cBuff;

	TCHAR *pb = pszBuff;
	*pb = 0;
	switch(enSystem)
	{
	case TvRat_SystemDontKnow: 
		{
			_tcsncat(pszBuff,L"DontKnow",cMaxChars); cMaxChars-=8;
		}
		break;

	case MPAA: 
		{
			_tcsncat(pszBuff,L"MPAA-",cMaxChars); cMaxChars-=5;
			switch(enLevel)
			{
				case MPAA_NotApplicable: _tcsncat(pszBuff,L"NA",cMaxChars); cMaxChars-=2; break;
				case MPAA_G:		_tcsncat(pszBuff,L"G",cMaxChars); cMaxChars-=1; break;
				case MPAA_PG:		_tcsncat(pszBuff,L"PG",cMaxChars); cMaxChars-=2; break;
				case MPAA_PG13:		_tcsncat(pszBuff,L"PG13",cMaxChars); cMaxChars-=4; break;
				case MPAA_R:		_tcsncat(pszBuff,L"R",cMaxChars); cMaxChars-=1; break;
				case MPAA_NC17:		_tcsncat(pszBuff,L"NC17",cMaxChars); cMaxChars-=4; break;
				case MPAA_X:		_tcsncat(pszBuff,L"X",cMaxChars); cMaxChars-=1; break;
				default:
				case MPAA_NotRated:	_tcsncat(pszBuff,L"NR",cMaxChars); cMaxChars-=2; break;
			}
		}
		break;
			
	case US_TV:
		{
			_tcsncat(pszBuff,L"TV-",  cMaxChars); cMaxChars-=5;
			switch(enLevel)
			{
				case US_TV_None:	_tcsncat(pszBuff,L"E",cMaxChars); cMaxChars-=1; break;
				case US_TV_Y:		_tcsncat(pszBuff,L"Y",cMaxChars); cMaxChars-=1; break;
				case US_TV_Y7:		_tcsncat(pszBuff,L"Y7",cMaxChars); cMaxChars-=2; break;
				case US_TV_G:		_tcsncat(pszBuff,L"G",cMaxChars); cMaxChars-=1; break;
				case US_TV_PG:		_tcsncat(pszBuff,L"PG",cMaxChars); cMaxChars-=2; break;
				case US_TV_14:		_tcsncat(pszBuff,L"14",cMaxChars); cMaxChars-=2; break;
				case US_TV_MA:		_tcsncat(pszBuff,L"MA",cMaxChars); cMaxChars-=2; break;
				default:
				case US_TV_None7:   _tcsncat(pszBuff,L"None",cMaxChars); cMaxChars-=4; break;

			}
							
		}
		break;

	case Canadian_English:
		{
			_tcsncat(pszBuff,L"CETV-",cMaxChars); cMaxChars-=5;						
			switch(enLevel)
			{
			case 0:
			default: _tcsncat(pszBuff,L"<not done>",cMaxChars); cMaxChars-=13; break;
			}
		}
		break;

	case Canadian_French:
		{
			_tcsncat(pszBuff,L"CFTV-",cMaxChars); cMaxChars-=5; 							
			switch(enLevel)
			{
			case 0:
			default: _tcsncat(pszBuff,L"<not done>",cMaxChars); cMaxChars-=13; break;
			}
		}
		break;

	case System5:
		{
			_tcsncat(pszBuff,L"Sys5-",cMaxChars); cMaxChars-=5; 							
			switch(enLevel)
			{
			case 0:
			default: _tcsncat(pszBuff,L"<not done>",cMaxChars); cMaxChars-=10; break;
			}
		}
		break;

	case System6:
		{
			_tcsncat(pszBuff,L"Sys6-",cMaxChars); cMaxChars-=5; 							
		}
			switch(enLevel)
			{
			case 0:
			default: _tcsncat(pszBuff,L"<not done>",cMaxChars); cMaxChars-=10; break;
			}
		break;

	default:
		{
			_tcsncat(pszBuff,L"Sys?-",cMaxChars); cMaxChars-=5; 							
			switch(enLevel)
			{
			case 0:
			default: _tcsncat(pszBuff,L"<not done>",cMaxChars); cMaxChars-=10; break;
			}
		}
		break;

	}

	switch(enSystem)
	{
	case US_TV:
//		if(bfEnAttributes & (US_TV_ValidAttrSubmask & ~BfIsBlocked))
//                                                          _tcsncat(pszBuff,L"-",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & (BfValidAttrSubmask & ~BfIsBlocked))
                                                            _tcsncat(pszBuff,L"-",cMaxChars);  cMaxChars-=1;
                    // BfIsBlocked should not be set on anything but Max ratings to test against
		if(lbfEnAttributes & BfIsBlocked)                    _tcsncat(pszBuff,L"<B>",cMaxChars);cMaxChars-=3;
		if(lbfEnAttributes & US_TV_IsViolent)				_tcsncat(pszBuff,L"V",cMaxChars);  cMaxChars-=1; 
		if(lbfEnAttributes & US_TV_IsSexualSituation)		_tcsncat(pszBuff,L"S",cMaxChars);  cMaxChars-=1; 
		if(lbfEnAttributes & US_TV_IsAdultLanguage)			_tcsncat(pszBuff,L"L",cMaxChars);  cMaxChars-=1; 
		if(lbfEnAttributes & US_TV_IsSexuallySuggestiveDialog) _tcsncat(pszBuff,L"D",cMaxChars); cMaxChars-=1; 
		if(lbfEnAttributes & BfIsAttr_5)                     _tcsncat(pszBuff,L"5",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & BfIsAttr_6)                     _tcsncat(pszBuff,L"6",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & BfIsAttr_7)                     _tcsncat(pszBuff,L"7",cMaxChars);  cMaxChars-=1;
 		break;
	case Canadian_English:          // if any attributes here (if real standard shouldn't be)
 	case Canadian_French:           //    show them anyway
    case MPAA:
    default:            
		if(lbfEnAttributes & (BfValidAttrSubmask & ~BfIsBlocked))
                                                _tcsncat(pszBuff,L"-",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & BfIsBlocked)        _tcsncat(pszBuff,L"<B>",cMaxChars);  cMaxChars-=3;
		if(lbfEnAttributes & BfIsAttr_1)         _tcsncat(pszBuff,L"1",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & BfIsAttr_2)         _tcsncat(pszBuff,L"2",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & BfIsAttr_3)         _tcsncat(pszBuff,L"3",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & BfIsAttr_4)         _tcsncat(pszBuff,L"4",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & BfIsAttr_5)         _tcsncat(pszBuff,L"5",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & BfIsAttr_6)         _tcsncat(pszBuff,L"6",cMaxChars);  cMaxChars-=1;
		if(lbfEnAttributes & BfIsAttr_7)         _tcsncat(pszBuff,L"7",cMaxChars);  cMaxChars-=1;
  	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\attrib\attrblock.cpp ===
/*++

    Copyright (c) 2002 Microsoft Corporation

    Module Name:

        AttrBlock.cpp

    Abstract:

        This module contains the currently rather private implementation
        of attribute blocks

    Author:

        J.Bradstreet (johnbrad)

    Revision History:

        25-Mar-2002    created

--*/

#include "EncDecAll.h"
#include "AttrBlock.h"


/*
#ifdef _DEBUG
#include <crtdbg.h>
#define new DEBUG_NEW
#undef THIS_FILE
#define char THIS_FILE[] = __FILE__;
#endif
*/

// -------------------------------------------------------
// -------------------------------------------------------

CAttrSubBlock::CAttrSubBlock()
{
    memset(this, 0, sizeof(CAttrSubBlock));
    m_enSubBlock_Class = SubBlock_Uninitialized;
}

CAttrSubBlock::~CAttrSubBlock()
{
    m_spbsData.Empty();      // do here so I can watch the deallocation
}

// returns allocated copy of the data


HRESULT 
CAttrSubBlock::Get(
    EnAttrSubBlock_Class *pEnSubBlock_Class, 
    LONG *pSubBlock_SubClass,        // can be a 'value'
    BSTR *pBstrOut                   // can be null
    )
{   
    if(NULL == pEnSubBlock_Class || NULL == pSubBlock_SubClass)
        return E_POINTER;
    *pEnSubBlock_Class     = (EnAttrSubBlock_Class) m_enSubBlock_Class;
    *pSubBlock_SubClass    = m_subBlock_SubClass;
    if(pBstrOut)
        m_spbsData.CopyTo(pBstrOut);
    return S_OK;
}

HRESULT 
CAttrSubBlock::Set(
    EnAttrSubBlock_Class enSubBlock_Class, 
    LONG subBlock_SubClass,         // can be a value...
    BSTR bstrIn
    )
{
    if(enSubBlock_Class < 0 || enSubBlock_Class >= SubBlock_Last) 
        return E_INVALIDARG;
    
    m_enSubBlock_Class  = enSubBlock_Class;
    m_subBlock_SubClass = subBlock_SubClass;
    m_spbsData = bstrIn;
    return S_OK;
}

HRESULT 
CAttrSubBlock::Set(
    EnAttrSubBlock_Class    enSubBlock_Class, 
    LONG                    lValue,
    LONG                    cbData,
    BYTE                   *pbDataIn
    )
{
    if(NULL == pbDataIn)
        return E_INVALIDARG;

    m_enSubBlock_Class  = enSubBlock_Class;    // well defined Class

    m_subBlock_SubClass = lValue;    // 
   
    int cwChars = (cbData + 1)/sizeof(WCHAR);
    m_spbsData = CComBSTR(cwChars);
    m_spbsData.m_str[cwChars-1] = 0;            // null terminate the extra byte if odd

    if(NULL == m_spbsData.m_str)
        return E_OUTOFMEMORY;
    
    char *pbData = (char *) m_spbsData.m_str;       // ?? Some sort of casting going on here? Check disassembly
    memcpy(pbData,  pbDataIn,     cbData);
 
    return S_OK;
}

HRESULT 
CAttrSubBlock::Get(
    EnAttrSubBlock_Class *pEnSubBlock_Class, 
    LONG *pSubBlock_SubClass,        // cal be a 'value'
    LONG *pcbData,
    BYTE **ppbData                  // can be null - free with CoTaskMemFree
    )
{   
    if(NULL == pEnSubBlock_Class || NULL == pSubBlock_SubClass)
        return E_POINTER;
    if(NULL == pcbData)
        return E_POINTER;

    *pEnSubBlock_Class     = (EnAttrSubBlock_Class) m_enSubBlock_Class;
    *pSubBlock_SubClass    = m_subBlock_SubClass;
    *pcbData               = SysStringByteLen(m_spbsData);  // hum, odd length problems here

    if(*pcbData > 0 && ppbData != NULL) {
        *ppbData =  (BYTE *) CoTaskMemAlloc(*pcbData);
        if(NULL == *ppbData)
            return E_OUTOFMEMORY;
        memcpy(*ppbData, m_spbsData.m_str, *pcbData);
    }
    return S_OK;
}
// ---------------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------------

//  ============================================================================
//      CAttrSubBlock_List
//  ============================================================================

CAttrSubBlock_List::CAttrSubBlock_List (
    ) : m_pAttrListHead   (NULL),
        m_cAttributes       (0)
{
}

CAttrSubBlock_List::~CAttrSubBlock_List (
    )
{
    Reset() ;
}



CAttrSubBlock *
CAttrSubBlock_List::PopListHead_ (
    )
{
    CAttrSubBlock *    pCur ;

    pCur = m_pAttrListHead ;
    if (pCur) {
        m_pAttrListHead =  m_pAttrListHead->m_pNext ;
        pCur->m_pNext = NULL ;

        ASSERT (m_cAttributes > 0) ;
        m_cAttributes-- ;
    }

    return pCur ;
}

CAttrSubBlock *
CAttrSubBlock_List::GetIndexed_ (
    IN  LONG    lIndex
    )
{
    LONG            lCur ;
    CAttrSubBlock * pCur ;

    ASSERT (lIndex < GetCount ()) ;
    ASSERT (lIndex >= 0) ;

    for (lCur = 0, pCur = m_pAttrListHead;
         lCur < lIndex;
         lCur++, pCur = pCur->m_pNext) ;

    return pCur ;
}


CAttrSubBlock *
CAttrSubBlock_List::FindInList_ (
    IN  EnAttrSubBlock_Class    enClass
    )
{
    CAttrSubBlock *    pCur ;

    for (pCur = m_pAttrListHead;
         pCur && !pCur->IsEqual(enClass);
         pCur = pCur->m_pNext) ;

    return pCur ;
}



CAttrSubBlock *
CAttrSubBlock_List::FindInList_ (
    IN  EnAttrSubBlock_Class    enClass,
    IN  LONG                    subClass
    )
{
    CAttrSubBlock *    pCur ;

    for (pCur = m_pAttrListHead;
         pCur && !pCur->IsEqual(enClass, subClass);
         pCur = pCur->m_pNext) ;

    return pCur ;
}


HRESULT
CAttrSubBlock_List::InsertInList_(
    IN  CAttrSubBlock *    pNew
    )
{
    pNew -> m_pNext = m_pAttrListHead ;
    m_pAttrListHead = pNew;

    m_cAttributes++ ;
    return S_OK;
}

HRESULT
CAttrSubBlock_List::DeleteFromList_(
    IN CAttrSubBlock * pToDelete
    )
{
    CAttrSubBlock *pPrev, *pCur;

    if(pToDelete == NULL)
        return E_INVALIDARG;

    if(m_pAttrListHead == NULL)         // nothing to delete
        return E_FAIL;

    if(m_pAttrListHead == pToDelete)    // deleting head?
    {
        m_pAttrListHead = pToDelete->m_pNext;
    } else {

        for (pPrev = m_pAttrListHead, pCur = pPrev->m_pNext;
             pCur && pCur != pToDelete;
             pPrev = pCur, pCur == pCur->m_pNext);

        if(pCur == NULL)
            return E_INVALIDARG;         // wasn't there to delete

        ASSERT(pCur == pToDelete);      // error check for stupidity...
        pPrev->m_pNext = pToDelete->m_pNext;    // jump the gap
    }

    pToDelete->m_pNext = NULL;
    Recycle_(pToDelete);

    --m_cAttributes;

    return S_OK;
}
HRESULT
CAttrSubBlock_List::Add(
        IN  EnAttrSubBlock_Class    enSubBlock,
        IN  LONG                    subBlock_SubClass,
        IN  BSTR                    bstrIn
     )
{
    HRESULT         hr ;
    CAttrSubBlock * pNew ;

    pNew = FindInList_(enSubBlock, subBlock_SubClass) ;
    if (!pNew) {
        pNew = NewObj_();
        if (pNew) {
            hr = pNew->Set(enSubBlock, subBlock_SubClass, bstrIn);

            if (SUCCEEDED (hr)) {
                InsertInList_ (pNew) ;
            }
            else {
                //  recycle it if anything failed
                Recycle_(pNew) ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        //  duplicates don't make sense; closest error found in winerror.h
        hr = HRESULT_FROM_WIN32 (ERROR_DUPLICATE_TAG) ;
    }

    return hr ;
}

HRESULT
CAttrSubBlock_List::Add(
        IN  EnAttrSubBlock_Class    enSubBlock,
        IN  LONG                    valueIn
     )
{
    HRESULT         hr ;
    CAttrSubBlock * pNew ;

    pNew = FindInList_(enSubBlock) ;
    if (!pNew) {
        pNew = NewObj_();
        if (pNew) {
            hr = pNew->Set(enSubBlock, valueIn, NULL);

            if (SUCCEEDED (hr)) {
                InsertInList_ (pNew) ;
            }
            else {
                //  recycle it if anything failed
                Recycle_(pNew) ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        //  duplicates don't make sense; closest error found in winerror.h
        hr = HRESULT_FROM_WIN32 (ERROR_DUPLICATE_TAG) ;
    }
    return hr ;
}


HRESULT
CAttrSubBlock_List::Add(
        IN  EnAttrSubBlock_Class    enSubBlock,
        IN  LONG                    lValue,
        IN  LONG                    cBytes,
        IN  BYTE *                  pbBytes)
{
    HRESULT         hr ;
    CAttrSubBlock * pNew ;

    pNew = FindInList_(enSubBlock) ;
    if (!pNew) {
        pNew = NewObj_();
        if (pNew) 
        {
            hr = pNew->Set(enSubBlock, lValue, cBytes, pbBytes);

            if (SUCCEEDED (hr)) {
                InsertInList_ (pNew) ;
            }
            else {
                //  recycle it if anything failed
                Recycle_(pNew) ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        //  duplicates don't make sense; closest error found in winerror.h
        hr = HRESULT_FROM_WIN32 (ERROR_DUPLICATE_TAG) ;
    }

    return hr ;
}

HRESULT
CAttrSubBlock_List::Replace(
        IN  EnAttrSubBlock_Class    enSubBlock,
        IN  LONG                    subBlock_SubClass,
        IN  BSTR                    bstrIn
     )
{
    HRESULT         hr ;
    CAttrSubBlock * pNew ;

    pNew = FindInList_(enSubBlock, subBlock_SubClass) ;
    if (!pNew) {
        pNew = NewObj_();
        if (pNew) {
            hr = pNew->Set(enSubBlock, subBlock_SubClass, bstrIn);

            if (SUCCEEDED (hr)) {
                InsertInList_ (pNew) ;
            }
            else {
                //  recycle it if anything failed
                Recycle_(pNew) ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else 
    {
        hr = pNew->Set(enSubBlock, subBlock_SubClass, bstrIn);
    }

    return hr ;
}

HRESULT
CAttrSubBlock_List::Replace(
        IN  EnAttrSubBlock_Class    enSubBlock,
        IN  LONG                    valueIn
     )
{
    HRESULT         hr ;
    CAttrSubBlock * pNew ;

    pNew = FindInList_(enSubBlock) ;
    if (!pNew) {
        pNew = NewObj_();
        if (pNew) {
            hr = pNew->Set(enSubBlock, valueIn, NULL);

            if (SUCCEEDED (hr)) {
                InsertInList_ (pNew) ;
            }
            else {
                //  recycle it if anything failed
                Recycle_(pNew) ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else 
    {
        hr = pNew->Set(enSubBlock, valueIn, NULL);
    }

    return hr ;
}

HRESULT
CAttrSubBlock_List::Replace(
        IN  EnAttrSubBlock_Class    enSubBlock,
        IN  LONG                    lValue,
        IN  LONG                    cBytes,
        IN  BYTE *                  pbBytes)
{
    HRESULT         hr ;
    CAttrSubBlock * pNew ;

    pNew = FindInList_(enSubBlock) ;
    if (!pNew) {
        pNew = NewObj_();
        if (pNew) 
        {
            hr = pNew->Set(enSubBlock, lValue, cBytes, pbBytes);

            if (SUCCEEDED (hr)) {
                InsertInList_ (pNew) ;
            }
            else {
                //  recycle it if anything failed
                Recycle_(pNew) ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        //  duplicates don't make sense; closest error found in winerror.h
            hr = pNew->Set(enSubBlock, lValue, cBytes, pbBytes);
    }

    return hr ;
}

HRESULT
CAttrSubBlock_List::Get(
        IN  EnAttrSubBlock_Class    enSubBlock,
        IN  LONG                    subBlock_SubClass,
        OUT BSTR                    *pbstrOut
    )
{
    HRESULT         hr ;
    CAttrSubBlock * pAttrib ;

    pAttrib = FindInList_(enSubBlock, subBlock_SubClass) ;
    if (pAttrib) {
        EnAttrSubBlock_Class enT;
        LONG sbT;
        hr = pAttrib->Get(&enT, &sbT, pbstrOut);
    }
    else {
        hr = E_INVALIDARG;
    }

    return hr ;
}

HRESULT
CAttrSubBlock_List::Get(
        IN  EnAttrSubBlock_Class    enSubBlock,
        OUT  LONG                   *pValueOut
    )
{
    HRESULT         hr ;
    CAttrSubBlock * pAttrib ;

    pAttrib = FindInList_(enSubBlock) ;
    if (pAttrib) {
        EnAttrSubBlock_Class enT;
        hr = pAttrib->Get(&enT, pValueOut, NULL);
    }
    else {
        hr = E_INVALIDARG;
    }

    return hr ;
}

HRESULT
CAttrSubBlock_List::Get(
        IN  EnAttrSubBlock_Class    enSubBlock,
        IN  LONG                    subBlock_SubClass,
        OUT  LONG                   *pcBytes,
        OUT  BYTE                   **ppbBytes)
{
    HRESULT         hr ;
    CAttrSubBlock * pNew ;

    CAttrSubBlock * pAttrib ;

    pAttrib = FindInList_(enSubBlock, subBlock_SubClass) ;
    if (pAttrib) {
        EnAttrSubBlock_Class enT;
        LONG lSubT;
        hr = pAttrib->Get(&enT, &lSubT, pcBytes, ppbBytes);
    }
    else {
        hr = E_INVALIDARG;
    }

    return hr ;
}

HRESULT
CAttrSubBlock_List::Get(
        IN  EnAttrSubBlock_Class    enSubBlock,
        OUT  LONG                   *plValue,
        OUT  LONG                   *pcBytes,
        OUT  BYTE                   **ppbBytes)
{
    HRESULT         hr ;
    CAttrSubBlock * pNew ;

    CAttrSubBlock * pAttrib ;

    pAttrib = FindInList_(enSubBlock) ;
    if (pAttrib) {
        EnAttrSubBlock_Class enT;
        hr = pAttrib->Get(&enT, plValue, pcBytes, ppbBytes);
    }
    else {
        hr = E_INVALIDARG;
    }

    return hr ;
}
HRESULT
CAttrSubBlock_List::Delete(
        IN  EnAttrSubBlock_Class    enSubBlock,
        IN  LONG                    subBlock_SubClass
    )
{
    CAttrSubBlock * pAttrib ;

    pAttrib = FindInList_(enSubBlock, subBlock_SubClass) ;
    if (pAttrib) {
        return DeleteFromList_(pAttrib);
    }
    else {
        return S_FALSE;
    }
}

HRESULT
CAttrSubBlock_List::Delete(
        IN  EnAttrSubBlock_Class    enSubBlock
    )
{
    CAttrSubBlock * pAttrib ;

    pAttrib = FindInList_(enSubBlock) ;
    if (pAttrib) {
        return DeleteFromList_(pAttrib);
    }
    else {
        return S_FALSE;
    }
}


HRESULT
CAttrSubBlock_List::GetIndexed (
    IN      LONG    lIndex,
    OUT EnAttrSubBlock_Class    *pEnSubBlock,
    OUT LONG                    *pSubBlock_SubClass,
    OUT BSTR                    *pbstrOut
    )
{
    CAttrSubBlock * pAttrib ;

    if (lIndex < 0 ||
        lIndex >= GetCount ()) {
        return E_INVALIDARG ;
    }

    pAttrib = GetIndexed_(lIndex) ;
    ASSERT (pAttrib) ;

    return pAttrib -> Get(
            pEnSubBlock,
            pSubBlock_SubClass,
            pbstrOut
            ) ;
}

void
CAttrSubBlock_List::Reset(
    )
{
    CAttrSubBlock *    pCur ;

    for (;;) {
        pCur = PopListHead_ () ;
        if (pCur) {
                Recycle_ (pCur) ;
        }
        else {
            break ;
        }
    }
}

// ----------------------------------------------
// full block stuff

LONG
CAttrSubBlock_List::GetBlockByteLength()
{
    LONG            lCur ;
    CAttrSubBlock * pCur ;
    long            cBytes = 0;

    for (lCur = 0, pCur = m_pAttrListHead;
         pCur && lCur < m_cAttributes;
         lCur++, pCur = pCur->m_pNext)
    {
             cBytes += pCur->ByteLength();
    }

    return cBytes;
}

// ---------------------------------------------------
//  Block Memory format is:
//      long Magic
//      long cAttrs
//      long cBytesTotal
//      long Reserved
//      {  long sbClass         (basically, just the CAttrSubBlock class, next --> cBytesBlock)
//         long sbSubClass
//         long *pData = NULL
//         long cBytesBlock
//         ...  data ... (cBytesBlock - sizeof(CAttrSubBlock) long)
//      }
// ----------------------------------------------------


const int kAttrMagic = 0x696c6156;            // a random magic number
class AttrBlockHeader
{
public:
    long m_Magic;
    long m_cAttrs;
    long m_cBytesTotal;
    long m_Reserved;
} ;

HRESULT
CAttrSubBlock_List::GetAsOneBlock(OUT BSTR *pBstrOut)      // returns a peristable block for the whole list
{
    LONG            lCur ;
    CAttrSubBlock * pCur ;
    long            cBytes = GetBlockByteLength();

    long            cwChars = (cBytes + sizeof(AttrBlockHeader)+1)/sizeof(WCHAR);
    CComBSTR        spbsOut(cwChars);
    spbsOut.m_str[cwChars-1] = 0;       // tail with zero for odd length strings

    BYTE *pB = (BYTE *) (spbsOut.m_str);
    if(NULL == pB)
        return E_OUTOFMEMORY;

    AttrBlockHeader *pAttrOut = (AttrBlockHeader *) pB; pB += sizeof(AttrBlockHeader);    

    pAttrOut->m_Magic       = kAttrMagic;
    pAttrOut->m_cAttrs      = m_cAttributes;
    pAttrOut->m_cBytesTotal = cBytes;
    pAttrOut->m_Reserved    = 0;

    CAttrSubBlock attrT;
    const kcbAttr = sizeof(CAttrSubBlock); 

    for (lCur = 0, pCur = m_pAttrListHead;
         lCur < m_cAttributes;
         lCur++, pCur = pCur->m_pNext)
    {
       long cBytesBlock = pCur->ByteLength();
       attrT.m_enSubBlock_Class  = pCur->m_enSubBlock_Class;
       attrT.m_subBlock_SubClass = pCur->m_subBlock_SubClass;
       attrT.m_varData.vt        = VT_I4;
       attrT.m_varData.lVal      = cBytesBlock;
       attrT.m_pNext             = NULL;

       long cbData = cBytesBlock - kcbAttr;

       memcpy(pB, &attrT, kcbAttr);                     pB += kcbAttr;
       if(cbData > 0)
           memcpy(pB, pCur->m_spbsData.m_str, cbData);  pB += cbData;
    }

//    *pBstrOut = bstrOut.Detach();       // will this work?
    return spbsOut.CopyTo(pBstrOut);   // this is way I usually do it

}

HRESULT
CAttrSubBlock_List::SetAsOneBlock(IN BSTR bstrIn)      // returns a peristable block for the whole list
{
    HRESULT hr = S_OK;
    
    LONG            lCur ;
    CAttrSubBlock * pCur ;
    
    BYTE *pB = (BYTE *) (bstrIn);

    if(NULL == pB)
        return E_INVALIDARG;

    AttrBlockHeader *pAttrIn = (AttrBlockHeader *) pB; pB += sizeof(AttrBlockHeader);    

    if(kAttrMagic != pAttrIn->m_Magic)
        return E_INVALIDARG;

    long cAttributes = pAttrIn->m_cAttrs;
    long cBytes      = pAttrIn->m_cBytesTotal;  

    // size of the 'header' of each block
    const int  kcbAttr = sizeof(CAttrSubBlock);

    for (lCur = 0; lCur < cAttributes; lCur++)
    {
       
       CAttrSubBlock *pAttr = (CAttrSubBlock *) pB; 
       
       ASSERT(pAttr->m_varData.vt == VT_I4);
       LONG cBytesBlock = pAttr->m_varData.lVal;

       CAttrSubBlock *pNew = NewObj_();
       if (pNew) 
       {
            hr = pNew->Set(pAttr->m_enSubBlock_Class, 
                           pAttr->m_subBlock_SubClass, 
                           NULL);
            ASSERT(!FAILED(hr));

            int cBytesData = cBytesBlock - kcbAttr; 

            if(cBytesData > 0)
            {
                int cwChars = (cBytesData + 1)/sizeof(WCHAR);
                pNew->m_spbsData = CComBSTR(cwChars);
                pNew->m_spbsData.m_str[cwChars-1] = 0;  // for odd lengths, tail with 0
                memcpy(pNew->m_spbsData.m_str, pB + kcbAttr, cBytesData);  
                int cChars = SysStringByteLen(pNew->m_spbsData);
                int cChars2 = pNew->ByteLength();
            }
            

            if (SUCCEEDED (hr)) 
                InsertInList_ (pNew) ;      // TODO - thing about replacing instead (but O(N^2))
            
       } else {
           hr = E_OUTOFMEMORY;
           break;
       }
       pB += cBytesBlock;

    }

    if(FAILED(hr))
        Reset();       // clean up as much as we can

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\attrib\mediaattrib.cpp ===
/*++

    Copyright (c) 2002 Microsoft Corporation

    Module Name:

        MediaAttrib.cpp

    Abstract:

        This module contains the IMediaSampleTagged implementation

    Author:

        J.Bradstreet (johnbrad)

    Revision History:

        19-Mar-2002    created

--*/

#include "EncDecAll.h"
#include "MediaSampleAttr.h"				//  compiled from From IDL file
#include "MediaAttrib.h"

#define NS_E_UNSUPPORTED_PROPERTY	E_FAIL


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
#define char THIS_FILE[] = __FILE__;
#endif

//  ============================================================================
//   CMedSampAttr
//  ============================================================================

CMedSampAttr::CMedSampAttr (
    ) : m_dwAttributeSize   (0)
{
}

CMedSampAttr::~CMedSampAttr (
    ) 
{
    m_spbsAttributeData.Empty();
}



HRESULT
CMedSampAttr::SetAttributeData (
    IN  GUID    guid,
    IN  LPVOID  pvData,
    IN  DWORD   dwSize
    )
{
    DWORD   dw ;
    HRESULT hr ;

    if (!pvData &&
        dwSize > 0) 
	{
        return E_POINTER ;
    }

	DWORD dwCurLen = SysStringByteLen(m_spbsAttributeData);
	if((dwSize > 0) &&
		((dwSize > dwCurLen) ||
		  (dwSize < dwCurLen/4)))
    {
	    m_spbsAttributeData.Empty();
        int cwChars = (dwSize+1)/sizeof(WCHAR);
	    m_spbsAttributeData = CComBSTR(cwChars);		// TODO - what happens if throws?
        if(cwChars > 0 && m_spbsAttributeData.m_str != 0)
            m_spbsAttributeData.m_str[cwChars-1] = 0;     // tail with 0 in case odd length
    }

	if(m_spbsAttributeData == (LPCSTR) NULL)
		return E_OUTOFMEMORY;  // CComBSTR

	if(pvData)		// may just want to allocate space
	{
		CopyMemory( (void *) m_spbsAttributeData.m_str,  // dst
					pvData,  // src
					dwSize);
	} 

    if (true) {
        //  size always is set
        m_dwAttributeSize = dwSize ;

        //  GUID always gets set
        m_guidAttribute = guid ;

        //  success
        hr = S_OK ;
    }
    else {
        hr = HRESULT_FROM_WIN32 (dw) ;
    }

    return hr ;
}

BOOL
CMedSampAttr::IsEqual (
    IN  REFGUID rguid
    )
{
    return (rguid == m_guidAttribute ? TRUE : FALSE) ;
}

HRESULT
CMedSampAttr::GetAttribute (
    IN      GUID    guid,
    IN OUT  LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    HRESULT hr ;

    if (!pdwDataLen) {
        return E_POINTER ;
    }

    if (IsEqual (guid)) {

     //   int cbsLen = m_spbsAttributeData.Length(); // doesn't work (strlen?)
     //   ASSERT(cbsLen >= m_dwAttributeSize);

        if (pvData) {
            //  caller wants the data
            (* pdwDataLen) = min(*pdwDataLen, m_dwAttributeSize) ;
            CopyMemory (pvData, m_spbsAttributeData.m_str, (* pdwDataLen)) ;
        }
        else {
            //  caller just wants to know how big
            (* pdwDataLen) = m_dwAttributeSize ;
        }

        //  success
        hr = S_OK ;
    }
    else {
        //  not the right guid
        hr = NS_E_UNSUPPORTED_PROPERTY ;
    }

    return hr ;
}

HRESULT
CMedSampAttr::GetAttributeData (
    OUT     GUID *  pguid,
    IN OUT  LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    //  set the GUID
    ASSERT (pguid) ;
    (* pguid) = m_guidAttribute ;

    //  retrieve the attributes
    return GetAttribute (
                (* pguid),
                pvData,
                pdwDataLen
                ) ;
}



//  ============================================================================
//      CMedSampAttrList
//  ============================================================================

CMedSampAttrList::CMedSampAttrList (
    ) : m_pAttribListHead   (NULL),
        m_cAttributes       (0)
{
}

CMedSampAttrList::~CMedSampAttrList (
    )
{
    Reset () ;
}

CMedSampAttr *
CMedSampAttrList::PopListHead_ (
    )
{
    CMedSampAttr *    pCur ;

    pCur = m_pAttribListHead ;
    if (pCur) {
        m_pAttribListHead = m_pAttribListHead -> m_pNext ;
        pCur -> m_pNext = NULL ;

        ASSERT (m_cAttributes > 0) ;
        m_cAttributes-- ;
    }

    return pCur ;
}

CMedSampAttr *
CMedSampAttrList::GetIndexed_ (
    IN  LONG    lIndex
    )
{
    LONG            lCur ;
    CMedSampAttr * pCur ;

    ASSERT (lIndex < GetCount ()) ;
    ASSERT (lIndex >= 0) ;

    for (lCur = 0, pCur = m_pAttribListHead;
         lCur < lIndex;
         lCur++, pCur = pCur -> m_pNext) ;

    return pCur ;
}

CMedSampAttr *
CMedSampAttrList::FindInList_ (
    IN  GUID    guid
    )
{
    CMedSampAttr *    pCur ;

    for (pCur = m_pAttribListHead;
         pCur && !pCur -> IsEqual (guid);
         pCur = pCur -> m_pNext) ;

    return pCur ;
}

    CMedSampAttr *
    GetIndexed_ (
        IN  LONG    lIndex
        ) ;

void
CMedSampAttrList::InsertInList_ (
    IN  CMedSampAttr *    pNew
    )
{
    pNew -> m_pNext = m_pAttribListHead ;
    m_pAttribListHead = pNew ;

    m_cAttributes++ ;
}

HRESULT
CMedSampAttrList::AddAttribute (
    IN  GUID    guid,
    IN  LPVOID  pvData,
    IN  DWORD   dwSize
    )
{
    HRESULT         hr ;
    CMedSampAttr * pNew ;

    pNew = FindInList_ (guid) ;
    if (!pNew) {
        pNew = NewObj_();
        if (pNew) {
            hr = pNew -> SetAttributeData (
                    guid,
                    pvData,
                    dwSize
                    ) ;

            if (SUCCEEDED (hr)) {
                InsertInList_ (pNew) ;
            }
            else {
                //  recycle it if anything failed
                Recycle_(pNew) ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        //  duplicates don't make sense; closest error found in winerror.h
        hr = HRESULT_FROM_WIN32 (ERROR_DUPLICATE_TAG) ;
    }

    return hr ;
}

HRESULT
CMedSampAttrList::GetAttribute (
    IN      GUID    guid,
    IN OUT  LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    HRESULT         hr ;
    CMedSampAttr * pAttrib ;

    pAttrib = FindInList_ (guid) ;
    if (pAttrib) {
        hr = pAttrib -> GetAttribute (
                guid,
                pvData,
                pdwDataLen
                ) ;
    }
    else {
        hr = NS_E_UNSUPPORTED_PROPERTY ;
    }

    return hr ;
}

HRESULT
CMedSampAttrList::GetAttributeIndexed (
    IN      LONG    lIndex,
    OUT     GUID *  pguidAttribute,
    OUT     LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    CMedSampAttr * pAttrib ;

    if (lIndex < 0 ||
        lIndex >= GetCount ()) {
        return E_INVALIDARG ;
    }

    pAttrib = GetIndexed_ (lIndex) ;
    ASSERT (pAttrib) ;

    return pAttrib -> GetAttributeData (
            pguidAttribute,
            pvData,
            pdwDataLen
            ) ;
}

void
CMedSampAttrList::Reset (
    )
{
    CMedSampAttr *    pCur ;

    for (;;) {
        pCur = PopListHead_ () ;
        if (pCur) {
                Recycle_ (pCur) ;
        }
        else {
            break ;
        }
    }
}


//  ----------------------------------------------------------------------------
//      CAttributedMediaSample
//  ----------------------------------------------------------------------------

CAttributedMediaSample::CAttributedMediaSample(
			TCHAR			*pName,
			CBaseAllocator	*pAllocator,
			HRESULT			*pHR,
			LPBYTE			pBuffer,
			LONG			length) :
	    CMediaSample(pName,pAllocator,pHR,pBuffer,length),
        m_cRef                  (0),
        m_pSampleOriginal       (NULL)

{
		// put some stuff here..
}

CAttributedMediaSample::~CAttributedMediaSample()
{
	m_MediaSampleAttributeList.Reset();	// clear all the data in it
}

/* Override this to publicise our interfaces */

STDMETHODIMP
CAttributedMediaSample::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IMediaSample ||
        riid == IID_IMediaSample2 ||
        riid == IID_IUnknown) {
        return GetInterface((IMediaSample *) this, ppv);
    }
    else if (riid == IID_IAttributeSet) {
        return GetInterface ((IAttributeSet *) this, ppv) ;
    }
    else if (riid == IID_IAttributeGet) {
        return GetInterface ((IAttributeGet *) this, ppv) ;
    }
    else {
        return E_NOINTERFACE;
    }
}


STDMETHODIMP_(ULONG)
CAttributedMediaSample::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CAttributedMediaSample::Release()
{

    /* Decrement our own private reference count */
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    /* Did we release our final reference count */
    if (lRef == 0) {
        /* Free all resources */
        if (m_dwFlags & Sample_TypeChanged) {
            SetMediaType(NULL);
        }
        ASSERT(m_pMediaType == NULL);
        m_dwFlags = 0;
        m_dwTypeSpecificFlags = 0;
        m_dwStreamId = AM_STREAM_MEDIA;

        if(m_pSampleOriginal)
            m_pSampleOriginal->Release();

        m_MediaSampleAttributeList.Reset();

        /* This may cause us to be deleted */
        // Our refcount is reliably 0 thus no-one will mess with us
// not yet, not until we use or own allocator...
//        m_pAllocator->ReleaseBuffer(this);

        delete this;
    }
    return (ULONG)lRef;
}


            // wraps a media sample.. 
            //   Can be used to pull subsection of of a media sample.
            // The begining is offset by cbNewOffset, (defaults to 0)
            // The length is set to cbNewLength if it's >= 0, (defaults to -1)
            //   It's an error if the specified subsection isn't entirely contained 
            // by the original sample.
HRESULT
CAttributedMediaSample::Wrap (IMediaSample *pSample, int cbNewOffset, int cbNewLength)
{
    HRESULT hr;
    if(pSample == NULL)
        return S_FALSE; // nothing to wrap

    CComQIPtr<IMediaSample2>    pSample2(pSample);

    if(pSample2)
    {
        AM_SAMPLE2_PROPERTIES sampleProps;
        hr = pSample2->GetProperties(sizeof(sampleProps),(BYTE *) &sampleProps);
            
        ASSERT(sizeof(sampleProps) == sampleProps.cbData);
        if(FAILED(hr)) return hr;

        // copy properties into our sample

        //DWORD            m_dwFlags;       /* Flags for this sample */
                                            /* Type specific flags are packed
                                               into the top word */                                    
        m_dwFlags = sampleProps.dwSampleFlags;

        //DWORD            m_dwTypeSpecificFlags; /* Media type specific flags */
        m_dwTypeSpecificFlags = sampleProps.dwTypeSpecificFlags;
    
     //   LPBYTE           m_pBuffer;         /* Pointer to the complete buffer */
        m_pBuffer = sampleProps.pbBuffer + cbNewOffset;
     //   LONG             m_lActual;         /* Length of data in this sample */
        m_lActual = sampleProps.lActual;
     //   LONG             m_cbBuffer;        /* Size of the buffer */
        m_cbBuffer = sampleProps.cbBuffer;
        if(cbNewLength > 0)
            m_cbBuffer = min(cbNewLength, m_lActual - cbNewOffset);
     //  CBaseAllocator  *m_pAllocator;      /* The allocator who owns us */
     //  CMediaSample     *m_pNext;          /* Chaining in free list */
        
     //   REFERENCE_TIME   m_Start;           /* Start sample time */
     //   REFERENCE_TIME   m_End;             /* End sample time */
        hr = pSample->GetTime(&m_Start, &m_End);
        if(S_OK == hr)
        {
            m_Start = sampleProps.tStart;
            m_End   = sampleProps.tStop;
        }

     //LONGLONG         m_MediaStart;      /* Real media start position */
     //LONG             m_MediaEnd;        /* A difference to get the end */
        LONGLONG llStart = (LONGLONG) 0;
        LONGLONG llEnd  = (LONGLONG) 0;
        hr = pSample->GetMediaTime(&llStart, &llEnd);  // could return 
        if(S_OK == hr)
            SetMediaTime(&llStart, &llEnd);    // call this instead of writing to m_MediaStart/End directly, 
                                                    //  the prop code wipes out the Sample_MediaTimeValid flag

     //   AM_MEDIA_TYPE    *m_pMediaType;     /* Media type change data */
        hr = pSample->GetMediaType(&m_pMediaType);
        if(S_OK == hr)
     //   DWORD            m_dwStreamId;      /* Stream id */
            m_dwStreamId   = sampleProps.dwStreamId;
    } 
    else 
    {


        // copy properties into our sample
        //DWORD            m_dwFlags;         /* Flags for this sample */
        /* Type specific flags are packed
        into the top word */
        
        // yecko, going to miss lots of bits here!
        SetDiscontinuity(S_OK == pSample->IsDiscontinuity());
        SetPreroll(S_OK == pSample->IsPreroll());
        SetSyncPoint(S_OK == pSample->IsSyncPoint());
        
        //   DWORD            m_dwTypeSpecificFlags; /* Media type specific flags */
        // m_dwTypeSpecificFlags = sampleProps.dwTypeSpecificFlags;
        
        //   LPBYTE           m_pBuffer;         /* Pointer to the complete buffer */
        hr = pSample->GetPointer(&m_pBuffer);;
        ASSERT(!FAILED(hr));
        m_pBuffer += cbNewOffset;
        
        //   LONG             m_lActual;         /* Length of data in this sample */
        m_lActual = pSample->GetActualDataLength();
        
        //   LONG             m_cbBuffer;        /* Size of the buffer */
        m_cbBuffer = pSample->GetSize();
        if(cbNewLength >= 0)
            m_cbBuffer = min(cbNewLength, m_lActual - cbNewOffset);
        
        //  CBaseAllocator  *m_pAllocator;          /* The allocator who owns us */
        //  CMediaSample     *m_pNext;              /* Chaining in free list */
        
        //   REFERENCE_TIME   m_Start;              /* Start sample time */
        //   REFERENCE_TIME   m_End;                /* End sample time */
        hr = pSample->GetTime(&m_Start, &m_End);
        ASSERT(!FAILED(hr));
        
        //   LONGLONG         m_MediaStart;         /* Real media start position */
        //   LONG             m_MediaEnd;           /* A difference to get the end */
        LONGLONG llStart = (LONGLONG) 0;
        LONGLONG llEnd  = (LONGLONG) 0;
        hr = pSample->GetMediaTime(&llStart, &llEnd);  // could return 
        if(S_OK == hr)
            SetMediaTime(&llStart, &llEnd);     // call this instead of writing to m_MediaStart/End directly, 
          
        //   AM_MEDIA_TYPE    *m_pMediaType;     /* Media type change data */
        hr = pSample->GetMediaType(&m_pMediaType);
        ASSERT(!FAILED(hr));
        //   DWORD            m_dwStreamId;      /* Stream id */
        m_dwStreamId = AM_STREAM_MEDIA;         // ?? what else do we default it to?
    }

    if((cbNewOffset < 0) || 
       (cbNewOffset > m_lActual) ||
       ((cbNewLength > 0) && 
        (cbNewOffset + cbNewLength > m_lActual)))
    {
       return E_INVALIDARG;
    }

    m_pSampleOriginal = pSample;
    m_pSampleOriginal->AddRef();          // keep an internal reference

    return S_OK;
}

STDMETHODIMP
CAttributedMediaSample::SetAttrib (
    IN  GUID    guidAttribute,
    IN  BYTE *  pbAttribute,
    IN  DWORD   dwAttributeLength
    )
{
    return m_MediaSampleAttributeList.AddAttribute (
            guidAttribute,
            pbAttribute,
            dwAttributeLength
            ) ;
}

STDMETHODIMP
CAttributedMediaSample::GetCount (
    OUT LONG *  plCount
    )
{
    if (!plCount) {
        return E_POINTER ;
    }

    (* plCount) = m_MediaSampleAttributeList.GetCount () ;
    return S_OK ;
}

STDMETHODIMP
CAttributedMediaSample::GetAttribIndexed (
    IN  LONG    lIndex,             //  0-based
    OUT GUID *  pguidAttribute,
    OUT BYTE *  pbAttribute,
    OUT DWORD * pdwAttributeLength
    )
{
    return m_MediaSampleAttributeList.GetAttributeIndexed (
            lIndex,
            pguidAttribute,
            pbAttribute,
            pdwAttributeLength
            ) ;
}

STDMETHODIMP
CAttributedMediaSample::GetAttrib (
    IN  GUID    guidAttribute,
    OUT BYTE *  pbAttribute,
    OUT DWORD * pdwAttributeLength
    )
{
    return m_MediaSampleAttributeList.GetAttribute (
            guidAttribute,
            pbAttribute,
            pdwAttributeLength
            ) ;
}

/*

HRESULT
CAttributedMediaSample::Init (
    IN  BYTE *  pbPayload,
    IN  LONG    lPayloadLength
    )
{
    m_lActual = m_cbBuffer = lPayloadLength ;
    m_pBuffer = pbPayload ;

    return S_OK ;
}



// set the buffer pointer and length. Used by allocators that
// want variable sized pointers or pointers into already-read data.
// This is only available through a CAttributedMediaSample* not an IMediaSample*
// and so cannot be changed by clients.
HRESULT
CAttributedMediaSample::SetPointer(BYTE * ptr, LONG cBytes)
{
    m_pBuffer = ptr;            // new buffer area (could be null)
    m_cbBuffer = cBytes;        // length of buffer
    m_lActual = cBytes;         // length of data in buffer (assume full)

    return S_OK;
}



// get me a read/write pointer to this buffer's memory. I will actually
// want to use sizeUsed bytes.
STDMETHODIMP
CAttributedMediaSample::GetPointer(BYTE ** ppBuffer)
{
    ValidateReadWritePtr(ppBuffer,sizeof(BYTE *));

    // creator must have set pointer either during
    // constructor or by SetPointer
    ASSERT(m_pBuffer);

    *ppBuffer = m_pBuffer;
    return NOERROR;
}


// return the size in bytes of this buffer
//STDMETHODIMP_(LONG)
LONG
CAttributedMediaSample::GetSize(void)
{
    return m_cbBuffer;
}



STDMETHODIMP
CAttributedMediaSample::SetActualDataLength(LONG lActual)
{
    if (lActual > m_cbBuffer) {
        ASSERT(lActual <= GetSize());
        return VFW_E_BUFFER_OVERFLOW;
    }
    m_lActual = lActual;
    return NOERROR;
}

*/
//=====================================================================
//=====================================================================
// Implements CAMSAllocator
//		Code stolen from CMemAllocator
//=====================================================================
//=====================================================================

// This goes in the factory template table to create new instances 
CUnknown *CAMSAllocator::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CUnknown *pUnkRet = new CAMSAllocator(NAME("CAMSAllocator"), pUnk, phr);
    return pUnkRet;
}

CAMSAllocator::CAMSAllocator(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseAllocator(pName, pUnk, phr, TRUE, TRUE),
    m_pBuffer(NULL)
{
}

#ifdef UNICODE
CAMSAllocator::CAMSAllocator(
    CHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseAllocator(pName, pUnk, phr, TRUE, TRUE),
    m_pBuffer(NULL)
{
}
#endif

/* This sets the size and count of the required samples. The memory isn't
   actually allocated until Commit() is called, if memory has already been
   allocated then assuming no samples are outstanding the user may call us
   to change the buffering, the memory will be released in Commit() */
STDMETHODIMP
CAMSAllocator::SetProperties(
                ALLOCATOR_PROPERTIES* pRequest,
                ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pActual,E_POINTER);
    ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES));
    CAutoLock cObjectLock(this);

    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

    ASSERT(pRequest->cbBuffer > 0);

    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);

    /*  Check the alignment request is a power of 2 */
    if ((-pRequest->cbAlign & pRequest->cbAlign) != pRequest->cbAlign) {
        DbgLog((LOG_ERROR, 1, TEXT("Alignment requested 0x%x not a power of 2!"),
               pRequest->cbAlign));
    }
    /*  Check the alignment requested */
    if (pRequest->cbAlign == 0 ||
    (SysInfo.dwAllocationGranularity & (pRequest->cbAlign - 1)) != 0) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid alignment 0x%x requested - granularity = 0x%x"),
               pRequest->cbAlign, SysInfo.dwAllocationGranularity));
        return VFW_E_BADALIGN;
    }

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted == TRUE) {
        return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    if (m_lFree.GetCount() < m_lAllocated) {
        return VFW_E_BUFFERS_OUTSTANDING;
    }

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    // round length up to alignment - remember that prefix is included in
    // the alignment
    LONG lSize = pRequest->cbBuffer + pRequest->cbPrefix;
    LONG lRemainder = lSize % pRequest->cbAlign;
    if (lRemainder != 0) {
        lSize = lSize - lRemainder + pRequest->cbAlign;
    }
    pActual->cbBuffer = m_lSize = (lSize - pRequest->cbPrefix);

    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    m_bChanged = TRUE;
    return NOERROR;
}

// override this to allocate our resources when Commit is called.
//
// note that our resources may be already allocated when this is called,
// since we don't free them on Decommit. We will only be called when in
// decommit state with all buffers free.
//
// object locked by caller
HRESULT
CAMSAllocator::Alloc(void)
{
    CAutoLock lck(this);

    /* Check he has called SetProperties */
    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
        return hr;
    }

    /* If the requirements haven't changed then don't reallocate */
    if (hr == S_FALSE) {
        ASSERT(m_pBuffer);
        return NOERROR;
    }
    ASSERT(hr == S_OK); // we use this fact in the loop below

    /* Free the old resources */
    if (m_pBuffer) {
        ReallyFree();
    }

    /* Compute the aligned size */
    LONG lAlignedSize = m_lSize + m_lPrefix;
    if (m_lAlignment > 1) {
        LONG lRemainder = lAlignedSize % m_lAlignment;
        if (lRemainder != 0) {
            lAlignedSize += (m_lAlignment - lRemainder);
        }
    }

    /* Create the contiguous memory block for the samples
       making sure it's properly aligned (64K should be enough!)
    */
    ASSERT(lAlignedSize % m_lAlignment == 0);

    m_pBuffer = (PBYTE)VirtualAlloc(NULL,
                    m_lCount * lAlignedSize,
                    MEM_COMMIT,
                    PAGE_READWRITE);

    if (m_pBuffer == NULL) {
        return E_OUTOFMEMORY;
    }

    LPBYTE pNext = m_pBuffer;
    CMediaSample *pSample;

    ASSERT(m_lAllocated == 0);

    // Create the new samples - we have allocated m_lSize bytes for each sample
    // plus m_lPrefix bytes per sample as a prefix. We set the pointer to
    // the memory after the prefix - so that GetPointer() will return a pointer
    // to m_lSize bytes.
    for (; m_lAllocated < m_lCount; m_lAllocated++, pNext += lAlignedSize) {


        pSample = new CMediaSample(
                            NAME("Default memory media sample"),
                this,
                            &hr,
                            pNext + m_lPrefix,      // GetPointer() value
                            m_lSize);               // not including prefix

            ASSERT(SUCCEEDED(hr));
        if (pSample == NULL) {
            return E_OUTOFMEMORY;
        }

        // This CANNOT fail
        m_lFree.Add(pSample);
    }

    m_bChanged = FALSE;
    return NOERROR;
}


// override this to free up any resources we have allocated.
// called from the base class on Decommit when all buffers have been
// returned to the free list.
//
// caller has already locked the object.

// in our case, we keep the memory until we are deleted, so
// we do nothing here. The memory is deleted in the destructor by
// calling ReallyFree()
void
CAMSAllocator::Free(void)
{
    return;
}


// called from the destructor (and from Alloc if changing size/count) to
// actually free up the memory
void
CAMSAllocator::ReallyFree(void)
{
    /* Should never be deleting this unless all buffers are freed */

    ASSERT(m_lAllocated == m_lFree.GetCount());

    /* Free up all the CMediaSamples */

    CMediaSample *pSample;
    for (;;) {
        pSample = m_lFree.RemoveHead();
        if (pSample != NULL) {
            delete pSample;
        } else {
            break;
        }
    }

    m_lAllocated = 0;

    // free the block of buffer memory
    if (m_pBuffer) {
        EXECUTE_ASSERT(VirtualFree(m_pBuffer, 0, MEM_RELEASE));
        m_pBuffer = NULL;
    }
}


/* Destructor frees our memory resources */

CAMSAllocator::~CAMSAllocator()
{
    Decommit();
    ReallyFree();
}

// --------------------------------------------------------------
// ----------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dll\timeit.cpp ===
//--------------------------------------------------
// timeit.cpp
//        
// 	simple little C++ timing utilities
//--------------------------------------------------

#include <time.h>
#include "timeit.h"

#ifndef MAX
#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#endif

#define NTimeits 25
static Timeit * Timeit_List[NTimeits];	 // hacky way to remember timers
static int Timeit_Count = 0;			 // number of allocated timers
		
										// real constructor - two different inlined constructors

void 
Timeit::Init(bool fAutoRun)
{
	m_ctimer   = Timeit_Count++;
	m_ctimer  %= NTimeits;		//  ugly but simple math here	 -- need to do this right when run out of timers (ASSERT)
	m_frunning = FALSE;
	m_ctimes   = 0;		   		// number of times called

	m_i64start = 0;				// performance counter time last started
	m_i64lastdel = 0;			
	m_i64total = 0;				// total run time

	Timeit_List[m_ctimer] = this;
	m_fAutoRun = fAutoRun;

	if(m_fAutoRun)  Start();
}

Timeit::~Timeit()
{
	if(m_fAutoRun) {
		Stop();
	}

	Timeit_List[m_ctimer] = NULL;
}

void Timeit::Stop()
{
	if(m_frunning) {
		LARGE_INTEGER	li_stop;
		QueryPerformanceCounter(&li_stop);

		__int64 i64_Stop = To__int64(li_stop);
		__int64 i64_del = i64_Stop - m_i64start;

		m_i64total   = m_i64total + i64_del;
		m_i64lastdel = i64_del;		// remember in case we are doing a continue

		m_ctimes++;
		m_frunning = FALSE;
	}
}

void Timeit::Start()
{
	if(m_frunning) Stop();
	m_frunning = TRUE;
	QueryPerformanceCounter(&m_i64start);
}



void Timeit::Continue()
{
	m_frunning = TRUE;
	m_ctimes--;

	__int64 i64_Now;
	QueryPerformanceCounter(&i64_Now);
	m_i64start = i64_Now - m_i64lastdel;
}

void Timeit::Restart()			// like Start, but also resets the clock back to 0 (use to throw out previous runs)
{
	if(m_frunning) Stop();
	m_ctimes     = 0;

	m_i64total   = 0;
	m_i64lastdel = 0;

    Start();
}

void Timeit::Clear()
{
	if(m_frunning) Stop();
	m_ctimes     = 0;

	m_i64total   = 0;
	m_i64lastdel = 0;
}

double Timeit::TotalTime()
{
	__int64 i64Freq;
	QueryPerformanceFrequency(&i64Freq);

	double rTotal = (double) m_i64total;
	double rFreq  = (double) i64Freq;

	return rTotal / rFreq;
}

double Timeit::AvgTime()
{
	__int64 i64Freq;
	QueryPerformanceFrequency(&i64Freq);

	double rTotal = (double) m_i64total;
	double rFreg  = (double) i64Freq;

	return rTotal / (MAX(1,m_ctimes)*rFreg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dll\regkey.cpp ===
/*++

    Copyright (c) 2002 Microsoft Corporation

    Module Name:

        RegKey.cpp

    Abstract:

        This module contains Registry Key manipulation code for EncDec

    Author:

        J.Bradstreet (johnbrad)

    Revision History:

        07-Mar-2002    created


--*/


#include "EncDecAll.h"

#include "RegKey.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------

HRESULT 
Get_EncDec_RegEntries(BSTR *pbsKID, DWORD *pcbBytesHash, BYTE **ppbHash,  DWORD *pdwCSFlags, DWORD *pdwRatFlags)
{
    HRESULT hr = S_OK;
    HRESULT hrRes = S_OK;
    
    TCHAR szReg[MAX_PATH];
    DWORD dwszReg = MAX_PATH;
    
    if(pbsKID != NULL)
    {                                           // try to get the KID
        hr = GetRegValueSZ(DEF_ENCDEC_BASE,		// "SOFTWARE\\Microsoft\\eHome\\EncDec"
            NULL,
            NULL,
            DEF_KID_VAR,                        // "Key Identifier"
            szReg, 
            &dwszReg);
        if(ERROR_SUCCESS == hr && pbsKID != NULL)
        {
            CComBSTR spbs(szReg);
            spbs.CopyTo(pbsKID);
        } else {
            hrRes = E_FAIL;
        }
    }
    
  if(pcbBytesHash != 0 && ppbHash != 0)
    {
        const int kMaxBytes = 128;
        BYTE rgBytes[kMaxBytes];
        DWORD dwBytes = kMaxBytes;
	    hr = GetRegValue(DEF_ENCDEC_BASE,		// try to get the hash
						   NULL,
						   NULL,
						   DEF_KIDHASH_VAR, 
                           rgBytes, 
                           &dwBytes);

        if(ERROR_SUCCESS == hr)
        {
            BYTE *pbHash = (BYTE *) CoTaskMemAlloc(dwBytes);
            if(NULL != pbHash)
            {
                memcpy(pbHash, rgBytes, dwBytes);
                *pcbBytesHash = dwBytes;
                *ppbHash = pbHash;
            } else {
                *ppbHash = NULL;
                *pcbBytesHash = NULL;
            }
        } else {
            *ppbHash = NULL;
            *pcbBytesHash = NULL;
        }
    }

    

#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS
    if(pdwCSFlags != NULL)
    {
        DWORD dwCS_DebugFlags;
        hr = GetRegValue(DEF_ENCDEC_BASE,		// try to get the flags
            NULL,
            NULL,
            DEF_CSFLAGS_VAR,                    // "CA Flags"
            &dwCS_DebugFlags
            );
    
        if(ERROR_SUCCESS == hr)                 // ignore any errors if cant find it..
        {
            if(dwCS_DebugFlags != DEF_CSFLAGS_INITVAL)
                *pdwCSFlags = (dwCS_DebugFlags & 0xff);      // only allow a 8-bit value
        } else {
             *pdwCSFlags = DEF_CSFLAGS_INITVAL;
        }
    }
#endif


#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_RATINGS
    if(pdwRatFlags != NULL)
    {
        DWORD dwRat_DebugFlags;
        hr = GetRegValue(DEF_ENCDEC_BASE,		// try to get the flags
            NULL,
            NULL,
            DEF_RATFLAGS_VAR,                   // "Ratings Flags"
            &dwRat_DebugFlags                   
            );
    
        if(ERROR_SUCCESS == hr)                 // ignore any errors if cant find it..
        {
            if(dwRat_DebugFlags != DEF_CSFLAGS_INITVAL)
                *pdwRatFlags = (dwRat_DebugFlags & 0xff);   // only allow a 8-bit value
        } else {
            *pdwRatFlags  = DEF_CSFLAGS_INITVAL;
        }
    }
#endif

    return hrRes;
}

        // TODO - consider ACL'ing this to make them modifyable by everyone, but only create/delete by admin.
HRESULT 
Set_EncDec_RegEntries(BSTR bsKID, DWORD cbHashBytes, BYTE *pbHash, DWORD dwCSFlags, DWORD dwRatFlags)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    HRESULT hrRes = S_OK;
    
    if(bsKID != NULL && wcslen(bsKID) > 0)
    {
        
        hr = SetRegValueSZ(DEF_ENCDEC_BASE,		// try to set KID
            NULL,
            NULL,
            DEF_KID_VAR, 
            W2T(bsKID));
        if(ERROR_SUCCESS != hr)
        {
            hrRes = hr;
        } 
    }
    
    if(cbHashBytes > 0 && pbHash != NULL)
    {
	    hr = SetRegValue(DEF_ENCDEC_BASE,		// try to get the hash
						       NULL,
						       NULL,
						       DEF_KIDHASH_VAR, 
                               pbHash, cbHashBytes);
        if(ERROR_SUCCESS != hr)
        {
            hrRes = hr;
  
        }
    }
    
#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS
    if(dwCSFlags != DEF_CSFLAGS_INITVAL)
    {
        hr = SetRegValue(DEF_ENCDEC_BASE,		// try to set the flags
            NULL,
            NULL,
            DEF_CSFLAGS_VAR, 
            dwCSFlags
            );
        if(ERROR_SUCCESS != hr)
        {
            hrRes = hr;
            
        }
    }
#endif
   
#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_RATINGS
    if(dwRatFlags != DEF_CSFLAGS_INITVAL)
    {
        hr = SetRegValue(DEF_ENCDEC_BASE,		// try to set the flags
            NULL,
            NULL,
            DEF_RATFLAGS_VAR, 
            dwRatFlags
            );
        if(ERROR_SUCCESS != hr)
        {
            hrRes = hr;
            
        }
    }
#endif
    return  hrRes;
}

			// null it out...
HRESULT 
Remove_EncDec_RegEntries()
{
    
    HKEY hkey;
    long r = OpenRegKey(DEF_ENCDEC_BASE,				// is key there?
        NULL,
        NULL,
        &hkey);
    
    long r2, r3, r4, r5;
    r2 = r3 = r4 = r5 = -1;									// default to non-zero
    if(ERROR_SUCCESS == r) 
    {
        r2 = RegDeleteValue(hkey,DEF_KID_VAR);			    // delete the value
        r3 = RegDeleteValue(hkey,DEF_KIDHASH_VAR);			// delete the value
        r4 = RegDeleteValue(hkey,DEF_CSFLAGS_VAR);	  	    // delete the value (may not be defined)
        r5 = RegDeleteValue(hkey,DEF_RATFLAGS_VAR);	  	    // delete the value (may not be defined)
        r = RegCloseKey(hkey);
    }   // don't care about inside error cases
    return (ERROR_SUCCESS == r) ? S_OK : HRESULT_FROM_WIN32(r);
}

//-----------------------------------------------------------------------------
// See  TveReg.h for documentation for all functions.
//-----------------------------------------------------------------------------

long OpenRegKey(HKEY hkeyRoot, 
                LPCTSTR szKey, 
                LPCTSTR szSubKey1,
                LPCTSTR szSubKey2, 
                HKEY *phkey,
                REGSAM sam /* = BPC_KEY_STD_ACCESS */, 
                BOOL fCreate /* = FALSE */)
{
    LONG r;
    TCHAR *szFullKey = NULL;
    
    if (szKey == NULL)
    {
        if (szSubKey1 != NULL)
        {
            szKey = szSubKey1;
            szSubKey1 = NULL;
        }
    }
    else
    {
        if (szSubKey1 == NULL && szSubKey2 != NULL)
        {
            szSubKey1 = szSubKey2;
            szSubKey2 = NULL;
        }
        
        if (szSubKey1 != NULL)
        {
            int cb = _tcsclen(szKey) + _tcsclen(szSubKey1) + 2;
            if (szSubKey2 != NULL)
                cb += _tcsclen(szSubKey2) + 1;
#ifdef _AFX
            try
            {
                szFullKey = new TCHAR[cb];
            }
            catch (CMemoryException *pe)
            {
                pe->Delete();
                return ERROR_NOT_ENOUGH_MEMORY;
            }
#else
            szFullKey = new TCHAR[cb];
            if (szFullKey == NULL)
                return ERROR_NOT_ENOUGH_MEMORY;
#endif
            
            _tcscpy(szFullKey, szKey);
            
            TCHAR *szT = szFullKey + _tcsclen(szFullKey);
            if (szT[-1] != _T('\\') && szSubKey1[0] != _T('\\'))
            {
                szT[0] = _T('\\');
                szT++;
            }
            _tcscpy(szT, szSubKey1);
            
            if (szSubKey2 != NULL)
            {
                szT += _tcsclen(szT);
                if (szT[-1] != _T('\\') && szSubKey2[0] != _T('\\'))
                {
                    szT[0] = _T('\\');
                    szT++;
                }
                _tcscpy(szT, szSubKey2);
            }
            szKey = szFullKey;
        }
    }
    
    if (fCreate && szKey != NULL)
    {
        DWORD dwDisposition;
        
        r = RegCreateKeyEx(hkeyRoot, szKey, 0, _T(""), 0, sam, NULL,
            phkey, &dwDisposition);
    }
    else
    {
        r = RegOpenKeyEx(hkeyRoot, szKey, 0, sam, phkey);
    }
    
    if (r != ERROR_SUCCESS)
    {
        if (szKey != NULL)
            TRACE_2(LOG_AREA_DRM, 3, _T("OpenRegKey(): can't open key '%s' %ld"), szKey, r);
        else
            TRACE_2(LOG_AREA_DRM, 3, _T("OpenRegKey(): can't duplicate key '%x'  %ld"), hkeyRoot, r);
    }
    
    if (szFullKey != NULL)
        delete [] szFullKey;
    
    return r;
}

long 
GetRegValue(HKEY hkeyRoot, 
            LPCTSTR szKey, 
            LPCTSTR szSubKey1,
            LPCTSTR szSubKey2, 
            LPCTSTR szValueName,
            DWORD dwType, 
            BYTE *pb, DWORD *pcb)
{
    DWORD dwTypeGot;
    HKEY hkey;
    LONG r = ERROR_SUCCESS;
    
    if (pb != NULL)
    {
        if(NULL == pcb || NULL == pb)
            return E_FAIL;
        
        memset(pb, 0, *pcb);
    }
    
    r = OpenRegKey(hkeyRoot, szKey, szSubKey1, szSubKey2, &hkey, KEY_READ);
    
    if (r == ERROR_SUCCESS)
    {
        r = RegQueryValueEx(hkey, szValueName, NULL, &dwTypeGot, pb, pcb);
        RegCloseKey(hkey);
        
#ifdef _DEBUG
        if (szValueName == NULL)
            szValueName = _T("<default>");
#endif
        
        if (r != ERROR_SUCCESS)
        {
            TRACE_2(LOG_AREA_DRM, 2,_T("GetRegValue(): can't read value '%s'  %ld"), szValueName, r);
        }
        else if (dwTypeGot != dwType)
        {
            if ((dwTypeGot == REG_BINARY) && (dwType == REG_DWORD) && (*pcb == sizeof(DWORD)))
            {
                // REG_DWORD is the same as 4 bytes of REG_BINARY
            }
            else
            {
                //                TRACE3(_T("GetRegValue(): '%s' is wrong type (%x != %x)"),
                //                        szValueName, dwTypeGot, dwType);
                r = ERROR_INVALID_DATATYPE;
            }
        }
    }
    
    return r;
}

long 
SetRegValue(HKEY hkeyRoot, 
            LPCTSTR szKey, 
            LPCTSTR szSubKey1,
            LPCTSTR szSubKey2, 
            LPCTSTR szValueName,
            DWORD dwType, 
            const BYTE *pb, DWORD cb)
{
    HKEY hkey;
    LONG r;
    
    r = OpenRegKey(hkeyRoot, szKey, szSubKey1, szSubKey2, &hkey, KEY_WRITE, TRUE);
    
    ASSERT(pb != NULL);
    
    if (r == ERROR_SUCCESS)
    {
        r = RegSetValueEx(hkey, szValueName, NULL, dwType, pb, cb);
        RegCloseKey(hkey);
        
#ifdef _DEBUG
        if (r != ERROR_SUCCESS)
        {
            if (szValueName == NULL)
                szValueName = _T("<default>");
            TRACE_2(LOG_AREA_DRM, 2,_T("SetRegValue(): can't write value '%s'  %ld"), szValueName, r);
        }
#endif
    }
    
    return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dll\resource.h ===
// resource.h
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSVidCtl.rc
//
#define IDS_PROJNAME                    500
// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        502
#define _APS_NEXT_COMMAND_VALUE         502
#define _APS_NEXT_CONTROL_VALUE         502
#define _APS_NEXT_SYMED_VALUE           502
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\drm.h ===
//-----------------------------------------------------------------------------
//
// File:   drm.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __DRM_H__
#define __DRM_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef DRMLITE_EXPORTS
#define DRMLITE_API __declspec(dllexport)
#else
#define DRMLITE_API __declspec(dllimport)
#endif

#include <wtypes.h>

#include "license.h"
#include "pmlic.h"
#include "objbase.h"

#define DRMCLIENT_VER   0x00010004

#define DRM_FATAL_ERROR(hr)     (HRESULT_CODE(hr) > 0x1000)  

// non-fatal error
#define E_DRM_LICENSE_NOTEXIST			(MAKE_HRESULT(1,FACILITY_ITF,0x0FFD))
#define E_DRM_LICENSE_INCORRECT_APPSEC	(MAKE_HRESULT(1,FACILITY_ITF,0x0FFE))
#define E_DRM_LICENSE_INCORRECT_RIGHTS	(MAKE_HRESULT(1,FACILITY_ITF,0x0FFF))
#define E_DRM_LICENSE_EXPIRED			(MAKE_HRESULT(1,FACILITY_ITF,0x1000))

// fatal error
#define E_DRM_LICENSE_INCONSISTENT		(MAKE_HRESULT(1,FACILITY_ITF,0x1001))
#define E_DRM_HARDWARE_INCONSISTENT		(MAKE_HRESULT(1,FACILITY_ITF,0x1002))
#define E_DRM_INCORRECT_VERSION			(MAKE_HRESULT(1,FACILITY_ITF,0x1003))
#define E_DRM_ALPHA_NOT_SUPPORTED		(MAKE_HRESULT(1,FACILITY_ITF,0x1004))
// This happens when the client does not have the secret alg id requested
#define E_DRM_NEED_UPGRADE				(MAKE_HRESULT(1,FACILITY_ITF,0x1005))
// Only used in the PD code
//#define E_DRM_MORE_DATA				(MAKE_HRESULT(1,FACILITY_ITF,0x1006))

#define E_DRM_SDMI_TRIGGER				(MAKE_HRESULT(1,FACILITY_ITF,0x1007))
#define E_DRM_SDMI_NOMORECOPIES			(MAKE_HRESULT(1,FACILITY_ITF,0x1008))


#define DRM_LICSRC_INETSERVER   1
#define DRM_LICSRC_SDKDLL       2

// For GetLicenses API
#define DRM_FL_SEARCH_PC		0x00000001
#define DRM_FL_SEARCH_PM		0x00000002

// For QueryXferToPM API
#define DRM_XFER_FL_HAS_SERIALID    0x00000001
#define DRM_XFER_IGNORE_XCODE       0x00000002
#define DRM_XFER_IGNORE_SDMI        0x00000004
#define DRM_XFER_IGNORE_NONSDMI     0x00000008

#define DRM_XFER_SDMI		    0x00000001
#define DRM_XFER_NONSDMI		0x00000002
#define DRM_XFER_DECRYPTED		0x00000003
#define DRM_XFER_SDMI_XCODED    0x00000004
#define DRM_XFER_NONSDMI_XCODED 0x00000005

// For GenerateNewLicenseEx API
#define GNL_EX_MODE_PDRM            0x00000001       // Use PDRM method to form KID/Key
#define GNL_EX_MODE_RANDOM          0x00000002       // generate random KID/Key
#define GNL_EX_MODE_SPECIFIC        0x00000004       // generate license for specific KID/Key


class CDRMLiteCrypto
{
private:
	void *m_var;

	HRESULT Init( );
	HRESULT GetSongKey(LPCSTR pszContentID, BYTE *pbAppSec, 
						BYTE *pbRights, BOOL *pfCanDecrypt, DWORD dwFlags);
	HRESULT GetSongKeyEx(LPCSTR pszContentID, BYTE *pbAppSec, 
						BYTE *pbRights, BOOL *pfCanDecrypt, BOOL fUsePMLic);
    HRESULT ContentKeyToPMContentKey(
                    BYTE *pbPMKey,
                    DWORD dwPMKeyLen,
					LICENSE *pLic,
                    BYTE *pbPMContentKey);
	HRESULT i_SetLicenseStore(
                        BYTE *pbLicenseStore,
                        DWORD dwLicenseStoreLen,
                        BYTE *pbPMID,
                        DWORD dwPMIDLen,
						LPCSTR pszPath);
	HRESULT i_SetPMID(BYTE *pbPMID, DWORD dwPMIDLen);
	HRESULT i_GetLicenses(						
						LPCSTR pszContentID,
						PMLICENSE *pPMLic,
						LPDWORD lpdwCount,
						DWORD dwFlags,
                        LPVOID lpReserved,
                        LPDWORD lpdwReservedLen);
    HRESULT i_QueryXferToPM(
                        LPCSTR pszContentID,
                        DWORD dwFlags,
                        LPDWORD lpdwXferMode );
    HRESULT i_CreatePMLicense(
                        LPCSTR pszContentID,
                        LPCSTR pszContentID2,
                        BOOL fIsSDMI,
                        BYTE *pbPMID,
                        DWORD dwPMIDLen,
                        BYTE *pbPMLicenseStoreBuf,
                        DWORD dwPMLicenseStoreBufLen,
                        LPDWORD pdwPMLicenseStoreLen,
                        BYTE *pbAsfLicenseStoreBuf,
                        DWORD dwAsfLicenseStoreBufLen,
                        LPDWORD pdwAsfLicenseStoreLen,
                        PMLICENSE *pPMLic,
                        BOOL bPMLicStore );
	HRESULT GenerateAndStoreLicense( 
						BYTE *pbAppSec,
						BYTE *pbRights,
						BYTE *pbExpiryDate,
						LPCSTR pszKID,
						const BYTE *pbKey );

    HRESULT GetMachineRandomKIDData( CHAR* pszRandomData, DWORD cbSize );

public:
    DRMLITE_API HRESULT KeyExchange( APPCERT *pAppcert, BYTE *pbRandNum );

    DRMLITE_API HRESULT InitAppCerts( APPCERT *pAppcert, APPCERT *pAppCert2 );

	DRMLITE_API HRESULT Bind(
						LPCSTR pszContentID,
						APPCERT *pAppCert,
						APPCERT *pAppCert2,
						BYTE *pbRights );

	DRMLITE_API HRESULT BindEx(
						LPCSTR pszContentID,
						APPCERT *pAppCert,
						APPCERT *pAppCert2,
						BYTE *pbRights,
                        LICENSEDATA *pLicData,
                        LPVOID lpReserved,
                        LPDWORD lpdwReservedLen,
                        BYTE *pbHash );

    DRMLITE_API HRESULT CanDecrypt(
                        LPCSTR pszContentID,
  						APPCERT *pAppCert,
						APPCERT *pAppCert2,
						BYTE *pbRights,
						BOOL *pfCanDecrypt );

    DRMLITE_API HRESULT CanDecryptEx(
                        LPCSTR pszContentID,
  						APPCERT *pAppCert,
						APPCERT *pAppCert2,
						BYTE *pbRights,
						BOOL *pfCanDecrypt );

	DRMLITE_API HRESULT Decrypt(
                        LPCSTR pszContentID,
                        DWORD dwLen,
                        BYTE *pData );
	
	DRMLITE_API HRESULT Encrypt(	
					    LPCSTR pszKey,
					    DWORD dwLen,
					    BYTE *pData,
                        BYTE *pbHash );

    DRMLITE_API HRESULT EncryptIndirectFast(	
                        LPCSTR pszKID,
                        DWORD dwLen,
                        BYTE *pData,
                        BYTE *pbHash );

    DRMLITE_API HRESULT GetPublicKey(
                        PKCERT *pPubKey );

    DRMLITE_API HRESULT RequestLicense(
                        LPCSTR pszContentID,
						APPCERT *pAppCert,
						APPCERT *pAppCert2,
						BYTE *pbRights,
                        LPSTR *ppszChallenge );

    DRMLITE_API HRESULT ProcessResponse(
                        LPCSTR pszResponse,
						APPCERT *pAppCert );

	DRMLITE_API HRESULT GenerateNewLicense(
								BYTE *pbAppSec,
								BYTE *pbRights,
								BYTE *pbExpiryDate,
								LPSTR *ppszKID,
								LPSTR *ppszEncryptKey,
								BYTE *pbHash );

	DRMLITE_API HRESULT GetVersion( LPDWORD lpdwVersion );

	DRMLITE_API HRESULT SetAppSec( 
						BYTE *pbAppSec,
						BYTE *pbHash );

	DRMLITE_API HRESULT SetLicenseStore(
                        BYTE *pbLicenseStore,
                        DWORD dwLicenseStoreLen,
                        BYTE *pbPMID,
                        DWORD dwPMIDLen,
						LPCSTR pszPath,
						BYTE *pbHash );

	DRMLITE_API HRESULT GetPMLicenseFileName(
                        LPSTR pszName,
                        LPDWORD pdwLen );

	DRMLITE_API HRESULT GetPMLicenseSize( LPDWORD pdwLen );

	DRMLITE_API HRESULT QueryXferToPM(
                        LPCSTR pszContentID,
                        DWORD dwFlags,
                        LPDWORD lpdwXferMode,
                        LPVOID lpReserved,
                        LPDWORD lpdwReservedLen,
                        BYTE *pbHash );

    DRMLITE_API HRESULT QueryXferToPMEx(
                        LPCSTR pszContentID,
                        DWORD dwFlags,
                        LPDWORD lpdwXferMode,
                        BYTE *pbPMID,
                        DWORD dwPMIDLen,
                        BYTE *pbLicenseStoreBuf,
                        DWORD dwLicenseStoreBufLen,
                        LPDWORD pdwLicenseStoreLen,
                        BYTE *pbHash );

	DRMLITE_API HRESULT CreatePMLicense(
						LPCSTR pszContentID,
						LPCSTR pszContentID2,
                        BOOL fIsSDMI,
                        BYTE *pbPMID,
                        DWORD dwPMIDLen,
                        BYTE *pbLicenseStoreBuf,
                        DWORD dwLicenseStoreBufLen, 
                        LPDWORD pdwLicenseStoreLen, 
                        PMLICENSE *pPMLic,
                        LPVOID lpReserved,
                        LPDWORD lpdwReservedLen,
                        BYTE *pbHash );

	DRMLITE_API HRESULT GetLicenses(						
						LPCSTR pszContentID,
						PMLICENSE *pPMLic,
						LPDWORD lpdwCount,
						DWORD dwFlags,
                        LPVOID lpReserved,
                        LPDWORD lpdwReservedLen,
                        BYTE *pbHash );

	DRMLITE_API CDRMLiteCrypto();
	DRMLITE_API ~CDRMLiteCrypto();
    DRMLITE_API HRESULT BackupLicenses(DWORD dwFlags, 
                                       LPWSTR pwszBackupPath, 
                                       IUnknown *pStatusCallback,
                                       BOOL *pfCancel,
                                       LPVOID pLock);

    DRMLITE_API HRESULT RestoreLicenses(DWORD dwFlags, 
                                        BYTE *pbBindData,
                                        LPWSTR pwszRestorePath, 
                                        IUnknown *pStatusCallback,
                                        BOOL *pfCancel,
                                        LPVOID pLock);

	DRMLITE_API HRESULT EncryptFast(	
					    LPCSTR pszKey,
					    DWORD dwLen,
					    BYTE *pData,
                        BYTE *pbHash );

    DRMLITE_API HRESULT GenerateNewLicenseEx(
                        DWORD dwFlags,
                        BYTE *pbAppSec,
                        BYTE *pbRights,
                        BYTE *pbExpiryDate,
                        LPSTR *ppszKID,
                        LPSTR *ppszEncryptKey, 
                        BYTE *pbHash );

private:

    HRESULT i_GenerateNewLicense(
								BYTE *pbAppSec,
								BYTE *pbRights,
								BYTE *pbExpiryDate,
								LPSTR *ppszKID,
								LPSTR *ppszEncryptKey);

    HRESULT i_Encrypt(	
				    LPCSTR pszKey,
				    DWORD dwLen,
				    BYTE *pData );

};

#endif  // __DRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\drmdefs.h ===
//-----------------------------------------------------------------------------
//
// File:   drmdefs.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef DRMDEFS_H
#define DRMDEFS_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _M_IX86
#ifdef OBFUSCATE
#define OBFUS
#define OBFUS1
#define OBFUS2
#define OBFUS3
#endif
#endif

#if ( _MSC_VER <= 1100 )

typedef unsigned int UINT32;
typedef unsigned __int64 UINT64;

#endif

#endif	// DRMDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\des.h ===
//-----------------------------------------------------------------------------
//
// File:   des.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __DES_H__
#define __DES_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef RSA32API

#if defined WIN32
#define RSA32API __stdcall
#elif defined _WIN32_WCE
#define RSA32API __stdcall
#else
#define RSA32API 
#endif

#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
    unsigned long   keytab[16][2];
} DESTable;

#define DES_TABLESIZE   (sizeof(DESTable))
#define DES_BLOCKLEN    (8)
#define DES_KEYSIZE     (8)

typedef struct _desxtable {
    unsigned char inWhitening[8];
    unsigned char outWhitening[8];
    DESTable desTable;
} DESXTable;

#define DESX_TABLESIZE  (sizeof(DESXTable))
#define DESX_BLOCKLEN   (8)
#define DESX_KEYSIZE    (24)

/* In deskey.c:

     Fill in the DESTable struct with the decrypt and encrypt
     key expansions.

     Assumes that the second parameter points to DES_BLOCKLEN
     bytes of key.

*/

void RSA32API deskey(DESTable *,BYTE *);

/* In desport.c:

     Encrypt or decrypt with the key in DESTable

*/

void RSA32API des(BYTE *pbOut, BYTE *pbIn, void *key, INT32 op);

//
// set the parity on the DES key to be odd
// NOTE : must be called before deskey
// key must be cbKey number of bytes
//
void RSA32API desparityonkey(BYTE *pbKey, DWORD cbKey);

//
// reduce the DES key to a 40 bit key
// NOTE : must be called before deskey
// key must be 8 bytes
//
void RSA32API desreducekey(BYTE *key);

// Expand 40 bit DES key to 64 and check weakness
// same as desreducekey except expands instead of weakening keys
void RSA32API deskeyexpand(BYTE *pbKey, BYTE *pbExpanded_key);


void
RSA32API
desexpand128to192(
    BYTE *pbKey,        // input 128bit or 192bit buffer
    BYTE *pbExpandedKey // output buffer (must be 192bit wide if pbKey == pbExpandedKey
    );

// DES-X routines

// initialize desX key struct.  key size is 24 bytes
void RSA32API desxkey(DESXTable *k, BYTE *key);

void RSA32API desx(BYTE *pbOut, BYTE *pbIn, void *keyin, INT32 op);


extern INT32 Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __DES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\drmcrypbase.h ===
//-----------------------------------------------------------------------------
//
// File:   drmcrypbase.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef DRMLITECRYPTOBASE_H
#define DRMLITECRYPTOBASE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <wtypes.h>


/////////////////////////////////////////////////////////////////////////////
class CDRMLiteCryptoBase
{
public:
    //
    // The tool will call this method to encrypt portions of data packets.
    // 
    virtual HRESULT Encrypt( LPCSTR pszKey, DWORD cbData, BYTE *pbData ) = 0;

    //
    // The client will call this method first to determine if the secret key
    // store is able to decrypt data with the given content ID.
    //
    virtual HRESULT CanDecrypt( LPCSTR pszContentID, BOOL *pfCanDecrypt ) = 0;

    //
    // The client will call this method to decrypt portions of data packets
    // which have been encrypted using the secret key associated with the
    // given content ID.
    // 
    virtual HRESULT Decrypt( LPCSTR pszContentID, DWORD cbData, BYTE *pbData ) = 0;

    //
    // If the client needs to obtain a secret key for the given content ID,
    // it will call this method to generate the challenge string that will
    // be passed in the clear to a server-side app.
    //
    // The challenge string returned should be a NULL-terminated string which
    // has already been encoded for use as an URL parameter, and should
    // be allocated using CoTaskMemAlloc.
    //
    virtual HRESULT GenerateChallenge( LPCSTR pszContentID, LPSTR *ppszChallenge ) = 0;

    //
    // When the client receives a response (passed in the clear) back from a
    // server-side app to a challenge which it issued, it should call this
    // method to store the decryption key encapsulated within the response
    // into the secret key store.  Note that the client instance receiving
    // the response may not necessarily be the same one that issued the
    // original challenge.
    //
    virtual HRESULT ProcessResponse( LPCSTR pszResponse ) = 0;
};


#endif  // DRMLITECRYPTOBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\keygen.h ===
//depot/private/dmd_DEV/eclipse/SDMIDRM/common/inc/keygen.h#1 - branch change 33725 (text)
#pragma once
//-----------------------------------------------------------------------------
//
// File:   keygen.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//  This files contains prototypes for using key generation algorithm.
//
// Author: K. Ganesan
//
//-----------------------------------------------------------------------------

#include <wtypes.h>
// Define key length in bytes. 
#define DRM_V1_CONTENT_KEY_LENGTH 7

void DRMReEncode(BYTE *buffer, size_t size); 
void DRMReDecode(BYTE *buffer, size_t size); 
void DRMGenerateKey(BYTE *ucKeySeed, size_t nKeySeedLength, BYTE *ucKeyId, size_t nKeyIdLength, BYTE *ucKey);
HRESULT __stdcall DRMHr64SzToBlob(LPCSTR in, BYTE **ppbBlob, DWORD *pcbBlob);
HRESULT __stdcall DRMHrBlobTo64Sz(BYTE* pbBlob, DWORD cbBlob, LPSTR *out);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\drmutil.h ===
//-----------------------------------------------------------------------------
//
// File:   drmutil.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __DRMUTIL_H__
#define __DRMUTIL_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "strutil.h"
#include "keygen.h"
#include "license.h"
#include "rc4.h"

void rc4args( RC4_KEYSTRUCT *rc4ks, APPCERT *pAppCert1, APPCERT *pAppCert2, BYTE *pRights );
void rc4args2( RC4_KEYSTRUCT *prc4ks, APPCERT *pAppCert1, APPCERT *pOutAppCert1,
            APPCERT *pAppCert2, APPCERT *pOutAppCert2,
            BYTE *pRights,  BYTE *pOutRights);

BYTE *FlipBits(BYTE *pbData, int iLen);

#ifdef _M_IX86
DWORD Byte2LittleEndian(BYTE *pb);
#endif
#ifdef _M_ALPHA
DWORD Byte2BigEndian(BYTE *pb);
BYTE *BigEndian2Byte(BYTE *pb, DWORD dwNum);
#endif

void LicDateToSysDate(BYTE *pbLicDate, SYSTEMTIME *pSysDate);
void SysDateToLicDate(SYSTEMTIME *pSysDate, BYTE *pbLicDate);

bool IsVersionOK(BYTE *pbVersion, BYTE *pbCurVersion);
bool IsDateOK(BYTE *pbLicDate);

HRESULT CheckCert(CERT *pCert, PUBKEY *ppk, bool fCheckCertDate);
HRESULT CheckLicenseCertChain(CERTIFIED_LICENSE *pCertLicense, bool fCheckCertDate);

DWORD GetDriveFormFactor(int iDrive);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\drmstub.h ===
//-----------------------------------------------------------------------------
//
// File:   drmstub.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __DRMSTUB_H__
#define __DRMSTUB_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <wtypes.h>


#include "drmcrypbase.h"
#include "drm.h"
#include "pkcrypto.h"
#include "rc4.h"
#include "sha.h"
#include "pmlic.h"

#include "drmutil.h"


class CDRMLite : CDRMLiteCryptoBase
{
private:
    HRESULT m_hrInit;
    PRIVKEY m_privkey;
    APPCERT  m_appcert;
    APPCERT  m_appcert2;
    BOOL m_fAppCert2;
    LPSTR m_lpszContentID;
    RC4_KEYSTRUCT m_rc4ksRand;        
    CDRMLiteCrypto *m_pDRMLiteCrypto;
    CDRMPKCrypto m_PKCrypto;
    BYTE m_bRights[RIGHTS_LEN];
    HRESULT Init();

    void DefInitV2()    { /* was v2 shim*/ }


public:
    HRESULT Encrypt(        
                    LPCSTR pszKey,
                    DWORD dwLen,
                    BYTE *pData );

    HRESULT CanDecrypt(    
                        LPCSTR pszContentID,
                        BOOL *pfCanDecrypt );

    HRESULT Decrypt(
                    LPCSTR pszContentID,
                    DWORD dwLen,
                    BYTE *pData );

    HRESULT GenerateChallenge(
                                LPCSTR pszContentID,
                                LPSTR *ppszChallenge );

    HRESULT ProcessResponse(
                            LPCSTR pszResponse );

    HRESULT GenerateNewLicense(
                            BYTE *pbAppSec,
                            BYTE *pbRights,
                            BYTE *pbExpiryDate,
                            LPSTR *ppszKID,
                            LPSTR *ppszEncryptKey);

    HRESULT GetVersion( LPDWORD lpdwVersion );

    HRESULT SetAppSec(BYTE *pbAppSec);

    HRESULT SetLicenseStore(
                        BYTE *pbLicenseStore,
                        DWORD dwLicenseStoreLen,
                        BYTE *pbPMID,
                        DWORD dwPMIDLen,
                        LPCSTR pszPath );

    HRESULT GetPMLicenseFileName(
                        LPSTR pszName,
                        LPDWORD pdwLen );

    HRESULT GetPMLicenseSize( LPDWORD pdwLen );

    HRESULT QueryXferToPM(
                        LPCSTR pszContentID,
                        DWORD dwFlags,
                        LPDWORD lpdwXferMode,
                        LPVOID lpReserved,
                        LPDWORD lpdwReservedLen );

    HRESULT QueryXferToPMEx(
                        LPCSTR pszContentID,
                        DWORD dwFlags,
                        LPDWORD lpdwXferMode,
                        BYTE *pbPMID,
                        DWORD dwPMIDLen,
                        BYTE *pbLicenseStoreBuf,
                        DWORD dwLicenseStoreBufLen,
                        LPDWORD pdwLicenseStoreLen );

    HRESULT CreatePMLicense(
                        LPCSTR pszContentID,
                        LPCSTR pszContentID2,
                        BOOL fIsSDMI,
                        BYTE *pbPMID,
                        DWORD dwPMIDLen,
                        BYTE *pbLicenseStoreBuf,
                        DWORD dwLicenseStoreBufLen,
                        LPDWORD pdwLicenseStoreLen,
                        PMLICENSE *pPMLic,
                        LPVOID lpReserved,
                        LPDWORD lpdwReservedLen );

    HRESULT GetLicenses(                        
                        LPCSTR pszContentID,
                        PMLICENSE *pPMLic,
                        LPDWORD lpdwCount,
                        DWORD dwFlags,
                        LPVOID lpReserved,
                        LPDWORD lpdwReservedLen );

    HRESULT SetAppCert(APPCERT *pAppCert);
    HRESULT SetRights(BYTE *pbRights);
    CDRMLite(); // in mainstub.cpp, sdkstub.cpp, sdmistub.cpp, etc.
    ~CDRMLite();
    HRESULT BackupLicenses(DWORD dwFlags, LPWSTR pwszBackupPath, IUnknown *pStatusCallback, BOOL *pfCancel, LPVOID pLock);
    HRESULT RestoreLicenses(DWORD dwFlags, BYTE *pbBindData, LPWSTR pwszRestorePath, IUnknown *pStatusCallback, BOOL *pfCancel, LPVOID pLock);

    HRESULT EncryptFast(        
                    LPCSTR pszKey,
                    DWORD dwLen,
                    BYTE *pData );

    HRESULT EncryptIndirectFast(	
                    LPCSTR pszContentID,
                    DWORD dwLen,
                    BYTE *pData );

    HRESULT GenerateNewLicenseEx(
                    DWORD dwFlags,
                    BYTE *pbAppSec,
                    BYTE *pbRights,
                    BYTE *pbExpiryDate,
                    LPSTR *ppszKID,
                    LPSTR *ppszEncryptKey );

};

#endif  // __DRMSTUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\licbase.h ===
//-----------------------------------------------------------------------------
//
// File:   licbase.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __LICBASE_H__
#define __LICBASE_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define KIDLEN		25

#define VERSION_LEN          4
#define DATE_LEN             4
#define RIGHTS_LEN           4
#define APPSEC_LEN           4
#define INT_LEN				 4

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\drmerr.h ===
//----------------------------------------------------------------------------
// File: drmerr.h
//
// Copyright (C) Microsoft Corporation, 1997 - 1999, All rights reserved.
//
// Description
// Includes some helpful define and macros for error flow control.
//
// Author: dongi
//----------------------------------------------------------------------------

#ifndef __DRMERR_H__
#define __DRMERR_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// ----------------- BEGIN HACK ----------------------------------------
// author: Davidme (though I don't want the credit!)
// date:   Sept 16, 1998
//
// The problem is that the CORg macros depend on using the Error label
// and ADO defines the symbol Error in adoint.h.  So any code that wants
// to use both this file and ADO breaks.  The hack is to fool adoint.h
// to not define the Error symbol.  This should not affect any C++ code
// that uses adoint.h since the Error symbol is defined in adoint.h only
// if the __cplusplus is not defined.
//
// The easy workaround if you get the error below is to #include this file
// before including adoint.h.
//
// Hopefully this hack is less intrusive than the previous one!

#ifdef _ADOINT_H_
#error Name collision with ADO's Error symbol and this file's use of the Error label.  To fix this problem,\
 define __Error_FWD_DEFINED__ before including adoint.h or include this header file before including adoint.h.
#else
#define __Error_FWD_DEFINED__
#endif  // _ADOINT_H_

// ----------------- END HACK ------------------------------------------


#include <wtypes.h>

/*----------------------------------------------------------------------------
	Some hungarian style definitions
 ----------------------------------------------------------------------------*/


#ifndef fFalse
#define	fFalse		0
#define fTrue		1

#define hrOK		HRESULT(S_OK)
#define hrTrue		HRESULT(S_OK)
#define hrFalse		ResultFromScode(S_FALSE)
#define hrFail		ResultFromScode(E_FAIL)
#define hrNotImpl	ResultFromScode(E_NOTIMPL)
#define hrNoInterface	ResultFromScode(E_NOINTERFACE)
#define hrNoMem	ResultFromScode(E_OUTOFMEMORY)
#define hrAbort		ResultFromScode(E_ABORT)
#define hrInvalidArg	ResultFromScode(E_INVALIDARG)
#endif

#define MSCSAssert(f) ((void)0)

#define HRESULT_FROM_ADO_ERROR(hr)   ((hr == S_OK) ? S_OK : ((HRESULT) (hr | 0x80000000)) )


/*----------------------------------------------------------------------------
	CORg style error handling
	(Historicaly stands for Check OLE Result and Goto)
 ----------------------------------------------------------------------------*/


#define DebugMessageCPRg(pwszFile, nLine)
#define DebugMessageCORg(pwszFile, nLine, hr)
#define DebugMessageCFRg(pwszFile, nLine)
#define DebugMessageCADORg(pwszFile, nLine, hr)

#define _UNITEXT(quote) L##quote
#define UNITEXT(quote) _UNITEXT(quote)


#ifndef CPRg
#define	CPRg(p)\
	do\
		{\
		if (!(p))\
			{\
            DebugMessageCPRg(UNITEXT(__FILE__), __LINE__);\
			hr = hrNoMem;\
			goto Error;\
			}\
		}\
	while (fFalse)

#define	CHRg(hResult) CORg(hResult)

#define	CORg(hResult)\
	do\
		{\
		hr = (hResult);\
        if (FAILED(hr))\
            {\
            DebugMessageCORg(UNITEXT(__FILE__), __LINE__, hr);\
            goto Error;\
            }\
		}\
	while (fFalse)

#define	CADORg(hResult)\
	do\
		{\
		hr = (hResult);\
        if (hr!=S_OK && hr!=S_FALSE)\
            {\
            hr = HRESULT_FROM_ADO_ERROR(hr);\
            DebugMessageCADORg(UNITEXT(__FILE__), __LINE__, hr);\
            goto Error;\
            }\
		}\
	while (fFalse)

#define	CORgl(label, hResult)\
	do\
		{\
		hr = (hResult);\
        if (FAILED(hr))\
            {\
            DebugMessageCORg(UNITEXT(__FILE__), __LINE__, hr);\
            goto label;\
            }\
		}\
	while (fFalse)

#define	CWRg(fResult)\
	{\
	if (!(fResult))\
		{\
        hr = GetLastError();\
	    if (!(hr & 0xFFFF0000)) hr = HRESULT_FROM_WIN32(hr);\
        DebugMessageCORg(UNITEXT(__FILE__), __LINE__, hr);\
		goto Error;\
		}\
	}

#define	CWRgl(label, fResult)\
	{\
	if (!(fResult))\
		{\
        hr = GetLastError();\
		if (!(hr & 0xFFFF0000)) hr = HRESULT_FROM_WIN32(hr);\
        DebugMessageCORg(UNITEXT(__FILE__), __LINE__, hr);\
		goto label;\
		}\
	}

#define	CFRg(fResult)\
	{\
	if (!(fResult))\
		{\
        DebugMessageCFRg(UNITEXT(__FILE__), __LINE__);\
		hr = hrFail;\
		goto Error;\
		}\
	}

#define	CFRgl(label, fResult)\
	{\
	if (!(fResult))\
		{\
        DebugMessageCFRg(UNITEXT(__FILE__), __LINE__);\
		hr = hrFail;\
		goto label;\
		}\
	}

#define	CARg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = hrInvalidArg;\
			goto Error;\
			}\
		}\
	while (fFalse)
#endif



//+---------------------------------------------------------------------------
//
//  The custom _Assert we formerly used has been replaced with one that calls
//  the C run-time _CrtDbgReport method (same as _ASSERTE).  If your project
//  doesn't link with the C run-time for some reason, you must provide your own
//  definition for _Assert before including this header file.
//
//  I recommend using the _Assert macro and not _ASSERTE because you can replace
//  the implementation later by defining your own before including this header.
//
//  IMPORTANT: If your code runs as a service or is an object that runs in a
//      service, you should use the INSTALL_ASSERT_EVENTLOG_HOOK macro to
//      install a handler that turns off the default functionality of popping
//      up a message box when an assertion occurs in favor of logging it to
//      the EventLog and debug console and then kicking you into the debugger.
//      This way your service won't hang trying to pop up a window.
//
//  History:    09/17/98    davidme     switched to using this CRT implementation
//
//----------------------------------------------------------------------------


#ifndef _Assert
#ifdef _DEBUG

#include <crtdbg.h>
#define _Assert(f)          _ASSERTE(f)     // use crtdbg's ASSERT
int AssertEventlogHook( int, char *, int * );
#define INSTALL_ASSERT_EVENTLOG_HOOK    _CrtSetReportHook(AssertEventlogHook);

#else   // _DEBUG

#define _Assert(f)          ((void)0)
#define INSTALL_ASSERT_EVENTLOG_HOOK

#endif // _DEBUG
#endif // _Assert


#endif // __MSCSERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\obfus.h ===
// -----------------------------------------------
//  obfus.h
//
//
//
// -----------------------------------------------

#include "vsplabl20.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\license.h ===
//depot/private/dmd_DEV/eclipse/SDMIDRM/common/inc/license.h#1 - branch change 33725 (text)
//-----------------------------------------------------------------------------
//
// File:   license.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __LICENSE_H__
#define __LICENSE_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "licbase.h"
#include "pkcrypto.h"

#define SER_NUM_LEN          4
#define ISSUER_LEN           4
#define SUBJ_LEN             4

const BYTE PK_VER[VERSION_LEN] = {0, 1, 0, 0};
const BYTE LICREQUEST_VER[VERSION_LEN] = {0, 1, 0, 1};
const BYTE CERT_VER[VERSION_LEN] = {0, 1, 0, 0};
const BYTE APPCERT_VER[VERSION_LEN] = {0, 1, 0, 0};

const BYTE DRM_LICVER_FLEXKEY1[VERSION_LEN] = {0, 1, 0, 1};
const BYTE DRM_LICVER_PREBETA_LICSRVR[VERSION_LEN] = {0, 1, 0, 0};
const BYTE LICENSE_VER[VERSION_LEN] = {0, 1, 0, 0};

#define DRM_SDK1_CONTENT_KEY_LENGTH     6

const BYTE APPCERT_SUBJECT_DRMSTUB[SUBJ_LEN] = {0, 0, 0, 1};
const BYTE APPCERT_SUBJECT_SDKSTUB[SUBJ_LEN] = {0, 0, 0, 2};
const BYTE APPCERT_SUBJECT_SDKSTUBS[][SUBJ_LEN] =   {   {0, 0, 0, 2},
                                                        {0, 0, 0, 10},
                                                        {0, 0, 0, 14},
                                                        {0, 0, 0, 18}
                                                    };
const int NUM_APPCERT_SUBJECT_SDKSTUBS = sizeof(APPCERT_SUBJECT_SDKSTUBS)/SUBJ_LEN;

#define APPCERT_SUBJECT_SDKSTUBS_RANGE_MIN     50
#define APPCERT_SUBJECT_SDKSTUBS_RANGE_MAX     75

const BYTE CERT_ISSUER_SDK[SUBJ_LEN] = {0, 0, 0, 0};
const BYTE CERT_ISSUER_BKUPRESTORE[SUBJ_LEN] = {0, 0, 0, 0};
const BYTE CERT_SUBJECT_SDK[SUBJ_LEN] = {0, 0, 0, 2};
const BYTE CERT_SUBJECT_SDK1_2[SUBJ_LEN] = {0, 0, 0, 3};
const BYTE CERT_SUBJECT_BKUPRESTORE[SUBJ_LEN] = {0, 0, 0, 4};

typedef struct {
	PUBKEY pk;
	BYTE version[VERSION_LEN];
} PK;

typedef struct {
	PK pk;
	BYTE sign[PK_ENC_SIGNATURE_LEN];
} PKCERT;


typedef struct {
	PK pk;
	BYTE appSec[APPSEC_LEN];
	BYTE subject[SUBJ_LEN];
} APPCERTDATA;

typedef struct {
	BYTE appcertVersion[VERSION_LEN];
	BYTE datalen[INT_LEN];
	BYTE sign[PK_ENC_SIGNATURE_LEN];
	APPCERTDATA appcd;
} APPCERT;


#define CKEYLEN		7
#define EXPORTKEYLEN    7

const BYTE RIGHT_NONE[RIGHTS_LEN] = {0x0, 0x0, 0x0, 0x0};
const BYTE RIGHT1[RIGHTS_LEN] = {0x1, 0x0, 0x0, 0x0};
const BYTE RIGHT2[RIGHTS_LEN] = {0x2, 0x0, 0x0, 0x0};

const BYTE RIGHT_PLAY_ON_PC[RIGHTS_LEN] = {0x1, 0x0, 0x0, 0x0};
const BYTE RIGHT_COPY_TO_NONSDMI_DEVICE[RIGHTS_LEN] = {0x2, 0x0, 0x0, 0x0};
const BYTE RIGHT_NO_RESTORE[RIGHTS_LEN] = {0x4, 0x0, 0x0, 0x0};
const BYTE RIGHT_BURN_TO_CD[RIGHTS_LEN] = {0x8, 0x0, 0x0, 0x0};
const BYTE RIGHT_COPY_TO_SDMI_DEVICE[RIGHTS_LEN] = {0x10, 0x0, 0x0, 0x0};
const BYTE RIGHT_ONE_TIME[RIGHTS_LEN]   = {0x20, 0x0, 0x0, 0x0};
const BYTE RIGHT_SDMI_TRIGGER[RIGHTS_LEN]       = {0x0, 0x0, 0x1, 0x0};
const BYTE RIGHT_SDMI_NOMORECOPIES[RIGHTS_LEN]  = {0x0, 0x0, 0x2, 0x0};

const BYTE APPSEC_MAX[APPSEC_LEN] = {0xFF, 0xFF, 0xFF, 0xFF};
const BYTE APPSEC_MPLAYER[APPSEC_LEN] = {0, 0, 0x3, 0xE8}; // level 1000
const BYTE APPSEC_SDK[APPSEC_LEN] = {0, 0, 0x3, 0xE8};     // level 1000

typedef struct {
	char KID[KIDLEN];
	BYTE key[PK_ENC_CIPHERTEXT_LEN];	// encrypted with DRM PK
	BYTE rights[RIGHTS_LEN];
	BYTE appSec[APPSEC_LEN];
	BYTE expiryDate[DATE_LEN];
} LICENSEDATA;

typedef struct {
	BYTE licVersion[VERSION_LEN];
	BYTE datalen[INT_LEN];
	BYTE sign[PK_ENC_SIGNATURE_LEN];	// signature over licensedata
	LICENSEDATA ld;
} LICENSE;

typedef struct {
	char KID[KIDLEN];
	BYTE rights[RIGHTS_LEN];
	BYTE appSec[APPSEC_LEN];
} LICREQDATA;

typedef struct {
	BYTE licReqVersion[VERSION_LEN];
	PKCERT pk;
	LICREQDATA reqData;
} LICREQUEST;

typedef struct {
	BYTE licReqVersion[VERSION_LEN];
    BYTE licReqRandNum[PK_ENC_CIPHERTEXT_LEN];
    PKCERT pk;
	LICREQDATA reqData;
} LICREQUEST2;

//----------------cert section -----------------------
typedef struct {
	PUBKEY pk;
	BYTE expiryDate[DATE_LEN];
	BYTE serialNumber[SER_NUM_LEN];
	BYTE issuer[ISSUER_LEN];
	BYTE subject[SUBJ_LEN];
} CERTDATA;


typedef struct {
	BYTE certVersion[VERSION_LEN];
	BYTE datalen[INT_LEN];
	BYTE sign[PK_ENC_SIGNATURE_LEN];
	CERTDATA cd;
} CERT;


typedef struct {
	LICENSE license;
	CERT cert1;
	CERT cert2;
} CERTIFIED_LICENSE;


bool satisfies( LICENSEDATA *pLicCriterion, LICENSEDATA *pLicCandidate );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\obfbytes.h ===
//-----------------------------------------------------------------------------
//
// File:   obfbytes.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//	simple attempt to store secret data in a somewhat non-obvious way
//
// Author:	marcuspe
//
//-----------------------------------------------------------------------------

#ifndef __OBFBYTES_H__
#define __OBFBYTES_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <wtypes.h>

#define OBFBYTESLEN	4096

class CObfBytes {
private:
	BYTE *pData;
	bool hasContent;
public:
	CObfBytes();
	~CObfBytes();
	HRESULT fromClear( DWORD dwLen, BYTE *buf );
	HRESULT toClear( BYTE *buf );
    HRESULT toClear2( BYTE *buf ); // returns buf of original length which depends only
                                    // on the original bytes, but which differs from orig. bytes
	HRESULT getObf( BYTE *buf );
	HRESULT setObf( BYTE *buf );
//	DWORD random();
};




#endif // __OBFBYTES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\pkcrypto.h ===
//-----------------------------------------------------------------------------
//
// File:   pkcrypto.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//  public key crypto library
//
// Author:	marcuspe
//
//-----------------------------------------------------------------------------

#ifndef __DRMPKCRYPTO_H__
#define __DRMPKCRYPTO_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <wtypes.h>

#define LNGQDW 5

/*
typedef struct {
	DWORD y[2*LNGQDW];
} PUBKEY;

typedef struct {
	DWORD x[LNGQDW];
} PRIVKEY;
*/

#define PK_ENC_PUBLIC_KEY_LEN	(2 * LNGQDW * sizeof(DWORD))
#define PK_ENC_PRIVATE_KEY_LEN	(    LNGQDW * sizeof(DWORD))
#define PK_ENC_PLAINTEXT_LEN	((LNGQDW-1) * sizeof(DWORD))
#define PK_ENC_CIPHERTEXT_LEN	(4 * LNGQDW * sizeof(DWORD))
#define PK_ENC_SIGNATURE_LEN	(2 * LNGQDW * sizeof(DWORD))


typedef struct {
	BYTE y[ PK_ENC_PUBLIC_KEY_LEN ];
} PUBKEY;

typedef struct {
	BYTE x[ PK_ENC_PRIVATE_KEY_LEN ];
} PRIVKEY;



class CDRMPKCrypto {
private:
	char *pkd;
public:
	CDRMPKCrypto();
	~CDRMPKCrypto();
	HRESULT PKinit();
	HRESULT PKencrypt( PUBKEY *pk, BYTE *in, BYTE *out );
	HRESULT PKdecrypt( PRIVKEY *pk, BYTE *in, BYTE *out );
	HRESULT PKsign( PRIVKEY *privkey, BYTE  *buffer, DWORD lbuf, BYTE *sign );
	BOOL PKverify( PUBKEY *pubkey, BYTE *buffer, DWORD lbuf, BYTE *sign );
	HRESULT PKGenKeyPair( PUBKEY *pPub, PRIVKEY *pPriv );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\rc4.h ===
//-----------------------------------------------------------------------------
//
// File:   rc4.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __RC4_H__
#define __RC4_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef RSA32API

#if defined WIN32
#define RSA32API __stdcall
#elif defined _WIN32_WCE
#define RSA32API __stdcall
#else
#define RSA32API 
#endif

#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Key structure */
typedef struct RC4_KEYSTRUCT
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
#ifdef NODWORDALIGN  
  WORD wDummy; 
#endif
} RC4_KEYSTRUCT;

/* rc4_key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *   Key        A KEYSTRUCT structure that will be initialized.
 *   dwLen      Size of the key, in bytes.
 *   pbKey      Pointer to the key.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4_key(struct RC4_KEYSTRUCT *pKS, UINT32 dwLen, BYTE *pbKey);

/* rc4()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *   pKS        Pointer to the KEYSTRUCT created using rc4_key().
 *   dwLen      Size of buffer, in bytes.
 *   pbuf       Buffer to be encrypted.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4(struct RC4_KEYSTRUCT *pKS, UINT32 dwLen, BYTE *pbuf);

#ifdef __cplusplus
}
#endif

#endif // __RC4_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\pmlic.h ===
//-----------------------------------------------------------------------------
//
// File:   pmlic.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __PMLIC_H__
#define __PMLIC_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "licbase.h"


//#define PM_CONTENTKEY_LEN    PK_ENC_PLAINTEXT_LEN
#define PM_CONTENTKEY_LEN   16 

static const BYTE PMLICENSE_VER[VERSION_LEN] = {0, 1, 0, 2};


typedef struct {
	char KID[KIDLEN];
	BYTE key[PM_CONTENTKEY_LEN];	
	BYTE rights[RIGHTS_LEN];
	BYTE appSec[APPSEC_LEN];
	BYTE expiryDate[DATE_LEN];  
#ifdef NODWORDALIGN  
  BYTE cDummy; 
#endif
    WORD wAlgID;		// Identifier to tell which secret should be used to
						//  convert PMID to PMKey
	WORD wPMKeyLen;		// Length of key used to encrypt the content key
#ifdef NODWORDALIGN  
  WORD wDummy; 
#endif
    DWORD dwFlags;		// Reserved for future use 
						//  eg. License disabled bit 
} PMLICENSEDATA;

typedef struct {
	BYTE licVersion[VERSION_LEN];
	DWORD datalen;
	PMLICENSEDATA ld;
} PMLICENSE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\sha.h ===
//-----------------------------------------------------------------------------
//
// File:   sha.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef RSA32API

#if defined WIN32
#define RSA32API __stdcall
#elif defined _WIN32_WCE
#define RSA32API __stdcall
#else
#define RSA32API 
#endif

#endif

#ifdef __cplusplus
extern "C" {
#endif

#define A_SHA_DIGEST_LEN 20

typedef struct {
    DWORD       FinishFlag;
    BYTE        HashVal[A_SHA_DIGEST_LEN]; 
#ifdef NODWORDALIGN  
  WORD wDummy; 
#endif
    DWORD state[5];                             /* state (ABCDE) */
    DWORD count[2];                             /* number of bytes, msb first */
    unsigned char buffer[64];                   /* input buffer */
} A_SHA_CTX;

void RSA32API A_SHAInit(A_SHA_CTX *);
void RSA32API A_SHAUpdate(A_SHA_CTX *, unsigned char *, UINT32);
void RSA32API A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

//
// versions that don't internally byteswap (NoSwap version), for apps like
// the RNG that don't need hash compatibility - perf increase helps.
//

void RSA32API A_SHAUpdateNS(A_SHA_CTX *, unsigned char *, UINT32);
void RSA32API A_SHAFinalNS(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drminc\strutil.h ===
/*----------------------------------------------------------------------------
	strutil.h

		Includes some helpful string functions and smart pointers.

	Copyright (C) Microsoft Corporation, 1997 - 1999
	All rights reserved.

	Authors:
		DonGi	Don Gillett, Microsoft

        davidme 10/26/98    Made member variables of smart pointers public so
                            that you can get around bogus _Assert on operator &
                            by taking the address of the member itself (use with
                            caution, of course)
 ----------------------------------------------------------------------------*/

#ifndef __STRUTIL_H__
#define __STRUTIL_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <stdio.h>
#include <objbase.h>

#ifndef __DRMERR_H__
#include "drmerr.h"
#endif

LPWSTR WszDupWsz(LPCWSTR wsz);
void ctoh(BYTE c, BYTE b[]);
void htoc(BYTE *c, BYTE b[]);
HRESULT HrHSzToBlob(LPCSTR in, BYTE** ppbBlob, DWORD *pcbBlob);
HRESULT HrBlobToHSz(BYTE* pbBlob, DWORD cbBlob, LPSTR *out);
HRESULT Hr64SzToBlob(LPCSTR in, BYTE **ppbBlob, DWORD *pcbBlob);
HRESULT HrBlobTo64Sz(BYTE* pbBlob, DWORD cbBlob, LPSTR *out);
HRESULT HrSzToWSz(LPCSTR sz, size_t len, WCHAR** ppwsz, UINT cp = CP_ACP);
HRESULT HrSzToWSz(LPCSTR sz, WCHAR** ppwsz, UINT cp = CP_ACP);
HRESULT HrWSzToSzBuf(LPCWSTR wsz, LPSTR sz, int nMaxLen, UINT cp = CP_ACP );
HRESULT HrWSzToSz(LPCWSTR wsz, LPSTR* psz, UINT cp = CP_ACP);

class SPSZ
{
public:
	SPSZ() {p=NULL;}
	~SPSZ() {if (p) delete [] (p);}
	operator CHAR*() {return p;}
    CHAR& operator*() { _Assert(p!=NULL); return *p; }
    CHAR** operator&() { _Assert(p==NULL); return &p; }
    CHAR* operator=(CHAR* lp){ _Assert(p==NULL); return p = lp;}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
	void Free() {if (p) delete [] (p); p=NULL;}
    void Release() {if (p) delete [] (p); p=NULL;}

    CHAR* p;
};

class SPWSZ
{
public:
	SPWSZ() {p=NULL;}
	~SPWSZ() {if (p) delete [] (p);}
	operator WCHAR*() {return p;}
    WCHAR& operator*() { _Assert(p!=NULL); return *p; }
    WCHAR** operator&() { _Assert(p==NULL); return &p; }
    WCHAR* operator=(WCHAR* lp){ _Assert(p==NULL); return p = lp;}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
	void Free() {if (p) delete [] (p); p=NULL;}
    void Release() {if (p) delete [] (p); p=NULL;}

    WCHAR* p;
};

class SBSTR
{
public:
	SBSTR() {p=NULL;}
	~SBSTR() {if (p) SysFreeString(p);}
	operator WCHAR*() {return p;}
    WCHAR& operator*() { _Assert(p!=NULL); return *p; }
    WCHAR** operator&() { _Assert(p==NULL); return &p; }
    WCHAR* operator=(WCHAR* lp){ _Assert(p==NULL); return p = lp;}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
	void Free() {if (p) SysFreeString(p); p=NULL;}
    void Release() {if (p) SysFreeString(p); p=NULL;}

    BSTR p;
};

class MapWSzToPtr
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		SPWSZ spwszKey;
		void* value;
	};

public:

// Construction
	MapWSzToPtr(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCWSTR key, void*& rValue) const;
	BOOL LookupKey(LPCWSTR key, LPCWSTR& rKey) const;

// Operations
	// Lookup and add if not there
	void*& operator[](LPCWSTR key);

	// add a new (key, value) pair
	void SetAt(LPCWSTR key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCWSTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	DWORD GetStartPosition() const;
	void GetNextAssoc(DWORD& rNextPosition, LPWSTR* pKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCWSTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCWSTR, UINT&) const;

public:
	~MapWSzToPtr();

protected:
	// local typedefs for CTypedPtrMap class template
	typedef LPWSTR BASE_KEY;
	typedef LPCWSTR BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};

inline int MapWSzToPtr::GetCount() const
	{ return m_nCount; }
inline BOOL MapWSzToPtr::IsEmpty() const
	{ return m_nCount == 0; }
inline void MapWSzToPtr::SetAt(LPCWSTR key, void* newValue)
	{ (*this)[key] = newValue; }
inline DWORD MapWSzToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : -1; }
inline UINT MapWSzToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


/////////////////////////////////////////////////////////////////////////////
// TTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class TTypedPtrMap : public BASE_CLASS
{
public:

// Construction
	TTypedPtrMap(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// Lookup
	BOOL Lookup(typename BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](typename BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// add a new key (key, value) pair
	void SetAt(KEY key, VALUE newValue)
		{ BASE_CLASS::SetAt(key, newValue); }

	// removing existing (key, ?) pair
	BOOL RemoveKey(KEY key)
		{ return BASE_CLASS::RemoveKey(key); }

	// iteration
	void GetNextAssoc(DWORD& rPosition, KEY* pKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY*)pKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};


HRESULT HrAppendN(BSTR* pbstrDest, LPCWSTR wsz, int nChar);
HRESULT HrAppend(BSTR* pbstrDest, LPCWSTR wsz);
HRESULT HrAppendEqEncoded(BSTR* pbstrURL, LPCWSTR wsz);
HRESULT HrAppendEqDecoded(BSTR* pbstrURL, LPCWSTR wsz);
HRESULT HrAppendHTMLEncoded(BSTR* pbstrUTL, LPCWSTR wsz);

#endif // __STRUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\drmtest\drmlitetest.cpp ===
//-----------------------------------------------------------------------------
//
// File:   drmlitetest.cpp
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//		original link lib was: .\lib,.\checked
//				changed to	 : ..\DrmLib, ..\DrmLib\Checked
//
// Need to add  f:\nt1\tools\x86 to Tools\Directories\Executables path
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <objbase.h>

#include "des.h"
#include "sha.h"
#include "pkcrypto.h"
#include "drmerr.h"
#include "drmstub.h"
#include "drmutil.h"
#include "license.h"

#define PACKET_LEN          128

static const BYTE NO_EXPIRY_DATE[DATE_LEN] = {0xFF, 0xFF, 0xFF, 0xFF};

INT TestDRMLite( VOID )
{
	HRESULT   hr;
	CDRMLite  cDRMLite;
    BYTE      bAppSec[APPSEC_LEN]        = {0x0, 0x0, 0x3, 0xE8};    // 1000
    BYTE      bGenLicRights[RIGHTS_LEN]  = {0x13, 0x0, 0x0, 0x0};    // 0x1=PlayOnPC, 0x2=XfertoNonSDMI, 0x4=NoBackupRestore, 0x8=BurnToCD, 0x10=XferToSDMI
    BYTE      bDecryptRights[RIGHTS_LEN] = {0x01, 0x0, 0x0, 0x0};    // 0x1=PlayOnPC
    LPSTR     pszKID                     = NULL;
    LPSTR     pszEncryptKey              = NULL;
    BYTE     *pbTmp                      = NULL;
    DWORD     dwLen;
    INT       i;
	BYTE      data[ PACKET_LEN ];
    BOOL      fCanDecrypt;

    // Generate a new license
    // KID and EncryptKey are allocated and returned as base64-encoded strings in the output buffers
    //
	hr = cDRMLite.GenerateNewLicense(
        bAppSec,
        bGenLicRights,
        (BYTE *)NO_EXPIRY_DATE,
        &pszKID,
        &pszEncryptKey );
	printf( "GenerateNewLicense (0x%x)\n", hr );
    CORg( hr );

    printf( "KID=%s\nEncryptKey=%s\n", pszKID, pszEncryptKey );

    // Convert key from string to raw byte data
    // pmTmp is allocated inside the call to DRMHr64SzToBlob
    //
    hr = DRMHr64SzToBlob( pszEncryptKey, &pbTmp, &dwLen );
    CORg( hr );

    printf("EncryptKey=");
    for( i=0; i<(int)dwLen; i++ )
    {
        printf("0x%0x ", *(pbTmp+i));
    }
    printf("\n");

    // Initialize clear data buffer
    //
	for( i=0; i<PACKET_LEN; i++ )
    {
        data[i] = 'a';
    }

    // Display clear data buffer
    //
	for( i=0; i<PACKET_LEN; i++ )
    {
        printf("%02x",data[i] );
    }
    printf("\n");
    
    // Encrypt the data
    //
	hr = cDRMLite.Encrypt( pszEncryptKey, PACKET_LEN, data );
	printf( "Encrypt (0x%x)\n", hr );
    CORg( hr );

    // Display the encrypted buffer
    //
	for( i=0; i<PACKET_LEN; i++ )
    {
		printf("%02x",data[i] );
    }
    printf("\n");

    // Set the rights to use for decryption
    //
    hr = cDRMLite.SetRights( bDecryptRights );
    CORg( hr );

    // Check to verify the data can be decrypted
    //
   	hr = cDRMLite.CanDecrypt( pszKID, &fCanDecrypt );
	printf( "CanDecrypt = 0x%x (0x%x)\n", fCanDecrypt, hr );
    CORg( hr );

    // Decrypt the data buffer
    //
	hr = cDRMLite.Decrypt( pszKID, PACKET_LEN, data );
	printf( "Decrypt (0x%x)\n", hr );
    CORg( hr );

    // Display the decrypted buffer
    //
	for( i=0; i<PACKET_LEN; i++ )
    {
		printf("%02x",data[i] );
    }
    printf("\n");

Error:

    if( pbTmp )
    {
        delete [] pbTmp;
    }
    if( pszKID )
    {
        CoTaskMemFree( pszKID );
    }
    if( pszEncryptKey )
    {
        CoTaskMemFree( pszEncryptKey );
    }

    return hr; 
}


int __cdecl main( int argc, char *argv[] )
{
	TestDRMLite();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dtfilter\dtfilter_res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DTFilter.rc
//
//  note - think we need to keep #defines different
//		    than those in ETFilter_res.h
//
//#define	IDS_PROJNAME					200

#define IDS_DTFILTER_ENCPROPNAME        201
#define IDS_DTFILTER_TAGSPROPNAME       202
#define IDD_DTFILTER_ENCPROPPAGE        206
#define IDD_DTFILTER_TAGSPROPPAGE       207
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         400
#define _APS_NEXT_SYMED_VALUE           400
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dtfilter\dtfilter.cpp ===
/*++

    Copyright (c) 2002 Microsoft Corporation

    Module Name:

        DTFilter.cpp

    Abstract:

        This module contains the Encrypter/Tagger filter code.

    Author:

        J.Bradstreet (johnbrad)

    Revision History:

        07-Mar-2002    created


    Note - there are 3+ versions of this filter running simulatneously in the
    same graph, usually all in the same thread.  Locking is hence very crutial.

--*/

#include "EncDecAll.h"

//#include "DTFilterutil.h"
#include "DTFilter.h"
#include "RegKey.h"             // getting and setting EncDec registry values

#include <comdef.h>             // _com_error

#ifdef EHOME_WMI_INSTRUMENTATION
#include <dxmperf.h>
#endif

#include <obfus.h>

#ifdef DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//#define HACK_AROUND_NOMAXRATINGS

// --------------------------------------------------------

//  disable so we can use 'this' in the initializer list
#pragma warning (disable:4355)


void ODS(int Lvl, WCHAR *szFormat, long lValue1=-1, long lValue2=-1, long lValue3=-1)
{
#if 1
    static int DbgLvl = 3;          // higher the more verbose
    if(Lvl > DbgLvl) return;

    const int kChars = 256;
    int cMaxChars = kChars;
    WCHAR szBuff[kChars];
    szBuff[0] = 0;
    _snwprintf(szBuff,cMaxChars,L"0x%04X: ",GetCurrentThreadId());

    int cChars = wcslen(szBuff);
    TCHAR *pZ = szBuff + cChars;
    cMaxChars -= cChars;

    if(lValue1 == -1)
        wcsncpy(pZ, szFormat, cMaxChars);
    else if(lValue2 == -1)
        _snwprintf(pZ,cMaxChars,szFormat,lValue1);
    else if(lValue3 == -1)
        _snwprintf(pZ,cMaxChars,szFormat,lValue1,lValue2);
    else
        _snwprintf(pZ,cMaxChars,szFormat,lValue1,lValue2,lValue3);

    szBuff[kChars-1] = 0;       // terminate in case string's too large
    OutputDebugString(szBuff);
#endif
}

#ifdef DEBUG
TCHAR *
EventIDToString(IN const GUID &eventID)
{
                // sent by XDSCodec when get a new rating
    if(eventID == EVENTID_XDSCodecNewXDSRating)
        return _T("NewXDSRating");
    else if(eventID == EVENTID_XDSCodecNewXDSPacket)
        return _T("NewXDSPacket");
    else if(eventID == EVENTID_XDSCodecDuplicateXDSRating)
        return _T("DuplicateXDSRating");
    else if(eventID == EVENTID_DTFilterRatingChange)
        return _T("DTFilter RatingsChange");
    else if(eventID == EVENTID_DTFilterRatingsBlock)
        return _T("RatingsBlock");
    else if(eventID == EVENTID_DTFilterRatingsUnblock)
        return _T("RatingsUnblock");
    else if(eventID == EVENTID_DTFilterXDSPacket)
        return _T("DTFilter XDSPacket");
    else if(eventID == EVENTID_DTFilterDataFormatOK)
        return _T("DataFormatOK");
    else if(eventID == EVENTID_DTFilterDataFormatFailure)
        return _T("DataFormatFailure");
    else if(eventID == EVENTID_ETDTFilterLicenseOK)
        return _T("LicenseOK");
    else if(eventID == EVENTID_ETDTFilterLicenseFailure)
        return _T("LicenseFailure");
    else if(eventID == EVENTID_TuningChanged)
        return _T("Tuning Changed");
    else
    {
        static TCHAR tzBuff[128];   // nasty to return, but this is debug code...
        _stprintf(tzBuff,_T("Unknown Broadcast Event : %08x-%04x-%04x-..."),
            eventID.Data1, eventID.Data2, eventID.Data3);
        return tzBuff;
    }

}
#else
TCHAR *
EventIDToString(IN const GUID &eventID)
{
    return NULL;
}
#endif
//  ============================================================================

//  ============================================================================
AMOVIESETUP_FILTER
g_sudDTFilter = {
    & CLSID_DTFilter,
    _TEXT(DT_FILTER_NAME),
    MERIT_DO_NOT_USE,
    0,                          //  0 pins registered
    NULL
} ;

//  ============================================================================
CCritSec* CDTFilter::m_pCritSectGlobalFilt = NULL;
LONG      CDTFilter::m_gFilterID = 0;

void CALLBACK
CDTFilter::InitInstance (
    IN  BOOL bLoading,
    IN  const CLSID *rclsid
    )
{
    if( bLoading ) {
        m_pCritSectGlobalFilt = new CCritSec;
    } else {
        if( m_pCritSectGlobalFilt )
        {
           delete m_pCritSectGlobalFilt;         // DeleteCriticalSection(&m_CritSectGlobalFilt);
           m_pCritSectGlobalFilt = NULL;
        }
    }
}

CUnknown *
WINAPI
CDTFilter::CreateInstance (
    IN  IUnknown *  punkControlling,
    IN  HRESULT *   phr
    )
{
    if(m_pCritSectGlobalFilt == NULL ) // if didn't create
    {
        *phr = E_FAIL;
        return NULL;
    }

    CDTFilter *    pCDTFilter ;

    if (true /*::CheckOS ()*/) {
        pCDTFilter = new CDTFilter (
                                TEXT(DT_FILTER_NAME),
                                punkControlling,
                                CLSID_DTFilter,
                                phr
                                ) ;
        if (!pCDTFilter ||
            FAILED (* phr)) {

            (* phr) = (FAILED (* phr) ? (* phr) : E_OUTOFMEMORY) ;
            delete pCDTFilter; pCDTFilter=NULL;
        }
    }
    else {
        //  wrong OS
        pCDTFilter = NULL ;
    }

    return pCDTFilter ;
}

//  ============================================================================

CDTFilterInput::CDTFilterInput (
    IN  TCHAR *         pszPinName,
    IN  CDTFilter *  pDTFilter,
    IN  CCritSec *      pFilterLock,        // must be a 'new' lock, do not pass in filter lock.
    OUT HRESULT *       phr
    ) : CBaseInputPin       (NAME ("CDTFilterInput"),
                             pDTFilter,
                             pFilterLock,
                             phr,
                             pszPinName
                             ),
    m_pHostDTFilter         (pDTFilter)
{
    TRACE_CONSTRUCTOR (TEXT ("CDTFilterInput")) ;

    if(NULL == m_pLock)     // check if failed in constructor call
    {
        *phr = E_OUTOFMEMORY;
    }

}

CDTFilterInput::~CDTFilterInput ()
{

}


STDMETHODIMP
CDTFilterInput::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
                // KSProp set interfaces used for
                //   pasing Rate data around the filter

    if (riid == IID_IKsPropertySet) {
                // see if connected before doing this?
        if(S_OK != m_pHostDTFilter->IsInterfaceOnPinConnectedTo_Supported(PINDIR_OUTPUT, IID_IKsPropertySet))
            return E_NOINTERFACE;       // could be just not connected... try again later

                // do it ourselves (we need to hook calls on this interface, so don't just pass it)
        return GetInterface (
                    (IKsPropertySet *) this,
                    ppv
                    ) ;
    }

    return CBaseInputPin::NonDelegatingQueryInterface (riid, ppv) ;
}

HRESULT
CDTFilterInput::StreamingLock ()              // this is the streaming lock...
{
    m_StreamingLock.Lock();
    return S_OK;
}
HRESULT
CDTFilterInput::StreamingUnlock ()
{
    m_StreamingLock.Unlock();
    return S_OK;
}

HRESULT
CDTFilterInput::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    BOOL    f ;
    ASSERT(m_pHostDTFilter);

    f = m_pHostDTFilter -> CheckDecrypterMediaType (m_dir, pmt) ;

    return (f ? S_OK : S_FALSE) ;
}

HRESULT
CDTFilterInput::CompleteConnect (
    IN  IPin *  pIPin
    )
{
    HRESULT hr ;

    hr = CBaseInputPin::CompleteConnect (pIPin) ;

    if (SUCCEEDED (hr)) {
        hr = m_pHostDTFilter -> OnCompleteConnect (m_dir) ;
    }

    return hr ;
}

HRESULT
CDTFilterInput::BreakConnect (
    )
{
    HRESULT hr ;

    hr = CBaseInputPin::BreakConnect () ;

    if (SUCCEEDED (hr)) {
        hr = m_pHostDTFilter -> OnBreakConnect (m_dir) ;
    }

    return hr ;
}

STDMETHODIMP
CDTFilterInput::Receive (
    IN  IMediaSample * pIMediaSample
    )
{
    HRESULT hr ;


    {
        CAutoLock  cLock(&m_StreamingLock);           // Grab the streaming lock

        // Before using resources, make sure it is safe to proceed. Do not
        // continue if the base-class method returns anything besides S_OK.
#ifdef EHOME_WMI_INSTRUMENTATION
        PERFLOG_STREAMTRACE( 1, PERFINFO_STREAMTRACE_ENCDEC_DTFILTERINPUT,
            0, 0, 0, 0, 0 );
#endif
        hr = CBaseInputPin::Receive (pIMediaSample) ;

        if (S_OK == hr)             // Receive returns S_FALSE if flushing..
        {
            hr = m_pHostDTFilter -> Process (pIMediaSample) ;
        }
   }

    return hr ;
}

HRESULT
CDTFilterInput::SetAllocatorProperties (
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    HRESULT hr ;

    if (IsConnected ()) {
        ASSERT (m_pAllocator) ;
        hr = m_pAllocator -> GetProperties (ppropInputRequest) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDTFilterInput::GetRefdConnectionAllocator (
    OUT IMemAllocator **    ppAlloc
    )
{
    HRESULT hr ;


    if (m_pAllocator) {
        (* ppAlloc) = m_pAllocator ;
        (* ppAlloc) -> AddRef () ;

        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}


STDMETHODIMP
CDTFilterInput::BeginFlush (
    )
{
    HRESULT hr = S_OK;

    CAutoLock  cLock(m_pLock);                  // grab the filter lock..

    // First, make sure the Receive method will fail from now on.
    hr = CBaseInputPin::BeginFlush () ;
    if( FAILED( hr ) )
    {
        return hr;
    }

    // Force downstream filters to release samples. If our Receive method
    // is blocked in GetBuffer or Deliver, this will unblock it.
    hr = m_pHostDTFilter->DeliverBeginFlush () ;
    if( FAILED( hr ) ) {
        return hr;
    }

    // At this point, the Receive method can't be blocked. Make sure
    // it finishes, by taking the streaming lock. (Not necessary if this
    // is the last step.)
    //  Note - this sometimes deadlocks in NVVIDDEC.... Lets try grabbing the lock later it later.
/*    {
        CAutoLock  cLock2(&m_StreamingLock);

        // Code to clean drop queue.
        hr = m_pHostDTFilter->FlushDropQueue();
    }
*/

    return S_OK;
}

STDMETHODIMP
CDTFilterInput::EndFlush (
    )
{
    HRESULT hr ;

    CAutoLock  cLock(m_pLock);

        // The EndFlush method will signal to the filter that it can
        // start receiving samples again.


    hr = m_pHostDTFilter->DeliverEndFlush () ;      // if dropping, may signal a stop?
    // ASSERT(!FAILED(hr));  // could be


        // possible NVVIDDEC deadlock bug fix... Move this Flush call here, rather than in the
        // beginFlush method

    {
        CAutoLock  cLock2(&m_StreamingLock);

        // Code to clean drop queue.
        hr = m_pHostDTFilter->FlushDropQueue();
    }
       // The CBaseInputPin::EndFlush method resets the m_bFlushing flag to FALSE,
        // which allows the Receive method to start receiving samples again.
        // This should be the last step in EndFlush, because the pin must not receive any
        // samples until flushing is complete and all downstream filters are notified.

    hr = CBaseInputPin::EndFlush () ;

    return hr ;
}


STDMETHODIMP
CDTFilterInput::EndOfStream (
    )
{
    // When the input pin receives an end-of-stream notification, it propagates the call
    // downstream. Any downstream filters that receive data from this input pin should
    // also get the end-of-stream notification. Again, take the streaming lock and not
    // the filter lock. If the filter has pending data that was not yet delivered, the
    // filter should deliver it now, before it sends the end-of-stream notification.
    // It should not send any data after the end of the stream.

    CAutoLock  cLock(&m_StreamingLock);

    HRESULT hr = CheckStreaming();
    if( S_OK != hr ) {
        return hr;
    }

    hr = m_pHostDTFilter->DeliverEndOfStream();
    if( S_OK != hr ) {
        return hr;
    }

    return S_OK;
}


        //  --------------------------------------------------------------------
        //  IKSPropertySet methods  (Forward all calls to the output pin)

STDMETHODIMP
CDTFilterInput::Set(
        IN REFGUID guidPropSet,
        IN DWORD dwPropID,
        IN LPVOID pInstanceData,
        IN DWORD cbInstanceData,
        IN LPVOID pPropData,
        IN DWORD cbPropData
        )
{
    if(NULL == m_pHostDTFilter)
        return E_FAIL;
    return m_pHostDTFilter->KSPropSetFwd_Set(PINDIR_OUTPUT, guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
}

STDMETHODIMP
CDTFilterInput::Get(
        IN  REFGUID guidPropSet,
        IN  DWORD dwPropID,
        IN  LPVOID pInstanceData,
        IN  DWORD cbInstanceData,
        OUT LPVOID pPropData,
        IN  DWORD cbPropData,
        OUT DWORD *pcbReturned
        )
{
    if(NULL == m_pHostDTFilter)
        return E_FAIL;
    return m_pHostDTFilter->KSPropSetFwd_Get(PINDIR_OUTPUT, guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);

}

STDMETHODIMP
CDTFilterInput::QuerySupported(
       IN  REFGUID guidPropSet,
       IN  DWORD dwPropID,
       OUT DWORD *pTypeSupport
       )
{
    if(NULL == m_pHostDTFilter)
        return E_FAIL;
     return m_pHostDTFilter->KSPropSetFwd_QuerySupported(PINDIR_OUTPUT, guidPropSet, dwPropID, pTypeSupport);
}

//  ============================================================================

CDTFilterOutput::CDTFilterOutput (
    IN  TCHAR *         pszPinName,
    IN  CDTFilter *  pDTFilter,
    IN  CCritSec *      pFilterLock,
    OUT HRESULT *       phr
    ) : CBaseOutputPin      (NAME ("CDTFilterOutput"),
                             pDTFilter,
                             pFilterLock,       // a new lock
                             phr,
                             pszPinName
                             ),
    m_pHostDTFilter   (pDTFilter)
{
    TRACE_CONSTRUCTOR (TEXT ("CDTFilterOutput")) ;
    if(NULL == m_pLock)
    {
        *phr = E_OUTOFMEMORY;
    }
}

CDTFilterOutput::~CDTFilterOutput ()
{

}


STDMETHODIMP
CDTFilterOutput::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  ------------------------------------------------------------------------
    //  IDTFilterConfig; allows the filter to be configured...

    if (riid == IID_IDTFilterConfig) {

        return GetInterface (
                    (IDTFilterConfig *) this,
                    ppv
                    ) ;
    }

    return CBaseOutputPin::NonDelegatingQueryInterface (riid, ppv) ;
}

    // -----------------------------------------

HRESULT
CDTFilterOutput::GetMediaType (
    IN  int             iPosition,
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    if (iPosition > 0) {                // only support the one type
        return VFW_S_NO_MORE_ITEMS;
    }

    hr = m_pHostDTFilter -> OnOutputGetMediaType (pmt) ;

    return hr ;
}

HRESULT
CDTFilterOutput::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    BOOL    f ;

    ASSERT(m_pHostDTFilter);

    f = m_pHostDTFilter -> CheckDecrypterMediaType (m_dir, pmt) ;

    return (f ? S_OK : S_FALSE) ;
}

HRESULT
CDTFilterOutput::CompleteConnect (
    IN  IPin *  pIPin
    )
{
    HRESULT hr ;

    hr = CBaseOutputPin::CompleteConnect (pIPin) ;

    if (SUCCEEDED (hr)) {
        hr = m_pHostDTFilter -> OnCompleteConnect (m_dir) ;
    }

    return hr ;
}

HRESULT
CDTFilterOutput::BreakConnect (
    )
{
    HRESULT hr ;

    hr = CBaseOutputPin::BreakConnect () ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostDTFilter -> OnBreakConnect (m_dir) ;
    }

    return hr ;
}



HRESULT
CDTFilterOutput::  SendSample  (
    OUT  IMediaSample *  pIMS
    )
{
    HRESULT hr ;

    ASSERT (pIMS) ;

#ifdef EHOME_WMI_INSTRUMENTATION
    PERFLOG_STREAMTRACE( 1, PERFINFO_STREAMTRACE_ENCDEC_DTFILTEROUTPUT,
        0, 0, 0, 0, 0 );
#endif
    hr = Deliver (pIMS) ;

    return hr ;
}

// ---------------------------------------------------------------
// Allocator stuff

HRESULT
CDTFilterOutput::DecideBufferSize (
    IN  IMemAllocator *         pAlloc,
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    HRESULT hr ;

    hr = m_pHostDTFilter -> UpdateAllocatorProperties (
            ppropInputRequest
            ) ;

    return hr ;
}

HRESULT
CDTFilterOutput::DecideAllocator (
    IN  IMemInputPin *      pPin,
    IN  IMemAllocator **    ppAlloc
    )
{
    HRESULT hr ;

    hr = m_pHostDTFilter -> GetRefdInputAllocator (ppAlloc) ;
    if (SUCCEEDED (hr)) {
        //  input pin must be connected i.e. have an allocator; preserve
        //   all properties and pass them through to the output
        hr = pPin -> NotifyAllocator ((* ppAlloc), FALSE) ;
    }

    return hr ;
}

// ---------------------------------------------------------------------
// KSPropertySet forwarding stuff

HRESULT
CDTFilterOutput::IsInterfaceOnPinConnectedTo_Supported(
                                      IN  REFIID          riid
                                      )
{
    if(NULL == m_pInputPin)
        return E_NOINTERFACE;       // not connected yet

    CComPtr<IUnknown> spPunk;
    return m_pInputPin->QueryInterface(riid,(void **) &spPunk);
}

HRESULT
CDTFilterOutput::KSPropSetFwd_Set(
                 IN  REFGUID         guidPropSet,
                 IN  DWORD           dwPropID,
                 IN  LPVOID          pInstanceData,
                 IN  DWORD           cbInstanceData,
                 IN  LPVOID          pPropData,
                 IN  DWORD           cbPropData
                 )
{
    if(NULL == m_pInputPin)
        return E_NOINTERFACE;       // not connected yet

    CComQIPtr<IKsPropertySet> spKS(m_pInputPin);
    if(spKS == NULL)
        return E_NOINTERFACE;

    return spKS->Set(guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData );
}

HRESULT
CDTFilterOutput::KSPropSetFwd_Get(
                 IN  REFGUID         guidPropSet,
                 IN  DWORD           dwPropID,
                 IN  LPVOID          pInstanceData,
                 IN  DWORD           cbInstanceData,
                 OUT LPVOID          pPropData,
                 IN  DWORD           cbPropData,
                 OUT DWORD           *pcbReturned
                 )
{
    if(NULL == m_pInputPin)
        return E_NOINTERFACE;       // not connected yet

    CComQIPtr<IKsPropertySet> spKS(m_pInputPin);
    if(spKS == NULL)
        return E_NOINTERFACE;

    return spKS->Get(guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned );

}

HRESULT
CDTFilterOutput::KSPropSetFwd_QuerySupported(
                            IN  REFGUID          guidPropSet,
                            IN  DWORD            dwPropID,
                            OUT DWORD            *pTypeSupport
                            )
{
    if(NULL == m_pInputPin)
        return E_NOINTERFACE;       // not connected yet

    CComQIPtr<IKsPropertySet> spKS(m_pInputPin);
    if(spKS == NULL)
        return E_NOINTERFACE;

    return spKS->QuerySupported(guidPropSet, dwPropID, pTypeSupport);
}


// needed to avoid an Asert in the debug version of Quartz
STDMETHODIMP
CDTFilterOutput::Notify(IBaseFilter *pSender, Quality q)
{
    return S_OK;        // don't do anything
}

//  ============================================================================

CDTFilter::CDTFilter (
    IN  TCHAR *     pszFilterName,
    IN  IUnknown *  punkControlling,
    IN  REFCLSID    rCLSID,
    OUT HRESULT *   phr
    ) : CBaseFilter             (pszFilterName,
                                 punkControlling,
                                 new CCritSec,
                                 rCLSID
                                ),
        m_pInputPin                 (NULL),
        m_pOutputPin                (NULL),
        m_dwBroadcastEventsCookie   (kBadCookie),
        m_fRatingsValid             (false),
        m_fFireEvents               (true),
        m_EnSystemCurr              (TvRat_SystemDontKnow),     // better inits?
        m_EnLevelCurr               (TvRat_LevelDontKnow),
        m_lbfEnAttrCurr             (BfAttrNone),
        m_hrEvalRatCoCreateRetValue (CLASS_E_CLASSNOTAVAILABLE),
        m_3fDRMLicenseFailure       (-2),           // 3 state logic, init to non-true and non-false.  False is less verbose on startup
#if BUILD_WITH_DRM
        m_pszKID                    (NULL),
        m_cbKID                     (NULL),
#endif
        m_fDataFormatHasBeenBad     (false),        // set true if get bad data (for ok/fail event toggle)
        m_fForceNoRatBlocks         (false),
        m_milsecsDelayBeforeBlock   (0),            //  delay between detection of unrated and blocking as unrated (0 is 'safest', 2000 allows surfing)
        m_milsecsNoRatingsBeforeUnrated (4000),      //  delay between last fresh rating and setting as unrated - total time has above added to it
        m_fDoingDelayBeforeBlock    (false),
        m_fRunningInSlowMo          (false),
        m_refTimeToStartBlock       (0),
        m_cDropQueueMin             (0),
        m_cDropQueueMax             (0),
        m_dwDropQueueEventCookie    (0),
        m_dwDropQueueThreadId       (0),
        m_hDropQueueThread          (0),
        m_hDropQueueThreadAliveEvent(0),
        m_hDropQueueThreadDieEvent  (0),
        m_hDropQueueEmptySemaphore  (0),
        m_hDropQueueFullSemaphore   (0),
        m_hDropQueueAdviseTimeEvent (0),
        m_fHaltedDelivery           (false),
        m_cRestarts                 (0),
        m_fCompleteNotified         (false),
        m_refTimeLastEvent          (0),
        m_lastEventID               (GUID_NULL),
        m_PTSRate                   (kSecsPurgeThreshold*kSecsToUnits, kMaxRateSegments)

{
    HRESULT hr = S_OK;

    TRACE_CONSTRUCTOR (TEXT ("CDTFilter")) ;

    TimeitC ti(&m_tiStartup);

    if (!m_pLock) {
        (* phr) = E_OUTOFMEMORY ;
        goto cleanup ;
    }

    m_FilterID = m_gFilterID;        // does this need to be protected with below? Probably not...
    InterlockedIncrement(&m_gFilterID);

    memset(m_rgMedSampDropQueue, 0, sizeof(m_rgMedSampDropQueue));
    InitStats();

    m_pInputPin = new CDTFilterInput (
                        TEXT (DT_INPIN_NAME),
                        this,
                         m_pLock,                           //  // use the filter's lock on the input pin
                        phr
                        ) ;
    if (!m_pInputPin ||
        FAILED (* phr)) {

        (* phr) = (m_pInputPin ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    m_pOutputPin = new CDTFilterOutput (
                        TEXT (DT_OUTPIN_NAME),
                        this,
                        m_pLock, // new CCritSec,          // use the filter's lock on the output pin
                        phr
                        ) ;
    if (!m_pOutputPin ||
        FAILED (* phr)) {

        (* phr) = (m_pOutputPin ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

            // CoCreate the ratings evaluator...
    try {
        m_hrEvalRatCoCreateRetValue =
            CoCreateInstance(CLSID_EvalRat,         // CLSID
                             NULL,                  // pUnkOut
                             CLSCTX_INPROC_SERVER,
                             IID_IEvalRat,          // riid
                             (LPVOID *) &m_spEvalRat);

    } catch (HRESULT hr) {
        m_hrEvalRatCoCreateRetValue = hr;
    }

    if(FAILED(m_hrEvalRatCoCreateRetValue))
        TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::*** WARNING - failed to create EvalRat object"), m_FilterID) ;
    else
        TRACE_1(LOG_AREA_DECRYPTER, 3, _T("CDTFilter(%d)::*** Successfully created EvalRat object"), m_FilterID) ;


//  hr = RegisterForBroadcastEvents();  // don't really care if fail here,  try in Connect if haven't

            // setup Authenticator (DRM secure channel object)
    if(SUCCEEDED(*phr))
        *phr = InitializeAsSecureClient();


    //  success
    ASSERT (SUCCEEDED (* phr)) ;
    ASSERT (m_pInputPin) ;
    ASSERT (m_pOutputPin) ;

/*
#ifdef HACK_AROUND_NOMAXRATINGS // used when don't have ratings....
    if(m_spEvalRat)
    {
         //ASSERT(false);      // place to hang a breakpoint...
       //  put_BlockUnRated(true);
       //  put_BlockUnRatedDelay(1000);

//        ASSERT(false);      // just so we have a break point...

        // US_TV_IsBlocked
        // US_TV_IsViolent | US_TV_IsSexualSituation | US_TV_IsAdultLanguage | US_TV_IsSexuallySuggestiveDialog

 //       put_BlockedRatingAttributes(US_TV.  US_TV_None, US_TV_IsBlocked);
 //       put_BlockedRatingAttributes(US_TV.  US_TV_Y,    US_TV_IsBlocked);
  //      put_BlockedRatingAttributes(US_TV.  US_TV_Y7,   US_TV_IsBlocked);
  //      put_BlockedRatingAttributes(US_TV.  US_TV_G,    US_TV_IsBlocked);
  //      put_BlockedRatingAttributes(US_TV.  US_TV_PG,   US_TV_IsBlocked);
  //      put_BlockedRatingAttributes(US_TV.  US_TV_14,   US_TV_IsBlocked);
  //      put_BlockedRatingAttributes(US_TV.  US_TV_MA,   US_TV_IsBlocked);
  //      put_BlockedRatingAttributes(US_TV.  US_TV_Y,    US_TV_IsBlocked);
    }
#endif
*/

cleanup :

    return ;
}

CDTFilter::~CDTFilter (
    )
{
#if BUILD_WITH_DRM
    if(m_pszKID) CoTaskMemFree(m_pszKID);  m_pszKID = NULL;
#endif

    InterlockedDecrement(&m_gFilterID);

    delete m_pInputPin ;    m_pInputPin = NULL;
    delete m_pOutputPin ;   m_pOutputPin = NULL;
    delete m_pLock;         m_pLock = NULL;
}

STDMETHODIMP
CDTFilter::NonDelegatingQueryInterface (
                                        IN  REFIID  riid,
                                        OUT void ** ppv
                                        )
{

    // IDTFilter :allows the filter to be configured...
    if (riid == IID_IDTFilter) {

        return GetInterface (
            (IDTFilter *) this,
            ppv
            ) ;

        // IDTFilterConfig :allows the filter to be configured...
    } else if (riid == IID_IDTFilterConfig) {   
        return GetInterface (
            (IDTFilterConfig *) this,
            ppv
            ) ;

        // ISpecifyPropertyPages: allows an app to enumerate property pages
    } else if (riid == IID_ISpecifyPropertyPages) {

        return GetInterface (
            (ISpecifyPropertyPages *) this,
            ppv
            ) ;

        // IBroadcastEvents: allows the filter to receive events broadcast
        //                   from XDS and Tuner filters
    } else if (riid == IID_IBroadcastEvent) {

        return GetInterface (
            (IBroadcastEvent *) this,
            ppv
            ) ;

    }

    return CBaseFilter::NonDelegatingQueryInterface (riid, ppv) ;
}

int
CDTFilter::GetPinCount ( )
{
    int i ;

    //  don't show the output pin if the input pin is not connected
    i = (m_pInputPin -> IsConnected () ? 2 : 1) ;

    //i = 2;        // show it


    return i ;
}

CBasePin *
CDTFilter::GetPin (
    IN  int iIndex
    )
{
    CBasePin *  pPin ;

    if (iIndex == 0) {
        pPin = m_pInputPin ;
    }
    else if (iIndex == 1) { // don't show if not connected
        pPin = (m_pInputPin -> IsConnected () ? m_pOutputPin : NULL) ;
 //       pPin = m_pOutputPin;
    }
    else {
        pPin = NULL ;
    }

    return pPin ;
}

        // --------------------------------------------

BOOL
CDTFilter::CompareConnectionMediaType_ (
    IN  const AM_MEDIA_TYPE *   pmt,
    IN  CBasePin *              pPin
    )
{
    BOOL        f ;
    HRESULT     hr ;
    CMediaType  cmtConnection ;

    ASSERT (pPin -> IsConnected ()) ;

        // This method called from the output pin, suggesting possible input formats
        //  We only want to use one, (the orginal media type).

        // input pin's media type
    hr = pPin -> ConnectionMediaType (&cmtConnection) ;
    if (SUCCEEDED (hr)) {
        CMediaType  cmtOriginal;
        hr = ProposeNewOutputMediaType(&cmtConnection,  &cmtOriginal);      // strip format envelope off
        if(S_OK != hr)
            return false;

        CMediaType  cmtCompare = (* pmt); ;
        f = (cmtOriginal == cmtCompare ? TRUE : FALSE) ;
    } else {
        f = false;
    }

     return f ;
}

BOOL
CDTFilter::CheckInputMediaType_ (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    BOOL    f = true;
    HRESULT hr = S_OK;

    if (m_pOutputPin -> IsConnected ()) {
        ASSERT(false);      // don't allow this case
//        f = CompareConnectionMediaType_ (pmt, m_pOutputPin) ;
    }
    else {
    }

            
#ifndef DONT_CHANGE_EDTFILTER_MEDIATYPE
            // only allow input data coming from the ETFilter somewhere up the path
    f =  IsEqualGUID( pmt->subtype,    MEDIASUBTYPE_ETDTFilter_Tagged);
#else
            // only anything...
    f = true;
#endif

    return f ;
}

BOOL
CDTFilter::CheckOutputMediaType_ (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    BOOL    f = true ;
    HRESULT hr ;

    if (m_pInputPin -> IsConnected ()) {
        f = CompareConnectionMediaType_ (pmt, m_pInputPin) ;
    }
    else {
        f = FALSE ;
    }

    return f ;
}


BOOL
CDTFilter::CheckDecrypterMediaType (
    IN  PIN_DIRECTION       PinDir,
    IN  const CMediaType *  pmt
    )
{
    BOOL    f ;

    //  both pins must have identical media types, so we check with the pin that
    //   is not calling; if it's connected, we measure against the connection's
    //   media type

    if (PinDir == PINDIR_INPUT) {
        f = CheckInputMediaType_ (pmt) ;
    }
    else {
        ASSERT (PinDir == PINDIR_OUTPUT) ;
        f = CheckOutputMediaType_ (pmt) ;
    }

    return f ;
}

HRESULT
CDTFilter::ProposeNewOutputMediaType (
    IN  CMediaType *  pmt,
    OUT CMediaType *  pmtOut
    )
{
    HRESULT hr = S_OK;
    if(NULL == pmtOut)
        return E_POINTER;

    CMediaType mtOut(*pmt);     // does a deep copy
    if(NULL == pmtOut)
        return E_OUTOFMEMORY;

#ifndef DONT_CHANGE_EDTFILTER_MEDIATYPE     // pull when Matthijs gets MediaSDK changes done
    
            // discover all sorts of interesing info about the current type
    const GUID *pGuidSubtypeCurr    = pmt->Subtype();
    const GUID *pGuidFormatCurr     = pmt->FormatType();
    int  cbFormatCurr               = pmt->FormatLength();

                // if not our tagged format, just return
    if(!IsEqualGUID( *pGuidSubtypeCurr, MEDIASUBTYPE_ETDTFilter_Tagged) ||
       !IsEqualGUID( *pGuidFormatCurr,  FORMATTYPE_ETDTFilter_Tagged))
       return S_OK;

    BYTE *pb = pmt->Format();
            // This format block contains:
            //    1) original format block  2) the original subtype 3) original format type

    BYTE *pFormatOrig        = pb;           pb += (cbFormatCurr - 2*sizeof(GUID)) ;    
    GUID *pGuidSubtypeOrig   = (GUID *) pb;  pb += sizeof(GUID);
    GUID *pGuidFormatOrig    = (GUID *) pb;  pb += sizeof(GUID);

            // create a new format block, containing just the original format block
    int cbFormatOrig = cbFormatCurr - 2*sizeof(GUID);

            // now override the data, setting back the original subtype, format type,  and format block
    mtOut.SetSubtype(   pGuidSubtypeOrig );
    mtOut.SetFormatType(pGuidFormatOrig);

    if(cbFormatOrig > 0)
    {
        BYTE *pbNew = new BYTE[cbFormatOrig];       // new slighty inefficent, worried about
        if(NULL == pbNew)
            return E_OUTOFMEMORY;
        memcpy(pbNew, pFormatOrig, cbFormatOrig);   // overlapping memory regions here
        mtOut.SetFormat(pbNew, cbFormatOrig);
        delete [] pbNew;
    }
    else            // oops, nothing left to format block.  Hence womp one we have
    {
        mtOut.ResetFormatBuffer();
    }

    TRACE_1(LOG_AREA_DECRYPTER, 5, _T("CDTFilter(%d)::ProposeNewOutputMediaType"), m_FilterID) ;

#endif
    *pmtOut = mtOut;        // hope this does a deep copy too..
    return hr;
}
// --------------------------------------------------

                // temporaray TimeBomb...
#ifdef INSERT_TIMEBOMB
static HRESULT TimeBomb()
{
     SYSTEMTIME sysTimeNow, sysTimeBomb;
     GetLocalTime(&sysTimeNow);


     sysTimeBomb.wYear  = 2002;
     sysTimeBomb.wMonth = TIMEBOMBMONTH;
     sysTimeBomb.wDay   = TIMEBOMBDATE;
     sysTimeBomb.wHour  = 12;

     TRACE_3(LOG_AREA_DECRYPTER, 3,L"CDTFilter:: TimeBomb set to Noon on %d/%d/%d",TIMEBOMBMONTH,TIMEBOMBDATE,sysTimeBomb.wYear );

     long hNow  = ((sysTimeNow.wYear*12 + sysTimeNow.wMonth)*31 + sysTimeNow.wDay)*24 + sysTimeNow.wHour;
     long hBomb = ((sysTimeBomb.wYear*12 + sysTimeBomb.wMonth)*31 + sysTimeBomb.wDay)*24 + sysTimeBomb.wHour;
     if(hNow > hBomb)
     {
         TRACE_0(LOG_AREA_DECRYPTER, 1,L"CDTFilter:: Your Decryptor Filter is out of date - Time to get a new one");
         MessageBox(NULL,L"Your Decryptor/Tagger Filter is out of date\nTime to get a new one", L"Stale Decrypter Filter", MB_OK);
         return E_INVALIDARG;
     }
     else
         return S_OK;
}
#endif
// ---------------------------------------------
STDMETHODIMP
CDTFilter::JoinFilterGraph (
                            IFilterGraph *pGraph,
                            LPCWSTR pName
                            )
{

    O_TRACE_ENTER_0 (TEXT("CDTFilter::JoinFilterGraph ()")) ;
    HRESULT hr = S_OK;

    if(NULL != pGraph)     // not disconnecting
    {

#ifdef INSERT_TIMEBOMB
        hr = TimeBomb();
        if(FAILED(hr))
            return hr;
#endif

        BOOL fRequireDRM = true;


#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_RATINGS
        {
            DWORD dwRatFlags;
            HRESULT hrReg = (HRESULT) -1;   // an invalid HR, we set it down below
            if(hr == S_OK)
            {
                TRACE_1(LOG_AREA_DRM, 2, _T("CDTFilter(%d)::JoinFilterGraph - Security Warning - Registry Key allows Ratings to be ignored"),
                    m_FilterID) ;
                hrReg = Get_EncDec_RegEntries(NULL, 0, NULL, NULL, &dwRatFlags);
            }

            if(hrReg == S_OK)
            {
                DWORD ratFlags = dwRatFlags & 0xf;
                if(ratFlags == DEF_DONT_DO_RATINGS_BLOCK)
                    m_fForceNoRatBlocks = true;
            }

            if(m_fForceNoRatBlocks)
            {
                TRACE_1(LOG_AREA_DRM, 2, _T("CDTFilter(%d)::JoinFilterGraph - Security Warning! Ratings being ignored"),
                    m_FilterID) ;
            }
        }
#endif

#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS      // need this to turn off CheckServer DRM call, so we can debug around the call
        DWORD dwCSFlags;
        HRESULT hrReg = (HRESULT) -1;   // an invalid HR, we set it down below
        if(hr == S_OK)
        {
            TRACE_1(LOG_AREA_DRM, 2, _T("CDTFilter(%d)::JoinFilterGraph - Security Warning - Registry Key allows DRM Encryption or Authentication to be turned off"),
                m_FilterID) ;
            hrReg = Get_EncDec_RegEntries(NULL, 0, NULL, &dwCSFlags, NULL);
        }

        if(hrReg == S_OK)
        {
            DWORD encMethod = dwCSFlags & 0xf;
            if(encMethod != DEF_CS_DEBUG_DRM_ENC_VAL)
                fRequireDRM = false;
         }

        if(!fRequireDRM)
        {
            TRACE_1(LOG_AREA_DRM, 2, _T("CDTFilter(%d)::JoinFilterGraph - Security Warning! Not Checking for Secure Server"),
                m_FilterID) ;
        }
        else                                // note, starts scope below
#endif // SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS
        {
                // let DTFilter try to register that it's trusted (DEBUG ONLY!)
#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
            hr = RegisterSecureServer(pGraph);      // test
#else
            TRACE_1(LOG_AREA_DRM, 3, _T("CDTFilter(%d)::JoinFilterGraph is Secure - Filters not allowed to create their own trust"),m_FilterID) ;
#endif


#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS      // check if reg-key to turn off checking the server.
            if(0 == (DEF_CS_DO_AUTHENTICATE_SERVER & dwCSFlags))
            {
                hr = S_OK;
                TRACE_1(LOG_AREA_DRM, 2, _T("CDTFilter(%d)::JoinFilterGraph - Security Warning! Filters not Authenticating Server"),
                    m_FilterID) ;

            }
            else
#endif
                hr = CheckIfSecureServer(pGraph);
            if(S_OK != hr)
                return hr;
        }
// test code
#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
        {
                    // test code to get the IDTFilterConfig interface the hard way
            CComPtr<IUnknown> spUnkDTFilter;
            this->QueryInterface(IID_IUnknown, (void**)&spUnkDTFilter);

                    // how the vid control would call this

                    // QI for the DTFilterConfig interface
            CComQIPtr<IDTFilterConfig> spDTFiltC(spUnkDTFilter);

            if(spDTFiltC != NULL)
            {       // get the SecureChannel object
                CComPtr<IUnknown> spUnkSecChan;
                hr = spDTFiltC->GetSecureChannelObject(&spUnkSecChan);   // gets DRM authenticator object from the filter
                if(!FAILED(hr))
                {   // call own method to pass keys and certs
                    hr = CheckIfSecureClient(spUnkSecChan);
                }
                if(FAILED(hr))
                {
                    // bad things happened - filter isn't authenticated
                }
            }
        }
#endif
// end test code

    }

    hr = CBaseFilter::JoinFilterGraph(pGraph, pName) ;
    return hr;
}




STDMETHODIMP
CDTFilter::Pause (
    )
{
    HRESULT                 hr ;
    ALLOCATOR_PROPERTIES    AllocProp ;

    O_TRACE_ENTER_0 (TEXT("CDTFilter::Pause ()")) ;

    CAutoLock  cLock(m_pLock);

    int start_state = m_State;


    if (start_state == State_Stopped) {     // only called when startup for the first time
        TRACE_1(LOG_AREA_DECRYPTER, 2,L"CDTFilter(%d):: Stop -> Pause", m_FilterID);
        InitStats();

        m_tiRun.Clear();
        m_tiTeardown.Clear();
        m_tiProcess.Clear();
        m_tiProcessIn.Clear();
        m_tiProcessDRM.Clear();
        m_tiStartup.Clear();
        m_tiAuthenticate.Clear();

        m_tiRun.Start();

                                        // MGates does this call in pin:Active(), supposedly called by this base method
        m_PTSRate.Clear();              // womp any existing rate segment data


        m_fCompleteNotified = false;    // indicate we haven't sent an event when we hit end of stream

                    // set flag to only fire events if:  1 DTFilter, or it's video encrypter filter
        if(m_gFilterID <= 1 || m_gFilterID > 3)     // greater than 3 test in case count gets messed up..
        {
            ASSERT(m_gFilterID <= 1);               //  it's still an error...
            m_fFireEvents = true;
        }
        else        // else only fire events if it's the Video data.
        {

           ASSERT (m_pOutputPin->IsConnected ()) ;
           CMediaType  mtOut;
           hr = m_pInputPin->ConnectionMediaType (&mtOut) ;

           if(!IsEqualGUID( *mtOut.Type(), MEDIATYPE_Video))
           {
               m_fFireEvents = false;
           } else {
               m_fFireEvents = true;
           }
        }

        if(!m_fFireEvents)
        {
            TRACE_1(LOG_AREA_BROADCASTEVENTS, 2,L"CDTFilter(%d):: Is NOT firing ratings events", m_FilterID);
        } else {
            TRACE_1(LOG_AREA_BROADCASTEVENTS, 2,L"CDTFilter(%d):: IS Firing ratings events", m_FilterID);
        }

        hr = CBaseFilter::Pause () ;    // ready to run...

    } else {
        m_tiRun.Stop();
        TRACE_1(LOG_AREA_DECRYPTER, 2,L"CDTFilter(%d):: Run -> Pause", m_FilterID);

        hr = CBaseFilter::Pause () ;    // ready to stop - grabs the FilterLock...

        TRACE_4(LOG_AREA_TIME, 3, L"CDTFilter(%d):: Stats: %d packets, %gK Total Bytes (Avg  Bytes/Packet = %d)",
            m_FilterID, m_cPackets, double(m_clBytesTotal/1024.0), long(m_clBytesTotal / max(1, m_cPackets)));
        TRACE_3(LOG_AREA_TIME, 3, L"                             %d samples dropped, %d overflowed. %d times blocked",
            m_cSampsDropped, m_cSampsDroppedOverflowed, m_cBlockedWhileDroppingASample);


        if(m_tiRun.TotalTime() > 0.0)
        {
            TRACE_1(LOG_AREA_TIME, 3, L"               Total time:  Run          %8.4f (secs)",
                                    m_tiRun.TotalTime());
            TRACE_1(LOG_AREA_TIME, 3, L"               Total time:  Startup      %8.4f (secs)",
                                    m_tiStartup.TotalTime());
            TRACE_2(LOG_AREA_TIME, 3, L"               Total time:  Full Process %8.4f (secs) Percentage of Run %8.2f%%",
                                    m_tiProcess.TotalTime(),
                                    100.0 * m_tiProcess.TotalTime() / m_tiRun.TotalTime());
            TRACE_2(LOG_AREA_TIME, 3, L"               Total time:  In Process   %8.4f (secs) Percentage of Run %8.2f%%",
                                    m_tiProcessIn.TotalTime(),
                                    100.0 * m_tiProcessIn.TotalTime() / m_tiRun.TotalTime());
            TRACE_2(LOG_AREA_TIME, 3, L"               Total time:  DRM Process  %8.4f (secs) Percentage of Run %8.2f%%",
                                    m_tiProcessDRM.TotalTime(),
                                    100.0 * m_tiProcessDRM.TotalTime() / m_tiRun.TotalTime());
        }

    }
    m_fRatingsValid = false;            // reinit the ratings test
    m_fDataFormatHasBeenBad = false;    // reinit this too - assume starts as OK

    return hr ;
}

STDMETHODIMP
CDTFilter::Stop (
    )
{
    HRESULT hr = S_OK;

    O_TRACE_ENTER_0 (TEXT("CDTFilter::Stop ()")) ;

    TRACE_1(LOG_AREA_DECRYPTER, 2,L"CDTFilter(%d):: Stop", m_FilterID);

    hr = UnBindDRMLicenses();       // unbind any active licenses  (Bind called when first processing data)
    hr = FlushDropQueue();          // clean out the drop queue...(?)
    hr = S_OK ;

    hr = CBaseFilter::Stop () ;

    // Make sure the streaming thread has returned from IMemInputPin::Receive(), IPin::EndOfStream() and
    // IPin::NewSegment() before returning,
    m_pInputPin->StreamingLock();
    m_pInputPin->StreamingUnlock();

    return hr;
}


STDMETHODIMP
CDTFilter::Run (
    REFERENCE_TIME tStart
    )
{
    HRESULT                 hr ;
    O_TRACE_ENTER_0 (TEXT("CETFilter::Run ()")) ;
    TRACE_0(LOG_AREA_DECRYPTER, 1,L"CDTFilter:: Run");

    CAutoLock  cLock(m_pLock);

    CreateDropQueueThread();

    hr = CBaseFilter::Run (tStart) ;
    TRACE_0(LOG_AREA_DECRYPTER, 2,L"CDTFilter:: Run");

    return hr ;
}



//--------------------
//  Data formats (due to types of Attribute subblocks)
//  
//  Subblocks                       Description
//      none                non encrypted data, non-error, pass straight through
//      _EncryptMethod      pre beta, error to read
//      _PackedV1Data       beta, ok for beta, probably and error afterwards

HRESULT
CDTFilter::Process (
    IN  IMediaSample *  pIMediaSample
    )
{


    TimeitC ti(&m_tiProcess);       // simple use of destructor to stop our clock
    TimeitC tc(&m_tiProcessIn);       // simple use of destructor to stop our clock

    HRESULT                 hr       = S_OK;
    EnTvRat_System          enSystem = TvRat_SystemDontKnow;
    EnTvRat_GenericLevel    enLevel  = TvRat_LevelDontKnow;
    LONG                    lbfAttrs = BfAttrNone;              // BfEnTvRat_GenericAttributes
    LONG                    cCallSeqNumber = -1;
    LONG                    cPktSeqNumber  = -1;


    Encryption_Method       encryptionMethod = Encrypt_None;

            // use these to determine version... (should change to use magic number in Subblock header)
    HRESULT                 hrGetEncSubblock = S_FALSE;         // have pre-beta data if find this
    HRESULT                 hrGetPackedV1Data = S_FALSE;        // have beta-data if find this.

          // Side logic code...
                // two ways to handle not firing many events here
                //   first is to just check the CallSeqID and only do it on the first one.
                //   second is to do it when the cPacketSeqID changes from a static persisted value for these filters
                //   trouble with first is that if not reading the particular stream that has the first one, don't get it
                //   trouble with the second is that all DTFilters get it, meaning can't have scattered around in the graph
                //   First is easiest, second requires use of the global DTFilter lock.
                // For now, just do the first method, it's simpler.

    BOOL fFireEvents         = m_fFireEvents; // may be set to false to turn off events in this call
                                                // set in Stop->Pause transition...

    BOOL fRestartingDelivery = false;        // set to true on sample we unblock on, used to deliver a discontinuity

    BOOL fIsFreshRating      = false;        // set to true when get new or duplicate sent rating

    BOOL fDataFormatIsBad    = false;

    {

        // QI for an attribute block on the media sample
        CComQIPtr<IAttributeGet>   spAttrGet(pIMediaSample);

        EncDec_PackedV1Data *pEDPv1 = NULL;        // << NJB

        // If there is an attribute block, start to decode it
        do {
            if(spAttrGet == NULL)
                break;              // no attribute block

            LONG cAttrs;

            hr = spAttrGet->GetCount(&cAttrs);
            if(FAILED(hr))
                break;              // error getting count - bogus attribute block

            if(cAttrs == 0)         // no attributes to look at
                break;


            BYTE *pbData;
            DWORD cBytesBlock;
            // Does <OUR> attribute block exists - how big is it? (I hate this type interface - better to just return BSTR's..
            hr = spAttrGet->GetAttrib(ATTRID_ENCDEC_BLOCK, NULL, &cBytesBlock);
            if(FAILED(hr) || 0 == cBytesBlock)
            {
                hr = S_OK;          // this is ok, attributes just include the one we want..
                break;
            }

            // get the attribute block
            {
                CComBSTR spbsBlock(cBytesBlock);
                hr = spAttrGet->GetAttrib(ATTRID_ENCDEC_BLOCK, (BYTE *) spbsBlock.m_str, &cBytesBlock);
                if(FAILED(hr))
                {
                    ASSERT(false);      // got it once, but not again... This is bad
                   break;
                }

                m_attrSB.Reset();       // clear any existing attributes from this block  (e.g. don't allow history of attributes)


                // fill our saved block with data from the ENCDEC_BLOCK
                hr = m_attrSB.SetAsOneBlock(spbsBlock);     // if we remove clear above, we could have history of most recent attributes due to this

                spbsBlock.Empty();      // hey, CComBSTR's don't delete themselves... strange but true!

                if(FAILED(hr))          // were we able to convert it over into a list of subblocks?    
                {
                    if(E_INVALIDARG == hr)
                        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);          // SetAsOneBlock returns E_INVALIDARG if change magic number            
                    break;
                }
            }


            // any subblock attributes?
            LONG cSubBlocks = m_attrSB.GetCount();      // annoyingly different count interface from above
            if(0 == cSubBlocks)
                break;                                  // nothing to get (do I need with CBytes test above?)


                                        // lets get our encrypter and ratings attributes...
            LONG cBytes;
            LONG lVal;
            hrGetPackedV1Data = m_attrSB.Get(SubBlock_PackedV1Data,  &lVal, &cBytes, (BYTE **) &pEDPv1);

            if(S_OK == hrGetPackedV1Data && sizeof(EncDec_PackedV1Data) == cBytes)
            {
                        // whats the encryption method?
                encryptionMethod = (Encryption_Method) pEDPv1->m_EncryptionMethod;

                    // grab ratings data
                StoredTvRating *pSRating = &(pEDPv1->m_StoredTvRating);

                // Did we get a new rating?
                HRESULT hrUnpack = E_FAIL;
                {

                    hrUnpack = UnpackTvRating(pSRating->m_PackedRating, &enSystem, &enLevel, &lbfAttrs);
                    cCallSeqNumber = pSRating->m_cCallSeqID;
                    cPktSeqNumber  = pSRating->m_cPacketSeqID;
                    fIsFreshRating =  (0 != (pSRating->m_dwFlags & StoredTVRat_Fresh));

                    if(fIsFreshRating)
                    {
                        hr = m_pClock->GetTime(&m_refTimeFreshRating);
                        ASSERT(!FAILED(hr));
                    }
                    //
                    // fFireEvents = (cCallSeqNumber == 0);        // SIDE Logic --- See description at top of method
                }
            }

                        // look for Encryption Block from old data type...  (ToDo - remove this post-beta, change magic number next time instead)
            hrGetEncSubblock = m_attrSB.Get(SubBlock_EncryptMethod, (LONG *) &encryptionMethod);
            if(hrGetEncSubblock == S_OK)
            {                   // read a pre-beta file format...
                hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
            }

        } while (FALSE); // Get attributes on the media sample


        if(FAILED(hr))
        {
            fDataFormatIsBad = true;
            if(enSystem != TvRat_SystemDontKnow)
            {
                enSystem = TvRat_SystemDontKnow;
                enLevel  = TvRat_LevelDontKnow;
                lbfAttrs = BfAttrNone;
            }
        }

                        // if haven't had a rating in a long time,
                        //   and current rating isn't DontKnow, set it to DontKnow
        if(enSystem != TvRat_SystemDontKnow)
        {
            REFERENCE_TIME refTimeNow;
            hr = m_pClock->GetTime(&refTimeNow);
            if(!FAILED(hr))
            {
                REFERENCE_TIME refTimeDiff = refTimeNow - m_refTimeFreshRating;
                if(long(refTimeDiff / kMilliSecsToUnits) > m_milsecsNoRatingsBeforeUnrated)
                {
                    enSystem = TvRat_SystemDontKnow;
                    enLevel  = TvRat_LevelDontKnow;
                    lbfAttrs = BfAttrNone;
                }
            }
        }

                    // Set our rating (SetCurrRating returns S_FALSE if didn't change)
        HRESULT hrSetRat = SetCurrRating(enSystem, enLevel, lbfAttrs);

                    // if the rating changed, notify folk about it.
        if(S_OK == hrSetRat)
        {

#ifdef DEBUG
            if(fFireEvents)
            {
                const int kChars = 128;
                TCHAR szBuff[kChars];
                RatingToString(enSystem, enLevel, lbfAttrs, szBuff, kChars);

                TRACE_4(LOG_AREA_DECRYPTER, 1, L"CDTFilter(%d):: New Rating %s (%d/%d)",
                    m_FilterID, szBuff, cPktSeqNumber, cCallSeqNumber);
            }
#endif

            if(fFireEvents)
                FireBroadcastEvent(EVENTID_DTFilterRatingChange);

        }


                    // now test the rating.  Are we allowed to view it?
        HRESULT hrRatTest = S_OK;           //   If no EvalRat object exists, default to we are allowed to view it
        if(m_spEvalRat)
        {
            hrRatTest = m_spEvalRat->TestRating(enSystem, enLevel, lbfAttrs);   // returns S_FALSE if not allowed
        }

#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_RATINGS
        if(m_fForceNoRatBlocks)
            hrRatTest = S_OK;       // turn off blocking...
#endif

        if(TRUE != m_3fDRMLicenseFailure)      // 3 state logic (-2, false, and true)
        {
            if(fDataFormatIsBad)                // if bad data format, immediatly drop it..
            {
                if(!m_fDataFormatHasBeenBad)
                {
                    m_fDataFormatHasBeenBad = true;
                    if(true) //fFireEvents
                    {
                        TRACE_1 (LOG_AREA_DECRYPTER, 3,  _T("CDTFilter(%d):: ***Error*** Bad Data format"), m_FilterID);
                        FireBroadcastEvent(EVENTID_DTFilterDataFormatFailure);
                    }
                }
                m_fHaltedDelivery = true;       // make sure we don't send it on...
            }

            if(!fDataFormatIsBad && m_fDataFormatHasBeenBad)
            {
                m_fDataFormatHasBeenBad = false;

                if(true) //fFireEvents
                {
                    TRACE_1 (LOG_AREA_DECRYPTER, 3,  _T("CDTFilter(%d):: Data format OK"), m_FilterID);
                    FireBroadcastEvent(EVENTID_DTFilterDataFormatOK);
                }
            }
        }

        if(S_FALSE != hrRatTest)            // did we pass the test ... remove blockif had one
        {
            if(S_OK != hrRatTest)     // invalid rating... count it as not blocked (REVIEW with LCA?)
                TRACE_5 (LOG_AREA_DECRYPTER, 2,  _T("CDTFilter(%d)::*** Failed hrRatTest 0x%08x. Sys, Lvl, Att: %d %d %d"),
                        m_FilterID, hrRatTest, enSystem, enLevel, lbfAttrs);

            if(m_fHaltedDelivery && !m_fDataFormatHasBeenBad)
            {
                if(TRUE!=m_3fDRMLicenseFailure)
                {
                    if(fFireEvents)
                        TRACE_1 (LOG_AREA_DECRYPTER, 3,  _T("CDTFilter(%d):: Removing Block"), m_FilterID);

                    m_fHaltedDelivery       = FALSE;
                    fRestartingDelivery     = TRUE;

                    if(fFireEvents)
                        FireBroadcastEvent(EVENTID_DTFilterRatingsUnblock);
                }
                m_refTimeToStartBlock       = 0;        // reset these, may be set if previously unrated..
                m_fDoingDelayBeforeBlock    = FALSE;
            }
        }

                    // if not allowed to view it, and currently sending on data
        if(S_FALSE == hrRatTest && FALSE == m_fHaltedDelivery)            // failed Rattest... need to think of blocking
        {
                                                                            // if not 'dont know' rating,
            if(!(enSystem == TvRat_SystemDontKnow || enLevel == TvRat_LevelDontKnow))
            {
                m_fHaltedDelivery = TRUE;                                   // simply block delivery ASAP
                if(fFireEvents)
                {
                    TRACE_1 (LOG_AREA_DECRYPTER, 3,  _T("CDTFilter(%d):: Ratings Block"), m_FilterID);
                    FireBroadcastEvent(EVENTID_DTFilterRatingsBlock);
                }
            }
            else                                                            // else if 'dont know' rating
            {

                if(m_fRunningInSlowMo)                                      // if slow mo, block ASAP
                {
                    m_fHaltedDelivery        = TRUE;
                    m_fDoingDelayBeforeBlock = FALSE;
                    if(fFireEvents)
                    {
                        TRACE_1 (LOG_AREA_DECRYPTER, 3,  _T("CDTFilter(%d):: SlowMo, forcing immediate block"), m_FilterID);
                        FireBroadcastEvent(EVENTID_DTFilterRatingsBlock);
                    }
                }
                else if(FALSE == m_fDoingDelayBeforeBlock)                  // else if just started thinking about blocking
                {
                    REFERENCE_TIME rtStart, rtEnd;                     // compute now+delay to really start blocking
                    HRESULT hrGetTime = pIMediaSample->GetTime(&rtStart, &rtEnd);       // this fails often, just means no time available..
                    if(S_OK == hrGetTime)
                    {
                        m_refTimeToStartBlock = rtStart + m_milsecsDelayBeforeBlock*kMilliSecsToUnits; // MSecsToUnits...(100 nano seconds)
                        m_fDoingDelayBeforeBlock = TRUE;

                        if(fFireEvents)
                            TRACE_3 (LOG_AREA_DECRYPTER, 3,  _T("CDTFilter(%d):: Will Block Unrated at %d (now %d) (msec)"),
                                m_FilterID, long(m_refTimeToStartBlock / 10000), long(rtStart / 10000));

                    }
                }
            }
        }

                // Check if it's time to end the delay period
        if(FALSE == m_fHaltedDelivery &&               // if in delay peroid
            TRUE == m_fDoingDelayBeforeBlock)
        {
            REFERENCE_TIME rtStart, rtEnd;          //  and sample ends after the blocking time
            HRESULT hrGetTime = pIMediaSample->GetTime(&rtStart, &rtEnd);
            if(S_OK == hrGetTime && rtEnd > m_refTimeToStartBlock)
            {
                if(fFireEvents)
                    TRACE_3 (LOG_AREA_DECRYPTER, 3,  _T("CDTFilter(%d):: Ratings Block (Delayed Unrated) at %d (now %d) (msec)"),
                        m_FilterID, long(rtEnd / 10000), long(m_refTimeToStartBlock / 10000));


                m_fHaltedDelivery = TRUE;               // start blocking
                m_fDoingDelayBeforeBlock = FALSE;       // and set out of the delay area

                 if(fFireEvents)
                     FireBroadcastEvent(EVENTID_DTFilterRatingsBlock);
            }
        }

                // decrypt the data if we need to..

        if(FALSE == m_fHaltedDelivery)
        {
            BYTE *pBuffer;
            LONG cbBuffer;
            cbBuffer = pIMediaSample->GetActualDataLength();
            hr = pIMediaSample->GetPointer(&pBuffer);

            ASSERT(!fDataFormatIsBad);      // oops - goofed logic above

            BOOL fDecryptionFailure = FALSE;

            if(!FAILED(hr) && cbBuffer > 0)
            {

                switch(encryptionMethod)
                {
                default:                        // if not defined, it's an error...
                    fDecryptionFailure = TRUE;
                    break;

                case Encrypt_None:              // no encryption
                     break;

                case Encrypt_XOR_Even:         // XOR encryption
                    {
                        DWORD *pdwB = (DWORD *) pBuffer;
                        for(int i = 0; i < cbBuffer / 4; i++)
                        {
                            *pdwB = *pdwB ^ 0xF0F0F0F0;
                            pdwB++;
                        }
                    }
                    break;
                case Encrypt_XOR_Odd:            // XOR encryption
                    {
                        DWORD *pdwB = (DWORD *) pBuffer;
                        for(int i = 0; i < cbBuffer / 4; i++)
                        {
                            *pdwB = *pdwB ^ 0x0F0F0F0F;
                            pdwB++;
                        }
                    }
                    break;
                case Encrypt_XOR_DogFood:         // XOR encryption
                    {
                        DWORD *pdwB = (DWORD *) pBuffer;
                        for(int i = 0; i < cbBuffer / 4; i++)
                        {
                            *pdwB = *pdwB ^ 0xD006F00D;
                            pdwB++;
                        }
                    }
                    break;
               case Encrypt_DRMv1:              // DRMv1 decryption
                   {
#ifndef BUILD_WITH_DRM
                       fDecryptionFailure = TRUE;
                       m_3fDRMLicenseFailure = FALSE;                       // normally set in BindDRMLicense...
#else

                       try
                       {
                           LONG szChars;
                           LONG lValue;

                           TimeitC tcD(&m_tiProcessDRM);                    // simple use of destructor to stop our clock

                           hr = BindDRMLicense(KIDLEN, pEDPv1->m_KID);            // quick return if already bound
                          // ASSERT(!FAILED(hr));                    // don't want this Assert, handle error below.
                           if(!FAILED(hr))
                           {
                               hr = m_cDRMLite.Decrypt((char*) pEDPv1->m_KID, cbBuffer, (BYTE *) pBuffer);
                           }
                           if(FAILED(hr))
                               fDecryptionFailure = TRUE;

                       }
                       catch (...)             // catch DRM errors (e.g debugger is present, and fail rendering)
                       {
                           fDecryptionFailure = TRUE;
                       }
#endif
                   }
                   break;

                }   // end encryption type switch

                if(fDecryptionFailure)
                {
                    m_fHaltedDelivery = true;
                    if(m_3fDRMLicenseFailure != TRUE)       // this is rare case unless I call Decrypt wrong, BindDRMLicense should catch it...
                    {
                        TRACE_3(LOG_AREA_DECRYPTER, 1, L"CDTFilter(%d):: ***Error - Decryption Failure, cbBuffer %d, KID %S",
                            m_FilterID, cbBuffer, pEDPv1->m_KID);
                        if(true) //fFireEvents
                        {
                            FireBroadcastEvent(EVENTID_ETDTFilterLicenseFailure);
                            m_3fDRMLicenseFailure = true;
                        }
                    }
                }

            } // first fOKToSendOnData test
            else            // !(FAILED(hr) && cbBuffer > 0)
            {
                if(pEDPv1)
                    CoTaskMemFree((void *) pEDPv1);
                m_cPackets++;
                TRACE_3(LOG_AREA_DECRYPTER, 1, L"CDTFilter(%d):: *** Bad Packet (%d), hr=0x%08x",
                     m_FilterID, m_cPackets, hr);

                return S_OK;                            // empty packet, do do anything..
            }
        }  // encryption block


            // if FAILED, then should have halted delivery  -- ASSERT to verify
        if(FAILED(hr))
        {
             ASSERT(TRUE == m_fHaltedDelivery);
        }

        m_cPackets++;
        m_clBytesTotal += pIMediaSample->GetActualDataLength();

        //    m_fHaltedDelivery = (m_cPackets % 40) < 20;
        //    m_fHaltedDelivery = false;     // DEBUG - REMOVE THIS WHEN GET DROPPING TO WORK!

        if(pEDPv1)
            CoTaskMemFree((void *) pEDPv1);
    }

     m_tiProcessIn.Stop();                          // manual halt before destructor to avoid SendSample times

    if(!m_fHaltedDelivery)                         // allow further processing of the data
    {
        if(fRestartingDelivery)
        {
            if(fFireEvents)
                TRACE_1(LOG_AREA_DECRYPTER, 3, L"CDTFilter(%d):: Restarting Delivery", m_FilterID);
            OnRestartDelivery(pIMediaSample);
        }
        TRACE_3(LOG_AREA_DECRYPTER, 5, L"CDTFilter(%d):: Playing Sample %d (%d bytes)",
            m_FilterID, m_cPackets, pIMediaSample->GetActualDataLength());

        hr = m_pOutputPin->SendSample(pIMediaSample);
        if(FAILED(hr) && hr != VFW_E_WRONG_STATE)   // 0x80040227
        {
            TRACE_3(LOG_AREA_DECRYPTER, 5, L"CDTFilter(%d)::WARNING** SendSample %d returned hr=0x%08x",
                m_FilterID, m_cPackets, hr);
        }

    }
    else                                        // queue sample up for dropping it
    {
        TRACE_3(LOG_AREA_DECRYPTER, 5, L"CDTFilter(%d):: Dropping Sample %d (%d bytes)",
            m_FilterID, m_cPackets, pIMediaSample->GetActualDataLength());
        // return S_OK;     // leave this line in to simply skip the drop queue

        hr = AddSampleToDropQueue(pIMediaSample);
        if(hr == S_FALSE)
        {
            TRACE_2(LOG_AREA_DECRYPTER, 5, L"CDTFilter(%d)::Warning** - AddSampleToDropQueue %d Failed",
                m_FilterID, m_cPackets);
            // ASSERT(false);          // wasn't able to add sample to DropQueue
        }

        return S_OK;                // ignore the error
    }
        
                                    // refresh the last event every 10 second or so...
    if(fFireEvents)
        PossiblyUpdateBroadcastEvent();

    return hr ;
}


HRESULT
CDTFilter::OnRestartDelivery(IMediaSample *pSample)
{
    ASSERT(pSample != NULL);
    if(NULL == pSample)
        return E_INVALIDARG;

//    DeliverBeginFlush();        // flush upstream packets...
//    DeliverEndFlush();

                    // sample is discontinuous...  mark it so
                    //  else some of the downstream renderers get confused
    pSample->SetDiscontinuity(true);
    m_fHaltedDelivery = false;


    return S_OK;
}


// ----------------------------------------------------------------
//  Do stuff to deliver end of stream -
//  Think this needs to be called when hit end while dumping data
//          This code from modified from:
//              CRenderedInputPin::EndFlush()
//          and CRenderedInputPin::DoCompleteHandling()
//                           multimedia\published\dxmdev\dshowdev\base\amextra.cpp
//
//  Question is, when/how to call this. This code called from RenderedInputPin::EndOfStream()
//   call, but we don't have that on our decypter filter....
//

HRESULT
CDTFilter::DoEndOfStreamDuringDrop()
{
    FILTER_STATE fs;

    HRESULT hr = GetState(0, &fs);
    if (fs == State_Running)
    {
        if (!m_fCompleteNotified) {
            m_fCompleteNotified = TRUE;
            NotifyEvent(EC_COMPLETE, S_OK, (LONG_PTR)(IBaseFilter *)this);
        }
    }
    return hr;
}
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

HRESULT
CDTFilter::BindDRMLicense(IN LONG cbKID, IN BYTE *pbKID)
{
#ifdef BUILD_WITH_DRM
    HRESULT hr = S_OK;
    BYTE  bDecryptRights[RIGHTS_LEN] = {0x01, 0x0, 0x0, 0x0};    // 0x1=PlayOnPC
    
    if(0 >= cbKID || NULL == pbKID)
        return E_INVALIDARG;        // must at least specify one

    if(cbKID != m_cbKID ||          // inefficent test, wonder if some way to use m_fDRMLicenseFailure here...
        0 != strncmp((CHAR *) pbKID, (CHAR *) m_pszKID, cbKID))
    {
        UnBindDRMLicenses();        // remove any existing ones - todo, remove only one

        hr = m_cDRMLite.SetRights( bDecryptRights );


        // Check to verify the data can be decrypted
        BOOL fCanDecrypt;
        hr = m_cDRMLite.CanDecrypt((char *) pbKID, &fCanDecrypt);

        if((FAILED(hr) || (fCanDecrypt == FALSE)) && (m_3fDRMLicenseFailure != TRUE))
        {
            FireBroadcastEvent(EVENTID_ETDTFilterLicenseFailure);       // something went wrong
            m_3fDRMLicenseFailure = TRUE;

        } else {
            if(m_3fDRMLicenseFailure != FALSE)
            {
                m_3fDRMLicenseFailure = FALSE;
                FireBroadcastEvent(EVENTID_ETDTFilterLicenseOK);        // something went right again
            }
                                                                        // keep track of current values...
            m_cbKID = cbKID;
            if(m_pszKID) CoTaskMemFree(m_pszKID); m_pszKID = NULL;
            m_pszKID = (BYTE *) CoTaskMemAlloc(m_cbKID);
            memcpy(m_pszKID, pbKID, cbKID);

            if(NULL == m_pszKID)
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;
#else
    m_3fDRMLicenseFailure = FALSE;
    return S_OK;
#endif
}

HRESULT
CDTFilter::UnBindDRMLicenses()
{

#ifdef BUILD_WITH_DRM
    if(m_pszKID) CoTaskMemFree(m_pszKID);
    m_pszKID = NULL;      // not used other than to see if it changed..
    m_cbKID = 0;

    m_3fDRMLicenseFailure = -2;     // false would be less verbose here...
#endif
        // todo - add stuff here to actually remove it
    return S_OK;
}

HRESULT
CDTFilter::OnCompleteConnect (
    IN  PIN_DIRECTION   PinDir
    )
{

    HRESULT hr = S_OK;

    if (PinDir == PINDIR_INPUT) {
        //  time to display the output pin
        IncrementPinVersion () ;

#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS
        if(false)       // to do, read reg key and set according to value (see JoinFilterGraph).  For now, simple default..
#endif
        {
            hr = CheckIfSecureServer();
            if(FAILED(hr))
                return hr;
        }

        if(kBadCookie == m_dwBroadcastEventsCookie)
        {
            hr = RegisterForBroadcastEvents();  // shouldn't fail here,
        }
    }

    return hr ;
}

HRESULT
CDTFilter::OnBreakConnect (
    IN  PIN_DIRECTION   PinDir
    )
{
    HRESULT hr ;

    if (PinDir == PINDIR_INPUT)
    {
        TRACE_1(LOG_AREA_DECRYPTER, 4, _T("CDTFilter(%d)::OnBreakConnect"), m_FilterID) ;

        if (m_pOutputPin -> IsConnected ()) {
            m_pOutputPin -> GetConnected () -> Disconnect () ;
            m_pOutputPin -> Disconnect () ;

            IncrementPinVersion () ;
        }
        if(kBadCookie != m_dwBroadcastEventsCookie)
            UnRegisterForBroadcastEvents();

        UnhookGraphEventService();
    }

    return S_OK ;
}


HRESULT
CDTFilter::OnOutputGetMediaType (
    OUT CMediaType *    pmtOut
    )
{
    HRESULT hr ;

    ASSERT (pmtOut) ;
    CMediaType mtIn;

    if (m_pInputPin -> IsConnected ()) {
        hr = m_pInputPin->ConnectionMediaType (&mtIn) ;

                    // change it over to a new subtype...
        if(!FAILED(hr)) {
            hr = ProposeNewOutputMediaType(&mtIn, pmtOut);
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

// -------------------------------------------
//  allocator stuff
//      passes everything to the upstream pin

HRESULT
CDTFilter::UpdateAllocatorProperties (
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    HRESULT hr ;

    if (m_pInputPin -> IsConnected ()) {
        hr = m_pInputPin -> SetAllocatorProperties (ppropInputRequest) ;
    }
    else {
        hr = S_OK ;
    }

    return hr ;
}


HRESULT
CDTFilter::GetRefdInputAllocator (
    OUT IMemAllocator **    ppAlloc
    )
{
    HRESULT hr ;

    hr = m_pInputPin -> GetRefdConnectionAllocator (ppAlloc) ;

    return hr ;
}


// ---------------------------


HRESULT
CDTFilter::DeliverBeginFlush (
    )
{
    HRESULT hr ;

    TRACE_1(LOG_AREA_DECRYPTER, 4, _T("CDTFilter(%d)::DeliverBeginFlush"), m_FilterID) ;

    if (m_pOutputPin) {
        hr = m_pOutputPin -> DeliverBeginFlush () ;
    }
    else {
        hr = S_OK ;
    }

    if (SUCCEEDED (hr)) {
    }

    return hr ;
}

HRESULT
CDTFilter::DeliverEndFlush (
    )
{
    HRESULT hr ;

     if (m_pOutputPin) {
        hr = m_pOutputPin -> DeliverEndFlush () ;
        m_fRatingsValid = false;        // re-init the ratings test
    }
    else {
        hr = S_OK ;
    }

    TRACE_1(LOG_AREA_DECRYPTER, 4, _T("CDTFilter(%d)::DeliverEndFlush"), m_FilterID) ;

    return hr ;
}

HRESULT
CDTFilter::DeliverEndOfStream (
    )
{
    HRESULT hr ;

    TRACE_1(LOG_AREA_DECRYPTER, 4, _T("CDTFilter(%d)::DeliverEndOfStream - start"), m_FilterID) ;

    if (m_pOutputPin) {
        hr = m_pOutputPin -> DeliverEndOfStream () ;
    }
    else {
        hr = S_OK ;
    }

    TRACE_1(LOG_AREA_ENCRYPTER, 4, _T("CDTFilter(%d)::DeliverEndOfStream - end"), m_FilterID) ;

    return hr ;
}
// ------------------------------------
STDMETHODIMP
CDTFilter::GetPages (
    CAUUID * pPages
    )
{

    HRESULT hr = S_OK;

#ifdef DEBUG
    pPages->cElems = 2 ;
#else
    pPages->cElems = 1 ;
#endif


    pPages->pElems = (GUID *) CoTaskMemAlloc(pPages->cElems * sizeof GUID) ;

    if (pPages->pElems == NULL)
    {
        pPages->cElems = 0;
        return E_OUTOFMEMORY;
    }
    if(pPages->cElems > 0)
        (pPages->pElems)[0] = CLSID_DTFilterEncProperties;
    if(pPages->cElems > 1)
        (pPages->pElems)[1] = CLSID_DTFilterTagProperties;

    return hr;
}

// ---------------------------------------------------------------------
//      IDTFilter methods
// ---------------------------------------------------------------------
STDMETHODIMP
CDTFilter::get_EvalRatObjOK(
    OUT HRESULT *pHrCoCreateRetVal
    )
{
    if(NULL == pHrCoCreateRetVal)
        return E_POINTER;
    
    *pHrCoCreateRetVal = m_hrEvalRatCoCreateRetValue;

    return S_OK;
}


STDMETHODIMP
CDTFilter::get_BlockedRatingAttributes
            (
             IN  EnTvRat_System         enSystem,
             IN  EnTvRat_GenericLevel   enLevel,
             OUT LONG                  *plbfEnAttrs // BfEnTvRat_GenericAttributes
             )
{
    if(m_spEvalRat == NULL)
        return E_NOINTERFACE;

    HRESULT hr = m_spEvalRat->get_BlockedRatingAttributes(enSystem, enLevel, plbfEnAttrs);

    return hr;
}

STDMETHODIMP
CDTFilter::put_BlockedRatingAttributes
            (
             IN  EnTvRat_System             enSystem,
             IN  EnTvRat_GenericLevel       enLevel,
             IN  LONG                       lbfEnAttrs
            )
{
#ifdef DEBUG
    if(m_fFireEvents)
    {
        const int kBuff = 64;
        TCHAR buff[kBuff];
        RatingToString(enSystem, enLevel, lbfEnAttrs, buff, kBuff);
        TRACE_2(LOG_AREA_DECRYPTER, 3, L"CDTFilter(%d):: put_BlockedRatingAttributes %s",m_FilterID, buff);
    }
#endif

    if(m_spEvalRat == NULL)
        return E_NOINTERFACE;

    HRESULT hr = m_spEvalRat->put_BlockedRatingAttributes(enSystem, enLevel, lbfEnAttrs);

    return hr;
}

STDMETHODIMP
CDTFilter::get_BlockUnRated
            (
             OUT  BOOL              *pfBlockUnRatedShows
            )
{
    if(m_spEvalRat == NULL)
        return E_NOINTERFACE;

    HRESULT hr = m_spEvalRat->get_BlockUnRated(pfBlockUnRatedShows);

    return hr;
}

STDMETHODIMP
CDTFilter::put_BlockUnRated
            (
             IN  BOOL               fBlockUnRatedShows
            )
{

    TRACE_2(LOG_AREA_DECRYPTER, 3, L"CDTFilter(%d):: put_BlockUnRated %d",m_FilterID, fBlockUnRatedShows);

    if(m_spEvalRat == NULL)
        return E_NOINTERFACE;

    HRESULT hr = m_spEvalRat->put_BlockUnRated(fBlockUnRatedShows);

    return hr;
}

STDMETHODIMP
CDTFilter::put_BlockUnRatedDelay
            (
             IN  LONG               milsecsDelayBeforeBlock
            )
{
    if(m_fFireEvents)
        TRACE_2(LOG_AREA_DECRYPTER, 3, L"CDTFilter(%d):: put_BlockUnRatedDelay %f secs",m_FilterID, milsecsDelayBeforeBlock/1000.0);

    if(milsecsDelayBeforeBlock < 0 || milsecsDelayBeforeBlock > 60000)
        return E_INVALIDARG;

    m_milsecsDelayBeforeBlock = milsecsDelayBeforeBlock;

    return S_OK;
}

STDMETHODIMP
CDTFilter::get_BlockUnRatedDelay
            (
             OUT  LONG      *pmilsecsDelayBeforeBlock
            )
{
    if(NULL == pmilsecsDelayBeforeBlock)
        return E_POINTER;

    *pmilsecsDelayBeforeBlock = m_milsecsDelayBeforeBlock;

    return S_OK;
}

STDMETHODIMP
CDTFilter::GetCurrRating
            (
             OUT EnTvRat_System         *pEnSystem,
             OUT EnTvRat_GenericLevel   *pEnLevel,
             OUT LONG                   *plbfEnAttrs     // BfEnTvRat_GenericAttributes
             )
{
    if(pEnSystem == NULL || pEnLevel == NULL || plbfEnAttrs == NULL)
        return E_FAIL;

    *pEnSystem   = m_EnSystemCurr;
    *pEnLevel    = m_EnLevelCurr;
    *plbfEnAttrs = m_lbfEnAttrCurr;

    return S_OK;
}

                // helper method that locks...  // returns S_FALSE if didn't change
HRESULT
CDTFilter::SetCurrRating
            (
             IN EnTvRat_System          enSystem,
             IN EnTvRat_GenericLevel    enLevel,
             IN LONG                    lbfEnAttr
             )
{

    BOOL fChanged = false;

#ifdef DEBUG
    const int kChars = 128;
    TCHAR szBuffFrom[kChars];
    RatingToString(m_EnSystemCurr, m_EnLevelCurr, m_lbfEnAttrCurr, szBuffFrom,  kChars);
#endif

    if(m_EnSystemCurr  != enSystem)  {m_EnSystemCurr = enSystem;   fChanged = true;}
    if(m_EnLevelCurr   != enLevel)   {m_EnLevelCurr  = enLevel;    fChanged = true;}
    if(m_lbfEnAttrCurr != lbfEnAttr) {m_lbfEnAttrCurr = lbfEnAttr; fChanged = true;}


                // changing,or if not valid (just inited), force it to return S_OK
    HRESULT hrChanging = (fChanged || !m_fRatingsValid) ? S_OK : S_FALSE;
    m_fRatingsValid = true;

#ifdef DEBUG
    if(S_OK == hrChanging && m_fFireEvents)
    {
        TCHAR szBuffTo[kChars];
        RatingToString(enSystem, enLevel, lbfEnAttr, szBuffTo,  kChars);

        TRACE_3(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d):: Rating Change %s -> %s"), m_FilterID,
            szBuffFrom, szBuffTo);
    }
#endif

    return hrChanging;
}

// ---------------------------------------------------------------------
// IBroadcastEvent
// ---------------------------------------------------------------------

STDMETHODIMP
CDTFilter::Fire(GUID eventID)     // this comes from the Graph's events - call our own method
{
    TRACE_2(LOG_AREA_BROADCASTEVENTS, 6,  _T("CDTFilter(%d):: Fire(get) - %s"), m_FilterID,
        EventIDToString(eventID));

    if (eventID == EVENTID_TuningChanged)
    {
   //    DoTuneChanged();
    }
    return S_OK;            // doesn't matter what we return on an event...
}

// ---------------------------------------------------------------------
// Broadcast Event Service
// ---------------------------------------------------------------------
HRESULT
CDTFilter::FireBroadcastEvent(IN const GUID &eventID)
{
    HRESULT hr = S_OK;

    if(m_spBCastEvents == NULL)
    {
        hr = HookupGraphEventService();
        if(FAILED(hr)) return hr;
    }

    if(m_spBCastEvents == NULL)
        return E_FAIL;              // wasn't able to create it

    TRACE_2 (LOG_AREA_BROADCASTEVENTS, 5,  _T("CDTFilter(%d):: FireBroadcastEvent : %s"), m_FilterID,
        EventIDToString(eventID));


    hr = m_pClock->GetTime(&m_refTimeLastEvent);
    
    m_lastEventID = eventID;

    return m_spBCastEvents->Fire(eventID);
}

HRESULT
CDTFilter::PossiblyUpdateBroadcastEvent()
{
    REFERENCE_TIME refTimeNow;
    HRESULT hr = m_pClock->GetTime(&refTimeNow);
    if(FAILED(hr))
        return hr;

    if( (int(refTimeNow - m_refTimeLastEvent)/10000) > kMaxMSecsBetweenEvents)
    {
        TRACE_2 (LOG_AREA_BROADCASTEVENTS, 5,  _T("CDTFilter(%d):: PossiblyUpdateBroadcastEvent : %s"), m_FilterID,
            EventIDToString(m_lastEventID));

        FireBroadcastEvent(m_lastEventID);
    }
    return S_OK;
}

HRESULT
CDTFilter::HookupGraphEventService()
{
                        // basically, just makes sure we have the broadcast event service object
                        //   and if it doesn't exist, it creates it..
    TimeitC ti(&m_tiStartup);

    HRESULT hr = S_OK;
    TRACE_1(LOG_AREA_BROADCASTEVENTS, 3, _T("CDTFilter(%d)::HookupGraphEventService"), m_FilterID) ;

    if (!m_spBCastEvents)
    {

        CAutoLock  cLockGlob(m_pCritSectGlobalFilt);

        CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
        if (spServiceProvider == NULL) {
            TRACE_0 (LOG_AREA_BROADCASTEVENTS, 1, _T("CDTFilter:: Can't get service provider interface from the graph"));
            return E_NOINTERFACE;
        }
        hr = spServiceProvider->QueryService(SID_SBroadcastEventService,
                                             IID_IBroadcastEvent,
                                             reinterpret_cast<LPVOID*>(&m_spBCastEvents));
        if (FAILED(hr) || !m_spBCastEvents)
        {
            hr = m_spBCastEvents.CoCreateInstance(CLSID_BroadcastEventService, 0, CLSCTX_INPROC_SERVER);
            if (FAILED(hr)) {
                TRACE_0 (LOG_AREA_BROADCASTEVENTS, 1,  _T("CDTFilter:: Can't create BroadcastEventService"));
                return E_UNEXPECTED;
            }
            CComQIPtr<IRegisterServiceProvider> spRegisterServiceProvider(m_pGraph);
            if (spRegisterServiceProvider == NULL) {
                TRACE_0 (LOG_AREA_BROADCASTEVENTS, 1,  _T("CDTFilter:: Can't get RegisterServiceProvider from Graph"));
                return E_UNEXPECTED;
            }
            hr = spRegisterServiceProvider->RegisterService(SID_SBroadcastEventService, m_spBCastEvents);
            if (FAILED(hr)) {
                    // deal with unlikely race condition case here, if can't register, perhaps someone already did it for us
                TRACE_1 (LOG_AREA_BROADCASTEVENTS, 2,  _T("CDTFilter:: Rare Warning - Can't register BroadcastEventService in Service Provider. hr = 0x%08x"), hr);
                hr = spServiceProvider->QueryService(SID_SBroadcastEventService,
                                                     IID_IBroadcastEvent,
                                                     reinterpret_cast<LPVOID*>(&m_spBCastEvents));
                if(FAILED(hr))
                {
                    TRACE_1 (LOG_AREA_BROADCASTEVENTS, 1,  _T("CDTFilter:: Can't reget BroadcastEventService in Service Provider.. hr = 0x%08x"), hr);
                    return hr;
                }
            }
        }

        TRACE_3(LOG_AREA_BROADCASTEVENTS, 4, _T("CDTFilter(%d)::HookupGraphEventService - Service Provider 0x%08x, Service 0x%08x"),m_FilterID,
            spServiceProvider, m_spBCastEvents) ;

    }

    return hr;
}


HRESULT
CDTFilter::UnhookGraphEventService()
{
    HRESULT hr = S_OK;

    TimeitC ti(&m_tiTeardown);

    if(m_spBCastEvents != NULL)
    {
        m_spBCastEvents = NULL;     // null this out, will release object reference to object above
    }                               //   the filter graph will release final reference to created object when it goes away

    return hr;
}
            // ---------------------------------------------
            // DTFilter filter may not actually need to receive XDS events...
            //  but we'll leave the code in here for now.

HRESULT
CDTFilter::RegisterForBroadcastEvents()
{
    HRESULT hr = S_OK;
    TRACE_1(LOG_AREA_BROADCASTEVENTS, 3, _T("CDTFilter(%d):: RegisterForBroadcastEvents"), m_FilterID);

    TimeitC ti(&m_tiStartup);

    if(m_spBCastEvents == NULL)
        hr = HookupGraphEventService();


//  _ASSERT(m_spBCastEvents != NULL);       // failed hooking to HookupGraphEventService
    if(m_spBCastEvents == NULL)
    {
        TRACE_0(LOG_AREA_BROADCASTEVENTS, 3,_T("CDTFilter::RegisterForBroadcastEvents - Warning - Broadcast Event Service not yet created"));
        return hr;
    }

                /* IBroadcastEvent implementing event receiving object*/
    if(kBadCookie != m_dwBroadcastEventsCookie)
    {
        TRACE_0(LOG_AREA_BROADCASTEVENTS, 3, _T("CDTFilter::Already Registered for Broadcast Events"));
        return E_UNEXPECTED;
    }

    CComQIPtr<IConnectionPoint> spConnectionPoint(m_spBCastEvents);
    if(spConnectionPoint == NULL)
    {
        TRACE_0(LOG_AREA_BROADCASTEVENTS, 1, _T("CDTFilter::Can't QI Broadcast Event service for IConnectionPoint "));
        return E_NOINTERFACE;
    }


    CComPtr<IUnknown> spUnkThis;
    this->QueryInterface(IID_IUnknown, (void**)&spUnkThis);

    hr = spConnectionPoint->Advise(spUnkThis,  &m_dwBroadcastEventsCookie);
//  hr = spConnectionPoint->Advise(static_cast<IBroadcastEvent*>(this),  &m_dwBroadcastEventsCookie);
    if (FAILED(hr)) {
        TRACE_1(LOG_AREA_BROADCASTEVENTS, 1, _T("CDTFilter::Can't advise event notification. hr = 0x%08x"),hr);
        return E_UNEXPECTED;
    }
    TRACE_3(LOG_AREA_BROADCASTEVENTS, 3, _T("CDTFilter(%d)::RegisterForBroadcastEvents - Advise 0x%08x on CP 0x%08x"),
        m_FilterID, spUnkThis,spConnectionPoint);

    return hr;
}


HRESULT
CDTFilter::UnRegisterForBroadcastEvents()
{
    HRESULT hr = S_OK;
    TRACE_1(LOG_AREA_BROADCASTEVENTS, 3,  _T("CDTFilter(%d):: UnRegisterForBroadcastEvents"),m_FilterID);

    TimeitC ti(&m_tiTeardown);

    if(kBadCookie == m_dwBroadcastEventsCookie)
    {
        TRACE_1(LOG_AREA_BROADCASTEVENTS, 3, _T("CDTFilter(%d):: Not Yet Registered for Broadcast Events"),m_FilterID);
        return S_FALSE;
    }

    CComQIPtr<IConnectionPoint> spConnectionPoint(m_spBCastEvents);
    if(spConnectionPoint == NULL)
    {
        TRACE_1(LOG_AREA_BROADCASTEVENTS, 1, _T("CDTFilter(%d):: Can't QI Broadcast Event service for IConnectionPoint "),m_FilterID);
        return E_NOINTERFACE;
    }

    hr = spConnectionPoint->Unadvise(m_dwBroadcastEventsCookie);
    m_dwBroadcastEventsCookie = kBadCookie;

    if(!FAILED(hr))
        TRACE_1(LOG_AREA_BROADCASTEVENTS, 3, _T("CDTFilter(%d):: Successfully Unregistered for Broadcast events"), m_FilterID);
    else
        TRACE_2(LOG_AREA_BROADCASTEVENTS, 2, _T("CDTFilter(%d)::UnRegisterForBroadcastEvents Failed - hr = 0x%08x"),m_FilterID, hr);
        
    return hr;
}

// ----------------------------------------------------------------

HRESULT
CDTFilter::IsInterfaceOnPinConnectedTo_Supported(
                       IN  PIN_DIRECTION    PinDir,         // either PINDIR_INPUT of PINDIR_OUTPUT
                       IN  REFIID           riid
                       )
{
    if(PinDir != PINDIR_OUTPUT)
        return E_NOTIMPL;

    return m_pOutputPin->IsInterfaceOnPinConnectedTo_Supported(riid);
}


HRESULT
CDTFilter::KSPropSetFwd_Set(
                 IN  PIN_DIRECTION   PinDir,
                 IN  REFGUID         guidPropSet,
                 IN  DWORD           dwPropID,
                 IN  LPVOID          pInstanceData,
                 IN  DWORD           cbInstanceData,
                 IN  LPVOID          pPropData,
                 IN  DWORD           cbPropData
                 )
{
    if(PinDir != PINDIR_OUTPUT)
        return E_NOTIMPL;

        // if it's a rate change, we want to examine it..
    if(AM_KSPROPSETID_TSRateChange == guidPropSet  &&
       AM_RATE_SimpleRateChange == dwPropID)
    {
        AM_SimpleRateChange *pData = (AM_SimpleRateChange *) pPropData;
        ASSERT(cbPropData == sizeof(AM_SimpleRateChange));
        if(cbPropData == sizeof(AM_SimpleRateChange))
        {

                    // 10000/passed rate is true speed...
            float Speed10k = abs(1.0e8/pData->Rate);

                           // update the rate segment
            HRESULT hr = m_PTSRate.NewSegment (pData->StartTime, double(Speed10k)/10000.0) ;

             if(Speed10k < kMax10kSpeedToCountAsSlowMo)
            {
                m_fRunningInSlowMo = true;
                TRACE_2(LOG_AREA_DECRYPTER, 2, L"CDTFilter(%d):: in SlowMo Mode (speed= %8.2f)", m_FilterID, double(Speed10k)/10000.0 );
            }
            else
            {
                m_fRunningInSlowMo = false;
                TRACE_2(LOG_AREA_DECRYPTER, 2, L"CDTFilter(%d):: in normal Mode (speed= %8.2f)", m_FilterID, double(Speed10k)/10000.0);
            }
        }
    }

   return m_pOutputPin->KSPropSetFwd_Set(guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData );

}

HRESULT
CDTFilter::KSPropSetFwd_Get(
                 IN  PIN_DIRECTION   PinDir,
                 IN  REFGUID         guidPropSet,
                 IN  DWORD           dwPropID,
                 IN  LPVOID          pInstanceData,
                 IN  DWORD           cbInstanceData,
                 OUT LPVOID          pPropData,
                 IN  DWORD           cbPropData,
                 OUT DWORD           *pcbReturned
                 )
{
    if(PinDir != PINDIR_OUTPUT)
        return E_NOTIMPL;

    // at some point far into the future, support query most forward object here.

        // if it's a rate change, we want to examine it (too?  need to do this, or just being paranoid)..
    if(AM_KSPROPSETID_TSRateChange == guidPropSet  &&
       AM_RATE_SimpleRateChange == dwPropID)
    {
        AM_SimpleRateChange *pData = (AM_SimpleRateChange *) pPropData;
        ASSERT(cbPropData == sizeof(AM_SimpleRateChange));
        if(cbPropData == sizeof(AM_SimpleRateChange))
        {
                    // passed rate is 10,000 times true rate
            float Speed10k = abs(1.0e8/pData->Rate);
            if(Speed10k < kMax10kSpeedToCountAsSlowMo)
            {
                m_fRunningInSlowMo = true;
               TRACE_2(LOG_AREA_DECRYPTER, 2, L"CDTFilter(%d):: (get) in SlowMo Mode (speed= %8.2f)", m_FilterID, double(Speed10k)/10000.0 );
            }
            else
            {
                m_fRunningInSlowMo = false;
                TRACE_2(LOG_AREA_DECRYPTER, 2, L"CDTFilter(%d)::(get) in normal Mode (speed= %8.2f)", m_FilterID, double(Speed10k)/10000.0);
            }
        }
    }
    return m_pOutputPin->KSPropSetFwd_Get(guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned );

}

HRESULT
CDTFilter::KSPropSetFwd_QuerySupported(
                            IN  PIN_DIRECTION    PinDir,
                            IN  REFGUID          guidPropSet,
                            IN  DWORD            dwPropID,
                            OUT DWORD            *pTypeSupport
                            )
{
    if(PinDir != PINDIR_OUTPUT)
        return E_NOTIMPL;

    return m_pOutputPin->KSPropSetFwd_QuerySupported(guidPropSet, dwPropID, pTypeSupport);

}




// ----------------------------------------------------------------
// The da-ta-ta-da (drum roll please)
//      DROP QUEUE!
//
//  The DropQueue is responsible for queueing up media samples that should
//  be dropped (either because we can'd decode them or morelikley, because
//  they're ratings value exceeded the max rating, and then releasing them
//  when their presentation time stamp is exceeded.
//
//  We do this, rather than just release them immediatly, to slow down the
//  delivery of upstream filters.  Without it, they'll just deliver samples
//  as fast as they can generate them, spinning out of control.....
//
//  The DropQueue is a simple fixed length array of media samples that I turn
//  into a circular buffer through the miracle of the modulo operator.
//  It seems dangerous to hold onto too many samples, and the code is more complicated,
//  so the fixed buffer seems appropriate here.
//
//  Stored samples are reference counted as they are added to the queue.
//  When they are removed, the reference count is decremented.
//
//
//  Syncronization objects used
//          // these 3 locks should go in the following order...
//
//      m_pLock                     -- used to protect Filter variables
//      m_CritSecDropQueue          -- used to protect DumpQueue variables
//      m_CritSecAdviseTime         -- used to protect AdviseTime variables
//
//      m_hDropQueueThreadAliveEvent-- used just once to block CreateDropQueueThread until the DropQueue thread is alive
//      m_hDropQueueFullSemaphore   -- used to block main thread from fill up the drop queu
//                                      (init to N and counts down to zero with packets)
//      m_hDropQueueEmptySemaphore  -- used to block DropQueue thread when have no packets
//                                      (inits to 0 and counts upward with packets)
//      m_hDropQueueTimeEvent       -- wait timer used to block until packet's display time is past
//
// -----------------------------------------------------------------------

HRESULT
CDTFilter::CreateDropQueueThread()
{
#ifdef SIMPLIFY_THINGS
    return S_OK;
#endif

    TimeitC ti(&m_tiStartup);

    HRESULT hr = S_OK;

    if(m_hDropQueueThread)          // already created.
         return S_FALSE;

    _ASSERT(NULL == m_hDropQueueThread);

    try
    {
                    // one use event to wait until queue is alive before continuing
        m_hDropQueueThreadAliveEvent = CreateEvent( NULL, FALSE, FALSE, NULL ); // security, manualreset, initialstate, name
        if( !m_hDropQueueThreadAliveEvent ) {
            KillDropQueueThread();
            return E_FAIL;
        }

                   // one use event to wait until queue is alive before continuing - ManualReset=TRUE
        m_hDropQueueThreadDieEvent = CreateEvent( NULL, TRUE, FALSE, NULL ); // security, manualreset, initialstate, name
        if( !m_hDropQueueThreadDieEvent ) {
            KillDropQueueThread();
            return E_FAIL;
        }

        // waited on in DropQueue, inits to zero, goes when non-zero
        m_hDropQueueEmptySemaphore = CreateSemaphore( NULL, 0, kMaxQueuePackets, NULL );
        if( !m_hDropQueueEmptySemaphore ) {
            KillDropQueueThread();
            return E_FAIL;
        }


        // waited on in Main thread, inits to N, stops when counts down to zero
        m_hDropQueueFullSemaphore = CreateSemaphore( NULL, kMaxQueuePackets, kMaxQueuePackets, NULL );
        if( !m_hDropQueueFullSemaphore ) {
            KillDropQueueThread();
            return E_FAIL;
        }

        // wait inside of DropQueue thread until sample becomes stale and it can be dropped...
        m_hDropQueueAdviseTimeEvent = CreateEvent( NULL, FALSE, FALSE, NULL ); // security, manualreset, initialstate, name
        if( !m_hDropQueueAdviseTimeEvent ) {
            KillDropQueueThread();
            return E_FAIL;
        }


        m_hDropQueueThread = CreateThread (NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) DropQueueThreadProc,
                                        (LPVOID) this,
                                        NULL,
                                        &m_dwDropQueueThreadId) ;

        if (!m_hDropQueueThread) {
            KillDropQueueThread() ;
            return E_FAIL ;
        }

        // wait for it to finish initializing
        WaitForSingleObject( m_hDropQueueThreadAliveEvent, INFINITE );

        TRACE_3(LOG_AREA_DECRYPTER, 4, L"CDTFilter(%d):: Created DropQueue Thread (Thread 0x%x - id 0x%x)",
                   m_FilterID, m_hDropQueueThread, m_dwDropQueueThreadId);

                    // drop the queue thread priority down a bit...
//        SetThreadPriority (m_hQueueThread, THREAD_PRIORITY_NORMAL);
        SetThreadPriority (m_hDropQueueThread, THREAD_PRIORITY_BELOW_NORMAL);

    } catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}


HRESULT
CDTFilter::KillDropQueueThread()
{
#ifdef SIMPLIFY_THINGS
    return S_OK;
#endif

    HRESULT hr = S_OK;

    TimeitC ti(&m_tiTeardown);


    TRACE_1(LOG_AREA_DECRYPTER, 4, L"CDTFilter(%d):: Killing the DropQueue Thread", m_FilterID);
    SetEvent( m_hDropQueueThreadDieEvent );
    hr = WaitForSingleObject(m_hDropQueueThread, INFINITE);        // now wait for the QueueThread to Die..

    TRACE_1(LOG_AREA_DECRYPTER, 4, L"CDTFilter(%d):: The DropQueue Thread Is Dead...", m_FilterID);


    if(NULL != m_pClock)                            // stop listening for timer events
    {
        CAutoLock  cLock2(&m_CritSecAdviseTime);     // wait until crit sec exits, then get the lock (wait doesn't hold it?)
        if(0 != m_dwDropQueueEventCookie)
        {
            m_pClock->Unadvise(m_dwDropQueueEventCookie);
            m_dwDropQueueEventCookie = 0;
        }
    }

    try {

        if (m_hDropQueueThread)
        {
            ASSERT(WAIT_OBJECT_0 == hr);

                // no fancy flushing of the dropQueue thread here (het), just do it..
            DWORD err = 0;
            BOOL fOk;

                                // clear up all the other events
            fOk = CloseHandle( m_hDropQueueThreadDieEvent );
            m_hDropQueueThreadDieEvent = NULL;
            if(!fOk) err = GetLastError();
            ASSERT(fOk);

            fOk = CloseHandle( m_hDropQueueAdviseTimeEvent );
            m_hDropQueueAdviseTimeEvent = NULL;
            if(!fOk) err = GetLastError();
            ASSERT(fOk);


            fOk = CloseHandle( m_hDropQueueFullSemaphore );
            m_hDropQueueFullSemaphore = NULL;
            if(!fOk) err = GetLastError();
            ASSERT(fOk);

            fOk = CloseHandle( m_hDropQueueEmptySemaphore );
            m_hDropQueueEmptySemaphore = NULL;
            if(!fOk) err = GetLastError();
            ASSERT(fOk);

            fOk = CloseHandle( m_hDropQueueThreadAliveEvent );
            m_hDropQueueThreadAliveEvent = NULL;
            if(!fOk) err = GetLastError();
            ASSERT(fOk);

            fOk = CloseHandle ( m_hDropQueueThread ) ;
            m_hDropQueueThread = NULL ;
            if(!fOk) err = GetLastError();
            ASSERT(fOk);

        }
    } catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT
CDTFilter::FlushDropQueue()
{
#ifdef SIMPLIFY_THINGS
    return S_OK;
#endif

    TRACE_1(LOG_AREA_DECRYPTER, 4, L"CDTFilter(%d)::FlushDropQueue", m_FilterID);

    KillDropQueueThread();                  // kill our dropQueue thread

                                            // release all our samples
    {
       CAutoLock  cLock(&m_CritSecDropQueue);       // shouldn't need this here - DropQueue should be dead

        for(int i = 0; i < kMaxQueuePackets; i++)
        {
           if(NULL != m_rgMedSampDropQueue[i])
               m_rgMedSampDropQueue[i]->Release();
           m_rgMedSampDropQueue[i] = NULL;
        };

        m_cDropQueueMin = 0;
        m_cDropQueueMax = 0;
    }

    return S_OK;
}


void
CDTFilter::DropQueueThreadProc (CDTFilter *pcontext)
{
    _ASSERT(pcontext) ;

    // NOTE: the thread will not have a message loop until we call some function that references it.
    //          CoInitializeEx with a APARTMENTTHREADED will implicitly reference the message queue
    //          So block the calling thread (sending the WM_QUIT) until after we have initialized
    //          (see the SetEvent in queueThreadBody).


    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);     // initialize it... (maybe multithreaded later???)
    pcontext -> DropQueueThreadBody () ;

    return ;                                            // never actually returns ???
}

void
CDTFilter::DropMinSampleFromDropQueue()
{
    CAutoLock  cLock(&m_CritSecDropQueue);

    if(m_rgMedSampDropQueue[m_cDropQueueMin] != NULL)       // start at min/max == (0,0)
    {
        m_rgMedSampDropQueue[m_cDropQueueMin]->Release();
        m_rgMedSampDropQueue[m_cDropQueueMin] = NULL;
    }
    m_cDropQueueMin = ((m_cDropQueueMin + 1) % kMaxQueuePackets);     // humm, strange but safer

}

void
CDTFilter::AddMaxSampleToDropQueue(IMediaSample *pSample)
{
#ifdef SIMPLIFY_THINGS
    return;
#endif
    CAutoLock  cLock(&m_CritSecDropQueue);

// vvvv Test Code
    int c1 = (m_cDropQueueMax + kMaxQueuePackets - 1) % kMaxQueuePackets;
    if(m_rgMedSampDropQueue[c1])
    {
        REFERENCE_TIME s1,e1,s2,e2;
        m_rgMedSampDropQueue[c1]->GetTime(&s1,&e1);
        pSample->GetTime(&s2,&e2);
        ASSERT(s2 >= s1);
    }
// ^^^^ End Test Cde

            // keep this new one...
    m_rgMedSampDropQueue[m_cDropQueueMax] = pSample;
    m_rgMedSampDropQueue[m_cDropQueueMax]->AddRef();        // keep track of it for a bit...

            // increment the counter
    m_cDropQueueMax = ((m_cDropQueueMax + 1) % kMaxQueuePackets);

}

IMediaSample *
CDTFilter::GetMinDropQueueSample()
{
    CAutoLock  cLock(&m_CritSecDropQueue);

    return m_rgMedSampDropQueue[m_cDropQueueMin];

}

// locking order:
//      m_pLock always encloses m_CritSecDropQueue

HRESULT
CDTFilter::AddSampleToDropQueue(IMediaSample *pSample)      // this method may block...
{
#ifdef SIMPLIFY_THINGS
    return S_OK;
#endif
    HRESULT hr = S_OK;

    if(pSample == NULL)
        return E_INVALIDARG;

    if(!m_fHaltedDelivery)
        TRACE_1(LOG_AREA_DECRYPTER, 3, L"CDTFilter(%d):: Starting to Drop Packets", m_FilterID);

    TRACE_1(LOG_AREA_DECRYPTER, 5, L"CDTFilter(%d)::  Dropping Packet", m_FilterID);


                                    // keep track that we are dropping here, so we can
                                    //   put a discontinuous marker when we start up again.

    if(NULL == m_hDropQueueThreadDieEvent)
    {
        return S_FALSE;             // coming back after a die event... Something strage
    }

    HANDLE hArray[] =
    {
       m_hDropQueueThreadDieEvent,      // first one is the die event..
       m_hDropQueueFullSemaphore        //  block if DropQueue is full
    };

    TRACE_1(LOG_AREA_DECRYPTER, 9, L"CDTFilter(%d):: --Wait On Full", m_FilterID);
                     // can we add something to the queue   -  decrements semaphore count by one
    hr = WaitForMultipleObjects(sizeof(hArray)/sizeof(hArray[0]),
                                hArray,
                                false,      // bWaitAll
                                INFINITE);
    TRACE_1(LOG_AREA_DECRYPTER, 9, L"CDTFilter(%d):: ----Done Wait On Full", m_FilterID);

    DWORD dwHr = DWORD(hr);     // cast to avoid prefast complaints about next line
    if(WAIT_OBJECT_0 == dwHr || WAIT_ABANDONED_0 == dwHr)     // if DieEvent - just exit...
    {
        return S_OK;            // error state
    }

            // these could be null for us...
    if(0 == m_hDropQueueEmptySemaphore || 0 == m_hDropQueueEmptySemaphore)
    {
        return S_OK;
    }
    TRACE_1(LOG_AREA_DECRYPTER, 9, L"CDTFilter(%d):: ------Now Dropping", m_FilterID);

    AddMaxSampleToDropQueue(pSample);

                // we've added something... Bump Empty semaphore up by one so it will start
    LONG lPrevCount;
    BOOL fOK = ReleaseSemaphore(m_hDropQueueEmptySemaphore, 1, &lPrevCount);
    TRACE_2(LOG_AREA_DECRYPTER, 9, L"CDTFilter(%d):: --------Release Empty Semaphore - %d", m_FilterID ,lPrevCount);
    if(!fOK)
    {
        hr = GetLastError();
        ASSERT(false);
    }

    return S_OK;        // the hr from WaitForMult isn't really an hr, so don't return it...
}



                            // drop samples from drop queue
                            //   but only when their presentation time has gone by...

HRESULT
CDTFilter::DropQueueThreadBody()
{
    REFERENCE_TIME refTimeNow=0;
    HRESULT hr;

                // signal caller we are alive! We're ALIVE!  Ha Ha Ha!!!
    SetEvent( m_hDropQueueThreadAliveEvent );
    TRACE_1(LOG_AREA_DECRYPTER, 3, L"CDTFilter(%d):: DropQueue Thread Lives!", m_FilterID);

    HANDLE hArray[] =
    {
       m_hDropQueueThreadDieEvent,     // first one is the die event..
       m_hDropQueueEmptySemaphore
    };

    while(true)
    {
        TRACE_1(LOG_AREA_DECRYPTER, 9, L"CDTFilter(%d):: ......Start Wait On Empty", m_FilterID);
        hr = WaitForMultipleObjects(sizeof(hArray)/sizeof(hArray[0]),
                               hArray,
                               false,   // WaitForAll
                               INFINITE);   // infinite
        TRACE_1(LOG_AREA_DECRYPTER, 9,L"CDTFilter(%d):: ........Done Wait On Empty", m_FilterID);

        DWORD dwHr = DWORD(hr);     // cast to avoid prefast complaints about next line
        if(WAIT_OBJECT_0 == dwHr || WAIT_ABANDONED_0 == dwHr)
            return S_OK;

        TRACE_1(LOG_AREA_DECRYPTER, 9,L"CDTFilter(%d):: ........Got Packet", m_FilterID);

        if(NULL == m_pClock)        // no clock to do stuff with
            return S_FALSE;
         // current time w.r.t. base time (m_tStart)
        hr = m_pClock->GetTime(&refTimeNow);
        ASSERT(!FAILED(hr));

        REFERENCE_TIME refStreamTimeStart=0, refStreamTimeEnd=0;

        IMediaSample *pSamp = GetMinDropQueueSample();
        ASSERT(pSamp != NULL);

                // refTimeEnd should contain sample end of next sample to drop...
        hr = pSamp->GetTime(&refStreamTimeStart, &refStreamTimeEnd);
        REFERENCE_TIME refDropTime = refStreamTimeStart;                // should this be end?

                // scale time for slow/fast motion out of DVR
        m_PTSRate.ScalePTS(&refDropTime);

                // Now wait until this sample is to be rendered before dropping it
        TRACE_1(LOG_AREA_DECRYPTER, 9,L"CDTFilter(%d)::..........Start Time Wait", m_FilterID);
        if(1)
        {
            {
                CAutoLock cLock(&m_CritSecAdviseTime);
                m_pClock->AdviseTime(m_tStart, refDropTime, (HEVENT) m_hDropQueueAdviseTimeEvent,(DWORD_PTR *) &m_dwDropQueueEventCookie);
            }

             HANDLE hArrayTE[] =
            {
               m_hDropQueueThreadDieEvent,     // first one is the die event..
               m_hDropQueueAdviseTimeEvent
            };

                // now wait for it to signal, or someone telling us to exit
            hr = WaitForMultipleObjects(sizeof(hArrayTE)/sizeof(hArrayTE[0]),
                               hArrayTE,
                               false,       // WaitForAll
                               INFINITE);   // infinite

            dwHr = DWORD(hr);     // cast to avoid prefast complaints about next line
            if(WAIT_OBJECT_0 == dwHr || WAIT_ABANDONED_0 == dwHr)   // killed do to 'die' event?
            {
                CAutoLock cLock(&m_CritSecAdviseTime);          // need to Unadvise first
                m_pClock->Unadvise(m_dwDropQueueEventCookie);
                 m_dwDropQueueEventCookie = 0;
            } else {                                            // else just clear the cookie..
                CAutoLock cLock(&m_CritSecAdviseTime);
                m_dwDropQueueEventCookie = 0;
            }
        }
        else             // --> so we sleep for a bit instead.... Need to make above work better however
        {
            Sleep(200);         // just wait a bit... then try again
        }
        TRACE_2(LOG_AREA_DECRYPTER, 9,L"CDTFilter(%d):: ..........Finish Time Wait, Dropping Packet %d", m_FilterID,m_cSampsDropped);

            // waited till time packet needs to go away...
        DropMinSampleFromDropQueue();

            // Now lets bump our semaphore count down by one... (Main thread pauses if it goes to zero).
        {
      //      CAutoLock cLock(&m_CritSecDropQueue);
            LONG lPrevCount;
            BOOL fOK = ReleaseSemaphore(m_hDropQueueFullSemaphore, 1, &lPrevCount);
            TRACE_2(LOG_AREA_DECRYPTER, 9,L"CDTFilter(%d):: ............Release Full Semaphore - %d", m_FilterID,lPrevCount);
            if(!fOK)
            {
                hr = GetLastError();
                ASSERT(fOK);      // if false,  released one too many (how?) else error
            }
            m_cSampsDropped++;
        }

    }   // end outer while loop (should never happen)

    return S_OK;
}


/// -----------------------------------------------------------------------------
//  Are we running under a secure server?
//        return S_OK only if we trust the server registered in the graph service provider
/// ------------------------------------------------------------------------------
#include "DrmRootCert.h"

#ifdef BUILD_WITH_DRM

#ifdef USE_TEST_DRM_CERT
#include "Keys_7001.h"
static const BYTE* pabCert3      = abCert7001;
static const int   cBytesCert3   = sizeof(abCert7001);
static const BYTE* pabPVK3       = abPVK7001;
static const int   cBytesPVK3    = sizeof(abPVK7001);

#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
static const BYTE* pabCert2      = abCert7001;
static const int   cBytesCert2   = sizeof(abCert7001);
static const BYTE* pabPVK2       = abPVK7001;
static const int   cBytesPVK2    = sizeof(abPVK7001);
#endif

#else   // !USE_TEST_DRM_CERT

#include "Keys_7003.h"                                  // 7003 used for client side certification
static const BYTE* pabCert3      = abCert7003;
static const int   cBytesCert3   = sizeof(abCert7003);
static const BYTE* pabPVK3       = abPVK7003;
static const int   cBytesPVK3    = sizeof(abPVK7003);

#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
#include "Keys_7002.h"                                  // 7002 used for server side simulation
static const BYTE* pabCert2      = abCert7002;
static const int   cBytesCert2   = sizeof(abCert7002);
static const BYTE* pabPVK2       = abPVK7002;
static const int   cBytesPVK2    = sizeof(abPVK7002);
#endif

#endif
#endif  // BUILD_WITH_DRM


HRESULT
CDTFilter::CheckIfSecureServer(IFilterGraph *pGraph)
{
    TimeitC ti(&m_tiAuthenticate);

    if(!(pGraph == NULL || m_pGraph == NULL || m_pGraph == pGraph)) // only allow arg to be passed in when m_pGraph is NULL
        return E_INVALIDARG;                //  -- lets us work in JoinFilterGraph().

#ifndef BUILD_WITH_DRM
    TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::CheckIfSecureServer - No Drm - not enabled"), m_FilterID) ;
    return S_OK;
#else

    TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::CheckIfSecureServer"), m_FilterID) ;

                        // basically, just makes sure we have the broadcast event service object
                        //   and if it doesn't exist, it creates it..
    HRESULT hr = S_OK;

    CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph ? m_pGraph : pGraph);
    if (spServiceProvider == NULL) {
        TRACE_1 (LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%2):: Can't get service provider interface from the graph"),m_FilterID);
        return E_NOINTERFACE;
    }
    CComPtr<IDRMSecureChannel>  spSecureService;

    hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel,
                                         IID_IDRMSecureChannel,
                                         reinterpret_cast<LPVOID*>(&spSecureService));

    if(!FAILED(hr))
    {
        do
        {
            // Create the Client and Init the keys/certs
            //
            CComPtr<IDRMSecureChannel>  spSecureServiceClient;

            hr = DRMCreateSecureChannel( &spSecureServiceClient);
            if(spSecureServiceClient == NULL )
                hr = E_OUTOFMEMORY;

            if( FAILED (hr) )
                break;


            hr = spSecureServiceClient->DRMSC_AtomicConnectAndDisconnect(
                    (BYTE *)pabCert3, cBytesCert3,                          // Cert
                    (BYTE *)pabPVK3,  cBytesPVK3,                           // PrivKey
                    (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot),     // PubKey
                    spSecureService);

            if( FAILED( hr ) )
                break;              // silly here, but a place to hang a breakpoint...

        } while (false) ;
    }

    TRACE_2(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::CheckIfSecureServer -->%s"),
        m_FilterID, S_OK == hr ? L"Succeeded" : L"Failed") ;
    return hr;
#endif

}

HRESULT
CDTFilter::InitializeAsSecureClient()
{
    TimeitC ti(&m_tiAuthenticate);

#ifndef BUILD_WITH_DRM
    TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::InitializeAsSecureClient - No Drm - not enabled"), m_FilterID) ;
    return S_OK;
#else

    TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::InitializeAsSecureClient"), m_FilterID) ;

    // BEGIN obfuscation

 // Create the Client and Init the keys/certs
                    //
    HRESULT hr = DRMCreateSecureChannel( &m_spDRMSecureChannel);
    if(m_spDRMSecureChannel == NULL )
        hr = E_OUTOFMEMORY;

    if( FAILED (hr) )
        m_spDRMSecureChannel = NULL;        // force the release

    if( !FAILED (hr) )
        hr = m_spDRMSecureChannel->DRMSC_SetCertificate( (BYTE *)pabCert3, cBytesCert3 );

    if( !FAILED (hr) )
        hr = m_spDRMSecureChannel->DRMSC_SetPrivateKeyBlob( (BYTE *)pabPVK3, cBytesPVK3 );

    if( !FAILED (hr) )
        hr = m_spDRMSecureChannel->DRMSC_AddVerificationPubKey( (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot) );

    // END obfuscation

    TRACE_2(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::InitializeAsSecureClient -->%s"),
        m_FilterID, S_OK == hr ? L"Succeeded" : L"Failed") ;

    return hr;
#endif  // BUILD_WITH_DRM
}

/// -------------- TEST CODE ---------------------------------------------------

#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST

HRESULT
CDTFilter::RegisterSecureServer(IFilterGraph *pGraph)
{

    if(!(pGraph == NULL || m_pGraph == NULL || m_pGraph == pGraph)) // only allow arg to be passed in when m_pGraph is NULL
        return E_INVALIDARG;                                        //  -- lets us work in JoinFilterGraph().

    HRESULT hr = S_OK;
#ifndef BUILD_WITH_DRM
    TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::RegisterSecureServer - No Drm - not enabled"), m_FilterID) ;
    return S_OK;
#else

    {
                //  Note - Only want to do this once...
        CAutoLock  cLockGlob(m_pCritSectGlobalFilt);

        TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::RegisterSecureServer Being Called"), m_FilterID) ;

        // already registered? (Error?)
        CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph ? m_pGraph : pGraph);
        if (spServiceProvider == NULL) {
     //       TRACE_0 (LOG_AREA_DECRYPTER, 1, _T("CDTFilter:: Can't get service provider interface from the graph"));
            TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::RegisterSecureServer Error - no Service Provider"), m_FilterID) ;
            return E_NOINTERFACE;
        }

        CComPtr<IDRMSecureChannel>  spSecureService;
        hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel,
                                             IID_IDRMSecureChannel,
                                             reinterpret_cast<LPVOID*>(&spSecureService));

        // returns E_NOINTERFACE doesn't find it
        //  humm, perhaps check S_OK result to see if it's the right one
        if(S_OK == hr)
        {
           TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::Found existing Secure Server."),m_FilterID) ;
           return S_OK;

        }
        else                // if it's not there or failed for ANY reason (VidCTL returns E_FAIL when it's site doesn't implement it)
        {                   //   lets create it and register it

            CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph ? m_pGraph : pGraph);
            if(spRegServiceProvider == NULL)
            {
                hr = E_NOINTERFACE;     // no service provider interface on the graph - fatal!
                TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::RegisterSecureServer Error - IRegisterServiceProvider not found"), m_FilterID) ;
            }
            else
            {
                do
                {
                    // Create the Client and Init the keys/certs
                    //
                    CComPtr<IDRMSecureChannel>  spSecureServiceServer;

                    hr = DRMCreateSecureChannel( &spSecureServiceServer);
                    if(spSecureServiceServer == NULL )
                        hr = E_OUTOFMEMORY;

                    if( FAILED (hr) )
                        break;

                    hr = spSecureServiceServer->DRMSC_SetCertificate( (BYTE *)pabCert2, cBytesCert2 );
                    if( FAILED( hr ) )
                        break;

                    hr = spSecureServiceServer->DRMSC_SetPrivateKeyBlob( (BYTE *)pabPVK2, cBytesPVK2 );
                    if( FAILED( hr ) )
                        break;

                    hr = spSecureServiceServer->DRMSC_AddVerificationPubKey( (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot) );
                    if( FAILED( hr ) )
                        break;

                    // RegisterService does not addref pUnkSeekProvider
                    //               hr = pSvcProvider->RegisterService(GUID_MultiGraphHostService, GBL(spSecureServiceServer));
    //                hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, GBL(spSecureServiceServer));
                    hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, spSecureServiceServer);
                   // spSecureServiceServer._PtrClass

                } while (FALSE);
            }
        }
    }

    if(S_OK == hr)
    {
        TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::RegisterSecureServer - Security Warning!: -  Created Self Server"), m_FilterID) ;
    } else {
        TRACE_2(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::RegisterSecureServer - Failed Creating Self SecureServer. hr = 0x%08x"), m_FilterID, hr) ;
    }

    return hr;
#endif      // BUILD_WITH_DRM
}

        // prototype of code to be placed in VidControl to check if DTFilter is trusted
HRESULT
CDTFilter::CheckIfSecureClient(IUnknown *pUnk)
{
    TimeitC ti(&m_tiAuthenticate);

    if(pUnk == NULL)
        return E_INVALIDARG;

#ifndef BUILD_WITH_DRM
    TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::CheckIfSecureClient - No Drm - not enabled"), m_FilterID) ;
    return S_OK;
#else

    TRACE_1(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::CheckIfSecureClient"), m_FilterID) ;

                        // QI for the SecureChannel interface on the Punk (hopefully the DTFilter)
    HRESULT hr = S_OK;

    CComQIPtr<IDRMSecureChannel> spSecureClient(pUnk);
    if (spSecureClient == NULL) {
        TRACE_1 (LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%2):: Passed in pUnk doesnt support IDRMSecureChannel"),m_FilterID);
        return E_NOINTERFACE;
    }

    if(!FAILED(hr))
    {
        // Create the Server side and Init the keys/certs
        //
        CComPtr<IDRMSecureChannel>  spSecureServer;

        hr = DRMCreateSecureChannel( &spSecureServer);
        if(spSecureServer == NULL )
            hr = E_OUTOFMEMORY;

        if(!FAILED(hr))
            hr = spSecureServer->DRMSC_AtomicConnectAndDisconnect(
                (BYTE *)pabCert2, cBytesCert2,                                  // Cert
                (BYTE *)pabPVK2,  cBytesPVK2,                                   // PrivKey
                (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot),     // PubKey
                spSecureClient);

    }

    TRACE_2(LOG_AREA_DECRYPTER, 1, _T("CDTFilter(%d)::CheckIfSecureClient -->%s"),
        m_FilterID, S_OK == hr ? L"Succeeded" : L"Failed") ;
    return hr;
#endif  // BUILD_WITH_DRM
}

#endif      // FILTERS_CAN_CREATE_THEIR_OWN_TRUST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dtfilter\dtfilter.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DTFilter.h

    Abstract:

        This module contains the Encrypter/Tagger filter declarations

    Author:

        John Bradstreet (johnbrad)

    Revision History:

        07-Mar-2002    created

--*/

#ifndef __EncDec__DTFilter_h
#define __EncDec__DTFilter_h


#include <tuner.h>		// needed for IBroadcastEvent
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>	// EVENTID_TuningChanged, XDS_RatingsPacket

#include "DTFilter_res.h"

#include "PackTvRat.h"              // packed TvRating definitions
#include "MediaSampleAttr.h"		// from the IDL file
//#include "MediaAttrib.h"            // IMediaSampleAttrGet/Set definitions, CAttributedMediaSample
#include "..\Attrib\MediaAttrib.h"            // IMediaSampleAttrGet/Set definitions, CAttributedMediaSample
#include "AttrBlock.h"               // attributed block definitions

#include "DRMEncDec.h"             // drm encryption/decryption definitions...

#include "DRMSecure.h"          // IDRMSecureChannel 

#if 1
#include "rateseg.h"    // before integration - I stole the code
#else
#include "dvrutil.h"    // when we eventually integrate
#endif

#define DT_FILTER_NAME      "Decrypt/DeTag"
#define DT_INPIN_NAME		"In(Enc/Tag)"
#define DT_OUTPIN_NAME		"Out"


extern AMOVIESETUP_FILTER   g_sudDTFilter;

		// forward declarations
class CDTFilter;
class CDTFilterInput;
class CDTFilterOutput;

//  --------------------------------------------------------------------
//  class CDTFilterInput
//  --------------------------------------------------------------------

class CDTFilterInput :
   public IKsPropertySet,
     public CBaseInputPin
{
    private:
    CDTFilter *  m_pHostDTFilter ;

    CCritSec                    m_StreamingLock;

    DECLARE_IUNKNOWN;           // needed when have IKsPropertySet

    public :
        
        CDTFilterInput (
            IN  TCHAR *         pszPinName,
            IN  CDTFilter *		pDTFilter,
            IN  CCritSec *      pFilterLock,    // NULL or a passed in lock
            OUT HRESULT *       phr
            ) ;

        ~CDTFilterInput ();;

        
        STDMETHODIMP
            NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;
        
        //  --------------------------------------------------------------------
        //  CBasePin methods
        
        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;
        
        HRESULT
        CompleteConnect (
            IN  IPin *  pIPin
            ) ;
        
        HRESULT
        BreakConnect (
            ) ;



        //  --------------------------------------------------------------------
        //  CBaseInputPin methods
        
        STDMETHODIMP
        Receive (
            IN  IMediaSample * pIMediaSample
            ) ;
        
        STDMETHODIMP
            BeginFlush (
            ) ;
        
        STDMETHODIMP
        EndFlush (
            ) ;

        STDMETHODIMP
        EndOfStream (
            );
        
        //  --------------------------------------------------------------------
        //  IKSPropertySet methods  (Forward all calls to the output pin)
        

       
        STDMETHODIMP
        Set(
            IN REFGUID guidPropSet,
            IN DWORD dwPropID,
            IN LPVOID pInstanceData,
            IN DWORD cbInstanceData,
            IN LPVOID pPropData,
            IN DWORD cbPropData
            );
        
        STDMETHODIMP
        Get(
            IN  REFGUID guidPropSet,
            IN  DWORD dwPropID,
            IN  LPVOID pInstanceData,
            IN  DWORD cbInstanceData,
            OUT LPVOID pPropData,
            IN  DWORD cbPropData,
            OUT DWORD *pcbReturned
            );
        
        STDMETHODIMP
        QuerySupported(
            IN  REFGUID guidPropSet,
            IN  DWORD dwPropID,
            OUT DWORD *pTypeSupport
            );
      
        //  --------------------------------------------------------------------
        //  class methods

        HRESULT
            StreamingLock (
            );

        HRESULT
            StreamingUnlock (
            );
        
        HRESULT
        SetAllocatorProperties (
            IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
            ) ;
        
        HRESULT
        GetRefdConnectionAllocator (
            OUT IMemAllocator **    ppAlloc
            ) ;
} ;

//  --------------------------------------------------------------------
//  class CDTFilterOutput
//  --------------------------------------------------------------------

class CDTFilterOutput :
    public CBaseOutputPin
{
    CDTFilter *  m_pHostDTFilter ;

//    void FilterLock_ ()         { m_pLock -> Lock () ;      }
//    void FilterUnlock_ ()       { m_pLock -> Unlock () ;    }

    public :

        CDTFilterOutput (
            IN  TCHAR *         pszPinName,
            IN  CDTFilter *		pDTFilter,
            IN  CCritSec *      pFilterLock,
            OUT HRESULT *       phr
            ) ;

        ~CDTFilterOutput (
            );


        DECLARE_IUNKNOWN ;
 
        HRESULT
        SendSample (
            IN  IMediaSample *  pIMS
            ) ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;


		//  --------------------------------------------------------------------
        //  CBasePin methods

        HRESULT
        DecideBufferSize (
            IN  IMemAllocator *         pAlloc,
            IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
            ) ;

        HRESULT
        GetMediaType (
            IN  int             iPosition,
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;

        HRESULT
        CompleteConnect (
            IN  IPin *  pIPin
            ) ;

        HRESULT
        BreakConnect (
            ) ;

        HRESULT
        DecideAllocator (
            IN  IMemInputPin *      pPin,
            IN  IMemAllocator **    ppAlloc
            ) ;

        STDMETHOD(Notify) (
            IBaseFilter *pSender,
            Quality q
            );

        // Class methods
/*        HRESULT
            SendLock (
            );

        HRESULT
            SendUnlock (
            );
*/        
        // IKSPropertySet forwarding methods....

        HRESULT
        IsInterfaceOnPinConnectedTo_Supported(
                IN  REFIID          riid
                );

        HRESULT 
        KSPropSetFwd_Set(
                IN  REFGUID         guidPropSet,
                IN  DWORD           dwPropID,
                IN  LPVOID          pInstanceData,
                IN  DWORD           cbInstanceData,
                IN  LPVOID          pPropData,
                IN  DWORD           cbPropData
                );

        HRESULT 
        KSPropSetFwd_Get(
                IN  REFGUID         guidPropSet,
                IN  DWORD           dwPropID,
                IN  LPVOID          pInstanceData,
                IN  DWORD           cbInstanceData,
                OUT LPVOID          pPropData,
                IN  DWORD           cbPropData,
                OUT DWORD           *pcbReturned
                );

        HRESULT
        KSPropSetFwd_QuerySupported(
               IN  REFGUID          guidPropSet,
               IN  DWORD            dwPropID,
               OUT DWORD            *pTypeSupport
               );
} ;

//  --------------------------------------------------------------------
//  class CDTFilter
//  --------------------------------------------------------------------

class CDTFilter :
    public CBaseFilter,             //  dshow base class
    public ISpecifyPropertyPages,
    public IDTFilter,
    public IDTFilterConfig,
    public IBroadcastEvent
{
    friend CDTFilterInput;                  // so input pin can call FlushDropQueue  on BeginFlush()   
    CDTFilterInput  *       m_pInputPin ;
    CDTFilterOutput *       m_pOutputPin ;

    CCritSec                m_CritSecDropQueue;
    CCritSec                m_CritSecAdviseTime;

    BOOL
    CompareConnectionMediaType_ (
        IN  const AM_MEDIA_TYPE *   pmt,
        IN  CBasePin *              pPin
        ) ;

    BOOL
    CheckInputMediaType_ (
        IN  const AM_MEDIA_TYPE *   pmt
        ) ;

    BOOL
    CheckOutputMediaType_ (
        IN  const AM_MEDIA_TYPE *   pmt
        ) ;

    public :

        CDTFilter (
            IN  TCHAR *     pszFilterName,
            IN  IUnknown *  punkControlling,
            IN  REFCLSID    rCLSID,
            OUT HRESULT *   phr
            ) ;

        ~CDTFilter () ;

        static
        CUnknown *
        CreateInstance (
            IN  IUnknown *  punk,
            OUT HRESULT *   phr
            ) ;

        static void CALLBACK            // used to create a global crit sec
        InitInstance (
            IN  BOOL bLoading,
            IN  const CLSID *rclsid
            );

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;


        DECLARE_IUNKNOWN ;
  
		// =====================================================================
		//   Worker Methods
  
				// tell folk we got something...
		HRESULT FireBroadcastEvent(IN const GUID &eventID);

		HRESULT ProposeNewOutputMediaType (
				IN   CMediaType *  pmt,
				OUT  CMediaType *  pmtOut
				);

        HRESULT BindDRMLicense(
                IN LONG         cbKID, 
                IN  BYTE *     pbKID
                );

        HRESULT UnBindDRMLicenses(
                );
		// =====================================================================
		//		IDTFilter

		STDMETHODIMP 
		get_EvalRatObjOK(
			OUT HRESULT *pHrCoCreateRetVal	
			);

        STDMETHOD(GetCurrRating)(
            OUT EnTvRat_System              *pEnSystem, 
            OUT EnTvRat_GenericLevel        *pEnRating,
            OUT LONG                        *plbfEnAttr      //BfEnTvRat_GenericAttributes
            );

        STDMETHOD(get_BlockedRatingAttributes)(
            IN  EnTvRat_System              enSystem, 
            IN  EnTvRat_GenericLevel        enLevel,
            OUT LONG                        *plbfEnAttr // BfEnTvRat_GenericAttributes
            );
        
        STDMETHOD(put_BlockedRatingAttributes)(
            IN  EnTvRat_System              enSystem, 
            IN  EnTvRat_GenericLevel        enLevel,
            IN  LONG                        lbfEnAttrs   // BfEnTvRat_GenericAttributes
            );


        STDMETHOD(get_BlockUnRated)(
             OUT  BOOL				    *pmfBlockUnRatedShows
            );
        
        STDMETHOD(put_BlockUnRated)(
             IN  BOOL				    fBlockUnRatedShows
            );
        
        STDMETHOD(get_BlockUnRatedDelay)(
             OUT  LONG				    *pmsecsDelayBeforeBlock
            );
        
        STDMETHOD(put_BlockUnRatedDelay)(
             IN  LONG				    msecsDelayBeforeBlock
            );


        HRESULT				// helper non interface method - returns S_FALSE if cahgned
        SetCurrRating(
            IN EnTvRat_System           enSystem, 
            IN EnTvRat_GenericLevel     enRating,
            IN LONG 	                lbfEnAttr
            );

        //  ====================================================================
        // IDTFilterConfig
        STDMETHOD(GetSecureChannelObject)(
            OUT IUnknown **ppUnkDRMSecureChannel	// an IDRMSecureChannel 
            )
        {
            if(NULL == ppUnkDRMSecureChannel)
                return E_POINTER;

#ifdef BUILD_WITH_DRM
            *ppUnkDRMSecureChannel = NULL;
            if(m_spDRMSecureChannel == NULL)
                return E_NOINTERFACE;
            return m_spDRMSecureChannel->QueryInterface(IID_IUnknown, (void**)ppUnkDRMSecureChannel);
#else
            return E_NOINTERFACE;       // not supported..
#endif
        }

        //  ====================================================================
        //  CFilterBase virtual methods in base class


        int
        GetPinCount (
            ) ;

        CBasePin *
        GetPin (
            IN  int
            ) ;

        STDMETHOD(JoinFilterGraph) (
            IFilterGraph *pGraph,
            LPCWSTR pName
            );

        STDMETHOD(Stop) (
            ) ;

        STDMETHOD(Pause) (
            ) ;

        STDMETHOD(Run) (
            REFERENCE_TIME tStart
            );


        //  ====================================================================
        //  class methods


        HRESULT
        DeliverBeginFlush (
            ) ;

        HRESULT
        DeliverEndFlush (
            ) ;

        HRESULT
        DeliverEndOfStream(
            );

        BOOL
        CheckDecrypterMediaType (
            IN  PIN_DIRECTION,          //  caller
            IN  const CMediaType *
            ) ;

        HRESULT
        Process (
            IN  IMediaSample *
            ) ;

        HRESULT
        OnCompleteConnect (
            IN  PIN_DIRECTION           //  caller
            ) ;

        HRESULT
        OnBreakConnect (
            IN  PIN_DIRECTION           //  caller
            ) ;

        HRESULT
        UpdateAllocatorProperties (
            IN  ALLOCATOR_PROPERTIES *
            ) ;

        HRESULT
        OnOutputGetMediaType (
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        GetRefdInputAllocator (
            OUT IMemAllocator **
            ) ;

	//  ISpecifyPropertyPages  --------------------------------------------

		STDMETHODIMP 
		GetPages (
			CAUUID * pPages
        ) ;

    // IKSPropertySet forwarding from the input pin to the output pin (or visa versa)

        HRESULT
        IsInterfaceOnPinConnectedTo_Supported(
                IN  PIN_DIRECTION   PinDir,         // either PINDIR_INPUT of PINDIR_OUTPUT
                IN  REFIID          riid
                );

        HRESULT 
        KSPropSetFwd_Set(
                IN  PIN_DIRECTION   PinDir,         
                IN  REFGUID         guidPropSet,
                IN  DWORD           dwPropID,
                IN  LPVOID          pInstanceData,
                IN  DWORD           cbInstanceData,
                IN  LPVOID          pPropData,
                IN  DWORD           cbPropData
                );

        HRESULT 
        KSPropSetFwd_Get(
                IN  PIN_DIRECTION   PinDir,         
                IN  REFGUID         guidPropSet,
                IN  DWORD           dwPropID,
                IN  LPVOID          pInstanceData,
                IN  DWORD           cbInstanceData,
                OUT LPVOID          pPropData,
                IN  DWORD           cbPropData,
                OUT DWORD           *pcbReturned
                );

        HRESULT
        KSPropSetFwd_QuerySupported(
               IN  PIN_DIRECTION    PinDir,         
               IN  REFGUID          guidPropSet,
               IN  DWORD            dwPropID,
               OUT DWORD            *pTypeSupport
               );


	// IBroadcastEvent

        STDMETHOD(Fire)(GUID eventID);     // this comes from the Graph's events - call our own method


 
private:
                    // global filter CritSec    (to keep multiple instances of this filter from colliding)
    static CCritSec             *m_pCritSectGlobalFilt;           // ***always*** inside the FilterLock (m_pLock)

    static LONG                 m_gFilterID;    // used to distinqish instances from each other...
    LONG                        m_FilterID;     // actual one for this filter
                    // graph broadcast events

	HRESULT						HookupGraphEventService();
	HRESULT						UnhookGraphEventService();
	CComPtr<IBroadcastEvent>	m_spBCastEvents;

	HRESULT						RegisterForBroadcastEvents();
	HRESULT						UnRegisterForBroadcastEvents();
	enum {kBadCookie = -1};
	DWORD						m_dwBroadcastEventsCookie;

    BOOL                        m_fFireEvents;          // set to false to avoid firing (duplicate) events 

                    // current rating

	CComPtr<IEvalRat>			m_spEvalRat;
	HRESULT						m_hrEvalRatCoCreateRetValue;

    BOOL                        m_fRatingsValid;    // have they been set yet?
	EnTvRat_System				m_EnSystemCurr; 
	EnTvRat_GenericLevel		m_EnLevelCurr;
	LONG                        m_lbfEnAttrCurr;     // bitfield of BfEnTvRat_GenericAttributes

	
	CComPtr<ITuner>				m_spTuner;			
	//CComQIPtr<IMSVidTuner>		m_spVidTuner;


                // block delay 
    BOOL                        m_fHaltedDelivery;          // halting delivery 
    LONG                        m_milsecsDelayBeforeBlock;  // delay time before blocking in micro-secs
    BOOL                        m_fDoingDelayBeforeBlock;
    BOOL                        m_fRunningInSlowMo;         // set to true to turn of delay in starting the Ratings block
    REFERENCE_TIME              m_refTimeToStartBlock;
    

    BOOL                        m_fForceNoRatBlocks;        // special flag (SUPPORT_REGISTRY_KEY_TO_TURN_OFF_RATINGS) to avoid blocks
    BOOL                        m_fDataFormatHasBeenBad;    // set when get bad data (toggle for ok/failure event pair)
                // 
    LONG                        m_milsecsNoRatingsBeforeUnrated;    // delay time before no ratings count as don't know
    REFERENCE_TIME              m_refTimeFreshRating;       // get ClockTime for last 'fresh' rating

    enum {kMax10kSpeedToCountAsSlowMo = 9001};                 // abs(speed)* 10,000 to count as slow motion for delayed block

    REFERENCE_TIME              m_refTimeLastEvent;
    GUID                        m_lastEventID;
    enum {kMaxMSecsBetweenEvents      = 10*1000};             // max time between ratings events (in 10^-3 secs)
    HRESULT                     PossiblyUpdateBroadcastEvent();

                // media sample attributes

    CAttrSubBlock_List          m_attrSB;

                // DRM
    BOOL                        m_3fDRMLicenseFailure;  // 3 state logic (unitialized, true, and false)
#ifdef BUILD_WITH_DRM 
    CDRMLite                    m_cDRMLite;
    BYTE*                       m_pszKID;               // only used to see if it changed and need to ReBind
    LONG                        m_cbKID;
    CComPtr<IDRMSecureChannel>  m_spDRMSecureChannel; // authenticator...
#endif

    HRESULT                     CheckIfSecureServer(IFilterGraph *pGraph=NULL);      // return S_OK only if trust the server registered in the graph service provider
    HRESULT                     InitializeAsSecureClient();

#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
    HRESULT                     RegisterSecureServer(IFilterGraph *pGraph=NULL);     // return S_OK only if trust the server registered in the graph service provider
    HRESULT                     CheckIfSecureClient(IUnknown *pUnk);                 // prototype for VidControl method to see if it trusts the filter
#endif   
                                                        //  Restarting the upstream delivery
    HRESULT                     OnRestartDelivery(IMediaSample *pSample);

                // Rate Segment
    enum {kMaxRateSegments      = 32};
    enum {kSecsPurgeThreshold   = 5 };
    CTTimestampRate<REFERENCE_TIME>    m_PTSRate ;

                // stopping and flushing
    HRESULT                     DoEndOfStreamDuringDrop();
    BOOL                        m_fCompleteNotified;

                // DropQueue (circular buffer)
    HRESULT                     CreateDropQueueThread();
    HRESULT                     KillDropQueueThread();

    DWORD                       m_dwDropQueueThreadId;              // Thread used to queue up/process dropped packets
    HANDLE                      m_hDropQueueThread;                 // Thread used to queue up/process dropped packets
    HANDLE                      m_hDropQueueThreadAliveEvent;       // Signal from thread that its ready
    HANDLE                      m_hDropQueueThreadDieEvent;         // Signal from thread that its ready
    HANDLE                      m_hDropQueueEmptySemaphore;         // Waited on in DropQueue, inits to zero, goes when non-zero
    HANDLE                      m_hDropQueueFullSemaphore;          // Waited on in Main Thread, inits to N, stops when goes to zero
    HANDLE                      m_hDropQueueAdviseTimeEvent;        // Wait until some time passes

    DWORD                       m_dwDropQueueEventCookie;           // cookie for the TimeEvent
   
                                                        // and a new sample
    HRESULT                     AddSampleToDropQueue(IMediaSample *pSample);
                                                        // add the top sample
    void                        AddMaxSampleToDropQueue(IMediaSample *pSample);
                                                        // remove the bottom sample
    void                        DropMinSampleFromDropQueue();
                                                        // return the oldest version
    IMediaSample *              GetMinDropQueueSample();
                                                        // flush all samples (when pause or stop)
    HRESULT                     FlushDropQueue();
                                                        // drop samples from drop queue
    static void                 DropQueueThreadProc (CDTFilter *pcontext);
    HRESULT                     DropQueueThreadBody();

    enum {kMaxQueuePackets = 10};   // maximum number of packets to queue up
    IMediaSample              * m_rgMedSampDropQueue[kMaxQueuePackets];
    int                         m_cDropQueueMin;        // first sample filled
    int                         m_cDropQueueMax;        // next sample we will fill
  

                // minimal stats
    void                        InitStats()
    {
        CAutoLock   cLock(m_pLock);

        m_cPackets = 0;
        m_clBytesTotal = 0;
        m_cSampsDropped = 0;
        m_cSampsDroppedOverflowed = 0;
        m_cBlockedWhileDroppingASample = 0;
        m_cRestarts++;
    }

    LONG                        m_cPackets;                     // total stamples processed
    LONG64                      m_clBytesTotal;                 // total number of bytes processed
    LONG                        m_cSampsDropped;                // total dropped
    LONG                        m_cBlockedWhileDroppingASample; // total times paused due to DropQueue thread being full
    LONG                        m_cSampsDroppedOverflowed;      // total dropped and didn't time out (should be zero)
    LONG                        m_cRestarts;                    // total number of reinits


    Timeit                      m_tiAuthenticate;   // time in authentication methods
    Timeit                      m_tiProcess;        // total ::process time
    Timeit                      m_tiProcessIn;      // total ::process time minus the final 'SendSample'
    Timeit                      m_tiProcessDRM;     // :process time of just the DRM code
    Timeit                      m_tiRun;            // total run time
    Timeit                      m_tiStartup;        // creating the license and similar startup
    Timeit                      m_tiTeardown;       // closing things down

} ;

#endif  //  __EncDec__DTFilter_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dtfilter\dtfiltprops.cpp ===
//==========================================================================;
//  DTFiltProps.cpp
//
//			Property Sheet for Decrypter/DeTagger Filter
//
// Copyright (c) 2002  Microsoft Corporation.  All Rights Reserved.
//	------------------------------------------------------------------------

#include "EncDecAll.h"
#include "EncDec.h"				//  compiled from From IDL file
#include "DTFilter.h"			
#include "DTFiltProps.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Filter property page code
//
CUnknown * WINAPI 
CDTFilterEncProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDTFilterEncProperties(_T(DT_PROPPAGE_TAG_NAME),
											  lpunk, 
											  phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CDTFilterEncProperties::CDTFilterEncProperties(
			IN  TCHAR		*   pClassName,
			IN	IUnknown	*	pIUnknown, 
			HRESULT			*	phr)
    : CBasePropertyPage(pClassName, 
						pIUnknown,
						IDD_DTFILTER_ENCPROPPAGE, 
						IDS_DTFILTER_ENCPROPNAME
						),
    m_hwnd(NULL),
	m_pIDTFilter(NULL)
{
	ASSERT(phr);
	*phr = S_OK;

/*	INITCOMMONCONTROLSEX icce;					// needs Comctl32.dll
	icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icce.dwICC = ICC_INTERNET_CLASSES;
	BOOL fOK = InitCommonControlsEx(&icce);
	if(!fOK)
		*phr = E_FAIL;
*/
	return;
}

CDTFilterEncProperties::~CDTFilterEncProperties()
{
	return;
}

HRESULT CDTFilterEncProperties::OnConnect(IUnknown *pUnknown) 
{
	ASSERT(!m_pIDTFilter);  // pUnk is to CCCTFilter, not CDShowCCTFilter...
    HRESULT hr = CBasePropertyPage::OnConnect (pUnknown) ;

	if(!FAILED(hr))
		hr = pUnknown->QueryInterface(IID_IDTFilter, (void**) &m_pIDTFilter);

	if(FAILED(hr)) {
		m_pIDTFilter = NULL;
		return hr;
	}
	return S_OK;
}

HRESULT CDTFilterEncProperties::OnDisconnect() 
{
  HRESULT hr = S_OK;
  if (m_pIDTFilter)
	  m_pIDTFilter->Release(); 
   m_pIDTFilter = NULL;

   return CBasePropertyPage::OnDisconnect () ;
}

HRESULT CDTFilterEncProperties::OnActivate(void)
{
   UpdateFields();
   return S_OK;
}

#define _SETBUT(buttonIDC, grfFlag)	SetDlgItemTextW(m_hwnd, (buttonIDC), (lGrfHaltFlags & (grfFlag)) ? L"Stopped" : L"Running");

void CDTFilterEncProperties::UpdateFields() 
{
	if(!m_pIDTFilter) return;		// haven't inited yet....
	

}

HRESULT CDTFilterEncProperties::OnDeactivate(void)
{
    return CBasePropertyPage::OnDeactivate () ;
}


HRESULT CDTFilterEncProperties::OnApplyChanges(void)
{
   return CBasePropertyPage::OnApplyChanges () ;
}


INT_PTR 
CDTFilterEncProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{
    switch (uMsg) {

    case WM_INITDIALOG:
    {
        ASSERT (m_hwnd == NULL) ;
        m_hwnd = hwnd ;
        break;
    }

    //  see ::OnDeactivate()'s comment block
    case WM_DESTROY :
    {
        m_hwnd = NULL ;
        break ;
    }

    case WM_COMMAND:

        if (HIWORD(wParam) == EN_KILLFOCUS) {
//           m_bDirty = TRUE;
 //          if (m_pPageSite)
 //              m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }

/*
		if(LOWORD(wParam) == IDC_COMBO_CCMODE)
		{
			HWND hCBox = GetDlgItem(hwnd, IDC_COMBO_CCMODE);
			if(0 == hCBox)
				break;
			long iItem = SendMessage(hCBox, CB_GETCURSEL, 0, 0);
			long iVal  = SendMessage(hCBox, CB_GETITEMDATA, iItem, 0);
			if(iVal != lgrfCCMode)
			{
				NCCT_Mode cMode = (NCCT_Mode) iVal;
				m_pIDTFilter->put_CCMode(cMode);
			}
		}
*/
    }	// end uMsg switch

   return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

// ---------------------------------------------------------------------------
//
// Tag property page code
//
CUnknown * WINAPI 
CDTFilterTagProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDTFilterTagProperties(_T(DT_PROPPAGE_TAG_NAME),
											  lpunk, 
											  phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CDTFilterTagProperties::CDTFilterTagProperties(
			IN  TCHAR		*   pClassName,
			IN	IUnknown	*	pIUnknown, 
			HRESULT			*	phr)
    : CBasePropertyPage(pClassName, 
						pIUnknown,
						IDD_DTFILTER_TAGSPROPPAGE, 
						IDS_DTFILTER_TAGSPROPNAME
						),
    m_hwnd(NULL),
	m_pIDTFilter(NULL)
{
    TRACE_CONSTRUCTOR (TEXT ("CDTFilterTagProperties")) ;
	
	ASSERT(phr);
	*phr = S_OK;

/*	INITCOMMONCONTROLSEX icce;					// needs Comctl32.dll
	icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icce.dwICC = ICC_INTERNET_CLASSES;
	BOOL fOK = InitCommonControlsEx(&icce);
	if(!fOK)
		*phr = E_FAIL;
*/
	return;
}


CDTFilterTagProperties::~CDTFilterTagProperties()
{
	return;
}

HRESULT CDTFilterTagProperties::OnConnect(IUnknown *pUnknown) 
{
	ASSERT(!m_pIDTFilter);
	HRESULT hr = pUnknown->QueryInterface(IID_IDTFilter, (void**) &m_pIDTFilter);
	if (FAILED(hr)) {
		m_pIDTFilter = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CDTFilterTagProperties::OnDisconnect() 
{
	if (!m_pIDTFilter)
      return E_UNEXPECTED;
   m_pIDTFilter->Release(); 
   m_pIDTFilter = NULL;
   return S_OK;
}

HRESULT CDTFilterTagProperties::OnActivate(void)
{
   UpdateFields();
   return S_OK;
}

void CDTFilterTagProperties::UpdateFields() 
{
	HRESULT hr=S_OK;
	

	if(!m_pIDTFilter)
		return;
/*

	CComBSTR bstrFakeStats;
	hr = m_pIDTFilter->GetStats(&bstrFakeStats);		// hacky way to send a fixed length string
	if(FAILED(hr))
		return;

	if(NULL == bstrFakeStats.m_str)
		return;

	CCTStats *pcctStats = (CCTStats *) bstrFakeStats.m_str;

	SetDlgItemInt(m_hwnd, IDC_TS_CB0,					pcctStats->m_cbData[0],	true);
	SetDlgItemInt(m_hwnd, IDC_TS_CB1,					pcctStats->m_cbData[1],	true);

*/
}

HRESULT CDTFilterTagProperties::OnDeactivate(void)
{
	return S_OK;
}


HRESULT CDTFilterTagProperties::OnApplyChanges(void)
{
	return S_OK;
}


INT_PTR CDTFilterTagProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{
	HRESULT hr = S_OK;

    switch (uMsg) {
    case WM_INITDIALOG:
    {
        ASSERT (m_hwnd == NULL) ;
        m_hwnd = hwnd ;
        const UINT uWait = 1000;
        SetTimer(m_Dlg, 1, uWait, NULL);
        break;
    }

    //  see ::OnDeactivate()'s comment block
    case WM_DESTROY :
    {
        m_hwnd = NULL;
        KillTimer(m_Dlg, 1);
        break ;
    }

    case WM_TIMER:
    {
        UpdateFields();
        break;
    }

    case WM_COMMAND:
	{
        if (HIWORD(wParam) == EN_KILLFOCUS) {
		}

/*		if(LOWORD(wParam) == IDC_ETTAGS_RESET)
		{

			if(!m_pIDTFilter)
				break;

			try {
				hr = m_pIDTFilter->InitStats();		// set them all to zero...
			}
			catch(const _com_error& e)
			{
			//	printf("Error 0x%08x): %s\n", e.Error(), e.ErrorMessage());
				hr = e.Error();
			}

			if(!FAILED(hr))
				UpdateFields();
		}
*/
		break;
	}

	default:
		break;

	}
	return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dtfilter\dtfiltprops.h ===
// ---------------------------------------------------------------
// DTFILTProps.h
//
// ---------------------------------------------------------------


#ifndef __DTFILTPROPS_H__
#define __DTFILTPROPS_H__

#define DT_PROPPAGE_ENC_NAME "DecrypterX"
#define DT_PROPPAGE_TAG_NAME "TagsX"

// ----------------------------------
//  forward declarations
// ----------------------------------

class CDTFilterEncProperties;
class CDTFilterTagProperties;

// ----------------------------------
// ----------------------------------

	


class CDTFilterEncProperties : 
	public CBasePropertyPage 
{
 
public:
   CDTFilterEncProperties(IN  TCHAR		*pClassName,
							IN  IUnknown	*lpUnk, 
							OUT HRESULT		*phr);
	~CDTFilterEncProperties();


    HRESULT
    OnActivate (
        ) ;

    HRESULT
    OnApplyChanges (
        ) ;

    HRESULT
    OnConnect (
        IN  IUnknown *  pIUnknown
        ) ;

    HRESULT
    OnDeactivate (
        ) ;

    HRESULT
    OnDisconnect (
        ) ;

    INT_PTR
    OnReceiveMessage (
        IN  HWND    hwnd,
        IN  UINT    uMsg,
        IN  WPARAM  wParam,
        IN  LPARAM  lParam
            ) ;

	DECLARE_IUNKNOWN ;

    static
    CUnknown *
    WINAPI
    CreateInstance (
        IN  IUnknown *  pIUnknown,
        IN  HRESULT *   pHr
        ) ;

private:
   void UpdateFields();

   IDTFilter		*m_pIDTFilter;
   HWND				m_hwnd ;
};
	
				// ---------------------------


class CDTFilterTagProperties : 
	public CBasePropertyPage 
{
 
public:
   CDTFilterTagProperties(IN  TCHAR		*pClassName,
							IN  IUnknown	*lpUnk, 
							OUT HRESULT		*phr);
	~CDTFilterTagProperties();


    HRESULT
    OnActivate (
        ) ;

    HRESULT
    OnApplyChanges (
        ) ;

    HRESULT
    OnConnect (
        IN  IUnknown *  pIUnknown
        ) ;

    HRESULT
    OnDeactivate (
        ) ;

    HRESULT
    OnDisconnect (
        ) ;

    INT_PTR
    OnReceiveMessage (
        IN  HWND    hwnd,
        IN  UINT    uMsg,
        IN  WPARAM  wParam,
        IN  LPARAM  lParam
            ) ;

	DECLARE_IUNKNOWN ;

    static
    CUnknown *
    WINAPI
    CreateInstance (
        IN  IUnknown *  pIUnknown,
        IN  HRESULT *   pHr
        ) ;

private:
   void UpdateFields();

   IDTFilter		*m_pIDTFilter;
   HWND				m_hwnd ;

};

#endif //__DTFILTPROPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\etfilter\etfilter.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        ETFilter.h

    Abstract:

        This module contains the Encrypter/Tagger filter declarations

    Author:

        John Bradstreet (johnbrad)

    Revision History:

        07-Mar-2002    created

--*/

#ifndef __EncDec__ETFilter_h
#define __EncDec__ETFilter_h


// #define DOING_REAL_ENCRYPTION        // UnComment in real release


#include <tuner.h>		// needed for IBroadcastEvent
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>	// EVENTID_TuningChanged, XDS_RatingsPacket
#include "ETFilter_res.h"

#include "PackTvRat.h"              // packed TvRating definitions
#include "MediaSampleAttr.h"		// from the IDL file
//#include "MediaAttrib.h"            // IMediaSampleAttrGet/Set definitions, CAttributedMediaSample
#include "..\Attrib\MediaAttrib.h"            // IMediaSampleAttrGet/Set definitions, CAttributedMediaSample
#include "AttrBlock.h"               // attributed block definitions

#include "DRMEncDec.h"                    // drm encryption definitions...

#include "DRMSecure.h"          // IDRMSecureChannel 

#define ET_FILTER_NAME      "Encrypt/Tag"
#define ET_INPIN_NAME		"In"
#define ET_OUTPIN_NAME		"Out(Enc/Tag)"


extern AMOVIESETUP_FILTER   g_sudETFilter;

		// forward declarations
class CETFilter;
class CETFilterInput;
class CETFilterOutput;

//  --------------------------------------------------------------------
//  class CETFilterInput
//  --------------------------------------------------------------------

class CETFilterInput :
    public CBaseInputPin
{
    CETFilter *  m_pHostETFilter ;

    CCritSec                    m_StreamingLock;

    
//    void FilterLock_ ()         { m_pLock -> Lock () ;      }
//    void FilterUnlock_ ()       { m_pLock -> Unlock () ;    }

    public :

        CETFilterInput (
            IN  TCHAR *         pszPinName,
            IN  CETFilter *		pETFilter,
            IN  CCritSec *      pFilterLock,
            OUT HRESULT *       phr
            ) ;
        
        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  --------------------------------------------------------------------
        //  CBasePin methods
        
        HRESULT
            CheckMediaType (
            IN  const CMediaType *
            ) ;
        
        HRESULT
            CompleteConnect (
            IN  IPin *  pIPin
            ) ;
        
        HRESULT
            BreakConnect (
            ) ;
        
        //  --------------------------------------------------------------------
        //  CBaseInputPin methods
        
        STDMETHODIMP
            Receive (
            IN  IMediaSample * pIMediaSample
            ) ;
        
        STDMETHODIMP
            BeginFlush (
            ) ;
        
        STDMETHODIMP
            EndFlush (
            ) ;
        
        STDMETHODIMP
            EndOfStream (
            ) ;
        //  --------------------------------------------------------------------
        //  class methods
        
        HRESULT
            StreamingLock (
            );

        HRESULT
            StreamingUnlock (
            );

        HRESULT
            SetAllocatorProperties (
            IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
            ) ;
        
        HRESULT
            GetRefdConnectionAllocator (
            OUT IMemAllocator **    ppAlloc
            ) ;

        HRESULT
            QueryInterface_OnInputPin(			// queries pin input pin is connected to for a particular interface
            IN  REFIID          riid,
            OUT LPVOID*			ppvObject
            );

} ;


//  --------------------------------------------------------------------
//  class CETFilterOutput
//  --------------------------------------------------------------------

class CETFilterOutput :
    public CBaseOutputPin       // CBaseInputPin
{
private:
    CETFilter		*m_pHostETFilter ;

//    void FilterLock_ ()         { m_pLock -> Lock () ;      }
//    void FilterUnlock_ ()       { m_pLock -> Unlock () ;    }

    public :

        CETFilterOutput (
            IN  TCHAR *         pszPinName,
            IN  CETFilter *		pETFilter,
            IN  CCritSec *      pFilterLock,
            OUT HRESULT *       phr
            ) ;
        
        ~CETFilterOutput ();
        
        DECLARE_IUNKNOWN;
        
        HRESULT
            SendSample (
            IN  IMediaSample *  pIMS
            ) ;
        
        STDMETHODIMP
            NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;
        
        
        //  --------------------------------------------------------------------
        //  CBasePin methods
        
        HRESULT
            DecideBufferSize (
            IN  IMemAllocator *         pAlloc,
            IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
            ) ;
        
        HRESULT
            GetMediaType (
            IN  int             iPosition,
            OUT CMediaType *    pmt
            ) ;
        
        HRESULT
            CheckMediaType (
            IN  const CMediaType *
            ) ;
        
        HRESULT
            CompleteConnect (
            IN  IPin *  pIPin
            ) ;
        
        HRESULT
            BreakConnect (
            ) ;
        
        HRESULT 
            InitAllocator(
            OUT IMemAllocator **ppAlloc
            ) ;
                
        HRESULT
            DecideAllocator (
            IN  IMemInputPin *      pPin,
            IN  IMemAllocator **    ppAlloc
            ) ;

        HRESULT
            QueryInterface_OnOutputPin(			// queries pin output pin is connected to for a particular interface
            IN  REFIID          riid,
            OUT LPVOID*			ppvObject
            );
};

//  --------------------------------------------------------------------
//  class CETFilter
//  --------------------------------------------------------------------

class CETFilter :
    public CBaseFilter,             //  dshow base class
    public ISpecifyPropertyPages,
    public IETFilter,
    public IETFilterConfig,
    public IBroadcastEvent
{
    CETFilterInput  *		 m_pInputPin ;
    CETFilterOutput *		m_pOutputPin ;
        
//    void Lock_ ()           { m_pLock -> Lock () ;      } // use CAutoLock
//    void Unlock_ ()         { m_pLock -> Unlock () ;    }
    
    BOOL
        CompareConnectionMediaType_ (
        IN  const AM_MEDIA_TYPE *   pmt,
        IN  CBasePin *              pPin
        ) ;
    
    BOOL
        CheckInputMediaType_ (
        IN  const AM_MEDIA_TYPE *   pmt
        ) ;
    
    BOOL
        CheckOutputMediaType_ (
        IN  const AM_MEDIA_TYPE *   pmt
        ) ;
        
public :
    
    CETFilter (
        IN  TCHAR *     pszFilterName,
        IN  IUnknown *  punkControlling,
        IN  REFCLSID    rCLSID,
        OUT HRESULT *   phr
        ) ;
    
    ~CETFilter () ;
    
    static
        CUnknown *
        CreateInstance (
        IN  IUnknown *  punk,
        OUT HRESULT *   phr
        ) ;

    static void CALLBACK            // used to create a global crit sec
        InitInstance (
        IN  BOOL bLoading,
        IN  const CLSID *rclsid
        );
    
    
    STDMETHODIMP
        NonDelegatingQueryInterface (
        IN  REFIID  riid,
        OUT void ** ppv
        ) ;
    
    
    DECLARE_IUNKNOWN ;
    
    // =====================================================================
    //   Worker Methods
    
private:
    HRESULT	LocateXDSCodec();		// fills spXDSFilter
    
    // tell folk we got something...
    HRESULT FireBroadcastEvent(IN const GUID &eventID);
    

    // create license that encrypts true license, ecrypted by the BaseKID
    HRESULT CreateHashStruct(BSTR bsBaseKID, DWORD *pcBytes, BYTE **ppbHashStruct);

    // pull the true license KID out of the encrypted hash struct...
    HRESULT DecodeHashStruct(BSTR bsBaseKID, DWORD cBytesHash, BYTE *pbHashStruct, 
                             BYTE **ppszTrueKID, LONG *pAgeSeconds);
    // =====================================================================
    //		IETFilterConfig 
public:    
    STDMETHOD(InitLicense)(
        IN int	LicenseId	// which license (0-N to use) - LicenseID not used yet, should be zero
        );

    STDMETHOD(CheckLicense)( // check if KID is a valid DRM license for this machine
        BSTR bsKID
        );

    STDMETHOD(ReleaseLicenses)(
        ); 
    

        //  ====================================================================
        // IDTFilterConfig
    STDMETHOD(GetSecureChannelObject)(
        OUT IUnknown **ppUnkDRMSecureChannel	// an IDRMSecureChannel 
        )
    {
        if(NULL == ppUnkDRMSecureChannel)
            return E_POINTER;
        
#ifdef BUILD_WITH_DRM
        *ppUnkDRMSecureChannel = NULL;
        if(m_spDRMSecureChannel == NULL)
            return E_NOINTERFACE;
        return m_spDRMSecureChannel->QueryInterface(IID_IUnknown, (void**)ppUnkDRMSecureChannel);
#else
        return E_NOINTERFACE;       // not supported..
#endif
    }

    // =====================================================================
    //		IETFilter
    
    STDMETHOD(get_EvalRatObjOK)(
        OUT HRESULT *pHrCoCreateRetVal	
        );
    
    STDMETHOD(GetCurrRating)(
        OUT EnTvRat_System              *pEnSystem, 
        OUT EnTvRat_GenericLevel        *pEnLevel,
        OUT LONG                       	*plbfEnAttr  // bitfield of BfEnTvRat_GenericAttributes
        );

private:    
    HRESULT				// helper non interface methods
        SetRating(
        IN EnTvRat_System               enSystem, 
        IN EnTvRat_GenericLevel         enLevel,
        IN LONG                         lbfEnAttr,
        IN LONG                         pktSeqID,
        IN LONG                         callSeqID,
        IN REFERENCE_TIME               timeStart,
        IN REFERENCE_TIME               timeEnd
    );

    HRESULT
        RefreshRating(
        IN BOOL                          fRefresh
        )
    {
        m_fRatingIsFresh = fRefresh;
        return S_OK;
    }

   HRESULT
       GetRating(
        IN  REFERENCE_TIME              timeStart,      // if 0, get latest
        IN  REFERENCE_TIME              timeEnd,
        OUT EnTvRat_System              *pEnSystem, 
        OUT EnTvRat_GenericLevel        *pEnLevel,
        OUT LONG                       	*plbfEnAttr,     // bitfield of BfEnTvRat_GenericAttributes
        OUT LONG                        *pPktSeqID,
        OUT LONG                        *pCallSeqID
        );

public:
   STDMETHOD(QueryInterfaceOnPin)(
       IN  PIN_DIRECTION   PinDir,         // either PINDIR_INPUT of PINDIR_OUTPUT
       IN  REFIID          riid,
       OUT LPVOID*			ppvObject
       )
   { 
       if(PinDir == PINDIR_OUTPUT)
           return m_pOutputPin->QueryInterface_OnOutputPin(riid, ppvObject);
       else if (PinDir == PINDIR_INPUT)
           return m_pInputPin->QueryInterface_OnInputPin(riid, ppvObject);
       else
           return E_INVALIDARG;
       
   }
    //  ====================================================================
    //  pure virtual methods in base class
    
public:
    int
        GetPinCount (
        ) ;
    
    CBasePin *
        GetPin (
        IN  int
        ) ;

    STDMETHOD(JoinFilterGraph) (
        IFilterGraph *pGraph,
        LPCWSTR pName
        );

    
    STDMETHOD(Stop) (
        ) ;

    STDMETHOD(Pause) (
        ) ;
    
    STDMETHOD(Run) (
        REFERENCE_TIME tStart
        ) ;
    //  ====================================================================
    //  class methods
    
    HRESULT
        DeliverBeginFlush (
        ) ;
    
    HRESULT
        DeliverEndFlush (
        ) ;
    
    HRESULT
        DeliverEndOfStream (
        ) ;

    BOOL
        CheckEncrypterMediaType (
        IN  PIN_DIRECTION,          //  caller
        IN  const CMediaType *
        ) ;
    
    HRESULT
        ProposeNewOutputMediaType (	// like above, but sets new subtype
        IN  CMediaType *pmtIn,
        OUT  CMediaType *pmtOut 
        ) ;
    
    HRESULT
        Process (
        IN  IMediaSample *
        ) ;
    
    HRESULT
        OnCompleteConnect (
        IN  PIN_DIRECTION           //  caller
        ) ;
    
    HRESULT
        OnBreakConnect (
        IN  PIN_DIRECTION           //  caller
        ) ;
    
  
    HRESULT
        OnOutputGetMediaType (
        OUT CMediaType *    pmt
        ) ;
    
    
    HRESULT
        UpdateAllocatorProperties (
        IN  ALLOCATOR_PROPERTIES *
        ) ;

    HRESULT
        GetRefdInputAllocator (
        OUT IMemAllocator **
        ) ;
    
    
    //  ISpecifyPropertyPages  --------------------------------------------
    
    STDMETHODIMP 
        GetPages (
        CAUUID * pPages
        ) ;
    
    // IBroadcastEvent
    
    STDMETHOD(Fire)(IN GUID eventID);     // this comes from the Graph's events - call our own method
    
    
    
private:
                    // global filter CritSec    (to keep multiple instances of this filter from colliding)
    static CCritSec             *m_pCritSectGlobalFilt;       // ***always*** inside the FilterLock (m_pLock)

    static LONG                 m_gFilterID;    // used to distinqish instances from each other...
    LONG                        m_FilterID;     // actual one for this filter

                    // graph broadcast evetns
    HRESULT                     HookupGraphEventService();
    HRESULT                     UnhookGraphEventService();
    CComPtr<IBroadcastEvent>	m_spBCastEvents;
    
    HRESULT                     RegisterForBroadcastEvents();
    HRESULT                     UnRegisterForBroadcastEvents();
    enum {kBadCookie = -1};
    DWORD                       m_dwBroadcastEventsCookie;
    
    CComPtr<ITuner>				m_spTuner;
    //CComQIPtr<IMSVidTuner>		m_spVidTuner;
    
				// keeping track of the current ratings
    CComPtr<IEvalRat>           m_spEvalRat;
    HRESULT                 	m_hrEvalRatCoCreateRetValue;
     
    LONG                        m_callSeqIDCurr;
    LONG                        m_pktSeqIDCurr;

    enum {kMaxRats = 10};                           // keep N around to handle clock skew
    EnTvRat_System              m_EnSystemCurr;		
    EnTvRat_GenericLevel        m_EnLevelCurr;
    LONG                        m_lbfEnAttrCurr;    // BfEnTvRat_GenericAttributes
    
    REFERENCE_TIME              m_timeStartCurr;
    REFERENCE_TIME              m_timeEndCurr;

    BOOL                        m_fRatingIsFresh;

    CComPtr<IXDSCodec>          m_spXDSCodec;
    
				// broadcast event handlers
    HRESULT	DoTuneChanged();
    HRESULT	DoXDSRatings();
    HRESULT	DoDuplicateXDSRatings();
    HRESULT	DoXDSPacket();
    
				// Pin format conversion
    GUID                        m_guidSubtypeOriginal;

                // AttrBlock 
    CAttrSubBlock_List          m_attrSB;

    // TODO - obfuscate this
    Encryption_Method           m_enEncryptionMethod;   
	BOOL						m_fIsCC;		        // is this CC data we're working on?
    // todo - end obfuscation

                // DRM
#ifdef BUILD_WITH_DRM 
    LONG                        m_3fDRMLicenseFailure;   // 3-state logic (uninitialized, true, and false)
    CDRMLite                    m_cDRMLite;
    BYTE*                       m_pbKID;

    CComPtr<IDRMSecureChannel>  m_spDRMSecureChannel; // authenticator...
#endif


    HRESULT                     CheckIfSecureServer(IFilterGraph *pGraph=NULL);      // return S_OK only if trust the server registered in the graph service provider
    HRESULT                     InitializeAsSecureClient();

#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
    HRESULT                     RegisterSecureServer(IFilterGraph *pGraph=NULL);                         // return S_OK only if trust the server registered in the graph service provider
    HRESULT                     CheckIfSecureClient(IUnknown *pUnk);                 // prototype for VidControl method to see if it trusts the filter
#endif    

    HRESULT                     CheckIfOEMAllowsConfigurableDRMSystem();

                // Stats
    DWORD                       m_cRestarts;
    LONG64                      m_clBytesTotal;
    LONG                        m_cPackets;
    LONG                        m_cPacketsOK;
    LONG                        m_cPacketsFailure;
    LONG                        m_cPacketsShort;
    LONG64                      m_clBytesShort;
    void    InitStats()
    {
            m_cPackets = m_cPacketsOK = m_cPacketsFailure = m_cPacketsShort = 0;
            m_clBytesTotal = m_clBytesShort = 0;
            m_cRestarts++;
    }

    Timeit                      m_tiAuthenticate;   // total time spent authenticating
    Timeit                      m_tiProcess;        // total ::process time
    Timeit                      m_tiProcessIn;      // total ::process time minus the final 'SendSample'
    Timeit                      m_tiProcessDRM;     // total ::process time minus the final 'SendSample'
    Timeit                      m_tiRun;            // total run time
    Timeit                      m_tiStartup;        // creating the license and similar startup
    Timeit                      m_tiTeardown;       // closing things down

} ;

#endif  //  __EncDec__ETFilter_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\etfilter\etfilter.cpp ===
/*++

    Copyright (c) 2002 Microsoft Corporation

    Module Name:

        ETFilter.cpp

    Abstract:

        This module contains the Encrypter/Tagger filter code.

    Author:

        J.Bradstreet (johnbrad)

    Revision History:

        07-Mar-2002    created

--*/

#include "EncDecAll.h"
#include "EncDec.h"             //  compiled from From IDL file



//#include "ETFilterutil.h"
#include "ETFilter.h"

#include "DRMSecure.h"
#include "PackTvRat.h"          // for display
#include "RegKey.h"             // getting and setting EncDec registry values

#include <shlwapi.h>
#include <sfc.h>

//  #if (_WIN32_IE < 0x0500)

#include <shlobj.h>

#include <msi.h>                // MsiGetFileSignatureInformation

#ifdef EHOME_WMI_INSTRUMENTATION
#include <dxmperf.h>
#endif

#include "obfus.h"

/*
#ifdef _MSI_NO_CRYPTO
#pragma message( L"_MSI_NO_CRYPTO defined" )
#pragma warning("fail here");
#else
#pragma message( L"_MSI_NO_CRYPTO not defined" )
#pragma warning("fail there");
#endif

#pragma warning( _WIN32_MSI _WIN32_WINNT)
#if (_WIN32_MSI >= 150)
#pragma warning("This is good")
#else
#pragma warning("This is bad")
#endif
*/

//#include "DVRAnalysis.h"      // for IID_IDVRAnalysisConfig
//#include "DVRAnalysis_i.c"        //   to get the CLSID's defined (bad form here?)



#define INITGUID
#include <guiddef.h>

DEFINE_GUID(IID_IDVRAnalysisConfig,
0x09dc9fef, 0x97ad, 0x4cab, 0x82, 0x52, 0x96, 0x83, 0xbc, 0x87, 0x78, 0xf2);

//  disable so we can use 'this' in the initializer list
#pragma warning (disable:4355)


#ifdef DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//  ============================================================================

//  ============================================================================
AMOVIESETUP_FILTER
g_sudETFilter = {
    & CLSID_ETFilter,
    _TEXT(ET_FILTER_NAME),
    MERIT_DO_NOT_USE,
    0,                          //  0 pins registered
    NULL
} ;

// ====================================================
CCritSec* CETFilter::m_pCritSectGlobalFilt = NULL;
LONG CETFilter::m_gFilterID = 0;

void CALLBACK
CETFilter::InitInstance (                       // this is a global method, only called once per DLL loading
    IN  BOOL bLoading,
    IN  const CLSID *rclsid
    )
{
    if( bLoading ) {
        m_pCritSectGlobalFilt = new CCritSec;
    } else {
        if( m_pCritSectGlobalFilt  )
        {
           delete m_pCritSectGlobalFilt;         // DeleteCriticalSection(&m_CritSectGlobalFilt);
           m_pCritSectGlobalFilt = NULL;
        }
    }
}

//  ============================================================================
CUnknown *
WINAPI
CETFilter::CreateInstance (
    IN  IUnknown *  punkControlling,
    OUT  HRESULT *   phr
    )
{
    CETFilter *    pCETFilter ;

    if(m_pCritSectGlobalFilt == NULL ) // if didn't create
    {
        *phr = E_FAIL;
        return NULL;
    }


    if (true /*::CheckOS ()*/) {
        pCETFilter = new CETFilter (
                                TEXT(ET_FILTER_NAME),
                                punkControlling,
                                CLSID_ETFilter,
                                phr
                                ) ;
        if (!pCETFilter ||
            FAILED (* phr)) {

            (* phr) = (FAILED (* phr) ? (* phr) : E_OUTOFMEMORY) ;
            delete pCETFilter; pCETFilter=NULL;
        }
    }
    else {
        //  wrong OS
        pCETFilter = NULL ;
    }

    return pCETFilter ;
}

//  --------------------------------------------------------------------
//  class CETFilterInput
//  --------------------------------------------------------------------

CETFilterInput::CETFilterInput (
    IN  TCHAR *         pszPinName,
    IN  CETFilter *  pETFilter,
    IN  CCritSec *      pFilterLock,
    OUT HRESULT *       phr
    ) : CBaseInputPin       (NAME ("CETFilterInput"),
                             pETFilter,
                             pFilterLock,
                             phr,
                             pszPinName
                             ),
    m_pHostETFilter   (pETFilter)
{
    TRACE_CONSTRUCTOR (TEXT ("CETFilterInput")) ;

    if(NULL == m_pLock)
    {
        *phr = E_OUTOFMEMORY;
    }
}

STDMETHODIMP
CETFilterInput::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  ------------------------------------------------------------------------
    //  IETFilterConfig; allows the filter to be configured...

    if (riid == IID_IDVRAnalysisConfig)         // forward this QI accoss the filter
    {
        return m_pHostETFilter->QueryInterfaceOnPin(PINDIR_OUTPUT, riid, ppv);
    }

    return CBaseInputPin::NonDelegatingQueryInterface (riid, ppv) ;
}


HRESULT
CETFilterInput::QueryInterface_OnInputPin(          // queries pin input pin is connected to for a particular interface
                IN  REFIID          riid,
                OUT LPVOID*         ppvObject
            )
{
    if(NULL == m_Connected)
        return E_NOINTERFACE;       // not connected yet

    return m_Connected->QueryInterface(riid, ppvObject);
}

HRESULT
CETFilterInput::StreamingLock ()      // always grab the PinLock before the Filter lock...
{
    m_StreamingLock.Lock();
    return S_OK;
}

HRESULT
CETFilterInput::StreamingUnlock ()
{
    m_StreamingLock.Unlock();
    return S_OK;
}


HRESULT
CETFilterInput::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    BOOL    f ;
    ASSERT(m_pHostETFilter);


    f = m_pHostETFilter -> CheckEncrypterMediaType (m_dir, pmt) ;


    return (f ? S_OK : S_FALSE) ;
}

HRESULT
CETFilterInput::CompleteConnect (
    IN  IPin *  pIPin
    )
{
    HRESULT hr ;

    hr = CBaseInputPin::CompleteConnect (pIPin) ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostETFilter -> OnCompleteConnect (m_dir) ;
    }

    return hr ;
}

HRESULT
CETFilterInput::BreakConnect (
    )
{
    HRESULT hr ;

    TRACE_0(LOG_AREA_ENCRYPTER, 4, _T("CETFilterInput::OnBreakConnect")) ;

    hr = CBaseInputPin::BreakConnect () ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostETFilter -> OnBreakConnect (m_dir) ;
    }

    return hr ;
}

// --------------------------------------------------------------
// ---------------------------------------------------------------

STDMETHODIMP
CETFilterInput::Receive (
    IN  IMediaSample * pIMediaSample
    )
{
    HRESULT hr ;

    {
        CAutoLock  cLock(&m_StreamingLock);       // Grab the streaming lock here!

#ifdef EHOME_WMI_INSTRUMENTATION
        PERFLOG_STREAMTRACE( 1, PERFINFO_STREAMTRACE_ENCDEC_ETFILTERINPUT,
            0, 0, 0, 0, 0 );
#endif
        hr = CBaseInputPin::Receive (pIMediaSample) ;

        if (S_OK == hr)             // Will get S_FALSE if above if flushing...
        {
            hr = m_pHostETFilter -> Process (pIMediaSample) ;
            ASSERT(!FAILED(hr));        // extra panoia...
        }
    }

    return hr ;
}

HRESULT
CETFilterInput::SetAllocatorProperties (
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    HRESULT hr ;

    if (IsConnected ()) {
        ASSERT (m_pAllocator) ;
        hr = m_pAllocator -> GetProperties (ppropInputRequest) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}


HRESULT
CETFilterInput::GetRefdConnectionAllocator (
    OUT IMemAllocator **    ppAlloc
    )
{
    HRESULT hr ;

    if (m_pAllocator) {
        (* ppAlloc) = m_pAllocator ;
        (* ppAlloc) -> AddRef () ;

        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}


STDMETHODIMP
CETFilterInput::BeginFlush (
    )
{
    HRESULT hr ;

    CAutoLock  cLock(m_pLock);           // grab the filter lock..

  // First, make sure the Receive method will fail from now on.
    hr = CBaseInputPin::BeginFlush () ;
    if( FAILED( hr ) )
    {
        return hr;
    }

    // Force downstream filters to release samples. If our Receive method
    // is blocked in GetBuffer or Deliver, this will unblock it.
    hr = m_pHostETFilter->DeliverBeginFlush () ;
    if( FAILED( hr ) ) {
        return hr;
    }

    // At this point, the Receive method can't be blocked. Make sure
    // it finishes, by taking the streaming lock. (Not necessary if this
    // is the last step.)
    {
        CAutoLock  cLock2(&m_StreamingLock);
    }

    return hr ;
}

STDMETHODIMP
CETFilterInput::EndFlush (
    )
{
    HRESULT hr ;

    CAutoLock  cLock(m_pLock);      // grab the filter lock

        // The EndFlush method will signal to the filter that it can
        // start receiving samples again.

    hr = m_pHostETFilter -> DeliverEndFlush () ;
    ASSERT(!FAILED(hr));

        // The CBaseInputPin::EndFlush method resets the m_bFlushing flag to FALSE,
        // which allows the Receive method to start receiving samples again.
        // This should be the last step in EndFlush, because the pin must not receive any
        // samples until flushing is complete and all downstream filters are notified.

    hr = CBaseInputPin::EndFlush () ;

    return hr ;
}

STDMETHODIMP
CETFilterInput::EndOfStream (
    )
{
    // When the input pin receives an end-of-stream notification, it propagates the call
    // downstream. Any downstream filters that receive data from this input pin should
    // also get the end-of-stream notification. Again, take the streaming lock and not
    // the filter lock. If the filter has pending data that was not yet delivered, the
    // filter should deliver it now, before it sends the end-of-stream notification.
    // It should not send any data after the end of the stream.

    CAutoLock  cLock(&m_StreamingLock);

    HRESULT hr = CheckStreaming();
    if( S_OK != hr ) {
        return hr;
    }

    hr = m_pHostETFilter->DeliverEndOfStream();
    if( S_OK != hr ) {
        return hr;
    }

    return S_OK;
}

//  ============================================================================

CETFilterOutput::CETFilterOutput (
    IN  TCHAR *         pszPinName,
    IN  CETFilter *  pETFilter,
    IN  CCritSec *      pFilterLock,
    OUT HRESULT *       phr
    ) : CBaseOutputPin      (NAME ("CETFilterOutput"),
                             pETFilter,
                             pFilterLock,
                             phr,
                             pszPinName
                             ),
    m_pHostETFilter   (pETFilter)
{
    TRACE_CONSTRUCTOR (TEXT ("CETFilterOutput")) ;
}

CETFilterOutput::~CETFilterOutput ()
{
    if(m_pAllocator) m_pAllocator->Release();
    m_pAllocator = NULL;
}

STDMETHODIMP
CETFilterOutput::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IDVRAnalysisConfig)         // forward this QI accoss the filter
    {
        return m_pHostETFilter->QueryInterfaceOnPin(PINDIR_INPUT, riid, ppv);
    }

    return CBaseOutputPin::NonDelegatingQueryInterface (riid, ppv) ;
}



HRESULT
CETFilterOutput::QueryInterface_OnOutputPin(            // queries pin input pin is connected to for a particular interface
                IN  REFIID          riid,
                OUT LPVOID*         ppvObject
            )
{
    if(NULL == m_pInputPin)     // input pin is one this output pin is connected too
        return E_NOINTERFACE;       // not connected yet

    return m_pInputPin->QueryInterface(riid, ppvObject);

}
HRESULT
CETFilterOutput::GetMediaType (
    IN  int             iPosition,
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

     hr = m_pHostETFilter -> OnOutputGetMediaType (pmt) ;

    return hr ;
}

HRESULT
CETFilterOutput::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    BOOL    f ;

    ASSERT(m_pHostETFilter);

     f = m_pHostETFilter -> CheckEncrypterMediaType (m_dir, pmt) ;

    return (f ? S_OK : S_FALSE) ;
}

HRESULT
CETFilterOutput::CompleteConnect (
    IN  IPin *  pIPin
    )
{
    HRESULT hr ;

    hr = CBaseOutputPin::CompleteConnect (pIPin) ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostETFilter -> OnCompleteConnect (m_dir) ;
    }

    return hr ;
}

HRESULT
CETFilterOutput::BreakConnect (
    )
{
    HRESULT hr ;

    hr = CBaseOutputPin::BreakConnect () ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostETFilter -> OnBreakConnect (m_dir) ;
    }

    return hr ;
}

HRESULT
CETFilterOutput::  SendSample  (
    OUT  IMediaSample *  pIMS
    )
{
    HRESULT hr ;

    ASSERT (pIMS) ;

#ifdef EHOME_WMI_INSTRUMENTATION
    PERFLOG_STREAMTRACE( 1, PERFINFO_STREAMTRACE_ENCDEC_ETFILTEROUTPUT,
        0, 0, 0, 0, 0 );
#endif
    hr = Deliver (pIMS) ;

    return hr ;
}

// ----------------------------------------
//  allocator stuff

HRESULT
CETFilterOutput::InitAllocator(
            OUT IMemAllocator **ppAlloc
            )
{
    if(NULL == ppAlloc)
        return E_POINTER;

    ASSERT(m_pAllocator == NULL);
    HRESULT hr;

    m_pAllocator = (IMemAllocator *) CAMSAllocator::CreateInstance(NULL, &hr);
//  m_pAllocator = (IMemAllocator *) new CAMSAllocator(L"IETFilterAllocator",NULL,&hr);

    if(NULL == m_pAllocator)
        return E_OUTOFMEMORY;
    if(FAILED(hr))
        return hr;

    *ppAlloc = m_pAllocator;
    return S_OK;
}


HRESULT
CETFilterOutput::DecideBufferSize (
    IN  IMemAllocator *         pAlloc,
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    HRESULT hr ;

    hr = m_pHostETFilter -> UpdateAllocatorProperties (
            ppropInputRequest
            ) ;

    return hr ;
}


HRESULT
CETFilterOutput::DecideAllocator (          // TODO - change this!
    IN  IMemInputPin *      pPin,
    IN  IMemAllocator **    ppAlloc
    )
{
    HRESULT hr ;

    hr = m_pHostETFilter -> GetRefdInputAllocator (ppAlloc) ;
    if (SUCCEEDED (hr)) {
        //  input pin must be connected i.e. have an allocator; preserve
        //   all properties and pass them through to the output
        hr = pPin -> NotifyAllocator ((* ppAlloc), FALSE) ;
    }

    return hr ;
}


//  ============================================================================

CETFilter::CETFilter (
    IN  TCHAR *     pszFilterName,
    IN  IUnknown *  punkControlling,
    IN  REFCLSID    rCLSID,
    OUT HRESULT *   phr
    ) : CBaseFilter             (pszFilterName,
                                 punkControlling,
                                 new CCritSec,
                                 rCLSID
                                ),
        m_pInputPin                 (NULL),
        m_pOutputPin                (NULL),
        m_dwBroadcastEventsCookie   (kBadCookie),   // I think 0 may be a valid Cookie
        m_EnSystemCurr              (TvRat_SystemDontKnow), // better inits?
        m_EnLevelCurr               (TvRat_LevelDontKnow),
        m_lbfEnAttrCurr             (BfAttrNone),
        m_fRatingIsFresh            (false),
        m_pktSeqIDCurr              (-1),
        m_callSeqIDCurr             (-1),
        m_timeStartCurr             (0),
        m_timeEndCurr               (0),
        m_hrEvalRatCoCreateRetValue (CLASS_E_CLASSNOTAVAILABLE),
        m_guidSubtypeOriginal       (GUID_NULL),
#ifdef BUILD_WITH_DRM
        m_3fDRMLicenseFailure       (-2),           // 3 state logic, init to non-true and non-false.  False is less verbose on startup
        m_pbKID                     (NULL),
#endif
        m_enEncryptionMethod         (Encrypt_XOR_DogFood),
        m_cRestarts                 (0)
//        m_enEncryptionMethod         (Encrypt_None)

{
    TRACE_CONSTRUCTOR (TEXT ("CETFilter")) ;

    m_tiStartup.Restart();
    m_tiTeardown.Restart();

    if (!m_pLock) {
        (* phr) = E_OUTOFMEMORY ;
        goto cleanup ;
    }

    InitStats();
    m_cRestarts = 0;        // initStats inc's this to 1, reset back...

    m_FilterID = m_gFilterID;               // should I protect these two line of code? not really necessary..
    InterlockedIncrement(&m_gFilterID);

    m_pInputPin = new CETFilterInput (
                        TEXT (ET_INPIN_NAME),
                        this,
                        m_pLock,
                        phr
                        ) ;
    if (!m_pInputPin ||
        FAILED (* phr)) {

        (* phr) = (m_pInputPin ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    m_pOutputPin = new CETFilterOutput (
                        TEXT (ET_OUTPIN_NAME),
                        this,
                        m_pLock,
                        phr
                        ) ;
    if (!m_pOutputPin ||
        FAILED (* phr)) {

        (* phr) = (m_pOutputPin ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

            // CoCreate the ratings evaluator...
    try {
        m_hrEvalRatCoCreateRetValue =
            CoCreateInstance(CLSID_EvalRat,         // CLSID
                             NULL,                  // pUnkOut
                             CLSCTX_INPROC_SERVER,
                             IID_IEvalRat,          // riid
                             (LPVOID *) &m_spEvalRat);

    } catch (HRESULT hr) {
        m_hrEvalRatCoCreateRetValue = hr;
    }

    TRACE_2(LOG_AREA_ENCRYPTER, 2, _T("CETFilter(%d)::CoCreate EvalRat object - hr = 0x%08x"),
        m_FilterID, m_hrEvalRatCoCreateRetValue) ;


//  HRESULT hr = RegisterForBroadcastEvents();  // don't really care if fail here,  try in Connect if haven't

           // setup Authenticator (DRM secure channel object)
    if(SUCCEEDED(*phr))
        *phr = InitializeAsSecureClient();


    //  success
    ASSERT (SUCCEEDED (* phr)) ;
    ASSERT (m_pInputPin) ;
    ASSERT (m_pOutputPin) ;

    m_tiStartup.Stop();
cleanup :

    return ;
}

CETFilter::~CETFilter (
    )
{
            // need to do UnHook while have a valid graph pointer, this is too late
//  UnRegisterForBroadcastEvents();
//  UnhookGraphEventService();
#ifdef BUILD_WITH_DRM
    if(m_pbKID)        CoTaskMemFree(m_pbKID);
#endif

    InterlockedDecrement(&m_gFilterID);

    delete m_pInputPin ;    m_pInputPin = NULL;
    delete m_pOutputPin ;   m_pOutputPin = NULL;
    delete m_pLock;         m_pLock = NULL;
}

STDMETHODIMP
CETFilter::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{

        // IETFilter :allows the filter to be configured...
    if (riid == IID_IETFilter) {

        return GetInterface (
                    (IETFilter *) this,
                    ppv
                    ) ;

        // IETFilterConfig :allows the filter to be configured...
   } else if (riid == IID_IETFilterConfig) {    
        return GetInterface (
                    (IETFilterConfig *) this,
                    ppv
                    ) ;

        // ISpecifyPropertyPages: allows an app to enumerate property pages
    } else if (riid == IID_ISpecifyPropertyPages) {

        return GetInterface (
                    (ISpecifyPropertyPages *) this,
                    ppv
                    ) ;

        // IBroadcastEvents: allows the filter to receive events broadcast
        //                   from XDS and Tuner filters
    } else if (riid == IID_IBroadcastEvent) {

        return GetInterface (
                    (IBroadcastEvent *) this,
                    ppv
                    ) ;

    }

    return CBaseFilter::NonDelegatingQueryInterface (riid, ppv) ;
}

int
CETFilter::GetPinCount ( )
{
    int i ;

    //  don't show the output pin if the input pin is not connected
    i = (m_pInputPin -> IsConnected () ? 2 : 1) ;

    //i = 2;        // show it

    return i ;
}

CBasePin *
CETFilter::GetPin (
    IN  int iIndex
    )
{
    CBasePin *  pPin ;

    if (iIndex == 0) {
        pPin = m_pInputPin ;
    }
    else if (iIndex == 1) { // don't show if not connected
        pPin = (m_pInputPin -> IsConnected () ? m_pOutputPin : NULL) ;
 //       pPin = m_pOutputPin;
    }
    else {
        pPin = NULL ;
    }


    return pPin ;
}

            // ----------------------------------

BOOL
CETFilter::CompareConnectionMediaType_ (
    IN  const AM_MEDIA_TYPE *   pmt,
    IN  CBasePin *              pPin
    )
{
    BOOL        f ;
    HRESULT     hr ;
    CMediaType  cmtOriginal ;

    ASSERT (pPin -> IsConnected ()) ;

        // This method called from the output pin, suggesting possible input formats
        //  We only want to use one, (the orginal media type modified to have our new minor type on it).
        // However. for now, we'll also allow the true original media typ eon it...

        // input pin's media type
    hr = pPin -> ConnectionMediaType (&cmtOriginal) ;
    if (SUCCEEDED (hr)) {
        CMediaType  cmtProposed;
        hr = ProposeNewOutputMediaType(&cmtOriginal,  &cmtProposed);        // strip format envelope off
        if(S_OK != hr)
            return false;

        CMediaType  cmtCompare = (* pmt);
        if( cmtProposed == cmtCompare

#ifdef DONT_CHANGE_EDTFILTER_MEDIATYPE
            || cmtOriginal == cmtCompare            // TODO - remove this line
#endif
            )
            f = true;
        else
            f = false;
    } else {
        f = false;
    }


    return f ;
}

BOOL
CETFilter::CheckInputMediaType_ (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    BOOL    f = true;
    HRESULT hr = S_OK;

#ifndef DONT_CHANGE_EDTFILTER_MEDIATYPE
            // don't allow data coming from another ETFilter upstream
            // (problem current that Propose method doesn't nest format blocks,
            //  nor will tagging support two types.  Could fix, but why?)
    f =  !(IsEqualGUID( pmt->subtype,    MEDIASUBTYPE_ETDTFilter_Tagged));
#else
    f = true;
#endif

    // tells us if this is 'CC data, cause we may want to do something special for it
    m_fIsCC = IsEqualGUID( pmt->majortype, MEDIATYPE_AUXLine21Data);

    return f ;
}

BOOL
CETFilter::CheckOutputMediaType_ (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    BOOL    f = true ;
    HRESULT hr ;

    if (m_pInputPin -> IsConnected ()) {
        f = CompareConnectionMediaType_ (pmt, m_pInputPin) ;
    }
    else {
        f = FALSE ;
    }


    return f ;
}

BOOL
CETFilter::CheckEncrypterMediaType (
    IN  PIN_DIRECTION       PinDir,
    IN  const CMediaType *  pmt
    )
{
    BOOL    f ;

    if (PinDir == PINDIR_INPUT) {
        f = CheckInputMediaType_ (pmt) ;
    }
    else
    {
        ASSERT (PinDir == PINDIR_OUTPUT) ;
        f = CheckOutputMediaType_ (pmt) ;       // is it something we like?
    }

    return f ;
}


HRESULT
CETFilter::ProposeNewOutputMediaType (
    IN  CMediaType  * pmt,
    OUT  CMediaType * pmtOut
    )
{
    HRESULT hr = S_OK;

    if(NULL == pmtOut)
        return E_POINTER;

    CMediaType mtOut(*pmt); // does a deep copy
    if(NULL == pmtOut)
        return E_OUTOFMEMORY;

#ifndef DONT_CHANGE_EDTFILTER_MEDIATYPE     // pull when Matthijs gets MediaSDK changes done
    
            // discover all sorts of interesing info about the current type
    const GUID *pGuidSubtypeOrig    = pmt->Subtype();
    const GUID *pGuidFormatOrig     = pmt->FormatType();
    int  cbFormatOrig               = pmt->FormatLength();

            // create a new format block, concatenating
            //    1) original format block  2) the original subtype 3) original format type
    int cbFormatNew = cbFormatOrig + 2 * sizeof(GUID);
    BYTE *pFormatNew = new BYTE[cbFormatNew];
    if(NULL == pFormatNew)
        return E_OUTOFMEMORY;

    BYTE *pb = pFormatNew;
    memcpy(pb, (void *) pmt->Format(),    cbFormatOrig);  pb += cbFormatOrig;
    memcpy(pb, (void *) pGuidSubtypeOrig, sizeof(GUID));  pb += sizeof(GUID);
    memcpy(pb, (void *) pGuidFormatOrig,  sizeof(GUID));  pb += sizeof(GUID);

            // now override the data
    mtOut.SetSubtype(   &MEDIASUBTYPE_ETDTFilter_Tagged );
    mtOut.SetFormatType(&FORMATTYPE_ETDTFilter_Tagged);
    mtOut.SetFormat(pFormatNew, cbFormatNew);

    delete [] pFormatNew;       // SetFormat realloc's the data for us..

    TRACE_0(LOG_AREA_ENCRYPTER, 5, _T("CETFilter::ProposeNewOutputMediaType")) ;

#endif

    *pmtOut = mtOut;

    return hr;
}

        // -----------------------------------

STDMETHODIMP
CETFilter::Pause (
    )
{
    HRESULT                 hr ;
    ALLOCATOR_PROPERTIES    AllocProp ;

    O_TRACE_ENTER_0 (TEXT("CETFilter::Pause ()")) ;

    CAutoLock  cLock(m_pLock);      // grab the filter lock

    int start_state = m_State;

    if (start_state == State_Stopped)
    {
        m_tiRun.Clear();
        m_tiTeardown.Clear();
        m_tiProcess.Clear();
        m_tiProcessIn.Clear();
        m_tiProcessDRM.Clear();
        m_tiStartup.Clear();
        m_tiAuthenticate.Clear();

        m_tiRun.Start();

        TRACE_1(LOG_AREA_DECRYPTER, 2,L"CETFilter(%d):: Stop -> Pause", m_FilterID);
        InitStats();

        try{
//DECRYPT_DATA(111,1,1)
            hr = InitLicense(0);     // create our license (run state is too late)
//ENCRYPT_DATA(111,1,1)
        } catch (...) {
            hr = E_FAIL;
        }
                                            // what do we do if it fails?  
        if(FAILED(hr))
            return hr;

        hr = CBaseFilter::Pause () ;


    } else {
        m_tiRun.Stop();
        TRACE_0(LOG_AREA_ENCRYPTER, 2,L"CETFilter:: Run -> Pause");

        hr = CBaseFilter::Pause () ;

        TRACE_5(LOG_AREA_TIME, 3, L"CETFilter(%d):: Stats: %d samples, %gK total bytes (Avg Bytes/Packet %d)  (%d rejects)",
            m_FilterID, m_cPackets, double(m_clBytesTotal/1024.0), long(m_clBytesTotal / max(1, m_cPackets)), m_cPacketsFailure);

        if(m_cPacketsShort > 0)
            TRACE_4(LOG_AREA_TIME, 3, L"                      %d short samples, %gK total bytes (Avg Bytes/Short Packet %d)",
                m_cPacketsShort, double(m_clBytesShort/1024.0), long(m_clBytesShort / max(1, m_cPacketsShort)), m_cPacketsShort);

        if(m_tiRun.TotalTime() > 0.0)
        {
            TRACE_1(LOG_AREA_TIME, 3, L"               Total time:  Run          %8.4f (secs)",
                                    m_tiRun.TotalTime());
            TRACE_1(LOG_AREA_TIME, 3, L"               Total time:  Authenticate %8.4f (secs)",
                                    m_tiAuthenticate.TotalTime());
            TRACE_1(LOG_AREA_TIME, 3, L"               Total time:  Startup      %8.4f (secs)",
                                    m_tiStartup.TotalTime());
            TRACE_2(LOG_AREA_TIME, 3, L"               Total time:  Full Process %8.4f (secs) Percentage of Run %8.2f%%",
                                    m_tiProcess.TotalTime(),
                                    100.0 * m_tiProcess.TotalTime() / m_tiRun.TotalTime());
            TRACE_2(LOG_AREA_TIME, 3, L"               Total time:  In Process   %8.4f (secs) Percentage of Run %8.2f%%",
                                    m_tiProcessIn.TotalTime(),
                                    100.0 * m_tiProcessIn.TotalTime() / m_tiRun.TotalTime());
            TRACE_2(LOG_AREA_TIME, 3, L"               Total time:  DRM Process  %8.4f (secs) Percentage of Run %8.2f%%",
                                    m_tiProcessDRM.TotalTime(),
                                    100.0 * m_tiProcessDRM.TotalTime() / m_tiRun.TotalTime());
        }
        hr = S_OK ;


    }

    return hr ;
}

STDMETHODIMP
CETFilter::Stop (
    )
{
    HRESULT hr = S_OK;

    O_TRACE_ENTER_0 (TEXT("CETFilter::Stop ()")) ;

    TRACE_1(LOG_AREA_ENCRYPTER, 2,L"CETFilter(%d):: Stop", m_FilterID);
    hr = CBaseFilter::Stop() ;


    // Make sure the streaming thread has returned from IMemInputPin::Receive(), IPin::EndOfStream() and
    // IPin::NewSegment() before returning,
    m_pInputPin->StreamingLock();
    m_pInputPin->StreamingUnlock();

    ReleaseLicenses();       // release any we are holding (if we can)

    return hr;
}


STDMETHODIMP
CETFilter::Run (
    REFERENCE_TIME tStart
    )
{
    HRESULT                 hr ;
    O_TRACE_ENTER_0 (TEXT("CETFilter::Run ()")) ;

    CAutoLock  cLock(m_pLock);      // grab the filter lock

    hr = CBaseFilter::Run (tStart) ;
    TRACE_1(LOG_AREA_ENCRYPTER, 2,L"CETFilter(%d):: Run", m_FilterID);

    return hr ;
}




HRESULT
CETFilter::Process (
    IN  IMediaSample *  pIMediaSample
    )
{
    HRESULT hr = S_OK;

    TimeitC ti(&m_tiProcess);           // simple use of destructor to stop our clock
    TimeitC tc(&m_tiProcessIn);       // simple use of destructor to stop our clock

    CAttributedMediaSample *pAMS = NULL;    // we'll have to create our own
    BOOL fOKToSendOnData = true;

    {
        // BEGIN OBFUSCATION

                // has someone attributed this sample already?
        CComQIPtr<IAttributeSet>   spAttrSet(pIMediaSample);

                    // if not, create one of ours, and wrap the original one
        if(spAttrSet == NULL)
        {
            CComPtr<IMemAllocator> spAllocator;
            hr = m_pInputPin->GetAllocator(&spAllocator);
            if(FAILED(hr))
                return hr;
            CBaseAllocator *pAllocator = (CBaseAllocator *) spAllocator.p;

            pAMS = new CAttributedMediaSample(L"ETFilter", pAllocator, &hr, NULL, 0);
            if(FAILED(hr))
                return hr;
            if(NULL == pAMS)
                return E_OUTOFMEMORY;

            pAMS->AddRef();              // new returns with refcount of 0;
            pAMS->Wrap(pIMediaSample);

            spAttrSet = pAMS;              // do the QI
        } else {
          //  pIMediaSample->AddRef();        // Question --- do I need to do this?
        }

        Encryption_Method encryptionMethod = m_enEncryptionMethod;


        BYTE *pBuffer;
        LONG cbBuffer;
        cbBuffer = pIMediaSample->GetActualDataLength();
        hr = pIMediaSample->GetPointer(&pBuffer);

        EncDec_PackedV1Data pv1;        // << NJB


        if(!FAILED(hr) && cbBuffer > 0)
        {


#ifdef BUILD_WITH_DRM
                                   // we don't want to DRM encrypt
                                    //  really short (<= 16?) packets - security and efficency problem
                                    // should really only happen with CC packets
            if(encryptionMethod == Encrypt_DRMv1 &&
                cbBuffer < kMinPacketSizeForDRMEncrypt)
            {
                encryptionMethod = Encrypt_None;
                m_cPacketsShort++;
                m_clBytesShort += cbBuffer;
            }
#endif


//#define DO_SUBBLOCK_TEST                // 2nd arg not being used, could use as a continuity counter...
#ifdef DO_SUBBLOCK_TEST    // add more code here to test validity of blocks... (continuity counters, stats, header/trailer)
//          m_attrSB.Replace(SubBlock_Test1, cbBuffer , min(64, cbBuffer), pBuffer);   // note, subblock can't be longer that about 100 bytes or so..., else SBE dies
#endif

//#define DO_SUBBLOCK_TEST2                // 2nd arg not being used, use as a continuity counter...
#ifdef DO_SUBBLOCK_TEST2    // add more code here to test validity of blocks... (continuity counters, stats, header/trailer)
            Test2_SubBlock sb2;
            sb2.m_cSampleID = m_cPackets;
            sb2.m_cSampleSize = cbBuffer;
            sb2.m_dwFirstDataWord = pBuffer[0];
//            pBuffer[0] = sb2.m_cSampleID;           // swap in the Sample ID to be complex

            m_attrSB.Replace(SubBlock_Test2, sb2.m_cSampleID , sizeof(sb2),(BYTE *) &sb2);   // note, subblock can't be longer that about 100 bytes or so..., else SBE dies
#endif



            // now encrypt the data buffer
            switch(encryptionMethod)
            {
#ifdef ALLOW_NON_DRM_ENCRYPTION
//            default:                      // if none set (or DRM set but not supporting it), do something to make things slightly annoying
            case Encrypt_None:               // no encryption
                break;
            case Encrypt_XOR_Even:
                {
                    DWORD *pdwB = (DWORD *) pBuffer;
                    for(int i = 0; i < cbBuffer / 4; i++)
                    {
                        *pdwB = *pdwB ^ 0xF0F0F0F0;
                        pdwB++;
                    }
                }
                break;
            case Encrypt_XOR_Odd:
                {
                    DWORD *pdwB = (DWORD *) pBuffer;
                    for(int i = 0; i < cbBuffer / 4; i++)
                    {
                        *pdwB = *pdwB ^ 0x0F0F0F0F;
                        pdwB++;
                    }
                }
                break;
#ifndef BUILD_WITH_DRM                                          // if not valid, default to DogFood encrption
           default:
                 encryptionMethod = Encrypt_XOR_DogFood;        // so decrypter understands it...
#endif
            case Encrypt_XOR_DogFood:
                {

#define DO_SUBBLOCK_TEST                // 2nd arg not being used, use as a continuity counter...
#ifdef DO_SUBBLOCK_TEST    // add more code here to test validity of blocks... (continuity counters, stats, header/trailer)
//                    m_attrSB.Replace(SubBlock_Test1, cbBuffer , min(32, cbBuffer), pBuffer);   // note, subblock can't be longer that about 100 bytes or so..., else SBE dies
#endif
                    DWORD *pdwB = (DWORD *) pBuffer;
                    for(int i = 0; i < cbBuffer / 4; i++)
                    {
                        *pdwB = *pdwB ^ 0xD006F00D;
                        pdwB++;
                    }
                }
                break;
#endif      // ALLOW_NON_DRM_ENCRYTPION

#ifdef BUILD_WITH_DRM
            default:                                            // if not valid, default to DRMv1 encrption
                 encryptionMethod = Encrypt_DRMv1;              // so decrypter understands it...
            case Encrypt_DRMv1:
                {
                    fOKToSendOnData = false;        // not OK unless we can encrypt it
                    ASSERT(m_3fDRMLicenseFailure == FALSE);     // forgot to init or license failure

                    if(m_3fDRMLicenseFailure == FALSE)
                    {
                         TimeitC tc2(&m_tiProcessDRM);       // simple use of destructor to stop our clock

                         hr = m_cDRMLite.EncryptIndirectFast((char *) m_pbKID, cbBuffer, pBuffer );


                        if(!FAILED(hr))
                            fOKToSendOnData = true;
                    }
                                                            // +1 below, don't foget the trailing 0

                   // int i = strlen((char*) m_pbKID)+1;

                   // hr = m_attrSB.Replace(SubBlock_DRM_KID, 0, KIDLEN, (BYTE*) m_pbKID);
                   // ASSERT(!FAILED(hr));
                    memcpy(pv1.m_KID, m_pbKID, KIDLEN);
                    pv1.m_KID[KIDLEN] = 0;              // paranoia termination

                }
#endif  // BUILD_WITH_DRM

            }
        }   // end valid data tests

            // add some attributes describing what we are doing
        BOOL fChanged = false;
    //    hr = m_attrSB.Replace(SubBlock_EncryptMethod, encryptionMethod);
    //    ASSERT(!FAILED(hr));
        pv1.m_EncryptionMethod = encryptionMethod;


                // whats the rating for this sample..
        EnTvRat_System              enSystem;
        EnTvRat_GenericLevel        enLevel;
        LONG                        lbfEnAttr;
        REFERENCE_TIME              timeStart;
        REFERENCE_TIME              timeEnd;
        LONG                        PktSeq;
        LONG                        CallSeq;

                // for video, hrTime is 0x80040249. timeStart is 0, timeEnd last good time, 90% of the time
        HRESULT hrTime = pIMediaSample->GetTime(&timeStart, &timeEnd);
        if(S_OK == hrTime)
            GetRating(timeStart, timeEnd, &enSystem, &enLevel, &lbfEnAttr, &PktSeq, &CallSeq);
        else
            GetCurrRating(&enSystem, &enLevel, &lbfEnAttr);


        PackedTvRating TvRat;
        PackTvRating(enSystem, enLevel, lbfEnAttr, &TvRat);

        StoredTvRating sRating;
        sRating.m_dwFlags           = 0 ;           // extra space for expansion...
        sRating.m_PackedRating      = TvRat;
        sRating.m_cPacketSeqID      = m_pktSeqIDCurr;
        sRating.m_cCallSeqID        = m_callSeqIDCurr;

        if(m_fRatingIsFresh)
        {
            sRating.m_dwFlags |= StoredTVRat_Fresh;
            m_fRatingIsFresh = false;                   // untoggle this - it's reset on next rating (dup or new)
        }

        ASSERT(sizeof(LONG) == sizeof(PackedTvRating)); // just in case it changes
        //hr = m_attrSB.Replace(SubBlock_PackedRating, kStoredTvRating_Version, sizeof(StoredTvRating),(BYTE *) &sRating);
        memcpy(&(pv1.m_StoredTvRating), &sRating, sizeof(StoredTvRating));



        ASSERT(!FAILED(hr));

        if(Encrypt_DRMv1 != encryptionMethod)
        {
         //    hr = m_attrSB.Delete(SubBlock_DRM_KID);
            memset(pv1.m_KID, 0, KIDLEN);
        }

                // --------------- new code --------------------------
        hr = m_attrSB.Replace(SubBlock_PackedV1Data, 0, sizeof(EncDec_PackedV1Data), (BYTE *) &pv1);
                 // ---------------  end new code --------------------------

        // convert list of attributes to one big block
        CComBSTR spbsBlock;
        hr = m_attrSB.GetAsOneBlock(&spbsBlock);
        ASSERT(!FAILED(hr));

            // save it out
        spAttrSet->SetAttrib(ATTRID_ENCDEC_BLOCK,
                             (BYTE*) spbsBlock.m_str,
                             (spbsBlock.Length()+1)* sizeof(WCHAR));

            // END OBFUSCATION

     }  // end of top block

     m_tiProcessIn.Stop();

     m_cPackets++;
     if(fOKToSendOnData)
     {
        m_cPacketsOK++;

        TRACE_4(LOG_AREA_ENCRYPTER, 6, _T("CETFilter(%d)::Sending %spacket %d (%d bytes)"),
            m_FilterID,
            pAMS ? _T("AMS ") : _T(""),
            m_cPackets,
            pAMS ? pAMS->GetActualDataLength() : pIMediaSample->GetActualDataLength()) ;

                // finally, send it to the downstream file
        if(pAMS == NULL)
        {
            m_pOutputPin->SendSample(pIMediaSample);    // send the original one
            m_clBytesTotal += pIMediaSample->GetActualDataLength();
        }
        else
        {
           m_pOutputPin->SendSample(pAMS);              // send our new one
           m_clBytesTotal += pAMS->GetActualDataLength();
           pAMS->Release();
        }
     } else {
        TRACE_4(LOG_AREA_ENCRYPTER, 6, _T("CETFilter(%d)::Can't encrypt %spacket %d (%d bytes) - tossing it "),
            m_FilterID,
            pAMS ? _T("AMS ") : _T(""),
            m_cPackets,
            pAMS ? pAMS->GetSize() : pIMediaSample->GetActualDataLength()) ;

        m_cPacketsFailure++;
        if(pAMS == NULL)                   // caution, this could spin senders out of control
            pIMediaSample->Release();      //  do we need to queue and release on time?
        else
            pAMS->Release();
     }

    return hr ;
}




HRESULT
CETFilter::OnCompleteConnect (
    IN  PIN_DIRECTION   PinDir
    )
{
    HRESULT hr;

    if (PinDir == PINDIR_INPUT) {
        //  time to display the output pin
        IncrementPinVersion () ;

        if(kBadCookie == m_dwBroadcastEventsCookie)
        {
            hr = RegisterForBroadcastEvents();  // shouldn't fail here, but could be in a non-vid control graph

    //        hr = InitLicense(0);             // init once just to see if we can do it
            if(FAILED(hr))                      // this makes graph building way slow...
            {
                // TODO: what do we do?
                ASSERT(false);
            }

            hr = ReleaseLicenses();          // release here, put them back in the Go method

        }

        hr = LocateXDSCodec();  // ok if fail here, we'll get it when we run
    }

    return S_OK ;
}

HRESULT
CETFilter::OnBreakConnect (
    IN  PIN_DIRECTION   PinDir
    )
{
    HRESULT hr ;

    if (PinDir == PINDIR_INPUT)
    {

        TRACE_1(LOG_AREA_ENCRYPTER, 4, _T("CETFilter(%d)::OnBreakConnect"), m_FilterID) ;

        if (m_pOutputPin -> IsConnected ()) {
            m_pOutputPin -> GetConnected () -> Disconnect () ;
            m_pOutputPin -> Disconnect () ;

            IncrementPinVersion () ;
        }

        if(kBadCookie != m_dwBroadcastEventsCookie)     // this test is quick optimization... done in UnReg too
            UnRegisterForBroadcastEvents();

        UnhookGraphEventService();      // need to do here, destructor too late since need a graph pointer

        m_spXDSCodec = false;       // release our reference in case it changes
    }


    return S_OK ;
}


// -------------------------------------------
//  allocator stuff
//      passes everything to the upstream pin


HRESULT
CETFilter::UpdateAllocatorProperties (
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    HRESULT hr ;

    if (m_pInputPin -> IsConnected ()) {
         hr = m_pInputPin -> SetAllocatorProperties (ppropInputRequest) ;
    }
    else {
        hr = S_OK ;
    }

    return hr ;
}


HRESULT
CETFilter::GetRefdInputAllocator (
    OUT IMemAllocator **    ppAlloc
    )
{
    HRESULT hr ;

    hr = m_pInputPin -> GetRefdConnectionAllocator (ppAlloc) ;

    return hr ;
}

// ------------------------------------------------
// ------------------------------------------------

                // temporaray TimeBomb...
#ifdef INSERT_TIMEBOMB
static HRESULT TimeBomb()
{
     SYSTEMTIME sysTimeNow, sysTimeBomb;
     GetLocalTime(&sysTimeNow);


     sysTimeBomb.wYear  = 2002;
     sysTimeBomb.wMonth = TIMEBOMBMONTH;
     sysTimeBomb.wDay   = TIMEBOMBDATE;
     sysTimeBomb.wHour  = 12;

     TRACE_3(LOG_AREA_DECRYPTER, 3,L"CETFilter:: TimeBomb set to Noon on %d/%d/%d",
         TIMEBOMBMONTH, TIMEBOMBDATE, sysTimeBomb.wYear );

     long hNow  = ((sysTimeNow.wYear*12 + sysTimeNow.wMonth)*31 + sysTimeNow.wDay)*24 + sysTimeNow.wHour;
     long hBomb = ((sysTimeBomb.wYear*12 + sysTimeBomb.wMonth)*31 + sysTimeBomb.wDay)*24 + sysTimeBomb.wHour;
     if(hNow > hBomb)
     {
         TRACE_0(LOG_AREA_DECRYPTER, 1,L"CDTFilter:: Your Encrypter Filter is out of date - Time to get a new one");
         MessageBox(NULL,L"Your Encrypter/Tagger Filter is out of date\nTime to get a new one", L"Stale Encrypter Filter", MB_OK);
         return E_INVALIDARG;
     }
     else
         return S_OK;
}
#endif


// --------------------------------------------
// --------------------------------------------
        // returns S_OK if OEM allows DRM to be turned off
        //    else it returns S_FALSE or an error method
        // Note - need to obfuscate this method...

        // Note - this code not done.....  Need far more work...

/*
#ifdef DO_OEM_BIOS_CODE

#define DEF_OEM_FILENAME (L"CatRoot\\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\\nt5.cat")
#define E_FILE_NOT_PROTECTED    S_FALSE

HRESULT
CETFilter::CheckIfOEMAllowsConfigurableDRMSystem()
{
    HRESULT hr = S_OK;

    USES_CONVERSION;
    // 1) locate the oembios.xxx file

    WCHAR szPath[MAX_PATH];

        // this version not defined in NT - need _WIN32_IE > 0x500
        //    currently defined to be 0x400
//     hr = SHGetFolderPath(NULL,               // hwndOner
//                        CSIDL_SYSTEM,       // CSIDL
//                        NULL,               // htoken
//                        SHGFP_TYPE_CURRENT, // dwFlags
//                        szPath);

    BOOL fOK = SHGetSpecialFolderPath(NULL,               // hwndOner
                                szPath,
                                CSIDL_SYSTEM,       // CSIDL
                                false);             // fCreate

    ASSERT(fOK);
    if(!fOK)
        return E_FAIL;

    return E_NOTIMPL;      // not done yet...

    TCHAR szFullPath[MAX_PATH*2];
    PathCombine(szFullPath, szPath, DEF_OEM_FILENAME );
    int currSearchMode = 0;

    WCHAR *pwzFile = T2W(szFullPath);
    BOOL fProtected = SfcIsFileProtected(NULL, pwzFile);
    if(!fProtected)
    {
        DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        if(hr == ERROR_FILE_NOT_FOUND)
            return E_FILE_NOT_PROTECTED;
        else
        {
            return hr;
        }
    }

    // 2) has it been modified

    PCCERT_CONTEXT pcCertContext;
    const DWORD kcSize = 1024;
    BYTE rgbHashDataFixed[kcSize];
    DWORD cbHashData = kcSize;
    hr = MsiGetFileSignatureInformation(pwzFile,        // path to signed object
                                        MSI_INVALID_HASH_IS_FATAL,
                                        &pcCertContext,
                                        rgbHashDataFixed,
                                        &cbHashData);
    BYTE *prgbHashData = NULL;
    if(((HRESULT) ERROR_MORE_DATA) == hr)
    {
        prgbHashData = new BYTE[cbHashData];
        hr = MsiGetFileSignatureInformation(pwzFile,        // path to signed object
                                            MSI_INVALID_HASH_IS_FATAL,
                                            &pcCertContext,
                                            prgbHashData,
                                            &cbHashData);
    }
    if(FAILED(hr))
    {
    }

    delete[] prgbHashData;

    // 3) read the 'AllowUserConfig' bit,
    // 4) if set, return S_OK, else return S_FALSE;

    return E_NOTIMPL;
}
#endif //#ifdef DO_OEM_BIOS_CODE
*/

// ---------------------------------------------
//      ETFilter checks for secure server here
//      only to prevent encrypting data that couldn't be
//      unencrypted later (since DTFilter couldn't be added)

//      TODO - OBFUSCATE THIS METHOD

STDMETHODIMP
CETFilter::JoinFilterGraph (
                            IFilterGraph *pGraph,
                            LPCWSTR pName
                            )
{
    O_TRACE_ENTER_0 (TEXT("CETFilter::JoinFilterGraph ()")) ;
    HRESULT hr = S_OK;

    if(NULL != pGraph)   // not disconnection
    {
        m_enEncryptionMethod = Encrypt_DRMv1;

        {                // begin obfucation

#ifdef INSERT_TIMEBOMB
            hr = TimeBomb();
            if(FAILED(hr))
                return hr;
#endif

            DWORD dwFlags;
            HRESULT hrReg = (HRESULT) -1;   // an invalid HR, we set it down below

/* -- no longer doing OEM tests...

            hr = CheckIfOEMAllowsConfigurableDRMSystem();
            if(FAILED(hr))
            {
                TRACE_1(LOG_AREA_DRM, 1, _T("CETFilter(%d)::JoinFilterGraph - CheckIfOnOEMSystem Failed -tampering detected"),m_FilterID) ;
                hr = S_FALSE;
            }

        // more stuff here to set a registry value....
*/

#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS
            if(m_enEncryptionMethod != Encrypt_None)        // if haven't turned all the way off...
            {
                if(hrReg == (HRESULT) -1)
                    hrReg = Get_EncDec_RegEntries(NULL, 0, NULL, &dwFlags, NULL);    // get registry entry if don't yet have it..
                if(hrReg == S_OK)
                {
                    DWORD encMethod = dwFlags & 0xf;

                    if (encMethod == DEF_CS_DEBUG_DOGFOOD_ENC_VAL)
                    {
                        m_enEncryptionMethod = Encrypt_XOR_DogFood;
                        TRACE_1(LOG_AREA_DRM, 2, _T("CETFilter(%d)::JoinFilterGraph - Security Warning! DogFood encryption allowed for by setting a registry key"),
                            m_FilterID) ;
                    }
                    else // -- make this the default case.... if (encMethod == DEF_DRM_DEBUG_DRM_ENC_VAL)
                    {
                        m_enEncryptionMethod = Encrypt_DRMv1;
                        TRACE_1(LOG_AREA_DRM, 2, _T("CETFilter(%d)::JoinFilterGraph - DRM encryption turned on by setting a registry key"),
                            m_FilterID) ;
                    }
/*
#ifdef CodeToTurnOffDRM_AllTogether
                    else if ((dwFlags & 0xf) == DEF_CS_DEBUG_NO_ENC_VAL)
                    {
                        m_enEncryptionMethod = Encrypt_None;

                        TRACE_1(LOG_AREA_DRM, 2, _T("CETFilter(%d)::JoinFilterGraph - Security Warning! Encryption Turned Off By registry key"),
                            m_FilterID) ;
                    }
#endif // dwFlags
*/

                }

            }
#endif              // SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS

            const BOOL fCheckAlways = false;    // set to true to do DRM testing on graph start...

            if(fCheckAlways || m_enEncryptionMethod == Encrypt_DRMv1)       // only check if running DRM
            {
            // let ETFilter try to register that it's trusted (DEBUG ONLY!)
#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
                TRACE_1(LOG_AREA_DRM, 3, _T("CETFilter(%d)::JoinFilterGraph - Insecure - FILTERS_CAN_CREATE_THEIR_OWN_TRUST"),m_FilterID) ;
                hr = RegisterSecureServer(pGraph);      // test
#else
                TRACE_1(LOG_AREA_DRM, 3, _T("CETFilter(%d)::JoinFilterGraph is Secure - Filters not allowed to create their own trust"),m_FilterID) ;
#endif


#ifdef SUPPORT_REGISTRY_KEY_TO_TURN_OFF_CS      // check if reg-key to turn off checking the server.
                if(0 == (DEF_CS_DO_AUTHENTICATE_SERVER & dwFlags))
                    hr = S_OK;
                else
#endif
                    hr = CheckIfSecureServer(pGraph);

                if(S_OK != hr)
                {
                    TRACE_1(LOG_AREA_DRM, 1, _T("CETFilter(%d)::JoinFilterGraph Failed, Server Not Deemed Secure"),m_FilterID) ;
                    return hr;
                }
            }
        }   /// end obfuscation

                    // setup Authenticator (DRM secure channel object)
// test code
#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
        {
                    // test code to get the IDTFilterConfig interface the hard way
            CComPtr<IUnknown> spUnkETFilter;
            this->QueryInterface(IID_IUnknown, (void**)&spUnkETFilter);

                    // how the vid control would call this

                    // QI for the DTFilterConfig interface
            CComQIPtr<IETFilterConfig> spETFiltC(spUnkETFilter);

            if(spETFiltC != NULL)
            {

                // get the SecureChannel object
                CComPtr<IUnknown> spUnkSecChan;
                hr = spETFiltC->GetSecureChannelObject(&spUnkSecChan);   // gets DRM authenticator object from the filter
                if(!FAILED(hr))
                {   // call own method to pass keys and certs
                    hr = CheckIfSecureClient(spUnkSecChan);
                }
                if(FAILED(hr))
                {
                    TRACE_2(LOG_AREA_DRM, 1, _T("CETFilter(%d)::CheckIfSecureClient failed - hr = 0x%08x"),m_FilterID, hr);
                }
            }
        }
#endif
// end test code
    }   // conntection, not disconnection

    hr = CBaseFilter::JoinFilterGraph(pGraph, pName) ;
    return hr;
}

// ---------------------------

HRESULT
CETFilter::OnOutputGetMediaType (
    OUT CMediaType *    pmtOut
    )
{
    HRESULT hr ;

    ASSERT (pmtOut) ;

    CMediaType mtIn;
    if (m_pInputPin -> IsConnected ()) {
        // this gives us the input media type...
        hr = m_pInputPin -> ConnectionMediaType (&mtIn) ;

        // change it over to a new subtype...
        if(!FAILED(hr))
            hr = ProposeNewOutputMediaType(&mtIn, pmtOut);
    }
    else {
        //  output won't connecting when the input is not connected
        hr = E_UNEXPECTED ;
    }

    return hr ;
}


HRESULT
CETFilter::DeliverBeginFlush (
    )
{
    HRESULT hr ;

    TRACE_1(LOG_AREA_ENCRYPTER, 4, _T("CETFilter(%d)::DeliverBeginFlush"), m_FilterID) ;

    if (m_pOutputPin) {
        hr = m_pOutputPin -> DeliverBeginFlush () ;
    }
    else {
        hr = S_OK ;
    }

    if (SUCCEEDED (hr))
    {
    }

    return hr ;
}

HRESULT
CETFilter::DeliverEndFlush (
    )
{
    HRESULT hr ;

    if (m_pOutputPin) {
        hr = m_pOutputPin -> DeliverEndFlush () ;
    }
    else {
        hr = S_OK ;
    }

    TRACE_1(LOG_AREA_ENCRYPTER, 4, _T("CETFilter(%d)::DeliverEndFlush"), m_FilterID) ;

    return hr ;
}

HRESULT
CETFilter::DeliverEndOfStream (
    )
{
    HRESULT hr ;

    TRACE_1(LOG_AREA_ENCRYPTER, 4, _T("CETFilter(%d)::DeliverEndOfStream - start"), m_FilterID) ;

    if (m_pOutputPin) {
        hr = m_pOutputPin -> DeliverEndOfStream () ;
    }
    else {
        hr = S_OK ;
    }

    TRACE_1(LOG_AREA_ENCRYPTER, 4, _T("CETFilter(%d)::DeliverEndOfStream - end"), m_FilterID) ;

    return hr ;
}

// ------------------------------------
STDMETHODIMP
CETFilter::GetPages (
    CAUUID * pPages
    )
{

    HRESULT hr = S_OK;

#ifdef DEBUG
        pPages->cElems = 2 ;
#else
        pPages->cElems = 1 ;
#endif
        pPages->pElems = (GUID *) CoTaskMemAlloc(pPages->cElems * sizeof GUID) ;

        if (pPages->pElems == NULL)
        {
            pPages->cElems = 0;
            return E_OUTOFMEMORY;
        }
        if(pPages->cElems > 0)
            (pPages->pElems)[0] = CLSID_ETFilterEncProperties;
        if(pPages->cElems > 1)
            (pPages->pElems)[1] = CLSID_ETFilterTagProperties;

    return hr;
}

// ---------------------------------------------------------------------
//      IETFilterConfig methods
// ---------------------------------------------------------------------
STDMETHODIMP
CETFilter::CheckLicense(BSTR bsKID)
{
#ifdef BUILD_WITH_DRM

   // TimeitC(&m_tiStartup);    // time include in InitLicense

    USES_CONVERSION;
    HRESULT hr = S_OK;
    BYTE  bDecryptRights[RIGHTS_LEN] = {0x05, 0x0, 0x0, 0x0};    // 0x1=PlayOnPC, 0x2=XfertoNonSDMI, 0x4=NoBackupRestore, 0x8=BurnToCD, 0x10=XferToSDMI

    if(wcslen(bsKID) >= KIDLEN)
        return E_FAIL;
    
    hr = m_cDRMLite.SetRights( bDecryptRights );

        // Check to verify the data can be decrypted
    BOOL fCanDecrypt;

    try
    {
        char *pszKID = W2A(bsKID);
        hr = m_cDRMLite.CanDecrypt(pszKID, &fCanDecrypt);
    }
    catch (...)
    {
        ASSERT(false);      // tossed an exception (out of memory?)
        hr = E_FAIL;
    }

    if(fCanDecrypt == FALSE && !FAILED(hr))
    {
        hr = E_FAIL;      // LicenseFailure;       // something went wrong
    }
    return hr;
#else
    return S_OK;
#endif
}

STDMETHODIMP
CETFilter::InitLicense(
            IN int  LicenseId   // which license - not used, set as 0
          )
{

    TimeitC ti(&m_tiStartup);

#ifdef BUILD_WITH_DRM


    BYTE      NO_EXPIRY_DATE[DATE_LEN]   = {0xFF, 0xFF, 0xFF, 0xFF};
    BYTE      bAppSec[APPSEC_LEN]        = {0x0, 0x0, 0x3, 0xE8};    // 1000
    BYTE      bGenLicRights[RIGHTS_LEN]  = {0x05, 0x0, 0x0, 0x0};    // 0x1=PlayOnPC, 0x2=XfertoNonSDMI, 0x4=NoBackupRestore, 0x8=BurnToCD, 0x10=XferToSDMI
    LPSTR     pszKID                     = NULL;
    LPSTR     pszEncryptKey              = NULL;

    HRESULT hr    = S_OK;
    HRESULT hrGen = S_OK;
        
//   try
   {           
        
        USES_CONVERSION;


        // Generate a new license
        // KID and EncryptKey are allocated and returned as
        //  base64-encoded strings in the output buffers
        //

        {           // do all this inside the global ETFilters Crit Sec, want to serialize it...
            //  Note - DRM functions can take a long time (seconds)... Hope this doesn't block to bad
            CAutoLock  cLockGlob(m_pCritSectGlobalFilt);


            if(m_enEncryptionMethod < Encrypt_DRMv1)    // not using DRM...
                return S_FALSE;

            // License initialization
            DWORD       dwCAFlags;
            CComBSTR    spbsBaseKID;
            BYTE *pbHash = NULL;
            DWORD cbHash;

            // 1) Try to get a license cached in the registry
            hr = Get_EncDec_RegEntries(&spbsBaseKID, &cbHash, &pbHash, NULL, NULL);       // KID, HASHBuff, FLAGS

            int iLen = spbsBaseKID.Length();
            if(S_OK == hr && (iLen == 0 || cbHash == 0 || pbHash == NULL))  // if no hash buff, fail too
                hr = E_FAIL;

            if(S_OK == hr)
            {
                // 1b)  If find it, and it's reasonable length, check if it's a valid.license
//ENCRYPT_DATA(111,1,2)
                hr = CheckLicense(spbsBaseKID);
//DECRYPT_DATA(111,1,2)
                
                // 1b) If the one that there is invalid, remove it now....
                if(FAILED(hr))
                {
                    TRACE_1(LOG_AREA_DRM, 2, _T("CETFilter(%d)::Invalid BaseKID License in Registry. Clearing it"), m_FilterID) ;
                    TRACE_1(LOG_AREA_DRM, 3, _T("               KID: %s"),W2T(spbsBaseKID)) ;
                } else {

                    TRACE_1(LOG_AREA_DRM, 3, _T("CETFilter(%d)::Check Registry BaseKID License Succeeded"), m_FilterID) ;
                    TRACE_1(LOG_AREA_DRM, 3, _T("               BaseKID: %s"),W2T(spbsBaseKID)) ;

                   // 1c)  Decode the hash into it's pieces (using license specified by baseKID)
                    BYTE *pszTrueKID;
                    LONG pAgeSeconds;
                    hr = DecodeHashStruct(spbsBaseKID, cbHash, pbHash, &pszTrueKID, &pAgeSeconds);
                    if(!FAILED(hr))
                    {
                        TRACE_1(LOG_AREA_DRM, 3, _T("CETFilter(%d)::TrueKID Decrypt Succeeded"), m_FilterID) ;
                        TRACE_3(LOG_AREA_DRM, 3, _T("               TrueKID: %S, Age : %8.2f %s"), pszTrueKID,
                                pAgeSeconds < 120 ? pAgeSeconds :
                                 (pAgeSeconds/60 < 120 ? pAgeSeconds/60.0 :
                                 (pAgeSeconds/(60*60) < 48 ? pAgeSeconds / (60*60.0) :
                                 (pAgeSeconds/(60*60*24)))),
                                pAgeSeconds < 120 ? _T("Secs") :
                                 (pAgeSeconds/60 < 120 ? _T("Mins") :
                                 (pAgeSeconds/(60*60) < 48 ? _T("Hrs") :
                                 _T("Days") )));

                        // 1d) Save this true KID away so we can encrypt with it.
                        if(NULL == m_pbKID)
                            m_pbKID = (BYTE *) CoTaskMemAlloc(KIDLEN + 1);          // get some space for our KID as an Ascii string
                        memcpy(m_pbKID, pszTrueKID, KIDLEN);
                        m_pbKID[KIDLEN] = 0;                            // null terminate

                    }

#ifdef MAX_LICENSE_AGE_IN_HRS
                     if(pAgeSeconds/(60*60) > MAX_LICENSE_AGE_IN_HRS)
                    {
                        TRACE_2(LOG_AREA_DRM, 3, _T("CETFilter(%d)::License more than %d hours old, being revoked"),
                            m_FilterID, MAX_LICENSE_AGE_IN_HRS) ;
                        hr = E_FAIL;
                    }
#endif

#ifdef MAX_LICENSE_AGE_IN_SECS
                     if(pAgeSeconds > MAX_LICENSE_AGE_IN_SECS)
                    {
                        TRACE_2(LOG_AREA_DRM, 3, _T("CETFilter(%d)::License more than %d secs old, being revoked"),
                            m_FilterID, MAX_LICENSE_AGE_IN_SECS) ;
                        hr = E_FAIL;
                    }
#endif


                    if(NULL != pszTrueKID)
                        CoTaskMemFree(pszTrueKID);
                }
                if(NULL != pbHash)
                    CoTaskMemFree(pbHash);
            }

            // 2) If no license in registry, or the one there was invalid, create a new one
            if(FAILED(hr))
            {
                hrGen = m_cDRMLite.GenerateNewLicenseEx(        // this generates the baseKID
                    GNL_EX_MODE_RANDOM,
                    bAppSec,
                    bGenLicRights,
                    (BYTE *)NO_EXPIRY_DATE,
                    &pszKID,
                    &pszEncryptKey );       // can't NULL this out, program fails if we do...

#ifdef _DEBUG                               // for paranoia, this code should be gone in release build...
                if(!FAILED(hrGen))
                {

                    TRACE_1(LOG_AREA_DRM, 3, _T("CETFilter(%d)::GenerateNewLicenseEx Succeeded"), m_FilterID) ;
                    TRACE_1(LOG_AREA_DRM, 3, _T("               BaseKID: %s"),A2W(pszKID)) ;
                    //        TRACE_1(LOG_AREA_DRM, 5, _T("               Key: %s"),A2W(pszEncryptKey)) ;
                }
#endif

                if(pszEncryptKey && *pszEncryptKey)      // immediatly clear this, we don't need it and it's a security hole
                {
                    memset((void *) pszEncryptKey, 0, strlen(pszEncryptKey));
                }

                // 2b)  If created a new license, geneate a new license, use baseKID to encrypt it,
                        // and store it into the registry so we don't create it again
                if(!FAILED(hrGen))
                {

                    CComBSTR spbsBaseKID(pszKID);

                    DWORD cBytesHashStruct;
                    BYTE *pbHashStruct = NULL;
                    hr = CreateHashStruct(spbsBaseKID, &cBytesHashStruct, &pbHashStruct);

                    if(FAILED(hr))
                    {
                        TRACE_2(LOG_AREA_DRM, 2, _T("CETFilter(%d)::Warning couldn't create Hash Struct, hr=0x%08x"),m_FilterID, hr);
                    }
                    else
                    {
                        // 2c) Store the base KID and the hashed value into the registry
                        hr = Set_EncDec_RegEntries(spbsBaseKID, cBytesHashStruct, pbHashStruct);

                        if(FAILED(hr))
                        {
                            TRACE_2(LOG_AREA_DRM, 2, _T("CETFilter(%d)::Warning couldn't set KID in registry,  hr=0x%08x"), m_FilterID,hr) ;
                            Remove_EncDec_RegEntries();
                        }  else {
                            TRACE_2(LOG_AREA_DRM, 2, _T("CETFilter(%d)::Succesfully stored KID in registry hr=0x%08x"), m_FilterID,hr) ;
                        }
                    }
                        // 2d) Get the unecrypted true KID out of the hash buffer
                    if(!FAILED(hr))
                    {
                        LONG pAgeSeconds;
                        BYTE *pszTrueKID = NULL;
                        hr = DecodeHashStruct(spbsBaseKID, cBytesHashStruct, pbHashStruct,
                                              &pszTrueKID, &pAgeSeconds);
                        if(!FAILED(hr))
                        {
                            TRACE_1(LOG_AREA_DRM, 3, _T("CETFilter(%d)::TrueKID Decrypt Succeeded"), m_FilterID) ;
                            TRACE_3(LOG_AREA_DRM, 3, _T("               TrueKID: '%S', Age : %8.2f %s"), pszTrueKID,
                                float(pAgeSeconds < 120 ? pAgeSeconds :
                                        (pAgeSeconds/60 < 120 ? pAgeSeconds/60.0 :
                                        (pAgeSeconds/(60*60) < 48 ? pAgeSeconds / (60*60.0) :
                                        (pAgeSeconds/(60*60*24))))),
                                pAgeSeconds < 120 ? _T("Secs") :
                                 (pAgeSeconds/60 < 120 ? _T("Mins") :
                                 (pAgeSeconds/(60*60) < 48 ? _T("Hrs") :
                                 _T("Days") )));

                                        // Save this true KID away so we can encrypt with it.
                            if(NULL == m_pbKID)
                                m_pbKID = (BYTE *) CoTaskMemAlloc(KIDLEN + 1);          // get some space for our KID as an Ascii string
                            memcpy(m_pbKID, pszTrueKID, KIDLEN);
                            m_pbKID[KIDLEN] = 0;                            // null terminate

                        }

                        if(NULL != pszTrueKID)
                            CoTaskMemFree(pszTrueKID);
                    }

                    if(pbHashStruct) CoTaskMemFree(pbHashStruct);

                    hrGen = hr;         // keep track of the error
                }

                if(pszKID)        CoTaskMemFree(pszKID);
                if(pszEncryptKey) CoTaskMemFree(pszEncryptKey);
            }
        }           // end of the global ETFilters CritSec

        if(!FAILED(hrGen))
        {
            if(m_3fDRMLicenseFailure != FALSE)  // 3 state logic (uninitalized, true an dfalse
            {
                FireBroadcastEvent(EVENTID_ETDTFilterLicenseOK);
                m_3fDRMLicenseFailure = FALSE;
            }


        } else {
            TRACE_2(LOG_AREA_DRM, 2, _T("CETFilter(%d)::GenerateNewLicenseEx Failed, hr = 0x%08x"),m_FilterID, hr) ;
            if(m_3fDRMLicenseFailure != TRUE)
            {

                FireBroadcastEvent(EVENTID_ETDTFilterLicenseFailure);
                m_3fDRMLicenseFailure = TRUE;
            }
            //  ASSERT(false);          // failed
        }

        return hr;
    } 
 //   catch (...)
 //   {
 //       TRACE_2(LOG_AREA_DRM, 1, _T("CETFilter(%d)::GenerateNewLicenseEx tossed an exception - returning failure"),m_FilterID, hr) ;
 //       return E_FAIL;
 //   }
#else
    return S_OK;        // don't care
#endif
}




STDMETHODIMP
CETFilter::ReleaseLicenses(
          )
{
    TimeitC ti(&m_tiTeardown);
                // need to add stuff here... but what?  When does this get called?
    return S_OK;
}
// ---------------------------------------------------------------------
//      IETFilter methods
// ---------------------------------------------------------------------
STDMETHODIMP
CETFilter::get_EvalRatObjOK(
    OUT HRESULT *pHrCoCreateRetVal
    )
{
    if(NULL == pHrCoCreateRetVal)
        return E_POINTER;

    *pHrCoCreateRetVal = m_hrEvalRatCoCreateRetValue;
    return S_OK;
}

        // The trouble with ratings is they show up at quite skewed times
        //  from the actual data....  This method helps to unskews them by
        //  allowing you to set the desired time.

STDMETHODIMP
CETFilter::GetCurrRating
        (
        OUT EnTvRat_System         *pEnSystem,
        OUT EnTvRat_GenericLevel   *pEnLevel,
        OUT LONG                   *plbfEnAttr  // BfEnTvRat_GenericAttributes
         )
{
    return GetRating(0, 0, pEnSystem, pEnLevel, plbfEnAttr, NULL, NULL);
}

HRESULT
CETFilter::GetRating
        (
        IN  REFERENCE_TIME          timeStart,      // if 0, get latest
        IN  REFERENCE_TIME          timeEnd,
        OUT EnTvRat_System         *pEnSystem,
        OUT EnTvRat_GenericLevel   *pEnLevel,
        OUT LONG                   *plbfEnAttr,  // BfEnTvRat_GenericAttributes
        OUT LONG                   *pPktSeqID,
        OUT LONG                   *pCallSeqID
         )
{
    if(pEnSystem == NULL || pEnLevel == NULL || plbfEnAttr == NULL)
        return E_FAIL;

    *pEnSystem  = m_EnSystemCurr;
    *pEnLevel   = m_EnLevelCurr;
    *plbfEnAttr = m_lbfEnAttrCurr;
    if(NULL != pCallSeqID) *pCallSeqID = m_callSeqIDCurr;
    if(NULL != pPktSeqID)  *pPktSeqID  = m_pktSeqIDCurr;

    int diffTime = int(timeStart - m_timeStartCurr);

    if(m_timeStartCurr != 0 && timeStart != 0)
        TRACE_2(LOG_AREA_ENCRYPTER, 8, _T("CETFilter(%d)::GetRating - Skew of %d msecs"),m_FilterID, diffTime/100000);

    return S_OK;
}

                // helper method that locks...  // returns S_FALSE if changed
HRESULT
CETFilter::SetRating
            (
             IN EnTvRat_System              enSystem,
             IN EnTvRat_GenericLevel        enLevel,
             IN LONG                        lbfEnAttr,    // BfEnTvRat_GenericAttributes
             IN LONG                        pktSeqID,
             IN LONG                        callSeqID,
             IN REFERENCE_TIME              timeStart,
             IN REFERENCE_TIME              timeEnd
             )
{

#ifdef DEBUG
    TCHAR buff[64];
    RatingToString(enSystem, enLevel, lbfEnAttr, buff, sizeof(buff)/sizeof(buff[0]) );
    TRACE_6(LOG_AREA_ENCRYPTER, 3, _T("CETFilter(%d):: SetRating %9s (%d/%d) Time %d %d (msec) Media Time %d %d (msec)"),
        m_FilterID, buff, pktSeqID, callSeqID, int(timeStart/10000), int(timeEnd/10000));

#endif

    BOOL fChanged = false;

 //   ASSERT(pktSeqID != m_pktSeqIDCurr);         // unexpected case if called twice...
 //                                             // (happens occasionally when get 2 events really close)

    if(m_EnSystemCurr  != enSystem)  {m_EnSystemCurr = enSystem; fChanged = true;}
    if(m_EnLevelCurr   != enLevel)   {m_EnLevelCurr  = enLevel; fChanged = true;}
    if(m_lbfEnAttrCurr != lbfEnAttr) {m_lbfEnAttrCurr = lbfEnAttr; fChanged = true;}

    if(fChanged)
    {
        m_pktSeqIDCurr  = pktSeqID;
        m_callSeqIDCurr = callSeqID;
     }
    m_timeStartCurr = timeStart;
    m_timeEndCurr   = timeEnd;              // even if didn't change, end time probably the same

    return fChanged ? S_OK : S_FALSE;
}

// ---------------------------------------------------------------------
// IBroadcastEvent
// ---------------------------------------------------------------------

STDMETHODIMP
CETFilter::Fire(IN GUID eventID)     // this comes from the Graph's events - call our own method
{
    TRACE_2 (LOG_AREA_BROADCASTEVENTS, 6,  L"CETFilter(%d):: Fire(get) : %s", m_FilterID,
        EventIDToString(eventID));

    if(eventID == EVENTID_XDSCodecNewXDSRating)
    {
       DoXDSRatings();
    }
    else if (eventID == EVENTID_XDSCodecDuplicateXDSRating)
    {
       DoDuplicateXDSRatings();
    }
    else if (eventID == EVENTID_XDSCodecNewXDSPacket)
    {
       DoXDSPacket();
    }
    else if (eventID == EVENTID_TuningChanged)
    {
       DoTuneChanged();
    }
    return S_OK;            // doesn't matter what we return on an event...
}


// ---------------------------------------------------------------------
// Broadcast Event Service
//
//      Hookup needed to send events,
//       Then also need to Register to receive events
// ---------------------------------------------------------------------

HRESULT
CETFilter::FireBroadcastEvent(IN const GUID &eventID)
{
    HRESULT hr = S_OK;

    if(m_spBCastEvents == NULL)
    {
        hr = HookupGraphEventService();
        if(FAILED(hr))
            return hr;
    }

    if(m_spBCastEvents == NULL)
        return E_FAIL;              // wasn't able to create it

    TRACE_2 (LOG_AREA_BROADCASTEVENTS, 5,  L"CETFilter(%d):: FireBroadcastEvent : %s", m_FilterID,
        EventIDToString(eventID));

    return m_spBCastEvents->Fire(eventID);
}


HRESULT                             
CETFilter::HookupGraphEventService()
{
                        // basically, just makes sure we have the broadcast event service object
                        //   and if it doesn't exist, it creates it..
    HRESULT hr = S_OK;

    TimeitC ti(&m_tiStartup);

    if (!m_spBCastEvents)
    {
        CAutoLock  cLockGlob(m_pCritSectGlobalFilt);

        CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph);
        if (spServiceProvider == NULL) {
            TRACE_1 (LOG_AREA_BROADCASTEVENTS, 1, _T("CETFilter(%d):: Can't get service provider interface from the graph"), m_FilterID);
            return E_NOINTERFACE;
        }
        hr = spServiceProvider->QueryService(SID_SBroadcastEventService,
                                             IID_IBroadcastEvent,
                                             reinterpret_cast<LPVOID*>(&m_spBCastEvents));
        if (FAILED(hr) || !m_spBCastEvents)
        {
//          hr = m_spBCastEvents.CoCreateInstance(CLSID_BroadcastEventService, 0, CLSCTX_INPROC_SERVER);
            hr = m_spBCastEvents.CoCreateInstance(CLSID_BroadcastEventService);
            if (FAILED(hr)) {
                TRACE_0 (LOG_AREA_BROADCASTEVENTS, 1,  _T("CETFilter:: Can't create BroadcastEventService"));
                return E_UNEXPECTED;
            }

            CComQIPtr<IRegisterServiceProvider> spRegisterServiceProvider(m_pGraph);
            if (spRegisterServiceProvider == NULL) {
                TRACE_0 (LOG_AREA_BROADCASTEVENTS, 1,  _T("CETFilter:: Can't QI Graph for RegisterServiceProvider"));
                return E_UNEXPECTED;
            }
            hr = spRegisterServiceProvider->RegisterService(SID_SBroadcastEventService, m_spBCastEvents);
            if (FAILED(hr)) {
                   // deal with unlikely race condition case here, if can't register, perhaps someone already did it for us
                TRACE_1 (LOG_AREA_BROADCASTEVENTS, 2,  _T("CETFilter:: Rare Warning - Can't register BroadcastEventService in Service Provider. hr = 0x%08x"), hr);
                hr = spServiceProvider->QueryService(SID_SBroadcastEventService,
                                                     IID_IBroadcastEvent,
                                                     reinterpret_cast<LPVOID*>(&m_spBCastEvents));
                if(FAILED(hr))
                {
                    TRACE_1 (LOG_AREA_BROADCASTEVENTS, 1,  _T("CETFilter:: Can't reget BroadcastEventService in Service Provider. hr = 0x%08x"), hr);
                    return hr;
                }
            }
        }

        TRACE_3(LOG_AREA_BROADCASTEVENTS, 4, _T("CETFilter(%d)::HookupGraphEventService - Service Provider 0x%08x, Service 0x%08x"), m_FilterID,
            spServiceProvider, m_spBCastEvents) ;

    }

    return hr;
}


HRESULT
CETFilter::UnhookGraphEventService()
{
    TimeitC ti(&m_tiTeardown);

    HRESULT hr = S_OK;

    if(m_spBCastEvents != NULL)
    {
        m_spBCastEvents = NULL;     // null this out, will release object reference to object above
    }                               //   the filter graph will release final reference to created object when it goes away
    TRACE_1(LOG_AREA_BROADCASTEVENTS, 5, _T("CETFilter(%d)::UnhookGraphEventService  Successfully"), m_FilterID) ;

    return hr;
}



            // ---------------------------------------------
            // ETFilter filter does need to receive XDS events...
            //  so this code is required.

HRESULT
CETFilter::RegisterForBroadcastEvents()
{
    TimeitC ti(&m_tiStartup);

    HRESULT hr = S_OK;
    TRACE_1(LOG_AREA_BROADCASTEVENTS, 3, _T("CETFilter(%d)::RegisterForBroadcastEvents"), m_FilterID);

    if(m_spBCastEvents == NULL)
        hr = HookupGraphEventService();

    if(m_spBCastEvents == NULL)
    {
        TRACE_0(LOG_AREA_BROADCASTEVENTS, 3,_T("CETFilter::RegisterForBroadcastEvents - Warning - Broadcast Event Service not yet created"));
        return hr;
    }

                /* IBroadcastEvent implementing event receiving object*/
    if(kBadCookie != m_dwBroadcastEventsCookie)
    {
        TRACE_0(LOG_AREA_BROADCASTEVENTS, 3, _T("CETFilter::Already Registered for Broadcast Events"));
        return E_UNEXPECTED;
    }

    CComQIPtr<IConnectionPoint> spConnectionPoint(m_spBCastEvents);
    if(spConnectionPoint == NULL)
    {
        TRACE_0(LOG_AREA_BROADCASTEVENTS, 1, _T("CETFilter::Can't QI Broadcast Event service for IConnectionPoint "));
        return E_NOINTERFACE;
    }


    CComPtr<IUnknown> spUnkThis;
    this->QueryInterface(IID_IUnknown, (void**)&spUnkThis);

    hr = spConnectionPoint->Advise(spUnkThis,  &m_dwBroadcastEventsCookie);
//  hr = spConnectionPoint->Advise(static_cast<IBroadcastEvent*>(this),  &m_dwBroadcastEventsCookie);
    if (FAILED(hr)) {
        TRACE_1(LOG_AREA_BROADCASTEVENTS, 1, _T("CETFilter::Can't advise event notification. hr = 0x%08x"),hr);
        return E_UNEXPECTED;
    }
    TRACE_3(LOG_AREA_BROADCASTEVENTS, 3, _T("CETFilter(%d)::RegisterForBroadcastEvents - Advise 0x%08x on CP 0x%08x"),m_FilterID, spUnkThis,spConnectionPoint);

    return hr;
}


HRESULT
CETFilter::UnRegisterForBroadcastEvents()
{
    TimeitC ti(&m_tiTeardown);

    HRESULT hr = S_OK;
    TRACE_1(LOG_AREA_BROADCASTEVENTS, 3,  _T("CETFilter(%d)::UnRegisterForBroadcastEvents"), m_FilterID);

    if(kBadCookie == m_dwBroadcastEventsCookie)
    {
        TRACE_1(LOG_AREA_BROADCASTEVENTS, 3, _T("CETFilter(%d)::Not Yet Registered for Tune Events"), m_FilterID);
        return S_FALSE;
    }

    CComQIPtr<IConnectionPoint> spConnectionPoint(m_spBCastEvents);
    if(spConnectionPoint == NULL)
    {
        TRACE_1(LOG_AREA_BROADCASTEVENTS, 1, _T("CETFilter(%d)::Can't QI Broadcast Event service for IConnectionPoint "), m_FilterID);
        return E_NOINTERFACE;
    }

    hr = spConnectionPoint->Unadvise(m_dwBroadcastEventsCookie);
    m_dwBroadcastEventsCookie = kBadCookie;
//  m_spBCastEvents.Detach();   -- don't like this, why is it here? (bad leak fix? forgot to unregister service instead)

    if(!FAILED(hr))
        TRACE_1(LOG_AREA_BROADCASTEVENTS, 3, _T("CETFilter(%d)::Successfully Unregistered for Broadcast Events"), m_FilterID);
    else
        TRACE_2(LOG_AREA_BROADCASTEVENTS, 3, _T("CETFilter(%d)::Failed Unregistering for Broadcast Events - hr = 0x%08x"), m_FilterID, hr);
        
    return hr;
}

// ---------------------------------------------------------------------
// ---------------------------------------------------------------------

HRESULT
CETFilter::DoXDSRatings()
{
    HRESULT hr = S_OK;
    TRACE_1(LOG_AREA_ENCRYPTER, 7, _T("CETFilter(%d)::DoXDSRatings"), m_FilterID);

    //  1) find the XDSCodec filter,
    if(m_spXDSCodec == NULL)
    {
        hr = LocateXDSCodec();
        if(FAILED(hr))
            return hr;
    }
    if(m_spXDSCodec == NULL)        // extra paranoia
        return E_FAIL;

    // 2) get the rating...
    PackedTvRating TvRat;
    long pktSeqID;
    long callSeqID;
    REFERENCE_TIME timeStart;
    REFERENCE_TIME timeEnd;
    m_spXDSCodec->GetContentAdvisoryRating(&TvRat, &pktSeqID, &callSeqID, &timeStart, &timeEnd);

    //  3) unpack it into the 3-part rating
    EnTvRat_System              enSystem;
    EnTvRat_GenericLevel        enLevel;
    LONG                        lbfEnAttr;
    UnpackTvRating(TvRat, &enSystem, &enLevel, &lbfEnAttr);

    //  4) store nice unpacked version of it, along with time it was crated for...
    SetRating(enSystem, enLevel, lbfEnAttr, pktSeqID, callSeqID, timeStart, timeEnd);

    //  5) indicate it's a new fresh rating (used for timeouts...)
    RefreshRating(true);

    return S_OK;
}

                    // called when get duplicate rating... No (real) need to look for the XDS Codec
                    //   - we've already got the rating.
                    // (What we don't have is the new time... Assume for now we don't need it.
HRESULT
CETFilter::DoDuplicateXDSRatings()
{
    HRESULT hr = S_OK;
    TRACE_1(LOG_AREA_ENCRYPTER, 8, _T("CETFilter(%d)::DoDuplicateXDSRatings"), m_FilterID);

    RefreshRating(true);

    return S_OK;
}

HRESULT
CETFilter::DoXDSPacket()
{
    HRESULT hr = S_OK;
    TRACE_1(LOG_AREA_ENCRYPTER, 8, _T("CETFilter(%d)::DoXDSPacket"), m_FilterID);

        // TODO -
        //  1) find the XDSCodec filter,
        //  2) get the current other packet
        //  3) if active type, send event upward
        //  4) if PVR type, cache it away


    return S_OK;
}
// -----------------------------------------------------------------------------------
//  DoTuneChanged
//
//          Called when the user changes channels..
//          Locates the TuneRequest by digging through the graph, and then
//          then calls CAManager::put_TuneRequest()
//          
//          Then calls ICAManagerInternal:get_Check() to let policies have
//            a chance at denying the channel change.
// -----------------------------------------------------------------------------------
HRESULT
CETFilter::DoTuneChanged()
{
    HRESULT hr = S_OK;
    TRACE_1(LOG_AREA_BROADCASTEVENTS, 8, _T("CETFilter(%d)::DoTuneChanged"), m_FilterID);
    TRACE_0(LOG_AREA_ENCRYPTER, 3, _T("CETFilter::DoTuneChanged - not implemented")) ;
                                    // find the tuner...

#if 0
    if(m_spTuner == NULL && m_spVidTuner == NULL)
    {
        if(m_pGraph != NULL)
        {

            int iFilt = 0;
            for (DSGraph::iterator i = m_pGraph.begin(); i != m_pGraph.end(); ++i)
            {
                DSFilter f(*i);
                ITunerPtr spTuner(f);
                if(NULL != spTuner)
                {
                    m_spTuner = spTuner;
                    break;
                }
                iFilt++;
             }
        }

                    // if couldn't find a filter that supported ITuner, try the input graph segments instead
        if(m_spTuner == NULL && m_spVidTuner == NULL)
        {
            if(m_pContainer == NULL)
            {
                _ASSERT(false);
            } else {
                IMSVidCtlPtr spVidCtl(m_pContainer);
                if(spVidCtl != NULL)
                {
                    IMSVidInputDevicePtr spInputDevice;
                    hr = spVidCtl->get_InputActive(&spInputDevice);
                    if(!FAILED(hr))
                    {
                        IMSVidTunerPtr spVidTuner(spInputDevice);
                        if(NULL != spVidTuner)
                        {
                            m_spVidTuner = spVidTuner;
                        }
                    }
                }
            }
        }
    }

    ITuneRequestPtr spTRequest;
    if(m_spTuner)
    {
        hr = m_spTuner->get_TuneRequest(&spTRequest);
    } else if(m_spVidTuner) {
        hr = m_spVidTuner->get_Tune(&spTRequest);
    } else {
        _ASSERT(false);     // wasn't able to find a tuner!  What gives!
        hr = S_FALSE;
    }

    // Whack the cached vidctl tuner segment, in case of view next or other tuner change
      if(m_spVidTuner)
          m_spVidTuner = NULL;

    // TODO -
    //      create Tag containing this tune request
    //      cache it away.
    


#endif
    return hr;
}

        // =====================================================================
        //   Worker Methods

HRESULT 
CETFilter::LocateXDSCodec()     // walks through the graph to find spXDSFilter
{
    TimeitC ti(&m_tiStartup);

    HRESULT hr = S_OK;
    if(m_spXDSCodec != NULL)    // already found it?
        return S_OK;

    CComPtr<IFilterGraph> spGraph = GetFilterGraph( );
    if(spGraph == NULL)
        return S_FALSE;

    CComPtr<IEnumFilters> speFilters;
    hr = spGraph->EnumFilters(&speFilters);

    CComPtr<IBaseFilter> spFilter;
    ULONG cFetched;
    int cFilters = 0;
    while(S_OK == speFilters->Next(1, &spFilter, &cFetched))
    {
        if(cFetched == 0) break;
        CComQIPtr<IXDSCodec> spXDSCodec(spFilter);  // QI for main interface on that filter
        spFilter = NULL;

        if(spXDSCodec != NULL)
        {
            m_spXDSCodec = spXDSCodec;
            break;
        }
        cFilters++;     // just for fun, keep track of # of filters we have
    }

    if(m_spXDSCodec == NULL)
    {
        TRACE_1(LOG_AREA_ENCRYPTER, 2, L"CETFilter(%d)::Couldn't find the XDSCodec filter\n", m_FilterID);
    } else {
        TRACE_1(LOG_AREA_ENCRYPTER, 5, L"CETFilter(%d)::Located the XDSCodec filter\n", m_FilterID);
    }

    return S_OK;
}


// -----------------------------------------------------------------------
//
// This is the two-part KID object to protect the true encryption KID from being hacked,
// and to allow use to create new encrytion license on a resonable schedule.
//
// The goal was to prevent two security attacks:
//   - someone substituting a known license in place of the true one by editing the registy
//     This would let people perhaps use an external license to encrypt data.  If they
//     managed to copy that license between machines, then they could copy content.
//   - general security issue of not changing the encryption key occasionally (say once a month)
//     If the license for one file compromised, then all content on the machine would be.
//
// The idea is to store 2 things in the registry
//     BaseKID          - Key Identifier for license to decrypt the Encrypted Buffer
//     Encrypted Buffer - encrypted time buffer
//
//     Where the Encrypted Buffer contains the following
//          Magic #'s
//          TrueKID
//          Time of Creation
//      and is stored encrypted in the registry using the License referenced by BaseKID
//
//  On initialization, the code reads the KID and uses it to decode the Encrypted buffer.
//  The TrueKID is then used to encrypt the actual data.  All the KID's and the structure
//  are checked, and if either of them are invalid, or the structure is invalid (bad magic)
//  or optionally, if the license is too old, then an entirerly new pair of licenses is
//  generated, and the second on is encrypted into the registry buffer.
//
// --------------------------------------------------------------------------

#define kMagic 0x66336645   // use #define rather than const int to avoid this value appearing in code/data section
struct HashBuff
{
    DWORD   dwMagic;        // a magic number
    DWORD   cBytes;         // size of structure in bytes
    char    KID[KIDLEN];    // actual KID used to encrypt
    time_t  tmCreated;
};

    // returns CoTaskMemAlloc'ed buffer on success.  Caller is responsible for clearing it.

HRESULT
CETFilter::CreateHashStruct(BSTR bsBaseKID, DWORD *pcBytes, BYTE **ppbHashStruct)
{
    if(NULL == pcBytes || NULL == ppbHashStruct)
        return E_INVALIDARG;

#ifndef BUILD_WITH_DRM
    return S_OK;
#else
    HRESULT hr;
    BYTE      NO_EXPIRY_DATE[DATE_LEN]   = {0xFF, 0xFF, 0xFF, 0xFF};
    BYTE      bAppSec[APPSEC_LEN]        = {0x0, 0x0, 0x3, 0xE8};    // 1000
    BYTE      bGenLicRights[RIGHTS_LEN]  = {0x5, 0x0, 0x0, 0x0};    // 0x1=PlayOnPC, 0x2=XfertoNonSDMI, 0x4=NoBackupRestore, 0x8=BurnToCD, 0x10=XferToSDMI
    BYTE      bDecryptRights[RIGHTS_LEN] = {0x5, 0x0, 0x0, 0x0};    // 0x1=PlayOnPC, 0x2=XfertoNonSDMI, 0x4=NoBackupRestore, 0x8=BurnToCD, 0x10=XferToSDMI
    LPSTR     pszKID                     = NULL;
    LPSTR     pszEncryptKey              = NULL;


    if(wcslen(bsBaseKID) >= KIDLEN)
        return E_FAIL;

    hr = m_cDRMLite.SetRights( bDecryptRights );

                // Check to verify the data can be decrypted
    USES_CONVERSION;
    BOOL fCanDecrypt;

    char szBaseKID[KIDLEN+1];
    for(int i = 0; i < KIDLEN; i++)
        szBaseKID[i] = (char) bsBaseKID[i];  // copy over to ascii format...
    szBaseKID[KIDLEN] = 0;                     // null terminate for paranoia

    hr = m_cDRMLite.CanDecrypt(szBaseKID, &fCanDecrypt);           // is base license OK?
    if(FAILED(hr))
        return hr;

               // generate a new true license
    HashBuff *ptb = (HashBuff *) CoTaskMemAlloc(sizeof(HashBuff));

    if(NULL == ptb)
        return E_OUTOFMEMORY;


    hr = m_cDRMLite.GenerateNewLicenseEx(
            GNL_EX_MODE_RANDOM,
            bAppSec,
            bGenLicRights,
            (BYTE *)NO_EXPIRY_DATE,
            &pszKID,
            &pszEncryptKey );

    if(FAILED(hr))
        return hr;
                                // null out key, we don't use it and it's a security hole
    for(i = 0; i < 8; i++)
    {
        if(pszEncryptKey[i] == 0) break;
        pszEncryptKey[i] = 0;
    }

    time_t tm;                  // fill in the structure/buffer (love those unions!)
    ptb->dwMagic   = kMagic;
    ptb->cBytes    = sizeof(HashBuff);
    ptb->tmCreated = time(&tm);          // number of seconds since Jan 1 1970
    memcpy(ptb->KID, pszKID, KIDLEN);

    CoTaskMemFree(pszKID);
    CoTaskMemFree(pszEncryptKey);

               // indirect - where are we going to put the data
    *ppbHashStruct = (BYTE *) ptb;

    hr = m_cDRMLite.EncryptIndirectFast(szBaseKID, sizeof(HashBuff), *ppbHashStruct);

    if(FAILED(hr)) {
        CoTaskMemFree(ppbHashStruct);
        *ppbHashStruct = NULL;
        *pcBytes = 0;
    } else {
        *pcBytes       = sizeof(HashBuff);
    }

    return hr;
#endif          // BUILD_WITH_DRM
}


HRESULT
CETFilter::DecodeHashStruct(BSTR bsBaseKID, DWORD cBytesHash, BYTE *pbHashStruct,
                            BYTE **ppszTrueKID, LONG *pAgeSeconds)
{
    if(0 == cBytesHash || NULL == pbHashStruct)
        return E_INVALIDARG;

#ifndef BUILD_WITH_DRM

    return S_OK;
#else
    HRESULT hr;
    BYTE      NO_EXPIRY_DATE[DATE_LEN]   = {0xFF, 0xFF, 0xFF, 0xFF};
    BYTE      bAppSec[APPSEC_LEN]        = {0x0, 0x0, 0x3, 0xE8};    // 1000
    BYTE      bDecryptRights[RIGHTS_LEN] = {0x5, 0x0, 0x0, 0x0};    // 0x1=PlayOnPC, 0x2=XfertoNonSDMI, 0x4=NoBackupRestore, 0x8=BurnToCD, 0x10=XferToSDMI
    LPSTR     pszKID                     = NULL;
    LPSTR     pszEncryptKey              = NULL;

    if(0 == cBytesHash || NULL == pbHashStruct)
        return E_INVALIDARG;

    if(wcslen(bsBaseKID) >= KIDLEN)
        return E_FAIL;

    hr = m_cDRMLite.SetRights( bDecryptRights );

                                                // Check to verify the BaseKID is valid
    USES_CONVERSION;
    BOOL fCanDecrypt;

    char szBaseKID[KIDLEN+1];
    for(int i = 0; i < KIDLEN; i++)
        szBaseKID[i] = (char) bsBaseKID[i];     // copy over to ascii format...
    szBaseKID[KIDLEN] = 0;                      // null terminate for paranoia

    hr = m_cDRMLite.CanDecrypt(szBaseKID, &fCanDecrypt);           // is base license OK?
    if(FAILED(hr))
    {
        return hr;                              // Invalid License
    }

    hr = m_cDRMLite.Decrypt(szBaseKID, sizeof(HashBuff), pbHashStruct);
    if(FAILED(hr))
    {
        return hr;                              // Unable to decrypt data
    }

    HashBuff *ptb = (HashBuff *) pbHashStruct;

    if(kMagic != ptb->dwMagic || sizeof(HashBuff) != ptb->cBytes)
    {
        return E_FAIL;                          // Data Corrupt
    }

    if(ppszTrueKID)
    {
        *ppszTrueKID = (BYTE *) CoTaskMemAlloc(KIDLEN+1);
        memcpy(*ppszTrueKID, ptb->KID, KIDLEN);
        (*ppszTrueKID)[KIDLEN] = 0;                  // null terminate for safety..
    }

    if(pAgeSeconds)
    {
        time_t tm;
        *pAgeSeconds = (LONG) (time(&tm) - ptb->tmCreated);
    }
    return hr;
#endif

}

/// -----------------------------------------------------------------------------
//  Are we running under a secure server?
//        return S_OK only if we trust the server registered in the graph service provider
/// ------------------------------------------------------------------------------
#include "DrmRootCert.h"    // defines for abEncDecCertRoot

#ifdef BUILD_WITH_DRM

#ifdef USE_TEST_DRM_CERT
#include "Keys_7001.h"
static const BYTE* pabCert3      = abCert7001;
static const int   cBytesCert3   = sizeof(abCert7001);
static const BYTE* pabPVK3       = abPVK7001;
static const int   cBytesPVK3    = sizeof(abPVK7001);

#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
static const BYTE* pabCert2      = abCert7001;
static const int   cBytesCert2   = sizeof(abCert7001);
static const BYTE* pabPVK2       = abPVK7001;
static const int   cBytesPVK2    = sizeof(abPVK7001);
#endif

#else   // !USE_TEST_DRM_CERT

#include "Keys_7003.h"                                  // 7003 used for client side certification
static const BYTE* pabCert3      = abCert7003;
static const int   cBytesCert3   = sizeof(abCert7003);
static const BYTE* pabPVK3       = abPVK7003;
static const int   cBytesPVK3    = sizeof(abPVK7003);

#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST
#include "Keys_7002.h"                                  // 7002 used for server side simulation
static const BYTE* pabCert2      = abCert7002;
static const int   cBytesCert2   = sizeof(abCert7002);
static const BYTE* pabPVK2       = abPVK7002;
static const int   cBytesPVK2    = sizeof(abPVK7002);
#endif

#endif
#endif  // BUILD_WITH_DRM

HRESULT
CETFilter::CheckIfSecureServer(IFilterGraph *pGraph)
{
    TimeitC ti(&m_tiAuthenticate);

    if(!(pGraph == NULL || m_pGraph == NULL || m_pGraph == pGraph)) // only allow arg to be passed in when m_pGraph is NULL
        return E_INVALIDARG;                //  -- lets us work in JoinFilterGraph().

#ifndef BUILD_WITH_DRM
    TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::CheckIfSecureServer - No Drm - not enabled"), m_FilterID) ;
    return S_OK;
#else

    TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::CheckIfSecureServer"), m_FilterID) ;

                        // basically, just makes sure we have the broadcast event service object
                        //   and if it doesn't exist, it creates it..
    HRESULT hr = S_OK;

    CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph ? m_pGraph : pGraph);
    if (spServiceProvider == NULL) {
        TRACE_1 (LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d):: Can't get service provider interface from the graph"), m_FilterID);
        return E_NOINTERFACE;
    }
    CComPtr<IDRMSecureChannel>  spSecureService;

    hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel,
                                         IID_IDRMSecureChannel,
                                         reinterpret_cast<LPVOID*>(&spSecureService));

    if(!FAILED(hr))
    {
            // Create the Client and Init the keys/certs
        //
        CComPtr<IDRMSecureChannel>  spSecureServiceClient;

        hr = DRMCreateSecureChannel( &spSecureServiceClient);
        if(spSecureServiceClient == NULL )
            hr = E_OUTOFMEMORY;

        if(!FAILED (hr) )
            hr = spSecureServiceClient->DRMSC_AtomicConnectAndDisconnect(
                        (BYTE *)pabCert3, cBytesCert3,                         // Cert
                        (BYTE *)pabPVK3,  cBytesPVK3,                          // PrivKey
                        (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot),    // PubKey
                        spSecureService);

    }

    TRACE_2(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::CheckIfSecureServer -->%s"),
        m_FilterID, S_OK == hr ? L"Succeeded" : L"Failed") ;
    return hr;
#endif

    return S_OK;
}

HRESULT
CETFilter::InitializeAsSecureClient()
{
    TimeitC ti(&m_tiAuthenticate);

#ifndef BUILD_WITH_DRM
    TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::InitializeAsSecureClient - No Drm - not enabled"), m_FilterID) ;
    return S_OK;
#else

    TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::InitializeAsSecureClient"), m_FilterID) ;

 // Create the Client and Init the keys/certs
                    //
    HRESULT hr = DRMCreateSecureChannel( &m_spDRMSecureChannel);
    if(m_spDRMSecureChannel == NULL )
        hr = E_OUTOFMEMORY;

    if( FAILED (hr) )
        m_spDRMSecureChannel = NULL;        // force the release

    if( !FAILED (hr) )
        hr = m_spDRMSecureChannel->DRMSC_SetCertificate( (BYTE *)pabCert3, cBytesCert3 );

    if( !FAILED (hr) )
        hr = m_spDRMSecureChannel->DRMSC_SetPrivateKeyBlob( (BYTE *)pabPVK3, cBytesPVK3 );

    if( !FAILED (hr) )
        hr = m_spDRMSecureChannel->DRMSC_AddVerificationPubKey( (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot) );

    TRACE_2(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::InitializeAsSecureClient -->%s"),
        m_FilterID, S_OK == hr ? L"Succeeded" : L"Failed") ;

    return hr;
#endif  // BUILD_WITH_DRM
}

/// TEST CODE ---
#ifdef FILTERS_CAN_CREATE_THEIR_OWN_TRUST

HRESULT
CETFilter::RegisterSecureServer(IFilterGraph *pGraph)
{

    TimeitC ti(&m_tiAuthenticate);

    if(!(pGraph == NULL || m_pGraph == NULL || m_pGraph == pGraph)) // only allow arg to be passed in when m_pGraph is NULL
    {
        return E_INVALIDARG;                                        //  -- lets us work in JoinFilterGraph().
        TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::RegisterSecureServer - Error - No Graph to check..."), m_FilterID) ;
     }

    HRESULT hr = S_OK;
#ifndef BUILD_WITH_DRM
    TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::RegisterSecureServer - No Drm - not enabled"), m_FilterID) ;
    return S_OK;
#else

    {
                //  Note - Only want to do this once...
        CAutoLock  cLockGlob(m_pCritSectGlobalFilt);

        TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::RegisterSecureServer Being Called"), m_FilterID) ;

        // already registered? (Error?)
        CComQIPtr<IServiceProvider> spServiceProvider(m_pGraph ? m_pGraph : pGraph);
        if (spServiceProvider == NULL) {
            //       TRACE_0 (LOG_AREA_DECRYPTER, 1, _T("CETFilter:: Can't get service provider interface from the graph"));
            TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::RegisterSecureServer Error - no Service Provider"), m_FilterID) ;
            return E_NOINTERFACE;
        }

        CComPtr<IDRMSecureChannel>  spSecureService;
        hr = spServiceProvider->QueryService(SID_DRMSecureServiceChannel,
            IID_IDRMSecureChannel,
            reinterpret_cast<LPVOID*>(&spSecureService));

        // returns E_NOINTERFACE doesn't find it  May also return E_FAIL too
        //   (VidCtrl returns E_FAIL if it's 'site' doesn't support ID_IServiceProvider)
        //  humm, perhaps check S_OK result to see if it's the right one
        if(S_OK == hr)
        {
           TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::Found existing Secure Server."),m_FilterID) ;
           return S_OK;

        }
        else               // not there, lets create it and register it
        {

            CComQIPtr<IRegisterServiceProvider> spRegServiceProvider(m_pGraph ? m_pGraph : pGraph);
            if(spRegServiceProvider == NULL)
            {
                TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::RegisterSecureServer Error - IRegisterServiceProvider not found"), m_FilterID) ;
                hr = E_NOINTERFACE;     // no service provider interface on the graph - fatal!
            }
            else
            {
                do
                {
                    // Create the Client and Init the keys/certs
                    //
                    CComPtr<IDRMSecureChannel>  spSecureServiceServer;

                    hr = DRMCreateSecureChannel( &spSecureServiceServer);
                    if(spSecureServiceServer == NULL )
                        hr = E_OUTOFMEMORY;

                    if( FAILED (hr) )
                        break;

                    hr = spSecureServiceServer->DRMSC_SetCertificate( (BYTE *)pabCert2, cBytesCert2 );
                    if( FAILED( hr ) )
                        break;

                    hr = spSecureServiceServer->DRMSC_SetPrivateKeyBlob( (BYTE *)pabPVK2, cBytesPVK2 );
                    if( FAILED( hr ) )
                        break;

                    hr = spSecureServiceServer->DRMSC_AddVerificationPubKey( (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot) );
                    if( FAILED( hr ) )
                        break;

                    // RegisterService does not addref pUnkSeekProvider
                    //               hr = pSvcProvider->RegisterService(GUID_MultiGraphHostService, GBL(spSecureServiceServer));
                    //                hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, GBL(spSecureServiceServer));
                    hr = spRegServiceProvider->RegisterService(SID_DRMSecureServiceChannel, spSecureServiceServer);
                    // spSecureServiceServer._PtrClass

                } while (FALSE);
            }
        }
     }

    if(S_OK == hr)
    {
        TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::RegisterSecureServer - Security Warning!: -  Created Self Server"), m_FilterID) ;
    } else {
        TRACE_2(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::RegisterSecureServer - Failed Creating Self SecureServer. hr = 0x%08x"), m_FilterID, hr) ;
    }
    return hr;
#endif      // BUILD_WITH_DRM
}


        // prototype of code to be placed in VidControl to check if DTFilter is trusted
HRESULT
CETFilter::CheckIfSecureClient(IUnknown *pUnk)
{
    TimeitC ti(&m_tiAuthenticate);

    if(pUnk == NULL)
        return E_INVALIDARG;

#ifndef BUILD_WITH_DRM
    TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::CheckIfSecureClient - No Drm - not enabled"), m_FilterID) ;
    return S_OK;
#else

//  TRACE_1(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::CheckIfSecureClient"), m_FilterID) ;

                        // QI for the SecureChannel interface on the Punk (hopefully the DTFilter)
    HRESULT hr = S_OK;

    CComQIPtr<IDRMSecureChannel> spSecureClient(pUnk);
    if (spSecureClient == NULL) {
//        TRACE_1 (LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%2):: Passed in pUnk doesnt support IDRMSecureChannel"),m_FilterID);
        return E_NOINTERFACE;
    }

    if(!FAILED(hr))
    {
        // Create the Server side and Init the keys/certs
        //
        CComPtr<IDRMSecureChannel>  spSecureServer;

        hr = DRMCreateSecureChannel( &spSecureServer);
        if(spSecureServer == NULL )
            hr = E_OUTOFMEMORY;

        if(!FAILED(hr))
            hr = spSecureServer->DRMSC_AtomicConnectAndDisconnect(
                (BYTE *)pabCert2, cBytesCert2,                                  // Cert
                (BYTE *)pabPVK2,  cBytesPVK2,                                   // PrivKey
                (BYTE *)abEncDecCertRoot, sizeof(abEncDecCertRoot),     // PubKey
                spSecureClient);

    }

//    TRACE_2(LOG_AREA_ENCRYPTER, 1, _T("CETFilter(%d)::CheckIfSecureClient -->%s"),
//        m_FilterID, S_OK == hr ? L"Succeeded" : L"Failed") ;
    return hr;
#endif  // BUILD_WITH_DRM
}

#endif      // FILTERS_CAN_CREATE_THEIR_OWN_TRUST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\dtfilter\rateseg.h ===
//  ============================================================================
//   RateSeg.h
//
//      Most of this code from multimedia\dshow\filters\sbe\inc\dvrutil.h
//      Consider #including it rather than all this in the future
//  ============================================================================
#ifndef __RATESEG_H__
#define __RATESEG_H__

#define TRICK_PLAY_LOWEST_RATE              (0.1)		
/*++
LINK list:

    Definitions for a double link list.     sucked from sdk\inc\msputils.h

--*/

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//
#ifndef CONTAINING_RECORD
#define CONTAINING_RECORD(address, type, field) \
    ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))
#endif


#ifndef InitializeListHead
//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }



BOOL IsNodeOnList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry);


#endif //InitializeListHead


template <class T> T Min (T a, T b)                     { return (a < b ? a : b) ; }
template <class T> T Max (T a, T b)                     { return (a > b ? a : b) ; }
template <class T> T Abs (T t)                          { return (t >= 0 ? t : 0 - t) ; }
template <class T> BOOL InRange (T val, T min, T max)   { return (min <= val && val <= max) ; }

//  ============================================================================
//  ============================================================================

template <class T>
class CTRateSegment
{
    //
    //  Given a starting PTS and a rate, this object will scale PTSs that
    //    are >= the starting PTS according to the rate.
    //
    //  The formula used to compute a scaled timestamp is the usual x-y
    //    graph with slope, where x is the input timestamp, and y is the
    //    output timestamp.  The formula is based on y(i) = m * (x(i) -
    //    x(i-1)).  In this case, m = 1/rate.  Also, since the slope does
    //    change in a segment, we compute x(i-1) once, when the rate is
    //    set.  Thus, the formula becomes
    //
    //      PTS(out) = (1/rate) * (PTS(in) - PTS(base))
    //
    //    where PTS(base) is computed as
    //
    //      PTS(base) = PTS(start) - (rate(new)/rate(last)) * (PTS(start) -
    //                      PTS(start_last)
    //
    //  Rates cannot be 0, and must fall in the <= -0.1 && >= 0.1; note that
    //      TRICK_PLAY_LOWEST_RATE = 0.1
    //

    LIST_ENTRY  m_ListEntry ;
    T           m_tPTS_start ;      //  earliest PTS for this segment
    T           m_tPTS_base ;       //  computed; base PTS for this segment
    double      m_dRate ;           //  0.5 = half speed; 2 = twice speed
    double      m_dSlope ;          //  computed; = 1/rate
    T           m_tNextSegStart ;   //  use this value to determine if segment
                                    //    applies

    public :

        CTRateSegment (
            IN  T       tPTS_start,
            IN  double  dRate,
            IN  T       tPTS_start_last = 0,
            IN  double  dRate_last      = 1
            ) : m_tNextSegStart (0)
        {
            InitializeListHead (& m_ListEntry) ;
            Initialize (tPTS_start, dRate, tPTS_start_last, dRate_last) ;
        }

        T       Start ()        { return m_tPTS_start ; }
        T       Base ()         { return m_tPTS_base ; }
        double  Rate ()         { return m_dRate ; }
        T       NextSegStart () { return m_tNextSegStart ; }

        void SetNextSegStart (IN T tNextStart)  { m_tNextSegStart = tNextStart ; }

        void
        Initialize (
            IN  T       tPTS_start,
            IN  double  dRate,
            IN  T       tPTS_base_last = 0,
            IN  double  dRate_last      = 1,
            IN  T       tNextSegStart   = 0
            )
        {
            ASSERT (::Abs <double> (dRate) >= TRICK_PLAY_LOWEST_RATE) ;

            m_dRate         = dRate ;
            m_tPTS_start    = tPTS_start ;

            SetNextSegStart (tNextSegStart) ;

            //  compute the base
            ASSERT (dRate_last != 0) ;
            m_tPTS_base = tPTS_start - (T) ((dRate / dRate_last) *
                                        (double) (tPTS_start - tPTS_base_last)) ;

            //  compute the slope
            ASSERT (dRate != 0) ;
            m_dSlope = 1 / dRate ;
        }

        void
        Scale (
            IN OUT  T * ptPTS
            )
        {
            ASSERT (ptPTS) ;
            ASSERT ((* ptPTS) >= m_tPTS_start) ;

            (* ptPTS) = (T) (m_dSlope * (double) ((* ptPTS) - m_tPTS_base)) ;
        }

        LIST_ENTRY *
        ListEntry (
            )
        {
            return (& m_ListEntry) ;
        }

        //  ================================================================

        static
        CTRateSegment *
        RecoverSegment (
            IN  LIST_ENTRY *    pListEntry
            )
        {
            CTRateSegment * pRateSegment ;

            pRateSegment = CONTAINING_RECORD (pListEntry, CTRateSegment, m_ListEntry) ;
            return pRateSegment ;
        }
} ;

//  ============================================================================
//  ============================================================================

template <class T>
class CTTimestampRate
{
    //
    //  This class hosts a list of CTRateSegments.  It does not police to make
    //    sure old segments are inserted after timestamps have been scaled out
    //    of following segments.
    //

    LIST_ENTRY          m_SegmentList ;     //  CTRateSegment list list head
    CTRateSegment <T> * m_pCurSegment ;     //  current segment; cache this
                                            //    because we'll hit this one 99%
                                            //    of the time
    T                   m_tPurgeThreshold ; //  PTS-current_seg threshold beyond
                                            //    which we purge stale segments
    int                 m_iCurSegments ;
    int                 m_iMaxSegments ;    //  we'll never queue more than this
                                            //    number; this prevents non-timestamped
                                            //    streams from having infinite
                                            //    segments that we'd never know
                                            //    to delete

    //  get a new segment; allocate for now
    CTRateSegment <T> *
    NewSegment_ (
        IN  T       tPTS_start,
        IN  double  dRate,
        IN  T       tPTS_start_last = 0,
        IN  double  dRate_last      = 1
        )
    {
        return new CTRateSegment <T> (tPTS_start, dRate, tPTS_start_last, dRate_last) ;
    }

    //  recycle; delete for now
    void
    Recycle_ (
        IN  CTRateSegment <T> * pRateSegment
        )
    {
        delete pRateSegment ;
    }

    //  purges the passed list of all CTRateSegment objects
    void
    Purge_ (
        IN  LIST_ENTRY *    pListEntryHead
        )
    {
        CTRateSegment <T> * pRateSegment ;

        while (!IsListEmpty (pListEntryHead)) {
            //  pop & recycle first in the list
            pRateSegment = CTRateSegment <T>::RecoverSegment (pListEntryHead -> Flink) ;
            Pop_ (pRateSegment -> ListEntry ()) ;
            Recycle_ (pRateSegment) ;
        }
    }

    //  pops & fixes up the next/prev pointers
    void
    Pop_ (
        IN  LIST_ENTRY *    pListEntry
        )
    {
        RemoveEntryList (pListEntry) ;
        InitializeListHead (pListEntry) ;

        ASSERT (m_iCurSegments > 0) ;
        m_iCurSegments-- ;
    }

    //  following a mid-list insertion, we must fixup following segments' base
    //    pts, at the very least
    void
    ReinitFollowingSegments_ (
        )
    {
        CTRateSegment <T> * pCurSegment ;
        CTRateSegment <T> * pPrevSegment ;

        ASSERT (m_pCurSegment) ;
        pPrevSegment = m_pCurSegment ;

        while (pPrevSegment -> ListEntry () -> Flink != & m_SegmentList) {
            pCurSegment = CTRateSegment <T>::RecoverSegment (pPrevSegment -> ListEntry () -> Flink) ;

            pCurSegment -> Initialize (
                pCurSegment -> Start (),
                pCurSegment -> Rate (),
                pPrevSegment -> Base (),
                pPrevSegment -> Rate ()
                ) ;

            pPrevSegment -> SetNextSegStart (pCurSegment -> Start ()) ;

            pPrevSegment = pCurSegment ;
        }
    }

    void
    TrimToMaxSegments_ (
        )
    {
        CTRateSegment <T> * pTailSegment ;
        LIST_ENTRY *        pTailListEntry ;

        ASSERT (m_iCurSegments >= 0) ;

        while (m_iCurSegments > m_iMaxSegments) {
            //  trim from the tail
            pTailListEntry = m_SegmentList.Blink ;
            pTailSegment = CTRateSegment <T>::RecoverSegment (pTailListEntry) ;

            Pop_ (pTailSegment -> ListEntry ()) ;
            ASSERT (m_iCurSegments == m_iMaxSegments) ;

//            TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 1,
//               TEXT ("CTTimestampRate::TrimToMaxSegments_ () : %08xh"),
//                pTailSegment) ;

            Recycle_ (pTailSegment) ;
        }
    }

    //  new segment is inserted into list, sorted by start PTS
    DWORD
    InsertNewSegment_ (
        IN  T       tPTS_start,
        IN  double  dRate
        )
    {
        CTRateSegment <T> * pNewSegment ;
        CTRateSegment <T> * pPrevSegment ;
        LIST_ENTRY *        pPrevListEntry ;
        DWORD               dw ;
        T                   tBase_prev ;
        double              dRate_prev ;

        //  assume this one will go to the head of the active list; move
        //    all others to the tail

        pNewSegment = NewSegment_ (tPTS_start, dRate) ;
        if (pNewSegment) {

            tBase_prev = 0 ;
            dRate_prev = 1 ;

            //  back down the list, from the end
            for (pPrevListEntry = m_SegmentList.Blink ;
                 pPrevListEntry != & m_SegmentList ;
                 pPrevListEntry = pPrevListEntry -> Blink
                 ) {

                pPrevSegment = CTRateSegment <T>::RecoverSegment (pPrevListEntry) ;

                //  if we have a dup, remove it (we'll never have > 1 duplicate)
                if (pPrevSegment -> Start () == tPTS_start) {

                    pPrevListEntry = pPrevListEntry -> Flink ;  //  go forwards again
                    Pop_ (pPrevListEntry -> Blink) ;            //  remove previous
                    Recycle_ (pPrevSegment) ;                   //  recycle

                    //
                    //  next one should be it
                    //

                    continue ;
                }

                //  check for right position in ordering
                if (pPrevSegment -> Start () < tPTS_start) {
                    //  found it

                    tBase_prev = pPrevSegment -> Base () ;
                    dRate_prev = pPrevSegment -> Rate () ;

                    //  fixup previous' next start field
                    pPrevSegment -> SetNextSegStart (tPTS_start) ;

                    break ;
                }
            }

            //  initialize wrt to previous
            pNewSegment -> Initialize (
                tPTS_start,
                dRate,
                tBase_prev,
                dRate_prev
                ) ;

            //  insert
            InsertHeadList (
                pPrevListEntry,
                pNewSegment -> ListEntry ()
                ) ;

            //  one more segment inserted
            m_iCurSegments++ ;

//            TRACE_4 (LOG_AREA_SEEKING_AND_TRICK, 1,
//                TEXT ("CTTimestampRate::InsertNewSegment_ () : new segment queued; %I64d ms, %2.1f; segments = %d; %08xh"),
//                ::DShowTimeToMilliseconds (tPTS_start), dRate, m_iCurSegments, pNewSegment) ;

            //  set the current segment (assume locality)
            m_pCurSegment = pNewSegment ;

            //
            //  fixup the remainder of the segments in the list
            //

            ReinitFollowingSegments_ () ;

            //  trim a segment if we must
            TrimToMaxSegments_ () ;

            dw = NOERROR ;
        }
        else {
            dw = ERROR_NOT_ENOUGH_MEMORY ;
        }

        return dw ;
    }

    BOOL
    IsInSegment_ (
        IN  T                   tPTS,
        IN  CTRateSegment <T> * pSegment
        )
    {
        BOOL    r ;

        if (pSegment -> Start () <= tPTS &&
            (pSegment -> NextSegStart () == 0 || pSegment -> NextSegStart () > tPTS)) {

            r = TRUE ;
        }
        else {
            r = FALSE ;
        }

        return r ;
    }

    void
    PurgeStaleSegments_ (
        IN  T                   tPTS,
        IN  CTRateSegment <T> * pEffectiveSegment
        )
    {
        CTRateSegment <T> * pCurSegment ;
        LIST_ENTRY *        pCurListEntry ;

        //  on the whole, we expect PTSs to monotonically increase; this means
        //    that they may drift just a bit frame-frame as in the case with
        //    mpeg-2 video, but overall they will increase; we therefore compare
        //    to our threshold and if we have segments that end earlier than
        //    the oldest PTS we expect to see, we purge it

        ASSERT (pEffectiveSegment) ;
        ASSERT (pEffectiveSegment -> Start () <= tPTS) ;

        //  if we have stale segments, and we're above the threshold into
        //    effective (current) segment, purge all stale segments
        if (pEffectiveSegment -> ListEntry () -> Blink != & m_SegmentList &&
            tPTS - pEffectiveSegment -> Start () >= m_tPurgeThreshold) {

            //  back down from the previous segment and purge the list
            for (pCurListEntry = pEffectiveSegment -> ListEntry () -> Blink;
                 pCurListEntry != & m_SegmentList ;
                 ) {

                //  recover the segment
                pCurSegment = CTRateSegment <T>::RecoverSegment (pCurListEntry) ;

                //  back down to previous
                pCurListEntry = pCurListEntry -> Blink ;

                ASSERT (pCurListEntry -> Flink == pCurSegment -> ListEntry ()) ;

//                TRACE_3 (LOG_AREA_SEEKING_AND_TRICK, 1,
//                    TEXT ("CTTimestampRate::PurgeStaleSegments_ () : %08xh, PTS = %I64d ms, segstart = %I64d ms"),
//                    pCurSegment, ::DShowTimeToMilliseconds (tPTS), ::DShowTimeToMilliseconds (pCurSegment -> Start ())) ;

                //  now pop and recycle
                Pop_ (pCurSegment -> ListEntry ()) ;
                Recycle_ (pCurSegment) ;
            }

            //  should have purged all segments that preceded the effective segmetn
            ASSERT (pEffectiveSegment -> ListEntry () -> Blink == & m_SegmentList) ;
        }

        return ;
    }

    //  returns the right segment for the PTS, if there is one; returns NULL
    //    if there is none; resets m_pCurSegment if it must (if current
    //    m_pCurSegment is stale)
    CTRateSegment <T> *
    GetSegment_ (
        IN  T   tPTS
        )
    {
        CTRateSegment <T> * pRetSegment ;
        CTRateSegment <T> * pCurSegment ;
        LIST_ENTRY *        pCurListEntry ;

        //  make sure it's within bounds
        ASSERT (m_pCurSegment) ;
        if (IsInSegment_ (tPTS, m_pCurSegment)) {
            //  99.9% code path
            pRetSegment = m_pCurSegment ;
        }
        else {
            //  need to hunt down the right segment

            //  init retval for failure
            pRetSegment = NULL ;

            //  hunt forward or backward from m_pCurSegment ?
            if (m_pCurSegment -> Start () < tPTS) {

                //  forward

                ASSERT (m_pCurSegment -> NextSegStart () != 0) ;
                ASSERT (m_pCurSegment -> NextSegStart () <= tPTS) ;

                for (pCurListEntry = m_pCurSegment -> ListEntry () -> Flink ;
                     pCurListEntry != & m_SegmentList ;
                     pCurListEntry = pCurListEntry -> Flink) {

                    pCurSegment = CTRateSegment <T>::RecoverSegment (pCurListEntry) ;

                    if (IsInSegment_ (tPTS, pCurSegment)) {
                        //  found it; reset m_pCurSegment and return it
                        m_pCurSegment = pCurSegment ;
                        pRetSegment = m_pCurSegment ;

                        break ;
                    }
                }
            }
            else {
                //  backward
                ASSERT (m_pCurSegment -> Start () > tPTS) ;

                for (pCurListEntry = m_pCurSegment -> ListEntry () -> Blink ;
                     pCurListEntry != & m_SegmentList ;
                     pCurListEntry = pCurListEntry -> Blink) {

                    pCurSegment = CTRateSegment <T>::RecoverSegment (pCurListEntry) ;

                    if (IsInSegment_ (tPTS, pCurSegment)) {
                        //  found it; reset m_pCurSegment and return it
                        m_pCurSegment = pCurSegment ;
                        pRetSegment = m_pCurSegment ;

                        break ;
                    }
                }
            }
        }

        if (pRetSegment) {
            PurgeStaleSegments_ (tPTS, pRetSegment) ;
        }

        return pRetSegment ;
    }

    public :

        CTTimestampRate (
            IN  T tPurgeThreshold,      //  purge stale segments when we get a PTS
                                        //    that is further into the current
                                        //    segment than this
            IN  int iMaxSegments
            ) : m_pCurSegment       (NULL),
                m_tPurgeThreshold   (tPurgeThreshold),
                m_iMaxSegments      (iMaxSegments),
                m_iCurSegments      (0)
        {
            InitializeListHead (& m_SegmentList) ;
        }

        ~CTTimestampRate (
            )
        {
            Clear () ;
        }

        void
        Clear (
            )
        {
            Purge_ (& m_SegmentList) ;
            ASSERT (IsListEmpty (& m_SegmentList)) ;

            m_pCurSegment = NULL ;
        }

        DWORD
        NewSegment (
            IN  T       tPTS_start,
            IN  double  dRate
            )
        {
            DWORD   dw ;

            dw = InsertNewSegment_ (tPTS_start, dRate) ;

            return dw ;
        }

        DWORD
        ScalePTS (
            IN  OUT T * ptPTS
            )
        {
            DWORD               dw ;
            CTRateSegment <T> * pSegment ;

            //  don't proceed if we've got nothing queued
            if (m_pCurSegment) {
                pSegment = GetSegment_ (* ptPTS) ;
                if (pSegment) {
                    ASSERT (IsInSegment_ ((* ptPTS), pSegment)) ;
                    pSegment -> Scale (ptPTS) ;
                    dw = NOERROR ;
                }
                else {
                    //  earlier than earliest segment
                    dw = ERROR_GEN_FAILURE ;
                }
            }
            else {
                //  leave intact; don't fail the call
                dw = NOERROR ;
            }

            return dw ;
        }

#if 0
        void
        Dump (
            )
        {
            CTRateSegment <T> * pCurSegment ;
            LIST_ENTRY *        pCurListEntry ;

            printf ("==================================\n") ;
            for (pCurListEntry = m_SegmentList.Flink;
                 pCurListEntry != & m_SegmentList;
                 pCurListEntry = pCurListEntry -> Flink
                 ) {

                pCurSegment = CTRateSegment <T>::RecoverSegment (pCurListEntry) ;
                printf ("start = %-5d; rate = %-2.1f; base = %-5d; next = %-5d\n",
                    pCurSegment -> Start (),
                    pCurSegment -> Rate (),
                    pCurSegment -> Base (),
                    pCurSegment -> NextSegStart ()
                    ) ;
            }
        }
#endif
} ;


#endif  // __RATESEG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\etfilter\etfiltprops.cpp ===
//==========================================================================;
//  ETFiltProps.cpp
//
//			Property Sheet for Encrypter/Tagger Filter
//
// Copyright (c) 2002  Microsoft Corporation.  All Rights Reserved.
//	------------------------------------------------------------------------

#include "EncDecAll.h"
#include "EncDec.h"				//  compiled from From IDL file
#include "ETFilter.h"			
#include "ETFiltProps.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Filter property page code
//
CUnknown * WINAPI 
CETFilterEncProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CETFilterEncProperties(_T(ET_PROPPAGE_TAG_NAME),
											  lpunk, 
											  phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CETFilterEncProperties::CETFilterEncProperties(
			IN  TCHAR		*   pClassName,
			IN	IUnknown	*	pIUnknown, 
			HRESULT			*	phr)
    : CBasePropertyPage(pClassName, 
						pIUnknown,
						IDD_ETFILTER_ENCPROPPAGE, 
						IDS_ETFILTER_ENCPROPNAME
						),
    m_hwnd(NULL),
	m_pIETFilter(NULL)
{
	ASSERT(phr);
	*phr = S_OK;

/*	INITCOMMONCONTROLSEX icce;					// needs Comctl32.dll
	icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icce.dwICC = ICC_INTERNET_CLASSES;
	BOOL fOK = InitCommonControlsEx(&icce);
	if(!fOK)
		*phr = E_FAIL;
*/
	return;
}

CETFilterEncProperties::~CETFilterEncProperties()
{
	return;
}

HRESULT CETFilterEncProperties::OnConnect(IUnknown *pUnknown) 
{
	ASSERT(!m_pIETFilter);  // pUnk is to CCCTFilter, not CDShowCCTFilter...
    HRESULT hr = CBasePropertyPage::OnConnect (pUnknown) ;

	if(!FAILED(hr))
		hr = pUnknown->QueryInterface(IID_IETFilter, (void**) &m_pIETFilter);

	if(FAILED(hr)) {
		m_pIETFilter = NULL;
		return hr;
	}
	return S_OK;
}

HRESULT CETFilterEncProperties::OnDisconnect() 
{
  HRESULT hr = S_OK;
  if (m_pIETFilter)
	  m_pIETFilter->Release(); 
   m_pIETFilter = NULL;

   return CBasePropertyPage::OnDisconnect () ;
}

HRESULT CETFilterEncProperties::OnActivate(void)
{
   UpdateFields();
   return S_OK;
}

#define _SETBUT(buttonIDC, grfFlag)	SetDlgItemTextW(m_hwnd, (buttonIDC), (lGrfHaltFlags & (grfFlag)) ? L"Stopped" : L"Running");

void CETFilterEncProperties::UpdateFields() 
{
	if(!m_pIETFilter) return;		// haven't inited yet....
	
/*	long lGrfHaltFlags;
	m_pIETFilter->get_HaltFlags(&lGrfHaltFlags);

	NCCT_Mode lgrfCCMode;
	m_pIETFilter->get_CCMode(&lgrfCCMode);
*/

/*
	HWND hCBox = GetDlgItem(m_hwnd, IDC_COMBO_CCMODE);
	if(0 == hCBox)
		return;

	int iItemSelected = -1;

    SendMessage(hCBox, CB_RESETCONTENT, 0, 0);		// initalize the list

	int iItem = 0;
	if(lgrfCCMode == NCC_Mode_CC1) iItemSelected = iItem;
	SendMessage(hCBox, CB_INSERTSTRING,  -1, (LPARAM) _T("CC1"));
	SendMessage(hCBox, CB_SETITEMDATA, iItem, (LPARAM) NCC_Mode_CC1); iItem++;

	int cItems = (int) SendMessage(hCBox, CB_GETCOUNT, 0, 0);			

		// Place the word in the selection field. 
    SendMessage(hCBox,CB_SETCURSEL,	  iItemSelected<0 ? 0 : iItemSelected, 0);			// reselect the first one... (should be IPSinks!)
*/
	}

HRESULT CETFilterEncProperties::OnDeactivate(void)
{
    return CBasePropertyPage::OnDeactivate () ;
}


HRESULT CETFilterEncProperties::OnApplyChanges(void)
{
   return CBasePropertyPage::OnApplyChanges () ;
}


INT_PTR 
CETFilterEncProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{
    switch (uMsg) {

    case WM_INITDIALOG:
    {
        ASSERT (m_hwnd == NULL) ;
        m_hwnd = hwnd ;
        break;
    }

    //  see ::OnDeactivate()'s comment block
    case WM_DESTROY :
    {
        m_hwnd = NULL ;
        break ;
    }

    case WM_COMMAND:

        if (HIWORD(wParam) == EN_KILLFOCUS) {
//           m_bDirty = TRUE;
 //          if (m_pPageSite)
 //              m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }

/*
		if(LOWORD(wParam) == IDC_COMBO_CCMODE)
		{
			HWND hCBox = GetDlgItem(hwnd, IDC_COMBO_CCMODE);
			if(0 == hCBox)
				break;
			long iItem = SendMessage(hCBox, CB_GETCURSEL, 0, 0);
			long iVal  = SendMessage(hCBox, CB_GETITEMDATA, iItem, 0);
			if(iVal != lgrfCCMode)
			{
				NCCT_Mode cMode = (NCCT_Mode) iVal;
				m_pIETFilter->put_CCMode(cMode);
			}
		}
*/
    }	// end uMsg switch

   return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

// ---------------------------------------------------------------------------
//
// Tag property page code
//
CUnknown * WINAPI 
CETFilterTagProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CETFilterTagProperties(_T(ET_PROPPAGE_TAG_NAME),
											  lpunk, 
											  phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CETFilterTagProperties::CETFilterTagProperties(
			IN  TCHAR		*   pClassName,
			IN	IUnknown	*	pIUnknown, 
			HRESULT			*	phr)
    : CBasePropertyPage(pClassName, 
						pIUnknown,
						IDD_ETFILTER_TAGSPROPPAGE, 
						IDS_ETFILTER_TAGSPROPNAME
						),
    m_hwnd(NULL),
	m_pIETFilter(NULL)
{
    TRACE_CONSTRUCTOR (TEXT ("CETFilterTagProperties")) ;
	
	ASSERT(phr);
	*phr = S_OK;

/*	INITCOMMONCONTROLSEX icce;					// needs Comctl32.dll
	icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icce.dwICC = ICC_INTERNET_CLASSES;
	BOOL fOK = InitCommonControlsEx(&icce);
	if(!fOK)
		*phr = E_FAIL;
*/
	return;
}


CETFilterTagProperties::~CETFilterTagProperties()
{
	return;
}

HRESULT CETFilterTagProperties::OnConnect(IUnknown *pUnknown) 
{
	ASSERT(!m_pIETFilter);
	HRESULT hr = pUnknown->QueryInterface(IID_IETFilter, (void**) &m_pIETFilter);
	if (FAILED(hr)) {
		m_pIETFilter = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CETFilterTagProperties::OnDisconnect() 
{
	if (!m_pIETFilter)
      return E_UNEXPECTED;
   m_pIETFilter->Release(); 
   m_pIETFilter = NULL;
   return S_OK;
}

HRESULT CETFilterTagProperties::OnActivate(void)
{
   UpdateFields();
   return S_OK;
}

void CETFilterTagProperties::UpdateFields() 
{
	HRESULT hr=S_OK;
	

	if(!m_pIETFilter)
		return;
/*

	CComBSTR bstrFakeStats;
	hr = m_pIETFilter->GetStats(&bstrFakeStats);		// hacky way to send a fixed length string
	if(FAILED(hr))
		return;

	if(NULL == bstrFakeStats.m_str)
		return;

	CCTStats *pcctStats = (CCTStats *) bstrFakeStats.m_str;

	SetDlgItemInt(m_hwnd, IDC_TS_CB0,					pcctStats->m_cbData[0],	true);
	SetDlgItemInt(m_hwnd, IDC_TS_CB1,					pcctStats->m_cbData[1],	true);

*/
}

HRESULT CETFilterTagProperties::OnDeactivate(void)
{
	return S_OK;
}


HRESULT CETFilterTagProperties::OnApplyChanges(void)
{
	return S_OK;
}


INT_PTR CETFilterTagProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{
	HRESULT hr = S_OK;

    switch (uMsg) {
    case WM_INITDIALOG:
    {
        ASSERT (m_hwnd == NULL) ;
        m_hwnd = hwnd ;
        const UINT uWait = 1000;
        SetTimer(m_Dlg, 1, uWait, NULL);
        break;
    }

    //  see ::OnDeactivate()'s comment block
    case WM_DESTROY :
    {
        m_hwnd = NULL;
        KillTimer(m_Dlg, 1);
        break ;
    }

    case WM_TIMER:
    {
        UpdateFields();
        break;
    }

    case WM_COMMAND:
	{
        if (HIWORD(wParam) == EN_KILLFOCUS) {
		}

/*		if(LOWORD(wParam) == IDC_ETTAGS_RESET)
		{

			if(!m_pIETFilter)
				break;

			try {
				hr = m_pIETFilter->InitStats();		// set them all to zero...
			}
			catch(const _com_error& e)
			{
			//	printf("Error 0x%08x): %s\n", e.Error(), e.ErrorMessage());
				hr = e.Error();
			}

			if(!FAILED(hr))
				UpdateFields();
		}
*/
		break;
	}

	default:
		break;

	}
	return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\encdec\inc\attrblock.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        AttrBlock.h

    Abstract:

        Attributed Media Block data block definitions.

    Author:

        John Bradstreet (johnbrad)

    Revision History:

        07-Mar-2002    created

  
  Caution - don't mix Subclassed classes with non subclassed types in the same subblock


--*/

#ifndef __AT