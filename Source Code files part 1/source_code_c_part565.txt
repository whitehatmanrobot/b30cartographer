ount();
                        deltaTime = afterTime - beforeTime;
                        }
                    }
                }                           /* not looping */
            else { // playing not runonce, check for sound termination
                bool complete = 
                    RenderCheckComplete(metaDev, bufferElement)?true:false;

                if(complete)
                    TriggerEndEvent();

                if((!AVPathContains(path, RUNONCE_NODE)) && complete) {
                    RenderCleanupBuffer(metaDev, bufferElement);
                    bufferElement->_valid = FALSE;

    #if _DEBUG
    #if _USE_PRINT
                    // Check to avoid AVPathPrintString call
                    if (IsTagEnabled(tagSoundPath)) {
                        TraceTag((tagSoundReaper1,
                                  "LeafSound::Render found <%s> stopped",
                                  AVPathPrintString2(bufferElement->GetPath())));
                    }
    #endif
    #endif

                    // XXX we really should notify the server too, so it can prune
                    //     and process done!
                }
            }
        }

#ifdef THREADED
#else
    // Well, it is like this.  Only synthesizers used this method, and
    // this method is now being called from the other thread.
    if ((renderMode==RENDER_MODE) || (renderMode==MUTE_MODE))
         RenderSamples(metaDev, path);  // xfer samples as needed
#endif /* THREADED */
}
#endif /* OLD_SOUND_CODE */

#if _USE_PRINT
ostream&
operator<<(ostream& s, Sound *sound)
{
    return sound->Print(s);
}
#endif

SoundInstance *
CreateSoundInstance(LeafSound *snd, TimeXform tt)
{
    return snd->CreateSoundInstance(tt);
}

class TxSound : public Sound {
  public:
    TxSound(LeafSound *snd, TimeXform tt) : _snd(snd), _tt(tt) {}

    // NOTE: TxSound always allocated on GCHeap
    ~TxSound() {
        SoundGoingAway(this);
        // ViewGetSoundInstanceList()->Stop(this);
    }

    virtual void Render(GenericDevice& dev) {
        // TODO: this will be gone
        if(dev.GetDeviceType() != SOUND_DEVICE) {
            _snd->Render(dev); // just descend!
        } else { 
            Assert(ViewGetSoundInstanceList());
        
            SoundInstance *s =
                ViewGetSoundInstanceList()->GetSoundInstance(this);

            s->CollectAttributes(SAFE_CAST(MetaSoundDevice *, &dev));
        }
    }

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "(" << _snd << "," << _tt << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        Sound::DoKids(proc);
        (*proc)(_snd);
        (*proc)(_tt);
    }

  protected:
    LeafSound *_snd;
    TimeXform _tt;
};

Sound *
NewTxSound(LeafSound *snd, TimeXform tt)
{
    return NEW TxSound(snd, tt);
}

void
InitializeModule_Sound()
{
    silence = NEW SilentSound; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\dainit.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#include "headers.h"
#include "..\apeldbg\debug.h"

extern void STLInit();
extern void STLDeinit();

SysInfo sysInfo;

bool DALibStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
#ifdef _DEBUG
        // init the debug Trace mech.
        InitDebug(hInstance,NULL);

#endif
        STLInit();

        sysInfo.Init();

    } else if (dwReason == DLL_PROCESS_DETACH) {

        STLDeinit();

    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\malloc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "daheap.h"

extern "C" void * __cdecl malloc( size_t size )
{
    return HeapAlloc(hGlobalHeap,0,size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\free.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "daheap.h"

extern "C" void __cdecl free( void * p )
{
    HeapFree(hGlobalHeap,0,p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\memmove.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

extern "C" void *memmove( void *dest, const void *src, size_t count )
{
    MoveMemory(dest,src,count);
    return dest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\new.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#if !_DEBUGMEM

extern "C" void * __cdecl malloc( size_t size );

void * operator new( size_t cb )
{
    return malloc(cb);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\dllmain.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_DADllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
        if (!GetVersionEx(&versionInfo)) {
            ZeroMemory(&versionInfo,sizeof(versionInfo));
        }
    }

    return _DllMainCRTStartup(hInstance,dwReason,lpReserved);
}

#if 0
//#ifdef _NO_CRT
//#define WINMAINNAME DllMain
//#else
#define WINMAINNAME _DllMainCRTStartup
//#endif

extern "C" BOOL WINAPI WINMAINNAME (HINSTANCE hInstance,
                                    DWORD dwReason,
                                    LPVOID lpReserved);

HANDLE hGlobalHeap = NULL;

bool HeapInit()
{
    hGlobalHeap = HeapCreate(0,0x1000,0);

    return hGlobalHeap != NULL;
}

void HeapDeinit()
{
    if (hGlobalHeap) {
        HeapDestroy(hGlobalHeap);
        hGlobalHeap = NULL;
    }
}

extern "C" BOOL WINAPI
_DllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
        if (!HeapInit())
            return FALSE;

        if (!WINMAINNAME(hInstance,dwReason,lpReserved)) {
            HeapDeinit();
            return FALSE;
        }

        return TRUE;
      case DLL_PROCESS_DETACH:
        {
            BOOL b = WINMAINNAME(hInstance,dwReason,lpReserved);
            HeapDeinit();
            return b;
        }
      default:
        return WINMAINNAME(hInstance,dwReason,lpReserved);
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\purevirt.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

extern "C" int __cdecl _purecall()
{
    DebugBreak();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\realloc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "daheap.h"

extern "C" void * __cdecl realloc( void * pv, size_t newsize )
{
    return HeapReAlloc(hGlobalHeap,0,pv,newsize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <dalibc.h>

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\idl\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\xlock.cpp ===
/***
*xlock.cpp - thread lock class
*
*       Copyright (c) 1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Define lock class used to make STD C++ Library thread-safe.
*
*Revision History:
*       08-28-96  GJF   Module created, MGHMOM.
*
*******************************************************************************/

#include "headers.h"
#include <xstddef>
    
static CRITICAL_SECTION _CritSec;

void
STLInit()
{
//    InitializeCriticalSection( &_CritSec );
}

void
STLDeinit()
{
//    DeleteCriticalSection( &_CritSec );
}

/*
namespace std {
_Lockit::_Lockit()
{
    EnterCriticalSection( &_CritSec );
}

_Lockit::~_Lockit()
{
    LeaveCriticalSection( &_CritSec );
}

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\dll\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "dalite.h"
#include "comutil.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\include\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\sysinfo.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

    This file implements the methods for the SysInfo class, which maintains
    global information about the current runtime system.

*******************************************************************************/

#include "headers.h"
#include "windows.h"


int DeduceD3DLevel (OSVERSIONINFO&);
LARGE_INTEGER GetFileVersion (LPSTR szPath);



/*****************************************************************************
This method initializes the system info object.  It is called on startup in
DALibC.
*****************************************************************************/

void SysInfo::Init (void)
{
    // Load the OS version information.

    _osVersion.dwOSVersionInfoSize = sizeof(_osVersion);

    if (!GetVersionEx(&_osVersion)) {
        ZeroMemory (&_osVersion, sizeof(_osVersion));
    }

    // Initialize Member Variables

    _versionD3D   = -1;
    _versionDDraw = -1;
}



/*****************************************************************************
This method returns true if the current OS is NT-based.
*****************************************************************************/

bool SysInfo::IsNT (void)
{
    return _osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT;
}



/*****************************************************************************
This method returns true if the current OS is windows-based (Win95 or Win98).
*****************************************************************************/

bool SysInfo::IsWin9x (void)
{
    return _osVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
}



/*****************************************************************************
This method returns the MAJOR version of the OS.
*****************************************************************************/

DWORD SysInfo::OSVersionMajor (void)
{
    return _osVersion.dwMajorVersion;
}

/*****************************************************************************
This method returns the MINOR version of the OS.
*****************************************************************************/

DWORD SysInfo::OSVersionMinor (void)
{
    return _osVersion.dwMinorVersion;
}

/*****************************************************************************
This method returns the D3D version installed on the system.  Currently it
only returns 0 for earlier than DX3, or 3 for DX3 or later.
*****************************************************************************/

int SysInfo::VersionD3D (void)
{
    // If we've not yet examined the version of D3D on the system, check it now.

    if (_versionD3D < 0)
        _versionD3D = DeduceD3DLevel (_osVersion);

    return _versionD3D;
}



/*****************************************************************************
This method returns the version of DDraw, based on the file version of
DDRAW.DLL.  This method returns 3 for DDraw 3 or earlier, or N for DDRaw N
(N being 5 or later).
*****************************************************************************/

int SysInfo::VersionDDraw (void)
{
    // Only get the version if we haven't already

    if (_versionDDraw < 0) 
    {
        LARGE_INTEGER filever = GetFileVersion ("ddraw.dll");

        int n = LOWORD (filever.HighPart);

        if (n <= 4)
            _versionDDraw = 3;    // DDraw 3 or earlier
        else
            _versionDDraw = n;    // DDraw 5 or later
    }

    return _versionDDraw;
}



/*****************************************************************************
This function deduces the level of D3D on the current system.  It either
returns 0 (for pre-DX3) or 3 (for DX3+).  This is somewhat tricky since DXMini
installs some DX3 components, but leaves D3D at level 2.
*****************************************************************************/

typedef HRESULT (WINAPI *DIRECTINPUTCREATE)
                (HINSTANCE, DWORD, void**, void**);

int DeduceD3DLevel (OSVERSIONINFO &osver)
{
    // The D3D version has not yet been determined.  First look at the OS type.

    if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        // If this is NT3 or less, there's no D3D; if it's NT5, then it's at
        // least DX3.

        if (osver.dwMajorVersion < 4)
        {
            return 0;
        }
        else if (osver.dwMajorVersion > 4)
        {
            return 3;
        }

        // To check for DX3+, we need to check to see if DirectInput is on the
        // system.  If it is, then we're at DX3+.  (Note that both D3Dv3 and
        // DInput are absent from DXMini installs.)

        HINSTANCE diHinst = LoadLibrary ("DINPUT.DLL");

        if (diHinst == 0)
            return 0;

        DIRECTINPUTCREATE diCreate = (DIRECTINPUTCREATE)
            GetProcAddress (diHinst, "DirectInputCreateA");

        FreeLibrary (diHinst);

        if (diCreate == 0)
            return 0;

        return 3;
    }
    else if (osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        // If we're on Win98, then we know we have at least DX5.

        if (osver.dwMinorVersion > 0)
            return 3;

        // We're on Win95.  Get the version of D3DRM.DLL to check the version.

        LARGE_INTEGER rm_filever = GetFileVersion ("d3drm.dll");

        if (rm_filever.HighPart > 0x00040003)
        {
            // Greater than DX2.

            return 3;
        }
        else if (rm_filever.HighPart == 0x00040002)
        {
            // Special DXMini install with DX3 drivers (but not rasterizers)

            return 3;
        }
        else
        {
            // D3D missing or pre DX3.

            return 0;
        }
    }
   
    // Unknown OS

    return 0; 
}



/*****************************************************************************
This function returns the file version of a particular system file.
*****************************************************************************/

LARGE_INTEGER GetFileVersion (LPSTR szPath)
{
    LARGE_INTEGER li;
    int     size;
    DWORD   dw;

    ZeroMemory(&li, sizeof(li));

    if (size = (int)GetFileVersionInfoSize(szPath, &dw)) 
    {
        LPVOID vinfo;

        if (vinfo = (void *)LocalAlloc(LPTR, size)) 
        {
            if (GetFileVersionInfo(szPath, 0, size, vinfo)) 
            {
                VS_FIXEDFILEINFO *ver=NULL;
                UINT              cb = 0;
                LPSTR             lpszValue=NULL;

                if (VerQueryValue(vinfo, "\\", (void**)&ver, &cb))
                {
                    if (ver)
                    {
                        li.HighPart = ver->dwFileVersionMS;
                        li.LowPart  = ver->dwFileVersionLS;
                    }
                }
            }
            LocalFree((HLOCAL)vinfo);
        }
    }
    return li;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\strfns.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#include "headers.h"
#include <malloc.h>

// Copied from ATL

#define USES_CONVERSION int _convert

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHelper((LPSTR) alloca(_convert), lpw, _convert)))

LPSTR W2AHelper(LPSTR lpa, LPCWSTR lpw, int size)
{
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, size, NULL, NULL);
    return lpa;
}

// These are all copied from SHLWAPI
//#define OFFSETOF(x)     ((UINT)(x))

/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}


__inline BOOL ChrCmpW_inline(WORD w1, WORD wMatch)
{
    return(!(w1 == wMatch));
}

/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
    }
    else
        sz1[1] = '\0';

    *(WORD FAR *)sz2 = wMatch;
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
}

BOOL ChrCmpIW(WORD w1, WORD wMatch)
{
    WCHAR sz1[2], sz2[2];

    sz1[0] = w1;
    sz1[1] = '\0';
    sz2[0] = wMatch;
    sz2[1] = '\0';

    return StrCmpIW(sz1, sz2);
}


LPWSTR StrCpyW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;

    while (*psz1++ = *psz2++)
        ;

    return psz;
}


LPWSTR StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax)
{
    LPWSTR psz = psz1;

    if (0 < cchMax)
    {
        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if ( !(*psz1++ = *psz2++) )
                break;
        }

        if (0 == cchMax)
            *psz1 = '\0';
    }

    return psz;
}


LPWSTR StrCatW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;

    while (0 != *psz1)
        psz1++;

    while (*psz1++ = *psz2++)
        ;

    return psz;
}

/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    for ( ; lpStart < lpEnd; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

int StrCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    if (sysInfo.IsNT())
    {
        return lstrcmpW(pwsz1, pwsz2);
    }
    else
    {
        USES_CONVERSION;
        
        LPSTR psz1 = W2A(pwsz1);
        LPSTR psz2 = W2A(pwsz2);
        return lstrcmpA(psz1, psz2);
    }
}

int 
StrCmpIW(LPCWSTR pwsz1,
         LPCWSTR pwsz2)
{
    int iRet;

    if (sysInfo.IsNT())
    {
        return lstrcmpiW(pwsz1, pwsz2);
    }
    else
    {
        USES_CONVERSION;
        
        LPSTR psz1 = W2A(pwsz1);
        LPSTR psz2 = W2A(pwsz2);
        return lstrcmpiA(psz1, psz2);
    }
}

/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 */
int _StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar, BOOL fMBCS)
{
    LPCSTR lpszEnd = lpStr1 + nChar;
    char sz1[4];
    char sz2[4];

    if (fMBCS) {
        for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1 = AnsiNext(lpStr1), lpStr2 = AnsiNext(lpStr2)) {
            WORD w1;
            WORD w2;
    
            // If either pointer is at the null terminator already,
            // we want to copy just one byte to make sure we don't read 
            // past the buffer (might be at a page boundary).
    
            w1 = (*lpStr1) ? *(UNALIGNED WORD *)lpStr1 : 0;
            w2 = (*lpStr2) ? *(UNALIGNED WORD *)lpStr2 : 0;
    
            // (ChrCmpA returns FALSE if the characters match)
    
            // Do the characters match?
            if (ChrCmpA_inline(w1, w2)) 
            {
                // No; determine the lexical value of the comparison
                // (since ChrCmp just returns true/false).
    
                // Since the character may be a DBCS character; we
                // copy two bytes into each temporary buffer 
                // (in preparation for the lstrcmp call).
    
                (*(WORD *)sz1) = w1;
                (*(WORD *)sz2) = w2;
    
                // Add null terminators to temp buffers
                *AnsiNext(sz1) = 0;
                *AnsiNext(sz2) = 0;
                return lstrcmpA(sz1, sz2);
            }
        }
    } else {
        for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
            if (*lpStr1 != *lpStr2) {
                // No; determine the lexical value of the comparison
                // (since ChrCmp just returns true/false).
                sz1[0] = *lpStr1;
                sz2[0] = *lpStr2;
                sz1[1] = sz2[1] = '\0';
                return lstrcmpA(sz1, sz2);
            }
        }
    }

    return 0;
}

int StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    CPINFO cpinfo;
    return _StrCmpNA(lpStr1, lpStr2, nChar, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

int StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
    WCHAR sz1[2];
    WCHAR sz2[2];
    int i;
    LPCWSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
        i = ChrCmpW_inline(*lpStr1, *lpStr2);
        if (i) {
            int iRet;

            sz1[0] = *lpStr1;
            sz2[0] = *lpStr2;
            sz1[1] = TEXT('\0');
            sz2[1] = TEXT('\0');
            iRet = StrCmpW(sz1, sz2);
            return iRet;
        }
    }

    return 0;
}

/*
 * StrCmpNI     - Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */
int StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    int i;
    LPCSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); (lpStr1 = AnsiNext(lpStr1)), (lpStr2 = AnsiNext(lpStr2))) {
        WORD w1;
        WORD w2;

        // If either pointer is at the null terminator already,
        // we want to copy just one byte to make sure we don't read 
        // past the buffer (might be at a page boundary).

        w1 = (*lpStr1) ? *(UNALIGNED WORD *)lpStr1 : 0;
        w2 = (UINT)(IsDBCSLeadByte(*lpStr2)) ? *(UNALIGNED WORD *)lpStr2 : (WORD)(BYTE)(*lpStr2);

        i = ChrCmpIA(w1, w2);
        if (i)
            return i;
    }
    return 0;
}

int StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
    int i;
    LPCWSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
        i = ChrCmpIW(*lpStr1, *lpStr2);
        if (i) {
            return i;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"
#include "src\factory.h"
#include "dartapi.h"

DeclareTag(tagLockCount,"COM","Lock count");

DAComModule _Module;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_DALFactory, CDALFactory)
END_OBJECT_MAP()

HINSTANCE  hInst;
bool bFailedLoad = false;

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_DALDllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_DETACH) {
        // Call the routines in reverse order of initialization
        BOOL r = _DllMainCRTStartup(hInstance,dwReason,lpReserved);
        r = DALibStartup(hInstance,dwReason,lpReserved) && r;

        return r;
    } else {
        // In everything except DLL_PROCESS_DETACH call DALibStartup first
        return (DALibStartup(hInstance,dwReason,lpReserved) &&
                _DllMainCRTStartup(hInstance,dwReason,lpReserved));
    }
}

#define EXCEPTION(t) (GetExceptionCode() == t ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )

LONG
DAComModule::Lock()
{
    // Can't depend on value return from Lock to be accurate.  Since
    // the CRConnect can be called multiple times w/o a problem simply
    // check the internal variable to see if it is 0.  This should
    // never cause anything except multiple calls to CRConnect
    
    bool bNeedConnect = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    TraceTag((tagLockCount,
              "DAComModule::Lock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (bNeedConnect) {
        __try {
            CRConnect(hInst);
        } __except (  EXCEPTION_EXECUTE_HANDLER ) {
            bFailedLoad = true;
        }
    }

    return l;
}

LONG
DAComModule::Unlock()
{
    LONG l = CComModule::Unlock();

    TraceTag((tagLockCount,
              "DAComModule::Unlock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (l) return l;
    if (!bFailedLoad)
        CRDisconnect(hInst);
    return 0;
}

#if DEVELOPER_DEBUG
#include <map>

typedef std::map<void *, const char *> ObjectMap;
ObjectMap *objMap = NULL;

void
DAComModule::AddComPtr(void *ptr, const char * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::DumpObjectList()
{
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString ("DATxD.DLL: Detected unfreed COM pointers\n");
            OutputDebugString ("Listing pointers and types:\n");
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                char buf[1024];

                wsprintf(buf, "%#x:", (*i).first);
                OutputDebugString(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString("\n");
            }
        }
             
        LeaveCriticalSection(&m_csObjMap) ;
    }
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}

#endif
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);

        // For APELDBG
        RESTOREDEFAULTDEBUGSTATE;

        _Module.Init(COMObjectMap, hInstance);

#if DEVELOPER_DEBUG
        objMap = new ObjectMap;
#endif
    } else if (dwReason == DLL_PROCESS_DETACH) {
#if DEVELOPER_DEBUG
        DumpCOMObjectList();
        
        delete objMap;
        objMap = NULL;
#endif
        
        _Module.Term();
        
#if _DEBUG
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
#if _DEBUGMEM
        TraceTag((tagLeaks, "\n[%s] unfreed memory:", buf));
        DUMPMEMORYLEAKS;
#endif

        // de-initialize the debug trace info.
        DeinitDebug();
#endif
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    TraceTag((tagLockCount,
              "DllCanUnloadNow - lockcount - %d, com count - %d",
              _Module.GetLockCount(),
              objMap->size()));
    
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

#ifdef _DEBUG
static bool breakDialog = false ;
DeclareTag(tagDebugBreak, "!Debug", "Breakpoint on entry to DLL");
#endif

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _DEBUG
    if (!breakDialog && IsTagEnabled(tagDebugBreak)) {
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
        MessageBox(NULL,buf,"DAL - Creating first COM Object",MB_OK|MB_SETFOREGROUND) ;
        breakDialog = true;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


#if _DEBUG
STDAPI_(void)
DoTraceTagDialog(HWND hwndStub,
                 HINSTANCE hAppInstance,
                 LPWSTR lpwszCmdLine,
                 int nCmdShow)
{
    DoTracePointsDialog(true);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\include\resource.h ===
/*******************************************************************************

Copyright (c) 1998_98 Microsoft Corporation

Abstract:

    DALite Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define RESID_TYPELIB           1

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\include\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for dalite.dll
*******************************************************************************/

#ifndef DAL_HEADERS_HXX
#define DAL_HEADERS_HXX

/* Standard */
#include <math.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#include "apeldbg/apeldbg.h"

// ATL - needs to be before windows.h
#include "dalatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

/* C++ Replace DLL */
#include "dalibc.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\include\dalatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _LMATL_H
#define _LMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#define _ATL_STATIC_REGISTRY 1

#ifdef _DEBUG
inline void _cdecl AtlTrace2(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace2
#endif

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DEVELOPER_DEBUG
    void AddComPtr(void *ptr, const char * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#if _DEBUG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DEVELOPER_DEBUG
#if _DEBUG
        _Module.AddComPtr(this, GetName());
#else
        _Module.AddComPtr(this, NULL);
#endif
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DEVELOPER_DEBUG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;

// END OF COPIED CODE
// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

extern bool bFailedLoad;

#endif /* _LMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\include\util.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _UTIL_H
#define _UTIL_H

template <class T>
class CRPtr
{
  public:
    typedef T _PtrClass;
    CRPtr() { p = NULL; }
    CRPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    CRPtr(const CRPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    ~CRPtr() {
        CRReleaseGC(p);
    }
    void Release() {
        CRReleaseGC(p);
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const CRPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            CRAddRefGC(lp);

        CRReleaseGC(p);

        p = lp;

        return lp;
    }
};

class CRLockGrabber
{
  public:
    CRLockGrabber() { CRAcquireGCLock(); }
    ~CRLockGrabber() { CRReleaseGCLock(); }
};


class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool allowNullArray = false);
    ~SafeArrayAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    IUnknown **GetArray() { return _isVar?_allocArr:_ppUnk; }

    bool IsOK() { return !_failed; }
  protected:
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        IUnknown ** _ppUnk;
        void * _v;
    };
    
    VARTYPE _vt;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    CComVariant _retVar;
    bool _failed;
    IUnknown ** _allocArr;
};

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

#endif /* _UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\rsrc\makefile.inc ===
dalite.rc : $(TARGETPATH)\$(TARGET_DIRECTORY)\dalite.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\bvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _BVR_H
#define _BVR_H

#include "factory.h"

class CDALTrack;
class CDALBehavior;

class CallBackData;
typedef std::list<CallBackData *> CallBackList;

class ATL_NO_VTABLE CDALBehavior
    : public CComObjectRootEx<CComSingleThreadModel>,
      public IDALBehavior
{
  public:
    CDALBehavior();
    ~CDALBehavior();

    static HRESULT WINAPI
        InternalQueryInterface(CDALBehavior* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);

    HRESULT GetID(long *);
    HRESULT SetID(long);
        
    HRESULT GetDuration(double *);
    HRESULT SetDuration(double);
        
    HRESULT GetRepeat(long *);
    HRESULT SetRepeat(long);
        
    HRESULT GetBounce(VARIANT_BOOL *);
    HRESULT SetBounce(VARIANT_BOOL);
        
    HRESULT GetEventCB(IDALEventCB **);
    HRESULT SetEventCB(IDALEventCB *);
        
    HRESULT GetTotalTime(double *);
    HRESULT SetTotalTime(double);
        
    HRESULT GetEaseIn(float *);
    HRESULT SetEaseIn(float);

    HRESULT GetEaseInStart(float *);
    HRESULT SetEaseInStart(float);

    HRESULT GetEaseOut(float *);
    HRESULT SetEaseOut(float);

    HRESULT GetEaseOutEnd(float *);
    HRESULT SetEaseOutEnd(float);

    virtual HRESULT Error() = 0;

    CRBvrPtr GetBvr() { return m_bvr; }
    long GetID() { return m_id; }
    double GetDuration() { return m_duration; }
    double GetTotalDuration() { return m_totalduration; }
    double GetRepeatDuration() { return m_repduration; }
    long GetRepeat() { return m_repeat; }
    bool GetBounce() { return m_bBounce; }
    IDALEventCB * GetEventCB() { return m_eventcb; }
    float GetEaseIn() { return m_easein; }
    float GetEaseInStart() { return m_easeinstart; }
    float GetEaseOut() { return m_easeout; }
    float GetEaseOutEnd() { return m_easeout; }
    
    virtual CRBvrPtr Start();

    // This will call all the behaviors which are currently running
    // with the given event.  This is used when the track needs to
    // process a specific event like Pause/Resume/Stop/Play.
    
    // gTime is the global time that corresponds to 0 local time of
    // the behavior
    
    bool ProcessEvent(CallBackList & l,
                      double gTime,
                      double time,
                      bool bFirstTick,
                      DAL_EVENT_TYPE et);
    
    virtual bool _ProcessEvent(CallBackList & l,
                               double gTime,
                               double time,
                               bool bFirstTick,
                               DAL_EVENT_TYPE et,
                               bool bNeedsReverse) { return true; }
    
    bool ProcessCB(CallBackList & l,
                   double gTime,
                   double lastTick,
                   double curTime,
                   bool bForward,
                   bool bFirstTick,
                   bool bNeedPlay);

    virtual bool _ProcessCB(CallBackList & l,
                            double gTime,
                            double lastTick,
                            double curTime,
                            bool bForward,
                            bool bFirstTick,
                            bool bNeedPlay,
                            bool bNeedsReverse) { return true; }

    bool EventNotify(CallBackList &l,
                     double gTime,
                     DAL_EVENT_TYPE et);
    
    bool IsStarted();

    virtual void Invalidate();
    
    bool SetParent(CDALBehavior * parent) {
        if (m_parent) return false;
        m_parent = parent;
        return true;
    }

    virtual bool SetTrack(CDALTrack * parent);
    // This takes the current parent and only clears it for those
    // whose parent is the parent passed in (unless it is NULL)
    virtual void ClearTrack(CDALTrack * parent);

    void UpdateTotalDuration() {
        if (m_bBounce) {
            m_repduration = m_duration * 2;
        } else {
            m_repduration = m_duration;
        }
        
        if (m_repeat == 0 || m_duration == HUGE_VAL) {
            m_totalrepduration = HUGE_VAL;
        } else {
            m_totalrepduration = m_repeat * m_repduration;
        }

        if (m_totaltime != -1) {
            m_totalduration = m_totaltime;
        } else {
            m_totalduration = m_totalrepduration;
        }
    }
#if _DEBUG
    virtual void Print(int spaces) = 0;
#endif
  protected:
    long m_id;
    double m_duration;
    double m_totaltime;
    long m_repeat;
    bool m_bBounce;
    DAComPtr<IDALEventCB> m_eventcb;
    float m_easein;
    float m_easeinstart;
    float m_easeout;
    float m_easeoutend;

    // The real duration determine by checking the totaltime and the
    // totalrepduration
    
    double m_totalduration;

    // The duration for a single rep of a behavior
    double m_repduration;

    // Total duration we calculate for a regular behavior 
    double m_totalrepduration; 

    CRPtr<CRBvr> m_bvr;
    CDALTrack * m_track;
    CDALBehavior * m_parent;
    CR_BVR_TYPEID m_typeId;

    // The ease-in/out behavior modifier is applied using timeline
    // substitution.  The substitute timeline consists of three pieces
    // A, B and C, which are the ease-in, constant velocity and ease-out
    // parts respectively.  For B, a linear timeline is substituted; for
    // A and C, a quadratic warping of the input time is required.

    float m_flA0, m_flA1, m_flA2; // coefficients for the A piece
    float m_flB0, m_flB1;         // coefficients for the B piece
    float m_flC0, m_flC1, m_flC2; // coefficients for the C piece

    // These are the times to perform ease in/out
    float m_easeinEnd;
    float m_easeoutStart;
    bool m_bNeedEase;

    void CalculateEaseCoeff();

    // This will take the time behavior and ease it
    CRNumberPtr EaseTime(CRNumberPtr time);

    // This will take the given time and transform it to the correct
    // eased time
    // If the time is outside of our duration (i.e. <0 or >
    // m_duration) this will just return the given time
    double EaseTime(double time);

    virtual bool IsContinuousMediaBvr() { return false; }
};

CDALBehavior * GetBvr(IUnknown *);

class CallBackData
{
  public:
    CallBackData(CDALBehavior * bvr,
                 IDALEventCB * eventcb,
                 long id,
                 double time,
                 DAL_EVENT_TYPE et);
    ~CallBackData();

    HRESULT CallEvent();

  protected:
    DAComPtr<CDALBehavior> m_bvr;
    double m_time;
    DAL_EVENT_TYPE m_et;
    DAComPtr<IDALEventCB> m_eventcb;
    long m_id;
};

#if _DEBUG
inline char * EventString(DAL_EVENT_TYPE et) {
    switch(et) {
      case DAL_PLAY_EVENT:
        return "Play";
      case DAL_STOP_EVENT:
        return "Stop";
      case DAL_PAUSE_EVENT:
        return "Pause";
      case DAL_RESUME_EVENT:
        return "Resume";
      case DAL_REPEAT_EVENT:
        return "Repeat";
      case DAL_BOUNCE_EVENT:
        return "Bounce";
      case DAL_ONLOAD_EVENT:
        return "OnLoad(success)";
      case DAL_ONLOAD_ERROR_EVENT:
        return "OnLoad(failed)";
      default:
        return "Unknown";
    }
}
#endif

#endif /* _BVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\factory.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "bvr.h"
#include "singlebvr.h"
#include "seq.h"
#include "track.h"
#include "factory.h"
#include "import.h"

CDALFactory::CDALFactory()
{
}

CDALFactory::~CDALFactory()
{
}


HRESULT
CDALFactory::FinalConstruct()
{
    if (bFailedLoad)
        return E_FAIL;
    return S_OK;
}

STDMETHODIMP
CDALFactory::CreateSingleBehavior(long id,
                                  double duration,
                                  IDABehavior *bvr,
                                  IDALSingleBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CDALSingleBehavior> *pNew;
    DAComObject<CDALSingleBehavior>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(id, duration, bvr));
        
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALSingleBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CDALFactory::CreateImportBehavior(long id,
                                  IDABehavior *bvr,
                                  IDAImportationResult *impres,
                                  IDABehavior *prebvr,
                                  IDABehavior *postbvr,
                                  IDALImportBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);

    HRESULT hr;

    DAComObject<CDALImportBehavior> *pNew;
    DAComObject<CDALImportBehavior>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(id, bvr, impres, prebvr, postbvr));

        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALImportBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CDALFactory::CreateSequenceBehavior(long id,
                                    VARIANT seqArray,
                                    IDALSequenceBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);

    SafeArrayAccessor sa(seqArray, true);

    if (!sa.IsOK()) return Error();

    HRESULT hr;
    
    DAComObject<CDALSequenceBehavior> *pNew;
    DAComObject<CDALSequenceBehavior>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(id, sa.GetArraySize(), sa.GetArray()));
        
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALSequenceBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CDALFactory::CreateSequenceBehaviorEx(long id,
                                      long s,
                                      IDALBehavior **seqArray,
                                      IDALSequenceBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CDALSequenceBehavior> *pNew;
    DAComObject<CDALSequenceBehavior>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(id, s, (IUnknown **) seqArray));
        
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALSequenceBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CDALFactory::CreateTrack(IDALBehavior *bvr,
                         IDALTrack **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CDALTrack> *pNew;
    DAComObject<CDALTrack>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(bvr));
        
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALTrack,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

HRESULT
CDALFactory::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CDALFactory, &CLSID_DALFactory>::Error(str, IID_IDALFactory, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\factory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _FACTORY_H
#define _FACTORY_H

#define LIBID "DirectAnimationTxD"

class ATL_NO_VTABLE CDALFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CDALFactory, &CLSID_DALFactory>,
      public IDispatchImpl<IDALFactory, &IID_IDALFactory, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALFactory>,
      public ISupportErrorInfoImpl<&IID_IDALFactory>
{
  public:
    CDALFactory();
    ~CDALFactory();

    DA_DECLARE_NOT_AGGREGATABLE(CDALFactory);

    HRESULT FinalConstruct();
#if _DEBUG
    const char * GetName() { return "CDALFactory"; }
#endif

    DECLARE_REGISTRY(CLSID_DALFactory,
                     LIBID ".DATXDFactory.1",
                     LIBID ".DATXDFactory",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDALFactory)
        COM_INTERFACE_ENTRY(IDALFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(CreateSingleBehavior)(long id,
                                    double duration,
                                    IDABehavior *bvr,
                                    IDALSingleBehavior **ppOut);
    STDMETHOD(CreateSequenceBehavior)(long id,
                                      VARIANT seqArray,
                                      IDALSequenceBehavior **ppOut);
    STDMETHOD(CreateSequenceBehaviorEx)(long id,
                                        long s,
                                        IDALBehavior **seqArray,
                                        IDALSequenceBehavior **ppOut);
    STDMETHOD(CreateTrack)(IDALBehavior *bvr,
                           IDALTrack **ppOut);

    STDMETHOD(CreateImportBehavior)(long id,
                                    IDABehavior *bvr,
                                    IDAImportationResult *impres,
                                    IDABehavior *prebvr,
                                    IDABehavior *postbvr,
                                    IDALImportBehavior **ppOut);

    HRESULT Error();
};


#endif /* _FACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\bvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "bvr.h"
#include "track.h"

DeclareTag(tagBvr, "API", "CDALBehavior methods");
DeclareTag(tagNotify, "API", "Notifications");

CDALBehavior::CDALBehavior()
: m_id(0),
  m_duration(-1),
  m_totaltime(-1),
  m_repeat(1),
  m_bBounce(false),
  m_totalduration(0.0),
  m_repduration(0.0),
  m_totalrepduration(0.0),
  m_track(NULL),
  m_parent(NULL),
  m_typeId(CRINVALID_TYPEID),
  m_easein(0.0),
  m_easeinstart(0.0),
  m_easeout(0.0),
  m_easeoutend(0.0)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::CDALBehavior()",
              this));
}

CDALBehavior::~CDALBehavior()
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::~CDALBehavior()",
              this));
}

HRESULT
CDALBehavior::GetID(long * pid)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetID()",
              this));

    CHECK_RETURN_NULL(pid);

    *pid = m_id;
    return S_OK;
}

HRESULT
CDALBehavior::SetID(long id)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetID(%d)",
              this,
              id));

    if (IsStarted()) return E_FAIL;
    
    m_id = id;
    return S_OK;
}
        
HRESULT
CDALBehavior::GetDuration(double * pdur)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetDuration()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_duration;
    return S_OK;
}

HRESULT
CDALBehavior::SetDuration(double dur)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetDuration(%g)",
              this,
              dur));

    if (IsStarted()) return E_FAIL;

    m_duration = dur;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetTotalTime(double * pdur)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetTotalTime()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_totaltime;
    return S_OK;
}

HRESULT
CDALBehavior::SetTotalTime(double dur)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetTotaltime(%g)",
              this,
              dur));

    if (IsStarted()) return E_FAIL;

    m_totaltime = dur;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetRepeat(long * prepeat)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetRepeat()",
              this));

    CHECK_RETURN_NULL(prepeat);

    *prepeat = m_repeat;
    return S_OK;
}

HRESULT
CDALBehavior::SetRepeat(long repeat)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetRepeat(%d)",
              this,
              repeat));

    if (IsStarted()) return E_FAIL;

    m_repeat = repeat;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetBounce(VARIANT_BOOL * pbounce)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetBounce()",
              this));

    CHECK_RETURN_NULL(pbounce);

    *pbounce = m_bBounce;
    return S_OK;
}

HRESULT
CDALBehavior::SetBounce(VARIANT_BOOL bounce)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetBounce(%d)",
              this,
              bounce));

    if (IsStarted()) return E_FAIL;

    m_bBounce = bounce?true:false;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEventCB(IDALEventCB ** evcb)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEventCB()",
              this));

    CHECK_RETURN_SET_NULL(evcb);

    *evcb = m_eventcb;
    if (m_eventcb) m_eventcb->AddRef();

    return S_OK;
}

HRESULT
CDALBehavior::SetEventCB(IDALEventCB * evcb)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEventCB(%lx)",
              this,
              evcb));

    if (IsStarted()) return E_FAIL;

    m_eventcb = evcb;
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEaseIn(float * pd)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEaseIn()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easein;
    return S_OK;
}

HRESULT
CDALBehavior::SetEaseIn(float d)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEaseIn(%g)",
              this,
              d));

    if (IsStarted()) return E_FAIL;

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;
    
    m_easein = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEaseInStart(float * pd)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEaseInStart()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeinstart;
    return S_OK;
}

HRESULT
CDALBehavior::SetEaseInStart(float d)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEaseInStart(%g)",
              this,
              d));

    if (IsStarted()) return E_FAIL;

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeinstart = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEaseOut(float * pd)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEaseOut()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeout;
    return S_OK;
}

HRESULT
CDALBehavior::SetEaseOut(float d)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEaseOut(%g)",
              this,
              d));

    if (IsStarted()) return E_FAIL;

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeout = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEaseOutEnd(float * pd)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEaseOutEnd()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeoutend;
    return S_OK;
}

HRESULT
CDALBehavior::SetEaseOutEnd(float d)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEaseOutEnd(%g)",
              this,
              d));

    if (IsStarted()) return E_FAIL;

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeoutend = d;

    Invalidate();
    
    return S_OK;
}
        
void
CDALBehavior::Invalidate()
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::Invalidate()",
              this));

    UpdateTotalDuration();
    if (m_track) m_track->Invalidate();
    if (m_parent) m_parent->Invalidate();
}

CRBvrPtr
CDALBehavior::Start()
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::Start()",
              this));

    // Do not need to get GC lock since we assume the caller already
    // has
    
    CRBvrPtr newBvr = NULL;

    if (IsStarted()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Make sure we calculate the ease in/out coeff
    
    CalculateEaseCoeff();
    
    CRBvrPtr curbvr;

    curbvr = m_bvr;

    CRNumberPtr zeroTime;
    CRNumberPtr durationTime;
    
    if (m_bNeedEase) {
        CRNumberPtr time;

        if ((time = EaseTime(CRLocalTime())) == NULL ||
            (curbvr = CRSubstituteTime(curbvr, time)) == NULL)
            goto done;
    }

    if ((zeroTime = CRCreateNumber(0)) == NULL ||
        (durationTime = CRCreateNumber(m_duration)) == NULL)
        goto done;
    
    // For now clamp to the duration as well

    CRNumberPtr timeSub;
    CRBooleanPtr cond;

    if (m_bBounce) {
        CRNumberPtr totalTime;
    
        // Invert time from duration to repduration and clamp to
        // zero
        
        if ((totalTime = CRCreateNumber(m_repduration)) == NULL ||
            (timeSub = CRSub(totalTime, CRLocalTime())) == NULL ||
            (cond = CRLTE(timeSub, zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) timeSub)) == NULL)
            goto done;
    } else {
        timeSub = durationTime;
    }
    
    // We are localTime until the duration and then we are whatever
    // timeSub is currently set to from above (either clamped for
    // duration time for non-bounce or reversed for the bounce case)

    if ((cond = CRGTE(CRLocalTime(), durationTime)) == NULL ||
        (timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) CRLocalTime())) == NULL)
        goto done;

    // Substitute the clock and clamp to the duration
    
    if (IsContinuousMediaBvr())
    {
        if (!(m_repeat == 0 && m_typeId == CRSOUND_TYPEID))
        {
            if ((curbvr = CRDuration(curbvr, m_duration)) == NULL)
                goto done;
        }
    }
    else
    {
        if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL ||
            (curbvr = CRDuration(curbvr, m_repduration)) == NULL)
            goto done;
    }

    if (m_repeat != 1) {
        if (m_repeat == 0) {
            curbvr = CRRepeatForever(curbvr);
        } else {
            curbvr = CRRepeat(curbvr, m_repeat);
        }

        if (curbvr == NULL)
            goto done;
    }

    // We have a total time so add another duration node
    if (m_totaltime != -1) {
        if ((curbvr = CRDuration(curbvr, m_totaltime)) == NULL)
            goto done;
    }
    
    // indicate success
    newBvr = curbvr;
    
  done:
    return newBvr;
}

bool
CDALBehavior::EventNotify(CallBackList &l,
                          double gTime,
                          DAL_EVENT_TYPE et)
{
    TraceTag((tagNotify,
              "DAL::Notify(%#x): id = %#x, gTime = %g, lTime = %g, event = %s",
              m_track,
              m_id,
              gTime,
              gTime - (m_track->GetCurrentGlobalTime() - m_track->GetCurrentTime()),
              EventString(et)));

    if (m_eventcb) {
        CallBackData * data = new CallBackData(this,
                                               m_eventcb,
                                               m_id,
                                               gTime,
                                               et);
    
        if (!data) {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            return false;
        }
        
        l.push_back(data);
    }

    return true;
}

bool
CDALBehavior::ProcessCB(CallBackList & l,
                        double gTime,
                        double lastTick,
                        double curTime,
                        bool bForward,
                        bool bFirstTick,
                        bool bNeedPlay)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::ProcessCB(%g, %g, %g, %d, %d, %d)",
              this,
              gTime,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay));

    if (bForward) {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        // The equality just needs to match what we checked below when
        // we fired the event the frame before.  We need to use LT for
        // curTime since we need to fire when we are 0
        
        if (lastTick >= m_totalrepduration ||
            (m_totaltime != -1 && lastTick >= m_totaltime) ||
            curTime < 0) {

            // Need to handle boundary case where we start at the end
            // of the animation.  If so then just fire the stop event
            // since the start was done by the start call itself
            
            double maxtime;
            int offset;
            
            // Clamp to total duration
            if (m_totaltime != -1 && m_totaltime < m_totalrepduration)
                maxtime = m_totaltime;
            else
                maxtime = m_totalrepduration;

            if (curTime == maxtime && lastTick == maxtime && bFirstTick) {
                int offset = ceil(curTime / m_duration) - 1;
                if (offset < 0) offset = 0;
                double timeOffset = offset * m_duration;

                if (!_ProcessCB(l,
                                gTime + timeOffset,
                                lastTick - timeOffset,
                                curTime - timeOffset,
                                bForward,
                                bFirstTick,
                                bNeedPlay,
                                m_bBounce && (offset & 0x1)))
                    return false;

                EventNotify(l, gTime + maxtime, DAL_STOP_EVENT);
            }

            return true;
        }
        
        // We now know that the last tick was less than the
        // totalrepduration and the current time is greater than the
        // beginning

        // If the last tick was 0 then we fire the start last time
        // since the check above if for less than
        // So the rule is fire when curTime == 0.0
        
        bool bNeedStart = (lastTick < 0 || bNeedPlay);

        if (bNeedStart) {
            // This means that we just entered

            EventNotify(l, gTime, DAL_PLAY_EVENT);
        }
        
        if (m_duration == HUGE_VAL) {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            gTime,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
                return false;
            
        } else {
            // This is the last repeat/bounce boundary we hit
        
            int offset = int(lastTick / m_duration);
            if (offset < 0) offset = 0;
            double timeOffset = offset * m_duration;
            double maxtime;
            
            if (curTime > m_totalduration)
                maxtime = m_totalduration;
            else
                maxtime = curTime;

            while (1) {
                
                // We need to request a reversal of the underlying
                // behavior if we are bouncing and the offset is odd
                
                if (!_ProcessCB(l,
                                gTime + timeOffset,
                                lastTick - timeOffset,
                                maxtime - timeOffset,
                                true,
                                bFirstTick,
                                bNeedStart,
                                m_bBounce && (offset & 0x1)))
                    return false;
                
                offset++;
                timeOffset += m_duration;
                
                // If we have reached the end then notify and break
                
                if (timeOffset > curTime ||
                    timeOffset >= m_totalduration ||
                    timeOffset >= m_totalrepduration) {

                    if (curTime >= m_totalrepduration ||
                        curTime >= m_totalduration) {
                        // This means we were inside last time but not any more -
                        // generate an exit event
                        
                        EventNotify(l, gTime + maxtime, DAL_STOP_EVENT);
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are bouncing and the offset is odd then it is
                // a bounce and not a repeat
                
                if (m_bBounce && (offset & 0x1))
                    EventNotify(l, gTime + timeOffset, DAL_BOUNCE_EVENT);
                else
                    EventNotify(l, gTime + timeOffset, DAL_REPEAT_EVENT);
            }
        }
    } else {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        double maxtime;

        // Clamp to total duration
        if (m_totaltime != -1 && m_totaltime < m_totalrepduration)
            maxtime = m_totaltime;
        else
            maxtime = m_totalrepduration;
            
        if (curTime > maxtime || lastTick <= 0) {
            
            if (curTime == 0.0 && lastTick == 0.0 && bFirstTick) {
                // Need to handle the boundary case where we start at
                // the beginning going backwards.  The start call
                // itself handles the start event but we need to
                // process the rest of the behaviors to fire the stops

                if (!_ProcessCB(l,
                                gTime,
                                lastTick,
                                curTime,
                                bForward,
                                true,
                                bNeedPlay,
                                false))
                    return false;

                EventNotify(l, gTime, DAL_STOP_EVENT);
            }
            
            return true;
        }
        
        // We now know that the last tick was greater than the beginning
        // and the current time less than the total duration
        
        bool bNeedStart = (lastTick > m_totalduration ||
                           lastTick > m_totalrepduration ||
                           bNeedPlay);

        if (bNeedStart) {
            // This means that we just entered and we cannot have an
            // infinite value

            EventNotify(l, gTime - maxtime, DAL_PLAY_EVENT);
            
        }

        if (m_duration == HUGE_VAL) {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            gTime,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
                return false;

            if (curTime <= 0) {
                EventNotify(l, gTime, DAL_STOP_EVENT);
            }
                
        } else {
            // This will be the repeat point to begin with
            int offset;
            double timeOffset;

            // Now clamp to the last tick
            if (lastTick < maxtime)
                maxtime = lastTick;
                
            // This puts us on the last duration boundary greater than
            // the last position

            // It needs to be one greater since our loop decrements
            // first
            offset = int(ceil(maxtime / m_duration));
            timeOffset = offset * m_duration;
            
            while (1) {
                offset--;
                timeOffset -= m_duration;
            
                if (!_ProcessCB(l,
                                gTime - timeOffset,
                                maxtime - timeOffset,
                                curTime - timeOffset,
                                false,
                                bFirstTick,
                                bNeedStart,
                                m_bBounce && (offset & 0x1)))
                    return false;
                
                if (timeOffset < curTime) break;
                
                // If we have reached the end then notify and break
                
                if (offset <= 0) {
                    // This means we were inside last time but not any more -
                    // generate an exit event
                    
                    EventNotify(l, gTime, DAL_STOP_EVENT);
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are bouncing and the offset is odd then it is
                // a bounce and not a repeat
                
                if (m_bBounce && (offset & 0x1))
                    EventNotify(l, gTime - timeOffset, DAL_BOUNCE_EVENT);
                else
                    EventNotify(l, gTime - timeOffset, DAL_REPEAT_EVENT);
            }
        }
    }
    
    return true;
}

bool
CDALBehavior::ProcessEvent(CallBackList & l,
                           double gTime,
                           double time,
                           bool bFirstTick,
                           DAL_EVENT_TYPE et)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::ProcessEvent(%g, %g, %d, %s)",
              this,
              gTime,
              time,
              bFirstTick,
              EventString(et)));

    // If it is outside of our range then just bail
    
    if (time < 0 || time > m_totalduration || time > m_totalrepduration)
        return true;
    
    // If it is not the first tick and we are on a boundary do not
    // fire the events - they were already fired
    if (!bFirstTick &&
        (time == 0 ||
         time == m_totalduration ||
         time == m_totalrepduration))
        return true;
    
    // Plays and Pauses get called on the way down
    if (et == DAL_PAUSE_EVENT ||
        et == DAL_PLAY_EVENT) {
        EventNotify(l, gTime, et);
    }
    
    if (m_duration == HUGE_VAL) {
        // Just always process our children if we are infinite
        
        if (!_ProcessEvent(l,
                           gTime,
                           time,
                           bFirstTick,
                           et,
                           false))
            return false;
    } else {
        // This is the last repeat/bounce boundary we hit
        int offset = int(time / m_duration);
        
        Assert(offset >= 0);

        // We need to request a reversal of the underlying
        // behavior if we are bouncing and the offset is odd
        
        if (!_ProcessEvent(l,
                           gTime,
                           time - (offset * m_duration),
                           bFirstTick,
                           et,
                           m_bBounce && (offset & 0x1)))
            return false;
    }
    
    // Stops and Resumes get called on the way up
    if (et == DAL_STOP_EVENT ||
        et == DAL_RESUME_EVENT) {
        EventNotify(l, gTime, et);
    }
    
    return true;
}

bool
CDALBehavior::SetTrack(CDALTrack * parent)
{
    if (m_track) return false;
    m_track = parent;
    return true;
}

void
CDALBehavior::ClearTrack(CDALTrack * parent)
{
    if (parent == NULL || parent == m_track) {
        m_track = NULL;
    }
}

bool
CDALBehavior::IsStarted()
{
    return (m_track && m_track->IsStarted());
}

void
CDALBehavior::CalculateEaseCoeff()
{
    Assert(m_easein >= 0 && m_easein <= 1);
    Assert(m_easeout >= 0 && m_easeout <= 1);
    Assert(m_easeinstart >= 0 && m_easeinstart <= 1);
    Assert(m_easeoutend >= 0 && m_easeoutend <= 1);

    // We need to ease the behavior if we are not infinite and either
    // ease in or ease out percentages are non-zero
    
    m_bNeedEase = (m_duration != HUGE_VAL &&
                   (m_easein > 0 || m_easeout > 0) &&
                   (m_easein + m_easeout <= 1));

    if (!m_bNeedEase) return;
    
    float flEaseInDuration = m_easein * m_duration;
    float flEaseOutDuration = m_easeout * m_duration;
    float flMiddleDuration = m_duration - flEaseInDuration - flEaseOutDuration;
    
    // Compute B1, the velocity during segment B.
    float flInvB1 = (0.5f * m_easein * (m_easeinstart - 1) +
                     0.5f * m_easeout * (m_easeoutend - 1) + 1);
    Assert(flInvB1 > 0);
    m_flB1 = 1 / flInvB1;
    
    // Basically for accelerated pieces - t = t0 + v0 * t + 1/2 at^2
    // and a = Vend - Vstart / t

    if (flEaseInDuration != 0) {
        m_flA0 = 0;
        m_flA1 = m_easeinstart * m_flB1;
        m_flA2 = 0.5f * (m_flB1 - m_flA1) / flEaseInDuration;
    } else {
        m_flA0 = m_flA1 = m_flA2 = 0;
    }

    m_flB0 = m_flA0 + m_flA1 * flEaseInDuration + m_flA2 * flEaseInDuration * flEaseInDuration;
    
    if (flEaseOutDuration != 0) {
        m_flC0 = m_flB1 * flMiddleDuration + m_flB0;
        m_flC1 = m_flB1;
        m_flC2 = 0.5f * (m_easeoutend * m_flB1 - m_flC1) / flEaseOutDuration;
    } else {
        m_flC0 = m_flC1 = m_flC2 = 0;
    }

    m_easeinEnd = flEaseInDuration;
    m_easeoutStart = m_duration - flEaseOutDuration;
}

CRNumberPtr
Quadratic(CRNumberPtr time, float flA, float flB, float flC)
{
    // Assume that the GC lock is acquired
    
    // Need to calculate ax^2 + bx + c

    Assert(time != NULL);

    CRNumberPtr ret = NULL;
    CRNumberPtr accum = NULL;

    if (flC != 0.0) {
        if ((accum = CRCreateNumber(flC)) == NULL)
            goto done;
    }

    if (flB != 0.0) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flB)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    if (flA != 0.0) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flA)) == NULL ||
            (term = CRMul(term, time)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    // If all the coeff are zero then just return 0
    
    if (accum == NULL) {
        if ((accum = CRCreateNumber(0.0)) == NULL)
            goto done;
    }
    
    ret = accum;
    
  done:
    return ret;
}

CRNumberPtr
AddTerm(CRNumberPtr time,
        CRNumberPtr prevTerm,
        float prevDur,
        float flA, float flB, float flC)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr term;
    
    // Offset the time to be zero since that is what the coeffs are
    // based on
    
    if (prevTerm) {
        CRNumberPtr t;
        
        if ((t = CRCreateNumber(prevDur)) == NULL ||
            (time = CRSub(time, t)) == NULL)
            goto done;
    }

    if ((term = Quadratic(time, flA, flB, flC)) == NULL)
        goto done;
    
    // Now we need to conditional use the new term

    if (prevTerm) {
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (cond = CRLT(time, zeroTime)) == NULL ||
            (term = (CRNumberPtr) CRCond(cond,
                                         (CRBvrPtr) prevTerm,
                                         (CRBvrPtr) term)) == NULL)
            goto done;
    }

    ret = term;
  done:
    return ret;
}

CRNumberPtr
CDALBehavior::EaseTime(CRNumberPtr time)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr subTime = NULL;
    
    if (!m_bNeedEase) {
        ret = time;
        goto done;
    }
    
    if (m_easein > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               0.0,
                               m_flA2, m_flA1, m_flA0)) == NULL)
            goto done;
    }
    
    // If there is space between the end of easing in and the
    // beginning of easing out then we have some constant time
    // interval
    if (m_easeinEnd < m_easeoutStart) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeinEnd,
                               0, m_flB1, m_flB0)) == NULL)
            goto done;
    }

    if (m_easeout > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeoutStart,
                               m_flC2, m_flC1, m_flC0)) == NULL)
            goto done;
    }
    
    ret = subTime;
    
    Assert(ret);
  done:
    return ret;
}

double
Quadratic(double time, float flA, float flB, float flC)
{
    // Need to calculate ax^2 + bx + c
    // Use x * (a * x + b) + c - since it requires 1 less multiply
    
    return (time * (flA * time + flB) + flC);
}

double
CDALBehavior::EaseTime(double time)
{
    if (!m_bNeedEase || time <= 0 || time >= m_duration)
        return time;
    
    if (time <= m_easeinEnd) {
        return Quadratic(time, m_flA2, m_flA1, m_flA0);
    } else if (time < m_easeoutStart) {
        return Quadratic(time - m_easeinEnd, 0, m_flB1, m_flB0);
    } else {
        return Quadratic(time - m_easeoutStart, m_flC2, m_flC1, m_flC0);
    }
}

class __declspec(uuid("D19C5C64-C3A8-11d1-A000-00C04FA32195"))
BvrGuid {};

HRESULT WINAPI
CDALBehavior::InternalQueryInterface(CDALBehavior* pThis,
                                     const _ATL_INTMAP_ENTRY* pEntries,
                                     REFIID iid,
                                     void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(BvrGuid))) {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface((void *)pThis,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CDALBehavior *
GetBvr(IUnknown * pbvr)
{
    CDALBehavior * bvr = NULL;

    if (pbvr) {
        pbvr->QueryInterface(__uuidof(BvrGuid),(void **)&bvr);
    }
    
    if (bvr == NULL) {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}

CallBackData::CallBackData(CDALBehavior * bvr,
                           IDALEventCB * eventcb,
                           long id,
                           double time,
                           DAL_EVENT_TYPE et)
: m_bvr(bvr),
  m_eventcb(eventcb),
  m_time(time),
  m_et(et),
  m_id(id)
{
    Assert(eventcb);
}

CallBackData::~CallBackData()
{
}

HRESULT
CallBackData::CallEvent()
{
    Assert(m_eventcb);
    
    return THR(m_eventcb->OnEvent(m_id,
                                  m_time,
                                  m_bvr,
                                  m_et));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "dalite.h"
#include "comutil.h"
#include "dartapi.h"
#include "util.h"
#include <list>

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\import.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "import.h"
#include "track.h"

DeclareTag(tagImportBvr, "API", "CDALImportBehavior methods");
extern TAG tagNotify;

CDALImportBehavior::CDALImportBehavior()
: m_importid(-1)
{
    TraceTag((tagImportBvr,
              "CDALImportBehavior(%lx)::CDALImportBehavior()",
              this));
}

CDALImportBehavior::~CDALImportBehavior()
{
    TraceTag((tagImportBvr,
              "CDALImportBehavior(%lx)::~CDALImportBehavior()",
              this));
}

HRESULT
CDALImportBehavior::Init(long id,
                         IDABehavior *bvr,
                         IDAImportationResult *impres,
                         IDABehavior * prebvr,
                         IDABehavior * postbvr)
{
    TraceTag((tagImportBvr,
              "CDALImportBehavior(%lx)::Init(%d, %lx, %lx, %lx, %lx)",
              this,
              id,
              bvr,
              impres,
              prebvr,
              postbvr));
    
    bool ok = false;
    
    m_id = id;
    m_duration = HUGE_VAL;
    
    {
        DAComPtr<IDANumber> danum;
        DAComPtr<IDAEvent> daev;
        HRESULT hr;
        
        if (FAILED(hr = impres->get_Duration(&danum))) {
            CRSetLastError(hr, NULL);
            goto done;
        }
        
        m_durationBvr = (CRNumberPtr) COMToCRBvr(danum.p);
        
        if (!m_durationBvr)
            goto done;

        if (FAILED(hr = impres->get_CompletionEvent(&daev))) {
            CRSetLastError(hr, NULL);
            goto done;
        }
        
        m_completionEvent = (CREventPtr) COMToCRBvr(daev.p);
        
        if (!m_completionEvent)
            goto done;
    }
    
    if (!bvr) {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    m_importbvr = COMToCRBvr(bvr);
    
    if (!m_importbvr)
        goto done;

    if (prebvr) {
        m_prebvr = COMToCRBvr(prebvr);
    
        if (!m_prebvr)
            goto done;
    }

    if (postbvr) {
        m_postbvr = COMToCRBvr(postbvr);
    
        if (!m_postbvr)
            goto done;
    }

    m_typeId = CRGetTypeId(m_importbvr);
    
    Assert(m_typeId != CRUNKNOWN_TYPEID &&
           m_typeId != CRINVALID_TYPEID);
    
    if (m_prebvr || m_postbvr)
    {
        CRLockGrabber __gclg;
        
        m_bvr = CRModifiableBvr(m_importbvr, CRContinueTimeline);
        
        if (!m_bvr)
            goto done;
    }
    else
    {
        m_bvr = m_importbvr;
    }

    UpdateTotalDuration();

    ok = true;
  done:    
    return ok?S_OK:CRGetLastError();
}

bool
CDALImportBehavior::SetTrack(CDALTrack * parent)
{
    bool ok = false;
    
    if (!CDALBehavior::SetTrack(parent))
        goto done;

    if (m_track) {
        CRLockGrabber __gclg;
        CRBvrPtr danum;

        if ((danum = (CRBvrPtr) CRCreateNumber(0)) == NULL ||
            (danum = CRUntilNotify(danum,
                                   m_completionEvent,
                                   this)) == NULL ||
            (m_importid = m_track->AddPendingImport(danum)) == -1)
            goto done;
    }

    ok = true;
  done:
    return ok;
}

void
CDALImportBehavior::ClearTrack(CDALTrack * parent)
{
    if (m_track && m_importid != -1) {
        m_track->RemovePendingImport(m_importid);
        m_importid = -1;
    }
    CDALBehavior::ClearTrack(parent);
}

CRSTDAPICB_(CRBvrPtr)
CDALImportBehavior::Notify(CRBvrPtr eventData,
                           CRBvrPtr curRunningBvr,
                           CRViewPtr curView)
{
    if (m_track && m_importid != -1) {
        m_track->RemovePendingImport(m_importid);
        m_importid = -1;
    }

    Assert(CRIsConstantBvr(eventData));

    Assert(CRGetTypeId(eventData) == CRNUMBER_TYPEID);
    
    double d = CRExtract((CRNumberPtr) eventData);
    bool bFailed = (d == -1.0);
    
    if (!bFailed) {
        // Need to update the duration in case they change state
        // during the callback
        
        Assert(CRIsConstantBvr((CRBvrPtr) m_durationBvr.p));
        
        THR(SetDuration(CRExtract(m_durationBvr)));
    }

    // Now we need to update the behavior with the correct duration
    // (since sometimes imports do not always return the accurate
    // duration) and also to add the pre and post behaviors
    
    {
        CRLockGrabber __gclg;

        CRBvrPtr curbvr = m_importbvr;
        
        if (m_prebvr || m_postbvr)
        {
            if (m_prebvr)
            {
                CRBvrPtr b;
                
                b = CRDuration(m_prebvr, 0.00000001);
                
                if (b) {
                    curbvr = CRSequence(b, curbvr);
                }
            }
            
            if (curbvr && m_postbvr)
            {
                curbvr = CRSequence(curbvr, m_postbvr);
            }

            if (curbvr)
            {
                CRSwitchTo(m_bvr, curbvr, false, 0, 0);
            }
        }
    }
    
    if (m_track && m_eventcb) {
        TraceTag((tagNotify,
                  "DAL::Notify(%#x): id = %#x, gTime = %g, lTime = %g, event = %s, data = %g",
                  m_track, m_id, m_track->GetCurrentGlobalTime(), m_track->GetCurrentTime(),
                  EventString(bFailed?DAL_ONLOAD_ERROR_EVENT:DAL_ONLOAD_EVENT),
                  d));

        CallBackData data(this,
                          m_eventcb,
                          m_id,
                          m_track->GetCurrentTime(),
                          bFailed?DAL_ONLOAD_ERROR_EVENT:DAL_ONLOAD_EVENT);
    
        THR(data.CallEvent());

    }

    return curRunningBvr;
}

HRESULT
CDALImportBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CDALImportBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CDALImportBehavior, &__uuidof(CDALImportBehavior)>::Error(str, IID_IDALImportBehavior, hr);
    else
        return hr;
}

#if _DEBUG
void
CDALImportBehavior::Print(int spaces)
{
    char buf[1024];

    sprintf(buf, "%*s[id = %#x, dur = %g, tt = %g, rep = %d, bounce = %d]\r\n",
            spaces,"",
            m_id, m_duration, m_totaltime, m_repeat, m_bBounce);

    OutputDebugString(buf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\import.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _IMPORTBVR_H
#define _IMPORTBVR_H

#include "bvr.h"

class
__declspec(uuid("D2A88CBB-C16D-11d1-A4E0-00C04FC29D46")) 
ATL_NO_VTABLE CDALImportBehavior
    : public CDALBehavior,
      public CComCoClass<CDALImportBehavior, &__uuidof(CDALImportBehavior)>,
      public IDispatchImpl<IDALImportBehavior, &IID_IDALImportBehavior, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALImportBehavior>,
      public ISupportErrorInfoImpl<&IID_IDALImportBehavior>,
      public CRUntilNotifier
{
  public:
    CDALImportBehavior();
    ~CDALImportBehavior();

    HRESULT Init(long id,
                 IDABehavior * bvr,
                 IDAImportationResult * impres,
                 IDABehavior * prebvr,
                 IDABehavior * postbvr);
    
#if _DEBUG
    virtual const char * GetName() { return "CDALImportBehavior"; }
#endif

    BEGIN_COM_MAP(CDALImportBehavior)
        COM_INTERFACE_ENTRY2(IDispatch, IDALImportBehavior)
        COM_INTERFACE_ENTRY(IDALImportBehavior)
        COM_INTERFACE_ENTRY2(IDALBehavior, IDALImportBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(get_ID)(long * pid) { return GetID(pid); }
    STDMETHOD(put_ID)(long id) { return SetID(id); }
        
    STDMETHOD(get_Duration)(double * pd) { return GetDuration(pd); }
    STDMETHOD(put_Duration)(double d) { return E_FAIL; }
        
    STDMETHOD(get_Repeat)(long * pr) { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(long r) { return SetRepeat(r); }

    STDMETHOD(get_Bounce)(VARIANT_BOOL * pr) { return GetBounce(pr); }
    STDMETHOD(put_Bounce)(VARIANT_BOOL r) { return SetBounce(r); }
        
    STDMETHOD(get_EventCB)(IDALEventCB ** ev) { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IDALEventCB * ev) { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(double * pd) { return GetTotalTime(pd); }
    // TODO: HACK HACK - do not really set this for now.
    STDMETHOD(put_TotalTime)(double d) { return S_OK; /*return SetTotalTime(d);*/ }
        
    STDMETHOD(get_EaseIn)(float * pd) { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d) { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd) { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d) { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd) { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d) { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd) { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d) { return SetEaseOutEnd(d); }

    HRESULT Error();
    
    bool SetTrack(CDALTrack * parent);
    void ClearTrack(CDALTrack * parent);

#if _DEBUG
    virtual void Print(int spaces);
#endif

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {*pctinfo = 1; return S_OK;}

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return IDispatchImpl<IDALImportBehavior,
                           &IID_IDALImportBehavior,
                           &LIBID_DirectAnimationTxD>::GetTypeInfo(itinfo, lcid, pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return IDispatchImpl<IDALImportBehavior,
                           &IID_IDALImportBehavior,
                           &LIBID_DirectAnimationTxD>::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return IDispatchImpl<IDALImportBehavior,
                           &IID_IDALImportBehavior,
                           &LIBID_DirectAnimationTxD>::Invoke(dispidMember, riid, lcid,
                                                              wFlags, pdispparams, pvarResult,
                                                              pexcepinfo, puArgErr); }
  protected:
    CRPtr<CRNumber> m_durationBvr;
    CRPtr<CREvent> m_completionEvent;
    CRPtr<CRBvr> m_importbvr;
    CRPtr<CRBvr> m_prebvr;
    CRPtr<CRBvr> m_postbvr;
    long m_importid;

    CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                 CRBvrPtr curRunningBvr,
                                 CRViewPtr curView);

    virtual bool IsContinuousMediaBvr() { return true; }
};


#endif /* _IMPORTBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\seq.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "seq.h"

DeclareTag(tagSequence, "API", "CDALSequenceBehavior methods");

CDALSequenceBehavior::CDALSequenceBehavior()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::CDALSequenceBehavior()",
              this));
}

CDALSequenceBehavior::~CDALSequenceBehavior()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::~CDALSequenceBehavior()",
              this));

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++)
        (*i)->Release();
}

HRESULT
CDALSequenceBehavior::Init(long id, long len, IUnknown **bvrArray)
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::Init(%ld, %ld, %lx)",
              this,
              id,
              len,
              bvrArray));
    
    m_id = id;
    m_duration = 0;
    
    if (!bvrArray || len <= 0) return E_INVALIDARG;
    
    for (int i = 0;i < len;i++) {
        CDALBehavior * bvr = ::GetBvr(bvrArray[i]);

        if (bvr == NULL)
            return CRGetLastError();

        bvr->AddRef();
        bvr->SetParent(this);
        m_list.push_back(bvr);

        if (m_duration != HUGE_VAL) {
            double d = bvr->GetTotalDuration();
        
            if (d == HUGE_VAL) {
                m_duration = HUGE_VAL;
            } else {
                m_duration +=  d;
            }
        }

        // As soon as we have a valid bvr generate the modifiable
        // version
        
        if (!m_bvr) {
            CRLockGrabber __gclg;
            m_bvr = CRModifiableBvr(bvr->GetBvr(),0);

            if (!m_bvr)
                return CRGetLastError();

            m_typeId = CRGetTypeId(m_bvr);
    
            Assert(m_typeId != CRUNKNOWN_TYPEID &&
                   m_typeId != CRINVALID_TYPEID);
        }
    }

    UpdateTotalDuration();
    
    return S_OK;
}

CRBvrPtr
CDALSequenceBehavior::Start()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::Start()",
              this));

    // Do not need to get GC lock since we assume the caller already
    // has
    
    CRBvrPtr newBvr = NULL;
    BvrList::iterator i;
    
    if (IsStarted()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Make sure we calculate the ease in/out coeff
    
    CalculateEaseCoeff();

    CRBvrPtr curbvr;
    curbvr = NULL;
    
    for (i = m_list.begin();
         i != m_list.end();
         i++) {

        CRBvrPtr c;

        if ((c = (*i)->Start()) == NULL)
            goto done;

        if (curbvr == NULL) {
            curbvr = c;
        } else {
            if ((curbvr = CRSequence(curbvr, c)) == NULL)
                goto done;
        }

        Assert (curbvr);

        double curdur;
        curdur = (*i)->GetTotalDuration();

        // See if this was an infinite duration (repeatforever)
        // If so then forget about the rest
        if (curdur == HUGE_VAL) {
            // This means that my duration is also infinite
            Assert(m_duration == HUGE_VAL);
            break;
        }
    }

    CRNumberPtr timeSub;
    CRBooleanPtr cond;

    if (m_bNeedEase) {
        CRNumberPtr time;

        if ((time = EaseTime(CRLocalTime())) == NULL ||
            (curbvr = CRSubstituteTime(curbvr, time)) == NULL)
            goto done;
    }

    // We cannot bounce an infinite sequence so just skip it
    
    if (m_bBounce && m_duration != HUGE_VAL) {
        CRNumberPtr zeroTime;
        CRNumberPtr durationTime;
        CRNumberPtr totalTime;

        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (totalTime = CRCreateNumber(m_repduration)) == NULL ||
            (durationTime = CRCreateNumber(m_duration)) == NULL ||

            (timeSub = CRSub(totalTime, CRLocalTime())) == NULL ||
            (cond = CRLTE(timeSub, zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) timeSub)) == NULL ||

            (cond = CRGTE(CRLocalTime(),durationTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) timeSub,
                                            (CRBvrPtr) CRLocalTime())) == NULL ||
            (curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL)

            goto done;
    }

    if (m_duration != HUGE_VAL) {
        if ((curbvr = CRDuration(curbvr, m_repduration)) == NULL)
            goto done;
    }
    
    if (m_repeat != 1) {
        if (m_repeat == 0) {
            curbvr = CRRepeatForever(curbvr);
        } else {
            curbvr = CRRepeat(curbvr, m_repeat);
        }

        if (curbvr == NULL)
            goto done;
    }

    // We have a total time so add another duration node
    if (m_totaltime != -1) {
        if ((curbvr = CRDuration(curbvr, m_totaltime)) == NULL)
            goto done;
    }
    
    // indicate success
    newBvr = curbvr;
    
  done:
    return newBvr;
}

bool
CDALSequenceBehavior::_ProcessCB(CallBackList & l,
                                 double gTime,
                                 double lastTick,
                                 double curTime,
                                 bool bForward,
                                 bool bFirstTick,
                                 bool bNeedPlay,
                                 bool bNeedsReverse)
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::_ProcessCB(%g, %g, %g, %d, %d, %d, %d)",
              this,
              gTime,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay,
              bNeedsReverse));
    
    // If we need to reverse then invert which direct to process our
    // children and invert times for the current frame not our total
    // duration
    
    if (bNeedsReverse) {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_duration != HUGE_VAL);
        
        lastTick = m_duration - lastTick;
        curTime = m_duration - curTime;
        
        bForward = !bForward;
    }
    
    if (bForward) {
        // Do the quick and dirty solution - just call all our
        // children
        // TODO: Optimize to not call children we know don't need to
        // be
        
        double d = 0;
        
        for (BvrList::iterator i = m_list.begin();
             i != m_list.end();
             i++) {
            
            (*i)->ProcessCB(l,
                            gTime + d,
                            EaseTime(lastTick - d),
                            EaseTime(curTime - d),
                            true,
                            bFirstTick,
                            bNeedPlay);

            d += (*i)->GetTotalDuration();
            Assert(d <= m_duration);
        }
        
    } else {
        // Need to do it in the reverse order
        
        // Do the quick and dirty solution - just call all our
        // children
        // TODO: Optimize to not call children we know don't need to
        // be
        
        if (m_duration == HUGE_VAL)
        {
            double d = 0;
            
            BvrList::iterator i = m_list.begin();

            while (i != m_list.end() &&
                   ((*i)->GetTotalDuration() != HUGE_VAL))
            {
                d += (*i)->GetTotalDuration();
                i++;
            }

            // For a sequence we can only have an infinite duration of
            // one of our children did
            
            Assert((*i)->GetTotalDuration() == HUGE_VAL);
            
            while (1)
            {
                Assert(d >= 0);
                
                (*i)->ProcessCB(l,
                                gTime - d,
                                EaseTime(lastTick - d),
                                EaseTime(curTime - d),
                                false,
                                bFirstTick,
                                bNeedPlay);

                if (i == m_list.begin())
                    break;

                i--;
                d -= (*i)->GetTotalDuration();
            }
        }
        else
        {
            double d = m_duration;
            
            for (BvrList::reverse_iterator i = m_list.rbegin();
                 i != m_list.rend();
                 i++) {
                
                Assert((*i)->GetTotalDuration() != HUGE_VAL);
                
                d -= (*i)->GetTotalDuration();
                
                Assert(d >= 0);
                
                (*i)->ProcessCB(l,
                                gTime - d,
                                EaseTime(lastTick - d),
                                EaseTime(curTime - d),
                                false,
                                bFirstTick,
                                bNeedPlay);
            }
        }
    }
    
    return true;
}

bool
CDALSequenceBehavior::_ProcessEvent(CallBackList & l,
                                    double gTime,
                                    double time,
                                    bool bFirstTick,
                                    DAL_EVENT_TYPE et,
                                    bool bNeedsReverse)
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::_ProcessEvent(%g, %g, %d, %s, %d)",
              this,
              gTime,
              time,
              bFirstTick,
              EventString(et),
              bNeedsReverse));
    
    // If we need to reverse then invert which direct to process our
    // children and invert times for the current frame not our total
    // duration
    
    if (bNeedsReverse) {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_duration != HUGE_VAL);
        
        time = m_duration - time;
    }
    
    double d = 0;
        
    for (BvrList::iterator i = m_list.begin();
         i != m_list.end() && d <= time;
         i++) {
        
        (*i)->ProcessEvent(l,
                           gTime,
                           EaseTime(time - d),
                           bFirstTick,
                           et);
        
        d += (*i)->GetTotalDuration();
        Assert(d <= m_duration);
    }
        
    return true;
}

void
CDALSequenceBehavior::Invalidate()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::Invalidate()",
              this));
    
    UpdateDuration();
    CDALBehavior::Invalidate();
}

void
CDALSequenceBehavior::UpdateDuration()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::UpdateDuration()",
              this));

    m_duration = 0;

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++) {

        double d = (*i)->GetTotalDuration();
        
        if (d == HUGE_VAL) {
            m_duration = HUGE_VAL;
            break;
        } else {
            m_duration +=  d;
        }
    }
}

bool
CDALSequenceBehavior::SetTrack(CDALTrack * parent)
{
    if (!CDALBehavior::SetTrack(parent)) return false;

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++) {
        if (!(*i)->SetTrack(parent))
            return false;
    }

    return true;
}

void
CDALSequenceBehavior::ClearTrack(CDALTrack * parent)
{
    CDALBehavior::ClearTrack(parent);

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++) {
        (*i)->ClearTrack(parent);
    }
}

HRESULT
CDALSequenceBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CDALSequenceBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CDALSequenceBehavior, &__uuidof(CDALSequenceBehavior)>::Error(str, IID_IDALSequenceBehavior, hr);
    else
        return hr;
}

#if _DEBUG
void
CDALSequenceBehavior::Print(int spaces)
{
    char buf[1024];

    sprintf(buf, "%*s{id = %#x, dur = %g, tt = %g, rep = %d, bounce = %d\r\n",
            spaces,"",
            m_id, m_duration, m_totaltime, m_repeat, m_bBounce);

    OutputDebugString(buf);

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++) {
        (*i)->Print(spaces + 2);
    }

    sprintf(buf, "%*s}\r\n",
            spaces,"");

    OutputDebugString(buf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\singlebvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "singlebvr.h"

DeclareTag(tagSingleBvr, "API", "CDALSingleBehavior methods");

CDALSingleBehavior::CDALSingleBehavior()
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::CDALSingleBehavior()",
              this));
}

CDALSingleBehavior::~CDALSingleBehavior()
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::~CDALSingleBehavior()",
              this));
}

HRESULT
CDALSingleBehavior::Init(long id, double duration, IDABehavior *bvr)
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::Init(%d, %g, %lx)",
              this,
              id,
              duration,
              bvr));
    
    m_id = id;
    m_duration = duration;
    
    if (!bvr) return E_INVALIDARG;
    
    m_bvr = COMToCRBvr(bvr);
    
    if (!m_bvr)
        return CRGetLastError();

    m_typeId = CRGetTypeId(m_bvr);
    
    Assert(m_typeId != CRUNKNOWN_TYPEID &&
           m_typeId != CRINVALID_TYPEID);
    
    UpdateTotalDuration();
    
    return S_OK;
}

STDMETHODIMP
CDALSingleBehavior::get_DABehavior(IDABehavior ** bvr)
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::get_DABehavior(%lx)",
              this,
              bvr));

    return GetDABehavior(IID_IDABehavior,
                         (void **)bvr);
}

STDMETHODIMP
CDALSingleBehavior::put_DABehavior(IDABehavior * bvr)
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::put_DABehavior(%lx)",
              this,
              bvr));

    if (IsStarted()) return E_FAIL;
    
    if (!bvr) return E_INVALIDARG;
    
    CRBvrPtr b = COMToCRBvr(bvr);
    if (!b)
        return Error();

    m_bvr = b;

    Invalidate();
    
    return S_OK;
}

STDMETHODIMP
CDALSingleBehavior::GetDABehavior(REFIID riid, void ** bvr)
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::GetDABehavior()",
              this));

    CHECK_RETURN_SET_NULL(bvr);

    Assert(m_bvr);

    if (!CRBvrToCOM(m_bvr,
                    riid,
                    bvr))
        return Error();
    
    return S_OK;
}

HRESULT
CDALSingleBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CDALSingleBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CDALSingleBehavior, &__uuidof(CDALSingleBehavior)>::Error(str, IID_IDALSingleBehavior, hr);
    else
        return hr;
}

#if _DEBUG
void
CDALSingleBehavior::Print(int spaces)
{
    char buf[1024];

    sprintf(buf, "%*s[id = %#x, dur = %g, tt = %g, rep = %d, bounce = %d]\r\n",
            spaces,"",
            m_id, m_duration, m_totaltime, m_repeat, m_bBounce);

    OutputDebugString(buf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\seq.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SEQ_H
#define _SEQ_H

#include "bvr.h"
#include <list>

class
__declspec(uuid("445DE916-C3D8-11d1-A001-00C04FA32195")) 
ATL_NO_VTABLE CDALSequenceBehavior
    : public CDALBehavior,
      public CComCoClass<CDALSequenceBehavior, &__uuidof(CDALSequenceBehavior)>,
      public IDispatchImpl<IDALSequenceBehavior, &IID_IDALSequenceBehavior, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALSequenceBehavior>,
      public ISupportErrorInfoImpl<&IID_IDALSequenceBehavior>
{
  public:
    CDALSequenceBehavior();
    ~CDALSequenceBehavior();

    HRESULT Init(long id, long len, IUnknown ** bvr);
    
#if _DEBUG
    virtual const char * GetName() { return "CDALSequenceBehavior"; }
#endif

    BEGIN_COM_MAP(CDALSequenceBehavior)
        COM_INTERFACE_ENTRY2(IDispatch,IDALSequenceBehavior)
        COM_INTERFACE_ENTRY(IDALSequenceBehavior)
        COM_INTERFACE_ENTRY2(IDALBehavior,IDALSequenceBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(get_ID)(long * pid) { return GetID(pid); }
    STDMETHOD(put_ID)(long id) { return SetID(id); }
        
    STDMETHOD(get_Duration)(double * pd) { return GetDuration(pd); }
    STDMETHOD(put_Duration)(double d) { return E_FAIL; }
        
    STDMETHOD(get_Repeat)(long * pr) { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(long r) { return SetRepeat(r); }
       
    STDMETHOD(get_Bounce)(VARIANT_BOOL * pr) { return GetBounce(pr); }
    STDMETHOD(put_Bounce)(VARIANT_BOOL r) { return SetBounce(r); }
        
    STDMETHOD(get_EventCB)(IDALEventCB ** ev) { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IDALEventCB * ev) { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(double * pd) { return GetTotalTime(pd); }
    STDMETHOD(put_TotalTime)(double d) { return SetTotalTime(d); }
        
    STDMETHOD(get_EaseIn)(float * pd) { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d) { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd) { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d) { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd) { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d) { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd) { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d) { return SetEaseOutEnd(d); }

    HRESULT Error();
    
    bool SetTrack(CDALTrack * parent);
    void ClearTrack(CDALTrack * parent);

    CRBvrPtr Start();
    bool _ProcessCB(CallBackList & l,
                    double gTime,
                    double lastTick,
                    double curTime,
                    bool bForward,
                    bool bFirstTick,
                    bool bNeedPlay,
                    bool bNeedsReverse);

    bool _ProcessEvent(CallBackList & l,
                       double gTime,
                       double time,
                       bool bFirstTick,
                       DAL_EVENT_TYPE et,
                       bool bNeedsReverse);
    
    virtual void Invalidate();

#if _DEBUG
    virtual void Print(int spaces);
#endif

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {*pctinfo = 1; return S_OK;}

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return IDispatchImpl<IDALSequenceBehavior,
                           &IID_IDALSequenceBehavior,
                           &LIBID_DirectAnimationTxD>::GetTypeInfo(itinfo, lcid, pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return IDispatchImpl<IDALSequenceBehavior,
                           &IID_IDALSequenceBehavior,
                           &LIBID_DirectAnimationTxD>::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return IDispatchImpl<IDALSequenceBehavior,
                           &IID_IDALSequenceBehavior,
                           &LIBID_DirectAnimationTxD>::Invoke(dispidMember, riid, lcid,
                                                               wFlags, pdispparams, pvarResult,
                                                               pexcepinfo, puArgErr); }
  protected:
    void UpdateDuration();
    
    typedef std::list<CDALBehavior *> BvrList;
    BvrList m_list;
};

#endif /* _SEQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\singlebvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SINGLEBVR_H
#define _SINGLEBVR_H

#include "bvr.h"

class
__declspec(uuid("D2A88CBB-C16D-11d1-A4E0-00C04FC29D46")) 
ATL_NO_VTABLE CDALSingleBehavior
    : public CDALBehavior,
      public CComCoClass<CDALSingleBehavior, &__uuidof(CDALSingleBehavior)>,
      public IDispatchImpl<IDALSingleBehavior, &IID_IDALSingleBehavior, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALSingleBehavior>,
      public ISupportErrorInfoImpl<&IID_IDALSingleBehavior>
{
  public:
    CDALSingleBehavior();
    ~CDALSingleBehavior();

    HRESULT Init(long id, double duration, IDABehavior * bvr);
    
#if _DEBUG
    virtual const char * GetName() { return "CDALSingleBehavior"; }
#endif

    BEGIN_COM_MAP(CDALSingleBehavior)
        COM_INTERFACE_ENTRY2(IDispatch, IDALSingleBehavior)
        COM_INTERFACE_ENTRY(IDALSingleBehavior)
        COM_INTERFACE_ENTRY2(IDALBehavior, IDALSingleBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(get_ID)(long * pid) { return GetID(pid); }
    STDMETHOD(put_ID)(long id) { return SetID(id); }
        
    STDMETHOD(get_Duration)(double * pd) { return GetDuration(pd); }
    STDMETHOD(put_Duration)(double d) { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(long * pr) { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(long r) { return SetRepeat(r); }
       
    STDMETHOD(get_Bounce)(VARIANT_BOOL * pr) { return GetBounce(pr); }
    STDMETHOD(put_Bounce)(VARIANT_BOOL r) { return SetBounce(r); }
        
    STDMETHOD(get_EventCB)(IDALEventCB ** ev) { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IDALEventCB * ev) { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(double * pd) { return GetTotalTime(pd); }
    STDMETHOD(put_TotalTime)(double d) { return SetTotalTime(d); }
        
    STDMETHOD(get_EaseIn)(float * pd) { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d) { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd) { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d) { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd) { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d) { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd) { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d) { return SetEaseOutEnd(d); }

    STDMETHOD(get_DABehavior)(IDABehavior **);
    STDMETHOD(put_DABehavior)(IDABehavior *);

    STDMETHOD(GetDABehavior)(REFIID riid, void **);

    HRESULT Error();
    
#if _DEBUG
    virtual void Print(int spaces);
#endif

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {*pctinfo = 1; return S_OK;}

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return IDispatchImpl<IDALSingleBehavior,
                           &IID_IDALSingleBehavior,
                           &LIBID_DirectAnimationTxD>::GetTypeInfo(itinfo, lcid, pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return IDispatchImpl<IDALSingleBehavior,
                           &IID_IDALSingleBehavior,
                           &LIBID_DirectAnimationTxD>::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return IDispatchImpl<IDALSingleBehavior,
                           &IID_IDALSingleBehavior,
                           &LIBID_DirectAnimationTxD>::Invoke(dispidMember, riid, lcid,
                                                               wFlags, pdispparams, pvarResult,
                                                               pexcepinfo, puArgErr); }
};


#endif /* _SINGLEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\track.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _TRACK_H
#define _TRACK_H

class
__declspec(uuid("D2A88CBA-C16D-11d1-A4E0-00C04FC29D46")) 
ATL_NO_VTABLE CDALTrack
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CDALTrack, &__uuidof(CDALTrack)>,
      public IDispatchImpl<IDALTrack, &IID_IDALTrack, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALTrack>,
      public ISupportErrorInfoImpl<&IID_IDALTrack>
{
  public:
    CDALTrack();
    ~CDALTrack();

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    HRESULT Init(IDALBehavior * bvr);

#if _DEBUG
    const char * GetName() { return "CDALTrack"; }
#endif

    BEGIN_COM_MAP(CDALTrack)
        COM_INTERFACE_ENTRY(IDALTrack)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(get_Behavior)(IDALBehavior **);
    STDMETHOD(put_Behavior)(IDALBehavior *);
        
    STDMETHOD(Play)(double gTime, double lTime);
    STDMETHOD(Stop)(double gTime, double lTime);
    STDMETHOD(Pause)(double gTime, double lTime);
    STDMETHOD(Resume)(double gTime, double lTime);
        
    STDMETHOD(SetPosition)(double gTime, double lTime);
    STDMETHOD(SetDirection)(VARIANT_BOOL bForward);
        
    STDMETHOD(GetCurrentValueEx)(REFIID riid,
                                 void **ppResult);
    
    STDMETHOD(get_CurrentValue)(IDABehavior **ppResult)
    { return GetCurrentValueEx(IID_IDABehavior, (void **) ppResult); }
    
    STDMETHOD(get_TrackState)(DAL_TRACK_STATE *);
        
    STDMETHOD(get_DABehavior)(IDABehavior **);

    STDMETHOD(GetDABehavior)(REFIID riid, void **);

    STDMETHOD(get_CurrentTime)(double * d);

    STDMETHOD(get_CurrentGlobalTime)(double * d);
    
    bool IsStopped() { return m_state == DAL_STOPPED_STATE; }
    bool IsStarted() { return m_state != DAL_STOPPED_STATE; }
    bool IsPlaying() { return m_state == DAL_PLAYING_STATE; }
    bool IsPaused() { return m_state == DAL_PAUSED_STATE; }

    void Invalidate() { m_bNeedsUpdate = true; }

    void HookCallback(double gTime, double lTime);

    double GetTotalDuration() { return m_dalbvr->GetTotalDuration(); }

    long AddPendingImport(CRBvrPtr dabvr);
    void RemovePendingImport(long id);
    void ClearPendingImports();
    bool IsPendingImports() { return m_cimports > 0; }
    
    double GetCurrentTime() { return m_curTick; }
    double GetCurrentGlobalTime() { return m_curGlobalTime; }
  protected:
    bool UpdateBvr();
    bool _Start(double gTime, double lTime);
    bool _Stop(double gTime, double lTime);
    bool _Pause(double gTime, double lTime);
    bool _Resume(double gTime, double lTime);

    bool ProcessEvent(CallBackList &l,
                      double gTime,
                      double lTime,
                      DAL_EVENT_TYPE event);
    
    bool ProcessCB(CallBackList & l,
                   double gTime,
                   double lTime);
    
    bool ProcessCBList(CallBackList &l);
    
    bool SetTimeSub(double lTime, bool bPause, double gTime);
    
    HRESULT Error();
    
    DAComPtr<CDALBehavior> m_dalbvr;
    DAL_TRACK_STATE m_state;
    double m_curTick;
    bool m_bForward;
    bool m_bNeedsUpdate;
    bool m_firstTick;
    double m_curGlobalTime;
    long m_ignoreCB;
    
    CRPtr<CRNumber> m_timeSub;
    CRPtr<CRBvr> m_dabvr;
    CRPtr<CRBvr> m_dabasebvr;
    CRPtr<CRBvr> m_dabvr_runonce;
    CRPtr<CRBvr> m_modbvr;
    CRPtr<CRArray> m_daarraybvr;

    int m_cimports;
    
    class TrackHook : public CRBvrHook
    {
      public:
        TrackHook();
        ~TrackHook();
        
        virtual CRSTDAPICB_(ULONG) AddRef() { m_cRef++; return m_cRef; }
        virtual CRSTDAPICB_(ULONG) Release() {
            long r = --m_cRef;

            if (r == 0)
                delete this;

            return r;
        }
        
        CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                     bool startingPerformance,
                                     double startTime,
                                     double gTime,
                                     double lTime,
                                     CRBvrPtr sampleVal,
                                     CRBvrPtr curRunningBvr);

        void SetTrack(CDALTrack * t) { m_track = t; }

      protected:
        // We do not need a refcount since we are single threaded and
        // the track will NULL it out if it goes away

        CDALTrack * m_track;
        long m_cRef;
    };

    DAComPtr<TrackHook> m_trackhook;

    void DisableCB() { m_ignoreCB++; }
    void EnableCB() { m_ignoreCB--; Assert (m_ignoreCB >= 0); }

    bool IsCBDisabled() { return m_ignoreCB > 0; }
};

#endif /* _TRACK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\track.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning(disable:4291)

#include "headers.h"
#include "bvr.h"
#include "track.h"

DeclareTag(tagTrack, "API", "CDALTrack methods");
DeclareTag(tagDetailNotify, "API", "Detailed notify");

CDALTrack::CDALTrack()
: m_state(DAL_STOPPED_STATE),
  m_bForward(true),
  m_bNeedsUpdate(true),
  m_firstTick(true),
  m_curGlobalTime(0.0),
  m_ignoreCB(0),
  m_cimports(0)
{
}

CDALTrack::~CDALTrack()
{
    // Ensure the track will not try to call us since we are going away

    m_trackhook->SetTrack(NULL);

    _Stop(m_curGlobalTime, m_curTick);

    if (m_dalbvr) m_dalbvr->ClearTrack(this);

    Assert(!IsPendingImports());

    // Just to be safe
    ClearPendingImports();
}

HRESULT
CDALTrack::Init(IDALBehavior * bvr)
{
    if (!bvr) return E_INVALIDARG;

    CDALBehavior * cbvr = GetBvr(bvr);
    
    if (!cbvr) return E_INVALIDARG;

    m_dalbvr = cbvr;
    
    if (!m_dalbvr->SetTrack(this))
    {
        TraceTag((tagError,
                  "CDALTrack(%lx)::Init: Failed to set track on behavior in.",
                  this));
                  
        return E_FAIL;
    }
    
    m_trackhook = NEW TrackHook;

    if (!m_trackhook) return E_OUTOFMEMORY;
    
    {
        CRLockGrabber __gclg;
        m_modbvr = CRModifiableBvr(m_dalbvr->GetBvr(), 0);

        if (!m_modbvr)
            return CRGetLastError();

        CRNumberPtr ts;
        
        if (!(m_timeSub = CRModifiableNumber(0.0)))

            return CRGetLastError();
        
        // Place us in a stopped state
        if (!_Start(0, 0) || !_Stop(0, 0))
            return CRGetLastError();
    }

    return S_OK;
}

STDMETHODIMP
CDALTrack::get_Behavior(IDALBehavior ** dalbvr)
{
    CHECK_RETURN_SET_NULL(dalbvr);

    Assert (m_dalbvr);
    
    return m_dalbvr->QueryInterface(IID_IDALBehavior,
                                    (void **) dalbvr);
}

STDMETHODIMP
CDALTrack::put_Behavior(IDALBehavior * dalbvr)
{
    bool ok = false;

    if (IsStarted()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!dalbvr) {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    CDALBehavior * cbvr;

    cbvr = GetBvr(dalbvr);
    
    if (!cbvr)
        goto done;

    {
        CRLockGrabber __gclg;
        ok = CRSwitchTo(m_modbvr, cbvr->GetBvr(), false, 0, 0);
    }
    
    if (!cbvr->SetTrack(this)) {
        cbvr->ClearTrack(this);
        goto done;
    }

  done:
    if (!ok)
        return Error();

    m_dalbvr->ClearTrack(this);

    Assert(!IsPendingImports());

    // Just to be safe
    ClearPendingImports();

    m_dalbvr = cbvr;

    m_bNeedsUpdate = true;
    
    return S_OK;
}
        
STDMETHODIMP
CDALTrack::GetCurrentValueEx(REFIID riid,
                             void **ppResult)
{
    CHECK_RETURN_SET_NULL(ppResult);
    
    bool ok = false;

    DisableCB(); // Make sure we ignore callbacks
    
    CRLockGrabber __gclg;

    if (!m_dabvr) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    CRBvrPtr val;

    // If we have not ticked yet then use the non-runonced version and
    // use local time
    // Otherwise use the runonce behavior and the global time

    if (m_firstTick) {
        if ((val = CRSampleAtLocalTime(m_dabvr,
                                       0)) == NULL)
            goto done;
    
    } else {
        if ((val = CRSampleAtLocalTime(m_dabvr_runonce,
                                       m_curGlobalTime)) == NULL)
            goto done;
    }
    
    // This needs to be last so the ppResult is NULL on failure
    
    ok = CRBvrToCOM(val, riid, ppResult);
    
  done:
    EnableCB(); // Reenable callbacks

    return ok?S_OK:Error();
}


STDMETHODIMP
CDALTrack::get_TrackState(DAL_TRACK_STATE * pstate)
{
    CHECK_RETURN_NULL(pstate);
    
    *pstate = m_state;

    return S_OK;
}


STDMETHODIMP
CDALTrack::get_DABehavior(IDABehavior ** ppbvr)
{
    return GetDABehavior(IID_IDABehavior,
                         (void **)ppbvr);
}

STDMETHODIMP
CDALTrack::GetDABehavior(REFIID riid, void ** ppbvr)
{
    CHECK_RETURN_SET_NULL(ppbvr);
    
    Assert(m_modbvr);
    
    if (!CRBvrToCOM(m_modbvr,
                    riid,
                    ppbvr))
        return Error();

    return S_OK;
}

STDMETHODIMP
CDALTrack::get_CurrentTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curTick;

    return S_OK;
}

STDMETHODIMP
CDALTrack::get_CurrentGlobalTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curGlobalTime;

    return S_OK;
}

STDMETHODIMP
CDALTrack::SetPosition(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::SetPosition(%g, %g)",
              this,
              gTime,
              lTime));

    if (IsStarted())
    {
        TraceTag((tagError,
                  "CDALTrack(%lx)::SetPosition: Behavior already started.",
                  this));

        return E_FAIL;
    }

    // Place us in a stopped state
    if (!_Start(gTime, lTime) || !_Stop(gTime, lTime))
        return Error();
    
    return S_OK;
}

STDMETHODIMP
CDALTrack::SetDirection(VARIANT_BOOL bForward)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::SetDirection(%d)",
              this,
              bForward));

    if (IsStarted())
    {
        TraceTag((tagError,
                  "CDALTrack(%lx)::SetDirection: Behavior already started.",
                  this));

        return E_FAIL;
    }

    m_bForward = bForward?true:false;
    return S_OK;
}


STDMETHODIMP
CDALTrack::Play(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::Play(%g, %g)",
              this,
              gTime,
              lTime));

    bool ok = false;
    CallBackList l;

    if (IsPendingImports()) {
        CRSetLastError(E_PENDING, NULL);
        goto done;
    }
        
    if (!IsStopped()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
        
    if (!_Start(gTime, lTime) ||
        !ProcessEvent(l, gTime, lTime, DAL_PLAY_EVENT) ||
        !ProcessCBList(l))
        goto done;

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CDALTrack::Stop(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::Stop(%g, %g)",
              this,
              gTime,
              lTime));

    bool ok = false;
    CallBackList l;

    if (IsStopped()) {
        ok = true;
        goto done;
    } else if (IsPaused()) {
        if (m_curTick != lTime) {
            TraceTag((tagError,
                      "CDALTrack(%lx)::Stop - Invalid ltime - ltime - %g, m_curTick - %g",
                      this,
                      lTime,
                      m_curTick));

            lTime = m_curTick;
        }
    } else {
        if (m_bForward) {
            if (lTime < m_curTick) {
                TraceTag((tagError,
                          "CDALTrack(%lx)::Stop - Invalid ltime - ltime - %g, m_curTick - %g",
                          this,
                          lTime,
                          m_curTick));

                lTime = m_curTick;
            }
        } else {
            if (lTime > m_curTick) {
                TraceTag((tagError,
                          "CDALTrack(%lx)::Stop - Invalid ltime - ltime - %g, m_curTick - %g",
                          this,
                          lTime,
                          m_curTick));

                lTime = m_curTick;
            }
        }
    }
    
    if (!_Stop(gTime, lTime) ||
        !ProcessCB(l,
                   gTime,
                   lTime) ||
        !ProcessEvent(l, gTime, lTime, DAL_STOP_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CDALTrack::Pause(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::Pause(%g, %g)",
              this,
              gTime,
              lTime));

    bool ok = false;
    CallBackList l;

    if (IsPendingImports()) {
        CRSetLastError(E_PENDING, NULL);
        goto done;
    }
        
    if (IsPaused()) {
        ok = true;
        goto done;
    }
    
    if (IsStopped()) {
        if (FAILED(Play(gTime, lTime)))
            goto done;
    }
    
    Assert(IsPlaying());
        
    if (m_bForward) {
        if (lTime < m_curTick) {
            TraceTag((tagError,
                      "CDALTrack(%lx)::Pause - Invalid ltime - ltime - %g, m_curTick - %g",
                      this,
                      lTime,
                      m_curTick));

            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }
    } else {
        if (lTime > m_curTick) {
            TraceTag((tagError,
                      "CDALTrack(%lx)::Pause - Invalid ltime - ltime - %g, m_curTick - %g",
                      this,
                      lTime,
                      m_curTick));

            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }
    }
        
    if (!_Pause(gTime, lTime) ||
        !ProcessCB(l,
                   gTime,
                   lTime) ||
        !ProcessEvent(l, gTime, lTime, DAL_PAUSE_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CDALTrack::Resume(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::Resume(%g, %g)",
              this,
              gTime,
              lTime));

    bool ok = false;
    CallBackList l;

    if (IsPendingImports()) {
        CRSetLastError(E_PENDING, NULL);
        goto done;
    }
        
    if (IsPlaying()) {
        ok = true;
        goto done;
    } else if (IsStopped()) {
        if (FAILED(Play(gTime, lTime)))
            goto done;
    } else {
        Assert(IsPaused());

        if (lTime != m_curTick) {
            TraceTag((tagError,
                      "CDALTrack(%lx)::Resume - Invalid ltime - ltime - %g, m_curTick - %g",
                      this,
                      lTime,
                      m_curTick));

            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }
    }
    
    Assert(lTime == m_curTick);
    
    if (!_Resume(gTime, lTime) ||
        !ProcessCB(l,
                   gTime,
                   lTime) ||
        !ProcessEvent(l, gTime, lTime, DAL_RESUME_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CDALTrack::_Start(double gTime, double lTime)
{
    bool ok = false;
    
    CRLockGrabber __gclg;
    
    if (!UpdateBvr())
        goto done;

    TraceTag((tagError,
              "Track(%#x)::_Start(%g, %g)",
              this,
              gTime,
              lTime));

    CRBvrPtr bvr;

    bvr = m_dabasebvr;
    
    if (IsPendingImports()) {
        Assert(m_daarraybvr);

        CRTuplePtr tuple;
        CRBvrPtr arr[] = { bvr, (CRBvrPtr) m_daarraybvr.p };
        
        if ((tuple = (CRCreateTuple(ARRAY_SIZE(arr), arr))) == NULL ||
            (bvr = CRNth(tuple, 0)) == NULL)
            goto done;
    }
    
    if ((m_dabvr = CRSubstituteTime(bvr, m_timeSub)) == NULL ||
        (m_dabvr_runonce = CRRunOnce(m_dabvr)) == NULL ||
        !CRSwitchTo(m_modbvr, m_dabvr_runonce, true, CRSwitchAtTime, gTime) ||
        !SetTimeSub(lTime, false, gTime))
        goto done;

    m_state = DAL_PLAYING_STATE;
    m_curTick = lTime;
    m_firstTick = true;
    m_curGlobalTime = gTime;
    m_trackhook->SetTrack(this);
    
    ok = true;
  done:
    if (!ok) {
        _Stop(gTime, lTime);
    }

    return ok;
}


bool
CDALTrack::UpdateBvr()
{
    bool ok = false;
    
#if _DEBUG
    TraceTag((tagError,
              "Track(%#x)",
              this));
    m_dalbvr->Print(2);
#endif

    if (m_bNeedsUpdate) {
        CRBvrPtr baseBvr;

        if ((baseBvr = m_dalbvr->Start()) == NULL ||
            (baseBvr = CRHook(baseBvr, m_trackhook)) == NULL)
            goto done;
        
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        CRNumberPtr timeSub;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (cond = CRLTE(CRLocalTime(), zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) CRLocalTime())) == NULL)
            goto done;
        
        if (m_dalbvr->GetTotalDuration() != HUGE_VAL) {
            CRNumberPtr maxTime;
            
            if ((maxTime = CRCreateNumber(m_dalbvr->GetTotalDuration())) == NULL ||
                (cond = CRGTE(timeSub, maxTime)) == NULL ||
                (timeSub = (CRNumberPtr) CRCond(cond,
                                                (CRBvrPtr) maxTime,
                                                (CRBvrPtr) timeSub)) == NULL)
                goto done;
            
        }

        if ((baseBvr = CRSubstituteTime(baseBvr, timeSub)) == NULL)
            goto done;

        m_dabasebvr = baseBvr;
        m_bNeedsUpdate = false;
    }

    ok = true;

  done:
    return ok;
}

bool
CDALTrack::_Stop(double gTime, double lTime)
{
    bool ok = true;
    
    m_state = DAL_STOPPED_STATE;
    m_trackhook->SetTrack(NULL);
    
    {
        CRLockGrabber __gclg;
        
        if (!SetTimeSub(lTime, true, gTime))
            ok = false;
    }

  done:
    return ok;
}

bool
CDALTrack::_Pause(double gTime, double lTime)
{
    bool ok = false;
    
    {
        CRLockGrabber __gclg;
        
        if (!SetTimeSub(lTime, true, gTime))
            goto done;
    }
    
    m_state = DAL_PAUSED_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CDALTrack::_Resume(double gTime, double lTime)
{
    bool ok = false;
    
    {
        CRLockGrabber __gclg;
        
        if (!SetTimeSub(lTime, false, gTime))
            goto done;
    }
    
    m_state = DAL_PLAYING_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CDALTrack::SetTimeSub(double lTime, bool bPause, double gTime)
{
    bool ok = false;
    
    CRNumberPtr tc;
    
    if ((tc = CRCreateNumber(lTime)) == NULL)
        goto done;

    if (!bPause) {
        if (m_bForward) {
            if ((tc = CRAdd(tc, CRLocalTime())) == NULL)
                goto done;
        } else {
            if ((tc = CRSub(tc, CRLocalTime())) == NULL)
                goto done;
        }
    }
    
    if (!CRSwitchTo((CRBvrPtr) m_timeSub.p,
                    (CRBvrPtr) tc,
                    true,
                    CRSwitchAtTime,
                    gTime))
        goto done;

    ok = true;
  done:
    return ok;
}

HRESULT
CDALTrack::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CDALTrack, &__uuidof(CDALTrack)>::Error(str, IID_IDALTrack, hr);
    else
        return hr;
}

bool
CDALTrack::ProcessCB(CallBackList & l,
                     double gTime,
                     double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::ProcessCB(%lx, %g, %g)",
              this,
              &l,
              gTime,
              lTime));

    TraceTag((tagDetailNotify,
              "ProcessCB(%lx): lTime - %g, gTime - %g, m_curTick - %g, m_curGlobalTime - %g, firsttick - %d",
              this,
              lTime,
              gTime,
              m_curTick,
              m_curGlobalTime,
              m_firstTick));
    
    if (lTime != m_curTick || m_firstTick) {
        // See if we are at the end
        bool bIsDone = ((m_bForward && lTime >= GetTotalDuration()) ||
                        (!m_bForward && lTime <= 0));

        double gTimeBase;

        // gTimeBase is the global time it would be at local time 0
        
        if (m_bForward) {
            if (bIsDone) {
                gTimeBase = m_curGlobalTime - m_curTick;
            } else {
                gTimeBase = gTime - lTime;
            }
        } else {
            if (bIsDone) {
                gTimeBase = m_curGlobalTime + m_curTick;
            } else {
                gTimeBase = gTime + lTime;
            }
        }
        
        m_dalbvr->ProcessCB(l,
                            gTimeBase,
                            m_curTick,
                            lTime,
                            m_bForward,
                            m_firstTick,
                            false);

        m_firstTick = false;
        m_curTick = lTime;

        if (bIsDone)
            _Stop(gTime, m_curTick);
    }
    
    // Take the greater of the two since we may have played this
    // behavior during tick but not have tick it yet in the graph.
    
    if (gTime > m_curGlobalTime)
        m_curGlobalTime = gTime;

    return true;
}

bool
CDALTrack::ProcessEvent(CallBackList &l,
                        double gTime,
                        double lTime,
                        DAL_EVENT_TYPE event)
{
    return m_dalbvr->ProcessEvent(l, gTime, lTime, m_firstTick, event);
}

bool
CDALTrack::ProcessCBList(CallBackList &l)
{
    bool ok = true;
    
    for (CallBackList::iterator i = l.begin();
         i != l.end();
         i++) {

        if (FAILED((*i)->CallEvent()))
            ok = false;

        delete (*i);
    }

    l.clear();

    if (!ok)
        CRSetLastError(E_FAIL, NULL);

    return ok;
}

void
CDALTrack::HookCallback(double gTime, double lTime)
{
    TraceTag((tagDetailNotify,
              "HookCallback(%lx): lTime - %g, gTime - %g, m_curTick - %g, m_curGlobalTime - %g, firsttick - %d\n",
              this,
              lTime,
              gTime,
              m_curTick,
              m_curGlobalTime,
              m_firstTick));
    
    if (IsPlaying() && !IsCBDisabled()) {
        CallBackList l;
            
        ProcessCB(l,
                  gTime,
                  lTime);

        ProcessCBList(l);
    }
}

long
CDALTrack::AddPendingImport(CRBvrPtr dabvr)
{
    // Assume the GC Lock is already acquired
    
    long id = -1;
    
    if (!m_daarraybvr) {
        if ((m_daarraybvr = CRCreateArray(1, &dabvr, CR_ARRAY_CHANGEABLE_FLAG)) == NULL)
            goto done;

        id = 0;
    } else {
        long index;
        
        if ((index = CRAddElement(m_daarraybvr, dabvr, 0)) == 0)
            goto done;

        id = index;
    }
    
    m_cimports++;
    
  done:
    return id;
}

void
CDALTrack::RemovePendingImport(long id)
{
    if (m_daarraybvr) {
        CRLockGrabber __gclg;
        bool ok = CRRemoveElement(m_daarraybvr, id);

        if (ok) {
            m_cimports--;
            if (m_cimports == 0)
                m_daarraybvr = NULL;
        }
    }
}

void
CDALTrack::ClearPendingImports()
{
    m_daarraybvr = NULL;
    m_cimports = 0;
}

// While this object is alive we need to keep the DLL from getting
// unloaded

// Start off with a zero refcount
CDALTrack::TrackHook::TrackHook()
: m_cRef(0),
  m_track(NULL)
{
}

CDALTrack::TrackHook::~TrackHook()
{
}

CRSTDAPICB_(CRBvrPtr)
CDALTrack::TrackHook::Notify(long id,
                             bool startingPerformance,
                             double startTime,
                             double gTime,
                             double lTime,
                             CRBvrPtr sampleVal,
                             CRBvrPtr curRunningBvr)
{
    if (m_track && !startingPerformance) {
#if _DEBUG
        if (m_track->IsPlaying()) {
            TraceTag((tagDetailNotify,
                      "Notify(%lx): id - %lx, lTime - %g, gTime - %g",
                      m_track,
                      id,
                      lTime,
                      gTime));
        }
#endif
        m_track->HookCallback(gTime, lTime);
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\common.inc ===
ROOT=$(DAXCTL_ROOT:\src\daxctl=)

!include $(ROOT)\common.inc

INCLUDES = \
    $(DAXCTL_ROOT)\inc; \
    $(DAXCTL_ROOT)\srcodl\$(O); \
    $(LM_INC_DIRS); \
    $(INCLUDES)

NOT_LEAN_AND_MEAN=1

#daxctl build is not currently setup properly to link with RTTI in debug build, so turn off this flag (setting /GR-)
!undef USE_RTTI

USE_STATIC_ATL=1

#
# !!! TRICKY !!!
#
# The DAXCTL's link against MMUTILSE.DLL to get their CRT for size reasons, so we must
# turn off any CRT link settings that might have been set by the master common.inc which
# was included at the top of this file. (PaulNash, 1/21/99)
#
USE_NOLIBS=1

# Turn off EH for the DAX components
!undef USE_NATIVE_EH

# Target Winnt 4.0/Win95/IE4

SUBSYSTEM_VERSION=4.00

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
WIN32_IE_VERSION=0x0400

SOURCES_USED=$(SOURCES_USED) $(DAXCTL_ROOT)\common.inc

#add -DUSELOGGING to see daxctl dbg output
#C_DEFINES=$(C_DEFINES) -DNT_BUILD -DUSELOGGING
C_DEFINES=$(C_DEFINES) -DNT_BUILD

#
# Turn off LIBCMT linking.
#
!undef USE_LIBCMT
!undef USE_MSVCRT

!if $(386)
DAX_EXTRACRTOBJS = \
    $(DAXCTL_ROOT)\lib\$(TARGET_DIRECTORY)\ftol.obj \
    $(DAXCTL_ROOT)\lib\$(TARGET_DIRECTORY)\ftol2.obj

# add compiler support for inline MMX
USER_C_FLAGS = $(USER_C_FLAGS)  /GM
!endif

MMUTILS_LIB = $(SDKDIR)\mmutilse.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalite\src\util.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <mshtml.h>

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool canBeNull)
: _inited(false),
  _isVar(false),
  _s(NULL),
  _failed(true),
  _allocArr(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _inited = true;
                _failed = false;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LOCALE_USER_DEFAULT,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // See if it is a variant
    
    if (IS_VARIANT(pVar))
        _isVar = true;
    else if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
             !IS_VARTYPE(pVar,VT_DISPATCH)) {
        CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
        return;
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        if (canBeNull) {
            _v = NULL;
            _ubound = _lbound = 0;
            _inited = true;
            _failed = false;
            return;
        } else {
            CRSetLastError (E_INVALIDARG,NULL);
            return;
        }
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        int size = GetArraySize();
        
        if (size > 0) {
            // Check the first argument to see its type

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
                !IS_VARTYPE(pVar,VT_DISPATCH)) {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }

            _allocArr = (IUnknown **) malloc(size * sizeof (IUnknown *));

            if (_allocArr == NULL) {
                CRSetLastError(E_OUTOFMEMORY, NULL);
                return;
            }

            for (int i = 0; i < size; i++) {
                CComVariant var;
                HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    return;
                }
                
                _allocArr[i] = var.punkVal;
            }
        }
    }

    _failed = false;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

#if 0
HRESULT
CallScript(IOleClientSite * pClient,
           LPWSTR fun,
           IDispatch * disp,
           DWORD dwData)
{
    DISPID dispid;
    DAComPtr<IOleContainer> pRoot;
    DAComPtr<IHTMLDocument> pHTMLDoc;
    DAComPtr<IDispatch> pDispatch;
    CRBvrPtr bvr = NULL;
    DAComPtr<IDABehavior> event;
    DAComPtr<IDABehavior> curBvr;
    CComVariant retVal;
    HRESULT hr = E_INVALIDARG;
        
    if (!pClient) goto done;
    
    {
        CComBSTR bstrfun(fun);
        
        if (FAILED(hr = pClient->GetContainer(&pRoot)) ||
            FAILED(hr = pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(hr = pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(hr = pDispatch->GetIDsOfNames(IID_NULL, &bstrfun, 1,
                                                 LOCALE_USER_DEFAULT,
                                                 &dispid))) {
            goto done;
        }
    }

        
    // paramters needed to be pushed in reverse order
    VARIANT rgvarg[2];
    rgvarg[1].vt = VT_DISPATCH;
    rgvarg[1].pdispVal = disp;
    rgvarg[0].vt = VT_I4;
    rgvarg[0].lVal = dwData;
    
    DISPPARAMS dp;
    dp.cNamedArgs = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs = 2;
    dp.rgvarg = rgvarg;
    
    hr = pDispatch->Invoke(dispid, IID_NULL,
                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                           &dp, &retVal, NULL, NULL);

    if (FAILED(hr)) {
        goto done;
    }

  done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

#define IDB_ICON_SGRFX                  100
#define IDB_ICON_PATH                   101
#define IDB_ICON_SPRITE                 102
#define IDB_ICON_SEQUENCER              103


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\purevirt.cpp ===
// purevirt.c
//
// Avoids use of C runtime.
//

#include "..\ihbase\precomp.h"

extern "C" int __cdecl _purecall(void)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sources.inc ===
!include $(DAXCTL_ROOT)\common.inc

TARGETNAME=daxctle
TARGETPATH=$(SDKDIR_DEST)
TARGETTYPE=DYNLINK
TARGETEXT=ocx

DLLDEF=..\daxctl.def
DLLBASE=0x10000000
DLLENTRY=DllMain

UMTYPE=windows

C_DEFINES = \
    $(C_DEFINES) \
    /DUSE_OLD_SEQUENCER \
    /DINCLUDESEQ \
    /DUSE_IHOCHELPLIB

!undef USE_NATIVE_EH

INCLUDES=$(INCLUDES);$(DAXCTL_ROOT)\controls\ihbase;

SOURCES = \
    resource.rc \
    dll.cpp \
    purevirt.cpp

TARGETLIBS = \
    $(MMUTILS_LIB) \
    $(DAXCTL_ROOT)\srcodl\$(O)\srcodl.lib \
    $(DAXCTL_ROOT)\controls\ihbase\$(O)\ihbase.lib \
    $(DAXCTL_ROOT)\controls\path\$(O)\path.lib \
    $(DAXCTL_ROOT)\controls\sprite\$(O)\sprite.lib \
    $(DAXCTL_ROOT)\controls\sgrfx\$(O)\sgrfx.lib \
    $(DAXCTL_ROOT)\controls\mmseq\$(O)\mmseq.lib \
    $(DAXCTL_ROOT)\controls\mmctl\src\ochelp\$(O)\mmctl.lib \
    $(DAX_EXTRACRTOBJS) \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\gdi32.lib \
    $(SDK_LIB_PATH)\ole32.lib \
    $(SDK_LIB_PATH)\uuid.lib \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\winmm.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDKDIR)\daguid.lib

BUFFER_OVERFLOW_CHECKS=NO_NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\bvrcllbk.cpp ===
#include "precomp.h"  // From IHBase
#include "debug.h"    // From IHBase
#include <memlayer.h>
#include "bvrcllbk.h"

extern ULONG g_cLock;

/*==========================================================================*/

CCallbackBehavior::CCallbackBehavior()
{
    m_cRef = 1;
    m_pfnContinueFunction = NULL;
    m_fActive = FALSE;
	m_pvUserData = NULL;
	g_cLock++;
}

/*==========================================================================*/

CCallbackBehavior::~CCallbackBehavior()
{
    ASSERT(m_cRef == 0);
	g_cLock--;
}

/*==========================================================================*/

HRESULT CCallbackBehavior::Init(
    IDAStatics *pStatics, 
    IDAEvent *pEvent, 
    PFNCONTINUEFUNCTION pfnContinueFunction,
	LPVOID pvUserData,
    IDABehavior **ppBehavior)

{
    HRESULT hr = S_OK;

	m_pvUserData = pvUserData;

	if (NULL != pfnContinueFunction)
	{
		m_pfnContinueFunction = pfnContinueFunction;
	}
	else
	{
		hr = E_POINTER;
	}

    // Check IDAStatics pointer ...
    if ((SUCCEEDED(hr)) && (NULL != pStatics))
        m_StaticsPtr = pStatics;
    else
        hr = E_POINTER;

    // Check IDAEvent pointer
    if ((SUCCEEDED(hr)) && (NULL != pEvent))
        m_EventPtr = pEvent;
    else
        hr = E_POINTER;

    // Initialize everything ...
	// The Until Notify needs a dummy behavior
	CComPtr<IDANumber> cDummyBvr;

    if (SUCCEEDED(hr))
    {
		hr = m_StaticsPtr->DANumber(99, &cDummyBvr);
	}

    if (SUCCEEDED(hr))
    {
        IDAUntilNotifier * pThis = this;
        hr = m_StaticsPtr->UntilNotify(cDummyBvr, pEvent, pThis, ppBehavior);
    }
    

    if (FAILED(hr))
    {
        m_StaticsPtr.Release();
        m_pfnContinueFunction = NULL;
        m_EventPtr.Release();
    }

    return hr;
}

/*==========================================================================*/

BOOL CCallbackBehavior::IsActive()
{
    return m_fActive;
}

/*==========================================================================*/

BOOL CCallbackBehavior::SetActive(BOOL fActive)
{
    BOOL fTemp = m_fActive;
    m_fActive = fActive;
    
    return fTemp;
}

/*==========================================================================*/

///// IDAUntilNotifier 
HRESULT STDMETHODCALLTYPE CCallbackBehavior::Notify(
        IDABehavior __RPC_FAR *eventData, 
        IDABehavior __RPC_FAR *curRunningBvr,
        IDAView __RPC_FAR *curView,
        IDABehavior __RPC_FAR *__RPC_FAR *ppBvr)
{
    HRESULT hr = E_POINTER;

	ASSERT(NULL != ppBvr);
	if (NULL != ppBvr)
	{
		hr = S_OK;

		// Create a new dummy behavior.
		CComPtr<IDANumber> cDummyNumber;
		if (SUCCEEDED(hr))
		{
			hr = m_StaticsPtr->DANumber(99, &cDummyNumber);
			ASSERT(SUCCEEDED(hr));
		}

		if (m_pfnContinueFunction(m_pvUserData))
		{
			IDAUntilNotifier *pThis = this;

			hr = m_StaticsPtr->UntilNotify(cDummyNumber, m_EventPtr, this, ppBvr);
			ASSERT(SUCCEEDED(hr));
		}
		else
		{
			// Make sure that the dummy doesn't go away.
			cDummyNumber.p->AddRef();
			*ppBvr = cDummyNumber;
			hr = S_OK;
		}
	}

    return hr;
}

/*==========================================================================*/

///// IUnknown
HRESULT STDMETHODCALLTYPE CCallbackBehavior::QueryInterface(
    REFIID riid, 
    void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (NULL == ppvObject)
        return E_POINTER;

    HRESULT hr = E_NOINTERFACE;

    *ppvObject = NULL;

    if (IsEqualGUID(riid, IID_IDAUntilNotifier))
    {
        IDAUntilNotifier *pThis = this;
        
        *ppvObject = (LPVOID) pThis;
        AddRef(); // Since we only provide one interface, we can just AddRef here

        hr = S_OK;
    }

    return hr;
}

/*==========================================================================*/

ULONG STDMETHODCALLTYPE CCallbackBehavior::AddRef(void)
{
	return ::InterlockedIncrement((LONG *)(&m_cRef));
}

/*==========================================================================*/

ULONG STDMETHODCALLTYPE CCallbackBehavior::Release(void)
{
	::InterlockedDecrement((LONG *)(&m_cRef));
    if (m_cRef == 0)
    {
        Delete this;
    }

    return m_cRef;
}

/*==========================================================================*/

///// IDispatch implementation
STDMETHODIMP CCallbackBehavior::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

/*==========================================================================*/

STDMETHODIMP CCallbackBehavior::GetTypeInfo(
    UINT itinfo, 
    LCID lcid, 
    ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

/*==========================================================================*/

STDMETHODIMP CCallbackBehavior::GetIDsOfNames(
    REFIID riid, 
    LPOLESTR *rgszNames, 
    UINT cNames,
    LCID lcid, 
    DISPID *rgdispid)
{
    return E_NOTIMPL;
}

/*==========================================================================*/

STDMETHODIMP CCallbackBehavior::Invoke(
    DISPID dispidMember, 
    REFIID riid, 
    LCID lcid,
    WORD wFlags, 
    DISPPARAMS *pdispparams, 
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, 
    UINT *puArgErr)
{
    return E_NOTIMPL;
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"
#include <locale.h>

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"

#if defined(INCLUDESEQ) && defined(USE_OLD_SEQUENCER)
#include <itimer.iid>
#endif

// Pick up SGrfx headers
#include "sgrfx\sginit.h"
#include "sgrfx\sgrfx.h"

// Pick up Sprite headers
#include "sprite\sprinit.h"
#include "sprite\sprite.h"

// Pick up Path headers
#include "path\pathinit.h"
#include "path\pathctl.h"

#ifdef INCLUDESOUND
// Pick up Sound headers
#include "sound\sndinit.h"
#include "sound\sndctl.h"
#endif

// Pick up Sequencer headers
#ifdef INCLUDESEQ
#ifdef USE_OLD_SEQUENCER
#include "mmseq\seqinit.h"
#include "mmseq\seqctl.h"
#include "mmseq\seqmgr.h"
#else
#include "seq\seqinit.h"
#include "seq\seqctl.h"
#include "seq\seqmgr.h"
#endif

#ifndef USE_OLD_SEQUENCER
#define CACTION_CLASSDEF_ONLY
#include "seq\action.h"
#endif //!USE_OLD_SEQUENCER
#endif //INCLUDESEQ
//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
#ifdef STATIC_OCHELP
extern HINSTANCE       g_hinst;        // DLL instance handle
#else
HINSTANCE       g_hinst = NULL;        // DLL instance handle
#endif

ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfoSG, g_ctlinfoPath, g_ctlinfoSprite;

#ifdef INCLUDESOUND
ControlInfo     g_ctlinfoSound
#endif // INCLUDESOUND

#ifdef INCLUDESEQ
ControlInfo     g_ctlinfoSeq, g_ctlinfoSeqMgr;      // information about the control
#endif

#ifdef _DEBUG
BOOL			g_fLogDebugOutput; // Controls logging of debug info
#endif

extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE("DAExpress controls DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;

#ifdef USE_IHOCHELPLIB
        InitializeStaticOCHelp(hInst);
#endif // USE_IHOCHELPLIB

#if defined(_DEBUG)
#if defined(USELOGGING)
    g_fLogDebugOutput = TRUE;
#else
    g_fLogDebugOutput = FALSE;
#endif
#endif // USELOGGING

        setlocale( LC_ALL, "" );
        DisableThreadLibraryCalls(hInst);
 
        InitSGrfxControlInfo(hInst, &g_ctlinfoSG, AllocSGControl);
        InitPathControlInfo(hInst, &g_ctlinfoPath, AllocPathControl);
#ifdef INCLUDESOUND
        InitSoundControlInfo(hInst, &g_ctlinfoSound, AllocSoundControl);
#endif // INCLUDESOUND
        InitSpriteControlInfo(hInst, &g_ctlinfoSprite, AllocSpriteControl);
#ifdef INCLUDESEQ
	InitSeqControlInfo(hInst, &g_ctlinfoSeq, AllocSeqControl);
	InitSeqMgrControlInfo(hInst, &g_ctlinfoSeqMgr, AllocSequencerManager);
#endif //INCLUDESEQ
        
        g_ctlinfoSG.pNext = &g_ctlinfoPath; 
#ifndef INCLUDESOUND
        g_ctlinfoPath.pNext = &g_ctlinfoSprite; 
#else
        g_ctlinfoPath.pNext = &g_ctlinfoSound; 
        g_ctlinfoSound.pNext = &g_ctlinfoSprite; 
#endif // INCLUDESOUND

#ifdef INCLUDESEQ
        g_ctlinfoSprite.pNext = &g_ctlinfoSeq;
	g_ctlinfoSeq.pNext = &g_ctlinfoSeqMgr;
	g_ctlinfoSeqMgr.pNext = NULL;
#else
	g_ctlinfoSprite.pNext = NULL;
#endif
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
#ifdef USE_IHOCHELPLIB
        ::UninitializeStaticOCHelp();
#endif
        TRACE("DAExpress controls DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    // Give it the first control and it uses the pNext member to register all controls
    return RegisterControls(&g_ctlinfoSG, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
    // Give it the first control and it uses the pNext member to unregister all controls
	return RegisterControls(&g_ctlinfoSG, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Give it the first control and it uses the pNext member instantiate the correct one
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfoSG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\bvrcllbk.h ===
//
// Behaviour driver class
//
#ifndef __BVRCLLBK_H__
#define __BVRCLLBK_H__

#include <windows.h>
#include <daxpress.h>
#include "debug.h"

// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>

typedef BOOL (*PFNCONTINUEFUNCTION)(LPVOID);

class CCallbackBehavior : public IDAUntilNotifier
{
public :
    //
    // Constructors and destructors
    //
    CCallbackBehavior();
    ~CCallbackBehavior();

    //
    // Initialization
    //
    HRESULT Init(
        IDAStatics *pStatics, 
        IDAEvent *pEvent, 
        PFNCONTINUEFUNCTION pfnContinueFunction,
		LPVOID pvUserData,
        IDABehavior **ppBehavior);

    BOOL IsActive();
    BOOL SetActive(BOOL fActive);

    // Member variables
private:
    ULONG m_cRef; 
    PFNCONTINUEFUNCTION    m_pfnContinueFunction;
    BOOL                   m_fActive;
    CComPtr<IDAStatics>    m_StaticsPtr;
    CComPtr<IDAEvent>      m_EventPtr;
	LPVOID                 m_pvUserData;

    ///// IDAUntilNotifier 
protected:

    HRESULT STDMETHODCALLTYPE Notify(
        IDABehavior __RPC_FAR *eventData, 
        IDABehavior __RPC_FAR *curRunningBvr,
        IDAView __RPC_FAR *curView,
        IDABehavior __RPC_FAR *__RPC_FAR *ppBvr);

    ///// IUnknown
    public :

    HRESULT STDMETHODCALLTYPE QueryInterface(
        REFIID riid, 
        void __RPC_FAR *__RPC_FAR *ppvObject);

    ULONG STDMETHODCALLTYPE AddRef(void);

    ULONG STDMETHODCALLTYPE Release(void);

    ///// IDispatch implementation
protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);

    STDMETHODIMP GetTypeInfo(
        UINT itinfo, 
        LCID lcid, 
        ITypeInfo **pptinfo);

    STDMETHODIMP GetIDsOfNames(
        REFIID riid, 
        LPOLESTR *rgszNames, 
        UINT cNames,
        LCID lcid, 
        DISPID *rgdispid);

    STDMETHODIMP Invoke(
        DISPID dispidMember, 
        REFIID riid, 
        LCID lcid,
        WORD wFlags, 
        DISPPARAMS *pdispparams, 
        VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, 
        UINT *puArgErr);

};

#endif //__BVRCLLBK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\debug.cpp ===
// debug.cpp
//
// Debugging functions.
//

#include "..\ihbase\precomp.h"
#include <tchar.h>
#include "debug.h"


//////////////////////////////////////////////////////////////////////////////
// TRACE, ASSERT, VERIFY
//
// These are the same as MFC's functions of the same name (but are implemented
// without using MFC).  See "debug.h" for the actual macro definitions.
//

#ifdef _DEBUG

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
    // active popup window for the current thread
    HWND hwndParent = GetActiveWindow();
    if (hwndParent != NULL)
        hwndParent = GetLastActivePopup(hwndParent);

    // format message into buffer
    TCHAR atchAppName[_MAX_PATH * 2];
    TCHAR atchMessage[_MAX_PATH * 2];
    if (GetModuleFileName(g_hinst, atchAppName,
            sizeof(atchAppName) / sizeof(TCHAR)) == 0)
        atchAppName[0] = 0;
    wsprintf(atchMessage, _T("%s: File %hs, Line %d"),
        atchAppName, lpszFileName, nLine);

    // display the assert
    int nCode = MessageBox(hwndParent, atchMessage, _T("Assertion Failed!"),
        MB_TASKMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SETFOREGROUND);

    if (nCode == IDIGNORE)
        return FALSE;   // ignore

    if (nCode == IDRETRY)
        return TRUE;    // will cause DebugBreak()

    FatalExit(0);
    return TRUE;        // ...though FatalExit() should not return
}

void __cdecl Trace(LPCTSTR lpszFormat, ...)
{
    // start processing optional arguments
    va_list args;
    va_start(args, lpszFormat);

    // format the output string
    TCHAR atchBuffer[512];
    wvsprintf(atchBuffer, lpszFormat, args);

    // output the string
    OutputDebugString(atchBuffer);

    // end processing optional arguments
    va_end(args);
}

#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
// DebugIIDName, DebugCLSIDName
//
// These functions convert an IID or CLSID to a string name for debugging
// purposes (e.g. IID_IUnknown is converted to "IUnknown").
//

#ifdef _DEBUG

LPCSTR DebugGUIDName(REFGUID rguid, LPSTR szKey, LPSTR pchName)
{
    OLECHAR         achIID[100];        // interface ID (e.g. "{nnn-nnn-...}")  
    TCHAR           ach[150];

    // in case of error, clear <pchName>
    pchName[0] = 0;

    // convert <rguid> to a string (e.g. "{nnn-nnn-...}")
    StringFromGUID2(rguid, achIID, sizeof(achIID)/sizeof(achIID[0]));

    wsprintf(ach, TEXT("%hs\\%ls"), szKey, (LPOLESTR) achIID);
    
    // look up <achIID> in the registration database
#ifdef UNICODE
    TCHAR pchNameTemp[300];
    LONG cchNameTemp;
    cchNameTemp = _MAX_PATH;
    if (RegQueryValue(HKEY_CLASSES_ROOT, ach, pchNameTemp, &cchNameTemp)
            != ERROR_SUCCESS)
        // if <achIID> isn't in the registration database, use <achIID> itself
        wsprintf(pchNameTemp, TEXT("%ls"), (LPOLESTR) achIID);

    wcstombs(pchName, pchNameTemp, _MAX_PATH);
#else
    LONG cchNameTemp;
    cchNameTemp = _MAX_PATH;
    if (RegQueryValue(HKEY_CLASSES_ROOT, ach, pchName, &cchNameTemp)
            != ERROR_SUCCESS)
        // if <achIID> isn't in the registration database, use <achIID> itself
        wsprintf(pchName, TEXT("%ls"), (LPOLESTR) achIID);
#endif    
    return pchName;
}

#endif // _DEBUG


/* DebugIIDName

@func   Finds the name of an interface in the system registration database
        given the interface's IID (for debugging purposes only).

@rdesc  Returns a pointer to <p pchName>.

@comm   If the interface name is not found, a hexadecimal string form of
        <p riid> will be returned
        (e.g. "{209D2C80-11D7-101B-BF00-00AA002FC1C2}").

@comm   This function is only available in a debug build.
*/

#ifdef _DEBUG

LPCSTR DebugIIDName(

REFIID riid, /* @parm
        Interface ID to find the name of. */

LPSTR pchName) /* @parm
        Where to store the class ID name string.  This buffer should be
        large enough to hold _MAX_PATH characters. */

{
    return DebugGUIDName(riid, "Interface", pchName);
}

#endif


/* DebugCLSIDName

@func   Finds the name of an interface in the system registration database
        given the interface's CLSID (for debugging purposes only).

@rdesc  Returns a pointer to <p pchName>.

@comm   If the interface name is not found, a hexadecimal string form of
        <p rclsid> will be returned
        (e.g. "{209D2C80-11D7-101B-BF00-00AA002FC1C2}").

@comm   This function is only available in a debug build.
*/

#ifdef _DEBUG

LPCSTR DebugCLSIDName(

REFCLSID rclsid, /* @parm
        Class ID to find the name of. */

LPSTR pchName) /* @parm
        Where to store the class ID name string.  This buffer should be
        large enough to hold _MAX_PATH characters. */

{
    return DebugGUIDName(rclsid, "Clsid", pchName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\clocker.h ===
#ifndef __CLOCKER_H__
#define __CLOCKER_H__

#include "objbase.h"
// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>
#include <servprov.h>
#include <daxpress.h>
#include <ocmm.h>
#include <htmlfilter.h>

class CClockerSink
{
public:
    CClockerSink(void) {}
    virtual ~CClockerSink(void) {}

    virtual void OnTimer(DWORD dwTime)=0;
};

class CClocker : public ITimerSink
{
 public :
    typedef enum {CT_ITimer = 0, CT_WMTimer = 1} CCT;

        
        CClocker (void);
        virtual ~CClocker (void);

        HRESULT SetView (IDAView * piView);
        HRESULT SetHost (IOleClientSite * pocsHost);
        HRESULT SetVisible (BOOL fVisible);
        HRESULT SetSink(CClockerSink *pClockerSink);
        HRESULT SetInterval(ULONG iInterval);
    void SetTimerType(CCT ct) { m_CT = ct; }
    void SetAsync(BOOL fAsync) { m_fAsync = fAsync; }

        HRESULT Start (void);
        HRESULT Stop (void);

        // For the timer sink.
        STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
        STDMETHOD_(ULONG, AddRef) (void);
        STDMETHOD_(ULONG, Release) (void);
        STDMETHOD(OnTimer) (VARIANT varTimeAdvise);

 protected :

        HRESULT InitTimer (void);
    HRESULT CreateWindowsTimer (void);
        HRESULT FindTimer (void);
        HRESULT FindContainerTimer (void);
        HRESULT FindDefaultTimer (void);
    HRESULT MakeWindow(HINSTANCE hInstance, BOOL fCreateTimerWindow);
    HRESULT KillWindow(void);
    HRESULT DispatchTimer(DWORD dwTime);

    HWND m_hwnd;
    BOOL m_fToggle;
    BOOL m_fAsync;
        ULONG m_ulRefs;
        CComPtr<IDAView> m_cView;
        CComPtr<IOleClientSite> m_cHost;
        CComPtr<ITimer> m_cTimer;
        BOOL m_fVisible;
        BOOL m_fIgnoreAdvises;
        DWORD m_dwCookie;
    CClockerSink *m_pClockerSink;
        ULONG m_iTimerInterval;
    UINT_PTR m_iTimerID; // SetTimer thing
    CCT m_CT;

    static LRESULT __stdcall WndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);
    static LRESULT __stdcall TimerWndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);

    static BOOL g_fNotifyClassRegistered;
    static BOOL g_fTimerClassRegistered;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\ihbase.h ===
/*++

Module:
    ihbase.h

Author:
    IHammer Team (SimonB)

Created:
    October 1996

Description:
    Base class for implementing MMCtl controls

History:
    08-02-1997  Changed the implementation of IOleControl::FreezeEvents.  See the comment in that
                function for details (SimonB)
    07-28-1997  Added m_fInvalidateWhenActivated and supporting code.  This allows controls
                to be invalidated as soon as they are activated. (SimonB)
    04-07-1997  Added support for OnWindowLoad and OnWindowUnload.  This is Trident-specific (SimonB)
    04-03-1997  Modified QI to use a switch statement rather than if ... else blocks.  See the
                QI implementation for details on how to modify it.
    03-13-1997  Changed IOleObject::GetUserType.  Now call the Ole helper directly, rather than rely
                on the caller to do so.
    03-11-1997  Changed IOleObject::GetUserType.  OLE now provides the implementation. (SimonB)
    02-27-1997  Removed CFakeWindowlessClientSite and associated support (SimonB)
    02-18-1997  IOleObject::GetClientSite() implemented (NormB)
    02-17-1997  QI re-ordered for improved performance (NormB)
    01-21-1997  Added support for IObjectSafety (SimonB)
    01-02-1997  Added #ifdef _DESIGN around the property page and parameter page code.  Also
                fixed a bug in IOleObject::GetUserType (SimonB)
    12-30-1996  Added code for property pages. If you want to specify (tell someone else about)
                property pages you must define CONTROL_SPECIFIES_PROPERTY_PAGES and implement
                the ISpecifyPropertyPages interface. (a-rogerw)
    12-23-1996  Added code for parameter pages. If you want to specify (tell ActView about)
                parameter pages you must define CONTROL_SPECIFIES_PARAMETER_PAGES and implement
                the ISpecifyParameterPages interface. (a-rogerw)
    12-18-1996  Added CFakeWindowlessClientSite.  If we can't get a windowless site
                in SetClientSite, an instance of this class is created to handle
                any methods on that site we might need.  Only IUnknown is implemented -
                all other methods return E_FAIL.  This ensures we don't crash in
                containers that don't host windowless controls (like IE 3.0)    (SimonB)
    12-07-1996  Add ResizeControl member function (SimonB)
    11-30-1996  Improve debug output (SimonB)
    11-11-1996  Add caching of bounds in m_rcBounds (SimonB)
    11-10-1996  Add DoVerb code, IOleInPlaceObjectWindowless support (PhaniV)
    11-05-1996  Initialize m_size to something other than 0 (SimonB)
    10-21-1996  Templatized (SimonB)
    10-01-1996  Created (SimonB)

++*/


#ifndef __IHBASE_H__
#define __IHBASE_H__

#include "precomp.h"
#include <ihammer.h>
#include "..\mmctl\inc\ochelp.h"
#include "objsafe.h"
#include "utils.h"
#include "iids.h" // #defines for the .Data1 members of all the IID's we support
#include <minmax.h>

#ifdef SUPPORTONLOAD // Does the control need OnWindowLoad support ?
#include "onload.h"

#ifdef Delete
#define REDEFINE_DELETE_LATER
#undef Delete // remove the definition so <mshtml.h> won't barf
#endif

#include <mshtml.h>

#ifdef REDEFINE_DELETE_LATER
#undef REDEFINE_DELETE_LATER
#define Delete delete
#endif

#endif // SUPPORTONLOAD

#define CX_CONTROL      11      // control natural width (pixels)
#define CY_CONTROL      11      // control natural height (pixels)

/*
// REVIEW: How are we going to deal with this stuff (Simonb)
#define CRGB_CONTROL    8       // how many colors in control's palette
#define RGB_START       RGB(0,200,0)     // start of palette gradient
#define RGB_END         RGB(250,0,0) // end of palette gradient
*/

#ifndef _SYS_GUID_OPERATORS_
#ifndef _OLE32_
inline BOOL  InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
      ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
      ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
      ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
      ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}
#endif // _OLE32_
#endif  _SYS_GUID_OPERATORS_


// Just compare the last 3 elements ...
inline BOOL ShortIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return (
      ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
      ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
      ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}

#ifndef New
#define New new
#pragma message("NOT Using IHammer New and Delete")
#endif

#ifndef Delete
#define Delete delete
#endif

#define LANGID_USENGLISH MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)

// control's OLEMISC_ flags
#define CTL_OLEMISC \
        OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | \
        OLEMISC_INSIDEOUT | OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE;

// Turn on IObjectSafety support
#define USEOBJECTSAFETY

// globals
extern ControlInfo  g_ctlinfo;      // class information structure

// function that initializes <g_ctlinfo>
void InitControlInfo();

// control implementation

/*
template
    <
    class tempCDerived,            // The derived class
    class tempICustomInterface, // Base class
    const IID * temppCLSID,    // CLSID for the custom class
    const IID * temppIID,        // IID for the custom interface
    const IID * temppLIBID,    // LIBID for the control's typelib
    const IID * temppEventID    // DIID for the event sink
    >

*/
#define TEMPLATE_IHBASE_DEF template < \
    class tempCDerived, class tempICustomInterface, \
    const IID * temppCLSID,    const IID * temppIID,const IID * temppLIBID,const IID * temppEventID \
    >


// TEMPLATE_IHBASE_DEF

template <
    class tempCDerived,
    class tempICustomInterface,
    const IID * temppCLSID,
    const IID * temppIID,
    const IID * temppLIBID,
    const IID * temppEventID
    >
class CIHBaseCtl :
    public INonDelegatingUnknown,
#ifndef NOIVIEWOBJECT
    public IViewObjectEx,
#endif
    public IOleObject,
    public IPersistVariantIO,
    public IOleControl,
    public IConnectionPointContainer,
    public IProvideClassInfo,
    public IOleInPlaceObjectWindowless
#ifdef USEOBJECTSAFETY
    ,public IObjectSafety
#endif // USEOBJECTSAFETY

#ifdef _DESIGN
    ,public ISpecifyPropertyPages        //this is defined even in runtime, Simon.
#endif //_DESIGN

#ifdef SUPPORTONLOAD
    ,public CIHBaseOnLoad
#endif // SUPPORTONLOAD
{
    // Template typedefs
protected:

    typedef tempCDerived control_class;
    typedef tempICustomInterface control_interface;

    // Control state
protected:

    SIZEL m_Size;
    BOOL m_fDirty;
    IUnknown *m_punkPropHelp;
    IDispatch *m_pContainerDispatch; // Point to the container's IDispatch (for ambient property support)
    BOOL m_fDesignMode;
    HelpAdviseInfo m_advise;  // Advise helper

    RECT m_rcBounds;
    RECT m_rcClipRect;
    BOOL m_fControlIsActive; // Keep track of whether we're active or not
    BOOL m_fEventsFrozen;
    long m_cFreezeEvents;
    BOOL m_fInvalidateWhenActivated;

#ifdef SUPPORTONLOAD
private:
    CLUDispatch *m_pcLUDispatch;  // IDispatch for Load/Unload
    DWORD m_dwWindowEventConPtCookie;
    IConnectionPoint *m_pContainerConPt;
#endif
    //
    // construction, destruction
    //
public:

// Add these later
// #pragma optimize("a", on) // Optimization: assume no aliasing
    CIHBaseCtl(IUnknown *punkOuter, HRESULT *phr):
        m_punkPropHelp(NULL),
        m_pTypeInfo(NULL),
        m_pTypeLib(NULL),
        m_pContainerDispatch(NULL),
        m_fDesignMode(FALSE),
        m_fDirty(FALSE),
        m_cRef(1),
        m_pocs(NULL),
        m_poipsw(NULL),
        m_fControlIsActive(FALSE),
        m_fEventsFrozen(FALSE),
        m_cFreezeEvents(0),
        m_fInvalidateWhenActivated(FALSE)
#ifdef SUPPORTONLOAD
        ,m_pcLUDispatch(NULL),
        m_dwWindowEventConPtCookie(0),
        m_pconpt(NULL),
        m_pContainerConPt(NULL)
#endif
    {
        TRACE("CIHBaseCtl 0x%08lx created\n", this);

        // initialize IUnknown state
        m_punkOuter = (punkOuter == NULL ?
            (IUnknown *) (INonDelegatingUnknown *) (tempCDerived *)this : punkOuter);

        // other initialization

        // Initialize the structure for storing the size
        PixelsToHIMETRIC(CX_CONTROL, CY_CONTROL, &m_Size);

        m_fDirty = FALSE;

        // don't allow COM to unload this DLL while an object is alive
        InterlockedIncrement((LONG*)&g_cLock);

        // Initialise helper support for IViewObject::SetAdvise and ::GetAdvise
        InitHelpAdvise(&m_advise);
        *phr = AllocPropertyHelper(m_punkOuter,
                    (tempCDerived *)this,
                    *temppCLSID,
                    0,
                    &m_punkPropHelp);

        // Zero out our bounds and clipping region
        ZeroMemory(&m_rcBounds, sizeof(m_rcBounds));
        ZeroMemory(&m_rcClipRect, sizeof(m_rcClipRect));

        if (FAILED(*phr))
        {
            goto Exit;
        }

    *phr = AllocConnectionPointHelper((IUnknown *) (IDispatch *) (tempCDerived *)this,
        *temppEventID, &m_pconpt);

    if (FAILED(*phr))
    {
        goto Exit;
    }

    Exit:
        ;

    }


    virtual ~CIHBaseCtl()
    {
        TRACE("CIHBaseCtl 0x%08lx destroyed\n", this);

        UninitHelpAdvise(&m_advise);

        // clean up Event helper
        if (NULL != m_pconpt)
            FreeConnectionPointHelper(m_pconpt);

        // Free up the property helper
        SafeRelease((LPUNKNOWN *)&m_punkPropHelp);

        // Free up the typeinfo
        SafeRelease((LPUNKNOWN *)&m_pTypeInfo);

        //Free up the typelib
        SafeRelease((LPUNKNOWN *)&m_pTypeLib);

        // decrement lock count that was incremented in constructor
        InterlockedDecrement((LONG*)&g_cLock);

    }

protected:

    // This member was added to the base class to make life easier
    // for control authors wishing to resize their control.
    // Resizing controls is discussed in the OC96 spec
#ifdef NOTNEEDED
    STDMETHODIMP ResizeControl(long lWidth, long lHeight)
    {
        // CX and CY should be in pixels
        HRESULT hRes;

        // Convert units, and store
        PixelsToHIMETRIC(lWidth, lHeight, &m_Size);

        DEBUGLOG("IHBase: ResizeControl\n");
        if (m_fControlIsActive)
        {
            RECT rcRect;

            DEBUGLOG("IHBase: Control is active, watch for SetObjectRects\n");
            rcRect.top = m_rcBounds.top;
            rcRect.left = m_rcBounds.left;
            rcRect.right = m_Size.cx + m_rcBounds.left;
            rcRect.bottom = m_Size.cy + m_rcBounds.top;

            // ASSERT(m_poipsw != NULL);
            if (m_poipsw)
                hRes = m_poipsw->OnPosRectChange(&rcRect);
            else
                hRes = E_FAIL;

            // ::SetObectRects should be called right after this by the container
        }
        else
        {
            DEBUGLOG("IHBase: Control is inactive, watch for SetExtent\n");

            ASSERT(m_pocs != NULL);
            hRes = m_pocs->RequestNewObjectLayout();
            // GetExtent, and then SetExtent are called
        }

        return hRes;
    }

#endif // NOTNEEDED


///// non-delegating IUnknown implementation
protected:
    ULONG           m_cRef;         // object reference count
    virtual STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
    {
        HRESULT hRes = S_OK;
        BOOL fFallThrough = FALSE;

        if (NULL != ppv)
            *ppv = NULL;
        else
            return E_POINTER;


    #ifdef _DEBUG
        char ach[200];
        TRACE("IHBase::QI('%s')\n", DebugIIDName(riid, ach));
    #endif

        //
        // NOTE:    This QI does not handle IDispatch.  This is intentional.  This
        //            function must be overidden in the control's implementation.  See
        //            ihctl\control.cpp for details.
        //

        // NOTE:  A VTune session w/ structured-graphics showed the IViewObject* family,
        // IOleObject, IOleInPlaceObjectWindowless, and IOleControl were the most frequently
        // queried riids.  I've moved them forward and chosen InlineIsEqualGUID for them. (normb)
        // This is no longer necessary now that a switch is used (simonb)

        /*
        To add a GUID to this list:
        1) Modify dmpguid.cpp in the dmpguid subdirectory.  Build, and copy the
           updated binary to the dmpguid directory.
        2) Use the MakeHdr batch file in the dmpguid directory.  This will produce iids.h

        NOTE: If dmpguid mentions a collision, Data1 for two IID's collides.  Therefore, in
              the case for the two IIDs, you will have to determine which is being QI's for

        */
        switch (riid.Data1)
        {
#ifndef NOIVIEWOBJECT
            case IID_IViewObject_DATA1:
                if (!ShortIsEqualGUID(riid, IID_IViewObject))
                    break;
                else
                    fFallThrough = TRUE;
            //Intentional fall-through
            case IID_IViewObject2_DATA1:
                if (!ShortIsEqualGUID(riid, IID_IViewObject2))
                    break;
                else
                    fFallThrough = TRUE;
            //Intentional fall-through
            case IID_IViewObjectEx_DATA1:
            {
                if ((fFallThrough) || (ShortIsEqualGUID(riid, IID_IViewObjectEx)))
                {
                    IViewObjectEx *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;
#endif // NOIVIEWOBJECT

            case IID_IOleObject_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IOleObject))
                {
                    IOleObject *pThis = this;
                *ppv = (LPVOID) pThis;
                }
            }
            break;

            case IID_IOleInPlaceObjectWindowless_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IOleInPlaceObjectWindowless))
                {
                    IOleInPlaceObjectWindowless *pThis = this;
                    *ppv = (LPVOID) pThis;
                }

            }
            break;

            case IID_IOleControl_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IOleControl))
                {
                    IOleControl *pThis = this;
                    *ppv = (LPVOID) pThis;
                }

            }
            break;

            case IID_IConnectionPointContainer_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IConnectionPointContainer))
                {
                    IConnectionPointContainer *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;

            case IID_IOleInPlaceObject_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IOleInPlaceObject))// Review(SimonB) Is this necessary ?
                {
                    IOleInPlaceObject *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;

            case IID_IPersistVariantIO_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IPersistVariantIO))
                {
                    IPersistVariantIO *pThis = this;
                    *ppv = (LPVOID) pThis;
                }

            }
            break;

            case IID_IProvideClassInfo_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IProvideClassInfo))
                {
                    IProvideClassInfo *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;

#ifdef USEOBJECTSAFETY
            case IID_IObjectSafety_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IObjectSafety))
                {
                    IObjectSafety *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;
#endif // USEOBJECTSAFETY

#ifdef _DESIGN
            case IID_ISpecifyPropertyPages_DATA1:
            {
                if (IsEqualIID(riid, IID_ISpecifyPropertyPages))
                {
                    ISpecifyPropertyPages *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;
#endif //_DESIGN

            case IID_IUnknown_DATA1:
            {
                if (IsEqualIID(riid, IID_IUnknown))
                {
                     IUnknown *pThis = (IUnknown *)(INonDelegatingUnknown *) this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;
        }

        if (NULL == *ppv)
        {
            ASSERT(m_punkPropHelp != NULL);


#ifdef _DEBUG
            HRESULT hRes = m_punkPropHelp->QueryInterface(riid, ppv);
            if (NULL != *ppv) {
                DEBUGLOG("IHBase: Interface supported in OCHelp\n");
            } else {
                DEBUGLOG("IHBase: Interface not supported !\n");
            }
            return hRes;
#else
            return m_punkPropHelp->QueryInterface(riid, ppv);
#endif
        }

        if (NULL != *ppv)
        {
            DEBUGLOG("IHBase: Interface supported in base class\n");
            ((IUnknown *) *ppv)->AddRef();
        }

        return hRes;
    }


    STDMETHODIMP_(ULONG) NonDelegatingAddRef()
    {
#ifdef _DEBUG //Review(Unicode)
        TCHAR tchDebug[50];
        wsprintf(tchDebug, "IHBase: AddRef: %lu\n", m_cRef + 1);
        DEBUGLOG(tchDebug);
#endif

        return ++m_cRef;
    }


    STDMETHODIMP_(ULONG) NonDelegatingRelease()
    {
#ifdef _DEBUG
        TCHAR tchDebug[50];
        wsprintf(tchDebug, TEXT("IHBase: Releasing with refcount: %lu\n"), m_cRef - 1);
        DEBUGLOG(tchDebug);
#endif
        if (--m_cRef == 0L)
        {
            // free the object
            Delete this;
            return 0;
        }
        else
            return m_cRef;

    }

///// delegating IUnknown implementation
protected:
    LPUNKNOWN       m_punkOuter;    // controlling unknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

///// IViewObject implementation
protected:
    IOleClientSite *m_pocs;         // on client site
    IOleInPlaceSiteWindowless *m_poipsw; // on client site

protected:

#ifndef NOIVIEWOBJECT
    virtual STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
         BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue) = 0; // pure virtual


    STDMETHODIMP GetColorSet(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hicTargetDev, LOGPALETTE **ppColorSet)
    {
        // TODO: replace the contents of this function with real code
        // that returns the control's palette; return E_NOTIMPL if the
        // control uses only the 16 system colors

        return E_NOTIMPL;
    }


    STDMETHODIMP Freeze(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DWORD *pdwFreeze)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP Unfreeze(DWORD dwFreeze)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP SetAdvise(DWORD dwAspects, DWORD dwAdvf, IAdviseSink *pAdvSink)
    {
        return HelpSetAdvise(dwAspects, dwAdvf, pAdvSink, &m_advise);
    }

    STDMETHODIMP GetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
        IAdviseSink **ppAdvSink)
    {
        return HelpGetAdvise(pdwAspects, pdwAdvf, ppAdvSink, &m_advise);
    }

///// IViewObject2 implementation
protected:
    STDMETHODIMP GetExtent(DWORD dwDrawAspect, LONG lindex,
        DVTARGETDEVICE *ptd, LPSIZEL lpsizel)
    {
        DEBUGLOG("IHBase: IViewObject2::GetExtent\n");
        if (lpsizel)
        {
            switch (dwDrawAspect)
            {
                case(DVASPECT_CONTENT):
                // Intentional fallthrough
                case(DVASPECT_OPAQUE):
                // Intentional fallthrough
                case(DVASPECT_TRANSPARENT):
                {
                    lpsizel->cx = m_Size.cx;
                    lpsizel->cy = m_Size.cy;
                    return S_OK;
                }
                break;
                default:
                    return E_FAIL;
            }
        }
        else
        {
            return E_POINTER;
        }

    }


///// IViewObjectEx implementation

    STDMETHODIMP GetRect(DWORD dwAspect, LPRECTL pRect)
    {

        // This is written so that objects are assumed to be transparent
        // Opaque objects or objects which need more control should override
        // this method
        if (NULL != pRect)
        {
            switch (dwAspect)
            {
                case(DVASPECT_CONTENT):
                // Intentional fallthrough
                case(DVASPECT_TRANSPARENT):
                {
                    pRect->left = m_rcBounds.left;
                    pRect->right = m_rcBounds.right;
                    pRect->top = m_rcBounds.top;
                    pRect->bottom = m_rcBounds.bottom;
                    return S_OK;
                }
                break;
                default:
                    return DV_E_DVASPECT;
                break;
            }
        }
        else
        {
            return E_POINTER;
        }
    }

    STDMETHODIMP GetViewStatus(DWORD* pdwStatus)
    {

        if (NULL == pdwStatus)
        {
            return E_POINTER;
        }
        else
        {
            DWORD dwStatus = VIEWSTATUS_DVASPECTTRANSPARENT;

#ifdef USE_VIEWSTATUS_SURFACE
// TODO: hack for now until this makes it into the public Trident
// header files.
#define VIEWSTATUS_SURFACE 0x10
#define VIEWSTATUS_D3DSURFACE 0x20

             dwStatus = VIEWSTATUS_SURFACE | VIEWSTATUS_D3DSURFACE;
#endif // USE_VIEWSTATUS_SURFACE

            // Indicate that we are tranparent
            *pdwStatus = dwStatus;
            return S_OK;
        }
    }


    STDMETHODIMP QueryHitPoint(DWORD dwAspect, LPCRECT prcBounds,
                               POINT ptLoc, LONG lCloseHint, DWORD* pHitResult)
    {
#ifndef NOHITTESTING
        if ((NULL == pHitResult) || (NULL == prcBounds))
            return E_POINTER;

        *pHitResult = HITRESULT_OUTSIDE;

        switch (dwAspect)
        {
        case(DVASPECT_CONTENT):
        case(DVASPECT_TRANSPARENT):
            if (PtInRect(prcBounds, ptLoc))
            {
                // Are we inside ?
                *pHitResult = HITRESULT_HIT;
            }
            else // Are we near ?
            {
                SIZE size;
                RECT rcInflatedBounds = *prcBounds;

                // lCloseHint is in HIMETRIC unit - cnvert to pixels
                HIMETRICToPixels(lCloseHint, lCloseHint, &size);
                // Expand the rect
                InflateRect(&rcInflatedBounds, size.cx, size.cy);

                if (PtInRect(&rcInflatedBounds, ptLoc))
                    *pHitResult = HITRESULT_CLOSE;
            }
            return S_OK;
        default:
            return E_FAIL;
        }
#else // NOHITTESTING
        return E_NOTIMPL;
#endif // NOHITTESTING

    }

    STDMETHODIMP QueryHitRect(DWORD dwAspect, LPCRECT pRectBounds,
                              LPCRECT prcLoc, LONG lCloseHint, DWORD* pHitResult)
    {
#ifndef NOHITTESTING
        if ((pRectBounds == NULL) || (prcLoc == NULL) || (pHitResult == NULL))
            return E_POINTER;

        // For the time being, there is a hit if the object rectangle
        // intersects the container rectangle.

        RECT rcIntersection;

        *pHitResult = ::IntersectRect(&rcIntersection, pRectBounds, prcLoc)
                      ? HITRESULT_HIT
                      : HITRESULT_OUTSIDE;
        return S_OK;
#else // NOHITTESTING
        return E_NOTIMPL;
#endif // NOHITTESTING

    }

    STDMETHODIMP GetNaturalExtent(DWORD dwAspect, LONG lindex,
                                  DVTARGETDEVICE* ptd, HDC hicTargetDev,
                                  DVEXTENTINFO* pExtentInfo, LPSIZEL psizel)
    {
        DEBUGLOG("IHBase: GetNaturalExtent\n");
        return E_NOTIMPL;
    }

#endif // NOIVIEWOBJECT


///// IOleObject implementation
protected:
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite)
    {
        HRESULT hRes = S_OK;

#ifdef _DEBUG
        DEBUGLOG(TEXT("IHBase: SetClientSite\n"));
#endif

        // release the currently-held site pointers
        SafeRelease((LPUNKNOWN *)&m_pocs);
        SafeRelease((LPUNKNOWN *)&m_poipsw);
        SafeRelease((LPUNKNOWN *)&m_pContainerDispatch);
#ifdef SUPPORTONLOAD
        ReleaseContainerConnectionPoint();
#endif


        // store the new site pointers
        m_pocs = pClientSite;
        if (m_pocs != NULL)
        {
            m_pocs->AddRef();
            hRes = m_pocs->QueryInterface(IID_IOleInPlaceSiteWindowless,
                        (LPVOID *) &m_poipsw);
#ifdef _DEBUG
            // Could we get a windowless site ?
            if (FAILED(hRes))
            {
                ODS("IHBase: SetClientSite unable to get an IOleInPlaceSiteWindowless pointer.  IE 3.0 ?\n");
            }
#endif // _DEBUG

            hRes = m_pocs->QueryInterface(IID_IDispatch,
                                (LPVOID *) &m_pContainerDispatch);

            // if the control is connected to a site that supports IDispatch,
            // retrieve the ambient properties that we care about
            if (SUCCEEDED(hRes))
                OnAmbientPropertyChange(DISPID_UNKNOWN);

#ifdef SUPPORTONLOAD
            ConnectToContainerConnectionPoint();
#endif
        }

        return hRes;
    }



    STDMETHODIMP GetClientSite(IOleClientSite **ppClientSite)
    {
        if( ppClientSite )
        {
            if (m_pocs)
                m_pocs->AddRef();

            *ppClientSite = m_pocs;

            return S_OK;
        }
        return E_POINTER;
    }


    STDMETHODIMP SetHostNames(LPCOLESTR szContainerApp,
        LPCOLESTR szContainerObj)
    {
        return E_NOTIMPL;
    }


    STDMETHODIMP Close(DWORD dwSaveOption)
    {
        DEBUGLOG("IHBase: Close\n");
#ifdef SUPPORTONLOAD
        ReleaseContainerConnectionPoint();
#endif //SUPPORTONLOAD
        return S_OK;
    }


    STDMETHODIMP SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk)
     {
        return E_NOTIMPL;
    }


   STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
        IMoniker **ppmk)
    {
        return E_NOTIMPL;
    }


    STDMETHODIMP InitFromData(IDataObject *pDataObject, BOOL fCreation,
        DWORD dwReserved)
    {
        return E_NOTIMPL;
    }


    STDMETHODIMP GetClipboardData(DWORD dwReserved, IDataObject **ppDataObject)
    {
        return E_NOTIMPL;
    }

    // Copied from mmctl\hostlwoc\control.cpp and modified
    // Handle the OLEIVERB_INPLACEACTIVATE case of IOleObject::DoVerb
    STDMETHODIMP OnVerbInPlaceActivate(HWND hwndParent,
                                            LPCRECT lprcPosRect)
    {
        BOOL        fRedraw;
        HRESULT     hrReturn = S_OK;    // return value from this method

        ASSERT (lprcPosRect != NULL); // IE3 does this sometimes...

        // This should never fire, but just in case ...
        ASSERT(NULL != m_poipsw);

        //Review(SimonB): Do you handle the case where the container can't handle
        //Windlowless controls but can handle windowed controls? May be we are not
        //interested in this case. But I wanted to flag this - PhaniV


        // if we can go in-place active, notify container that we're doing so
        if (S_OK == m_poipsw->CanInPlaceActivate())
        {
            m_fControlIsActive = TRUE;
        }
        else
        {
            hrReturn = E_FAIL;
            goto EXIT;
        }

        if (FAILED(hrReturn = m_poipsw->OnInPlaceActivateEx(&fRedraw, ACTIVATE_WINDOWLESS)))
            goto EXIT;

        EXIT:
            return hrReturn;
    }


    STDMETHODIMP DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite,
        LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
     {
        switch (iVerb)
        {
            // Review(SimonB): Previously none of these is handled. Now at least
            // we handle Inplaceactivate. Investigate if others need be handled
            // - PhaniV

            case OLEIVERB_UIACTIVATE:
            {
                return S_OK;
            }
            break;

            case OLEIVERB_DISCARDUNDOSTATE:
            case OLEIVERB_HIDE:
            case OLEIVERB_SHOW:
            case OLEIVERB_OPEN:
                return E_NOTIMPL;
            break;

            case OLEIVERB_INPLACEACTIVATE:
            {
                HRESULT hRes = S_OK;
                // Some containers (Trident, for example) call this to give us our bounds.
                // Others (like ALX) give us our bounds through SetObjectRects

                // Make sure our site can support windowless objects

                // If make sure we actually have a site, and can activate windowless
                if ((NULL == m_poipsw) || (S_OK != m_poipsw->CanWindowlessActivate()))
                {
#ifdef _DEBUG
                    MessageBox(hwndParent,
                               TEXT("This container does not support windowless controls."),
                               TEXT("Error"),
                               MB_OK);
#endif
                    return E_NOTIMPL;
                }

                // Cache our bounds
                if (lprcPosRect)
                {
                    DEBUGLOG(TEXT("IHBase: caching bounds in DoVerb\n"));
                    CopyMemory(&m_rcBounds, lprcPosRect, sizeof(m_rcBounds));
                }

                if (SUCCEEDED(hRes = OnVerbInPlaceActivate(hwndParent, lprcPosRect)) && m_fInvalidateWhenActivated)
                {
                    ASSERT(NULL != m_poipsw);
                    m_poipsw->InvalidateRect(NULL, FALSE);
                    m_fInvalidateWhenActivated = FALSE;
                }
                return hRes;
            }
            break;

            default:
                return OLEOBJ_S_INVALIDVERB;
        }

        return S_OK;
    }


    STDMETHODIMP EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
     {
        return E_NOTIMPL;
    }


    STDMETHODIMP Update(void)
     {
        return E_NOTIMPL;
    }


    STDMETHODIMP IsUpToDate(void)
     {
        return E_NOTIMPL;
    }


    STDMETHODIMP GetUserClassID(CLSID *pClsid)
     {
        if (NULL != pClsid)
        {
            *pClsid = *temppCLSID;
        }
        else
        {
            return E_POINTER;
        }

        return S_OK;
    }

    STDMETHODIMP GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
    {
        /*
        Theoretically, this function should be able to just return OLE_S_USEREG and
        the caller should then call OleRegGetUserType.  However, most callers seem to
        be too lazy, so I just do it here for them
        */

        return OleRegGetUserType(*temppCLSID, dwFormOfType, pszUserType);
    }


    STDMETHODIMP SetExtent(DWORD dwDrawAspect,SIZEL *psizel)
    {
        DEBUGLOG("IHBase: IOleObject::SetExtent\n");

        if (NULL == psizel)
            return E_POINTER;

        if (DVASPECT_CONTENT == dwDrawAspect)
        {
            m_Size.cx = psizel->cx;
            m_Size.cy = psizel->cy;
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }

    STDMETHODIMP GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
    {
        DEBUGLOG("IHBase: IOleObject::GetExtent\n");

        if (NULL == psizel)
            return E_POINTER;

        if (DVASPECT_CONTENT == dwDrawAspect)
        {
            psizel->cx = m_Size.cx ;
            psizel->cy = m_Size.cy ;
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }

    STDMETHODIMP Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
     {
        DEBUGLOG("IHBase: Advise\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP Unadvise(DWORD dwConnection)
     {
        DEBUGLOG("IHBase: Unadvise\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP EnumAdvise(IEnumSTATDATA **ppenumAdvise)
     {
        DEBUGLOG("IHBase: EnumAdvise\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
    {
        DEBUGLOG("IHBase: GetMiscStatus\n");

        if (NULL == pdwStatus)
            return E_POINTER;

        *pdwStatus = CTL_OLEMISC;
        return S_OK;
    }

    STDMETHODIMP SetColorScheme(LOGPALETTE *pLogpal)
     {
        DEBUGLOG("IHBase: SetColorScheme\n");
        return E_NOTIMPL;
    }



///// IPersistVariantIO implementation
protected:
    STDMETHODIMP InitNew()
    {
        DEBUGLOG("IHBase: InitNew\n");
        return S_OK;
    }

    STDMETHODIMP IsDirty()
    {
        DEBUGLOG("IHBase: IsDirty\n");
                // REVIEW pauld - we're currently not properly updating the
                // dirty flag diligently.  When excalibur tries to edit a control's
                // properties, the changes are not properly persisted out to
                // the page as a result (since the private save that excalibur
                // calls clears our dirty flag).  This is currently blocking authoring.
                // This is a workaround until we change the code to update the
                // dirty flag in all of the right places.
                if (!m_fDesignMode)
                {
                        return (m_fDirty) ? S_OK : S_FALSE;
                }
                else
                {
                        return S_OK;
                }
    }

    STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags) = 0; // PURE


///// IOleControl implementation
protected:
    STDMETHODIMP GetControlInfo(LPCONTROLINFO pCI)
       {
        DEBUGLOG("IHBase: GetControlInfo\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP OnMnemonic(LPMSG pMsg)
       {
        DEBUGLOG("IHBase: OnMnemonic\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP OnAmbientPropertyChange(DISPID dispid)
    {
        DEBUGLOG("IHBase: OnAmbientPropertyChange\n");
        // can't do anything if the container doesn't support ambient properties
        if (m_pContainerDispatch == NULL)
            return E_FAIL;

        if ((dispid == DISPID_UNKNOWN) || (dispid == DISPID_AMBIENT_USERMODE))
        {
            // assume the user mode (design vs preview/run) changed...
            VARIANT var;
            if (SUCCEEDED(
                    DispatchPropertyGet(m_pContainerDispatch, DISPID_AMBIENT_USERMODE, &var)) &&
                (var.vt == VT_BOOL) &&
                ((V_BOOL(&var) != 0) != !m_fDesignMode))
            {
                // we switched between design and preview/run mode
                m_fDesignMode = (V_BOOL(&var) == 0);
                TRACE("IHBase: m_fDesignMode=%d\n", m_fDesignMode);

                // draw or erase the grab handles
                // CtlInvalidateHandles();
            }
        }

        return S_OK;
    }

    STDMETHODIMP FreezeEvents(BOOL bFreeze)
    {
        // Although the documentation doesn't mention this, Trident seems to assume that
        // FreezeEvents is implemented on a counter system: when the counter gets to 0,
        // events are unfrozen.  ATL implements it this way, so I assume it is correct
        // (SimonB, 08-02-1997)

        if (bFreeze)
        {
            m_fEventsFrozen = TRUE;
            m_cFreezeEvents++;
        }
        else
        {
            // Count should never go below 0 ...
            ASSERT(m_cFreezeEvents > 0);

            if (m_cFreezeEvents > 0)
                m_cFreezeEvents--;

            if (0 == m_cFreezeEvents)
                m_fEventsFrozen = FALSE;
        }

#ifdef _DEBUG
        TCHAR tchString[50];
        wsprintf(tchString, TEXT("IHBase: FreezeEvents (%lu)\n"), m_cFreezeEvents);
        DEBUGLOG(tchString);
#endif

        return S_OK;
    }



///// IConnectionPointContainer implementation
protected:
    IConnectionPointHelper *m_pconpt; // our single connection point
protected:
    STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS *ppEnum)
    {
        DEBUGLOG("IHBase: EnumConnectionPoints\n");
        ASSERT(m_pconpt != NULL);
        return m_pconpt->EnumConnectionPoints(ppEnum);
    }

    STDMETHODIMP FindConnectionPoint(REFIID riid, LPCONNECTIONPOINT *ppCP)
    {
        DEBUGLOG("IHBase: FindConnectionPoint\n");
        ASSERT(m_pconpt != NULL);
        return m_pconpt->FindConnectionPoint(riid, ppCP);
    }

   //IOleInplaceObjectWindowless implementation
protected:
    STDMETHODIMP GetWindow(HWND    *phwnd)
    {
        DEBUGLOG("IHBase: GetWindow\n");
        // Review(SimonB): If we handle windowed case, we need to return the proper hwnd for that case - PhaniV
        return    E_FAIL;
    }

    STDMETHODIMP ContextSensitiveHelp( BOOL fEnterMode)
    {
        DEBUGLOG("IHBase: ContextSensitiveHelp\n");
        // Who cares about context sensitive help?
        // Review(SimonB): Think about context sensitive help later - PhaniV
        return    E_NOTIMPL;
    }

    STDMETHODIMP InPlaceDeactivate(void)
    {
        DEBUGLOG("IHBase: InPlaceDeactivate\n");

        if (m_poipsw)
            m_fControlIsActive = (!SUCCEEDED(m_poipsw->OnInPlaceDeactivate()));

        return S_OK;
    }

    STDMETHODIMP UIDeactivate(void)
    {
        DEBUGLOG("IHBase: UIDeactivate\n");
        return S_OK;
    }

    STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
    {
        DEBUGLOG("IHBase: SetObjectRects\n");
        // Some containers (ALX, for example) call this to give us our bounds.
        // Others (like Trident) give us our bounds through DoVerb
        if ((NULL != lprcPosRect) && (NULL != lprcClipRect))
        {
        // Cache our bounds and clipping rectangle
#ifdef _DEBUG //Review(Unicode)
            TCHAR tchDebug[100];
            LPCRECT prc = lprcPosRect;
            wsprintf(tchDebug, "IHBase: lprcPosRect: top: %lu left: %lu bottom: %lu right: %lu\n",
                prc->top,
                prc->left,
                prc->bottom,
                prc->right);
            DEBUGLOG(tchDebug);
            prc = lprcClipRect;
            wsprintf(tchDebug, "IHBase: lprcClipRect: top: %lu left: %lu bottom: %lu right: %lu\n",
                prc->top,
                prc->left,
                prc->bottom,
                prc->right);
            DEBUGLOG(tchDebug);
#endif
            m_rcBounds = *lprcPosRect;
            m_rcClipRect = *lprcClipRect;
            return S_OK;
        }
        else
        {
            return E_POINTER;
        }
    }

    STDMETHODIMP ReactivateAndUndo(void)
    {
        DEBUGLOG("IHBase: ReactivateAndUndo\n");
        return S_OK;
    }

    STDMETHODIMP OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lparam, LRESULT *plResult)
    {
        DEBUGLOG("IHBase: OnWindowMessage\n");
        return S_FALSE; // We did not process the message
    }

    STDMETHODIMP GetDropTarget(IDropTarget **ppDropTarget)
    {
        DEBUGLOG("IHBase: GetDropTarget\n");
        return E_NOTIMPL;
    }


protected:
    LPTYPEINFO m_pTypeInfo;
    LPTYPELIB m_pTypeLib;

    ////// IProvideClassInfo
    STDMETHODIMP GetClassInfo(LPTYPEINFO *ppTI)
    {
        DEBUGLOG("IHBase: GetClassInfo\n");
        // Make sure the typelib is loaded
        if (NULL == m_pTypeLib)
        {
            HRESULT hRes;

            // Load the typelib
            hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, *temppIID, *temppLIBID, NULL);

            if (FAILED(hRes))
            {
                DEBUGLOG("IHBase: Unable to load typelib\n");
                m_pTypeInfo = NULL;
                m_pTypeLib = NULL;
            }
        }

        ASSERT(m_pTypeLib != NULL);

        return HelpGetClassInfoFromTypeLib(ppTI, *temppCLSID, m_pTypeLib, NULL, 0);
    }

#ifdef USEOBJECTSAFETY
    //////// IObjectSafety implementation
protected:
    STDMETHODIMP GetInterfaceSafetyOptions(
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions)
    {
#ifdef _DEBUG
        if (g_fLogDebugOutput)
        {
            char ach[200];
            TRACE("IHBase::GetInterfaceSafetyOptions('%s')\n", DebugIIDName(riid, ach));
        }
#endif

        IUnknown *punk = NULL;
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;

        // Check that we support the interface
        HRESULT hRes = QueryInterface(riid, (LPVOID *) &punk);

        if (SUCCEEDED(hRes))
        {
            // Let go of the object
            punk->Release();

            // We support both options for all interfaces we support
            *pdwSupportedOptions = *pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                                                        INTERFACESAFE_FOR_UNTRUSTED_DATA;
            hRes = S_OK;
        }

        return hRes;
    }

    STDMETHODIMP SetInterfaceSafetyOptions(
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions)
    {
#ifdef _DEBUG
        if (g_fLogDebugOutput)
        {
            char ach[200];
            TRACE("IHBase::SetInterfaceSafetyOptions('%s')\n", DebugIIDName(riid, ach));
        }
#endif

        IUnknown *punk = NULL;
        const dwSupportedBits =    INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                                INTERFACESAFE_FOR_UNTRUSTED_DATA;

        // Check that we support the interface
        HRESULT hRes = QueryInterface(riid, (LPVOID *) &punk);

        if (SUCCEEDED(hRes))
        {
            // Let go of the object
            punk->Release();

            // Since we support all options, we just return S_OK, assuming we support
            // the interface


            // Do we support the bits we are being asked to set ?
            if (!(dwOptionSetMask & ~dwSupportedBits))
            {
                // All the flags we are being asked to set are supported, so
                // now make sure we aren't turning off something we do support

                // Ignore any bits we support which the mask isn't interested in
                dwEnabledOptions &= dwSupportedBits;

                if ((dwEnabledOptions & dwOptionSetMask) == dwOptionSetMask)
                    hRes = S_OK;
                else
                    hRes = E_FAIL;
            }
            else // dwOptionSetMask & ~dwSupportedBits
            {
                // We are being asked to set bits we don't support
                hRes = E_FAIL;
            }

        }

        return hRes;
    }

#endif // USEOBJECTSAFETY
    // ISpecifyPropertyPages implementation

protected:
#ifdef _DESIGN
    STDMETHODIMP GetPages (CAUUID *pPages)
    {
        return E_NOTIMPL;
    }
#endif //_DESIGN

    // CIHBaseOnLoad implementation
#ifdef SUPPORTONLOAD

private:
    void ReleaseContainerConnectionPoint()
    {
        if (m_pcLUDispatch)
        {
            ASSERT(m_pContainerConPt != NULL);
            m_pContainerConPt->Unadvise( m_dwWindowEventConPtCookie );
            SafeRelease((LPUNKNOWN *)&m_pContainerConPt);
            Delete m_pcLUDispatch;
            m_pcLUDispatch = NULL;
        }
    }


    BOOL ConnectToContainerConnectionPoint()
    {
            // Get a connection point to the container
        LPUNKNOWN lpUnk = NULL;
        LPOLECONTAINER pContainer = NULL;
        IConnectionPointContainer* pCPC = NULL;
        IHTMLDocument *pDoc = NULL;
        LPDISPATCH pDisp = NULL;
        BOOL fRet = FALSE;
        HRESULT hRes = S_OK;

        // Get the container
        if (SUCCEEDED(m_pocs->GetContainer(&pContainer)))
        {
            ASSERT (pContainer != NULL);
            // Now get the document
            if (SUCCEEDED(pContainer->QueryInterface(IID_IHTMLDocument, (LPVOID *)&pDoc)))
            {
                // Get the scripting dispatch on the document
                ASSERT (pDoc != NULL);
                hRes = pDoc->get_Script(&pDisp);
                if (SUCCEEDED(hRes))
                {
                    ASSERT (pDisp != NULL);
                    // Now get the connection point container
                    hRes = pDisp->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPC);
                    if (SUCCEEDED(hRes))
                    {
                        ASSERT (pCPC != NULL);
                        // And get the connection point we want
                        hRes = pCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pContainerConPt );
                        if (SUCCEEDED(hRes))
                        {
                            ASSERT( m_pContainerConPt != NULL );
                            // Now we advise the Connection Point of who to talk to
                            m_pcLUDispatch = New CLUDispatch(this, m_punkOuter);
                            hRes = m_pContainerConPt->Advise( m_pcLUDispatch, &m_dwWindowEventConPtCookie );
                            if (SUCCEEDED(hRes))
                                fRet = TRUE;
                        }
                        pCPC->Release();
                    }
                    pDisp->Release();
                }
                pDoc->Release();
            }
            pContainer->Release();
        }

        return fRet;
    }


public:
    void OnWindowLoad() { return; }
    void OnWindowUnload() { return; }

#endif SUPPORTONLOAD


};

#endif // __IHBASE_H__

// End of File ihbase.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\debug.h ===
// debug.h
//
// Debugging functions.

#ifndef __IHBASEDEBUG_H__
#define __IHBASEDEBUG_H__
#include "..\..\inc\debug.h"

// <g_hinst> must be defined externally as the app/DLL instance handle
extern HINSTANCE g_hinst;


//////////////////////////////////////////////////////////////////////////////
// TRACE, ASSERT, VERIFY
//
// These are the same as MFC's functions of the same name (but are implemented
// without using MFC).  See "debug.h" for the actual macro definitions.
//

// Debugging support (SimonB)
#ifdef _DEBUG
extern BOOL g_fLogDebugOutput;
#define DEBUGLOG(X) { if (g_fLogDebugOutput) OutputDebugString(X);}
#else
#define DEBUGLOG(X)
#endif

#ifdef _DEBUG

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine);
void __cdecl Trace(LPCTSTR lpszFormat, ...);

// VanK modification
#ifdef TRACE
#pragma message("TRACE already defined - redefining")
#undef TRACE
#endif

#define TRACE              if (g_fLogDebugOutput) ::Trace

// VanK modification
#ifdef THIS_FILE
#pragma message("THIS_FILE already defined - redefining")
#undef THIS_FILE
#endif

#define THIS_FILE          __FILE__

// SimonB modification
#ifdef ASSERT
#pragma message("ASSERT already defined - redefining")
#undef ASSERT
#endif

#define ASSERT(f) \
    do \
    { \
    if (!(f) && AssertFailedLine(THIS_FILE, __LINE__)) \
        DebugBreak(); \
    } while (0) \

#define VERIFY(f)          ASSERT(f)

#else // #ifndef _DEBUG

#ifdef ASSERT
#pragma message("ASSERT being redefined as NULL statment")
#undef ASSERT
#endif

#define ASSERT(f)          ((void)0)

#define VERIFY(f)          ((void)(f))

inline void __cdecl Trace(LPCTSTR, ...) { }

// VanK modification
#ifdef TRACE
#pragma message("TRACE being redefined as NULL statment")
#undef TRACE
#endif

#define TRACE              1 ? (void)0 : ::Trace

#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
// DebugIIDName, DebugCLSIDName
//
// These functions convert an IID or CLSID to a string name for debugging
// purposes (e.g. IID_IUnknown is converted to "IUnknown").
//

#ifdef _DEBUG
LPCSTR DebugIIDName(REFIID riid, LPSTR pchName);
LPCSTR DebugCLSIDName(REFCLSID rclsid, LPSTR pchName);
#endif // _DEBUG

#endif // _IHBASEDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\onload.cpp ===
/*++

Module: 
        onload.cpp

Author: 
        IHammer Team (SimonB), based on Carrot sample in InetSDK

Created: 
        April 1997

Description:
        Implements an IDispatch which fires the OnLoad and OnUnload members in CIHBase

History:
        04-03-1997      Created

++*/

#include "..\ihbase\precomp.h"
#include <mshtmdid.h>
#undef Delete
#include <mshtml.h>
#define Delete delete
#include "onload.h"
#include "debug.h"

/*
 * CLUDispatch::CLUDispatch
 * CLUDispatch::~CLUDispatch
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CLUDispatch::CLUDispatch(CIHBaseOnLoad *pSink, IUnknown *pUnkOuter )
{
        ASSERT (pSink != NULL);

    m_cRef = 0;
    m_pOnLoadSink = pSink;
    m_pUnkOuter = pUnkOuter;
}

CLUDispatch::~CLUDispatch( void )
{
        ASSERT( m_cRef == 0 );
}


/*
 * CLUDispatch::QueryInterface
 * CLUDispatch::AddRef
 * CLUDispatch::Release
 *
 * Purpose:
 *  IUnknown members for CLUDispatch object.
 */

STDMETHODIMP CLUDispatch::QueryInterface( REFIID riid, void **ppv )
{
        if (NULL == ppv)
                return E_POINTER;

    *ppv = NULL;

    if ( IID_IDispatch == riid || DIID_HTMLWindowEvents == riid )
        {
        *ppv = this;
        }
        
        if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CLUDispatch::AddRef(void)
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CLUDispatch::Release(void)
{
    --m_cRef;
    return m_pUnkOuter->Release();
}


//IDispatch
STDMETHODIMP CLUDispatch::GetTypeInfoCount(UINT* /*pctinfo*/)
{
        return E_NOTIMPL;
}

STDMETHODIMP CLUDispatch::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
        return E_NOTIMPL;
}

STDMETHODIMP CLUDispatch::GetIDsOfNames(
            /* [in] */ REFIID /*riid*/,
            /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
            /* [in] */ UINT /*cNames*/,
            /* [in] */ LCID /*lcid*/,
            /* [size_is][out] */ DISPID* /*rgDispId*/)
{
        return E_NOTIMPL;
}


STDMETHODIMP CLUDispatch::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD /*wFlags*/,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* /*pVarResult*/,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{
        // Listen for the two events we're interested in, and call back if necessary
#ifdef _DEBUG
        TCHAR rgchDispIdInfo[40];
        wsprintf(rgchDispIdInfo, TEXT("CLUDispatch::Invoke: dispid = %lx\n"), dispIdMember);
        DEBUGLOG(rgchDispIdInfo);
#endif

        switch (dispIdMember)
        {
                case DISPID_EVPROP_ONLOAD:
                case DISPID_EVMETH_ONLOAD:
                {
                        m_pOnLoadSink->OnWindowLoad();
                }
                break;

                case DISPID_EVPROP_ONUNLOAD:
                case DISPID_EVMETH_ONUNLOAD:
                {
                        m_pOnLoadSink->OnWindowUnload();
                }
                break;
        }
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\iids.h ===
/*
	iids.h

	This generated header files contains #defines necessary for the IHBase implementation
	of QueryInterface.  The values below are IID_X.Data1 - not available at compile time.

	To generate this header file, run MakeHdr.  To add more interfaces, modify dmpguids.cpp,
	rebuild dmpguids.exe, and then run MakeHdr.

*/

#ifndef __IIDS_H__
#define __IIDS_H__

#define IID_IViewObject_DATA1 0x10d
#define IID_IViewObject2_DATA1 0x127
#define IID_IViewObjectEx_DATA1 0x3af24292
#define IID_IOleObject_DATA1 0x112
#define IID_IOleInPlaceObjectWindowless_DATA1 0x1c2056cc
#define IID_IOleControl_DATA1 0xb196b288
#define IID_IConnectionPointContainer_DATA1 0xb196b284
#define IID_IOleInPlaceObject_DATA1 0x113
#define IID_IPersistVariantIO_DATA1 0x26f45840
#define IID_IProvideClassInfo_DATA1 0xb196b283
#define IID_IObjectSafety_DATA1 0xcb5bdc81
#define IID_ISpecifyPropertyPages_DATA1 0xb196b28b
#define IID_IUnknown_DATA1 0x0

#endif // __IIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\clocker.cpp ===
#include "precomp.h"
#include "debug.h"
#include "utils.h"

#include "clocker.h"

extern HINSTANCE g_hinst;

#define CLOCKER_NOTIFY_CLASS_NAME  "CClockerNotifyWindow"
#define CLOCKER_TIMER_CLASS_NAME   "CClockerTimerWindow"

BOOL CClocker::g_fNotifyClassRegistered = FALSE;
BOOL CClocker::g_fTimerClassRegistered = FALSE;

CClocker::CClocker (void) :
    m_ulRefs(1),
        m_cView(NULL),
        m_cHost(NULL),
        m_cTimer(NULL),
        m_fVisible(TRUE),
        m_dwCookie(0),
        m_fIgnoreAdvises(FALSE),
        m_pClockerSink(NULL),
        m_iTimerInterval(50),
    m_hwnd(NULL),
    m_fToggle(FALSE),
    m_fAsync(FALSE),
    m_iTimerID(0),
    m_CT(CT_ITimer)
{
}

CClocker::~CClocker (void)
{
    KillWindow();

        if ((NULL != (ITimer *)m_cTimer) && (0 != m_dwCookie))
        {
        m_pClockerSink = NULL;
                Stop();
        }
}

HRESULT
CClocker::SetView (IDAView * piView)
{
        // NULL views are permissible ways to 
        // detach a prior view.
        m_cView = piView;
        return S_OK;
}

HRESULT
CClocker::SetHost (IOleClientSite * pocsHost)
{
        // NULL hosts are permissible ways to 
        // detach a prior host.
        m_cHost = pocsHost;
        return FindTimer();
}

HRESULT
CClocker::SetVisible (BOOL fVisible)
{
        m_fVisible = fVisible;
        return S_OK;
}

HRESULT 
CClocker::SetSink(CClockerSink *pClockerSink)
{
    m_pClockerSink = pClockerSink;
        return S_OK;
}

HRESULT 
CClocker::SetInterval(ULONG iInterval)
{
        m_iTimerInterval = iInterval;
        return S_OK;
}

STDMETHODIMP
CClocker::QueryInterface (REFIID riid, LPVOID * ppv)
{
        HRESULT hr = E_POINTER;

        if (NULL != ppv)
        {
                hr = E_NOINTERFACE;
                if (::IsEqualIID(riid, IID_ITimerSink) || (::IsEqualIID(riid, IID_IUnknown)))
                {
                        *ppv = (ITimerSink *)this;
                        AddRef();
                        hr  = S_OK;
                }
        }

        return hr;
}

STDMETHODIMP_(ULONG)
CClocker::AddRef (void)
{
        return ++m_ulRefs;
}

STDMETHODIMP_(ULONG)
CClocker::Release (void)
{
        // We shouldn't ever dip below a refcount of 1.
        ASSERT (1 < m_ulRefs);
        // This object is only used as a timer sink ... we do not 
        // want to delete it after the last external reference 
        // is removed.
        return --m_ulRefs;
}
#define TIMERID 1
STDMETHODIMP 
CClocker::OnTimer (VARIANT varTimeAdvise)
{
        HRESULT hr = S_OK;

        // If we're inactive, we should simply return without doing anything.
        // Ditto if we're still processing another sink call.
        if ((0 != m_dwCookie) && (!m_fIgnoreAdvises))
        {
                m_fIgnoreAdvises = TRUE;

        if (m_fAsync)
        {
            if (m_hwnd)
            {
                int iOffset = 0;
                m_fToggle = !m_fToggle;
                iOffset = m_fToggle ? 1 : -1;

#ifdef MOVEWINDOW
                // Let the post-notification handle the update...
                ::MoveWindow(m_hwnd, iOffset, iOffset, 1, 1, FALSE);
#else
                if (0 == SetTimer(m_hwnd, ++m_iTimerID, 0, NULL))
                    ASSERT(FALSE);
#endif
            }
            else
            {
                        m_fIgnoreAdvises = FALSE;
            }
        }
        else
        {
            // Dispatch Immediately...
            hr = DispatchTimer(timeGetTime());
        }
        }

        return hr;
}

HRESULT
CClocker::FindContainerTimer (void)
{
        HRESULT hr = E_FAIL;
        LPUNKNOWN piUnkSite = NULL;

        IServiceProvider * piServiceProvider = NULL;

        if ((NULL != (IOleClientSite *)m_cHost) && SUCCEEDED(hr = m_cHost->QueryInterface(IID_IServiceProvider, (LPVOID *)&piServiceProvider)))
        {
                ITimerService * piTimerService = NULL;

                if (SUCCEEDED(hr = piServiceProvider->QueryService(IID_ITimerService, IID_ITimerService, (LPVOID *)&piTimerService)))
                {
                        hr = piTimerService->GetNamedTimer(NAMEDTIMER_DRAW, &m_cTimer);
                        ASSERT(NULL != (ITimer *)m_cTimer);
                        piTimerService->Release();
                }
                piServiceProvider->Release();
        }

        return hr;
}

HRESULT
CClocker::FindDefaultTimer (void)
{
        HRESULT hr = E_FAIL;
#if 0
        ITimerService * pITimerService = NULL;

        // Get the timer service.  From this, we can create a timer for ourselves.
        hr = CoCreateInstance(CLSID_TimerService, NULL, CLSCTX_INPROC_SERVER, IID_ITimerService, (LPVOID *)&pITimerService);
        ASSERT(SUCCEEDED(hr) && (NULL != pITimerService));
        if (SUCCEEDED(hr) && (NULL != pITimerService))
        {
                // Create a timer, using no reference timer.
                hr = pITimerService->CreateTimer(NULL, &m_cTimer);
                pITimerService->Release();
        }
#endif

        return hr;
}


HRESULT
CClocker::CreateWindowsTimer (void)
{
    ASSERT (m_hwnd != NULL);

    m_iTimerID = SetTimer(m_hwnd, 1, m_iTimerInterval, NULL);
    
    ASSERT(m_iTimerID != NULL);
    
    return ((m_iTimerID != NULL) ? S_OK : E_FAIL);

}


HRESULT
CClocker::FindTimer (void)
{
        HRESULT hr = E_FAIL;

    if (CT_ITimer == m_CT)
    {
            if (FAILED(hr = FindContainerTimer()))
            {
                    hr = FindDefaultTimer();
            }
    }
    else
    {
        hr = S_OK;
    }

        return hr;
}

HRESULT
CClocker::InitTimer (void)
{
        return FindTimer();
}

HRESULT
CClocker::Start (void)
{
        HRESULT hr = E_FAIL;
    
    if (m_CT == CT_WMTimer) 
    {
      // Create the dummy window now...
        if (0 == m_iTimerID)
        {
            if (FAILED(hr = MakeWindow(g_hinst, TRUE)))
                return hr;

            if (FAILED(hr = CreateWindowsTimer()))
                return hr;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        if (m_dwCookie == 0)
        {
                ASSERT(NULL != (ITimer *)m_cTimer);
                if (NULL != (ITimer *)m_cTimer)
                {
                        // Set up the constant advise.
                        VARIANT varMin;
                        VARIANT varMax;
                        VARIANT varInterval;
                        DWORD dwNow = 0;

                if (m_fAsync)
                {
                    // Create the dummy window now...
                    if (FAILED(hr = MakeWindow(g_hinst, FALSE)))
                        return hr;
                }

                        VariantInit(&varMin);
                        V_VT(&varMin) = VT_UI4;
                        V_UI4(&varMin) = timeGetTime();
                        VariantInit(&varMax);
                        V_VT(&varMax) = VT_UI4;
                        V_UI4(&varMax) = 0;
                        VariantInit(&varInterval);
                        V_VT(&varInterval) = VT_UI4;
                        V_UI4(&varInterval) = m_iTimerInterval;
                        hr = m_cTimer->Advise(varMin, varMax, varInterval, 0, this, &m_dwCookie);
                        ASSERT(SUCCEEDED(hr));
                }
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT
CClocker::Stop (void)
{
        HRESULT hr = E_FAIL;

    if (m_CT == CT_WMTimer)
    {
        hr = (KillTimer(m_hwnd, 1) ? S_OK : E_FAIL);
        m_iTimerID = 0;
    }
    else
    {
            if ((NULL != (ITimer *)m_cTimer) && (0 != m_dwCookie))
            {
                    hr = m_cTimer->Unadvise(m_dwCookie);
                    m_dwCookie = 0;
            }
    }
        return hr;
}

HRESULT CClocker::DispatchTimer(DWORD dwTime)
{
    HRESULT hr = S_OK;

        // Use the supplied callback function if available
        if (m_pClockerSink)
        {
                m_pClockerSink->OnTimer(dwTime);
        }
        else
        {
        // Use the default behavior...
        if (NULL != (IDAView *)m_cView)
        {
            VARIANT_BOOL vBool = FALSE;
                    double dblCurrentTime = dwTime / 1000.0;

                    if (SUCCEEDED(hr = m_cView->Tick(dblCurrentTime, &vBool)))
                    {
                BOOL fForceRender = VBOOL_TO_BOOL(vBool);

                if (fForceRender)
                {
                            hr = m_cView->Render();
                }
                }
        }
        }

    // Allow more advises...
        m_fIgnoreAdvises = FALSE;

    return hr;
}

HRESULT CClocker::MakeWindow(HINSTANCE hInstance, BOOL fCreateTimerWindow)
{
    HRESULT hr = S_OK;

    if ( (!fCreateTimerWindow && !g_fNotifyClassRegistered) ||
         (fCreateTimerWindow && !g_fTimerClassRegistered))
    {
        WNDCLASS wndclass;
        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = fCreateTimerWindow ? CClocker::TimerWndProc : CClocker::WndProc;
        wndclass.hInstance     = hInstance;
        wndclass.hCursor       = NULL;
        wndclass.hbrBackground = NULL;

        if (fCreateTimerWindow)
            wndclass.lpszClassName = CLOCKER_TIMER_CLASS_NAME;
        else
            wndclass.lpszClassName = CLOCKER_NOTIFY_CLASS_NAME;

        ::RegisterClass(&wndclass);

        if (fCreateTimerWindow)
            g_fTimerClassRegistered = TRUE;
        else
            g_fNotifyClassRegistered = TRUE;
    }

    if (!m_hwnd)
    {
        m_hwnd = ::CreateWindowEx(
            (DWORD)0,
            fCreateTimerWindow ? CLOCKER_TIMER_CLASS_NAME : CLOCKER_NOTIFY_CLASS_NAME,
            "CClocker",
            (DWORD)0,
            0, 0, 0, 0,
            NULL,
            NULL,
            hInstance,
            (LPVOID)NULL);
    }

    if (m_hwnd)
    {
        ::SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)this);
        hr = S_OK;
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT CClocker::KillWindow(void)
{
    HRESULT hr = S_OK;

    if (m_hwnd)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    return hr;
}

LRESULT __stdcall CClocker::WndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

#ifdef MOVEWINDOW
    if (uiMessage == WM_WINDOWPOSCHANGED)
#else
    if (uiMessage == WM_TIMER)
#endif
    {
        CClocker *pThis = (CClocker *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);

#ifndef MOVEWINDOW
        if (pThis)
        {
            KillTimer(hWnd, pThis->m_iTimerID);
            if (64000 == pThis->m_iTimerID)
                pThis->m_iTimerID = 0;
        }
#endif
        if (pThis)
            pThis->DispatchTimer(timeGetTime());
    }

    lResult = ::DefWindowProc(hWnd, uiMessage, wParam, lParam);

    return lResult;
}

LRESULT __stdcall CClocker::TimerWndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    if (uiMessage == WM_TIMER)
    {
        CClocker *pThis = (CClocker *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);

        if (pThis && !(pThis->m_fIgnoreAdvises))
        {
            pThis->m_fIgnoreAdvises = TRUE;
            pThis->DispatchTimer(timeGetTime());
        }
    }

    lResult = ::DefWindowProc(hWnd, uiMessage, wParam, lParam);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\onload.h ===
/*++

Module: 
	onload.h

Author: 
	IHammer Team (SimonB), based on Carrot sample in InetSDK

Created: 
	April 1997

Description:
	Implements an IDispatch which fires the OnLoad and OnUnload members in CIHBase

History:
	04-03-1997	Created

++*/

#ifndef __ONLOAD_H__
#define __ONLOAD_H__

class CIHBaseOnLoad
{
public:

	//inline CIHBaseOnLoad() {};
	//virtual ~CIHBaseOnLoad() {};
	
	virtual void OnWindowLoad() = 0;
	virtual void OnWindowUnload() = 0;
};


// Load/Unload Dispatch
class CLUDispatch : public IDispatch
{
	protected:
        ULONG               m_cRef;
        LPUNKNOWN           m_pUnkOuter;
		CIHBaseOnLoad       *m_pOnLoadSink;
		
    public:
        CLUDispatch(CIHBaseOnLoad *pSink, IUnknown * );
        ~CLUDispatch(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		//IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo);
		STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
		STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

};

#endif //__ONLOAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\precomp.h ===
// precomp.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <windows.h>
#include <mmsystem.h> // for timeSetEvent()
#include <tchar.h>
#include <oleidl.h>
#include <olectl.h>
#include "..\mmctl\inc\mmctl.h"

// general globals
extern HINSTANCE    g_hinst;        // DLL instance handle
extern ULONG        g_cLock;        // DLL lock count

#ifdef _DEBUG
#define ODS(X) OutputDebugString(X)
#else
#define ODS(X)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\precomp.cpp ===
// precomp.cpp : source file that includes just the standard includes
//  precomp.pch will be the pre-compiled header
//  precomp.obj will contain the pre-compiled type information

#include "..\ihbase\precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\parser.cpp ===
#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\mmctl\inc\ochelp.h"
#include <ihammer.h>
#include "strwrap.h"
#include "parser.h"
#include "ctstr.h"
#include <locale.h>

/*==========================================================================*/

BOOL CLineParser::InitLine(BOOL fCompactString)
{
    m_iOffset = 0;
    m_pszLine = m_tstrLine.psz();
    m_tchDelimiter = TEXT(';');

    if (NULL != m_pszLine)
    {
        if (fCompactString)
            CompactString();
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/*==========================================================================*/

void CLineParser::CompactString()
{
    // Strip spaces, tabs, CR and LF in-place
    int i, j;

    for (i = 0, j = 0; i < m_tstrLine.Len(); i++)
    {
        if (!IsJunkChar(m_pszLine[i]))
            m_pszLine[j++] = m_pszLine[i];
    }

    // Terminate the string
    m_pszLine[j] = TEXT('\0');

    // And get the new length
    m_tstrLine.ResetLength();
}

/*==========================================================================*/

    // Constructors and destructors
CLineParser::CLineParser(LPSTR pszLineA, BOOL fCompactString):
    m_tstrLine(pszLineA)
{
    InitLine(fCompactString);
}

/*==========================================================================*/

CLineParser::CLineParser(LPWSTR pwszLineW, BOOL fCompactString):
    m_tstrLine(pwszLineW)
{
    InitLine(fCompactString);
}

/*==========================================================================*/

CLineParser::CLineParser()
{
    InitLine(FALSE);
}

/*==========================================================================*/

CLineParser::~CLineParser()
{
}

/*==========================================================================*/

BOOL CLineParser::SetNewString(LPSTR pszLineA, BOOL fCompactString)
{
    m_tstrLine.SetString(pszLineA);
    return InitLine(fCompactString);
}

/*==========================================================================*/

BOOL CLineParser::SetNewString(LPWSTR pszLineW, BOOL fCompactString)
{
    m_tstrLine.SetString(pszLineW);
    return InitLine(fCompactString);
}

/*==========================================================================*/

HRESULT CLineParser::GetFieldDouble(double *pdblRes, BOOL fAdvance)
{
    ASSERT (pdblRes != NULL);
    HRESULT hr;

    *pdblRes = 0.0f;
    setlocale(LC_NUMERIC, "English");
    hr = GetField(TEXT("%lf"), pdblRes, fAdvance);
    setlocale(LC_ALL, "");

    return hr;

}

/*==========================================================================*/

HRESULT CLineParser::GetFieldInt(int *piRes, BOOL fAdvance)
{
    ASSERT (piRes != NULL);

    *piRes = 0;
    return GetField(TEXT("%li"), piRes, fAdvance);
}

/*==========================================================================*/

HRESULT CLineParser::GetFieldUInt(unsigned int *piRes, BOOL fAdvance)
{
    ASSERT (piRes != NULL);

    *piRes = 0;
    return GetField(TEXT("%lu"), piRes, fAdvance);
}

/*==========================================================================*/

HRESULT CLineParser::GetFieldString(LPTSTR pszRes, BOOL fAdvance)
{
    ASSERT (pszRes != NULL);

    *pszRes = 0;
    return GetField(TEXT("%s"), pszRes, fAdvance);
}

/*==========================================================================*/

HRESULT CLineParser::GetField(LPCTSTR pszFormat, LPVOID pRes, BOOL fAdvance)
{
    int iRes = 0;

    // Find the next delimiter, and change it to a NULL
    LPTSTR pszToken = &m_pszLine[m_iOffset];
    BOOL fResetDelimiter = FALSE;

    if ( IsEndOfString() )
        return S_FALSE;

    while ( (*pszToken) && (*pszToken != m_tchDelimiter) )
        pszToken++;

    if (*pszToken)
    {
        fResetDelimiter = TRUE;
        *pszToken = 0;
    }

    iRes = CStringWrapper::Sscanf1(&m_pszLine[m_iOffset], pszFormat, pRes);

    if (fResetDelimiter)
        *pszToken = m_tchDelimiter;

    if (fAdvance)
    {
        m_iOffset += (DWORD) (pszToken - &m_pszLine[m_iOffset]);
        
        if (fResetDelimiter)
            m_iOffset++;

    }

    if (1 == iRes)
    {
        if (m_pszLine[m_iOffset] != 0)
            return S_OK;
        else
            return S_FALSE;
    }
    else
    {
        return E_FAIL;
    }
}

/*==========================================================================*/

BOOL CLineParser::SeekTo(int iNewPos)
{
    if (iNewPos < m_tstrLine.Len())
    {
        m_iOffset = iNewPos;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\parser.h ===
#ifndef __LINEPARSER_H__
#define __LINEPARSER_H__

#include "..\ihbase\precomp.h"
#include "ctstr.h"

inline BOOL IsJunkChar(TCHAR tchChar)
{
    return (tchChar == TEXT(' ')) || (tchChar == TEXT('\t')) || (tchChar == TEXT('\n')) || (tchChar == TEXT('\r'));
}

class CLineParser
{

public:

	// Constructors and destructors
	CLineParser(LPSTR pszLineA, BOOL fCompactString = TRUE);
	CLineParser(LPWSTR pwszLineA, BOOL fCompactString = TRUE);

	CLineParser();

	~CLineParser();

	BOOL SetNewString(LPSTR pszLineA, BOOL fCompactString = TRUE);
	BOOL SetNewString(LPWSTR pszLineW, BOOL fCompactString = TRUE);

	// Access members

	HRESULT GetFieldDouble(double *pdblRes, BOOL fAdvance = TRUE);
	HRESULT GetFieldInt(int *piRes, BOOL fAdvance = TRUE);
	HRESULT GetFieldUInt(unsigned int *piRes, BOOL fAdvance = TRUE);
	HRESULT GetFieldString(LPTSTR pszRes, BOOL fAdvance = TRUE);
	
	LPTSTR GetStringPointer(BOOL fUseOffset = FALSE) 
	{  return m_pszLine ? &m_pszLine[fUseOffset ? m_iOffset : 0] : NULL; }


	BOOL IsEndOfString() { return (m_iOffset == m_tstrLine.Len()); }
	void Reset() {	m_iOffset = 0;	}
	int GetPos() { 	return m_iOffset; }
	BOOL IsValid() { return (NULL != m_pszLine); }
	BOOL SeekTo(int iNewPos);

	void SetCharDelimiter(TCHAR tchDelimiter) { m_tchDelimiter = tchDelimiter; }

private:

	CTStr m_tstrLine;
	LPTSTR m_pszLine;
	int m_iOffset;
	TCHAR m_tchDelimiter;

	void CompactString();
	BOOL InitLine(BOOL fCompactString);

	HRESULT GetField(LPCTSTR pszFormat, LPVOID pRes, BOOL fAdvance);

};

#endif // __LINEPARSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\timemark.h ===
/*++

Module:
	timemark.h

Description:
	Handles parsing of AddTimeMarkerTags

Author:
	IHammer Team (simonb)

Created:
	06-03-1997

--*/

#include "ctstr.h"
#include "drg.h"
#include "memlayer.h"
#include "strwrap.h"

#ifndef __TIMEMARK_H__
#define __TIMEMARK_H__

class CTimeMarker
{
public:
    CTimeMarker* m_pnext;

	double m_dblTime;
	BSTR  m_pwszMarkerName;
    boolean m_bAbsolute;

public:
    void Sort(CTimeMarker** pptm)
    {
        while (*pptm != NULL && (*pptm)->m_dblTime < m_dblTime) {
            pptm = &((*pptm)->m_pnext);
        }

        m_pnext = *pptm;
        *pptm = this;
    }

    CTimeMarker(CTimeMarker** pptm, double dblTime, LPWSTR pwszName, boolean bAbsolute = true):
        m_dblTime(dblTime),
        m_bAbsolute(bAbsolute)
	{
        m_pwszMarkerName = New WCHAR [lstrlenW(pwszName) + 1];
        
        if (m_pwszMarkerName)
            CStringWrapper::WStrcpy(m_pwszMarkerName, pwszName);

        Sort(pptm);
	}

    ~CTimeMarker()
    {
        if (m_pwszMarkerName)
            Delete [] m_pwszMarkerName;
    }

};

#define ISINVALIDTIMEMARKER(X) (NULL != X.m_tstrMarkerName.psz())

typedef CPtrDrg<CTimeMarker> CTimeDrg;

HRESULT ParseTimeMarker(IVariantIO *pvio, int iLine, CTimeMarker **ppTimeMarker, CTimeMarker** ppTMList);
HRESULT WriteTimeMarker(IVariantIO *pvio, int iLine, CTimeMarker *pTimeMarker);

typedef void (*PFNFireMarker)(IConnectionPointHelper* pconpt, CTimeMarker* pmarker, boolean bPlaying);
void FireMarkersBetween(
    IConnectionPointHelper* pconpt,
    CTimeMarker* pmarkerFirst,
    PFNFireMarker pfn,
    double start,
    double end,
    double dblInstanceDuration,
    boolean bPlaying
);


#endif // __TIMEMARK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\timemark.cpp ===
/*++

Module:
	timemark.cpp

Description:
	Handles parsing of AddTimeMarkerTags

Author:
	IHammer Team (simonb)

Created:
	06-03-1997

--*/
#include "precomp.h"
#include "..\mmctl\inc\ochelp.h"
#include "debug.h"
#include <ctstr.h>
#include <drg.h>
#include <memlayer.h>
#include "timemark.h"
#include "parser.h"


HRESULT ParseTimeMarker(IVariantIO *pvio, int iLine, CTimeMarker **ppTimeMarker, CTimeMarker** ppTMList)
{
	ASSERT (ppTimeMarker);
	ASSERT (pvio);

	*ppTimeMarker = NULL;
	
	
	char rgchTagName[20]; // Construct tag name in here (ANSI)
	BSTR bstrLine = NULL;
	HRESULT hRes = S_OK;
	
	double dblTime = 0.0f;
	LPTSTR pszMarkerName = NULL;
	CLineParser parser;

	pszMarkerName = NULL;
	

	wsprintf(rgchTagName, "AddTimeMarker%lu", iLine);
	hRes = pvio->Persist(0,
		rgchTagName, VT_BSTR, &bstrLine,
		NULL);

	if (S_OK == hRes) // Read in the tag
	{
		parser.SetNewString(bstrLine);
		SysFreeString (bstrLine);
        parser.SetCharDelimiter(TEXT(','));

		if (parser.IsValid())
		{
			hRes = parser.GetFieldDouble(&dblTime);
			if (S_OK == hRes)
			{
				// Allocate space of at least the remaining length of the tag
				pszMarkerName = New TCHAR [lstrlen(parser.GetStringPointer(TRUE)) + 1];

				if (pszMarkerName)
				{
					// Get the string
					hRes = parser.GetFieldString(pszMarkerName);
					if (SUCCEEDED(hRes))
					{
                        bool fAbsolute = true;
                        // Is there an absolute/relative parameter ?
                        if (S_OK == hRes)
                        {
                            // Initialise to a non-zero value
                            int iTemp = 1;
                            hRes = parser.GetFieldInt(&iTemp);
                            
                            // 0 is the only thing we consider
                            if (SUCCEEDED(hRes) && (0 == iTemp))
                                fAbsolute = false;
                        }

                        // Construct a TimeMarker object
                        if (SUCCEEDED(hRes))
                        {
                            CTStr tstr;
                            tstr.SetStringPointer(pszMarkerName);
                            LPWSTR pszwMarkerName = tstr.pszW();

                            if (pszwMarkerName)
                            {
                                *ppTimeMarker = New CTimeMarker(ppTMList, dblTime, pszwMarkerName, fAbsolute);
                                Delete [] pszwMarkerName;
                            }
                            else
                            {
                                hRes = E_OUTOFMEMORY;
                            }

                            tstr.SetStringPointer(NULL, FALSE);

						    // Test for valid marker
						    if ( (NULL == *ppTimeMarker) || ((*ppTimeMarker)->m_pwszMarkerName == NULL) )
						    {
							    hRes = E_FAIL;
							    if (NULL == *ppTimeMarker)
								    Delete *ppTimeMarker;
						    }
                        }
					}
				}
				else
				{
					// Couldn't allocate memory for the marker name
					hRes = E_OUTOFMEMORY;
				}

				if (!parser.IsEndOfString())
				{
					hRes = E_FAIL;
				}
				else if (S_FALSE == hRes)
				{
					// S_FALSE means we tried to read beyond the end of a string
					hRes = S_OK;
				}

			}

		}
		else
		{
			// Only reason parser isn't valid is if we don't have memory
			hRes = E_OUTOFMEMORY;
		}
		
#ifdef _DEBUG
		if (E_FAIL == hRes)
		{
			TCHAR rgtchErr[100];
			wsprintf(rgtchErr, TEXT("SoundCtl: Error in AddFrameMarker%lu \n"), iLine);
			DEBUGLOG(rgtchErr);
		}
#endif

	}

	// Free up the temporary string
	if (NULL != pszMarkerName)
		Delete [] pszMarkerName;

	return hRes;
}



HRESULT WriteTimeMarker(IVariantIO *pvio, int iLine, CTimeMarker *pTimeMarker)
{
	ASSERT (pTimeMarker);
	ASSERT (pvio);

	if ( (NULL == pvio) || (NULL == pTimeMarker) )
		return E_POINTER;

	HRESULT hRes = S_OK;

	char rgchTagnameA[20]; // Construct tag name in here (ANSI)
	LPTSTR pszValue = NULL;
	
	wsprintfA(rgchTagnameA, "AddTimeMarker%lu", iLine++);

	// Allocate a string the length of the Marker name, + 20 for the time and 
	// possible relative/absolute indicator
	pszValue = New TCHAR[lstrlenW(pTimeMarker->m_pwszMarkerName) + 20];
	if (NULL != pszValue)
	{
        CTStr tstr(pTimeMarker->m_pwszMarkerName);
		
		int iAbsolute = (pTimeMarker->m_bAbsolute) ? 1 : 0;
		CStringWrapper::Sprintf(pszValue, TEXT("%.6lf,%s,%lu"), pTimeMarker->m_dblTime, tstr.psz(), iAbsolute);

#ifdef _UNICODE
		bstrValue = SysAllocString(pszValue);

		if (bstrValue != NULL)
		{
			hRes = pvio->Persist(NULL,
				rgchTagnameA, VT_BSTR, &bstrValue,
				NULL);
		}
		else
		{
			hRes = E_OUTOFMEMORY;
		}
		
		SysFreeString(bstrValue);
#else
		hRes = pvio->Persist(NULL,
			rgchTagnameA, VT_LPSTR, pszValue,
			NULL);
#endif
		Delete [] pszValue;

		// pvio->Persist returns S_FALSE when it has successfully written the property
		// S_OK would imply that the variable we passed in was changed
		if (S_FALSE == hRes)
			hRes = S_OK;
	}
	else
	{
		hRes = E_OUTOFMEMORY;
	}

	return hRes;
}
	
/*==========================================================================*/

void FireMarkersBetween(
    IConnectionPointHelper* pconpt,
    CTimeMarker* pmarkerFirst,
    PFNFireMarker pfnFireMarker,
    double start,
    double end,
    double dblInstanceDuration,
    boolean bPlaying
) {
    if (start >= end)
        return;

    int startIndex = (int)(start / dblInstanceDuration);
    int endIndex   = (int)(  end / dblInstanceDuration);

    double startTime = start - startIndex * dblInstanceDuration;
    double endTime   = end   -   endIndex * dblInstanceDuration;

    CTimeMarker* pmarker;

    if (startIndex == endIndex) {
        pmarker = pmarkerFirst;
        while (pmarker) {
            if (!pmarker->m_bAbsolute) {
                if (   (pmarker->m_dblTime == 0 && startTime == 0)
                    || (pmarker->m_dblTime > startTime && pmarker->m_dblTime <= endTime)
                ) {
                    pfnFireMarker(pconpt, pmarker, bPlaying);
                }
            }
            pmarker = pmarker->m_pnext;
        }
    } else {
        //
        // fire all the events in the first instance
        //

        pmarker = pmarkerFirst;
        while (pmarker) {
            if (!pmarker->m_bAbsolute) {
                if (   (pmarker->m_dblTime == 0 && startTime == 0)
                    || (pmarker->m_dblTime > startTime && pmarker->m_dblTime <= dblInstanceDuration)
                ) {
                    pfnFireMarker(pconpt, pmarker, bPlaying);
                }
            }
            pmarker = pmarker->m_pnext;
        }

        //
        // fire all the events in the middle instances
        //

        for(int index = startIndex + 1; index < endIndex; index++) {
            pmarker = pmarkerFirst;
            while (pmarker) {
                if (!pmarker->m_bAbsolute) {
                    if (pmarker->m_dblTime <= dblInstanceDuration) {
                        pfnFireMarker(pconpt, pmarker, bPlaying);
                    }
                }
                pmarker = pmarker->m_pnext;
            }
        }

        //
        // fire all the events in the last instance
        //

        pmarker = pmarkerFirst;
        while (pmarker) {
            if (!pmarker->m_bAbsolute && pmarker->m_dblTime <= endTime) {
                pfnFireMarker(pconpt, pmarker, bPlaying);
            }

            pmarker = pmarker->m_pnext;
        }
    }

    //
    // handle absolute markers
    //

    pmarker = pmarkerFirst;
    while (pmarker) {
        if (pmarker->m_bAbsolute) {
            if (   (pmarker->m_dblTime == 0 && start == 0)
                || (pmarker->m_dblTime > start && pmarker->m_dblTime <= end)
            ) {
               pfnFireMarker(pconpt, pmarker, bPlaying);
            }
        }
        pmarker = pmarker->m_pnext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\stringid.h ===
/*++

Module:
	stringid.h

Author:
	IHammer Team (SimonB)

Created:
	10-01-1996

Description:
	Resource string ID's for standard (expected) resources

++*/

#ifndef _STRINGID_H_

#define IDS_IHCTL_BASE 1024

#define IDS_IHCTL_GETUSERTYPE (IDS_IHCTL_BASE + 0) // IOleObject::GetUserType


#define _STRINGID_H_
#endif //_STRINGID_H_

// End of File stringid.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\unreg.h ===
/*++

Module: 
	unreg.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	October 1996

Description:
	Header for UnRegisterTypeLibEx 

History:
	10-01-1996	Created

++*/

#ifndef _UNREG_H_

#ifdef __cplusplus
extern "C" {
#endif

HRESULT UnRegisterTypeLibEx(REFGUID guid, 
						  unsigned short wVerMajor, 
						  unsigned short wVerMinor, 
						  LCID lcid, 
						  SYSKIND syskind);

#ifdef __cplusplus
}
#endif

#define _UNREG_H_
#endif

// End of file: unreg.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\utils.h ===
/*++

  utils.h

Description:
  Utilities useful to controls

Created:
  Simon Bernstein (SimonB) 30-Sept-1996

++*/

#ifndef _UTILS_H_

#pragma intrinsic(memcpy,memcmp,strcpy,strcmp)

// Convert a VARIANT_BOOL to a regular Win32 BOOL
#define VBOOL_TO_BOOL(X) (VARIANT_TRUE == X)

#define BOOL_TO_VBOOL(X) ((X)?VARIANT_TRUE:VARIANT_FALSE)

// Determine if an optional parameter is empty or not. 
// The OLE docs say the scode should be DISP_E_MEMBERNOTFOUND.  However, according to 
// Doug Franklin, this is wrong.  VBS, JScript and VBA all use DISP_E_PARAMNOTFOUND

#define ISEMPTYARG(x) ((VT_ERROR == V_VT(&x)) && (DISP_E_PARAMNOTFOUND == V_ERROR(&x)))


#define HANDLENULLPOINTER(X) {if (NULL == X) return E_POINTER;}

// Handy functions
BOOL BSTRtoWideChar(BSTR bstrSource, LPWSTR pwstrDest, int cchDest);
HRESULT LoadTypeInfo(ITypeInfo** ppTypeInfo, ITypeLib** ppTypeLib, REFCLSID clsid, GUID libid, LPWSTR pwszFilename);

#define _UTILS_H_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\dmpguid\dmpguids.cpp ===
// Lists the Data1 member of a variety of GUIDS
#include <windows.h>
#include <initguid.h> // once per build
#include "..\precomp.h"
#include "..\..\mmctl\inc\ochelp.h"
#include "objsafe.h"
#include "docobj.h"
#include <stdio.h>

#define DUMPGUID(I,IID) \
	WriteItem(pfHeader, pfCase, I, IID);\
	rgdwIID[i] = IID.Data1; \
	i++;

void WriteToHeader(FILE *pFile, LPSTR pszInterface, GUID riid)
{
	fprintf(pFile, "#define %s_DATA1 0x%lx\r\n", pszInterface, riid.Data1);
}

void WriteToSwitch(FILE *pFile, LPSTR pszInterface)
{
	TCHAR rgchFormat[] = TEXT("case %s_DATA1:\r\n{\r\nif (IsShortEqualIID(riid,%s))\r\n");
	fprintf(pFile, rgchFormat, pszInterface, pszInterface);
}

void WriteItem(FILE *pHfile, FILE *pSwitchFile, LPSTR pszInterface, GUID riid)
{
	WriteToHeader(pHfile, pszInterface, riid);
	WriteToSwitch(pSwitchFile, pszInterface);
}


void main()
{
	TCHAR rgchHeader[] = TEXT("header.h");
	TCHAR rgchSwitch[] = TEXT("switch.cpp");

	DWORD rgdwIID[14];
	int i = 0;
	int j;
	FILE *pfHeader, *pfCase;

	pfHeader = fopen(rgchHeader, "wb+");
	pfCase = fopen(rgchSwitch, "wb+");

	if ( (pfHeader) && (pfCase) )
	{
		ZeroMemory(rgdwIID, sizeof(rgdwIID));

		DUMPGUID("IID_IViewObject", IID_IViewObject);
		DUMPGUID("IID_IViewObject2", IID_IViewObject2);
		DUMPGUID("IID_IViewObjectEx", IID_IViewObjectEx);
		DUMPGUID("IID_IOleCommandTarget", IID_IOleCommandTarget);
		DUMPGUID("IID_IOleObject", IID_IOleObject);
		DUMPGUID("IID_IOleInPlaceObjectWindowless", IID_IOleInPlaceObjectWindowless);
		DUMPGUID("IID_IOleControl", IID_IOleControl);
		DUMPGUID("IID_IConnectionPointContainer", IID_IConnectionPointContainer);
		DUMPGUID("IID_IOleInPlaceObject", IID_IOleInPlaceObject);
		DUMPGUID("IID_IPersistVariantIO", IID_IPersistVariantIO);
		DUMPGUID("IID_IProvideClassInfo", IID_IProvideClassInfo);
		DUMPGUID("IID_IObjectSafety", IID_IObjectSafety);
		DUMPGUID("IID_ISpecifyPropertyPages", IID_ISpecifyPropertyPages);
		DUMPGUID("IID_IUnknown", IID_IUnknown);

		for (i=0; i < (sizeof(rgdwIID)/sizeof(rgdwIID[0])) - 1; i++)
		{
			for (j = i+1; j < (sizeof(rgdwIID)/sizeof(rgdwIID[0])); j++)
			{
				if (rgdwIID[i] == rgdwIID[j])
					printf("%lu and %lu match !\n", i, j);
			}
		}
	}

	if (pfHeader)
	{
		fprintf(pfHeader, "\r\n");
		fclose(pfHeader);
	}
	
	if (pfCase)
	{
		fprintf(pfHeader, "\r\n");
		fclose(pfCase);
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\unreg.cpp ===
/*++

Module: 
	unreg.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	October 1996

Description:
	Unregisters a typelib if the functionality is available.  Fails cleanly if not

History:
	01-18-1997	Added optimization pragmas
	01-11-1997	Changed calling convention for UNREGPROC, bug #169
	10-01-1996	Created

++*/

#include "..\ihbase\precomp.h" 
#include "unreg.h"

// Add these later
// #pragma optimize("a", on) // Optimization: assume no aliasing

typedef HRESULT (__stdcall *UNREGPROC)(REFGUID, WORD, WORD, LCID, SYSKIND);

HRESULT UnRegisterTypeLibEx(REFGUID guid, 
						  WORD wVerMajor, 
						  WORD wVerMinor, 
						  LCID lcid, 
						  SYSKIND syskind)
{
HMODULE hMod;
UNREGPROC procUnReg;
HRESULT hr = S_FALSE;

	hMod = LoadLibrary(TEXT("OLEAUT32.DLL"));
	if (NULL == hMod)
		return S_FALSE;

	procUnReg = (UNREGPROC)GetProcAddress(hMod, TEXT("UnRegisterTypeLib"));
	if (procUnReg)
	{
		hr = procUnReg(guid, wVerMajor, wVerMinor, lcid, syskind);
	}
	else
	{
		//
		// Probably running on standard Win95, no new OLEAUT32.DLL, so the 
		// function isn't available - return, but say that we succeeded 
		// so that the rest of unreg goes cleanly
		//

		hr = S_OK;
	}
	
	FreeLibrary (hMod);
	return hr;
}
	
// Add these later
// #pragma optimize("a", off) // Optimization: assume no aliasing

// End of file (unreg.cpp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\ihbase\utils.cpp ===
#include "precomp.h"
#include "debug.h"
#include "utils.h"

// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>

/*++

Function:
	BSTRtoWideChar

Description:
	Converts a BSTR to a UNICODE string.  Truncates to fit destination 
	if necessary

Author:
	SimonB

History:
	10/01/1996	Created

++*/

// Add these later
// #pragma optimize("a", on) // Optimization: assume no aliasing

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

namespace ATL
{

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}
};

BOOL BSTRtoWideChar(BSTR bstrSource, LPWSTR pwstrDest, int cchDest)
{

// Copies the BSTR in bstrSource to pwstrDest, truncating to make it
// fit in cchDest characters

	int iNumToCopy, iStrLen;
	
	//
	// Make sure we have been passed a valid string
	//

	if (NULL == bstrSource)
		return TRUE;

	ASSERT(pwstrDest != NULL);

	iStrLen = lstrlenW(bstrSource);
	
	// We have enough room to store the whole string ?
	if(iStrLen < cchDest)
		iNumToCopy = iStrLen;
	else 
		iNumToCopy = (cchDest - 1);

	// Copy the BSTR
	CopyMemory(pwstrDest, bstrSource, iNumToCopy * sizeof(WCHAR));
	
	// Insert a terminating \0
	pwstrDest[iNumToCopy] = L'\x0';

	return TRUE;
}


/*++

Function:
	LoadTypeInfo

Description:
	Loads a typelib, first trying it's registered location, followed by
	a filename

Author:
	SimonB 

History:
	10/19/1996	Added ITypeLib parameter
	10/01/1996	Created (from the Win32 SDK "Hello" sample)

++*/


HRESULT LoadTypeInfo(ITypeInfo** ppTypeInfo, ITypeLib** ppTypeLib, REFCLSID clsid, GUID libid, LPWSTR pwszFilename)
{                          
    HRESULT hr;
    LPTYPELIB ptlib = NULL;
	LPTYPEINFO ptinfo = NULL;
	LCID lcid = 0;

	
	// Make sure we have been given valid pointers
	ASSERT(ppTypeInfo != NULL);
	ASSERT(ppTypeLib != NULL);

	// Initialise pointers
    *ppTypeInfo = NULL;     
	*ppTypeLib = NULL;
    
    //
	// Load Type Library. 
	
	// First get the default LCID and try that
	
	lcid = GetUserDefaultLCID();
	hr = LoadRegTypeLib(libid, 1, 0, lcid, &ptlib);
	
	if (TYPE_E_CANTLOADLIBRARY == hr) // We need to try another LCID
	{
		lcid = GetSystemDefaultLCID(); 	// Try the system default
	    hr = LoadRegTypeLib(libid, 1, 0, lcid, &ptlib);
	}

    if ((FAILED(hr)) && (NULL != pwszFilename)) 
    {   
        // If it wasn't a registered typelib, try to load it from the 
		// path (if a filename was provided).  If this succeeds, it will 
		// have registered the type library for us for the next time.  

        hr = LoadTypeLib(pwszFilename, &ptlib); 
	}

	if(FAILED(hr))        
		return hr;   

    // Get type information for interface of the object.      
    hr = ptlib->GetTypeInfoOfGuid(clsid, &ptinfo);
    if (FAILED(hr))  
    { 
        ptlib->Release();
        return hr;
    }   

    
    *ppTypeInfo = ptinfo;
	*ppTypeLib = ptlib;

	// NOTE:  (SimonB, 10-19-1996)
	// It is unnecessary to call ptlib->Release, since we are copying the 
	// pointer to *ppTypeLib. So rather than AddRef that pointer and Release the pointer 
	// we copy it from, we just eliminate both
	
	return NOERROR;
} 


// Add these later
// #pragma optimize("a", off) // Optimization: assume no aliasing

// End of file (utils.cpp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\catid.h ===
// CATID_MMControl -- "Multimedia Control" component category ID
DEFINE_GUID(CATID_MMControl, // {E8558721-9D1F-11cf-92F8-00AA00613BF1}
	0xe8558721, 0x9d1f, 0x11cf, 0x92, 0xf8, 0x0, 0xaa, 0x0, 0x61, 0x3b, 0xf1);

// CATID for Designers
DEFINE_GUID(CATID_Designer,
    0x4eb304d0, 0x7555, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

// $Review: The following two CATIDs have the same values as CATID_SafeFor-
// Scripting and CATID_SafeForInitializing as given in the ocx96 spec.
// However, because the latter CATIDs are *declared* in msdev\include\
// objsafe.h but not *defined* in any standard .h or .lib, *and* because
// the definitions in objsafe.h aren't const (as they should be) we'll
// use these two constants instead. (10/1/96, a-swehba)

// CATID_SafeForScripting
DEFINE_GUID(CATID_SafeForScripting2, // 7dd95801-9882-11cf-9fa9-00aa-006c-42c4}
	0x7dd95801, 0x9882, 0x11cf, 0x9f, 0xa9, 0x00, 0xaa, 0x00, 0x6c, 0x42, 0xc4);

// CATID_SafeForInitializing
DEFINE_GUID(CATID_SafeForInitializing2, // {7dd95802-9882-11cf-9fa9-00aa-006c-42c4}
	0x7dd95802, 0x9882, 0x11cf, 0x9f, 0xa9, 0x00, 0xaa, 0x00, 0x6c, 0x42, 0xc4);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\mmctl.h ===
// mmctl.h
//
// Definitions for "multimedia controls".  Includes OCX96 definitions.
//
// There are two header files for use with "multimedia controls":
//
// "mmctl.h" should be #included in every .cpp file that implements or uses
// multimedia controls.  Alternatively, "mmctl.h" may be #included in a
// precompiled header file (e.g. "precomp.h").
//
// "mmctlg.h" should be #included in every .cpp file that implements or uses
// mutimedia controls, but "mmctlg.h" may NOT be #included in a precompiled
// header file.  Additionally, on ONE .cpp file per project (application/DLL),
// <initguid.h> should be included before "mmctlg.h".
//

#ifndef __MMCTL_H__
#define __MMCTL_H__

#include <olectl.h>


///////////////////////////////////////////////////////////////////////////////
// Constants
//

#define INVALID_FRAME_NUMBER	(0xFFFFFFFF)


///////////////////////////////////////////////////////////////////////////////
// Foward references
//

interface IBitmapSurface;
interface IDirectDrawSurface;
interface IMKBitmap;
interface IRenderSpriteFrameAdviseSink;
interface ISpriteFrameSourceAdviseSink;


///////////////////////////////////////////////////////////////////////////////
// Structures
//

// AnimationInfo -- parameter for IAnimate::SetAnimationInfo
struct AnimationInfo
{
    UINT cbSize;           // Size of this structure.
	DWORD dwTickInterval;  // Interval between calls to IAnimate::Tick.
    DWORD dwFlags;         // Unused.
};


///////////////////////////////////////////////////////////////////////////////
// Interfaces
//

// INonDelegatingUnknown -- helper for implementing aggregatable objects
#ifndef INONDELEGATINGUNKNOWN_DEFINED
#undef  INTERFACE
#define INTERFACE INonDelegatingUnknown
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NonDelegatingRelease)(THIS) PURE;
};
#define INONDELEGATINGUNKNOWN_DEFINED
#endif

// IAnimate -- animation interface

#ifndef IANIMATE_DEFINED
#undef INTERFACE
#define INTERFACE IAnimate
DECLARE_INTERFACE_(IAnimate, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IAnimate methods
    STDMETHOD(Tick) (THIS) PURE;
    STDMETHOD(Rewind) (THIS) PURE;
    STDMETHOD(SetAnimationInfo) (THIS_ AnimationInfo *pAnimationInfo) PURE;
};
#define IANIMATE_DEFINED
#endif

// ISpriteFrameSource - implemented by sprite frame sources
// these flags are returned in the HasIntrinsicData function
#define		grfIntrinsicTransparency		0x1
#define		grfIntrinsicIterations			0x2
#define		grfIntrinsicDurations			0x4
#define		grfIntrinsicFrameCounts			0x8


#ifndef ISPRITEFRAMESOURCE_DEFINED
#undef INTERFACE
#define INTERFACE ISpriteFrameSource
DECLARE_INTERFACE_(ISpriteFrameSource, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// ISpriteFrameSource methods
    STDMETHOD(GetReadyState) (THIS_ long *readystate) PURE;
    STDMETHOD(GetProgress) (THIS_ long *progress) PURE;
    STDMETHOD(Draw) (THIS_ ULONG ulFrame,  HDC hdc,  IBitmapSurface *pSurface, IDirectDrawSurface *pDDSurface, LPCRECT lprect) PURE;
    STDMETHOD(GetFrameSize) (THIS_ ULONG ulFrame, SIZE *psize) PURE;
    STDMETHOD(DefaultFrameSize) (THIS_ SIZE size) PURE;
    STDMETHOD_(BOOL, HasImage) (THIS_ ULONG ulFrame) PURE;
    STDMETHOD_(BOOL, HasTransparency) (THIS_ ULONG ulFrame) PURE;
    STDMETHOD(SetTransparency) (THIS_ BOOL fTransFlag) PURE;
    STDMETHOD(GetTotalFrames) (THIS_ long *framecnt) PURE;
    STDMETHOD(SetTotalFrames) (THIS_ long framecnt) PURE;
    STDMETHOD(GetURL) (THIS_ long cChar, unsigned char * pch) PURE;
    STDMETHOD(SetURL) (THIS_ const unsigned char * pch) PURE;
    STDMETHOD(GetAcrossFrames) (THIS_ long * plFrames) PURE;
    STDMETHOD(SetAcrossFrames) (THIS_ long lFrames) PURE;
    STDMETHOD(GetDownFrames) (THIS_ long * plFrames) PURE;
    STDMETHOD(SetDownFrames) (THIS_ long lFrames) PURE;
    STDMETHOD(Download) (THIS_ IUnknown * pUnk,  long lPriority) PURE;
    STDMETHOD(SetDownloadPriority) (THIS_ long lPriority) PURE;
    STDMETHOD(GetDownloadPriority) (THIS_ long * plPriority) PURE;
    STDMETHOD(AbortDownload) (THIS) PURE;
    STDMETHOD(GetColorSet) (THIS_ LOGPALETTE** ppColorSet) PURE;
    STDMETHOD(OnPaletteChanged) (THIS_ LOGPALETTE *pColorSet, BOOL fStaticPalette, long lBufferDepth) PURE;
    STDMETHOD(LoadFrame) (THIS) PURE;
    STDMETHOD(PurgeFrame) (THIS_ long iAllExceptThisFrame) PURE;
    STDMETHOD(Advise) (THIS_ ISpriteFrameSourceAdviseSink *pisfsas, DWORD *pdwCookie) PURE;
    STDMETHOD(Unadvise) (THIS_ DWORD dwCookie) PURE;
    STDMETHOD_(BOOL, HasIntrinsicData) (THIS) PURE;
    STDMETHOD(GetIterations) (THIS_ ULONG *pulIterations) PURE;
	STDMETHOD_(ULONG, GetFrameDuration) (THIS_ ULONG iFrame) PURE;
	
};
#define ISPRITEFRAMESOURCE_DEFINED
#endif


// IRenderSpriteFrame - implemented by sprite renderers

#ifndef IRENDERSPRITEFRAME_DEFINED
#undef INTERFACE
#define INTERFACE IRenderSpriteFrame
DECLARE_INTERFACE_(IRenderSpriteFrame, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IRenderFrameSource methods
    STDMETHOD(SetObjectRect) (THIS_ LPCRECT lprect) PURE;
    STDMETHOD(GetObjectRect) (THIS_ LPRECT lprect) PURE;
    STDMETHOD_(BOOL, HasImage) (THIS) PURE;
    STDMETHOD_(BOOL, HasTransparency) (THIS) PURE;
    STDMETHOD(Draw) (THIS_ HDC hdcDraw,  IBitmapSurface *pSurface, IDirectDrawSurface *pDDSurface, LPCRECT lprect) PURE;
    STDMETHOD(SetCurrentFrame) (THIS_ ISpriteFrameSource * pisfs,  ULONG ulFrame) PURE;
    STDMETHOD(GetCurrentFrame) (THIS_ ISpriteFrameSource ** ppisfs, ULONG * pulFrame) PURE;
    STDMETHOD(SetAdvise) (THIS_ IRenderSpriteFrameAdviseSink *pirsfas) PURE;
    STDMETHOD(GetAdvise) (THIS_ IRenderSpriteFrameAdviseSink **ppirsfas) PURE;
};
#define IRENDERSPRITEFRAME_DEFINED
#endif

// IMKBitmapFrameSource - implemented by default sprite frame source

#ifndef IMKBITMAPFRAMESOURCE_DEFINED
#undef INTERFACE
#define INTERFACE IMKBitmapFrameSource
DECLARE_INTERFACE_(IMKBitmapFrameSource, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IMKBitmapFrameSource methods
    STDMETHOD(GetBitmap) (THIS_ ULONG ulFrame, IMKBitmap ** pMKBitmap) PURE;
    STDMETHOD(FrameToPoint) (THIS_ ULONG ulFrame, POINT *ppt) PURE;
};
#define IMKBITMAPFRAMESOURCE_DEFINED
#endif

// IRenderSpriteFrameAdviseSink - implemented by those that use a sprite renderer

#ifndef IRENDERSPRITEFRAMEADVISESINK_DEFINED
#undef INTERFACE
#define INTERFACE IRenderSpriteFrameAdviseSink
DECLARE_INTERFACE_(IRenderSpriteFrameAdviseSink, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IRenderSpriteFrameAdviseSink methods
    STDMETHOD(InvalidateRect) (THIS_ LPCRECT lprect) PURE;
    STDMETHOD(OnPosRectChange) (THIS_ LPCRECT lprcOld, LPCRECT lprcNew) PURE;
};
#define IRENDERSPRITEFRAMEADVISESINK_DEFINED
#endif

// ISpriteFrameSourceAdviseSink - implemented by sprite renderer

#ifndef ISPRITEFRAMESOURCEADVISESINK_DEFINED
#undef INTERFACE
#define INTERFACE ISpriteFrameSourceAdviseSink
DECLARE_INTERFACE_(ISpriteFrameSourceAdviseSink, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// ISpriteFrameSourceAdviseSink methods
    STDMETHOD(OnSpriteFrameSourceChange) (ISpriteFrameSource *pisfs) PURE;
};
#define ISPRITEFRAMESOURCEADVISESINK_DEFINED
#endif

// IPseudoEventSink - implemented by HostLW and Multimedia Controls clients

#ifndef IPSEUDOEVENTSINK_DEFINED
#undef INTERFACE
#define INTERFACE IPseudoEventSink
DECLARE_INTERFACE_(IPseudoEventSink, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IPseudoEventSink methods
    STDMETHOD(OnEvent) (THIS_ SAFEARRAY *psaEventInfo) PURE;
};
#define IPSEUDOEVENTSINK_DEFINED
#endif


#endif // __MMCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\mmctlver.h ===
#define rmj		3
#define rmm		0
#define rup		403
#define szVerName	""
#define szVerUser	"a-tonyc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\ocmisc.h ===
// OCMisc.h
//
// Declarations for the OCMisc*.lib static-link library, which
// contains miscellaneous helper functions for implementing and
// using OLE controls.
//

#ifndef __OCMISC_H__
#define __OCMISC_H__

#ifndef __comcat_h__
	#include <comcat.h>
#endif

// parts of OCMisc require MKImage, but this header file can
// get by with only the following definitions:
interface IMKBitmap;


///////////////////////////////////////////////////////////////////////////////
// Constants And Flags
//

// constants for SiteLW
#define SITELW_CLOSEHINT    100     // himetric units that's close enough to hit
#define SITELW_ID_VERB_MIN  1000    // menu ID of first verb of embedded object
#define SITELW_ID_VERB_MAX  1999    // menu ID of last verb of embedded object

// string IDs used by SiteLW
#define SITELW_IDS_NEW              101     // "New..."
#define SITELW_IDS_OPEN             102     // "Open..."
#define SITELW_IDS_CLOSE            103     // "Close"
#define SITELW_IDS_SAVE             104     // "Save"
#define SITELW_IDS_PROPERTIES       105     // "Properties..."

// menu IDs used by SiteLW
#define SITELW_ID_NEW               201     // "New..."
#define SITELW_ID_OPEN              202     // "Open..."
#define SITELW_ID_CLOSE             203     // "Close"
#define SITELW_ID_SAVE              204     // "Save"
#define SITELW_ID_PROPERTIES        205     // "Properties..."

// ISiteLW::SetSiteWindowParameters() <dwFlags> flags
enum
{
    SSWP_OFFSCREEN          = 0x00000001,
    SSWP_HATCHEDBKGND       = 0x00000002,
    SSWP_STRETCHTOWINDOW    = 0x00000004,
    SSWP_ALWAYSSHOWBORDER   = 0x00000008,
    SSWP_CONTEXTNOFILEIO    = 0x00000010,
    SSWP_NOCUSTOMPALETTE    = 0x00000020,
    SSWP_STATICPALETTE      = 0x00000040
};

// flags for PrintableANSIToUNICODE() and UNICODEToPrintableANSI()
#define PA_CSV              0x00000001  // comma-separated variable fmt.
#define PA_HTML             0x00000002  // HTML format

// flags for FindStringInString()
#define FSIS_IGNORECASE     0x00000001  // case-insensitive search

// flags for AllocPropertyBagCompactor()
#define PBC_ISLOADING       0x00000001  // IPropertyBag::Read() will be called

// flags for ISiteLW::NewControl
#define NC_DONTSETSITE      0x00000001  // don't call IOleObject::SetClientSite


///////////////////////////////////////////////////////////////////////////////
// Macros
//

// COUNT_ELEMENTS(array)
#define COUNT_ELEMENTS(array) \
    sizeof(array) / sizeof((array)[0])


///////////////////////////////////////////////////////////////////////////////
// Structures and Types
//

DECLARE_HANDLE(HMRULIST);


///////////////////////////////////////////////////////////////////////////////
// Interfaces
//

// ISiteLW
DEFINE_GUID(IID_ISiteLW, 0xE943E9C0L, 0xEAC6, 0x11CF,
    0xB7, 0x05, 0x00, 0xAA, 0x00, 0xBF, 0x27, 0xFD);
#undef INTERFACE
#define INTERFACE ISiteLW
DECLARE_INTERFACE_(ISiteLW, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // ISiteLW members
    STDMETHOD(SetSiteWindow) (THIS_ HWND hwnd, DWORD dwFlags) PURE;
    STDMETHOD(SetSiteWindowParameters) (THIS_ DWORD dwFlags,
        IMKBitmap *pbmBkgnd) PURE;
    STDMETHOD(SetContainerWindow) (THIS_ HWND hwnd, DWORD dwFlags) PURE;
    STDMETHOD(SetDefaultPalette) (THIS_ HPALETTE hpal) PURE;
    STDMETHOD(GetControlColorSet) (THIS_ LOGPALETTE **pplp) PURE;
    STDMETHOD(SetServiceProvider) (THIS_ IServiceProvider *psp) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD dwAspects, DWORD dwAdvf,
        IAdviseSink *pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD *pdwAspects, DWORD *pdwAdvf,
        IAdviseSink **ppAdvSink) PURE;
    STDMETHOD(NewControl) (THIS_ IUnknown *punk, DWORD dwFlags) PURE;
    STDMETHOD(CloseControl) (THIS) PURE;
    STDMETHOD(ControlIsLoaded) (THIS) PURE;
    STDMETHOD(ControlQueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD(SetDesignMode) (THIS_ BOOL f) PURE;
    STDMETHOD(GetDesignMode) (THIS) PURE;
    STDMETHOD(CanShowProperties) (THIS) PURE;
    STDMETHOD(ShowProperties) (THIS) PURE;
    STDMETHOD(ShowContextMenu) (THIS_ POINT pt,
        BOOL fIncludeEmbeddedControl) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowResized) (THIS) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowQueryNewPalette) (THIS) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowPaletteChanged) (THIS_ WPARAM wParam) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowPaintRequest) (THIS_ WPARAM wParam) PURE;
	STDMETHOD(OnSiteDraw) (THIS_ HDC hdcDraw, LPCRECTL lprcBounds) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowMouseMessage) (THIS_ UINT uiMsg,
        WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowCursorMessage) (THIS_ UINT uiMsg,
        WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowKeyboardMessage) (THIS_ UINT uiMsg,
        WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowCommand) (THIS_ WPARAM wParam) PURE;
    STDMETHOD_(void, OnSiteWindowTick) (THIS) PURE;
    STDMETHOD_(void, OnSiteWindowRewind) (THIS) PURE;
    STDMETHOD_(void, OnSiteWindowSetAnimationInfo) (THIS_
		AnimationInfo *pAnimationInfo) PURE;
    STDMETHOD(OnSiteInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnSiteInPlaceDeactivate) (THIS) PURE;
    STDMETHOD(OnSiteUIActivate) (THIS_ LPMSG lpMsg) PURE;
    STDMETHOD(OnSiteUIDeactivate) (THIS) PURE;
    STDMETHOD(OnTranslateAccelerator) (THIS_ LPMSG lpMsg) PURE;
    STDMETHOD(OnSiteSetObjectRects) (THIS_ LPCRECT lprcPosRect,
		LPCRECT lprcClipRect) PURE;
};

// IActiveDesigner
DEFINE_GUID(IID_IActiveDesigner,
    0x51aae3e0, 0x7486, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

#undef  INTERFACE
#define INTERFACE IActiveDesigner
DECLARE_INTERFACE_(IActiveDesigner, IUnknown)
{
///// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

///// IActiveDesigner methods
	STDMETHOD(GetRuntimeClassID)(THIS_ CLSID *pclsid) PURE;
	STDMETHOD(GetRuntimeMiscStatusFlags)(THIS_ DWORD *pdwMiscFlags) PURE;
	STDMETHOD(QueryPersistenceInterface)(THIS_ REFIID riidPersist) PURE;
	STDMETHOD(SaveRuntimeState)(THIS_ REFIID riidPersist, REFIID riidObjStgMed, void *pObjStgMed) PURE;
	STDMETHOD(GetExtensibilityObject)(THIS_ IDispatch **ppvObjOut) PURE;
};

///////////////////////////////////////////////////////////////////////////////
// Functions
//

STDAPI AllocActiveDesignerHelper(IUnknown *punkOuter, IPersistVariantIO *ppvio,
    REFCLSID rclsidRuntime, DWORD dwRuntimeMiscStatusFlags,
    DWORD dwFlags, IUnknown **ppunk);
STDAPI AllocBindHostService(LPCTSTR szContainerFileName,
    IServiceProvider **ppsp);
STDAPI AllocPropertyBagCompactor(IPropertyBag *ppbCompact, DWORD dwFlags,
    IPropertyBag **pppb);
STDAPI AllocSiteLW(HWND hwnd, HINSTANCE hinst, ISiteLW **);
STDAPI ClearDirtyFlag(IPersistPropertyBag *pppb);
STDAPI CLSIDToFriendlyName(REFCLSID clsid, TCHAR* pszFriendlyName,
    int cchMaxFriendlyNameLen);
STDAPI CLSIDFromTCHAR(const TCHAR* pszCLSID, CLSID* pclsid);
STDAPI CreatePropertyFrame(HWND hwndOwner, UINT x, UINT y, 
    LPCOLESTR lpszCaption, ULONG cObjects, LPUNKNOWN FAR* lplpUnk,
    ULONG cPages, LPCLSID lpPageClsID, LCID lcid, DWORD dwReserved,
    LPVOID lpvReserved);
LPCSTR FindStringInString(LPCSTR szToSearch, LPCSTR szToFind, DWORD dwFlags);
HPALETTE GetHalftonePalette(DWORD dwFlags);
STDAPI GetStreamLengthToEnd(IStream *pstream, ULONG *pcb);
STDAPI LoadFromCSV(IOleClientSite *psite, IStream *pstream,
    LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid,
    DWORD dwFlags);
STDAPI LoadFromHTML(IOleClientSite *psite, IStream *pstream,
    LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid,
    LPSTR *ppchPage, DWORD dwFlags);
STDAPI LoadFromStream(IOleClientSite *psite, IStream *pstream,
    LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid,
    DWORD dwFlags);
STDAPI LoadPropertyBagFromCSV(IStream *pstream, int cch, IPropertyBag *ppb,
    DWORD dwFlags);
STDAPI LoadPropertyBagFromHTML(IStream *pstream, int cch, IPropertyBag *ppb,
    LPSTR * ppchPage, DWORD dwFlags);
HRESULT __cdecl PersistSiteProperties(IVariantIO *pvio, LPCSTR szCollection,
    int iChild, DWORD dwFlags, ...);
STDAPI_(int) PrintableANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc,
    int cwchDstMax, LPCSTR *ppchSrcEnd, DWORD dwFlags);
STDAPI PickClass(HINSTANCE hInstance, UINT residDialogTitle,
    UINT cCategories, const CATID rgCategories[], CLSID* pclsid);
STDAPI ReadHTMLTagToVariantIO(LPCSTR *ppchTag, IManageVariantIO **ppmvio,
    DWORD dwFlags);
STDAPI ReadHTMLToken(LPCSTR pchSrc, LPCSTR *ppchSrcEnd, BSTR *pbstr);
STDAPI ReadStreamToMemory(IStream *pstream, int cch, char **ppchBuf);
STDAPI ReadVariantPropertyFromCSV(LPCSTR pch, VariantProperty *pvp,
    LPCSTR *ppchEnd, DWORD dwFlags);
STDAPI SaveToCSV(IStream *pstream, CLSID *pclsid, IPersistPropertyBag *pppb,
    DWORD dwFlags);
STDAPI SaveToHTML(IStream *pstream, CLSID *pclsid, IPersistPropertyBag *pppb,
    LPCSTR szPage, DWORD dwFlags);
STDAPI SaveToStream(IStream *pstream, CLSID *pclsid, IPersistStream *pps,
    DWORD dwFlags);
STDAPI SaveVariantPropertiesToCSV(IStream *pstream,
    IEnumVariantProperty *pevp, DWORD dwFlags);
STDAPI SaveVariantPropertiesToHTML(IStream *pstream,
    IEnumVariantProperty *pevp, LPCSTR szPage, DWORD dwFlags);
STDAPI_(LPCSTR) SkipWhiteSpace(LPCSTR pch);
STDAPI_(int) UNICODEToPrintableANSI(LPSTR pchDst, LPCWSTR pwchSrc,
    int cchDstMax, int cchSrc, DWORD dwFlags);
STDAPI_(VARTYPE) VariantTypeNameToNumber(char *sz);
STDAPI_(void) VariantTypeNumberToName(VARTYPE vt, char *pch);
STDAPI WriteHTMLTagFromVariantIO(IStream *pstream, IEnumVariantProperty *pevp,
    DWORD dwFlags);
STDAPI WriteHTMLToken(IStream *pstream, LPOLESTR wsz);
STDAPI WriteVariantPropertyToCSV(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags);
STDAPI WriteVariantPropertyToHTML(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags);
STDAPI IsSameObject(IUnknown * punk1, IUnknown * punk2);
STDAPI PersistCollectionProperty(IVariantIO * pvio, LPCSTR szCollection, int iIndex,
    DWORD dwFlags, VARTYPE vt, LPVOID pv);
STDAPI DispatchHelpGetFromStringArray(WORD wFlags, DISPPARAMS *pdispparams,
    VARIANT *pvarResult, char *szList);
long StringToLong(const char *nptr);
STDAPI PersistChildRuntime(IVariantIO *pvio, LPCSTR szCollection,
    int iChild, LPUNKNOWN punk, DWORD dwFlags);

// managing an MRU list
STDAPI_(HMRULIST) OpenMRUList(int cMaxEntries, HKEY hKey, 
    LPCTSTR pszSubkey, LPCSTR pszListName);
STDAPI CloseMRUList(HMRULIST hMRUList);
STDAPI GetMRUListInfo(HMRULIST hMRUList, int* pcEntries, 
    int* pcchMaxEntryLen, int* pcMaxEntries);
STDAPI SetMRUListMaxEntries(HMRULIST hMRUList, int cMaxEntries);
STDAPI GetNextMRUListEntry(HMRULIST hMRUList, TCHAR* szEntry, 
    int* pcchEntryLen);
STDAPI GetIthMRUListEntry(HMRULIST hMRUList, int iEntry, TCHAR* szEntry, 
    int* pcchEntryLen);
STDAPI_(BOOL) AtEndOfMRUList(HMRULIST hMRUList);
STDAPI ResetMRUList(HMRULIST hMRUList);
STDAPI AddMRUListEntry(HMRULIST hMRUList, const TCHAR* szEntry);
STDAPI RemoveAllMRUListEntries(HMRULIST hMRUList);
STDAPI RemoveIthMRUListEntry(HMRULIST hMRUList, int iEntry);
STDAPI RemoveMRUListEntry(HMRULIST hMRUList, const TCHAR* szEntry);
STDAPI MapMRUListToMenu(HMRULIST hMRUList, HMENU hMenu, 
    UINT cBaseMenuItems, UINT iItemAfterMRUList, UINT iFirstMRUItem,
    const TCHAR* pszEmptyListMenuItem);


#endif // __OCMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\mmctlg.h ===
// mmctlg.h
//
// GUID definitions for "multimedia controls".  OCX96 GUIDs are not
// included.  See "mmctl.h" comments for more information.
//

// IAnimate -- animation interface
DEFINE_GUID(IID_IAnimate, // {26BA3E01-C89F-11d0-8B33-00A0C905438D}
	0x26ba3e01, 0xc89f, 0x11d0, 0x8b, 0x33, 0x0, 0xa0, 0xc9, 0x5, 0x43, 0x8d);

// ISpriteFrameSource -- 
DEFINE_GUID(IID_ISpriteFrameSource, // {4592C745-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c745, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// IRenderSpriteFrame -- 
DEFINE_GUID(IID_IRenderSpriteFrame, // {4592C751-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c751, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// IMKBitmapFrameSource -- 
DEFINE_GUID(IID_IMKBitmapFrameSource, // {4592C752-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c752, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// IRenderSpriteFrameAdviseSink -- 
DEFINE_GUID(IID_IRenderSpriteFrameAdviseSink, // {4592C753-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c753, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// ISpriteFrameSourceAdviseSink -- 
DEFINE_GUID(IID_ISpriteFrameSourceAdviseSink, // {4592C754-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c754, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// IID_IPseudoEventSink --
DEFINE_GUID(IID_IPseudoEventSink, // {1E658741-DC5E-11d0-8B41-00A0C905438D}
	0x1e658741, 0xdc5e, 0x11d0, 0x8b, 0x41, 0x0, 0xa0, 0xc9, 0x5, 0x43, 0x8d);

// SID_IPseudoEventSink service --
#define SID_SPseudoEventSink IID_IPseudoEventSink
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\ochelp.h ===
// ochelp.h
//
// Declares functions etc. to help implement a lightweight OLE control.
//

#ifndef __OCHELP_H__
#define __OCHELP_H__


///////////////////////////////////////////////////////////////////////////////
// Constants And Flags
//

// number of HIMETRIC units per inch
#define HIMETRIC_PER_INCH   2540

// flags for ControlInfo.dwFlags
#define CI_INSERTABLE           0x00000001  // register "Insertable" key
#define CI_CONTROL              0x00000002  // register "Control" key
#define CI_MMCONTROL            0x00000004  // register "Multimedia Control" key
#define CI_SAFEFORSCRIPTING     0x00000008  // register "safe-for-scripting"
#define CI_SAFEFORINITIALIZING  0x00000010  // register "safe-for-initializing"
#define CI_NOAPARTMENTTHREADING 0x00000020  // don't register "apartment-aware"
#define CI_DESIGNER             0x00000040  // register "Designer"

// the ControlInfo.dwFlags used by most MM Controls
#define CI_MMSTANDARD  (CI_MMCONTROL | CI_SAFEFORSCRIPTING \
					    | CI_SAFEFORINITIALIZING)

// flags for RegisterControls() <dwAction>
#define RC_REGISTER         0x00000001  // register the control
#define RC_UNREGISTER       0x00000002  // unregister the control

// DVASPECT_MASK: used by HelpQueryHitPoint() -- defined the same as
// DVASPECT_CONTENT except that non-transparent areas of the control are
// drawn black and other parts are either left untouched or draw white
// (cheat: DVASPECT_ICON was overloaded/reused to mean DVASPECT_MASK)
#define DVASPECT_MASK DVASPECT_ICON

// DISPID_BASE is the starting value for DISPIDs assigned by
// CPropertyHelper::GetIDsOfNames (which are IDs for persisted control
// properties).  This base value is used to avoid collisions with
// DISPIDs returned by DispatchHelpGetIDsOfNames (for methods and unpersisted
// control properties).  These latter IDs are assumed < DISPID_BASE.
#define DISPID_BASE         1000

// Palette index TRANSPARENT_COLOR_INDEX is reserved for transparent color.  
#define	TRANSPARENT_COLOR_RGB				RGB('r', 'g', 'b')	// some random 24 bit value
#define TRANSPARENT_COLOR_INDEX				255					// must be 255

// flags for DispatchGetArgs() and DispatchGetArgsList()
#define DGA_EXTRAOK         0x00000001
#define DGA_FEWEROK         0x00000002

// flags for HelpMemAlloc() and HelpMemFree()
#define HM_TASKMEM          0x80000000
#define HM_LEAKDETECT       0x40000000
#define HM_GMEM_MASK        0x0000FFFF  // reserved for GMEM_ values
#define HM_ZEROINIT         GMEM_ZEROINIT

// flags for HelpMemSetFailureMode()
#define HM_FAILNEVER        0x00000001
#define HM_FAILAFTER        0x00000002
#define HM_FAILUNTIL        0x00000004
#define HM_FAILEVERY        0x00000008
#define HM_FAILRANDOMLY     0x00000010

// custom messages sent to PropPageHelperProc
#define WM_PPH_APPLY                    (WM_USER + 1)
#define WM_PPH_HELP                     (WM_USER + 2)
#define WM_PPH_TRANSLATEACCELERATOR     (WM_USER + 3)

// macros that define DrawControlBorder() <piHit> values
#define DCB_HIT_GRAB(x, y)  (((y) << 2) | x)
#define DCB_HIT_EDGE            14
#define DCB_HIT_NONE            15

// Handle values (binary):  Handle values(decimal):
//    0000  0001  0010            0   1   2
//    0100        0110            4       6
//    1000  1001  1010            8   9  10
//

// masks that refer to collections of parts of the control border
#define DCB_EDGE            (1 << DCB_HIT_EDGE)
#define DCB_CORNERHANDLES   0x00000505  // handles at bit positions 0, 2, 8, 10
#define DCB_SIDEHANDLES     0x00000252  // handles at bit positions 1, 4, 6, 9
#define DCB_SIZENS          0x00000202  // handles at bit positions 1, 9
#define DCB_SIZEWE          0x00000050  // handles at bit positions 4, 6
#define DCB_SIZENESW        0x00000104  // handles at bit positions 2, 8
#define DCB_SIZENWSE        0x00000401  // handles at bit positions 0, 10

// other flags
#define DCB_XORED           0x80000000  // draw control border with XOR brush
#define DCB_INFLATE         0x40000000  // inflate <*prc> to include border

// flags for IVariantIO functions
#define VIO_ISLOADING       0x00000001  // VariantIO is in loading mode
#define VIO_ZEROISDEFAULT   0x00000002  // don't save 0 values since these are defaults

// flags for IPersistVariantIO functions
#define PVIO_PROPNAMESONLY  0x80000000  // DoPersist() only needs prop names
#define PVIO_CLEARDIRTY     0x40000000  // control should clear dirty flag
#define PVIO_NOKIDS         0x20000000  // control should not save children
#define PVIO_RUNTIME        0x10000000  // control should save runtime version of itself

// flags for AllocVariantIOToMapDISPID
#define VIOTMD_GETPROP      0x08000000  // get property value
#define VIOTMD_PUTPROP      0x04000000  // set property value

// flags for MsgWndDestroy function
#define MWD_DISPATCHALL     0x00000001  // dispatch all the window's messages 
										//  before destroying the window


///////////////////////////////////////////////////////////////////////////////
// Macros
//

// REG_CLOSE_KEY(hKey)
#define REG_CLOSE_KEY(hKey) \
    if ((hKey) != NULL) \
    { \
        RegCloseKey(hKey); \
        (hKey) = NULL; \
    }


///////////////////////////////////////////////////////////////////////////////
// Types
//

// AllocOCProc -- see RegisterControls()
EXTERN_C typedef LPUNKNOWN (STDAPICALLTYPE AllocOCProc)(LPUNKNOWN punkOuter);

// MsgWndCallback -- See MsgWndSendToCallback()
typedef void (CALLBACK MsgWndCallback) (UINT uiMsg, WPARAM wParam,
    LPARAM lParam);

// PropPageHelperProc -- see AllocPropPageHelper()
struct PropPageHelperInfo; // forward declaration
typedef BOOL (CALLBACK* PropPageHelperProc)(HWND hwnd, UINT uiMsg,
    WPARAM wParam, LPARAM lParam, PropPageHelperInfo *pInfo, HRESULT *phr);

// VERB_ENUM_CALLBACK -- See AllocVerbEnumHelper()
typedef HRESULT (VERB_ENUM_CALLBACK)(OLEVERB* pVerb, void* pOwner);


///////////////////////////////////////////////////////////////////////////////
// Structures
//

// ControlInfo -- parameters for RegisterOneControl() and RegisterControls()
struct ControlInfo
{
    UINT cbSize;
    LPCTSTR tszProgID;
    LPCTSTR tszFriendlyName;
    const CLSID *pclsid;
    HMODULE hmodDLL;
    LPCTSTR tszVersion;
    int iToolboxBitmapID;
    DWORD dwMiscStatusDefault;
    DWORD dwMiscStatusContent;
    const GUID *pguidTypeLib;
    AllocOCProc *pallococ;
    ULONG* pcLock;
    DWORD dwFlags;
    ControlInfo *pNext;
    UINT uiVerbStrID;
};

// HelpAdviseInfo -- see InitHelpAdvise(), HelpSetAdvise(), HelpGetAdvise()
struct HelpAdviseInfo
{
    DWORD           dwAspects;      // current SetAdvise() state
    DWORD           dwAdvf;         // current SetAdvise() state
    IAdviseSink *   pAdvSink;       // current SetAdvise() state
};

// PropPageHelperInfo -- used by AllocPropPageHelper
struct PropPageHelperInfo
{
    // initialized by aggregator
    int             idDialog;       // ID of propery page dialog resource
    int             idTitle;        // page title (ID of string resource)
    HINSTANCE       hinst;          // contains <idDialog> and <idTitle>
    PropPageHelperProc pproc;       // callback function
    IID             iid;            // interface that <ppunk[i]> will point to
    DWORD           dwUser;         // aggregator-specific information

    // initialized by AllocPropPageHelper
    IPropertyPageSite *psite;       // frame's page site object
    LPUNKNOWN *     ppunk;          // controls whose properties are shown
    int             cpunk;          // number of elements in <m_ppunk>
    HWND            hwnd;           // property page window
    BOOL            fDirty;         // TRUE iff changes not yet applied
    BOOL            fLockDirty;     // if TRUE, don't change <m_fDirty>
};

// VariantProperty -- a name/value pair
struct VariantProperty
{
    BSTR bstrPropName;
    VARIANT varValue;
};

// VariantPropertyHeader -- see ReadVariantProperty()
struct VariantPropertyHeader
{
    int iType;
    unsigned int cbData;
};



///////////////////////////////////////////////////////////////////////////////
// Interfaces
//

// IConnectionPointHelper interface
DEFINE_GUID(IID_IConnectionPointHelper, 0xD60E16C0L, 0x8AF2, 0x11CF,
    0xB7, 0x05, 0x00, 0xAA, 0x00, 0xBF, 0x27, 0xFD);
#undef INTERFACE
#define INTERFACE IConnectionPointHelper
DECLARE_INTERFACE_(IConnectionPointHelper, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IConnectionPointHelper members
    STDMETHOD(FireEventList) (DISPID dispid, va_list args) PURE;
    virtual HRESULT __cdecl FireEvent(DISPID dispid, ...) PURE;
    STDMETHOD(FireOnChanged) (DISPID dispid) PURE;
    STDMETHOD(FireOnRequestEdit) (DISPID dispid) PURE;
    STDMETHOD(EnumConnectionPoints) (LPENUMCONNECTIONPOINTS *ppEnum) PURE;
    STDMETHOD(FindConnectionPoint) (REFIID riid, LPCONNECTIONPOINT *ppCP) PURE;
	STDMETHOD(Close) (void) PURE;
};

// IEnumVariantProperty
DEFINE_GUID(IID_IEnumVariantProperty, 0xD0230A60L, 0x99C8, 0x11CF,
    0xB8, 0xED, 0x00, 0x20, 0xAF, 0x34, 0x4E, 0x0A);
#undef INTERFACE
#define INTERFACE IEnumVariantProperty
DECLARE_INTERFACE_(IEnumVariantProperty, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IEnumVariantProperty members
    STDMETHOD(Next) (THIS_ unsigned long celt, VariantProperty *rgvp,
        unsigned long *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ unsigned long celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumVariantProperty **ppenum) PURE;
    
};

// IVariantIO
DEFINE_GUID(IID_IVariantIO, 0xD07B1240L, 0x99C4, 0x11CF,
    0xB8, 0xED, 0x00, 0x20, 0xAF, 0x34, 0x4E, 0x0A);
#undef INTERFACE
#define INTERFACE IVariantIO
DECLARE_INTERFACE_(IVariantIO, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IVariantIO members
    STDMETHOD(PersistList) (THIS_ DWORD dwFlags, va_list args) PURE;
    virtual HRESULT __cdecl Persist(THIS_ DWORD dwFlags, ...) PURE;
    STDMETHOD(IsLoading) (THIS) PURE;
};

// IManageVariantIO
DEFINE_GUID(IID_IManageVariantIO, 0x02D937E0L, 0x99C9, 0x11CF,
    0xB8, 0xED, 0x00, 0x20, 0xAF, 0x34, 0x4E, 0x0A);
#undef INTERFACE
#define INTERFACE IManageVariantIO
DECLARE_INTERFACE_(IManageVariantIO, IVariantIO)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IVariantIO members
    STDMETHOD(PersistList) (THIS_ DWORD dwFlags, va_list args) PURE;
    virtual HRESULT __cdecl Persist(THIS_ DWORD dwFlags, ...) PURE;
    STDMETHOD(IsLoading) (THIS) PURE;

    // IManageVariantIO members
    STDMETHOD(SetMode) (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetMode) (THIS_ DWORD *pdwFlags) PURE;
    STDMETHOD(DeleteAllProperties) (THIS) PURE;
};

// IPersistVariantIO
DEFINE_GUID(IID_IPersistVariantIO, 0x26F45840L, 0x9CF2, 0x11CF,
    0xB8, 0xED, 0x00, 0x20, 0xAF, 0x34, 0x4E, 0x0A);
#undef INTERFACE
#define INTERFACE IPersistVariantIO
DECLARE_INTERFACE_(IPersistVariantIO, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IPersistVariantIO members
    STDMETHOD(InitNew) (THIS) PURE;
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(DoPersist) (THIS_ IVariantIO* pvio, DWORD dwFlags) PURE;
};


///////////////////////////////////////////////////////////////////////////////
// Functions
//

// define standard DLL entry point
extern "C" BOOL WINAPI _DllMainCRTStartup(HANDLE  hDllHandle, DWORD dwReason,
    LPVOID lpreserved);

// Implementing An In-Process Control DLL
STDAPI HelpGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv,
    ControlInfo *pctlinfo);
STDAPI RegisterControls(ControlInfo *pctlinfo, DWORD dwAction);

// Creating Controls
STDAPI CreateControlInstance(LPCSTR szName, LPUNKNOWN punkOuter,
    DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid,
    BOOL* pfSafeForScripting, BOOL* pfSafeForInitializing, DWORD dwFlags);

// Implementing Properties And Methods
HRESULT __cdecl DispatchGetArgs(DISPPARAMS *pdp, DWORD dwFlags, ...);
STDAPI DispatchGetArgsList(DISPPARAMS *pdp, DWORD dwFlags, va_list args);
STDAPI DispatchHelpGetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid, const char *szList);
STDAPI VariantFromString(VARIANT *pvar, LPCTSTR szSrc);

// Calling Properties And Methods
HRESULT __cdecl DispatchInvoke(IDispatch *pdisp, DISPID dispid,
    WORD wFlags, VARIANT *pvarResult, ...);
STDAPI DispatchInvokeEZ(IDispatch *pdisp, LPWSTR pstr, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, ...);
STDAPI DispatchInvokeIDEZ(IDispatch *pdisp, DISPID dispid, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, ...);
STDAPI DispatchInvokeList(IDispatch *pdisp, DISPID dispid,
    WORD wFlags, VARIANT *pvarResult, va_list args);
#define DispatchPropertyGet(pdisp, dispid, pvarResult) \
    (DispatchInvoke((pdisp), (dispid), DISPATCH_PROPERTYGET, (pvarResult), 0))
#define DispatchPropertyPut(pdisp, dispid, vt, value) \
    (DispatchInvoke((pdisp), (dispid), DISPATCH_PROPERTYPUT, NULL, \
        (vt), (value), 0))

// Firing Events
STDAPI AllocConnectionPointHelper(IUnknown *punkParent, REFIID riid,
    IConnectionPointHelper **ppconpt);
STDAPI FreeConnectionPointHelper(IConnectionPointHelper *pconpt);
STDAPI HelpGetClassInfo(LPTYPEINFO *ppti, REFCLSID rclsid, char *szEventList,
    DWORD dwFlags);
STDAPI HelpGetClassInfoFromTypeLib(LPTYPEINFO *ppTI, REFCLSID rclsid,
    ITypeLib *plib, HINSTANCE hinst, DWORD dwFlags);
HRESULT __cdecl FirePseudoEvent(HWND hwnd, LPCOLESTR oszEvName, 
	IDispatch *pctl, ...);
STDAPI FirePseudoEventList(HWND hwnd, LPCOLESTR oszEvName, 
	IDispatch *pctl, va_list args);

// Thread Safety And Popup Menus
STDAPI_(HWND) MsgWndCreate();
STDAPI_(void) MsgWndDestroy(HWND hwnd, DWORD dwFlags);
STDAPI_(LRESULT) MsgWndPostToCallback(HWND hwnd, MsgWndCallback *pproc,
    UINT uiMsg, LPARAM lParam);
STDAPI_(LRESULT) MsgWndSendToCallback(HWND hwnd, MsgWndCallback *pproc,
    UINT uiMsg, LPARAM lParam);
STDAPI_(BOOL) MsgWndTrackPopupMenuEx(HWND hwnd, HMENU hmenu, UINT fuFlags,
    int x, int y, LPTPMPARAMS lptpm, MsgWndCallback *pproc, LPARAM lParam);
STDAPI_(UINT_PTR) MsgWndSetTimer(HWND hwnd, MsgWndCallback *pproc, UINT nIDEvent,
        UINT uElapse, LPARAM lParam);

// Implementing IViewObject
STDAPI InitHelpAdvise(HelpAdviseInfo *pha);
STDAPI HelpSetAdvise(DWORD dwAspects, DWORD dwAdvf, IAdviseSink *pAdvSink,
    HelpAdviseInfo *pha);
STDAPI HelpGetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
    IAdviseSink **ppAdvSink, HelpAdviseInfo *pha);
STDAPI_(void) UninitHelpAdvise(HelpAdviseInfo *pha);

// Implementing IViewObjectEx
STDAPI HelpQueryHitPoint(IViewObject *pvo, DWORD dwAspect, LPCRECT prcBounds,
    POINT ptLoc, LONG lCloseHint, DWORD *pHitResult);

// Implementing Persistence and Simple IDispatch
STDAPI AllocChildPropertyBag(IPropertyBag *ppbParent, LPCSTR szPropNamePrefix,
    DWORD dwFlags, IPropertyBag **pppbChild);
STDAPI AllocPropertyBagOnStream(IStream *pstream, DWORD dwFlags,
    IPropertyBag **pppb);
STDAPI AllocPropertyBagOnVariantProperty(VariantProperty *pvp, DWORD dwFlags,
    IPropertyBag **pppb);
STDAPI AllocPropertyHelper(IUnknown *punkOuter, IPersistVariantIO *ppvio,
    REFCLSID rclsid, DWORD dwFlags, IUnknown **ppunk);
STDAPI AllocVariantIO(IManageVariantIO **ppmvio);
STDAPI AllocVariantIOOnPropertyBag(IPropertyBag *ppb,
    IManageVariantIO **ppmvio);
STDAPI AllocVariantIOToMapDISPID(char *pchPropName, DISPID *pdispid,
    VARIANT *pvar, DWORD dwFlags, IVariantIO **ppvio);
STDAPI LoadPropertyBagFromStream(IStream *pstream, IPropertyBag *ppb,
    DWORD dwFlags);
STDAPI PersistChild(IVariantIO *pvio, LPCSTR szCollection,
    int iChild, LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk,
    CLSID *pclsid, BOOL *pfSafeForScripting, BOOL *pfSafeForInitializing,
    DWORD dwFlags);
STDAPI PersistVariantIO(IPropertyBag *ppb, DWORD dwFlags, ...);
STDAPI PersistVariantIOList(IPropertyBag *ppb, DWORD dwFlags, va_list args);
STDAPI ReadVariantProperty(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags);
STDAPI_(void) VariantPropertyClear(VariantProperty *pvp);
STDAPI_(void) VariantPropertyInit(VariantProperty *pvp);
STDAPI WriteVariantProperty(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags);

// Utility Functions
STDAPI_(int) ANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc, int cwchDstMax);
STDAPI_(int) CompareUNICODEStrings(LPCWSTR wsz1, LPCWSTR wsz2);
STDAPI_(char *) FindCharInString(const char *sz, char chFind);
STDAPI_(char *) FindCharInStringRev(const char *sz, char chFind);
STDAPI_(const char *) FindStringByIndex(const char *szList, int iString,
    int *pcch);
STDAPI_(int) FindStringByValue(const char *szList, const char *szFind);
#define HelpDelete(pv) HelpMemFree(HM_ZEROINIT | HM_LEAKDETECT, (pv))
STDAPI_(LPVOID) HelpMemAlloc(DWORD dwFlags, ULONG cb);
STDAPI_(void) HelpMemFree(DWORD dwFlags, LPVOID pv);
#ifdef _DEBUG
STDAPI_(void) HelpMemSetFailureMode(ULONG ulParam, DWORD dwFlags);
#endif
#define HelpNew(cb) HelpMemAlloc(HM_ZEROINIT | HM_LEAKDETECT, (cb))
STDAPI_(void) HIMETRICToPixels(int cx, int cy, SIZE *psize);
STDAPI_(void) PixelsToHIMETRIC(int cx, int cy, LPSIZEL psize);
STDAPI_(ULONG) SafeRelease (LPUNKNOWN *ppunk);
#define TaskMemAlloc(cb) HelpMemAlloc(HM_TASKMEM, (cb))
#define TaskMemFree(pv) HelpMemFree(HM_TASKMEM, (pv))
STDAPI_(TCHAR*) TCHARFromGUID(REFGUID guid, TCHAR* pszGUID, int cchMaxGUIDLen);
STDAPI_(int) UNICODEToANSI(LPSTR pchDst, LPCWSTR pwchSrc, int cchDstMax);
STDAPI_(wchar_t *) UNICODEConcat(wchar_t *wpchDst, const wchar_t *wpchSrc,
    int wcchDstMax);
STDAPI_(wchar_t *) UNICODECopy(wchar_t *wpchDst, const wchar_t *wpchSrc,
    int wcchDstMax);

// Design-Time Functions
STDAPI_(IEnumOLEVERB*) AllocVerbEnumHelper(LPUNKNOWN punkOuter, void* pOwner,
    CLSID clsidOwner, VERB_ENUM_CALLBACK* pCallback);
STDAPI AllocPropPageHelper(LPUNKNOWN punkOuter, PropPageHelperInfo *pInfo,
    UINT cbInfo, LPUNKNOWN *ppunk);
STDAPI_(HBRUSH) CreateBorderBrush();
STDAPI DrawControlBorder(HDC hdc, RECT *prc, POINT *pptPrev, POINT *ppt,
    int *piHit, DWORD dwFlags);

// Miscellaneous Registry Helper Functions
STDAPI_(LONG) RegDeleteTree(HKEY hParentKey, LPCTSTR szKeyName);

// Functions that must be called by a client who uses OCHelp as a static
// library.  These are not called by clients who use the DLL version of OCHelp.
STDAPI_(BOOL) InitializeStaticOCHelp(HINSTANCE hInstance);
STDAPI_(void) UninitializeStaticOCHelp();

// Miscellaneous Functions
HRESULT __cdecl GetObjectSafety(BOOL* pfSafeForScripting, 
    BOOL* pfSafeForInitializing, IUnknown* punk, CLSID* pclsid, ...);

// Malloc spying
#ifdef _DEBUG

#define MALLOCSPY_BREAK_ON_ALLOC	0x00000001
#define MALLOCSPY_BREAK_ON_FREE		0x00000002

#define MALLOCSPY_NO_MSG_BOX		0x00000001
#define MALLOCSPY_NO_BLOCK_LIST		0x00000002

typedef HANDLE HMALLOCSPY;

STDAPI_(HMALLOCSPY) InstallMallocSpy(DWORD dwFlags);
STDAPI UninstallMallocSpy(HMALLOCSPY hSpy);
STDAPI_(void) SetMallocBreakpoint(HMALLOCSPY hSpy, ULONG iAllocNum, 
	SIZE_T cbSize, DWORD dwFlags);
STDAPI_(BOOL) DetectMallocLeaks(HMALLOCSPY hSpy, ULONG* pcUnfreedBlocks, 
	SIZE_T* pcbUnfreedBytes, DWORD dwFlags);

#endif // _DEBUG

// Wrappers for URLMON functions.
// These wrappers are defined so we can run without urlmon.dll existing
// on the target system. This is useful only for the Netscape Plugin.
//
// These definitions depend on symbols defined in urlmon.h (e.g.
// IBindStatusCallback). They aren't needed in places where urlmon.h
// hasn't been included. So rather than include urlmon.h everywhere,
// we use the __urlmon_h__ symbol to conditionally process this section.
#ifdef __urlmon_h__
STDAPI HelpCreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEFetc, IBindCtx **ppBC);
STDAPI HelpCreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);
STDAPI HelpMkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten, LPMONIKER *ppmk);
STDAPI HelpRegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback** ppBSCBPrev, DWORD dwReserved);
STDAPI HelpRevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb);
STDAPI HelpURLOpenStreamA(LPUNKNOWN punk, LPCSTR szURL, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc);
STDAPI HelpURLDownloadToCacheFileA(LPUNKNOWN punk, LPCSTR szURL, LPTSTR szFile, DWORD cch, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc);
#endif	// __urlmon_h__

#endif // __OCHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\mmtimer.h ===
// MmTimer.h
//
// Definitions for the timer interfaces.
//

#ifndef __MMTIMER_H__
#define __MMTIMER_H__

// IAdvTimerSink interface
#undef INTERFACE
#define INTERFACE IAdvTimerSink
DECLARE_INTERFACE_(IAdvTimerSink, ITimerSink)
{
    STDMETHOD(OnStateChange)(DWORD dwFlags) PURE;
};

// IAdvTimerSink
DEFINE_GUID(IID_IAdvTimerSink, 
    0xb1ac63d3, 0x5857, 0x11d0, 0x8b, 0xbe, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0x3);


// IAdvTimer interface

struct ADVTIMERSTATE
{
    DWORD cbSize;       // Size of structure
    float fltRate;      // Current rate of timer
    DWORD cWraps;       // Number of times the timer has wrapped
};

#define ADVTIMER_RATECHANGE 1
#define ADVTIMER_POSCHANGE 2
#define ADVTIMER_WRAP 4

#undef INTERFACE
#define INTERFACE IAdvTimer
DECLARE_INTERFACE_(IAdvTimer, ITimer)
{
    STDMETHOD(AdviseStateChange)(DWORD dwFlags, IAdvTimerSink * pAdvTimerSink,
        DWORD * pdwCookie) PURE;
    STDMETHOD(GetState)(ADVTIMERSTATE * pState) PURE;
};

// IAdvTimer
DEFINE_GUID(IID_IAdvTimer, 
    0xb1ac63d2, 0x5857, 0x11d0, 0x8b, 0xbe, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0x3);


#endif // __MMTIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\acpb.cpp ===
// acpb.cpp
//
// Implements AllocChildPropertyBag.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// ChildPropertyBag
//

/* @object ChildPropertyBag |

        Implements <i IPropertyBag> that provides a child object (contained
        within a parent object) access to the child's properties, which
        are stored within the parent's property bag.  The name of each child's
        property is prefixed with a given string (e.g. "Controls(7).").

@supint <i IPropertyBag> | The interface through which the child object
        accesses its properties.

@comm   Use <f AllocChildPropertyBag> to create a
        <o ChildPropertyBag> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CChildPropertyBag
//

struct CChildPropertyBag : IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    IPropertyBag *  m_ppbParent;    // parent's property bag
    OLECHAR         m_oachPrefix[_MAX_PATH];

///// construction and destruction
    CChildPropertyBag(IPropertyBag *ppbParent, LPCSTR szPropNamePrefix);
    ~CChildPropertyBag();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// ChildPropertyBag Creation & Destruction
//

/* @func HRESULT | AllocChildPropertyBag |

        Creates a <o ChildPropertyBag> object which implements <i IPropertyBag>
        that provides a child object (contained within a parent object) access
        to the child's properties, which are stored within the parent's
        property bag.  The name of each child's property is prefixed with a
        given string (e.g. "Controls(7).").

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IPropertyBag * | ppbParent | Parent's property bag.

@parm   LPCSTR | szPropNamePrefix | Prefix on the property name of each of the
        child's properties that are stored within the parent's property bag.
        This prefix does not appear on the properties in the returned
        property bag *<p pppbChild>.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@parm   IPropertyBag * * | pppbChild | Where to store the <i IPropertyBag>
        pointer to the new <o ChildPropertyBag> object.  NULL is stored
        in *<p pppbChild> on error.
*/
STDAPI AllocChildPropertyBag(IPropertyBag *ppbParent, LPCSTR szPropNamePrefix,
    DWORD dwFlags, IPropertyBag **pppbChild)
{
    // create the Windows object
    if ((*pppbChild = (IPropertyBag *)
            New CChildPropertyBag(ppbParent, szPropNamePrefix)) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CChildPropertyBag::CChildPropertyBag(IPropertyBag *ppbParent,
    LPCSTR szPropNamePrefix)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_ppbParent = ppbParent;
    m_ppbParent->AddRef();
    ANSIToUNICODE(m_oachPrefix, szPropNamePrefix,
        sizeof(m_oachPrefix) / sizeof(*m_oachPrefix));
}

CChildPropertyBag::~CChildPropertyBag()
{
    // cleanup
    m_ppbParent->Release();
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CChildPropertyBag::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("ChildPropertyBag::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IVariantIO) ||
        IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
    if (IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CChildPropertyBag::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChildPropertyBag::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CChildPropertyBag::Read(LPCOLESTR pszPropName,
    LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    OLECHAR oach[_MAX_PATH];
    UNICODECopy(oach, m_oachPrefix, sizeof(oach) / sizeof(*oach));
    UNICODEConcat(oach, pszPropName, sizeof(oach) / sizeof(*oach));
    return m_ppbParent->Read(oach, pVar, pErrorLog);
}

STDMETHODIMP CChildPropertyBag::Write(LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    OLECHAR oach[_MAX_PATH];
    UNICODECopy(oach, m_oachPrefix, sizeof(oach) / sizeof(*oach));
    UNICODEConcat(oach, pszPropName, sizeof(oach) / sizeof(*oach));
    return m_ppbParent->Write(oach, pVar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\advise.cpp ===
// advise.cpp
//
// Implements functions to help implement IViewObject::SetAdvise and
// IViewObject::GetAdvise.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | InitHelpAdvise |

        Initializes a <t HelpAdviseInfo> structure, used to help implement
        <om IViewObject.SetAdvise> and <om IViewObject.GetAdvise>.

@parm   HelpAdviseInfo * | pha | Caller-allocated structure that contains
        information used to help implement <om IViewObject.SetAdvise> and
        <om IViewObject.GetAdvise>.

@comm   You must call <f InitHelpAdvise> before calling <f HelpSetAdvise>
        and <f HelpGetAdvise>, and <f UninitHelpAdvise> when the object
        that contains the <t HelpAdviseInfo> structure is deleted.
*/
STDAPI InitHelpAdvise(HelpAdviseInfo *pha)
{
    memset(pha, 0, sizeof(*pha));
    return S_OK;
}


/* @func void | UninitHelpAdvise |

        Peforms final cleanup of a <t HelpAdviseInfo> structure, including
        releasing the <i IAdviseSink> pointer if necessary.

@parm   HelpAdviseInfo * | pha | Caller-allocated structure that was
        previously initialized using <f InitHelpAdvise>.

@comm   You must call <f InitHelpAdvise> before calling <f HelpSetAdvise>
        and <f HelpGetAdvise>, and <f UninitHelpAdvise> when the object
        that contains the <t HelpAdviseInfo> structure is deleted.
*/
STDAPI_(void) UninitHelpAdvise(HelpAdviseInfo *pha)
{
    if (pha->pAdvSink != NULL)
        pha->pAdvSink->Release();
}


/* @func HRESULT | HelpSetAdvise |

        Helps implement <om IViewObject.SetAdvise>.

@parm   DWORD | dwAspects | See <om IViewObject.SetAdvise>.

@parm   DWORD | dwAdvf | See <om IViewObject.SetAdvise>.

@parm   IAdviseSink * | pAdvSink | See <om IViewObject.SetAdvise>.

@parm   HelpAdviseInfo * | pha | Caller-allocated structure that was
        previously initialized using <f InitHelpAdvise>.

@comm   You must call <f InitHelpAdvise> before calling <f HelpSetAdvise>
        and <f HelpGetAdvise>, and <f UninitHelpAdvise> when the object
        that contains the <t HelpAdviseInfo> structure is deleted.

        This function updates *<p pha> with information given by the
        parameters <p dwAspects>, <p dwAdvf>, and <p pAdvSink>.  In particular,
        the <i IAdviseSink> pointer is stored in <p pha>-<gt><p pAdvSink>,
        and you can use this pointer (when non-NULL) to advise the
        view site object of changes in your object's view (e.g. by calling
        <p pha>-<gt><p pAdvSink>-<gt>OnViewChange()).

@ex     The following example shows how to use <f HelpSetAdvise> to help
        implement <om IViewObject.SetAdvise>, assuming <p m_advise> is
        a member variable of type <t HelpAdviseInfo>. |

        STDMETHODIMP CMyControl::SetAdvise(DWORD dwAspects, DWORD dwAdvf,
            IAdviseSink *pAdvSink)
        {
            return HelpSetAdvise(dwAspects, dwAdvf, pAdvSink, &m_advise);
        }

*/
STDAPI HelpSetAdvise(DWORD dwAspects, DWORD dwAdvf, IAdviseSink *pAdvSink,
    HelpAdviseInfo *pha)
{
    pha->dwAspects = dwAspects;
    pha->dwAdvf = dwAdvf;
    if (pha->pAdvSink != NULL)
        pha->pAdvSink->Release();
    pha->pAdvSink = pAdvSink;
    if (pha->pAdvSink != NULL)
        pha->pAdvSink->AddRef();
    return S_OK;
}


/* @func HRESULT | HelpGetAdvise |

        Helps implement <om IViewObject.GetAdvise>.

@parm   DWORD * | pdwAspects | See <om IViewObject.GetAdvise>.

@parm   DWORD * | pdwAdvf | See <om IViewObject.GetAdvise>.

@parm   IAdviseSink * * | ppAdvSink | See <om IViewObject.GetAdvise>.

@parm   HelpAdviseInfo * | pha | Caller-allocated structure that was
        previously initialized using <f InitHelpAdvise>.

@comm   You must call <f InitHelpAdvise> before calling <f HelpGetAdvise>
        and <f HelpGetAdvise>, and <f UninitHelpAdvise> when the object
        that contains the <t HelpAdviseInfo> structure is deleted.

        This function fills in *<p pdwAspects>, *<p pdwAdvf>, and
        *<p ppAdvSink> with information from <p pha>.

@ex     The following example shows how to use <f HelpGetAdvise> to help
        implement <om IViewObject.GetAdvise>, assuming <p m_advise> is
        a member variable of type <t HelpAdviseInfo>. |

        STDMETHODIMP CMyControl::GetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
            IAdviseSink **ppAdvSink)
        {
            return HelpGetAdvise(pdwAspects, pdwAdvf, ppAdvSink, &m_advise);
        }
*/
STDAPI HelpGetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
    IAdviseSink **ppAdvSink, HelpAdviseInfo *pha)
{
    if (pdwAspects != NULL)
        *pdwAspects = pha->dwAspects;
    if (pdwAdvf != NULL)
        *pdwAdvf = pha->dwAdvf;
    if (ppAdvSink != NULL)
    {
        *ppAdvSink = pha->pAdvSink;
        if (*ppAdvSink != NULL)
            (*ppAdvSink)->AddRef();
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\allocspy.cpp ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:                AllocSpy.cpp
//                              
// Description: This module contains the implementation of the exported
//                              functions:
//
//                                      InstallMallocSpy
//                                      UninstallMallocSpy
//                                      SetMallocBreakpoint
//                                      DetectMallocLeaks
//
//                              and the exported-classes:
//
//                                      CMallocSpy
//                                      CSpyList
//                                      CSpyListNode
//
// @doc MMCTL
//===========================================================================

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "precomp.h"
#ifdef _DEBUG
#include "..\..\inc\ochelp.h"   // CMallocSpy
#include "Globals.h"
#include "debug.h"                              // ASSERT()
#include "allocspy.h"




//---------------------------------------------------------------------------
// Global Variables
//---------------------------------------------------------------------------

#define HMALLOCSPY_NOTOWNER ((HMALLOCSPY)1)
        // the handle used to indicate that the caller of the malloc spy function
        // doesn't actually own the spy
        
struct DebugHeader
{
        DWORD iAllocNum;
        SIZE_T cbAllocSize;
};

CMallocSpy* g_pSpy = NULL;




//===========================================================================
// Non-Member Functions
//===========================================================================

/*---------------------------------------------------------------------------
@func   HMALLOCSPY | InstallMallocSpy |
                Creates a new IMalloc spy and registers it with OLE.  The IMalloc spy
                will monitor calls to <om IMalloc::Alloc> and <om IMalloc::Free>.

@rdesc  Returns a handle to the spy or NULL if the spy couldn't be
                initialized.  The spy handle is used as the first argument to all
                other spy functions.

@comm   If this function succeeds, a matching call to <f UninstallMallocSpy>
                should eventually be made.  Set breakpoints on calls to
                <om IMalloc::Alloc> or <om IMalloc::Free> via <f SetMallocBreakpoint>.
                Detect leaks via <f DetectMallocLeaks>.

                Warning: When an IMalloc spy is installed, system performance may be
                seriously degraded.

@xref   <f UninstallMallocSpy> <f SetMallocBreakpoint> <f DetectMallocLeaks>
*/

STDAPI_(HMALLOCSPY) InstallMallocSpy(
DWORD dwFlags) // @parm [in]
        // Flags controlling the spy.  Presently only one flag is supported:
        // @flag        MALLOCSPY_NO_BLOCK_LIST |
        //                      If set, the spy won't maintain a list of unfreed blocks,
        //                      although it will always keep track of the total number of
        //                      unfreed blocks and bytes.  If this flag is set,
        //                      <f DetectMallocLeaks> will not display a list of unfreed
        //                      blocks.
{
        HMALLOCSPY hSpy;
        HRESULT hr = S_OK;
        IMallocSpy* pISpy;

        ::EnterCriticalSection(&g_criticalSection);

        // If a malloc spy already exists then it has been installed.  Don't
        // bother installing another one.

        if (g_pSpy != NULL)
        {
                hSpy = HMALLOCSPY_NOTOWNER;
                goto Exit;
        }

        // Otherwise, create and register a new malloc spy.

        g_pSpy = new CMallocSpy(dwFlags);
        if (g_pSpy == NULL)
        {
                goto ErrExit;
        }
        if (FAILED(g_pSpy->QueryInterface(IID_IMallocSpy, (void**)&pISpy)))
        {
                goto ErrExit;
        }
        if (FAILED(::CoRegisterMallocSpy(pISpy)))
        {
                goto ErrExit;
        }

        // Set the spy handle to the address of the global spy variable.

        hSpy = (HMALLOCSPY)g_pSpy;

Exit:

        ::LeaveCriticalSection(&g_criticalSection);
        return (hSpy);

ErrExit:
        
        ASSERT(FAILED(hr));
        if (g_pSpy != NULL)
        {
                g_pSpy->Release();
                g_pSpy = NULL;
        }
        hSpy = NULL;
        goto Exit;
}




/*---------------------------------------------------------------------------
@func   HRESULT | UninstallMallocSpy |
                Uninstalls a previously installed IMalloc spy.

@rvalue S_OK |
                The spy was successfully uninstalled.
@rvalue CO_E_OBJNOTREG |
                No spy is currently installed.
@rvalue E_ACCESSDENIED |
                A spy is installed but there are outstanding (i.e., not yet
                freed) allocations made while this spy was active.

@xref   <f InstallMallocSpy> <f SetMallocBreakpoint> <f DetectMallocLeaks>
*/

STDAPI UninstallMallocSpy(
HMALLOCSPY hSpy) // @parm [in]
        // The handle returned by a previous call to <f InstallMallocSpy>
{
        HRESULT hr;

        // If the spy handle doesn't match the global <g_pSpy> variable, the
        // caller doesn't own the spy and shouldn't be deleting it.

        if (hSpy != (HMALLOCSPY)g_pSpy)
        {
                hr = E_ACCESSDENIED;
                goto Exit;
        }

        // Otherwise, tell OLE to revoke the spy and delete the global spy
        // object.
        
        ::EnterCriticalSection(&g_criticalSection);
        hr = ::CoRevokeMallocSpy();
        g_pSpy->Release();
        g_pSpy = NULL;
        ::LeaveCriticalSection(&g_criticalSection);

Exit:

        return (hr);
}




/*---------------------------------------------------------------------------
@func   void | SetMallocBreakpoint |
                Instructs a previously installed IMalloc spy to generate a debug break
                on a particular allocation number or size.

@comm   Once a spy is installed, every call to <om IMalloc::Alloc> is
                monitored and assigned a 0-based "allocation number".  A debug break
                can be triggered based on this allocation number or on an allocation
                size.  The breakpoint can be made to occur either on the call to
                <om IMalloc::Alloc> or <om IMalloc::Free>.

@xref   <f InstallMallocSpy> <f UninstallMallocSpy> <f DetectMallocLeaks>
*/

STDAPI_(void) SetMallocBreakpoint(
HMALLOCSPY hSpy, // @parm [in]
        // The handle returned by a previous call to <f InstallMallocSpy>
ULONG iAllocNum, // @parm [in]
        // The allocation number to break on.  Allocations are numbered from 0.
        // If you want to specify an allocation break by size instead of number,
        // set <p iAllocNum> to -1.
SIZE_T cbAllocSize, // @parm [in]
        // The allocation size to break on.  If you want to specify an allocation
        // break by allocation number instead of size, set <p cbAllocSize> to
        // -1.
DWORD dwFlags) // @parm [in]
        // Whether to break when the block is allocate or freed.  If you don't
        // want to break at all, set <p dwFlags> to 0.  Otherwise, set it to
        // a combination of the following flags:
        // @flag        MALLOCSPY_BREAK_ON_ALLOC |
        //                      Break when the block with the given <p iAllocNum> or
        //                      <p cbAllocSize> is allocated.
        // @flag        MALLOCSPY_BREAK_ON_FREE |
        //                      Break when the block with the given <p iAllocNum> or
        //                      <p cbAllocSize> is allocated.
{
        // Ignore the spy handle, <hSpy>.  Anyone can set a malloc breakpoint so
        // long as the spy has been installed.
        
        if (g_pSpy)
        {
                g_pSpy->SetBreakpoint(iAllocNum, cbAllocSize, dwFlags);
        }
}


/*---------------------------------------------------------------------------
@func   BOOL | DetectMallocLeaks |
                Displays information regarding unfreed IMalloc allocations.

@rdesc  If leaks were detected.  Returns one of the following values:
@flag   TRUE |
                There is at least one as-yet-unfreed IMalloc allocation.
@flag   FALSE |
                There are no unfreed IMalloc allocations.

@comm   Always writes a message to the debug output window.

@xref   <f InstallMallocSpy> <f UninstallMallocSpy> <f SetMallocBreakpoint>
*/

STDAPI_(BOOL) DetectMallocLeaks(
HMALLOCSPY hSpy, // @parm [in]
        // The handle returned by a previous call to <f InstallMallocSpy>
ULONG* pcUnfreedBlocks, // @parm [out]
        // If non-NULL on entry, *<p pcUnfreedBlocks> is set to the number of
        // unfreed blocks allocated by calls to <om IMalloc::Alloc>.
SIZE_T* pcbUnfreedBytes, // @parm [out]
        // If non-NULL on entry, *<p pcbUnfreedBytes> is set to the total number
        // of unfreed bytes allocated by calls to <om IMalloc::Alloc>.
DWORD dwFlags) // @parm [in]
        // Flags controlling how the leak information is displayed.  A combination
        // of the following flags:
        // @flag        MALLOCSPY_NO_BLOCK_LIST |
        //                      Don't display a list of unfreed blocks.  If this flag isn't
        //                      set, the leak message will display up to the first 10
        //                      unfreed blocks, showing the allocation number and size for
        //                      each block.
        // @flag        MALLOCSPY_NO_MSG_BOX |
        //                      Don't display a message box.  If this flag isn't set, a message
        //                      box will be displayed if leaks were detected.
{
        BOOL fResult = FALSE;

        // Ignore the spy handle, <hSpy>.  Anyone can detect leaks so long as
        // the spy has been installed.
        
        if (g_pSpy)
        {
                fResult = g_pSpy->DetectLeaks(pcUnfreedBlocks, pcbUnfreedBytes,
                                                        dwFlags);
        }
        return (fResult);
}




//===========================================================================
// CMallocSpy
//===========================================================================

//---------------------------------------------------------------------------
// Create a new Malloc spy.  The spy has a reference count of 0.  Delete it
// by calling Release().
//---------------------------------------------------------------------------

CMallocSpy::CMallocSpy(
DWORD dwFlags)
{
        BOOL fMaintainUnfreedBlockList = ((dwFlags & MALLOCSPY_NO_BLOCK_LIST) == 0);

        if (fMaintainUnfreedBlockList)
        {
                m_pListUnfreedBlocks = new CSpyList;
        }
        m_fBreakOnAlloc = FALSE;
        m_fBreakOnFree = FALSE;
}


//---------------------------------------------------------------------------
// Destroy an existing Malloc spy.  Don't call this method directly -- use
// Release() instead.
//---------------------------------------------------------------------------

CMallocSpy::~CMallocSpy()
{
        delete m_pListUnfreedBlocks;
}


//---------------------------------------------------------------------------
// Set a breakpoint on an allocation or free.  See ::SetMallocBreakpoint,
// above for more information.
//---------------------------------------------------------------------------

void CMallocSpy::SetBreakpoint(
ULONG iAllocNum,
SIZE_T cbAllocSize,
DWORD dwFlags)
{
        EnterCriticalSection(&g_criticalSection);
        
        m_iAllocBreakNum = iAllocNum;
        m_cbAllocBreakSize = cbAllocSize;
        m_fBreakOnAlloc = ((dwFlags & MALLOCSPY_BREAK_ON_ALLOC) != 0);
        m_fBreakOnFree = ((dwFlags & MALLOCSPY_BREAK_ON_FREE) != 0);

        LeaveCriticalSection(&g_criticalSection);
}


//---------------------------------------------------------------------------
// Detect leaks.  See ::DetectMallocLeaks(), above, for more information.
//---------------------------------------------------------------------------

BOOL CMallocSpy::DetectLeaks(
ULONG* pcUnfreedBlocks,
SIZE_T* pcbUnfreedBytes,
DWORD dwFlags)
{
    char ach[1000];
        char* psz = ach;
        BOOL fShowUnfreedBlocks = ((dwFlags & MALLOCSPY_NO_BLOCK_LIST) == 0);
        BOOL fShowMsgBox = ((dwFlags & MALLOCSPY_NO_MSG_BOX) == 0);
        
    OutputDebugString("IMalloc leak detection: ");
    EnterCriticalSection(&g_criticalSection);

    // Return the number of unfreed blocks and unfreed bytes if the caller
    // wants them.

    if (pcUnfreedBlocks != NULL)
    {
        *pcUnfreedBlocks = m_cUnfreedBlocks;
    }
    if (pcbUnfreedBytes != NULL)
    {
        *pcbUnfreedBytes = m_cbUnfreedBytes;
    }

    // If there was unfreed memory...

    if ((m_cUnfreedBlocks != 0) || (m_cbUnfreedBytes != 0))
    {
        // Form a basic message describing the number of blocks and bytes
        // which were unfreed.

        psz += wsprintf(psz,
                                "%d unreleased blocks, %d unreleased bytes",
                                m_cUnfreedBlocks,
                                m_cbUnfreedBytes);

                // Append a list of the first 10 unfreed blocks to the basic
                // message.

                if (fShowUnfreedBlocks && (m_pListUnfreedBlocks != NULL))
                {
                        psz += wsprintf(psz, "\nUnfreed blocks: ");
                        psz += m_pListUnfreedBlocks->StreamTo(psz, 10);
                }
        LeaveCriticalSection(&g_criticalSection);

                // Display the message.
                
        OutputDebugString(ach);
        if (fShowMsgBox)
        {
                MessageBox(NULL, ach, "IMalloc Leak Detection",
                MB_ICONEXCLAMATION | MB_OK);
        }
    }

    // If there was no unfreed memory...

    else
    {
        LeaveCriticalSection(&g_criticalSection);
        OutputDebugString("(no leaks detected)");
    }

    OutputDebugString("\n");
    return (m_cUnfreedBlocks > 0);
}


//---------------------------------------------------------------------------
// Get an interface on the spy.
//---------------------------------------------------------------------------

STDMETHODIMP
CMallocSpy::QueryInterface(
REFIID riid,
void** ppvObject)
{
        *ppvObject = NULL;
        if (IsEqualIID(riid, IID_IUnknown))
        {
                *ppvObject = (IUnknown*)this;
        }
        else if (IsEqualIID(riid, IID_IMallocSpy))
        {
                *ppvObject = (IMallocSpy*)this;
        }
        else
        {
                return (E_NOINTERFACE);
        }

        AddRef();
        return (S_OK);
}


//---------------------------------------------------------------------------
// Increment a Malloc spy's reference count.
//---------------------------------------------------------------------------

STDMETHODIMP_(ULONG)    
CMallocSpy::AddRef()
{
        return (m_cRef++);
}


//---------------------------------------------------------------------------
// If a Malloc spy's reference count is 0, delete it. Otherwise, decrement
// the reference count, and delete the spy if the count is 0.
//---------------------------------------------------------------------------

STDMETHODIMP_(ULONG)    
CMallocSpy::Release()
{
        if (m_cRef > 0)
        {
                m_cRef--;
        }
        if (m_cRef == 0)
        {
                delete this;
                return (0);
        }
        return (m_cRef);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::Alloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(SIZE_T)    
CMallocSpy::PreAlloc(
SIZE_T cbRequest)
{
        // Break if we're breaking on allocations and either the allocation
        // number or size match what we're looking for.
        
        if ((m_fBreakOnAlloc) && ((m_iAllocBreakNum == m_iAllocNum) ||
                (m_cbAllocBreakSize == cbRequest)))
        {
                DebugBreak();
        }
        
        // Pass <cbRequest> to PostAlloc() via <m_cbRequest>.

        m_cbRequest = cbRequest;

        // Allocation additional space for the allocation number and size.

        return (cbRequest + sizeof(DebugHeader));
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::Alloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PostAlloc(
void* pActual)
{
        DebugHeader* pHeader = (DebugHeader*)pActual;

        // Write the allocation number and size at the start of the block.

        pHeader->iAllocNum = m_iAllocNum;
        pHeader->cbAllocSize = m_cbRequest;

        // Adjust the allocation counters.

        m_cUnfreedBlocks++;
        m_cbUnfreedBytes += m_cbRequest;

        // Add the block to the list of unfreed blocks.

        if (m_pListUnfreedBlocks != NULL)
        {
                m_pListUnfreedBlocks->Add(pHeader->iAllocNum, pHeader->cbAllocSize);
        }

        // Increment the allocation number.

        m_iAllocNum++;
        return (pHeader + 1);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::Free().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PreFree(
void* pRequest,
BOOL fSpyed)
{
        if (fSpyed)
        {
                DebugHeader* pHeader = (DebugHeader*)pRequest - 1;

                // Break if we're breaking on allocations and either the allocation
                // number or size match what we're looking for.

                if ((m_fBreakOnFree) && ((pHeader->iAllocNum == m_iAllocBreakNum) ||
                        (pHeader->cbAllocSize == m_cbAllocBreakSize)))
                {
                        DebugBreak();
                }

                // Otherwise, decrement the unfreed block count and unfreed byte counts,
                // and remove the block from the list of unfreed blocks.
                
                m_cUnfreedBlocks--;
                m_cbUnfreedBytes -= pHeader->cbAllocSize;
                if (m_pListUnfreedBlocks != NULL)
                {
                        m_pListUnfreedBlocks->Remove(pHeader->iAllocNum);
                }
                return (pHeader);
        }
        return (pRequest);
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::Free().
//---------------------------------------------------------------------------

STDMETHODIMP_(void)             
CMallocSpy::PostFree(
BOOL fSpyed)
{
        // nothing to do
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::Realloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(SIZE_T)    
CMallocSpy::PreRealloc(
void* pRequest,
SIZE_T cbRequest,
void** ppNewRequest,
BOOL fSpyed)
{
        if (fSpyed)
        {
                DebugHeader* pHeader = (DebugHeader*)pRequest - 1;
                PreFree(pRequest, fSpyed);
                PreAlloc(cbRequest);
                *ppNewRequest = pHeader;
                return (cbRequest + sizeof(DebugHeader));
        }
        *ppNewRequest = pRequest;
        return (cbRequest);
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::Realloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PostRealloc(
void* pActual,
BOOL fSpyed)
{
        if (fSpyed)
        {
                return (PostAlloc(pActual));
        }
        return (pActual);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::GetSize().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PreGetSize(
void* pRequest,
BOOL fSpyed)
{
        if (fSpyed)
        {
                DebugHeader* pHeader = (DebugHeader*)pRequest - 1;
                return (pHeader);
        }
        return (pRequest);
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::GetSize().
//---------------------------------------------------------------------------

STDMETHODIMP_(SIZE_T)    
CMallocSpy::PostGetSize(
SIZE_T cbActual,
BOOL fSpyed)
{
        if (fSpyed)
        {
                return (cbActual - sizeof(DebugHeader));
        }
        return (cbActual);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::DidAlloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PreDidAlloc(
void* pRequest,
BOOL fSpyed)
{
        if (fSpyed)
        {
                DebugHeader* pHeader = (DebugHeader*)pRequest - 1;
                return (pHeader);
        }
        return (pRequest);
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::DidAlloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(int)              
CMallocSpy::PostDidAlloc(
void* pRequest,
BOOL fSpyed,
int fActual)
{
        return (fActual);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::HeapMinimize().
//---------------------------------------------------------------------------

STDMETHODIMP_(void)             
CMallocSpy::PreHeapMinimize()
{
        // nothing to do
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::HeapMinimize().
//---------------------------------------------------------------------------

STDMETHODIMP_(void)             
CMallocSpy::PostHeapMinimize()
{
        // nothing to do
}




//===========================================================================
// CSpyList
//===========================================================================

void* CSpyList::operator new(
size_t stSize)
{
        HGLOBAL h = GlobalAlloc(GHND, stSize);
        return (GlobalLock(h));
}


void CSpyList::operator delete(
void* pNodeList,
size_t stSize)
{
        ASSERT(stSize == sizeof(CSpyList));
    HGLOBAL h = (HGLOBAL)GlobalHandle(pNodeList);
    GlobalUnlock(h);
    GlobalFree(h);
}


CSpyList::CSpyList()
{
        m_pHead = new CSpyListNode(0, 0);
        m_pHead->m_pNext = m_pHead->m_pPrev = m_pHead;
}


CSpyList::~CSpyList()
{
        CSpyListNode* pNode1;
        CSpyListNode* pNode2;

        pNode1 = m_pHead->m_pNext;
        while (pNode1 != m_pHead)
        {
                pNode2 = pNode1->m_pNext;
                delete pNode1;
                pNode1 = pNode2;
        }
        delete m_pHead;
}


void CSpyList::Add(
ULONG iAllocNum,
SIZE_T cbSize)
{
        CSpyListNode* pNode = new CSpyListNode(iAllocNum, cbSize);
        pNode->m_pNext = m_pHead->m_pNext;
        pNode->m_pPrev = m_pHead;
        m_pHead->m_pNext->m_pPrev = pNode;
        m_pHead->m_pNext = pNode;
        m_cNodes++;
}


void CSpyList::Remove(
ULONG iAllocNum)
{
        CSpyListNode* pNode;

        for (pNode = m_pHead->m_pNext;
                 pNode != m_pHead;
                 pNode = pNode->m_pNext)
        {
                if (pNode->m_iAllocNum == iAllocNum)
                {
                        pNode->m_pPrev->m_pNext = pNode->m_pNext;
                        pNode->m_pNext->m_pPrev = pNode->m_pPrev;
                        delete pNode;
                        m_cNodes--;
                        return;
                }
        }
}


ULONG CSpyList::GetSize()
{
        return (m_cNodes);
}


int CSpyList::StreamTo(
LPTSTR psz,
ULONG cMaxNodes)
{
        CSpyListNode* pNode;
        ULONG iNode;
        LPTSTR pszNext = psz;

        for (iNode = 0, pNode = m_pHead->m_pPrev;
                 (iNode < cMaxNodes) && (pNode != m_pHead);
                 iNode++, pNode = pNode->m_pPrev)
        {
                pszNext += wsprintf(pszNext, _T("%s#%lu=%lu"),
                                                        (iNode > 0) ? _T(", ") : _T(""),
                                                        pNode->m_iAllocNum, pNode->m_cbSize);
        }

        if (pNode != m_pHead)
        {
                pszNext += wsprintf(pszNext, _T("%s%s"),
                                        (iNode > 0) ? _T(",") : _T(""),
                                        _T(" ..."));
        }

        return (int) (pszNext - psz);
}




//===========================================================================
// CSpyListNode
//===========================================================================

void* CSpyListNode::operator new(
size_t stSize)
{
        HGLOBAL h = GlobalAlloc(GHND, stSize);
        return (GlobalLock(h));
}


void CSpyListNode::operator delete(
void* pNode,
size_t stSize)
{
        ASSERT(stSize == sizeof(CSpyListNode));
    HGLOBAL h = (HGLOBAL)GlobalHandle(pNode);
    GlobalUnlock(h);
    GlobalFree(h);
}


CSpyListNode::CSpyListNode(
ULONG iAllocNum,
SIZE_T cbSize)
{
        m_iAllocNum = iAllocNum;
        m_cbSize = cbSize;
}


CSpyListNode::~CSpyListNode()
{
        // nothing to do
}
#endif      // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\allocspy.h ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		AllocSpy.h
//				
// Description:	This module contains the declarations for the classes
//				CSpyList, and CSpyListNode.
//===========================================================================

#ifndef _ALLOCSPY_H_
#define _ALLOCSPY_H_




//---------------------------------------------------------------------------
// Forward Declarations
//---------------------------------------------------------------------------

class CSpyList;
class CSpyListNode;




//---------------------------------------------------------------------------
// Class:		CMallocSpy
//
// Description:	(tbd)
//---------------------------------------------------------------------------

class CMallocSpy : IMallocSpy
{
//
// Friends
//

	// (none)


//
// Class Features
//

	// (none)


//
// Instance Features
//

public:

	// creating

	CMallocSpy(DWORD dwFlags);

	// setting allocation breakpoints

	void SetBreakpoint(ULONG iAllocNum, SIZE_T cbSize, DWORD dwFlags);
		
	// detecting leaks

	BOOL DetectLeaks(ULONG* pcUnfreedBlocks, SIZE_T* pcbUnfreedBytes, 
		DWORD dwFlags);

	// IUnknown methods

	STDMETHODIMP QueryInterface(REFIID riid, void** ppvObject);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();        

	// IMallocSpy methods

	STDMETHODIMP_(SIZE_T) PreAlloc(SIZE_T cbRequest);
	STDMETHODIMP_(void*) PostAlloc(void* pActual);
    STDMETHODIMP_(void*) PreFree(void* pRequest, BOOL fSpyed);
    STDMETHODIMP_(void) PostFree(BOOL fSpyed);
    STDMETHODIMP_(SIZE_T) PreRealloc(void* pRequest, SIZE_T cbRequest, 
    	void** ppNewRequest, BOOL fSpyed);
    STDMETHODIMP_(void*) PostRealloc(void* pActual, BOOL fSpyed);
    STDMETHODIMP_(void*) PreGetSize(void* pRequest, BOOL fSpyed);
    STDMETHODIMP_(SIZE_T) PostGetSize( SIZE_T, BOOL fSpyed);
    STDMETHODIMP_(void*) PreDidAlloc(void* pRequest, BOOL fSpyed);
    STDMETHODIMP_(int) PostDidAlloc(void* pRequest, BOOL fSpyed, int fActual);
    STDMETHODIMP_(void) PreHeapMinimize();
    STDMETHODIMP_(void) PostHeapMinimize();

private:

	// private methods

	~CMallocSpy();

	// private variables -- controlling debug breaks

	BOOL m_fBreakOnAlloc;
		// if TRUE, the malloc spy will cause a debug break on allocations when 
		// the allocation number or size match
	BOOL m_fBreakOnFree;
		// if TRUE, the malloc spy will cause a debug break on frees when the
		// allocation number or size match
	ULONG m_iAllocBreakNum;
		// the allocation number to break on
	SIZE_T m_cbAllocBreakSize;
		// the allocation size to break on
		
	// private variables -- tracking unfreed blocks and bytes

	ULONG m_cUnfreedBlocks;
		// the number of not-yet-freed blocks
	SIZE_T m_cbUnfreedBytes;
		// the number of not-yet-freed bytes
	CSpyList* m_pListUnfreedBlocks;
		// a list of unfreed blocks
	ULONG m_iAllocNum;
		// the sequential allocation number

	// private variables -- passing info between pre's and post's

	SIZE_T m_cbRequest;
		// the number of bytes requested in the last call to PreAlloc(); used
		// to pass information between PreAlloc() and PostAlloc()
	void* m_pRequest;
		// the block currently being freed; used to pass information between
		// PreFree() and PostFree()

	// private variables -- misc

	ULONG m_cRef;
		// reference count

};




//---------------------------------------------------------------------------
// Class:		CSpyList
//
// Description:	A circular-linked, doubly-linked list of CSpyListNodes.  An 
//				empty spy list has a single head node, linked to itself.
//				A spy list contains one node for every as-yes-unfreed OLE
//				allocation.  Add() adds a new node to the front of the list.
//				Remove() removes an existing node (identified by its
//				allocation number) from the list.  GetSize() returns the
//				number of nodes in the list.  StreamTo() writes a textual
//				representation of the list to a string.
//---------------------------------------------------------------------------

class CSpyList
{
//
// Class Features
//

public:

	void*	operator new(size_t stSize);
	void	operator delete(void* pNodeList, size_t stSize);

//
// Instance Features
//

public:

	// creating and destroying

	CSpyList();
	~CSpyList();

	// adding and removing entries

	void	Add(ULONG iAllocNum, SIZE_T cbSize);
	void	Remove(ULONG iAllocNum);

	// counting the number of entries

	ULONG	GetSize();

	// streaming out

	int		StreamTo(LPTSTR psz, ULONG cMaxNodes);

private:

	ULONG m_cNodes;
		// the number of nodes in the list
	CSpyListNode* m_pHead;
		// the head node
};




//---------------------------------------------------------------------------
// Class:		CSpyListNode
//
// Description:	A node in a CSpyList.  Each CSpyListNode represents an
//				as-yet-unfreed OLE allocation.
//---------------------------------------------------------------------------

class CSpyListNode
{
//
// Friends
//

	friend class CSpyList;

//
// Class Features
//

public:

	void*	operator new(size_t stSize);
	void	operator delete(void* pNode, size_t stSize);

//
// Instance Features
//

public:

	CSpyListNode(ULONG iAllocNum, SIZE_T cbSize);
	~CSpyListNode();

private:

	// private variables

	SIZE_T m_cbSize;
		// the size of the allocation
	ULONG m_iAllocNum;
		// the allocation's number
	CSpyListNode* m_pNext;
		// a pointer to the next node in the list
	CSpyListNode* m_pPrev;
		// a pointer to the previous node in the list
};




#endif // _ALLOCSPY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\aph.cpp ===
// aph.cpp
//
// Implements AllocPropertyHelper.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// PropertyHelper
//


/* @object PropertyHelper |

        Provides an implementation of <i Persist>, <i IPersistPropertyBag>,
        <i IPersistStream>, <i IPersistStreamInit>, and a simplified
        implementation of <i IDispatch>, for any object which implements
        <i IPersistVariantIO>.

@supint <i IPersistPropertyBag> | Loads or saves properties from/to a given
        <i IPropertyBag> object.  Used to provide a textual representation of
        the data of the object that implements <i IPersistVariantIO>.

@supint <i IPersistStream> | Loads or saves the data of the object that
        implements <i IPersistVariantIO> as a stream of bytes.

@supint <i IPersistStreamInit> | Like <i IPersistStream>, but with an extra
        method that allows the object to be created in a "newly initialized"
        state.

@supint <i IDispatch> | Provides script engines etc. access to the properties
        exposed by the <i IPersistVariantIO>.  This <i IDispatch>
        implementation isn't particularly fast, but it's an inexpensive way
        for a control to provide a rudimentary <i IDispatch> implementation.

@comm   Use <f AllocPropertyHelper> to create a <o PropertyHelper> object.

*/

/* @interface IPersistVariantIO |

        Loads or saves properties from/to a given <i IVariantIO> object
        (control).  Used by <o PropertyHelper> to help an object implement
        <i IPersistpropertyBag>, <i IPersistStream>, <i IPersistStreamInit>,
        and a simplified implementation of <i IDispatch>, for any object which
        implements <i IPersistVariantIO>.

@meth   HRESULT | InitNew | Informs the control that it has been created
        in a "new" state, so it should initialize its state data (if not
        done already).  If the control is being loaded from a stream,
        <om .DoPersist> will be called instead of <om .InitNew>.

@meth   HRESULT | IsDirty | Returns S_OK if the object has changed since it
        was last saved, S_FALSE otherwise.

@meth   HRESULT | DoPersist | Instructs the object to load or save its
        properties to a gieven <i IVariantIO> object.
*/

/* @method HRESULT | IPersistVariantIO | InitNew |

        Informs the control that it has been created in a "new" state, so it
        should initialize its state data (if not done already).  If the
        control is being loaded from a stream, <om .DoPersist> will be called
        instead of <om .InitNew>.

@rvalue S_OK | Success.

@rvalue E_NOTIMPL | The control does not implement this method.

@comm   The control can safely return E_NOTIMPL from this method if it
        initializes its data when it is created.  In this case, if the control
        needs to be re-initialized, the container will simply destroy and
        re-create it (which is what almost every container does anyway).
*/

/* @method HRESULT | IPersistVariantIO | IsDirty |

        Returns S_OK if the object has changed since it was last saved,
        S_FALSE otherwise.

@rvalue S_OK | The object has changed since it was last saved.

@rvalue S_FALSE | The object has not changed since it was last saved.

@comm   The control should maintain an internal "dirty flag" (e.g. a BOOL
        <p m_fDirty> class member), which should be initialized to FALSE,
        but set to TRUE whenever the control's data changes and set to
        FALSE in <om .DoPersist> when the PVIO_CLEARDIRTY flag is specified.

@ex     The following example shows how a control might implement
        <om .IsDirty> |

        STDMETHODIMP CMyControl::IsDirty()
        {
            return (m_fDirty ? S_OK : S_FALSE);
        }
*/

/* @method HRESULT | IPersistVariantIO | DoPersist |

        Instructs the object to load or save its properties to a gieven
        <i IVariantIO> object.

@parm   IVariantIO * | pvio | <i IVariantIO> object to save to or load from.

@parm   DWORD | dwFlags | May contain the following flags:

        @rdesc  Must return either S_OK or an error code.  Don't return S_FALSE!

        @flag   PVIO_PROPNAMESONLY | The caller is calling <om .DoPersist>
                purely to get a list of the names of properties from the
                control.  The control can safely ignore this flag, unless
                it wishes to use this information for optimization purposes.

        @flag   PVIO_CLEARDIRTY | The control should clear its dirty flag
                (so that the next call to <om .IsDirty> should return S_FALSE).

        @flag   PVIO_NOKIDS | The control need not persist any child controls that
		        it may contain.  For example, this flag is used by the property
				helper object when it calls DoPersist inside its
				IDispatch::GetIDsOfNames and IDispatch::Invoke.

        @flag   PVIO_RUNTIME | The control should save a runtime version of
                itself.  For example, this flag is used by the active designer
                helper object when <om IActiveDesigner.SaveRuntimeState> is
                called on the object.

@ex     The following example shows how a control might implement
        <om .DoPersist>.  Note that DoPersist must return S_OK on success. |

        STDMETHODIMP CMyControl::DoPersist(IVariantIO* pvio, DWORD dwFlags)
        {
            // load or save control properties to/from <info>
            HRESULT hr;
            if (FAILED(hr = pvio->Persist(0,
                    "BorderWidth", VT_INT, &m_iWidth,
                    "BorderColor", VT_INT, &m_rgb,
                    "X1", VT_INT, &m_iX1,
                    "Y1", VT_INT, &m_iY1,
                    "X2", VT_INT, &m_iX2,
                    "Y2", VT_INT, &m_iY2,
                    NULL)))
                return hr;
            if (hr == S_OK)
                ...one or more properties changed, so repaint etc. control...

            // clear the dirty bit if requested
            if (dwFlags & PVIO_CLEARDIRTY)
                m_fDirty = FALSE;

			// Important!  Don't return hr here, which may have been set to
			//             S_FALSE by IVariantIO::Persist.
            return S_OK;
        }

@ex     The following example shows how a control which supports <i IActiveDesigner>
        might implement <om .DoPersist>. |

        STDMETHODIMP CMyControl::DoPersist(IVariantIO* pvio, DWORD dwFlags)
        {
            // load or save runtime properties to/from <info>
            HRESULT hr;
            if (FAILED(hr = pvio->Persist(0,
                    "BorderWidth", VT_INT, &m_iWidth,
                    "BorderColor", VT_INT, &m_rgb,
                    "X1", VT_INT, &m_iX1,
                    "Y1", VT_INT, &m_iY1,
                    "X2", VT_INT, &m_iX2,
                    "Y2", VT_INT, &m_iY2,
                    NULL)))
                return hr;
            if (hr == S_OK)
                ...one or more properties changed, so repaint etc. control...

            // load or save design-time properties to/from <info>
        #ifdef _DESIGN
            if (!(dwFlags & PVIO_RUNTIME))
            {
                if (FAILED(hr = pvio->Persist(0,
                        "SomeDesignValue", VT_INT, &m_iSomeDesignValue,
                        NULL)))
                    return hr;
            }
        #endif

            // clear the dirty bit if requested
            if (dwFlags & PVIO_CLEARDIRTY)
                m_fDirty = FALSE;

			// Important!  Don't return hr here, which may have been set to
			//             S_FALSE by IVariantIO::Persist.
            return S_OK;
        }
*/

struct CPropertyHelper : INonDelegatingUnknown, IPersistStreamInit,
    IPersistPropertyBag, IDispatch
{
///// general object state
    IPersistVariantIO *m_ppvio;     // to access properties of parent
    CLSID           m_clsid;        // the class ID of the parent

///// non-delegating IUnknown implementation
    ULONG           m_cRef;         // object reference count
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

///// delegating IUnknown implementation
    LPUNKNOWN       m_punkOuter;    // controlling unknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

///// IPersist methods
    STDMETHODIMP GetClassID(CLSID* pClassID);

///// IPersistStream methods
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pstream);
    STDMETHODIMP Save(IStream* pstream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

///// IPersistStreamInit methods
    STDMETHODIMP InitNew();

///// IPersistPropertyBag methods
    // STDMETHODIMP InitNew(); // already provided by IPersistStream
    STDMETHODIMP Load(IPropertyBag* ppb, IErrorLog* pErrorLog);
    STDMETHODIMP Save(IPropertyBag* ppb, BOOL fClearDirty,
        BOOL fSaveAllProperties);

///// IDispatch implementation
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
};


//////////////////////////////////////////////////////////////////////////////
// PropertyHelper Construction
//

/* @func HRESULT | AllocPropertyHelper |

        Allocates a <o PropertyHelper> object which provides an implementation
        of <i IPersist>, <i IPersistPropertyBag>, <i IPersistStream>,
        <i IPersistStreamInit>, and a simplified implementation of
        <i IDispatch>, for any object which implements <i IPersistVariantIO>.

@parm   LPUNKNOWN | punkOuter | The <i IUnknown> of the parent object
        object (presumably the same object that implements
        <i IPersistVariantIO>).  Will be used as the controlling unknown of
        <o PropertyHelper>.

@parm   IPersistVariantIO * | ppvio | The interface used to access the
        properties of the parent object.  Note that this interface is
        <y not> <f AddRef>d by <f AllocPropertyHelper>, since doing so
        would likely cause a circular reference count.  Therefore it is
        the caller's responsibility to ensure that <p ppvio> remain valid
        for the lifetime of the <o PropertyHelper> object.

@parm   REFCLSID | rclsid | The class of the containing object (the object
        which implements <i IPersistVariantIO>).

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@parm   LPUNKNOWN * | ppunk | Where to store a pointer to the non-delegating
        <i IUnknown> of the allocated <o PropertyHelper> object.  NULL is
        stored in *<p ppunk> on error.

@comm   See <o PropertyHelper> for more information.

@ex     The following example shows how a control might use
        <f AllocPropertyHelper>.  This example control is aggregatable, though
        the control need not be aggregatable to use <f AllocPropertyHelper>. |

        // control implementation
        class CMyControl : public INonDelegatingUnknown, public IOleControl,
            public IPersistVariantIO ...
        {

        ///// general control state
        protected:
            BOOL            m_fDirty;       // TRUE iff control needs saving
            IUnknown *      m_punkPropHelp; // aggregated PropertyHelper object
            ...

        ///// construction, destruction
        public:
            CMyControl(IUnknown *punkOuter, HRESULT *phr);
            virtual ~CMyControl();

        ///// non-delegating IUnknown implementation
        protected:
            ULONG           m_cRef;         // object reference count
            STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
            STDMETHODIMP_(ULONG) NonDelegatingAddRef();
            STDMETHODIMP_(ULONG) NonDelegatingRelease();

        ///// delegating IUnknown implementation
        protected:
            LPUNKNOWN       m_punkOuter;    // controlling unknown
            STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
              { return m_punkOuter->QueryInterface(riid, ppv); }
            STDMETHODIMP_(ULONG) AddRef()
              { return m_punkOuter->AddRef(); }
            STDMETHODIMP_(ULONG) Release()
              { return m_punkOuter->Release(); }

        ///// IOleControl implementation
        protected:
            STDMETHODIMP GetControlInfo(LPCONTROLINFO pCI);
            STDMETHODIMP OnMnemonic(LPMSG pMsg);
            STDMETHODIMP OnAmbientPropertyChange(DISPID dispid);
            STDMETHODIMP FreezeEvents(BOOL bFreeze);

        ///// IPersistVariantIO implementation
        protected:
            STDMETHODIMP InitNew();
            STDMETHODIMP IsDirty();
            STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);

        ...
        };

        CMyControl::CMyControl(IUnknown *punkOuter, HRESULT *phr)
        {
            // initialize IUnknown state
            m_cRef = 1;
            m_punkOuter = (punkOuter == NULL ?
                (IUnknown *) (INonDelegatingUnknown *) this : punkOuter);

            // set the control's default properties
            ...

            // allocate a PropertyHelper object (to be aggregated with this
            // object) to implement persistence and properties
            if (FAILED(*phr = AllocPropertyHelper(m_punkOuter, this,
                    CLSID_CMyControl, 0, &m_punkPropHelp)))
                return;

            // other initialization
            ...

            *phr = S_OK;
        }

        CMyControl::~CMyControl()
        {
            // clean up
            if (m_punkPropHelp != NULL)
                m_punkPropHelp->Release();
            ...
        }

        STDMETHODIMP CMyControl::NonDelegatingQueryInterface(REFIID riid,
            LPVOID *ppv)
        {
            *ppv = NULL;
            if (IsEqualIID(riid, IID_IUnknown))
                *ppv = (IUnknown *) (INonDelegatingUnknown *) this;
            else
            if (IsEqualIID(riid, IID_IOleControl))
                *ppv = (IOleControl *) this;
            else
            ...
            else
                return m_punkPropHelp->QueryInterface(riid, ppv);

            ((IUnknown *) *ppv)->AddRef();
            return S_OK;
        }
*/
STDAPI AllocPropertyHelper(IUnknown *punkOuter, IPersistVariantIO *ppvio,
    REFCLSID rclsid, DWORD dwFlags, IUnknown **ppunk)
{
    HRESULT         hrReturn = S_OK; // function return code
    CPropertyHelper *pthis = NULL;  // allocated object

    // set <pthis> to point to new object instance
    if ((pthis = New CPropertyHelper) == NULL)
        goto ERR_OUTOFMEMORY;
    TRACE("CPropertyHelper 0x%08lx created\n", pthis);

    // initialize IUnknown state
    pthis->m_cRef = 1;
    pthis->m_punkOuter = (punkOuter == NULL ?
        (IUnknown *) (INonDelegatingUnknown *) pthis : punkOuter);

    // other initialization
    pthis->m_ppvio = ppvio; // not AddRef'd -- see above
    pthis->m_clsid = rclsid;

    // return a pointer to the non-delegating IUnknown implementation
    *ppunk = (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    if (pthis != NULL)
        Delete pthis;
    *ppunk = NULL;
    goto EXIT;

EXIT:

    // normal cleanup
    // (nothing to do)

    return hrReturn;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CPropertyHelper::NonDelegatingQueryInterface(REFIID riid,
    LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    // char ach[200];
    // TRACE("PropertyHelper::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (IUnknown *) (INonDelegatingUnknown *) this;
    else
    if (IsEqualIID(riid, IID_IPersist) ||
        IsEqualIID(riid, IID_IPersistPropertyBag))
        *ppv = (IPersistPropertyBag *) this;
    else
    if (IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit))
        *ppv = (IPersistStreamInit *) this;
    else
    if (IsEqualIID(riid, IID_IDispatch))
        *ppv = (IDispatch *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CPropertyHelper::NonDelegatingAddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPropertyHelper::NonDelegatingRelease()
{
    if (--m_cRef == 0L)
    {
        // free the object
        TRACE("CPropertyHelper 0x%08lx destroyed\n", this);
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


//////////////////////////////////////////////////////////////////////////////
// IPersist Implementation
//
STDMETHODIMP CPropertyHelper::GetClassID(CLSID* pClassID)
{
    *pClassID = m_clsid;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistStream Implementation
//

STDMETHODIMP CPropertyHelper::IsDirty()
{
    return m_ppvio->IsDirty();
}

STDMETHODIMP CPropertyHelper::Load(IStream* pstream)
{
    HRESULT         hrReturn = S_OK; // function return code
    IPropertyBag *  ppb = NULL;     // acceses the properties in <pstream>

    // allocate <ppb> to read properties from <pstream>
    if (FAILED(hrReturn = AllocPropertyBagOnStream(pstream, 0, &ppb)))
        goto ERR_EXIT;

    // tell the control to read properties from <ppb>
    if (FAILED(hrReturn = Load(ppb, NULL)))
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (ppb!= NULL)
        ppb->Release();

    return hrReturn;
}

STDMETHODIMP CPropertyHelper::Save(IStream* pstream, BOOL fClearDirty)
{
    HRESULT         hrReturn = S_OK; // function return code
    IPropertyBag *  ppb = NULL;     // acceses the properties in <pstream>

    // allocate <ppb> to write properties to <pstream>
    if (FAILED(hrReturn = AllocPropertyBagOnStream(pstream, 0, &ppb)))
        goto ERR_EXIT;

    // tell the control to write properties to <ppb>
    if (FAILED(hrReturn = Save(ppb, fClearDirty, TRUE)))
        goto ERR_EXIT;

 	// write out end of file marker
	if (FAILED(hrReturn = WriteVariantProperty(pstream, NULL, 0)))
		goto ERR_EXIT;

   goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (ppb!= NULL)
        ppb->Release();

    return hrReturn;
}

STDMETHODIMP CPropertyHelper::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInit Implementation
//
STDMETHODIMP CPropertyHelper::InitNew()
{
    return m_ppvio->InitNew();
}


//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBag Implementation
//

STDMETHODIMP CPropertyHelper::Load(IPropertyBag* ppb,
    IErrorLog* pErrorLog)
{
    HRESULT         hrReturn = S_OK; // function return code
    IManageVariantIO *pmvio = NULL; // to save properties to (to get names)

    if (FAILED(hrReturn = AllocVariantIOOnPropertyBag(ppb, &pmvio)))
        goto ERR_EXIT;

    // instruct the parent object to load its properties from <pmvio>
    if (FAILED(hrReturn = pmvio->SetMode(VIO_ISLOADING)))
        goto ERR_EXIT;
    if (FAILED(hrReturn = m_ppvio->DoPersist(pmvio, PVIO_CLEARDIRTY)))
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (pmvio != NULL)
        pmvio->Release();

    return hrReturn;
}

STDMETHODIMP CPropertyHelper::Save(IPropertyBag* ppb, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    HRESULT         hrReturn = S_OK; // function return code
    IManageVariantIO *pmvio = NULL; // to save properties to (to get names)

    if (FAILED(hrReturn = AllocVariantIOOnPropertyBag(ppb, &pmvio)))
        goto ERR_EXIT;

    // instruct the parent object to load its properties from <pmvio>
    ASSERT(pmvio->IsLoading() == S_FALSE);
    if (FAILED(hrReturn = m_ppvio->DoPersist(pmvio,
            (fClearDirty ? PVIO_CLEARDIRTY : 0))))
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (pmvio != NULL)
        pmvio->Release();

    return hrReturn;
}


//////////////////////////////////////////////////////////////////////////////
// IDispatch Implementation
//

STDMETHODIMP CPropertyHelper::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 0;
    return S_OK;
}

STDMETHODIMP CPropertyHelper::GetTypeInfo(UINT itinfo, LCID lcid,
    ITypeInfo **pptinfo)
{
    return DISP_E_BADINDEX;
}

STDMETHODIMP CPropertyHelper::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{
    HRESULT         hrReturn = S_OK; // function return code
    IVariantIO *    pvio = NULL;    // used to ask parent to enum. prop. names
    DISPID          dispid;         // ID corresponding to <rgszNames[0]>
    DISPID *        pdispid;        // pointer into <rgdispid>
    UINT            cdispid;        // count of unprocessed <pdispid> items
    char            achPropName[_MAX_PATH]; // ANSI version of <rgszNames[0]>

    // nothing to do if there are no names to convert to IDs
    if (cNames == 0)
        goto EXIT;

    // allocate <pvio> to be a special IVariantIO implementation which
    // doesn't implement persistence at all, but instead sets <dispid>
    // to the ID of the property named <rgszNames[0]> when the parent
    // tries to persist that property using <pvio>
    dispid = -1;
    UNICODEToANSI(achPropName, rgszNames[0], sizeof(achPropName));
    if (FAILED(hrReturn = AllocVariantIOToMapDISPID(achPropName,
            &dispid, NULL, 0, &pvio)))
        goto ERR_EXIT;

    // tell the parent object to "save" its properties to <pvio>;
    // this should set <dispid> as described above; if property
    // <rgszNames[0]> is not found, <dispid> will remain -1
    if (FAILED(hrReturn = m_ppvio->DoPersist(pvio, PVIO_PROPNAMESONLY | PVIO_NOKIDS)))
        goto ERR_EXIT;

    // set rgdispid[0] to the DISPID of the property/method name
    // or to -1 if the name is unknown
    *rgdispid = dispid;

    // fill the other elements of the <rgdispid> array with -1 values,
    // because we don't support named arguments
    for (pdispid = rgdispid + 1, cdispid = cNames - 1;
         cdispid > 0;
         cdispid--, pdispid++)
        *pdispid = -1;

    // if any names were unknown, return DISP_E_UNKNOWNNAME
    if ((*rgdispid == -1) || (cNames > 1))
        goto ERR_UNKNOWNNAME;
    
    goto EXIT;

ERR_UNKNOWNNAME:

    hrReturn = DISP_E_UNKNOWNNAME;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (pvio != NULL)
        pvio->Release();

    return hrReturn;
}

STDMETHODIMP CPropertyHelper::Invoke(DISPID dispidMember, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT         hrReturn = S_OK; // function return code
    IVariantIO *    pvio = NULL;    // used to ask parent to enum. prop. names
    char            achPropName[_MAX_PATH]; // <dispidMember> prop. name
    DWORD           dwFlags;
    VARIANT *       pvar;

    // set <dwFlags> and <pvar> to values to pass to AllocVariantIOToMapDISPID
    if (wFlags & DISPATCH_PROPERTYGET)
    {
        dwFlags = VIOTMD_GETPROP;
        pvar = pvarResult;
    }
    else
    if (wFlags & DISPATCH_PROPERTYPUT)
    {
        dwFlags = VIOTMD_PUTPROP;
        pvar = pdispparams->rgvarg;
    }
    else
        goto ERR_MEMBERNOTFOUND;

    // allocate <pvio> to be a special IVariantIO implementation which
    // gets or sets the value of the property associated with
    // <dispidMember> to/from <var> when the parent tries to persist that
    // property using <pvio>
    achPropName[0] = 0;
    if (FAILED(hrReturn = AllocVariantIOToMapDISPID(achPropName,
            &dispidMember, pvar, dwFlags, &pvio)))
        goto ERR_EXIT;

    // tell the parent object to "save" its properties to <pvio>;
    // this should set <achPropName> as described above; if property
    // <dispidMember> is not found, <achPropName> will remain ""
    if (FAILED(hrReturn = m_ppvio->DoPersist(pvio, PVIO_NOKIDS)))
        goto ERR_EXIT;
    if (achPropName[0] == 0)
        goto ERR_MEMBERNOTFOUND;

    goto EXIT;

ERR_MEMBERNOTFOUND:

    hrReturn = DISP_E_MEMBERNOTFOUND;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (pvio != NULL)
        pvio->Release();

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\avioopb.cpp ===
// avioopb.cpp
//
// Implements AllocVariantIOOnPropertyBag.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// VariantIOOnPropertyBag
//

/* @object VariantIOOnPropertyBag |

        Provides an implementation of <i IVariantIO> (and <i IManageVariantIO>)
        that operates on a given <i IPropertyBag>.

@supint <i IVariantIO> | An alternative to <i IPropertyBag> which allows the
        caller to implement property-based persistence with less code.

@supint <i IManageVariantIO> | Based on <i IVariantIO>.  Allows the caller to
        control how the methods of <i IVariantIO> operate (e.g. whether the
        <i IVariantIO> is in loading mode or saving mode).  Note that
        <o VariantIOOnPropertyBag> does not implement
        <om IManageVariantIO.DeleteAllProperties>.

@supint <i IPropertyBag> | Provides access to the same <i IPropertyBag>
        object that was given to <f AllocVariantIOOnPropertyBag> as
        the <i IPropertyBag> to operate on.

@comm   Use <f AllocVariantIOOnPropertyBag> to create a
        <o VariantIOOnPropertyBag> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CVariantIOOnPropertyBag
//

struct CVariantIOOnPropertyBag : IManageVariantIO, IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    IPropertyBag *  m_ppb;          // property bag that object operates on
    DWORD           m_dwFlags;      // VIO_ flags (below)

///// construction and destruction
    CVariantIOOnPropertyBag(IPropertyBag *);
    ~CVariantIOOnPropertyBag();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IVariantIO methods
    STDMETHODIMP PersistList(DWORD dwFlags, va_list args);
    HRESULT __cdecl Persist(DWORD dwFlags, ...);
    STDMETHODIMP IsLoading();

///// IManageVariantIO members
    STDMETHODIMP SetMode(DWORD dwFlags);
    STDMETHODIMP GetMode(DWORD *pdwFlags);
    STDMETHODIMP DeleteAllProperties();

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// VariantIOOnPropertyBag Creation & Destruction
//

/* @func HRESULT | AllocVariantIOOnPropertyBag |

        Creates a <o VariantIOOnPropertyBag> object which provides an
        implementation of <i IVariantIO> (and <i IManageVariantIO>)
        that operates on a given <i IPropertyBag>.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IPropertyBag * | ppb | Property bag that the new object is to
        operate on.

@parm   IManageVariantIO * * | ppmvio | Where to store the <i IManageVariantIO>
        pointer to the new <o VariantIOOnPropertyBag> object.  NULL is stored
        in *<p ppmvio> on error.

@comm   Note that <i IManageVariantIO> is based on <i IVariantIO>, so
        the pointer returned in *<p ppmvio> can be safely cast to
        an <i IVariantIO> pointer.
*/
STDAPI AllocVariantIOOnPropertyBag(IPropertyBag *ppb, IManageVariantIO **ppmvio)
{
    // create the Windows object
    if ((*ppmvio = (IManageVariantIO *) New CVariantIOOnPropertyBag(ppb))
            == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CVariantIOOnPropertyBag::CVariantIOOnPropertyBag(IPropertyBag *ppb)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_ppb = ppb;
    m_ppb->AddRef();
}

CVariantIOOnPropertyBag::~CVariantIOOnPropertyBag()
{
    // cleanup
    m_ppb->Release();
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CVariantIOOnPropertyBag::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("VariantIOOnPropertyBag::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IVariantIO) ||
        IsEqualIID(riid, IID_IManageVariantIO))
        *ppv = (IManageVariantIO *) this;
    else
    if (IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CVariantIOOnPropertyBag::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CVariantIOOnPropertyBag::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IVariantIO
//

STDMETHODIMP CVariantIOOnPropertyBag::PersistList(DWORD dwFlags, va_list args)
{
	// $Review: Notice in the following line that <dwFlags> is OR-ed with
	// <m_dwFlags>.  <m_dwFlags> has already been set (via SetMode()) to indicate
	// if we're loading or saving.  <dwFlags> has any additional flags (e.g.,
	// VIO_ZEROISDEFAULT).  I didn't alter <m_dwFlags> because to avoid a 
	// change in mode.  I believe this is the only place where the OR is needed
	// since Persist() calls this function.  Rick, does this seem correct?
	// (6/26/96 a-swehba)
    return PersistVariantIOList(m_ppb, m_dwFlags | dwFlags, args);
}

HRESULT __cdecl CVariantIOOnPropertyBag::Persist(DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // fire the event with the specified arguments
    hrReturn = PersistList(dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}

STDMETHODIMP CVariantIOOnPropertyBag::IsLoading()
{
    return ((m_dwFlags & VIO_ISLOADING) ? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// IManageVariantIO
//

STDMETHODIMP CVariantIOOnPropertyBag::SetMode(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    return S_OK;
}

STDMETHODIMP CVariantIOOnPropertyBag::GetMode(DWORD *pdwFlags)
{
    *pdwFlags = m_dwFlags;
    return S_OK;
}

STDMETHODIMP CVariantIOOnPropertyBag::DeleteAllProperties()
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CVariantIOOnPropertyBag::Read(LPCOLESTR pszPropName,
    LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    return m_ppb->Read(pszPropName, pVar, pErrorLog);
}

STDMETHODIMP CVariantIOOnPropertyBag::Write(LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    return m_ppb->Write(pszPropName, pVar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\apbovp.cpp ===
// apbovp.cpp
//
// Implements AllocPropertyBagOnVariantProperty.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// PropertyBagOnVariantProperty
//

/* @object PropertyBagOnVariantProperty |

        Implements <i IPropertyBag> whose only property is contained in
        a given <t VariantProperty>.

@supint <i IPropertyBag> | The interface to use to access the single property
        stored in the given <t VariantProperty>.

@comm   Use <f AllocPropertyBagOnVariantProperty> to create a
        <o PropertyBagOnVariantProperty> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CPropertyBagOnVariantProperty
//

struct CPropertyBagOnVariantProperty : IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    VariantProperty *m_pvp;         // parent-maintained single property

///// construction and destruction
    CPropertyBagOnVariantProperty(VariantProperty *pvp);

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// PropertyBagOnVariantProperty Creation & Destruction
//

/* @func HRESULT | AllocPropertyBagOnVariantProperty |

        Creates a <o PropertyBagOnVariantProperty> object which implements
        <i IPropertyBag> whose only property is contained in a given
        <t VariantProperty>.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   VariantProperty * | pvp | Holds the single property that the
        implemented property bag contains.  The caller must allocate *<p pvp>;
        the <t PropertyBagOnVariantProperty> object <y holds onto> *<p pvp>
        for the duration of its lifetime, so the caller is responsible for
        ensuring that *<p pvp> is valid for the lifetime of this object.
        Both <p pvp>-<gt><p bstrPropName> and <p pvp>-<gt><p varValue> must
        be valid; at the very least, <p pvp>-<gt><p varValue> must contain
        an empty VARIANT (initialized using <f VariantInit>).  After the
        allocated object is freed, the caller is responsible for freeing
        the contents of *<p pvp>.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@parm   IPropertyBag * * | pppb | Where to store the <i IPropertyBag>
        pointer to the new <o PropertyBagOnVariantProperty> object.  NULL is
        stored in *<p pppb> on error.

@comm   If the returned <i IPropertyBag> is written to, all properties are
        ignored except the property named <p pvp>-<gt><p bstrPropName>,
        whose value is saved to <p pvp>-<gt><p varValue>.  If the property bag
        is read from, <om IPropertyBag.Read> will return E_FAIL for all
        properties except <p pvp>-<gt><p bstrPropName>, whose returned value is
        <p pvp>-<gt><p varValue>.

        <o PropertyBagOnVariantProperty> is really only useful in specialized
        applications which want to efficiently set or get a single property
        value from an object.
*/
STDAPI AllocPropertyBagOnVariantProperty(VariantProperty *pvp, DWORD dwFlags,
    IPropertyBag **pppb)
{
    // create the Windows object
    if ((*pppb = (IPropertyBag *)
            New CPropertyBagOnVariantProperty(pvp)) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CPropertyBagOnVariantProperty::CPropertyBagOnVariantProperty(
    VariantProperty *pvp)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_pvp = pvp;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CPropertyBagOnVariantProperty::QueryInterface(REFIID riid,
    LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("PropertyBagOnVariantProperty::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CPropertyBagOnVariantProperty::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPropertyBagOnVariantProperty::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CPropertyBagOnVariantProperty::Read(LPCOLESTR pszPropName,
    LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    if (CompareUNICODEStrings(pszPropName, m_pvp->bstrPropName) == 0)
    {
        VARTYPE vtRequested = pVar->vt;
        VariantInit(pVar);
        if (vtRequested == VT_EMPTY)
        {
            // caller wants property value in its default type
            return VariantCopy(pVar, &m_pvp->varValue);
        }
        else
        {
            // coerce the property value to the requested type
            return VariantChangeType(pVar, &m_pvp->varValue, 0, vtRequested);
        }
    }

    return E_FAIL;
}

STDMETHODIMP CPropertyBagOnVariantProperty::Write(LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    if (CompareUNICODEStrings(pszPropName, m_pvp->bstrPropName) == 0)
        return VariantCopy(&m_pvp->varValue, pVar);

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\border.cpp ===
// border.cpp
//
// Implements DrawControlBorder.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


// private constants
#define CXY_HANDLE      4       // width of a handle (must be even)
#define CXY_PERIMETER   1       // width of perimeter line (currently must be 1)
#define CXY_INFLATE     (CXY_HANDLE + CXY_PERIMETER) // amt. to inflate rect. by


/* @func HRESULT | DrawControlBorder |

        Draws a border used to drag and resize controls.

@rvalue S_OK | Success.

@rvalue S_FALSE | Success.  Also indicates that *<p ppt> does not fall within
        any portion of the control border.

@parm   HDC | hdc | Device context to draw into.  If <p hdc> is NULL then
        no drawing is performed.

@parm   RECT * | prc | Where to draw border.  The border is drawn <y outside>
        this border.  If both <p ppt> and <p pptNew> are non-NULL, then
        on exit *<p prc> is modified to contain the border rectangle obtained
        after the mouse is dragged from <p ppt> to <p pptNew>.

@parm   POINT * | ppt | Mouse position.  See <p prc> and <p piHit>.

@parm   POINT * | pptNew | New mouse position.  See <p prc> and <p piHit>.
        Note that if <p pptNew> specifies an invalid mouse move (e.g. it
        would cause the right side of *<p prc> to be dragged to the left of
        the left side of *<p prc>) then *<p pptNew> is adjusted so that
        it is valid.

@parm   int * | piHit | If <p pptNew> is NULL, then on exit *<p piHit> contains
        a "hit test code" that indicates which part of the contro border was
        hit by *<p ppt>.  If <p pptNew> is not NULL, then on entry *<p piHit>
        must contain a hit test code (usually returned from a previous call
        to <f DrawControlBorder>) indicating which part of the control border
        the user wants to drag.  The hit test codes are as follows:

        @flag   DCB_HIT_NONE | No part of the border was hit.

        @flag   DCB_HIT_EDGE | The edge of the border was hit, but no
                grab handle was hit.

        @flag   DCB_HIT_GRAB(<p i>, <p j>) | Grab handle (<p i>, <p j>) was hit,
                where <p i> is the horizontal position of the grab handle
                (0=left, 1=middle, 2=right) and <p j> is the vertical position
                of the handle (0=top, 1=middle, 2=bottom).  See Comments below
                for more information about how to interpret *<p piHit>.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   DCB_CORNERHANDLES | Draw resize grab handles at the corners
                of the border rectangle.

        @flag   DCB_SIDEHANDLES | Draw resize grab handles at the sides
                of the border rectangle.

        @flag   DCB_EDGE | Draw the edge of the border rectangle of the
                border rectangle.

        @flag   DCB_XORED | Draw the border with an exclusive-or brush.

        @flag   DCB_INFLATE | On exit, inflate *<p prc> enough so that it
                encloses the control border.

@comm   You can test if *<p piHit> refers to a specific category of grab
        handle by computing the value (1 <lt><lt> *<p piHit>) and peforming a
        bitwise and (&) with any of the following bit masks:

        @flag   DCB_CORNERHANDLES | *<p piHit> refers to a corner grab handle.

        @flag   DCB_SIDEHANDLES | *<p piHit> refers to a side grab handle.

        @flag   DCB_SIZENS | *<p piHit> refers to a vertical (north-south
                resize grab handle (on the left or right sides).

        @flag   DCB_SIZEWE | *<p piHit> refers to a horizontal (west-east)
                resize grab handle (on the left or right sides).

        @flag   DCB_SIZENESW | *<p piHit> refers to a resize grab handle at
                the north-east or south-west corner.

        @flag   DCB_SIZENWSE | *<p piHit> refers to a resize grab handle at
                the north-west or south-east corner.

@ex     The following example shows how to use <f DrawControlBorder> to
        draw a border around a control (which is at position <p g_rcControl>
        in the client area of a window) and allow the control to be moved
        and resized. |

        // globals
        HINSTANCE       g_hinst;     // application instance handle
        RECT            g_rcControl;// location of simulated control
        RECT            g_rcGhost;  // location of ghost (XOR) image of border
        POINT           g_ptPrev;   // previous mouse location
        int             g_iDrag;    // which part of control border is dragged

        // window procedure of the window that contains the control
        LRESULT CALLBACK AppWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam,
            LPARAM lParam)
        {
            PAINTSTRUCT     ps;
            int             iHit;
            HDC             hdc;
            POINT           ptCursor;
            RECT            rc;
            LPCTSTR         sz;

            switch (uiMsg)
            {

            case WM_PAINT:

                hdc = BeginPaint(hwnd, &ps);

                // draw the control
                ...

                // draw the control border outside <g_rcControl>
                DrawControlBorder(hdc, &g_rcControl, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES);

                EndPaint(hwnd, &ps);
                return 0;

            case WM_SETCURSOR:

                // set <ptCursor> to the mouse position
                GetCursorPos(&ptCursor);
                ScreenToClient(hwnd, &ptCursor);

                // set <iHit> to a hit code which indicates which part of the
                // control border (if any) <ptCursor> is over
                DrawControlBorder(NULL, &g_rcControl, &ptCursor, NULL, &iHit,
                        DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES);

                // set the cursor based on <iHit>
                if ((1 << iHit) & DCB_SIZENS)
                    sz = IDC_SIZENS;
                else
                if ((1 << iHit) & DCB_SIZEWE)
                    sz = IDC_SIZEWE;
                else
                if ((1 << iHit) & DCB_SIZENESW)
                    sz = IDC_SIZENESW;
                else
                if ((1 << iHit) & DCB_SIZENWSE)
                    sz = IDC_SIZENWSE;
                else
                    sz = IDC_ARROW;
                SetCursor(LoadCursor(NULL, sz));
                return TRUE;

            case WM_LBUTTONDOWN:

                // set <ptCursor> to the mouse position
                ptCursor.x = (short) LOWORD(lParam);
                ptCursor.y = (short) HIWORD(lParam);

                // do nothing if <ptCursor> is not within the control border
                if (DrawControlBorder(NULL, &g_rcControl,
                        &ptCursor, NULL, &g_iDrag,
                        DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES) != S_OK)
                    break;

                // capture the mouse
                SetCapture(hwnd);

                // set the initial position of the border "ghost" (the XOR image
                // of the border) to be the current position of the control
                g_rcGhost = g_rcControl;

                // draw the control border XOR'd
                hdc = GetDC(hwnd);
                DrawControlBorder(hdc, &g_rcGhost, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES | DCB_XORED);
                ReleaseDC(hwnd, hdc);

                // remember the current cursor position
                g_ptPrev = ptCursor;
                break;

            case WM_MOUSEMOVE:

                // do nothing if we're not dragging
                if (GetCapture() != hwnd)
                    break;

                // set <ptCursor> to the mouse position
                ptCursor.x = (short) LOWORD(lParam);
                ptCursor.y = (short) HIWORD(lParam);

                // move the control XOR image
                hdc = GetDC(hwnd);
                DrawControlBorder(hdc, &g_rcGhost,
                    &g_ptPrev, &ptCursor, &g_iDrag,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES | DCB_XORED);
                ReleaseDC(hwnd, hdc);

                // remember the current cursor position
                g_ptPrev = ptCursor;
                break;

            case WM_LBUTTONUP:

                // do nothing if we're not dragging
                if (GetCapture() != hwnd)
                    break;

                // erase the control border XOR image
                hdc = GetDC(hwnd);
                DrawControlBorder(hdc, &g_rcGhost, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES | DCB_XORED);
                ReleaseDC(hwnd, hdc);

                // stop dragging
                ReleaseCapture();

                // move the control to the new location
                rc = g_rcControl;
                DrawControlBorder(NULL, &rc, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES |
                    DCB_INFLATE);
                InvalidateRect(hwnd, &rc, TRUE);
                g_rcControl = g_rcGhost;
                rc = g_rcControl;
                DrawControlBorder(NULL, &rc, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES |
                    DCB_INFLATE);
                InvalidateRect(hwnd, &rc, TRUE);
                break;

            ...

            }

            return DefWindowProc(hwnd, uiMsg, wParam, lParam);
        }
*/
STDAPI DrawControlBorder(HDC hdc, RECT *prc, POINT *ppt, POINT *pptNew,
    int *piHit, DWORD dwFlags)
{
    int             r, c;           // grab handle row, column (0=left/top...2)
    HBRUSH          hbr = NULL;     // brush to draw border with
    HBRUSH          hbrPrev = NULL; // previously-selected brush
    int             iHitTmp;        // to make <piHit> be valid
    RECT            rc;
    int             x, y;

    // make sure <piHit> points to a valid integer
    if (piHit == NULL)
        piHit = &iHitTmp;

    // default <*piHit> to "missed"
    if (pptNew == NULL)
        *piHit = DCB_HIT_NONE;

    if (hdc != NULL)
    {
        // save the DC state since we'll be fiddling with the clipping region
        SaveDC(hdc);
        SetBkColor( hdc, RGB(192, 192, 192) );
    }

    if (dwFlags & (DCB_CORNERHANDLES | DCB_SIDEHANDLES))
    {
        // draw the grab handles specified by <dwFlags>
        for (r = 0; r < 3; r++)
        {
            // set <y> to the vertical center of the grab handles on row <r>
            y = (r * (prc->bottom - prc->top + CXY_HANDLE)) / 2
                + prc->top - CXY_HANDLE / 2;
            for (c = 0; c < 3; c++)
            {
                if ((1 << DCB_HIT_GRAB(c, r)) & dwFlags)
                {
                    // set <x> to the horizontal center of the grab handles
                    // on column <c>
                    x = (c * (prc->right - prc->left + CXY_HANDLE)) / 2
                        + prc->left - CXY_HANDLE / 2;

                    // set <rc> to be the rectangle that contains
                    // this grab handle
                    SetRect(&rc, x - CXY_HANDLE / 2, y - CXY_HANDLE / 2,
                        x + CXY_HANDLE / 2, y + CXY_HANDLE / 2);

                    if (hdc != NULL)
                    {
                        // draw the grab handle and then exclude it from the
                        // clipping region so that it won't be erased when
                        // the border is drawn (below)
                        PatBlt(hdc, rc.left, rc.top,
                            rc.right - rc.left, rc.bottom - rc.top,
                            (dwFlags & DCB_XORED ? DSTINVERT : BLACKNESS));
                        ExcludeClipRect(hdc, rc.left, rc.top,
                            rc.right, rc.bottom);
                    }

                    // test if <*ppt> is in a grab handle (if requested)
                    if ((ppt != NULL) && (pptNew == NULL)
                            && PtInRect(&rc, *ppt))
                        *piHit = DCB_HIT_GRAB(c, r);
                }
            }
        }
    }

    if (dwFlags & DCB_EDGE)
    {
        // set <rc> temporarily to be the rectangle that contains the
        // entire border
        rc = *prc;
        InflateRect(&rc, CXY_INFLATE, CXY_INFLATE);

        // test if <*ppt> is in the edge (if requested)
        if ((ppt != NULL) && (pptNew == NULL) && (*piHit == DCB_HIT_NONE))
        {
            if (PtInRect(&rc, *ppt) && !PtInRect(prc, *ppt))
                *piHit = DCB_HIT_EDGE;
        }

        // draw the edge (unless <hdc> is NULL)
        if (hdc != NULL)
        {
            // draw the black perimeter rectangle
            if (dwFlags & DCB_XORED)
                SetROP2(hdc, R2_XORPEN);
            SelectObject(hdc, GetStockObject(BLACK_PEN));
            SelectObject(hdc, GetStockObject(NULL_BRUSH));
            Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

            // draw the border
            if ((hbr = CreateBorderBrush()) != NULL)
            {
                rc = *prc;
                InflateRect(&rc, CXY_HANDLE, CXY_HANDLE);
                ExcludeClipRect(hdc, prc->left, prc->top,
                    prc->right, prc->bottom);
                hbrPrev = (HBRUSH)SelectObject(hdc, hbr);
                PatBlt(hdc, rc.left, rc.top,
                    rc.right - rc.left, rc.bottom  - rc.top,
                    (dwFlags & DCB_XORED ? PATINVERT : PATCOPY));
            }
        }
    }

    // clean up
    if (hbrPrev != NULL)
        SelectObject(hdc, hbrPrev);
    if (hbr != NULL)
        DeleteObject(hbr);
    if (hdc != NULL)
        RestoreDC(hdc, -1);

    if (pptNew != NULL)
    {
        // adjust <*prc> to account for the user dragging the mouse
        // from <*ppt> to <*pptNew>
        if (*piHit == DCB_HIT_EDGE)
        {
            // user is dragging the edge of the border
            OffsetRect(prc, pptNew->x - ppt->x, pptNew->y - ppt->y);
        }
        else
        {
            // user is dragging a grab handle...

            // adjust <*prc> horizontally
            switch (*piHit & DCB_HIT_GRAB(3, 0))
            {

            case DCB_HIT_GRAB(0, 0):

                // user is dragging one of three handles on the left side
                prc->left += pptNew->x - ppt->x;
                if (prc->left > prc->right)
                {
                    pptNew->x += prc->right - prc->left;
                    prc->left = prc->right;
                }
                break;

            case DCB_HIT_GRAB(2, 0):

                // user is dragging one of three handles on the right side
                prc->right += pptNew->x - ppt->x;
                if (prc->right < prc->left)
                {
                    pptNew->x += prc->left - prc->right;
                    prc->right = prc->left;
                }
                break;

            }

            // adjust <*prc> vertically
            switch (*piHit & DCB_HIT_GRAB(0, 3))
            {

            case DCB_HIT_GRAB(0, 0):

                // user is dragging one of three handles on the top side
                prc->top += pptNew->y - ppt->y;
                if (prc->top > prc->bottom)
                {
                    pptNew->y += prc->bottom - prc->top;
                    prc->top = prc->bottom;
                }
                break;

            case DCB_HIT_GRAB(0, 2):

                // user is dragging one of three handles on the bottom side
                prc->bottom += pptNew->y - ppt->y;
                if (prc->bottom < prc->top)
                {
                    pptNew->y += prc->top - prc->bottom;
                    prc->bottom = prc->top;
                }
                break;

            }
        }

        // draw the control border in the new position
        DrawControlBorder(hdc, prc, NULL, NULL, NULL, dwFlags);
    }

    // if requested, inflate <*prc> to include the entire border
    if (dwFlags & DCB_INFLATE)
        InflateRect(prc, CXY_INFLATE, CXY_INFLATE);

    return ((*piHit != DCB_HIT_NONE) ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\apbos.cpp ===
// apbos.cpp
//
// Implements AllocPropertyBagOnStream.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// PropertyBagOnStream
//

/* @object PropertyBagOnStream |

        Implements <i IPropertyBag> whose properties are contained in
        a given <i IStream>.

@supint <i IPropertyBag> | The interface to use to access the properties
        stored in the given <i IStream>.

@comm   Use <f AllocPropertyBagOnStream> to create a <o PropertyBagOnStream>
        object.

@comm   See <t VariantPropertyHeader> for a description of the format of
        the data in the <i IStream>.
*/


//////////////////////////////////////////////////////////////////////////////
// CPropertyBagOnStream
//

struct CPropertyBagOnStream : IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    IStream *       m_ps;           // parent's property bag
    IStream *       m_psBuf;        // buffer used for reading properties

///// construction and destruction
    CPropertyBagOnStream(IStream *pstream);
    ~CPropertyBagOnStream();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// PropertyBagOnStream Creation & Destruction
//

/* @func HRESULT | AllocPropertyBagOnStream |

        Creates a <o PropertyBagOnStream> object which implements
        <i IPropertyBag> whose properties are contained in a given <i IStream>.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IStream * | pstream | Stream to read from or write to (depending on
        whether the returned <i IPropertyBag> is used for reading or
        writing).

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@parm   IPropertyBag * * | pppb | Where to store the <i IPropertyBag>
        pointer to the new <o PropertyBagOnStream> object.  NULL is stored
        in *<p pppb> on error.

@comm   The returned <i IPropertyBag> must be used either exclusively for
        reading (i.e. only <om IPropertyBag.Read> is called) or exclusively
        for writing (i.e. only <om IPropertyBag.Write> is called).  The
        properties are read/written starting from the current position of
        <p pstream>.  When reading/writing is complete, the current position
        of <p pstream> will be the end of the properties in the stream.

        See <t VariantPropertyHeader> for a description of the format of
        the data in the <i IStream>.
*/
STDAPI AllocPropertyBagOnStream(IStream *pstream, DWORD dwFlags,
    IPropertyBag **pppb)
{
    // create the Windows object
    if ((*pppb = (IPropertyBag *)
            New CPropertyBagOnStream(pstream)) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CPropertyBagOnStream::CPropertyBagOnStream(IStream *pstream)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_ps = pstream;
    m_ps->AddRef();
    m_psBuf = NULL;
}

CPropertyBagOnStream::~CPropertyBagOnStream()
{
    // cleanup
    m_ps->Release();
    if (m_psBuf != NULL)
        m_psBuf->Release();
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CPropertyBagOnStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("PropertyBagOnStream::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CPropertyBagOnStream::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPropertyBagOnStream::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CPropertyBagOnStream::Read(LPCOLESTR pszPropName,
    LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    HRESULT         hrReturn = S_OK; // function return code
    VariantProperty vp;             // a property name/value pair in <pmvio>
    LARGE_INTEGER   liZero = {0, 0};

    // ensure correct cleanup
    VariantPropertyInit(&vp);

    if (m_psBuf == NULL)
    {
        // copy the properties from <m_ps> to temporary memory-based stream
        // <m_psBuf> since the caller may read properties in any order...

        // set <m_psBuf> to be a new empty memory-based stream
        if (FAILED(hrReturn = CreateStreamOnHGlobal(NULL, TRUE, &m_psBuf)))
            goto ERR_EXIT;

        // loop once for each property in <m_ps>
        while (TRUE)
        {
            // set <vp> to the next property name/value pair in <m_ps>
            VariantPropertyClear(&vp);
            if (FAILED(hrReturn = ReadVariantProperty(m_ps, &vp, 0)))
                goto ERR_EXIT;
            if (hrReturn == S_FALSE)
            {
                // hit end of sequence of properties
                hrReturn = S_OK;
                break;
            }

            // write <vp> to <m_psBuf>
            if (FAILED(hrReturn = WriteVariantProperty(m_psBuf, &vp, 0)))
                goto ERR_EXIT;
        }
    }

    // seek <m_psBuf> to the beginning
    if (FAILED(hrReturn = m_psBuf->Seek(liZero, SEEK_SET, NULL)))
        goto ERR_EXIT;

    // loop once for each property in <m_psBuf>
    while (TRUE)
    {
        // set <vp> to the next property name/value pair in <m_psBuf>
        VariantPropertyClear(&vp);
        if (FAILED(hrReturn = ReadVariantProperty(m_psBuf, &vp, 0)))
            goto ERR_EXIT;
        if (hrReturn == S_FALSE)
        {
            // hit end of sequence of properties
            break;
        }

        // see if <vp> is the property the caller wants to read
        if (CompareUNICODEStrings(vp.bstrPropName, pszPropName) == 0)
        {
            // it is
            VARTYPE vtRequested = pVar->vt;
            if (vtRequested == VT_EMPTY)
            {
                // caller wants the property value in its default type;
                // hand ownership of <vp.varValue> to the caller
                *pVar = vp.varValue;
                VariantInit(&vp.varValue); // prevent double deallocation
            }
            else
            {
                // coerce <vp> to the requested type
                VariantInit(pVar);
                if (FAILED(hrReturn = VariantChangeType(pVar, &vp.varValue,
                        0, vtRequested)))
                    goto ERR_EXIT;
            }
            goto EXIT;
        }
    }

    // property <pszPropName> not found
    hrReturn = E_INVALIDARG;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    VariantPropertyClear(&vp);

    return hrReturn;
}

STDMETHODIMP CPropertyBagOnStream::Write(LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    VariantProperty vp;
    if ((vp.bstrPropName = SysAllocString(pszPropName)) == NULL)
        return E_OUTOFMEMORY;
    vp.varValue = *pVar;
    HRESULT hr = WriteVariantProperty(m_ps, &vp, 0);
    SysFreeString(vp.bstrPropName);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\avio.cpp ===
// avio.cpp
//
// Implements AllocVariantIO.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// VariantIO
//


/* @object VariantIO |

        Provides a property bag implementation which supports <i IPropertyBag>
        as well as <i IVariantIO>, <i IManageVariantIO>, and
        <i IEnumVariantProperty>.

@supint <i IPropertyBag> | Allows properties to be read from and written to the
        <o VariantIO> object.

@supint <i IVariantIO> | An alternative to <i IPropertyBag> which allows the
        caller to implement property-based persistence with less code.

@supint <i IManageVariantIO> | Based on <i IVariantIO>.  Allows the caller to
        control how the methods of <i IVariantIO> operate (e.g. whether the
        <i IVariantIO> is in loading mode or saving mode).

@supint <i IEnumVariantProperty> | Allows the caller to enumerate the
        properties that are currently in the <o VariantIO> object.  Note that
        <o VariantIO> does not implement <om IEnumVariantProperty.Clone>.

@comm   Use <f AllocVariantIO> to create a <o VariantIO> object.

*/


/* @interface IVariantIO |

        Allows property name/value pairs to be loaded or saved.  <i IVariantIO>
        is an alternative to <i IPropertyBag> which allows the caller to
        implement property-based persistence with less code.

@meth   HRESULT | PersistList | Loads or saves a list of property name/value
        pairs, specified as a va_list array.

@meth   HRESULT | Persist | Loads or saves a list of property name/value
        pairs, specified as a variable-length list of arguments.

@meth   HRESULT | IsLoading | Return S_OK if the <i IVariantIO> object is
        being used to load properties, S_FALSE if it is being used to save
        properties.
*/


/* @interface IManageVariantIO |

        Based on <i IVariantIO>.  Allows the caller to control how the methods
        of the <i IVariantIO> object operate (e.g. whether the <i IVariantIO>
        object is in loading mode or saving mode).

@meth   HRESULT | SetMode | Sets the mode of the <i IVariantIO> object.

@meth   HRESULT | SetMode | Gets the mode of the <i IVariantIO> object.

@meth   HRESULT | DeleteAllProperties | Removes all property/value pairs from
        the <i VariantIO> object.
*/


/* @struct VariantProperty |

        Contains the name and value of a property.

@field  BSTR | bstrPropName | The name of the property.

@field  VARIANT | varValue | The value of the property.

@comm   <i IEnumVariantProperty> uses this structure.
*/


/* @interface IEnumVariantProperty |

        Allows the properties of an object to be enumerated.

@meth   HRESULT | Next | Retrieves a specified number of items in the
        enumeration sequence.

@meth   HRESULT | Skip | Skips over a specified number of items in the
        enumeration sequence.

@meth   HRESULT | Reset | Resets the enumeration sequence to the beginning.

@meth   HRESULT | Clone | Creates another enumerator that contains the same
        enumeration state as the current one.  Note that <o VariantIO> does
        not implement this method.

@comm   The <o VariantIO> implementation of <i IEnumVariantProperty>
        has these restrictions:

@item       <om .Clone> is not supported.

@item       <om .Reset> is automatically called whenever a property is
            removed from the <o VariantIO> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CVariantIO
//

struct VariantPropertyNode : VariantProperty
{
///// state
    VariantPropertyNode *pnodeNext; // next node in linked list
    VariantPropertyNode *pnodePrev; // previous node in linked list

///// construction and destruction
    VariantPropertyNode(LPCOLESTR oszPropNameX, VARIANT *pvarValueX,
        VariantPropertyNode *pnodeNextX, HRESULT *phr)
    {
        if (oszPropNameX != NULL)
            bstrPropName = SysAllocString(oszPropNameX);
        if (pvarValueX != NULL)
            VariantCopyInd(&varValue, pvarValueX);
        if (pnodeNextX != NULL)
        {
            pnodeNext = pnodeNextX;
            pnodePrev = pnodeNextX->pnodePrev;
            pnodeNext->pnodePrev = this;
            pnodePrev->pnodeNext = this;
        }
        if (phr != NULL)
            *phr = (((bstrPropName != NULL) && (pvarValueX->vt == varValue.vt))
                ? S_OK : E_OUTOFMEMORY);
    }
    ~VariantPropertyNode()
    {
        SysFreeString(bstrPropName);
        VariantClear(&varValue);
        if (pnodeNext != NULL)
            pnodeNext->pnodePrev = pnodePrev;
        if (pnodePrev != NULL)
            pnodePrev->pnodeNext = pnodeNext;
    }
};

struct CVariantIO : IManageVariantIO, IEnumVariantProperty, IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    DWORD           m_dwFlags;      // VIO_ flags (below)
    VariantPropertyNode m_nodeHead; // head of linked list (contains no data)
    VariantPropertyNode *m_pnodeCur; // current node in enumeration

///// helper operations
    VariantPropertyNode *FindProperty(LPCOLESTR pszPropName);

///// construction and destruction
    CVariantIO();
    ~CVariantIO();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IVariantIO methods
    STDMETHODIMP PersistList(DWORD dwFlags, va_list args);
    HRESULT __cdecl Persist(DWORD dwFlags, ...);
    STDMETHODIMP IsLoading();

///// IManageVariantIO members
    STDMETHODIMP SetMode(DWORD dwFlags);
    STDMETHODIMP GetMode(DWORD *pdwFlags);
    STDMETHODIMP DeleteAllProperties();

///// IEnumVariantProperty members
    STDMETHODIMP Next(unsigned long celt, VariantProperty *rgvp,
        unsigned long *pceltFetched);
    STDMETHODIMP Skip(unsigned long celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumVariantProperty **ppenum);

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// VariantIO Creation & Destruction
//

/* @func HRESULT | AllocVariantIO |

        Creates a <o VariantIO> object which provides a property bag
        implementation which supports <i IPropertyBag> as well as
        <i IVariantIO>, <i IManageVariantIO>, and <i IEnumVariantProperty>.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IManageVariantIO * * | ppmvio | Where to store the <i IManageVariantIO>
        pointer to the new <o VariantIO> object.  NULL is stored in *<p ppmvio>
        on error.

@comm   Note that <i IManageVariantIO> is based on <i IVariantIO>, so
        the pointer returned in *<p ppmvio> can be safely cast to
        an <i IVariantIO> pointer.
*/
STDAPI AllocVariantIO(IManageVariantIO **ppmvio)
{
    // create the Windows object
    if ((*ppmvio = (IManageVariantIO *) New CVariantIO()) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CVariantIO::CVariantIO() :
    m_nodeHead(NULL, NULL, NULL, NULL)
{
    // initialize IUnknown
    m_cRef = 1;

    // initialize the circular doubly-linked list of VariantPropertyNode
    // structures to contain a single "head" item <m_nodeHead> (which is
    // not used to contain any actual data) which initially points to itself
    // (since it's initially the only node in the circular list)
    m_nodeHead.pnodeNext = m_nodeHead.pnodePrev = &m_nodeHead;

    // reset the property enumeration
    Reset();
}

CVariantIO::~CVariantIO()
{
    // cleanup
    DeleteAllProperties();
}


//////////////////////////////////////////////////////////////////////////////
// Helper Operations
//


// pnode = FindProperty(szPropName)
//
// Return a pointer to the node that contains the property named <szPropName>.
// Return NULL if no such node exists.
//
VariantPropertyNode *CVariantIO::FindProperty(LPCOLESTR pszPropName)
{
    // loop once for each property/value pair stored in this object
    for (VariantPropertyNode *pnode = m_nodeHead.pnodeNext;
         pnode != &m_nodeHead;
         pnode = pnode->pnodeNext)
    {
        if (CompareUNICODEStrings(pnode->bstrPropName, pszPropName) == 0)
        {
            // found the desired property
            return pnode;
        }
    }

    // desired property not found
    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CVariantIO::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#if 0
#ifdef _DEBUG
    char ach[200];
    TRACE("VariantIO::QI('%s')\n", DebugIIDName(riid, ach));
#endif
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IVariantIO) ||
        IsEqualIID(riid, IID_IManageVariantIO))
        *ppv = (IManageVariantIO *) this;
    else
    if (IsEqualIID(riid, IID_IEnumVariantProperty))
        *ppv = (IEnumVariantProperty *) this;
    else
    if (IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CVariantIO::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CVariantIO::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IVariantIO
//


/* @method HRESULT | IVariantIO | PersistList |

        Loads or saves a list of property name/value pairs, specified as a
        va_list array.

@rvalue S_OK | Success.  At least one of the variables listed in
        <p args> was written to, so the control may want to update
        itself accordingly.

@rvalue S_FALSE | None of the variables listed in <p args> were
        written to (either because the <i IVariantIO> object is in
        saving mode or because none of the properties named in
        <p args> exist in the <i IVariantIO> object).

@rvalue DISP_E_BADVARTYPE | One of the VARTYPE values in <p args> is invalid.

@rvalue DISP_E_TYPEMISMATCH | One of the variables in <p args> could not be
        coerced to the type of the corresponding property in the <i IVariantIO>
        object, or vice versa.

@rvalue E_OUTOFMEMORY | Out of memory.

@parm   DWORD | dwFlags | Optional flags.  See <om IManageVariantIO.SetMode> for
		possible values.

@parm   va_list | args | The arguments to pass.  See <om .Persist>
        for information about the organization of these arguments.
*/
STDMETHODIMP CVariantIO::PersistList(DWORD dwFlags, va_list args)
{
    return PersistVariantIOList(this, m_dwFlags, args);
}


/* @method HRESULT | IVariantIO | Persist |

        Loads or saves a list of property name/value pairs, specified as a
        variable-length list of arguments.

@rvalue S_OK | Success.  At least one of the variables listed in
        <p (arguments)> was written to, so the control may want to update
        itself accordingly.

@rvalue S_FALSE | None of the variables listed in <p (arguments)> were
        written to (either because the <i IVariantIO> object is in
        saving mode or because none of the properties named in
        <p (arguments)> exist in the <i IVariantIO> object.

@rvalue DISP_E_BADVARTYPE |
        One of the VARTYPE values in <p (arguments)> is invalid.

@rvalue DISP_E_TYPEMISMATCH |
        One of the variables in <p (arguments)> could not be coerced to the
        type of the corresponding property in the <i IVariantIO> object, or
        vice versa.

@rvalue E_OUTOFMEMORY | Out of memory.

@parm   DWORD | dwFlags | Optional flags.  See <om IManageVariantIO.SetMode> for
		possible values.

@parm   (varying) | (arguments) | The names, types, and pointers to variables
        containing the properties to persist.  These must consist of a series
        of argument triples (sets of 3 arguments) followed by a NULL.
        In each triplet, the first argument is an LPSTR which contains the
        name of the property; the second argument is a VARTYPE value that
        indicates the type of the property; the third argument is a pointer
        to a variable (typically a member variable of the control's C++ class)
        that holds the value of the property.  This variable will be read
        from or written to depending on the mode of the <i VariantIO> object
        (see <om IVariantIO.IsLoading>) -- therefore the variables should
        contain valid values before <om .Persist> is called.  The following
        VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int *.

        @flag   VT_I2 | The following argument is a short *.

        @flag   VT_I4 | The following argument is a long *.

        @flag   VT_BOOL | The following argument is a BOOL * (<y not> a
                VARIANT_BOOL *).  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR *.  If
                <om .Persist> changes the value of this BSTR, the previous
                BSTR is automatically freed using <f SysFreeString>.

        @flag   VT_LPSTR | The following argument is an LPSTR that points
                to a char array capable of holding at least _MAX_PATH
                characters including the terminating NULL.

        @flag   VT_UNKNOWN | The following argument is an LPUNKNOWN *.  If
                <om .Persist> changes the value of this LPUNKNOWN, the previous
                LPUNKNOWN is automatically freed using <f Release>, and the
                new value is automatically <f AddRef>d.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH *.  If
                <om .Persist> changes the value of this LPDISPATCH, the previous
                LPDISPATCH is automatically freed using <f Release>, and the
                new value is automatically <f AddRef>d.

        @flag   VT_VARIANT | The following arguement is a VARIANT *.
                This allows arbitrary parameters to be passed using this
                function.  Note that this behavior differs from the usual
                definition of VT_VARIANT.  If <om .Persist> changes the value
                of this VARIANT, the previous VARIANT value is automatically
                cleared using <f VariantClear>.

@ex     The following example persists two properties (which in BASIC would
        be a Long and a String, respectively) named "Foo" and "Bar",
        respectively. |

        pvio->Persist(0, "Foo", VT_INT, &m_iFoo, "Bar", VT_LPSTR, &m_achBar,
            NULL);
*/
HRESULT __cdecl CVariantIO::Persist(DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // fire the event with the specified arguments
    hrReturn = PersistList(dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @method HRESULT | IVariantIO | IsLoading |

        Return S_OK if the <i IVariantIO> object is being used to load
        properties, S_FALSE if it is being used to save

@rvalue S_OK | The <i IVariantIO> object is in loading mode, so
        <om IVariantIO.Persist> and <om IVariantIO.PersistList> will
        copy data from properties to variables.

@rvalue S_FALSE | The <i IVariantIO> object is in saving mode, so that
        <om IVariantIO.Persist> and <om IVariantIO.PersistList> will copy
        data from variables to properties.
*/
STDMETHODIMP CVariantIO::IsLoading()
{
    return ((m_dwFlags & VIO_ISLOADING) ? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// IManageVariantIO
//


/* @method HRESULT | IManageVariantIO | SetMode |

        Sets the mode of the <i IVariantIO> object.

@rvalue S_OK | Success.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   VIO_ISLOADING | Set the <i IVariantIO> object to loading
                mode, so that <om IVariantIO.Persist> and
                <om IVariantIO.PersistList> copy data from properties
                to variables.  If this flag is not spacified, then
                the <i IVariantIO> object will be set to saving mode,
                so that <om IVariantIO.Persist> and <om IVariantIO.PersistList>
                copy data from variables to properties.

		@flag	VIO_ZEROISDEFAULT | Inform the <i IVariantIO> object that
				0 is the default values for properties and that 0-valued
				properties should not be saved via <om IVariantIO.Persist> and
				<om IVariantIO.PersistList>.

@comm   When a <o VariantIO> object is created, its initial mode is such that
        none of the flags in <p dwFlags> are specified.
*/
STDMETHODIMP CVariantIO::SetMode(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    return S_OK;
}


/* @method HRESULT | IManageVariantIO | GetMode |

        Gets the mode of the <i IVariantIO> object.

@rvalue S_OK | Success.

@parm   DWORD * | *pdwFlags | Returns the flag specifying the current mode of
        the <i IVariantIO> object.  See <om .SetMode> for a description of
        these flags.

@comm   When a <o VariantIO> object is created, its initial mode is such that
        none of the flags in <p dwFlags> are specified.
*/
STDMETHODIMP CVariantIO::GetMode(DWORD *pdwFlags)
{
    *pdwFlags = m_dwFlags;
    return S_OK;
}


/* @method HRESULT | IManageVariantIO | DeleteAllProperties |

        Removes all property/value pairs from the <i VariantIO> object.

@rvalue S_OK | Success.

@rvalue E_OUTOFMEMORY | Out of memory.
*/
STDMETHODIMP CVariantIO::DeleteAllProperties()
{
    // delete all nodes
    while (m_nodeHead.pnodeNext != &m_nodeHead)
        Delete m_nodeHead.pnodeNext;

    // reset the property enumeration
    Reset();

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IEnumVariantProperty
//


/* @method HRESULT | IEnumVariantProperty | Next |

        Retrieves a specified number of items in the enumeration sequence.

@rvalue S_OK | The number of elements returned is <p celt>.

@rvalue S_FALSE | The number of elements returned is not <p celt>.

@parm   unsigned long | celt | The number of elements being requested.

@parm   VariantProperty * | rgvp | Receives an array of size <p celt>
        (or larger) of the elements to be returned.  The caller is responsible
        for calling <f SysFreeString> and <p VariantClear> on the
        <p bstrPropName> and <p varValue> fields, respectively, of each
        element returned in <p rgvp>.  (Alternatively, the caller can simply
        call <f VariantPropertyClear> on each element returned in <p rgvp>.)

@parm   unsigned long * | pceltFetched | On return, contains the number of
        elements actually returned in <p rgelt>.  If <p pceltFetched> is NULL,
        this information is not returned.
*/
STDMETHODIMP CVariantIO::Next(unsigned long celt, VariantProperty *rgvp,
    unsigned long *pceltFetched)
{
    // internal assumption: <rgvp> may be NULL -- if so, it is ignored
    // (this assumption is required by CVariantIO::Skip)

    // initialize the count of fetched elements;
    // make <pceltFetched> point to valid memory
    unsigned long celtFetchedTmp;
    if (pceltFetched == NULL)
        pceltFetched = &celtFetchedTmp;
    *pceltFetched = 0;

    // loop once for each element to skip
    while (celt-- > 0)
    {
        // set <m_pnodeCur> to the next element in the list
        if (m_pnodeCur->pnodeNext == &m_nodeHead)
            return S_FALSE; // hit the end of the list
        m_pnodeCur = m_pnodeCur->pnodeNext;

        // update the count of fetched elements
        *pceltFetched++;

        // return a copy of the current element
        if (rgvp != NULL)
        {
            // copy the current element to <*rgvp>
            rgvp->bstrPropName = SysAllocString(m_pnodeCur->bstrPropName);
            VariantInit(&rgvp->varValue);
            VariantCopy(&rgvp->varValue, &m_pnodeCur->varValue);
            if ((rgvp->bstrPropName == NULL) ||
                (rgvp->varValue.vt != m_pnodeCur->varValue.vt))
                goto EXIT_ERR; // copy operation failed
            rgvp++;
        }
    }

    return S_OK;

EXIT_ERR:

    // an error occurred -- free all the memory we allocated
    while (*pceltFetched-- > 0)
    {
        // note that SysFreeString() and VariantClear() operate correctly
        // on zero-initialized values
        SysFreeString(rgvp->bstrPropName);
        VariantClear(&rgvp->varValue);
        rgvp--;
    }

    return E_OUTOFMEMORY;
}


/* @method HRESULT | IEnumVariantProperty | Skip |

        Skips over a specified number of items in the enumeration sequence.

@rvalue S_OK | The number of elements skipped is <p celt>.

@rvalue S_FALSE | The number of elements skipped is not <p celt>.

@parm   unsigned long | celt | The number of elements that are to be skipped.

*/
STDMETHODIMP CVariantIO::Skip(unsigned long celt)
{
    return Next(celt, NULL, NULL);
}


/* @method HRESULT | IEnumVariantProperty | Reset |

        Resets the enumeration sequence to the beginning.

@rvalue S_OK | Success.

@comm   There is no guarantee that the same set of objects will be enumerated
        after the reset, because it depends on the collection being enumerated.
*/
STDMETHODIMP CVariantIO::Reset()
{
    m_pnodeCur = &m_nodeHead;
    return S_OK;
}


/* @method HRESULT | IEnumVariantProperty | Clone |

        Creates another enumerator that contains the same enumeration state
        as the current one.

@rvalue S_OK | Success.

@rvalue E_OUTOFMEMORY | Out of memory.

@rvalue E_UNEXPECTED | An unexpected error occurred.

@parm   IEnumVariantProperty * * | ppenum | On exit, contains the duplicate
        enumerator.  If the function was unsuccessful, this parameter's value
        is undefined.

@comm   Note that <o VariantIO> does not implement this method.
*/
STDMETHODIMP CVariantIO::Clone(IEnumVariantProperty **ppenum)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CVariantIO::Read(LPCOLESTR pszPropName, LPVARIANT pVar,
    LPERRORLOG pErrorLog)
{
    // set <pnode> to the node containing the property named <pszPropName>
    VariantPropertyNode *pnode = FindProperty(pszPropName);
    if (pnode == NULL)
        return E_INVALIDARG; // property not found

    // found the desired property
    VARTYPE vtRequested = pVar->vt;
    VariantInit(pVar);
    if (vtRequested == VT_EMPTY)
    {
        // caller wants property value in its default type
        return VariantCopy(pVar, &pnode->varValue);
    }
    else
    {
        // coerce property value to requested type
        return VariantChangeType(pVar, &pnode->varValue, 0, vtRequested);
    }
}

STDMETHODIMP CVariantIO::Write(LPCOLESTR pszPropName, LPVARIANT pVar)
{
    // set <pnode> to the node containing the property named <pszPropName>
    VariantPropertyNode *pnode = FindProperty(pszPropName);
    if (pnode != NULL)
    {
        // found the node -- change its value to <pVar>
        return VariantCopy(&pnode->varValue, pVar);
    }
    else
    {
        // no node named <pszPropName> exists; append a new VariantPropertyNode
        // containing a copy of <pszPropName> and <pVar> to the end of the
        // linked list of nodes
        HRESULT hr;
        pnode = New VariantPropertyNode(pszPropName, pVar,
            &m_nodeHead, &hr);
        if (pnode == NULL)
            return E_OUTOFMEMORY;
        if (FAILED(hr))
        {
            Delete pnode;
            return hr;
        }
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\aviotmd.cpp ===
// avitmd.cpp
//
// Implements AllocVariantIOToMapDISPID.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// VariantIOToMapDISPID
//

/* @object VariantIOToMapDISPID |

        Provides an implementation of <i IVariantIO> which is used to map a
        property name to a DISPID (property number) or vice versa.  Can also
        be used to get or set the value of that property.

@supint <i IVariantIO> | Typically used as a parameter to
        <om IPersistVariantIO.DoPersist>.

@comm   Use <f AllocVariantIOToMapDISPID> to create a
        <o VariantIOToMapDISPID> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CVariantIOToMapDISPID
//

struct CVariantIOToMapDISPID : IVariantIO
{
///// general object state
    ULONG           m_cRef;         // object reference count
    DISPID          m_dispidCounter; // count DISPID of persisted properties
    char *          m_pchPropName;  // owner's given/found prop. name (or "")
    DISPID *        m_pdispid;      // owner's given/found DISPID (or -1)
    VARIANT *       m_pvar;         // property to get/set
    DWORD           m_dwFlags;      // AllocVariantIOToMapDISPID flags

///// construction and destruction
    CVariantIOToMapDISPID(char *pchPropName, DISPID *pdispid,
        VARIANT *pvar, DWORD dwFlags);

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IVariantIO methods
    STDMETHODIMP PersistList(DWORD dwFlags, va_list args);
    HRESULT __cdecl Persist(DWORD dwFlags, ...);
    STDMETHODIMP IsLoading();
};


/////////////////////////////////////////////////////////////////////////////
// VariantIOToMapDISPID Creation & Destruction
//

/* @func HRESULT | AllocVariantIOToMapDISPID |

        Creates a <o VariantIOToMapDISPID> object which provides an
        implementation of <i IVariantIO> which is used to map a property name
        to a DISPID (property number) or vice versa.  Can also be used to get
        or set the value of that property.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   char * | pchPropName | A pointer to a caller-allocated buffer
        containing (on entry) either a property name to search for the DISPID
        of, or "" if it's the property name being searched for (if
        *<p pdispid> contains a non-negative number on entry).
        <p pchPropName> must remain valid for the lifetime of the
        allocated object.  If <p pchPropName> is "" on entry, then it must
        have enough space for _MAX_PATH characters.

@parm   DISPID * | pdispid | A pointer to a caller-allocated DISPID variable
        containing (on entry) either a DISPID to find the property name of,
        or -1 if it's the DISPID that's being searched for (if <p pchPropName>
        is non-empty on entry).  *<p pdispid> must remain valid for the
        lifetime of the allocated object.

@parm   VARIANT * | pvar | A pointer to a caller-allocated VARIANT variable,
        if either VIOTMD_GETPROP or VIOTMD_PUTPROP are specified in
        <p dwFlags> -- see those flags for more information.  If provided,
        *<p pvar> must be initialized by <f VariantInit> on entry and must
        remain valid for the lifetime of the allocated object.

@parm   DWORD | dwFlags | May optionally contain the following flags:

        @flag   VIOTMD_GETPROP | The value of the property (if found) is
                copied to *<p pvar>.  The previous value in *<p pvar>
                is cleared using <f VariantClear>.

        @flag   VIOTMD_PUTPROP | The value of the property (if found) is
                set to *<p pvar>, which must contain a valid valu on entry.

@parm   IVariantIO * * | ppvio | Where to store the <i IVariantIO>
        pointer to the new <o VariantIOToMapDISPID> object.  NULL is stored
        in *<p ppvio> on error.

@comm   DISPIDs assigned by this function start at DISPID_BASE (defined in
        ochelp.h) to avoid colliding with the DISPID values assigned by
        <f DispatchHelpGetIDsOfNames>.

@ex     To find the DISPID of property "Foo" implemented by an object <p ppvio>
        that implements <i IPeristVariantIO>, do the following.  Error checking
        is not shown. |

        char *achPropName = "Foo";
        DISPID dispid = -1;
        IVariantIO *pvio;
        AllocVariantIOToMapDISPID(&szPropName, &dispid, NULL, 0, &pvio);
        ppvio->DoPersist(pvio, PVIO_PROPNAMESONLY);
        if (dispid != -1)
            ... found DISPID <dispid> ...

@ex     To find the property name of a property with DISPID 7 implemented by an
        object <p ppvio> that implements <i IPeristVariantIO>, do the
        following.  Error checking is not shown. |

        char achPropName[_MAX_PATH];
        achPropName[0] = 0;
        DISPID dispid = 7;
        IVariantIO *pvio;
        AllocVariantIOToMapDISPID(&achPropName, &dispid, NULL, 0, &pvio);
        ppvio->DoPersist(pvio, PVIO_PROPNAMESONLY);
        if (achPropName[0] != 0)
            ... found property name <achPropName>...

@ex     To set the value of the property with DISPID 7 to 32-bit integer
        value 42, do the following.  Error checking is not shown. |

        char achPropName[_MAX_PATH];
        achPropName[0] = 0;
        DISPID dispid = 7;
        IVariantIO *pvio;
        VARIANT var;
        var.vt = VT_I2;
        V_I2(&var) = 42;
        AllocVariantIOToMapDISPID(&achPropName, &dispid, &var, VIOTMD_PUTPROP,
            &pvio);
        ppvio->DoPersist(pvio, 0);
        if (achPropName[0] != 0)
            ... successfully set property <dispid> to value <var> ...
*/
STDAPI AllocVariantIOToMapDISPID(char *pchPropName, DISPID *pdispid,
    VARIANT *pvar, DWORD dwFlags, IVariantIO **ppvio)
{
    // create the Windows object
    if ((*ppvio = (IVariantIO *) New CVariantIOToMapDISPID(pchPropName,
            pdispid, pvar, dwFlags)) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CVariantIOToMapDISPID::CVariantIOToMapDISPID(char *pchPropName,
    DISPID *pdispid, VARIANT *pvar, DWORD dwFlags)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_pchPropName = pchPropName;
    m_pdispid = pdispid;
    m_pvar = pvar;
    m_dwFlags = dwFlags;

    // assign the initial DISPID -- start numbering at DISPID_BASE to avoid
    // colliding with the DISPID values assigned by DispatchHelpGetIDsOfNames
    m_dispidCounter = DISPID_BASE;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CVariantIOToMapDISPID::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("VariantIOToMapDISPID::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IVariantIO))
        *ppv = (IVariantIO *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CVariantIOToMapDISPID::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CVariantIOToMapDISPID::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IVariantIO
//

STDMETHODIMP CVariantIOToMapDISPID::PersistList(DWORD dwFlags, va_list args)
{
    HRESULT         hrReturn = S_OK; // function return code
    LPSTR           szArg;          // property name from <args>
    VARTYPE         vtArg;          // variable type from <args>
    LPVOID          pvArg;          // variable pointer from <args>
    IPropertyBag *  ppb = NULL;     // to persist single property to/from
    OLECHAR         oach[MAX_PATH];
    VariantProperty vp;

    // ensure correct cleanup
    VariantPropertyInit(&vp);

    // loop once for each (name, VARTYPE, value) triplet in <args>;
    // for each triplet, increment <m_dispidCounter>, and if the
    // triplet's property name is <m_achPropName> then set
    // <*m_pdispid> to the DISPID of that property
    while ((szArg = va_arg(args, LPSTR)) != NULL)
    {
        // <szArg> is the name of the property in the current triplet;
        // set <vtArg> to the type of the variable pointer, and set
        // <pvArg> to the variable pointer
        vtArg = va_arg(args, VARTYPE);
        pvArg = va_arg(args, LPVOID);

        // <m_dispidCounter> is used to assign each property name
        // a DISPID (1, 2, 3, ...)
        m_dispidCounter++;

        if (*m_pdispid == -1)
        {
            // we're trying to find the DISPID of the property named
            // <m_pchPropName>
            if (lstrcmpi(m_pchPropName, szArg) == 0)
            {
                // this is the property we're looking for
                *m_pdispid = m_dispidCounter;
                goto FOUND_IT;
            }
        }
        else
        if (*m_pchPropName == 0)
        {
            // we're trying to find the property name corresponding to
            // DISPID <*m_pdispid>
            if (*m_pdispid == m_dispidCounter)
            {
                // this is the DISPID we're looking for
                lstrcpy(m_pchPropName, szArg);
                goto FOUND_IT;
            }
        }
        else
        {
            // we already found whatever we're searching for
            break;
        }
    }

    return S_FALSE; // means "no variables were written to"

FOUND_IT:

    // found searched-for DISPID or property name
    if (m_dwFlags & (VIOTMD_GETPROP | VIOTMD_PUTPROP))
    {
        // the caller of AllocVariantIOToMapDISPID() wants the value of the
        // found property to be copied to <m_pvar>, or wants the value of the
        // found property to be set to <m_pvar>

        // set <vp> to be the property to get/put
        ANSIToUNICODE(oach, szArg, sizeof(oach) / sizeof(*oach));
        vp.bstrPropName = SysAllocString(oach);
        if (m_dwFlags & VIOTMD_PUTPROP)
            VariantCopy(&vp.varValue, m_pvar);

        // get/put <vp>
        if (FAILED(hrReturn = AllocPropertyBagOnVariantProperty(&vp, 0, &ppb)))
            goto ERR_EXIT;
        if (FAILED(hrReturn = PersistVariantIO(ppb,
                ((m_dwFlags & VIOTMD_PUTPROP) ? VIO_ISLOADING : 0),
                szArg, vtArg, pvArg, NULL)))
            goto ERR_EXIT;

        // if requested, copy the value of the property to <m_pvar>
        if (m_dwFlags & VIOTMD_GETPROP)
            VariantCopy(m_pvar, &vp.varValue);
    }

    hrReturn = IsLoading();
    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (ppb != NULL)
        ppb->Release();
    VariantPropertyClear(&vp);

    return hrReturn;
}

HRESULT __cdecl CVariantIOToMapDISPID::Persist(DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // Because CVariantIOToMapDISPID::Persist is used for IDispatch rather 
	// than file load/save, we always want to persist all values.  So, we
	// turn off VIO_ZEROISDEFAULT.  If that flag were on, properties with
	// zero values would not be persisted.
	dwFlags = dwFlags & ~VIO_ZEROISDEFAULT;

	// start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // fire the event with the specified arguments
    hrReturn = PersistList(dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}

STDMETHODIMP CVariantIOToMapDISPID::IsLoading()
{
    return (m_dwFlags & VIOTMD_PUTPROP) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\dispid.cpp ===
// dispid.cpp
//
// Implements DispatchNameToID and DispatchIDToName.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"


/* @func DISPID | DispatchNameToID |

        Look up a <i IDispatch> member name (e.g. the name of a method
        or property) in a list of names and return the DISPID of the
        member name (if found).

@rdesc  Returns the DISPID of <p szName> if <p szName> is found in
        <p szList>.  Returns -1 if <p szName> is not found.

@parm   char * | szList | The list of member names to look up <p szName> in.
        <p szList> consists of the concatenation of each member name,
        where each member name is terminated by a newline character
        (e.g. "Foo\\nBar\\n").

@parm   char * | szName | The member name to look up.

@ex     The following line of code sets <p dispid> to 2. |

        dispid = DispatchNameToID("Foo\\nBar\\n", "bar");
*/
STDAPI_(DISPID) DispatchNameToID(char *szList, char *szName)
{
    for (DISPID dispid = 1; ; dispid++)
    {
        // make <pch> point to the next '\n' in <szList>
        for (char *pch = szList; *pch != '\n'; pch++)
            if (*pch == 0)
                return -1; // <szName> not found in <szList>

        // see if <szName> matches the next name in <szList>
        char ach[200];
        lstrcpyn(ach, szList, (DWORD) (pch - szList + 1));
        if (lstrcmpi(ach, szName) == 0)
            return dispid;

        // go to the next name in <szList>
        szList = pch + 1;
    }
}


/* @func DISPID | DispatchIDToName |

        Look up a DISPID in a list of names of methods and properties and
        return the member name (if found).

@rdesc  Returns a pointer to member number <p dispid> in <p szList> if found,
        or NULL if not found.  Note that the returned string is terminated
        by a newline character, not a null character -- user <p ppch> to
        copy the string (see the example below).

@parm   char * | szList | The list of member names to look up <p szName> in.
        <p szList> consists of the concatenation of each member name,
        where each member name is terminated by a newline character
        (e.g. "Foo\\nBar\\n").

@parm   DISPID | dispid | The member ID to look up.  The first member in
        <p szList> has DISPID 1; the second 2, and so on.

@ex     The following code stores "Bar" in <p ach>. |

        int cch;
        char ach[100];
        char *sz;
        DISPID dispid = 2;
        sz = DispatchIDToName("Foo\nBar\n", dispid, &cch);
        if (sz != NULL)
            lstrcpyn(ach, sz, cch + 1);
*/
STDAPI_(char *) DispatchIDToName(char *szList, DISPID dispid, int *pcch)
{
    if (dispid < 1)
        return NULL;

    while (TRUE)
    {
        // make <pch> point to the next '\n' in <szList>
        for (char *pch = szList; *pch != '\n'; pch++)
            if (*pch == 0)
                return NULL; // <dispid> not found in <szList>

        if (--dispid == 0)
        {
            // this is the member name we're looking for
            *pcch = (DWORD) (pch - szList);
            return szList;
        }

        // go to the next name in <szList>
        szList = pch + 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\brush.cpp ===
// brush.cpp
//
// Implements CreateBorderBrush.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HBRUSH | CreateBorderBrush |

        Creates and returns a hatch pattern brush used to draw control
        resize borders and grab handles.

@rdesc  Returns a handle to the created brush.  The caller is responsible
        for freeing the brush using <f DeleteObject>.

@comm   The returned brush is the standard brush for use in drawing
        control borders and grab handles.
*/
STDAPI_(HBRUSH) CreateBorderBrush()
{
    HBRUSH          hbr = NULL;     // created brush
    HBITMAP         hbm = NULL;     // bitmap that contains brush pattern

    // set <awHatchPattern> to be the hatch brush pattern
    WORD awHatchPattern[8];
    WORD wPattern = 0x7777; // 0x1111 (dark), 0x3333 (med.), or 0x7777 (light)
    for (int i = 0; i < 4; i++)
    {
        awHatchPattern[i] = wPattern;
        awHatchPattern[i+4] = wPattern;
        wPattern = (wPattern << 1) | (wPattern >> 15); // rotate left 1 bit
    }

    // set <hbm> to be a bitmap containing the hatch brush pattern
    if ((hbm = CreateBitmap(8, 8, 1, 1, &awHatchPattern)) == NULL)
        goto ERR_EXIT;

    // set <hbr> to be a brush containing the pattern in <hbm>
    if ((hbr = CreatePatternBrush(hbm)) == NULL)
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    if (hbr != NULL)
        DeleteObject(hbr);
    hbr = NULL;
    goto EXIT;

EXIT:

    if (hbm != NULL)
        DeleteObject(hbm);

    return hbr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\debug.h ===
// debug.h
//
// Debugging functions.


#include "Globals.h"


//////////////////////////////////////////////////////////////////////////////
// TRACE, ASSERT, VERIFY
//
// These are the same as MFC's functions of the same name (but are implemented
// without using MFC).  See "debug.h" for the actual macro definitions.
//

#ifdef _DEBUG

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine);
void __cdecl Trace(LPCTSTR lpszFormat, ...);
#define TRACE              ::Trace
#define THIS_FILE          __FILE__
#define ASSERT(f) \
    do \
    { \
    if (!(f) && AssertFailedLine(THIS_FILE, __LINE__)) \
        DebugBreak(); \
    } while (0) \

#define VERIFY(f)          ASSERT(f)

#else // #ifndef _DEBUG

#define ASSERT(f)          ((void)0)
#define VERIFY(f)          ((void)(f))
inline void __cdecl Trace(LPCTSTR, ...) { }
#define TRACE              1 ? (void)0 : ::Trace

#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
// DebugIIDName, DebugCLSIDName
//
// These functions convert an IID or CLSID to a string name for debugging
// purposes (e.g. IID_IUnknown is converted to "IUnknown").
//

#ifdef _DEBUG
LPCSTR DebugIIDName(REFIID riid, LPSTR pchName);
LPCSTR DebugCLSIDName(REFCLSID rclsid, LPSTR pchName);
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\disphelp.cpp ===
// disphelp.cpp
//
// Implements IDispatch helper functions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | DispatchInvokeList |

        Calls <om IDispatch.Invoke> on a given <i IDispatch> object, passing
        arguments specified as a va_list array.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The ID of the property or method to invoke.  See
        <om IDispatch.Invoke> for more information.

@parm   WORD | wFlags | May be one of the following values (see
        <om IDispatch.Invoke> for more information):

        @flag   DISPATCH_METHOD | The member <p dispid> is being invoked as a
                method.  If a property has the same name, both this and the
                DISPATCH_PROPERTYGET flag may be set.

        @flag   DISPATCH_PROPERTYGET | The member <p dispid> is being retrieved
                as a property or data member.

        @flag   DISPATCH_PROPERTYPUT | The member <p dispid> is being changed
                as a property or data member.

@parm   VARIANT * | pvarResult | Where to store the return value from the
        method or property-get call.  If <p pvarResult> is NULL, the result
        (if any) is discarded.  If <p pvarResult> is non-NULL, then it is the
        caller's responsibility to call <f VariantClear>(<p pvarResult>)
        on exit (but the caller doesn't have to call
        <f VariantInit>(<p pvarResult>) on entry).

@parm   va_list | args | The arguments to pass to the method or property.
        See <f DispatchInvoke> for a description of the organization of
        <p args>.

@comm   Named arguments are not supported by this function.
*/
STDAPI DispatchInvokeList(IDispatch *pdisp, DISPID dispid,
    WORD wFlags, VARIANT *pvarResult, va_list args)
{
    HRESULT         hrReturn = S_OK; // function return code
    VARIANTARG      ava[20];        // parameters
    VARIANTARG *    pva;            // pointer into <ava>
    int             cva = 0;        // number of items stored in <ava>
    DISPPARAMS      dp;             // parameters to Invoke
    VARIANT         varResultTmp;   // temporary result storage
    LPSTR           sz;
    OLECHAR         aoch[300];
    VARTYPE         vt;

    // loop once for each (VARTYPE, value) pair in <args>;
    // store arguments in <ava> (last argument first, as required by
    // Invoke()); on exit <pva> points to the last argument and
    // <cva> is the number of arguments
    pva = ava + (sizeof(ava) / sizeof(*ava));
    while (TRUE)
    {
        if ((vt = va_arg(args, VARTYPE)) == 0)
            break;
        if (--pva == ava)
            goto ERR_FAIL; // too many arguments
        cva++;
        pva->vt = vt;
        switch (pva->vt)
        {
        case VT_I2:
            pva->iVal = va_arg(args, short);
            break;
        case VT_I4:
            pva->lVal = va_arg(args, long);
            break;
        case VT_INT:
            pva->vt = VT_I4;
            pva->lVal = va_arg(args, int);
            break;
        case VT_R4:
			// Note that when an argument of type float is passed in a variable
			// argument list, the compiler actually converts the float to a
			// double and pushes the double onto the stack.

            V_R4(pva) = float( va_arg(args, double) );
            break;
        case VT_R8:
            V_R8(pva) = va_arg(args, double);
            break;
        case VT_BOOL:
            V_BOOL(pva) = (va_arg(args, BOOL) == 0 ? 0 : -1);
            break;
        case VT_BSTR:
            if ( (pva->bstrVal = va_arg(args, LPOLESTR)) &&
                 ((pva->bstrVal = SysAllocString(pva->bstrVal)) == NULL) )
                goto ERR_OUTOFMEMORY;
            break;
        case VT_DISPATCH:
			V_DISPATCH(pva) = va_arg(args, LPDISPATCH);
            if (V_DISPATCH(pva) != NULL)
                V_DISPATCH(pva)->AddRef();
            break;
        case VT_UNKNOWN:
			V_UNKNOWN(pva) = va_arg(args, LPUNKNOWN);
            if (V_UNKNOWN(pva) != NULL)
                V_UNKNOWN(pva)->AddRef();
            break;
        case VT_VARIANT:
            VariantInit(pva);
            if (FAILED(hrReturn = VariantCopy(pva, &va_arg(args, VARIANT))))
                goto ERR_EXIT;
            break;
        case VT_LPSTR:
            sz = va_arg(args, LPSTR);
            pva->vt = VT_BSTR;
            MultiByteToWideChar(CP_ACP, 0, sz, -1, aoch,
                sizeof(aoch) / sizeof(*aoch));
            if ((pva->bstrVal = SysAllocString(aoch)) == NULL)
                goto ERR_OUTOFMEMORY;
            break;
        default:
            pva++;
            cva--;
            goto ERR_FAIL;
        }
    }

    // fill in <dp> with information about the arguments
    dp.rgvarg = pva;
    dp.cArgs = cva;

	// If we're setting a property, must initialize named args fields.
	// The Dispatch implementation created by CreateStdDispatch requires this.
	DISPID dispidNamedArgs;
	if (wFlags & DISPATCH_PROPERTYPUT)
	{
		// (Note that this works fine for either a single- or a multiple-
		// parameter property.  DispatchInvokeList can also GET a multiple-
		// parameter property.)

		dp.rgdispidNamedArgs = &dispidNamedArgs;
		dp.rgdispidNamedArgs[0] = DISPID_PROPERTYPUT;
		dp.cNamedArgs = 1;
	}
	else
	{
		dp.rgdispidNamedArgs = NULL;
		dp.cNamedArgs = 0;
	}

    // make <pvarResult> point to a valid VARIANT
    if (pvarResult == NULL)
        pvarResult = &varResultTmp;
    VariantInit(pvarResult);

    // invoke the method
    if (FAILED(hrReturn = pdisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
            wFlags, &dp, pvarResult, NULL, NULL)))
        goto ERR_EXIT;

    goto EXIT;

ERR_FAIL:

    hrReturn = E_FAIL;
    goto ERR_EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)

    goto EXIT;

EXIT:

    // normal cleanup
    while (cva-- > 0)
        VariantClear(pva++);
    if (pvarResult == &varResultTmp)
        VariantClear(pvarResult);

    return hrReturn;
}


/* @func HRESULT | DispatchInvoke |

        Calls <om IDispatch.Invoke> on a given <i IDispatch> object, passing
        arguments specified as a variable-length list of arguments.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The ID of the property or method to invoke.  See
        <om IDispatch.Invoke> for more information.

@parm   WORD | wFlags | May be one of the following values (see
        <om IDispatch.Invoke> for more information):

        @flag   DISPATCH_METHOD | The member <p dispid> is being invoked as a
                method.  If a property has the same name, both this and the
                DISPATCH_PROPERTYGET flag may be set.

        @flag   DISPATCH_PROPERTYGET | The member <p dispid> is being retrieved
                as a property or data member.

        @flag   DISPATCH_PROPERTYPUT | The member <p dispid> is being changed
                as a property or data member.

@parm   VARIANT * | pvarResult | Where to store the return value from the
        method or property-get call.  If <p pvarResult> is NULL, the result
        (if any) is discarded.  If <p pvarResult> is non-NULL, then it is the
        caller's responsibility to call <f VariantClear>(<p pvarResult>)
        on exit (but the caller doesn't have to call
        <f VariantInit>(<p pvarResult>) on entry).

@parm   (varying) | (arguments) | The arguments to pass to the method or
        property.  These must consist of N pairs of arguments followed by
        a 0 (zero value).  In each pair, the first argument is a VARTYPE
        value that indicates the type of the second argument.  The following
        VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int.  <f Invoke>
                passes this as VT_I4, so this parameter should be declared
                as a Long in BASIC.

        @flag   VT_I2 | The following argument is a short.  In BASIC
                this parameter should be declared as Integer.

        @flag   VT_I4 | The following argument is a long.  In BASIC
                this parameter should be declared as Long.

        @flag   VT_R4 | The following argument is a float.  In BASIC
                this parameter should be declared as Single.

        @flag   VT_R8 | The following argument is a double.  In BASIC
                this parameter should be declared as Double.

        @flag   VT_BOOL | The following argument is a BOOL (<y not> a
                VARIANT_BOOL).  In BASIC this parameter should be declared
                as Boolean or Integer.  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR or an OLECHAR *.
				In BASIC this parameter should be declared as String.

        @flag   VT_LPSTR | The following argument is an LPSTR.  <f Invoke>
                passes this as a BSTR, so this parameter should be declared
                as a String in BASIC.  Note that this behavior differs
                from the usual definition of VT_LPSTR.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH.  In
                BASIC this parameter should be declared as an Object.

        @flag   VT_UNKNOWN | The following argument is an LPUNKNOWN.

        @flag   VT_VARIANT | The following arguement is a VARIANT that is
                passed as-is to <f Invoke>.  This allows arbitrary parameters
                to be passed using this function.  Note that this behavior
                differs from the usual definition of VT_VARIANT.

@comm   Named arguments are not supported by this function.

        Don't forget to add a 0 argument to the end of the argument list.

@ex     If a control has a "put" property that looks like this in ODL: |

        [propput, id(DISPID_TABSTOP)]
        HRESULT TabStop([in] float flTabStop)

@ex     then the property can be set with DispatchInvoke using the following
		code: |

        DispatchInvoke(pdisp, DISPID_TABSTOP, DISPATCH_PROPERTYPUT, NULL, VT_R4, flTabStop, 0);

@ex		If the ODL for the corresponding "get" property looks like this: |

        [propget, id(DISPID_TABSTOP)]
        HRESULT TabStop([out, retval] float *pflTabStop);

@ex     then the property can be read as follows: |

		VARIANT varResult;
        DispatchInvoke(pdisp, DISPID_TABSTOP, DISPATCH_PROPERTYGET, &varResult, 0);

@ex     The property value is stored as a VT_R4 in varResult.

		If the control has a SetText method with this ODL description: |

        [id(DISPID_SETTEXT)]
        HRESULT SetText([in] BSTR bstrText, [in] long lSize, [in] BOOL fBold);

@ex     then the method can be called with the following code: |
        
        DispatchInvoke(pdisp, DISPID_SETTEXT, DISPATCH_METHOD, NULL, VT_LPSTR, "Hello", VT_I4, 12, VT_BOOL, FALSE, 0);

@ex     (Note that DispatchInvoke copies the VT_LPSTR parameter to a BSTR before
		passing it to SetText.  You can also pass in a BSTR or an OLECHAR* for
		the first parameter.)

		If a method has an "out" parameter that is marked as "retval" in ODL,
		then DispatchInvoke stores that parameter in varResult.  If the method
		looks like this, for example: |

        [id(DISPID_GETROTATION)]
        HRESULT GetRotation([in] long iCell, [out, retval] float *pflRotation);

@ex		then GetRotation should be called like this: |

		VARIANT varResult;
		DispatchInvoke(pdisp, DISPID_GETROTATION, DISPATCH_METHOD, &varResult, VT_I4, iCell, 0);

@ex 	In this example, flRotation gets stored in varResult as a VT_R4.

		If you need to pass in a type that is not directly supported by
		DispatchInvoke, you can use VT_VARIANT.  Let's say the control has a
		GetFormat method that looks like this: |

        [id(DISPID_GETFORMAT)]
        HRESULT GetFormat([out] long *lColor, [out] BOOL *pfBold);
        
@ex 	This takes a pointer-to-long and a pointer-to-BOOL, neither of which
		can be passed directly to DispatchInvoke.  You can, however, use
		VARIANTs to call GetFormat: |

		long lColor;
		BOOL fBold;
		VARIANT varColor, varBold;

		VariantInit(&varColor);
		V_VT(&varColor) = VT_I4 | VT_BYREF;
		V_I4REF(&varColor) = &lColor;
		VariantInit(&varBold);
		V_VT(&varBold) = VT_BOOL | VT_BYREF;
		V_BOOLREF(&varBold) = &fBold;

		DispatchInvoke(pdisp, DISPID_GETFORMAT, DISPATCH_METHOD, NULL, VT_VARIANT, varColor, VT_VARIANT, varBold, 0);

*/
HRESULT __cdecl DispatchInvoke(IDispatch *pdisp, DISPID dispid,
    WORD wFlags, VARIANT *pvarResult, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, pvarResult);

    hrReturn = DispatchInvokeList(pdisp, dispid, wFlags, pvarResult, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @func HRESULT | DispatchPropertyPut |

        Sets the value of a given property on a given <i IDispatch> object.
        Used to help call <om IDispatch.Invoke>.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The ID of the property.  See <om IDispatch.Invoke>
        for more information.

@parm   VARTYPE | vt | The type of the <p value> parameter.  The valid values
        for <p vt> are the same as the VT_ values documented in
        <f DispatchInvoke>.

@parm   (varying) | value | The new property value.

@comm   Properties with parameters are not supported -- use
        <f DispatchInvoke> instead.
*/


/* @func HRESULT | DispatchPropertyGet |

        Gets the value of a given property on a given <i IDispatch> object.
        Used to help call <om IDispatch.Invoke>.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The ID of the property.  See <om IDispatch.Invoke>
        for more information.

@parm   VARIANT * | pvarResult | Where to store the return value from the
        method or property-get call.  It is the caller's responsibility to
        call <f VariantClear>(<p pvarResult>) on exit (but the caller doesn't
        have to call <f VariantInit>(<p pvarResult>) on entry).

@comm   Properties with parameters are not supported -- use
        <f DispatchInvoke> instead.
*/


/* @func HRESULT | DispatchGetArgsList |

        Retrieves arguments from a DISPPARAMS structure passed to
        <om IDispatch.Invoke>.  Arguments are stored in variables that
        are passed to <f DispatchGetArgsList> as a va_list array.
        Used to help implement <om IDispatch.Invoke>.

@rvalue S_OK |
        Success.

@rvalue DISP_E_BADPARAMCOUNT |
        The number of arguments in <p pdp> doesn't match the number of
        arguments specified in <p args>.

@rvalue DISP_E_BADVARTYPE |
        One of the VARTYPE values in <p args> is invalid.

@rvalue DISP_E_TYPEMISMATCH |
        One of the arguements in <p pdp> could not be coerced to the type
        of the corresponding parameter in <p args>.

@parm   DISPPARAMS * | pdp | The structure to retrieve arguments from.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   DGA_EXTRAOK | Don't return an error code if <p pdp> contains
                more actual arguments than the number of formal parameters
                specified in <p args>.  Instead, just ignore the extra
                arguments in <p pdp>.

        @flag   DGA_FEWEROK | Don't return an error code if <p pdp> contains
                fewer actual arguments than the number of formal parameters
                specified in <p args>.  Instead, ignore the extra parameters.
                In this case, the variables pointed to by elements of <p args>
                should be pre-initialized to default values before this
                function is called.

@parm   va_list | args | A list of pointers to variables which will receive
        the arguments from <p pdp>.  See <f DispatchGetArgs> for a description
        of the organizatin of <p args>.  In the event of an error, all
		BSTR <p args> are freed and the corresponding arguments are set to NULL;
*/
STDAPI DispatchGetArgsList(DISPPARAMS *pdp, DWORD dwFlags, va_list args)
{
    HRESULT         hrReturn = S_OK; // function return code
    VARIANTARG *    pva;            // pointer into <pdp->rgvarg>
    LPVOID          pvArg;          // where to store an argument
    VARTYPE         vtArg;          // the type that <pvArg> points to
    VARIANT         var;
    VARTYPE         vt;
	va_list			args_pre = args;
	va_list			args_post = args;
						// used to pre- and post-traverse the <args> list

    // ensure correct error cleanup
    VariantInit(&var);

	// set all the BSTR arguments to NULL so we can tell what needs to
	// be cleaned up below in the event of an error
	while ((vtArg = va_arg(args_pre, VARTYPE)) != 0)
	{
		pvArg = va_arg(args_pre, LPVOID);
		if (vtArg == VT_BSTR)
		{
			*((BSTR*)pvArg) = NULL;
		}
	}
	va_end(args_pre);

    // loop once for each (VARTYPE, value) pair in <args>;
    // retrieve arguments from <pdp->rgvarg> (last argument first, as
    // required by Invoke()); on exit <pva> should point to the first
    // argument in <pdp->rgvarg>
    pva = pdp->rgvarg + pdp->cArgs;
    while (TRUE)
    {
        // set <pvArg> to point to the variable that is to receive the
        // value of the next element of <rgvarg>, and set <vtArg> to the
        // type of variable that <pvArg> points to
        if ((vtArg = va_arg(args, VARTYPE)) == 0)
        {
            // we ran out of formal parameters (in <args>) -- if we have *not*
            // yet run out of actual arguments (in <pdp>) then we need to
            // return a DISP_E_BADPARAMCOUNT error, unless the caller has
            // asked us to relax this rule
            if ((pva != pdp->rgvarg) && !(dwFlags & DGA_EXTRAOK))
                goto ERR_BADPARAMCOUNT; // more arguments than parameters
            break;
        }
        pvArg = va_arg(args, LPVOID);

        // set <pva> to the next element of <rgvarg>, corresponding to
        // <pvArg> and <vtArg>
        if (pva-- == pdp->rgvarg)
        {
            // we ran out of actual arguments (in <pdp>) before running out
            // of formal parameters (in <args>) -- we need to return a
            // DISP_E_BADPARAMCOUNT error, unless the caller has asked us to
            // relax this rule
            if (dwFlags & DGA_FEWEROK)
                break;
            goto ERR_BADPARAMCOUNT;
        }

        // store the value of <pva> into <pvArg> (correctly coerced to
        // the type of <pvArg>)
        if (vtArg == VT_VARIANT)
            *((VARIANT *) pvArg) = *pva;
        else
        {
            // try to coerce <pva> to the type <vtArg>; store the result
            // into <var>
            VariantClear(&var);
            if (vtArg == VT_INT)
                vt = VT_I4;
            else
            if (vtArg == VT_LPSTR)
                vt = VT_BSTR;
            else
                vt = vtArg;
            if (FAILED(hrReturn = VariantChangeType(&var, pva, 0, vt)))
                goto ERR_EXIT;

            // copy from <var> to <*pvArg>
            switch (vtArg)
            {
            case VT_I2:
                *((short *) pvArg) = var.iVal;
                break;
            case VT_I4:
            case VT_INT:
                *((long *) pvArg) = var.lVal;
                break;
            case VT_R4:
                *((float *) pvArg) = V_R4(&var);
                break;
            case VT_R8:
                *((double *) pvArg) = V_R8(&var);
                break;
            case VT_BOOL:
                *((BOOL *) pvArg) = (V_BOOL(&var) == 0 ? 0 : 1);
                break;
            case VT_BSTR:
                *((BSTR *) pvArg) = var.bstrVal;
                VariantInit(&var); // prevent VariantClear clearing var.bstrVal
                break;
            case VT_DISPATCH:
                *((LPDISPATCH *) pvArg) = var.pdispVal;
                break;
            case VT_UNKNOWN:
                *((LPUNKNOWN *) pvArg) = var.punkVal;
                break;
            case VT_LPSTR:
				if (UNICODEToANSI(LPSTR(pvArg), var.bstrVal, _MAX_PATH) == 0)
				{
					// The string couldn't be converted.  One cause is a string
					// that's longer than _MAX_PATH characters, including the
					// NULL.

					hrReturn = DISP_E_OVERFLOW;
					goto ERR_EXIT;
				}
                break;
            default:
                hrReturn = DISP_E_BADVARTYPE;
                goto ERR_EXIT;
            }
        }
    }

    goto EXIT;

ERR_BADPARAMCOUNT:

    hrReturn = DISP_E_BADPARAMCOUNT;
    goto ERR_EXIT;

ERR_EXIT:

    // Error cleanup: free all BSTRs and set all IDispatch and IUnknown
	// pointers to NULL.  Failure to do the latter could cause problems if the
	// caller has error clean-up code that releases non-NULL pointers.
	while ((vtArg = va_arg(args_post, VARTYPE)) != 0)
	{
		pvArg = va_arg(args_post, LPVOID);
		if (vtArg == VT_BSTR)
		{
			SysFreeString(*((BSTR*)pvArg));
			*((BSTR*)pvArg) = NULL;
		}
		else if (vtArg == VT_DISPATCH)
		{
			*((LPDISPATCH*)pvArg) = NULL;
		}
		else if (vtArg == VT_UNKNOWN)
		{
			*((LPUNKNOWN*)pvArg) = NULL;
		}
	}
	va_end(args_post);
    goto EXIT;

EXIT:

    // normal cleanup
    VariantClear(&var);

    return hrReturn;
}


/* @func HRESULT | DispatchGetArgs |

        Retrieves arguments from a DISPPARAMS structure passed to
        <om IDispatch.Invoke>.  Arguments are stored in variables that
        are passed to <f DispatchGetArgs> as a va_list array.
        Used to help implement <om IDispatch.Invoke>.

@rvalue S_OK |
        Success.

@rvalue DISP_E_BADPARAMCOUNT |
        The number of arguments in <p pdp> doesn't match the number of
        arguments specified in <p (arguments)>.

@rvalue DISP_E_BADVARTYPE |
        One of the VARTYPE values in <p (arguments)> is invalid.

@rvalue DISP_E_TYPEMISMATCH |
        One of the arguements in <p pdp> could not be coerced to the type
        of the corresponding parameter in <p (arguments)>.

@rvalue DISP_E_OVERFLOW |
		A VT_LPSTR argument in <p pdp> is longer than _MAX_PATH characters
		(including the terminating NULL).  The longest VT_LPSTR that can be
		retrieved is _MAX_PATH characters, including the NULL.

@parm   DISPPARAMS * | pdp | The structure to retrieve arguments from.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   DGA_EXTRAOK | Don't return an error code if <p pdp> contains
                more actual arguments than the number of formal parameters
                specified in <p (arguments)>.  Instead, just ignore the extra
                arguments in <p pdp>.

        @flag   DGA_FEWEROK | Don't return an error code if <p pdp> contains
                fewer actual arguments than the number of formal parameters
                specified in <p (arguments)>.  Instead, ignore the extra
                parameters.  In this case, the variables pointed to by
                elements of <p (arguments)> should be pre-initialized to
                default values before this function is called.

@parm   (varying) | (arguments) | A list of pointers to variables which will
        receive the values of arguments from <p pdp>.  These must consist of N
        pairs of arguments followed by a 0 (zero value).  In each pair, the
        first argument is a VARTYPE value that indicates the type of variable
        that the the second argument points to.  (The actual arguments in
        <p pdp> will be coerced to the types specified in <p (arguments)>,
        if possible.) The following VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int *.

        @flag   VT_I2 | The following argument is a short *.

        @flag   VT_I4 | The following argument is a long *.

        @flag   VT_R4 | The following argument is a float *.

        @flag   VT_R8 | The following argument is a double *.

        @flag   VT_BOOL | The following argument is a BOOL * (<y not> a
                VARIANT_BOOL *).  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR *.  If the function
				succeeds, the caller of <f DispatchGetArgs> should free this 
				BSTR using <f SysFreeString>.  If the function fails, the
				BSTR is automatically freed, and the argument is set to 
				NULL.  <b IMPORTANT:> This behavior has changed:
                previously the caller was <b NOT> supposed to free this BSTR.
                (Note that the caller must free the BSTR because it may
                have been coerced from e.g. an integer.)

        @flag   VT_LPSTR | The following argument is an LPSTR that points
                to a char array capable of holding at least _MAX_PATH
                characters, including the terminating NULL.  (You should
				declare this as "char achArg[_MAX_PATH]".)  If the string in
				<p pdp> is too long for the LPSTR, DISP_E_OVERFLOW is returned.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH *.
                The caller of <f DispatchGetArgs> should not call <f Release>
                on this LPDISPATCH.

        @flag   VT_UNKNOWN | The following argument is an LPUNKNOWN *.
                The caller of <f DispatchGetArgs> should not call <f Release>
                on this LPUNKNOWN.

        @flag   VT_VARIANT | The following arguement is a VARIANT *.
                This allows arbitrary parameters to be passed using this
                function.  Note that this behavior differs from the usual
                definition of VT_VARIANT.  The caller of <f DispatchGetArgs>
				should not call VariantClear on this VARIANT.

@ex     The following example shows two parameters, an integer and a string,
        being retrieved from <p pdispparams> and stored into <p i> and
        <p ach>. |

        int i;
        char ach[_MAX_PATH];
        DispatchGetArgs(pdispparams, 0, VT_INT, &i, VT_LPSTR, ach, 0);
*/
HRESULT __cdecl DispatchGetArgs(DISPPARAMS *pdp, DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // copy arguments from <pdp> to <args>
    hrReturn = DispatchGetArgsList(pdp, dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @func HRESULT | DispatchHelpGetIDsOfNames |

        Helps implement <om IDispatch.GetIDsOfNames> given a string that
        contains the list of <i IDispatch> member names.

@rdesc  Returns the same return codes as <om IDispatch.GetIDsOfNames>.

@parm   REFIID | riid | As defined for <om IDispatch.GetIDsOfNames>.

@parm   LPOLESTR * | rgszNames | As defined for <om IDispatch.GetIDsOfNames>.

@parm   UINT | cNames | As defined for <om IDispatch.GetIDsOfNames>.

@parm   LCID | lcid | As defined for <om IDispatch.GetIDsOfNames>.

@parm   DISPID * | rgdispid | As defined for <om IDispatch.GetIDsOfNames>.

@parm   char * | szList | The list of member names.  Each name in the list
        must be terminated by a newline.  The first member name is assigned
        DISPID value 0, the second 1, and so on.  For example, if <p szList>
        is "\\nFoo\\nBar\\n", then "Foo" is assigned DISPID value 1 and "Bar"
        is assigned 2 (because, in this example, the first string in <p szList>
        is "").
*/
STDAPI DispatchHelpGetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid, const char *szList)
{
    DISPID *        pdispid;        // pointer into <rgdispid>
    UINT            cdispid;        // count of unprocessed <pdispid> items
    char            ach[200];

    // nothing to do if there are no names to convert to IDs
    if (cNames == 0)
        return S_OK;

    // set rgdispid[0] to the DISPID of the property/method name
    // rgszNames[0], or to -1 if the name is unknown
    UNICODEToANSI(ach, *rgszNames, sizeof(ach));
    *rgdispid = FindStringByValue(szList, ach);

    // fill the other elements of the <rgdispid> array with -1 values,
    // because we don't support named arguments
    for (pdispid = rgdispid + 1, cdispid = cNames - 1;
         cdispid > 0;
         cdispid--, pdispid++)
        *pdispid = -1;

    // if any names were unknown, return DISP_E_UNKNOWNNAME
    if ((*rgdispid == -1) || (cNames > 1))
        return DISP_E_UNKNOWNNAME;

    return S_OK;
}


/* @func HRESULT | VariantFromString |

        Initializes a VARIANT to contain the copy of an LPCTSTR string.

@rvalue S_OK | Success.

@rvalue E_OUTOFMEMORY | Out of memory.
@rvalue E_POINTER | One of the input pointers is NULL.

@parm   VARIANT * | pvarDst | A caller-supplied VARIANT structure to
        initialize.  The initial contents of <p pvarDst> are ignored;
        the caller does not need to call <f VariantInit> before
        calling <f VariantFromString>.  Both <p pvarDst>-<gt><p vt> and
        <p pvarDst>-<gt><p bstrVal> are initialized by this function.

@parm   LPCTSTR | szSrc | The string to copy.  Can't be NULL.
*/
STDAPI VariantFromString(VARIANT *pvar, LPCTSTR szSrc)
{
	if (NULL == pvar || szSrc == NULL)
		return E_POINTER;

    int cch = lstrlen(szSrc);
    if ((pvar->bstrVal = SysAllocStringLen(NULL, cch)) == NULL)
        return E_OUTOFMEMORY;
    ANSIToUNICODE(pvar->bstrVal, szSrc, cch + 1);
        // cch + 1 to account for terminal '\0' appended by SysAllocString()
    pvar->vt = VT_BSTR;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\cci.cpp ===
// cci.cpp
//
// Implements CreateControlInstance.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | CreateControlInstance |

        Creates a new instance of a control given either a class ID (in
        string form) or a ProgID.

@parm   LPCSTR | szName | The class ID or ProgID of the control to create.

@parm   LPUNKNOWN | punkOuter | The controlling unknown to use for the
        new object.

@parm   DWORD | dwClsContext | Specifies the context in which the executable
        is to be run. The values are taken from the enumeration CLSCTX.
        A typical value is CLSCTX_INPROC_SERVER.

@parm   LPUNKNOWN * | ppunk | Where to store the pointer to the loaded object.
        NULL is stored in *<p ppunk> on error.

@parm   CLSID * | pclsid | Where to store the class ID of the loaded object.
        If <p pclsid> is NULL then this information is not returned.

@parm	BOOL * | pfSafeForScripting | If non-NULL, *<p pfSafeForScripting> is
		set to TRUE or FALSE depending on whether the control is safe-for-scripting.

@parm	BOOL * | pfSafeForInitializing | If non-NULL, *<p pfSafeForInitializing> is
		set to TRUE or FALSE depending on whether the control is safe-for-initializing.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.
*/
STDAPI CreateControlInstance(LPCSTR szName, LPUNKNOWN punkOuter,
    DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid, 
	BOOL* pfSafeForScripting, BOOL* pfSafeForInitializing, DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    OLECHAR         aochName[200];  // <szName> converted to UNICODE
    CLSID           clsid;          // class ID of control
    IPersistPropertyBag *pppb = NULL; // interface on control
    IPersistStreamInit *ppsi = NULL; // interface on control

    // ensure correct cleanup
    *ppunk = NULL;

    // find the class ID of the control based on <szName>
    ANSIToUNICODE(aochName, szName, sizeof(aochName) / sizeof(*aochName));
    if (FAILED(CLSIDFromString(aochName, &clsid)) &&
        FAILED(CLSIDFromProgID(aochName, &clsid)))
        goto ERR_FAIL;

    // create an instance of the control, and point <*ppunk> to it
    if (FAILED(hrReturn = CoCreateInstance(clsid, punkOuter,
            dwClsContext, IID_IUnknown, (LPVOID *) ppunk)))
        goto ERR_EXIT;

	// assess the control's safety
	if (pfSafeForScripting != NULL || pfSafeForInitializing != NULL)
		if (FAILED(hrReturn = GetObjectSafety(pfSafeForScripting, 
				pfSafeForInitializing, *ppunk, &clsid, &IID_IPersistPropertyBag,
				&IID_IPersistStream, &IID_IPersistStreamInit, NULL)))
			goto ERR_EXIT;

    // tell the control to initialize itself as a new object
    if (SUCCEEDED((*ppunk)->QueryInterface(IID_IPersistPropertyBag,
            (LPVOID *) &pppb)))
        pppb->InitNew();
    else
    if (SUCCEEDED((*ppunk)->QueryInterface(IID_IPersistStreamInit,
            (LPVOID *) &ppsi)))
        ppsi->InitNew();

    // return the class ID if requested by the caller
    if (pclsid != NULL)
        *pclsid = clsid;
    goto EXIT;

ERR_FAIL:

    hrReturn = E_FAIL;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    if (*ppunk != NULL)
        (*ppunk)->Release();
    *ppunk = NULL;
    goto EXIT;

EXIT:

    // normal cleanup
    if (pppb != NULL)
        pppb->Release();
    if (ppsi != NULL)
        ppsi->Release();

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\cus.cpp ===
// cus.cpp
//
// Implements CompareUNICODEStrings.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func int | CompareUNICODEStrings |

        Compares two UNICODE strings.  The comparison is case-insensitive.

@rdesc  Returns the same values as <f lstrcmpi>.

@parm   LPCWSTR | wsz1 | First string.  NULL is interpreted as a zero-length string.

@parm   LPCWSTR | wsz2 | Second string.  NULL is interpreted as a zero-length string.

@comm   Currently, neither <p wsz1> or <p wsz2> can be longer than
        _MAX_PATH characters.
*/
STDAPI_(int) CompareUNICODEStrings(LPCWSTR wsz1, LPCWSTR wsz2)
{
    char            ach1[_MAX_PATH]; // <wsz1> converted to ANSI
    char            ach2[_MAX_PATH]; // <wsz2> converted to ANSI

    UNICODEToANSI(ach1, wsz1, sizeof(ach1));
    UNICODEToANSI(ach2, wsz2, sizeof(ach2));
    return lstrcmpi(ach1, ach2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\connect.cpp ===
// connect.cpp
//
// Implements IConnectionPointContainer, IEnumConnectionPoint,
// IConnectionPoint, IEnumConnections.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"
#include "unklist.h"
#include "unkenum.h"


//////////////////////////////////////////////////////////////////////////////
// CConnect -- implements IConnectionPoint
//
// Note that CConnect doesn't have a reference count, because its lifetime
// is equal to the lifetime of its parent object (the one that impelements
// IConnectionPointContainer).  Instead, on AddRef we AddRef the parent,
// and likewise for Release.
//
// Important: CConnect assumes a zero-initializeing new() operator.
//

/* @object ConnectionPointHelper |

        Contains functions for implementing the <o ConnectionPointHelper>
        object, which provides a simple implementation of an
        <i IDispatch>-based and an <i IPropertyNotifySink>-based 
		<i IConnectionPoint>. Also contains helper
        functions for implementing <i IConnectionPointContainer> in the
        case where these are the only connections maintained by the connection
        point container.

@supint IConnectionPointHelper | Contains methods for firing events to
        the objects connected to this object via <i IConnectionPoint>.
        Also contains helper functions for implementing
        <i IConnectionPointContainer> in the container object.
*/

/* @interface IConnectionPointHelper |

        Contains functions for implementing the <o ConnectionPointHelper>
        object, which provides a simple implementation of an
        <i IDispatch>-based and an <i IPropertyNotifySink>-based 
		<i IConnectionPoint>.  Also contains helper
        functions for implementing <i IConnectionPointContainer> in the case
		where these are the only connections maintained by the connection
        point container.

@meth   HRESULT | FireEventList |

        Fire a given <i IDispatch>-based event on all objects (e.g. VBS)
        connected to this <o ConnectionPointHelper> object.  Parameters
        for the event are passed as a va_list array.

@meth   HRESULT | FireEvent |

        Fire a given <i IDispatch>-based event on all objects (e.g. VBS)
        connected to this <o ConnectionPointHelper> object.  Parameters
        for the event are passed as a varying argument list.

@meth   HRESULT | FireOnChanged |

        Fire a <i IPropertyNotifySink> event on all objects
        connected to this <o ConnectionPointHelper> object.

@meth   HRESULT | FireOnRequestEdit |

        Fire a <i IPropertyNotifySink> event on all objects 
        connected to this <o ConnectionPointHelper> object. 

@meth   HRESULT | EnumConnectionPoints |

        Helps implement <om IConnectionPointContainer.EnumConnectionPoints>
        in the case where this object implements the only connection maintained
        by the connection point container.

@meth   HRESULT | FindConnectionPoint |

        Helps implement <om IConnectionPointContainer.FindConnectionPoint>
        in the case where this object implements the only connection maintained
        by the connection point container.

@comm   To allocate an <o ConnectionPointHelper> object, call
        <f AllocConnectionPointHelper>.  To free the object, call
        <f FreeConnectionPointHelper> (not <f Release> -- see
        <f AllocConnectionPointHelper> for more information).

*/

struct CConnect : IConnectionPoint
{
///// state
    IUnknown *      m_punkParent;   // parent object
    IID             m_iid;          // outgoing (source) dispinterface
    CUnknownList    m_listConnect;  // list of connections
    int             m_cUnadvise;    // count of Unadvise() operations

///// IUnknown implementation
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IConnectionPoint interface
    STDMETHODIMP GetConnectionInterface(IID *pIID);
    STDMETHODIMP GetConnectionPointContainer(
        IConnectionPointContainer **ppCPC);
    STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD *pdwCookie);
    STDMETHODIMP Unadvise(DWORD dwCookie);
    STDMETHODIMP EnumConnections(LPENUMCONNECTIONS *ppEnum);
};

struct CConnectHelper : IConnectionPointHelper
{
///// state
    IUnknown *      m_punkParent;   // parent object
	CConnect *		m_pconDispatch;
	CConnect *		m_pconPropertyNotify;

///// IUnknown implementation
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IConnectionPointHelper interface
    STDMETHODIMP FireEventList(DISPID dispid, va_list args);
    HRESULT __cdecl FireEvent(DISPID dispid, ...);
    STDMETHODIMP FireOnChanged(DISPID dispid);
    STDMETHODIMP FireOnRequestEdit(DISPID dispid);
    STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS *ppEnum);
    STDMETHODIMP FindConnectionPoint(REFIID riid, LPCONNECTIONPOINT *ppCP);
	STDMETHODIMP Close(void);
};


//////////////////////////////////////////////////////////////////////////////
// CEnumConnections -- implements IEnumConnections
//

struct CEnumConnections : IEnumConnections
{
///// object state
    ULONG           m_cRef;         // object reference count
    CConnect *      m_pconnect;     // parent object
    CUnknownItem *  m_pitemCur;     // current item in list
    int             m_cUnadvise;    // see WasItemDeleted()

///// construction & destruction
    CEnumConnections(CConnect *pconnect)
    {
        m_cRef = 1;
        m_pconnect = pconnect;
        m_pconnect->AddRef();
        m_pitemCur = m_pconnect->m_listConnect.m_pitemCur;
        m_cUnadvise = m_pconnect->m_cUnadvise;
    }
    ~CEnumConnections()
    {
        m_pconnect->Release();
    }

///// WasItemDeleted() -- if item was deleted, reset <m_pitemCur>
///// to prevent Next() or Skip() from walking off the list
    BOOL WasItemDeleted()
    {
        if (m_cUnadvise != m_pconnect->m_cUnadvise)
        {
            m_cUnadvise = m_pconnect->m_cUnadvise;
            return TRUE;
        }
        else
            return FALSE;
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IEnumConnections))
        {
            *ppvObj = (IEnumConnections *) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_cRef == 0L)
        {
            Delete this;
            return 0;
        }
        else
            return m_cRef;
    }

///// IEnumConnections Methods
    STDMETHODIMP Next(ULONG celt, LPCONNECTDATA rgelt, ULONG *pceltFetched)
    {
        if (WasItemDeleted())
            Reset();
        if (pceltFetched != NULL)
            (*pceltFetched) = 0;
        while (celt > 0)
        {
            // set <m_pitemCur> to the next item in the list of connections
            if (m_pitemCur->m_pitemNext ==
                    &m_pconnect->m_listConnect.m_itemHead)
                return NULL;
            m_pitemCur = m_pitemCur->m_pitemNext;
            if (rgelt != NULL)
            {
                rgelt->pUnk = m_pitemCur->Contents();
                rgelt->dwCookie = m_pitemCur->m_dwCookie;
                rgelt++;
            }
            celt--;
            if (pceltFetched != NULL)
                (*pceltFetched)++;
        }

        return (celt == 0 ? S_OK : S_FALSE);
    }
    STDMETHODIMP Skip(ULONG celt)
    {
        if (WasItemDeleted())
            Reset();
        return Next(celt, NULL, NULL);
    }
    STDMETHODIMP Reset()
    {
        m_pitemCur = &m_pconnect->m_listConnect.m_itemHead;
        return S_OK;
    }
    STDMETHODIMP Clone(IEnumConnections **ppenum)
    {
        CEnumConnections *penum;
        if ((penum = New CEnumConnections(m_pconnect)) == NULL)
        {
            *ppenum = NULL;
            return E_OUTOFMEMORY;
        }
        else
        {
            *ppenum = penum;
            return S_OK;
        }
    }
};


//////////////////////////////////////////////////////////////////////////////
// CConnect Allocation & Destruction
//


/* @func HRESULT | AllocConnectionPointHelper |

        Allocates a <o ConnectionPointHelper> object, which provides a simple
        implementation of an <i IDispatch>-based and an <i IPropertyNotifySink>-based
		<i IConnectionPoint>. Also contains helper functions for implementing
        <om IConnectionPointContainer.EnumConnectionPoints> in the case where
        these are the only connection maintained by the connection point container.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IUnknown * | punkParent | The parent of the connection point, which
        is the object that implements <i IConnectionPointContainer>.

@parm   REFIID | riid | The dispinterface (interface based on <i IDispatch>)
        which is the event set that the parent object fires methods of. If this is
		GUID_NULL, then there will be no <i IDispatch> based connection.

@parm   IConnectionPointHelper * | ppconpt | Where to store the pointer to
        the newly-allocated object.  NULL is stored in *<p ppconpt> on
        error.

@comm   <b Important:> Unlike most COM objects, the parent object needs to
        free the <o ConnectionPointHelper> object by calling
        <f FreeConnectionPointHelper>, not <f Release>.  The reason is that
        the <o ConnectionPointHelper> object doesn't maintain a reference
        count if its own -- it simply forwards <f AddRef> and <f Release>
        calls to <p punkParent>.  Therefore, calling <f Release> on
        the <o ConnectionPointHelper> object will simply cause <f Release>
        to be called on the parent.

        To use the <o ConnectionPointHelper> object, call
        <om IConnectionPointHelper.FireEvent> to fire events to any object
        connected to the <o ConnectionPointHelper> object.
*/
STDAPI AllocConnectionPointHelper(IUnknown *punkParent, REFIID riid,
    IConnectionPointHelper **ppconpt)
{
	SCODE		sc = E_OUTOFMEMORY;
	CConnect	*pconDispatch = NULL, *pconPropertyNotify = NULL;

    // allocate the CConnect object that implements IConnectionPointHelper
    CConnectHelper	*pconhelper = New CConnectHelper;

	if (pconhelper != NULL)
		{
		if (pconPropertyNotify = New CConnect)
			{
			if (IsEqualGUID(riid, GUID_NULL) || (pconDispatch = New CConnect))
				sc = S_OK;
			}
		}

	if (SUCCEEDED(sc))
		{
		if (pconDispatch)
			{
			pconDispatch->m_iid = riid;
			pconDispatch->m_punkParent = punkParent;
			}

		pconPropertyNotify->m_iid = IID_IPropertyNotifySink;
		pconPropertyNotify->m_punkParent = punkParent;

	    // we don't AddRef <m_punkParent> because the connection point's lifetime
		// equals its parent's lifetime (and AddRef would cause the parent
	    // object to never leave memory)
		pconhelper->m_punkParent = punkParent;
		pconhelper->m_pconDispatch = pconDispatch;
		pconhelper->m_pconPropertyNotify = pconPropertyNotify;
		}
	else
		{
		Delete pconhelper;
		pconhelper = NULL;
		Delete pconDispatch;
		Delete pconPropertyNotify;
		}

    *ppconpt = pconhelper;
    return sc;
}


/* @func HRESULT | FreeConnectionPointHelper |

        Frees a <o ConnectionPointHelper> object allocated using
        <f AllocConnectionPointHelper>.

@rvalue S_OK |
        Success.

@comm   See <f AllocConnectionPointHelper> for information about why you
        should not try to free the <o ConnectionPointHelper> object
        using <f Release>.
*/
STDAPI FreeConnectionPointHelper(IConnectionPointHelper *pconpt)
{
	if(pconpt)
		{
		pconpt->Close();
	    Delete pconpt;
		}
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown interface
//

STDMETHODIMP CConnectHelper::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("CConnect::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IConnectionPointHelper))
        *ppv = (IUnknown *) (IConnectionPointHelper*) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CConnectHelper::AddRef()
{
    return m_punkParent->AddRef();
}

STDMETHODIMP_(ULONG) CConnectHelper::Release()
{
    return m_punkParent->Release();
}


STDMETHODIMP CConnect::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("CConnect::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IConnectionPoint))
        *ppv = (IUnknown *) (IConnectionPoint*) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CConnect::AddRef()
{
    return m_punkParent->AddRef();
}

STDMETHODIMP_(ULONG) CConnect::Release()
{
    return m_punkParent->Release();
}


//////////////////////////////////////////////////////////////////////////////
// IConnectionPoint interface
//

STDMETHODIMP CConnect::GetConnectionInterface(IID *pIID)
{
    *pIID = m_iid;
    return S_OK;
}

STDMETHODIMP CConnect::GetConnectionPointContainer(
    IConnectionPointContainer **ppCPC)
{
    return m_punkParent->QueryInterface(IID_IConnectionPointContainer,
        (LPVOID *) ppCPC);
}

STDMETHODIMP CConnect::Advise(LPUNKNOWN punkSink, DWORD *pdwCookie)
{
    if (!m_listConnect.AddItem(punkSink))
        return E_OUTOFMEMORY;

    *pdwCookie = m_listConnect.LastCookieAdded();
    return S_OK;
}

STDMETHODIMP CConnect::Unadvise(DWORD dwCookie)
{
    m_listConnect.DeleteItem(m_listConnect.GetItemFromCookie(dwCookie));
    m_cUnadvise++;
    return S_OK;
}

STDMETHODIMP CConnect::EnumConnections(LPENUMCONNECTIONS *ppEnum)
{
    CEnumConnections *penum = New CEnumConnections(this);
    if (penum == NULL)
    {
        *ppEnum = NULL;
        return E_OUTOFMEMORY;
    }
    else
    {
        penum->Reset();
        *ppEnum = penum;
        return S_OK;
    }
}


//////////////////////////////////////////////////////////////////////////////
// IConnectionPointHelper interface
//


/* @method HRESULT | IConnectionPointHelper | FireEventList |

        Fire a given <i IDispatch>-based event on all objects (e.g. VBS)
        connected to this <o ConnectionPointHelper> object.  Parameters
        for the event are passed as a va_list array.

@rvalue S_OK |
        Success.

@parm   DISPID | dispid | The ID of the event to fire.

@parm   va_list | args | The arguments to pass.  See
        <om IConnectionPointHelper.FireEventList> for information about
        the organization of these arguments.
*/
STDMETHODIMP CConnectHelper::FireEventList(DISPID dispid, va_list args)
{
	// if there is no IDispatch connection point bail out
	if (m_pconDispatch == NULL)
		return E_FAIL;

    CUnknownItem *  pitem;          // an item in <m_listConnect>
                    
    m_pconDispatch->m_listConnect.Reset();
    while((pitem = m_pconDispatch->m_listConnect.GetNextItem()) != NULL)
    {
		IUnknown *punk;
        IDispatch *pdisp;
		HRESULT hr;

        punk = (IUnknown *) pitem->Contents();  // this does an AddRef
		hr = punk->QueryInterface(IID_IDispatch, (LPVOID *)&pdisp);
        punk->Release();

		if (FAILED(hr))
			return E_FAIL;

        DispatchInvokeList(pdisp, dispid, DISPATCH_METHOD, NULL, args);
        pdisp->Release();
    }

    return S_OK;
}


/* @method HRESULT | IConnectionPointHelper | FireEvent |

        Fire a given <i IDispatch>-based event on all objects (e.g. VBS)
        connected to this <o ConnectionPointHelper> object.  Parameters
        for the event are passed as a varying argument list.

@rvalue S_OK |
        Success.

@parm   DISPID | dispid | The ID of the event to fire.

@parm   (varying) | (arguments) | The arguments to pass to the event.
        These must consist of N pairs of arguments followed by a 0
        (zero value).  In each pair, the first argument is a VARTYPE
        value that indicates the type of the second argument.  Only a
        certain subset of VARTYPEs are supported.  See <f DispatchInvoke>
        for more information about the format of these arguments.

@ex     The following example fires the event DISPID_EVENT_BAR, which has
        two parameters (which in BASIC would be a Long and a String) --
        42 and "Hello", respectively, are passed as arguments. |

        pconpt->FireEvent(DISPID_EVENT_BAR, VT_INT, 42, VT_LPSTR, "Hello", 0);
*/
HRESULT __cdecl CConnectHelper::FireEvent(DISPID dispid, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dispid);

    // fire the event with the specified arguments
    hrReturn = FireEventList(dispid, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @method HRESULT | IConnectionPointHelper | FireOnChanged |

        Fire a given <om IPropertyNotifySink.OnChanged> event on all objects
        connected to this <o ConnectionPointHelper> object.  

@rvalue S_OK |
        Success.

@parm   DISPID | dispid | The ID of the event to fire.

*/
STDMETHODIMP CConnectHelper::FireOnChanged(DISPID dispid)
{
    CUnknownItem		*pitem;          // an item in <m_listConnect>
                    
    m_pconPropertyNotify->m_listConnect.Reset();
    while((pitem = m_pconPropertyNotify->m_listConnect.GetNextItem()) != NULL)
    {
		IUnknown *punk;
        IPropertyNotifySink *pnotify;
		HRESULT hr;

        punk = (IUnknown *) pitem->Contents();  // this does an AddRef
		hr = punk->QueryInterface(IID_IPropertyNotifySink, (LPVOID *)&pnotify);
        punk->Release();

		if (FAILED(hr))
			return E_FAIL;

		pnotify->OnChanged(dispid);
        pnotify->Release();
    }

    return S_OK;
}

/* @method HRESULT | IConnectionPointHelper | FireOnRequestEdit |

        Fire a given <om IPropertyNotifySink.OnRequestEdit> event on all objects
        connected to this <o ConnectionPointHelper> object.  

@rvalue S_OK |
        Success.

@parm   DISPID | dispid | The ID of the event to fire.

*/
STDMETHODIMP CConnectHelper::FireOnRequestEdit(DISPID dispid)
{
    CUnknownItem		*pitem;          // an item in <m_listConnect>
                    
    m_pconPropertyNotify->m_listConnect.Reset();
    while((pitem = m_pconPropertyNotify->m_listConnect.GetNextItem()) != NULL)
    {
		IUnknown *punk;
        IPropertyNotifySink *pnotify;
		HRESULT hr;

        punk = (IUnknown *) pitem->Contents();  // this does an AddRef
		hr = punk->QueryInterface(IID_IPropertyNotifySink, (LPVOID *)&pnotify);
        punk->Release();

		if (FAILED(hr))
			return E_FAIL;

		pnotify->OnRequestEdit(dispid);
        pnotify->Release();
    }

    return S_OK;
}

/* @method HRESULT | IConnectionPointHelper | EnumConnectionPoints |

        Helps implement <om IConnectionPointContainer.EnumConnectionPoints>
        in the case where this object implements the only connections maintained
        by the connection point container.

@rdesc  Returns the same error codes as
        <om IConnectionPointContainer.EnumConnectionPoints>.

@parm   LPENUMCONNECTIONPOINTS * | ppEnum | See
        <om IConnectionPointContainer.EnumConnectionPoints>.

@ex     In the following example, <c CMyControl> is a class that is based
        on (among other things) <i IConnectionPointContainer>.  This example
        shows how to use this <om .EnumConnectionPoints> function to
        implement <om IConnectionPointContainer.EnumConnectionPoints>. |

        STDMETHODIMP CMyControl::EnumConnectionPoints(
            LPENUMCONNECTIONPOINTS *ppEnum)
        {
            return m_pconpt->EnumConnectionPoints(ppEnum);
        }
*/
STDMETHODIMP CConnectHelper::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *ppEnum)
{
    HRESULT         hrReturn = S_OK; // function return code
    CEnumUnknown *  penum = NULL;   // new enumerator

    // set <penum> to the new enumerator
    if ((penum = New CEnumUnknown(IID_IEnumConnectionPoints)) == NULL)
        goto ERR_OUTOFMEMORY;

    // add the IDispatch connection point to the enumerated list
    if (m_pconDispatch && !penum->AddItem(m_pconDispatch))
        goto ERR_OUTOFMEMORY;

    // add the IPropertyNotifySink connection point to the enumerated list
    if (!penum->AddItem(m_pconPropertyNotify))
        goto ERR_OUTOFMEMORY;

    // return the enumerator
    *ppEnum = (LPENUMCONNECTIONPOINTS) penum;
    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    if (penum != NULL)
        penum->Release();
    *ppEnum = NULL;
    goto EXIT;

EXIT:

    return hrReturn;
}


/* @method HRESULT | IConnectionPointHelper | FindConnectionPoint |

        Helps implement <om IConnectionPointContainer.FindConnectionPoint>
        in the case where this object implements the only connections maintained
        by the connection point container.

@rdesc  Returns the same error codes as
        <om IConnectionPointContainer.FindConnectionPoint>.

@parm   LPENUMCONNECTIONPOINTS * | ppFindConnectionPoint | See
        <om IConnectionPointContainer.FindConnectionPoint>.

@ex     In the following example, <c CMyControl> is a class that is based
        on (among other things) <i IConnectionPointContainer>.  This example
        shows how to use this <om .FindConnectionPoint> function to
        implement <om IConnectionPointContainer.FindConnectionPoint>. |

        STDMETHODIMP CMyControl::FindConnectionPoint(REFIID riid,
            LPCONNECTIONPOINT *ppCP)
        {
            return m_pconpt->FindConnectionPoint(riid, ppCP);
        }
*/
STDMETHODIMP CConnectHelper::FindConnectionPoint(REFIID riid, LPCONNECTIONPOINT *ppCP)
{
    // we source a IDispatch-based <m_iid>
    if (IsEqualIID(riid, IID_IPropertyNotifySink))
		*ppCP = m_pconPropertyNotify;
	else if (m_pconDispatch && (IsEqualIID(riid, IID_IDispatch) || IsEqualIID(riid, m_pconDispatch->m_iid)))
		*ppCP = m_pconDispatch;
	else
        return CONNECT_E_NOCONNECTION;

    // return the requested pointer
    (*ppCP)->AddRef();
    return S_OK;
}

/* @method HRESULT | IConnectionPointHelper | Close |

        Empties the helper of all connections.  This is done typically
		just prior to destroying the CConnectHelper object.

@rdesc  S_OK.

*/
STDMETHODIMP CConnectHelper::Close(void)
{
	if (m_pconDispatch)
		{
		m_pconDispatch->m_cUnadvise += m_pconDispatch->m_listConnect.NumItems();
		m_pconDispatch->m_listConnect.EmptyList();
		}

	m_pconPropertyNotify->m_cUnadvise += m_pconPropertyNotify->m_listConnect.NumItems();
	m_pconPropertyNotify->m_listConnect.EmptyList();

	Delete m_pconDispatch;
	Delete m_pconPropertyNotify;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\debug.cpp ===
// debug.cpp
//
// Debugging functions.
//

#include "precomp.h"
#include <tchar.h>
#include "debug.h"


//////////////////////////////////////////////////////////////////////////////
// TRACE, ASSERT, VERIFY
//
// These are the same as MFC's functions of the same name (but are implemented
// without using MFC).  See "debug.h" for the actual macro definitions.
//

#ifdef _DEBUG

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
    // active popup window for the current thread
    HWND hwndParent = GetActiveWindow();
    if (hwndParent != NULL)
        hwndParent = GetLastActivePopup(hwndParent);

    // format message into buffer
    TCHAR atchAppName[_MAX_PATH * 2];
    TCHAR atchMessage[_MAX_PATH * 2];
    if (GetModuleFileName(g_hinst, atchAppName,
            sizeof(atchAppName) / sizeof(TCHAR)) == 0)
        atchAppName[0] = 0;
    wsprintf(atchMessage, _T("%s: File %hs, Line %d"),
        atchAppName, lpszFileName, nLine);

    // display the assert
    int nCode = MessageBox(hwndParent, atchMessage, _T("Assertion Failed!"),
        MB_TASKMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SETFOREGROUND);

    if (nCode == IDIGNORE)
        return FALSE;   // ignore

    if (nCode == IDRETRY)
        return TRUE;    // will cause DebugBreak()

    FatalExit(0);
    return TRUE;        // ...though FatalExit() should not return
}

void __cdecl Trace(LPCTSTR lpszFormat, ...)
{
    // start processing optional arguments
    va_list args;
    va_start(args, lpszFormat);

    // format the output string
    TCHAR atchBuffer[512];
    wvsprintf(atchBuffer, lpszFormat, args);

    // output the string
    OutputDebugString(atchBuffer);

    // end processing optional arguments
    va_end(args);
}

#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
// DebugIIDName, DebugCLSIDName
//
// These functions convert an IID or CLSID to a string name for debugging
// purposes (e.g. IID_IUnknown is converted to "IUnknown").
//

#ifdef _DEBUG

LPCSTR DebugGUIDName(REFGUID rguid, LPSTR szKey, LPSTR pchName)
{
    OLECHAR         achIID[100];        // interface ID (e.g. "{nnn-nnn-...}")  
    TCHAR           ach[150];

    // in case of error, clear <pchName>
    pchName[0] = 0;

    // convert <rguid> to a string (e.g. "{nnn-nnn-...}")
    StringFromGUID2(rguid, achIID, sizeof(achIID)/sizeof(achIID[0]));

    wsprintf(ach, TEXT("%hs\\%ls"), szKey, (LPOLESTR) achIID);
    
    // look up <achIID> in the registration database
#ifdef UNICODE
    TCHAR pchNameTemp[300];
    LONG cchNameTemp;
    cchNameTemp = _MAX_PATH;
    if (RegQueryValue(HKEY_CLASSES_ROOT, ach, pchNameTemp, &cchNameTemp)
            != ERROR_SUCCESS)
        // if <achIID> isn't in the registration database, use <achIID> itself
        wsprintf(pchNameTemp, TEXT("%ls"), (LPOLESTR) achIID);

    wcstombs(pchName, pchNameTemp, _MAX_PATH);
#else
    LONG cchNameTemp;
    cchNameTemp = _MAX_PATH;
    if (RegQueryValue(HKEY_CLASSES_ROOT, ach, pchName, &cchNameTemp)
            != ERROR_SUCCESS)
        // if <achIID> isn't in the registration database, use <achIID> itself
        wsprintf(pchName, TEXT("%ls"), (LPOLESTR) achIID);
#endif    
    return pchName;
}

#endif // _DEBUG


/* DebugIIDName

@func   Finds the name of an interface in the system registration database
        given the interface's IID (for debugging purposes only).

@rdesc  Returns a pointer to <p pchName>.

@comm   If the interface name is not found, a hexadecimal string form of
        <p riid> will be returned
        (e.g. "{209D2C80-11D7-101B-BF00-00AA002FC1C2}").

@comm   This function is only available in a debug build.
*/

#ifdef _DEBUG

LPCSTR DebugIIDName(

REFIID riid, /* @parm
        Interface ID to find the name of. */

LPSTR pchName) /* @parm
        Where to store the class ID name string.  This buffer should be
        large enough to hold _MAX_PATH characters. */

{
    return DebugGUIDName(riid, "Interface", pchName);
}

#endif


/* DebugCLSIDName

@func   Finds the name of an interface in the system registration database
        given the interface's CLSID (for debugging purposes only).

@rdesc  Returns a pointer to <p pchName>.

@comm   If the interface name is not found, a hexadecimal string form of
        <p rclsid> will be returned
        (e.g. "{209D2C80-11D7-101B-BF00-00AA002FC1C2}").

@comm   This function is only available in a debug build.
*/

#ifdef _DEBUG

LPCSTR DebugCLSIDName(

REFCLSID rclsid, /* @parm
        Class ID to find the name of. */

LPSTR pchName) /* @parm
        Where to store the class ID name string.  This buffer should be
        large enough to hold _MAX_PATH characters. */

{
    return DebugGUIDName(rclsid, "Clsid", pchName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\enumverb.h ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		enumverb.h
//				
// Description:	(tbd)
//
// History:		04/19/96	a-swehba
//					Created.
//===========================================================================

#ifndef _ENUMVERB_H
#define _ENUMVERB_H

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "..\..\inc\mmctl.h"		// INonDelegatingUnknown




//===========================================================================
// Class:		CVerbEnumHelper	
//
// Description:	(tbd)
//===========================================================================

class CVerbEnumHelper : public INonDelegatingUnknown,
					    public IEnumOLEVERB
{
//
// Friends
//

	friend IEnumOLEVERB* _stdcall ::AllocVerbEnumHelper(
										LPUNKNOWN punkOuter,
										void* pOwner,
										CLSID clsidOwner,
										VERB_ENUM_CALLBACK* pCallback);
		// needs access to CVerbEnumHelper::AllocVerbEnumHelper()


//
// Class Features
//

private:

	// factory methods

	static STDMETHODIMP_(IEnumOLEVERB*) AllocVerbEnumHelper(
											LPUNKNOWN punkOuter,
											void* pOwner,
											CLSID clsidOwner,
											VERB_ENUM_CALLBACK* pCallback,
											CVerbEnumHelper* pEnumToClone);


//
// Instance Features
//

protected:

	// NonDelegatingUnknown methods

    STDMETHODIMP			NonDelegatingQueryInterface(
								REFIID riid, 
								LPVOID* ppv);
    STDMETHODIMP_(ULONG)	NonDelegatingAddRef();
    STDMETHODIMP_(ULONG)	NonDelegatingRelease();

	// IUnknown methods

    STDMETHODIMP			QueryInterface(
								REFIID riid, 
								LPVOID* ppv);
    STDMETHODIMP_(ULONG)	AddRef();
    STDMETHODIMP_(ULONG)	Release();

	// IEnumOLEVERB methods

	STDMETHODIMP	Next(	
						ULONG celt, 
						OLEVERB* rgverb, 
						ULONG* pceltFetched); 
	STDMETHODIMP	Skip(
						ULONG celt); 
	STDMETHODIMP	Reset(); 
	STDMETHODIMP	Clone(
						IEnumOLEVERB** ppenum); 

private:
	
	// creating and destroying

	CVerbEnumHelper(
		IUnknown* punkOuter,
		void* pOwner,
		CLSID clsidOwner,
		VERB_ENUM_CALLBACK* pCallback,
		CVerbEnumHelper* pEnumToClone,
		HRESULT* pHResult);
    ~CVerbEnumHelper();

	// private variables

	VERB_ENUM_CALLBACK* m_pCallback;
		// this function is called each time CVerbEnumHelper::Next() is
		// called
	void* m_pOwner;
		// the object which "owns" the verbs associated with this enumerator
	CLSID m_clsidOwner;
		// the class ID of <m_pOwner>
	IEnumOLEVERB* m_pVerbEnum;
		// the enumerator's IEnumOLEVERB interface is implemented by calling
		// this interface which is, ultimately, provided by OleRegEnumVerbs()
    ULONG m_cRef;
		// object reference count; used only if the object isn't aggregated
    LPUNKNOWN  m_punkOuter;    
		// the controlling unknown; possibly NULL
};




#endif // _ENUMVERB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\factory.cpp ===
// factory.cpp
//
// Implements HelpCreateClassObject (and its class factory object).
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// CClassFactory -- Implements IClassFactory
//

class CClassFactory : public IClassFactory
{
friend HRESULT _stdcall HelpGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv,
    ControlInfo *pctlinfo);

///// IUnknown implementation
protected:
    ULONG           m_cRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
		return (++m_cRef);
    }
    STDMETHODIMP_(ULONG) Release()
    {
		ASSERT(m_cRef > 0);
		if (InterlockedDecrement((LONG*)&m_cRef) == 0)
		{
			Delete this;
			return (0);
		}
		return (m_cRef);
    }

///// IClassFactory implementation
protected:
    ControlInfo *m_pctlinfo;        // info. about control to create
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        LPUNKNOWN punk = (m_pctlinfo->pallococ)(punkOuter);
        if (punk == NULL)
            return E_OUTOFMEMORY;
        HRESULT hr = punk->QueryInterface(riid, ppv);
        punk->Release();
        return hr;
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if (fLock)
			InterlockedIncrement((LONG*)m_pctlinfo->pcLock);
        else
            InterlockedDecrement((LONG*)m_pctlinfo->pcLock);

        return NOERROR;
    }

///// Construction
    CClassFactory(ControlInfo *pci) : m_pctlinfo(pci) {}
};


/* @func HRESULT | HelpGetClassObject |

        Helps implement <f DllGetClassObject> (including the class factory
        object it creates) for any number of controls.

@parm   REFCLSID | rclsid | See <f DllGetClassObject>.

@parm   REFIID | riid | See <f DllGetClassObject>.

@parm   LPVOID * | ppv | See <f DllGetClassObject>.

@parm   ControlInfo * | pci | Information about the control that's
        implemented by the DLL.  See <t ControlInfo> for more information.

@comm   <f HelpGetClassObject> can support one control by making a linked list
        out of your <t ControlInfo> structures -- set each <p pNext>
        field to the next structure, and set the last <p pNext> to NULL.

@ex     The following example shows how to implement <f DllGetClassObject>
        using <f HelpGetClassObject>. |

        STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
        {
            return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfo);
        }
*/
STDAPI HelpGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv,
    ControlInfo *pci)
{
    // loop once for each ControlInfo structure in linked list <pci>
    // to find a ControlInfo that can create class <rclsid>
    while(TRUE)
    {
        // check the <cbSize> field (used for version checking)
        if (pci->cbSize != sizeof(*pci))
        {
            TRACE("HelpGetClassobject: incorrect cbSize field\n");
            return E_FAIL;
        }

        // this DLL can only create class factory objects that support
        // IUnknown and IClassFactory
        if (!IsEqualIID(riid, IID_IUnknown) &&
            !IsEqualIID(riid, IID_IClassFactory))
            return E_NOINTERFACE;

        // <pci> implements objects of type <pci->rclsid>
        if (IsEqualCLSID(rclsid, *pci->pclsid))
        {
            // create the class factory object
            CClassFactory *pcf = New CClassFactory(pci);
            if (pcf == NULL)
                return E_OUTOFMEMORY;

            // return AddRef'd interface pointer
            pcf->m_cRef = 1;
            *ppv = (IClassFactory *) pcf;
            return S_OK;
        }

        // go to the next ControlInfo structure in the linked list
        if (pci->pNext == NULL)
            break;
        pci = pci->pNext;
    }

    // no ControlInfo was found that can create an object of class <rclsid>
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\dispiez.cpp ===
// dispiez.cpp
//
// Implements IDispatch helper functions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"

// Common code used by DispatchInvokeEZ and DispatchInvokeIDEZ to convert the return
// value from a VARIANT into the requested type.  NOTE: The Variant is cleared by
// this function.
static HRESULT DispatchInvokeListIDEZ(IDispatch *pdisp, DISPID dispid, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, va_list args)
{
    HRESULT hr;
    VARIANT var;

    // Call the function
    hr = DispatchInvokeList(pdisp, dispid, wFlags, &var, args);

    // Return immediately on error
    if(FAILED(hr))
        goto EXIT;

    // Return the result
    if(vtReturn && pvReturn)
    {
        if (vtReturn == VT_VARIANT)
        {
            *((VARIANT *) pvReturn) = var;
            VariantInit(&var);
        }
        else
        {
            VARTYPE vtTemp;
            HRESULT hrTemp;

            // try to coerce the variant into the correct type.
            if (vtReturn == VT_INT)
                vtTemp = VT_I4;
            else
            if (vtReturn == VT_LPSTR)
                vtTemp = VT_BSTR;
            else
                vtTemp = vtReturn;
            if (FAILED(hrTemp = VariantChangeType(&var, &var, 0, vtTemp)))
            {
                hr = hrTemp;
                goto EXIT;
            }

            switch(vtReturn)
            {
                case VT_I2:
                    *((short *) pvReturn) = var.iVal;
                    break;
                case VT_I4:
                case VT_INT:
                    *((long *) pvReturn) = var.lVal;
                    break;
                case VT_R4:
                    *((float *) pvReturn) = V_R4(&var);
                    break;
                case VT_R8:
                    *((double *) pvReturn) = V_R8(&var);
                    break;
                case VT_BOOL:
                    *((BOOL *) pvReturn) = (V_BOOL(&var) == 0 ? 0 : 1);
                    break;
                case VT_BSTR:
                    *((BSTR *) pvReturn) = var.bstrVal;
                    VariantInit(&var); // prevent VariantClear clearing var.bstrVal
                    break;
                case VT_DISPATCH:
                    *((LPDISPATCH *) pvReturn) = var.pdispVal;
                    VariantInit(&var); // prevent VariantClear clearing var.pdispVal
                    break;
                case VT_UNKNOWN:
                    *((LPUNKNOWN *) pvReturn) = var.punkVal;
                    VariantInit(&var); // prevent VariantClear clearing var.punkVal
                    break;
                case VT_LPSTR:
                    if(var.bstrVal)
					{
						if (UNICODEToANSI(LPSTR(pvReturn), var.bstrVal,
										  _MAX_PATH) == 0)
						{
							// The string couldn't be converted.  One cause is
							// a string that's longer than _MAX_PATH characters,
							// including the NULL.

							hr = DISP_E_OVERFLOW;
							ASSERT(FALSE);
							goto EXIT;
						}
					}
                    else
					{
                        ((LPSTR)pvReturn)[0] = '\0';
					}
                    break;
                default:
                    hr = DISP_E_BADVARTYPE;
                    break;
            }
        }
    }

EXIT:

    VariantClear(&var);

    return hr;
}


/* @func HRESULT | DispatchInvokeIDEZ |

        Calls <om IDispatch.Invoke> on a given <i IDispatch> object, passing
        arguments specified as a variable-length list of arguments.  This function
        is almost identical to <f DispatchInvokeEZ>, except that <f DispatchInvokeIDEZ>
        takes a DISPID rather than a name of a property/method.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The DISPID of the property or method to invoke.

@parm   WORD | wFlags | May be one of the following values (see
        <om IDispatch.Invoke> for more information):

        @flag   DISPATCH_METHOD | The member <p dispid> is being invoked as a
                method.  If a property has the same name, both this and the
                DISPATCH_PROPERTYGET flag may be set.

        @flag   DISPATCH_PROPERTYGET | The member <p dispid> is being retrieved
                as a property or data member.

        @flag   DISPATCH_PROPERTYPUT | The member <p dispid> is being changed
                as a property or data member.

@parm   VARTYPE | vtReturn | The type of the return value (or NULL if the return
        value should be ignored).  See <f DispatchInvokeEZ> for more details.

@parm   LPVOID | pvReturn | Where to store the return value from the method
        or property-get call.  See <f DispatchInvokeEZ> for more details.

@parm   (varying) | (arguments) | The arguments to pass to the method or
        property.  See <f DispatchInvokeEZ> for more details.

@comm   Named arguments are not supported by this function.

        Don't forget to add a 0 argument to the end of the argument list.

@ex     If a control has a "put" property that looks like this in ODL: |

        [propput, id(DISPID_TABSTOP)]
        HRESULT TabStop([in] float flTabStop)

@ex     then the property can be set with DispatchInvokeIDEZ using the
		following code: |

        DispatchInvokeIDEZ(pdisp, DISPID_TABSTOP, DISPATCH_PROPERTYPUT, NULL, NULL, VT_R4, flTabStop, 0);

@ex		If the ODL for the corresponding "get" property looks like this: |

        [propget, id(DISPID_TABSTOP)]
        HRESULT TabStop([out, retval] float *pflTabStop);

@ex     then the property can be read as follows: |

		float flTabStop;
        DispatchInvokeIDEZ(pdisp, DISPID_TABSTOP, DISPATCH_PROPERTYGET, VT_R4, &flTabStop, 0);

@ex     If the control has a SetText method with this ODL description: |

        [id(DISPID_SETTEXT)]
        HRESULT SetText([in] BSTR bstrText, [in] long lSize, [in] BOOL fBold);

@ex     then the method can be called with the following code: |
        
        DispatchInvokeIDEZ(pdisp, DISPID_SETTEXT, DISPATCH_METHOD, NULL, NULL, VT_LPSTR, "Hello", VT_I4, 12, VT_BOOL, FALSE, 0);

@ex     (Note that DispatchInvokeIDEZ copies the VT_LPSTR parameter to a BSTR
		before passing it to SetText.  You can also pass in a BSTR or an
		OLECHAR* for the first parameter.)

		If a method has an "out" parameter that is marked as "retval" in ODL,
		then DispatchInvokeIDEZ stores that parameter in varResult.  If the
		method looks like this, for example: |

        [id(DISPID_GETROTATION)]
        HRESULT GetRotation([in] long iCell, [out, retval] float *pflRotation);

@ex		then GetRotation should be called like this: |

		float flRotation;
		DispatchInvokeIDEZ(pdisp, DISPID_GETROTATION, DISPATCH_METHOD, VT_R4, &flRotation, VT_I4, iCell, 0);

@ex 	If you need to pass in a type that is not directly supported by
		DispatchInvokeIDEZ, you can use VT_VARIANT.  Let's say the control has
		a GetFormat method that looks like this: |

        [id(DISPID_GETFORMAT)]
        HRESULT GetFormat([out] long *lColor, [out] BOOL *pfBold);
        
@ex 	This takes a pointer-to-long and a pointer-to-BOOL, neither of which
		can be passed directly to DispatchInvokeIDEZ.  You can, however, use
		VARIANTs to call GetFormat: |

		long lColor;
		BOOL fBold;
		VARIANT varColor, varBold;

		VariantInit(&varColor);
		V_VT(&varColor) = VT_I4 | VT_BYREF;
		V_I4REF(&varColor) = &lColor;
		VariantInit(&varBold);
		V_VT(&varBold) = VT_BOOL | VT_BYREF;
		V_BOOLREF(&varBold) = &fBold;

		DispatchInvokeIDEZ(pdisp, DISPID_GETFORMAT, DISPATCH_METHOD, NULL, NULL, VT_VARIANT, varColor, VT_VARIANT, varBold, 0);

*/
HRESULT DispatchInvokeIDEZ(IDispatch *pdisp, DISPID dispid, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, ...)
{
    HRESULT hr;

    // Call the function
    va_list args;
    va_start(args, pvReturn);
    hr = DispatchInvokeListIDEZ(pdisp, dispid, wFlags, vtReturn, pvReturn, args);
    va_end(args);

    return hr;
}

/* @func HRESULT | DispatchInvokeEZ |

        Calls <om IDispatch.Invoke> on a given <i IDispatch> object, passing
        arguments specified as a variable-length list of arguments.  This function
        is similar to <f DispatchInvoke>, but requires less setup.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   LPWSTR | pstr | The name of the property or method to invoke.

@parm   WORD | wFlags | May be one of the following values (see
        <om IDispatch.Invoke> for more information):

        @flag   DISPATCH_METHOD | The member <p pstr> is being invoked as a
                method.  If a property has the same name, both this and the
                DISPATCH_PROPERTYGET flag may be set.

        @flag   DISPATCH_PROPERTYGET | The member <p pstr> is being retrieved
                as a property or data member.

        @flag   DISPATCH_PROPERTYPUT | The member <p pstr> is being changed
                as a property or data member.

@parm   VARTYPE | vtReturn | The type of the return value (or NULL if the return
        value should be ignored).  The following VARTYPE values are supported:

        @flag   VT_INT | <p pvReturn> is an int *.

        @flag   VT_I2 | <p pvReturn> is a short *.

        @flag   VT_I4 | <p pvReturn> is a long *.

        @flag   VT_R4 | <p pvReturn> is a float *.

        @flag   VT_R8 | <p pvReturn> is a double *.

        @flag   VT_BOOL | <p pvReturn> is a BOOL * (<y not> a
                VARIANT_BOOL *).  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | <p pvReturn> is a BSTR *.  If the function
				succeeds, the caller of <f DispatchInvokeEZ> should free this 
				BSTR using <f SysFreeString>.

        @flag   VT_LPSTR | <p pvReturn> is an LPSTR that points
                to a char array capable of holding at least _MAX_PATH
                characters, including the terminating NULL.  (You should
				declare this as "char achReturn[_MAX_PATH]".)  If the string is
				too long for the LPSTR, DISP_E_OVERFLOW is returned.

        @flag   VT_DISPATCH | <p pvReturn> is an LPDISPATCH *.
                The caller of <f DispatchInvokeEZ> must call <f Release>
                on this LPDISPATCH.

        @flag   VT_UNKNOWN | <p pvReturn> is an LPUNKNOWN *.
                The caller of <f DispatchInvokeEZ> must call <f Release>
                on this LPUNKNOWN.

        @flag   VT_VARIANT | <p pvReturn> is a VARIANT *.
                This allows arbitrary parameters to be passed using this
                function.  Note that this behavior differs from the usual
                definition of VT_VARIANT.  The caller of <f DispatchGetArgs>
				should must call VariantClear on this VARIANT.

@parm   LPVOID | pvReturn | Where to store the return value from the method
        or property-get call.  If <p pvReturn> is NULL, the result (if any) is
        discarded.  See the <p vtReturn> property for more infomation.  This value
        is unchanged if <f DispatchInvokeEZ> returns an error code.

@parm   (varying) | (arguments) | The arguments to pass to the method or
        property.  These must consist of N pairs of arguments followed by
        a 0 (zero value).  In each pair, the first argument is a VARTYPE
        value that indicates the type of the second argument.  The following
        VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int.  <f Invoke>
                passes this as VT_I4, so this parameter should be declared
                as a Long in BASIC.

        @flag   VT_I2 | The following argument is a short.  In BASIC
                this parameter should be declared as Integer.

        @flag   VT_I4 | The following argument is a long.  In BASIC
                this parameter should be declared as Long.

        @flag   VT_R4 | The following argument is a float.  In BASIC
                this parameter should be declared as Single.

        @flag   VT_R8 | The following argument is a double.  In BASIC
                this parameter should be declared as Double.

        @flag   VT_BOOL | The following argument is a BOOL (<y not> a
                VARIANT_BOOL).  In BASIC this parameter should be declared
                as Boolean or Integer.  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR or an OLECHAR *.
				In BASIC this parameter should be declared as String.

        @flag   VT_LPSTR | The following argument is an LPSTR.  <f Invoke>
                passes this as a BSTR, so this parameter should be declared
                as a String in BASIC.  Note that this behavior differs
                from the usual definition of VT_LPSTR.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH.  In
                BASIC this parameter should be declared as an Object.

        @flag   VT_UNKNOWN | The following argument is an LPUNKNOWN.

        @flag   VT_VARIANT | The following arguement is a VARIANT that is
                passed as-is to <f Invoke>.  This allows arbitrary parameters
                to be passed using this function.  Note that this behavior
                differs from the usual definition of VT_VARIANT.

@comm   Named arguments are not supported by this function.

        Don't forget to add a 0 argument to the end of the argument list.

@ex     If a control has a "put" property that looks like this in ODL: |

        [propput, id(DISPID_TABSTOP)]
        HRESULT TabStop([in] float flTabStop)

@ex     then the property can be set with DispatchInvokeEZ using the following
		code: |

        DispatchInvokeEZ(pdisp, L"put_TabStop", DISPATCH_PROPERTYPUT, NULL, NULL, VT_R4, flTabStop, 0);

@ex		If the ODL for the corresponding "get" property looks like this: |

        [propget, id(DISPID_TABSTOP)]
        HRESULT TabStop([out, retval] float *pflTabStop);

@ex     then the property can be read as follows: |

		float flTabStop;
        DispatchInvokeEZ(pdisp, L"get_TabStop", DISPATCH_PROPERTYGET, VT_R4, &flTabStop, 0);

@ex     If the control has a SetText method with this ODL description: |

        [id(DISPID_SETTEXT)]
        HRESULT SetText([in] BSTR bstrText, [in] long lSize, [in] BOOL fBold);

@ex     then the method can be called with the following code: |
        
        DispatchInvokeEZ(pdisp, L"SetText", DISPATCH_METHOD, NULL, NULL, VT_LPSTR, "Hello", VT_I4, 12, VT_BOOL, FALSE, 0);

@ex     (Note that DispatchInvokeEZ copies the VT_LPSTR parameter to a BSTR
		before passing it to SetText.  You can also pass in a BSTR or an
		OLECHAR* for the first parameter.)

		If a method has an "out" parameter that is marked as "retval" in ODL,
		then DispatchInvokeEZ stores that parameter in varResult.  If the
		method looks like this, for example: |

        [id(DISPID_GETROTATION)]
        HRESULT GetRotation([in] long iCell, [out, retval] float *pflRotation);

@ex		then GetRotation should be called like this: |

		float flRotation;
		DispatchInvokeEZ(pdisp, L"GetRotation", DISPATCH_METHOD, VT_R4, &flRotation, VT_I4, iCell, 0);

@ex 	If you need to pass in a type that is not directly supported by
		DispatchInvokeEZ, you can use VT_VARIANT.  Let's say the control has a
		GetFormat method that looks like this: |

        [id(DISPID_GETFORMAT)]
        HRESULT GetFormat([out] long *lColor, [out] BOOL *pfBold);
        
@ex 	This takes a pointer-to-long and a pointer-to-BOOL, neither of which
		can be passed directly to DispatchInvokeEZ.  You can, however, use
		VARIANTs to call GetFormat: |

		long lColor;
		BOOL fBold;
		VARIANT varColor, varBold;

		VariantInit(&varColor);
		V_VT(&varColor) = VT_I4 | VT_BYREF;
		V_I4REF(&varColor) = &lColor;
		VariantInit(&varBold);
		V_VT(&varBold) = VT_BOOL | VT_BYREF;
		V_BOOLREF(&varBold) = &fBold;

		DispatchInvokeEZ(pdisp, L"GetFormat", DISPATCH_METHOD, NULL, NULL, VT_VARIANT, varColor, VT_VARIANT, varBold, 0);

*/
HRESULT DispatchInvokeEZ(IDispatch *pdisp, LPWSTR pstr, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, ...)
{
    HRESULT hr;
    DISPID dispid;

    // find the dispid
    hr = pdisp->GetIDsOfNames(IID_NULL, &pstr, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if(FAILED(hr))
        return hr;

    // Call the function
    va_list args;
    va_start(args, pvReturn);
    hr = DispatchInvokeListIDEZ(pdisp, dispid, wFlags, vtReturn, pvReturn, args);
    va_end(args);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//

#include "precomp.h"

#ifdef _DEBUG
    #pragma message("_DEBUG is defined.")
#else
    #pragma message("_DEBUG isn't defined.")
#endif
#ifdef _DESIGN
    #pragma message("_DESIGN is defined.")
#else
    #pragma message("_DESIGN isn't defined.")
#endif

// Define the GUIDs contained in public header files.  GUIDs contained in files
// that are not public are defined in Globals.cpp.

#include <initguid.h>
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"

#include "debug.h"
#include "ftrace.h"		// FT_xxx macros


//////////////////////////////////////////////////////////////////////////////
// Globals used by the OCHelp DLL but not by the OCHelp static library.
// Globals used by the static library are defined in Globals.cpp.
//

extern "C" int _fltused = 1;
	// indicates we need to manipulate float & double variables without the 
	// C runtime


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Point
//

extern "C" BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,
    LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		// Initialize the static library code that gets incorporated into the
		// DLL version of OCHelp.

		if (!InitializeStaticOCHelp(hInst))
			return FALSE;

        TRACE("OCHelp loaded\n");
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
	{
		UninitializeStaticOCHelp();
        TRACE("OCHelp unloaded\n");
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Custom default "new" and "delete" (zero-initializing, non-C-runtime)
// for use within this DLL.
//

#define LEAKFIND 0 // 1 to turn on leak-finding support

void * _cdecl operator new(size_t cb)
{
#if LEAKFIND
    LPVOID pv = HelpNew(cb);
    TRACE("++OCHelp 0x%X %d new\n", pv, cb);
	return pv;
#else
	return HelpNew(cb);
#endif
}

void _cdecl operator delete(void *pv)
{
#if LEAKFIND
    TRACE("++OCHelp 0x%X %d delete\n", pv, -(((int *) pv)[-1]));
#endif
    HelpDelete(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\globals.cpp ===
// Globals.cpp
//
// Global definitions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// If you add a definition here, add a corresponding declaration to Globals.h.
//

#include "precomp.h"

// Define the GUIDs contained in header files that are not public.  These GUIDs
// must be defined within the OCHelp static library, since a user of the static
// library has no way to define them himself.  Those GUIDs that are contained
// in public header files (mmctlg.h and ochelp.h) get defined by the user of
// the static library in the following manner:
//
// 		#include <initguid.h>
// 		#include "mmctlg.h"
// 		#include "ochelp.h"

#include <initguid.h>
#include "..\..\inc\catid.h"  // This file is not public.


// DLL instance handle.
// HINSTANCE g_hinst;				

// A critical section used within OCHelp.
CRITICAL_SECTION g_criticalSection;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\findstr.cpp ===
// findstr.cpp
//
// Implements FindStringByValue and FindStringByIndex.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"


/* @func char * | FindCharInString |

        Search a string to find a specific character.

@rdesc  Returns a pointer to the first occurence of <p chFind> in
        <p sz>.  Returns NULL if <p chFind> was not found.

@parm   const char * | sz | String to search.

@parm   char | chFind | Character to find.  May be '\\0' to search for
        the end of the string.

@comm   The search is case-sensitive.
*/
STDAPI_(char *) FindCharInString(const char *sz, char chFind)
{
    while (TRUE)
    {
        if (*sz == chFind)
            return (char*)sz;
        if (*sz++ == 0)
            return NULL;
    }
}


/* @func char * | FindCharInStringRev |

        Search a string to find the last occurrence of a specific character.

@rdesc  Returns a pointer to the last occurence of <p chFind> in
        <p sz>.  Returns NULL if <p chFind> was not found.

@parm   const char * | sz | String to search.  If NULL, the function returns NULL.

@parm   char | chFind | Character to find.  May be '\\0' to search for
        the end of the string.

@comm   The search is case-sensitive.
*/
STDAPI_(char *) FindCharInStringRev(const char *sz, char chFind)
{
        const char* pch;

        if (sz == NULL)
                return NULL;

        for (pch = sz + lstrlen(sz); pch >= sz; pch--)
    {
        if (*pch == chFind)
            return (char*)pch;
        }

        return NULL;
}



/* @func int | FindStringByValue |

        Look up string in a list of strings and return the index of the
        string (if found).

@rdesc  Returns the index of <p szFind> if <p szFind> is found in
        <p szList>.  The first string in <p szList> has index 0; the second 1,
        and so on.  Returns -1 if <p szFind> is not found.

@parm   const char * | szList | The list of strings to look up <p szFind> in.
        <p szList> consists of the concatenation of each string in the list,
        where each string is terminated by a newline character (e.g.
        "Foo\\nBar\\n").

@parm   const char * | szFind | The string to look up.

@comm   The search is case-insensitive.

@ex     The following line of code sets <p iString> to12. |

        iString = FindStringByValue("Foo\\nBar\\n", "bar");
*/
STDAPI_(int) FindStringByValue(const char *szList, const char *szFind)
{
    for (int iString = 0; ; iString++)
    {
        // make <pch> point to the next '\n' in <szList>
        const char *pch = FindCharInString(szList, '\n');
        if (pch == NULL)
            return -1; // <szFind> not found in <szList>

        // see if <szFind> matches the next string in <szList>
        char ach[200];
        lstrcpyn(ach, szList, (DWORD) (pch - szList + 1));
        if (lstrcmpi(ach, szFind) == 0)
            return iString;

        // go to the next string in <szList>
        szList = pch + 1;
    }
}


/* @func const char * | FindStringByIndex |

        Find a string with a given index in a list of strings.

@rdesc  Returns a pointer to string number <p iString> in <p szList> if found,
        or NULL if not found.  Note that the returned string is terminated
        by a newline character, not a null character -- user <p ppch> to
        copy the string (see the example below).

@parm   const char * | szList | The list of strings to look up <p iString> in.
        <p szList> consists of the concatenation of each string, where each
        string is terminated by a newline character (e.g. "Foo\\nBar\\n").

@parm   int | iString | The index of the string to find.  The first string in
        <p szList> has index 0; the second 1, and so on.

@ex     The following code stores "Bar" in <p ach>. |

        int cch;
        char ach[100];
        char *sz = FindStringByIndex("Foo\nBar\n", 1, &cch);
        if (sz != NULL)
            lstrcpyn(ach, sz, cch + 1);
*/
STDAPI_(const char *) FindStringByIndex(const char *szList, int iString,
    int *pcch)
{
    if (iString < 0)
        return NULL;

    while (TRUE)
    {
        // make <pch> point to the next '\n' in <szList>
        const char *pch = FindCharInString(szList, '\n');
        if (pch == NULL)
            return NULL; // <iString> not found in <szList>

        if (iString-- == 0)
        {
            // this is the string we're looking for
            *pcch = (DWORD) (pch - szList);
            return szList;
        }

        // go to the next string in <szList>
        szList = pch + 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\enumverb.cpp ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		enumverb.cpp
//				
// Description:	This module contains the implementation of the CVerbEnum-
//				Helper class and its non-member factory function,
//				AllocVerbEnumHelper.
//
// History:		04/19/96	a-swehba
//					Created.
//				07/29/96	a-swehba
//					Next() -- S_FALSE is now valid return code.  Removed
//						ASSERTs.  NULL <pceltFetched> allowed.
//
// @doc MMCTL
//===========================================================================

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "precomp.h"			// precompiled headers
#include "debug.h"				// ASSERT(), etc.
#include "..\..\inc\ochelp.h"		// helper functions
#include "enumverb.h"




//===========================================================================
// Non-Member Functions
//
// Category:	Factory methods
//
// Notes:		(none)
//===========================================================================

//---------------------------------------------------------------------------
// @func	IEnumOLEVERB* | AllocVerbEnumHelper |
//			Allocates and initializes a verb enumeration helper.
//
// @parm	LPUNKNOWN | punkOuter |
//			[in] The controlling unknown.  May be NULL.
//
// @parm	void* | pOwner |
//			[in] The verbs' "owner".  That is, the object to which the verbs
//			refer.  May not be NULL.
//
// @parm	CLSID | clsidOwner |
//			[in] The class ID of <p pOwner>.  When the verb helper is
//			allocated, <p clsidOwner> is passed to <f OleRegEnumVerbs> to
//			get an <i IEnumOLEVERB> interface.
//
// @parm	VERB_ENUM_CALLBACK* | pCallback |
//			[in] This function will be called whenever the verb helper is
//			asked for verbs via its internal <om IEnumOLEVERB.Next> method.
//			<p pCallback> is passed a pointer to each <t OLEVERB>.  May not
//			be NULL.  <t VERB_ENUM_CALLBACK> is defined as follows:
//
//			typedef HRESULT (VERB_ENUM_CALLBACK)(OLEVERB* pVerb, void* pOwner);
//
// @rdesc	The verb enumeration helper's <i IEnumOLEVerb> interface or
//			NULL if out of memory.
//
// @comm	To implement <om IOleObject.EnumVerbs>, make sure that <p pObject>'s
//			class registers its verbs, define a <t VERB_ENUM_CALLBACK> 
//			callback function and implement <om IOleObject.EnumVerbs> by
//			calling <f AllocVerbEnumHelper>.  That's all it takes.
//
//			Typically the <p pCallback> function adjusts the state of
//			the verb's menu item based on the state of the <p pOwner> object.
//
// @ex		The following example shows a typical implementation of
//			<om IOleObject.EnumVerbs>, and the verb helper callback function: |
//
//			STDMETHODIMP CMyControl::EnumVerbs(IEnumOLEVERB** ppEnumOleVerb)
//			{
//				HRESULT hResult;
//				*ppEnumOleVerb = AllocVerbEnumHelper(NULL, CLSID_CMyControl,
//									&VerbEnumCallback, this);
//				hResult = (*ppEnumOleVerb != NULL) ? S_OK : E_OUTOFMEMORY;
//				return (hResult);
//			}
//
//			HRESULT VerbEnumCallback(
//			OLEVERB* pVerb, 
//			void* pOwner)
//			{
//				int flag;
//				CMyControl* pMyControl = (CMyControl*)pOwner;
//
//				switch (pVerb->lVerb)
//				{
//					case 0: // verb 0
//						// if pMyControl indicates that verb 0 should be enabled
//						//		flag = MF_ENABLED;
//						// else
//						//		flag = MF_GRAYED;
//						break;
//					case 1: // verb 1
//						// if pMyControl indicates that verb 1 should be enabled
//						//		flag = MF_ENABLED;
//						// else
//						//		flag = MF_GRAYED;
//						break;
//
//					// etc.
//
//					default:
//						break;
//				}
//				pVerb->fuFlags |= flag;
//				return (S_OK);
//			}
//---------------------------------------------------------------------------

STDAPI_(IEnumOLEVERB*) AllocVerbEnumHelper(
LPUNKNOWN punkOuter,
void* pOwner,
CLSID clsidOwner,
VERB_ENUM_CALLBACK* pCallback)
{
	// Preconditions

	ASSERT(pCallback != NULL);
	ASSERT(pOwner != NULL);

	return (CVerbEnumHelper::AllocVerbEnumHelper(punkOuter, 
												 pOwner,
												 clsidOwner,
												 pCallback, 
												 NULL));
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[x] class  [ ] instance
//
// Method Category:	factory methods
//
// Notes:			(none)
//===========================================================================

STDMETHODIMP_(IEnumOLEVERB*)
CVerbEnumHelper::AllocVerbEnumHelper(
LPUNKNOWN punkOuter,
void* pOwner,
CLSID clsidOwner,
VERB_ENUM_CALLBACK* pCallback,
CVerbEnumHelper* pEnumToClone)
{
    HRESULT hResult;
	CVerbEnumHelper* pEnum = NULL;

	// Preconditions

	ASSERT(pCallback != NULL);

	// Create a new enumerator.

	pEnum = New CVerbEnumHelper(punkOuter, pOwner, clsidOwner, pCallback, 
								pEnumToClone, &hResult);
	if ((pEnum == NULL) || FAILED(hResult))
	{
		goto Error;
	}
	((IUnknown*)pEnum)->AddRef();

Exit:

	return ((IEnumOLEVERB*)pEnum);

Error:
	
	if (pEnum != NULL)
	{
		Delete pEnum;
		pEnum = NULL;
	}
	goto Exit;
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[ ] class  [x] instance
//
// Method Category:	creating and destroying
//
// Notes:			(none)
//===========================================================================

CVerbEnumHelper::CVerbEnumHelper(
IUnknown* punkOuter,
void* pOwner,
CLSID clsidOwner,
VERB_ENUM_CALLBACK* pCallback,
CVerbEnumHelper* pEnumToClone,
HRESULT* pHResult)
{
	// Preconditions

	ASSERT(pCallback != NULL);
	ASSERT(pHResult != NULL);

    // Initialize private variables.

	m_pCallback = pCallback;
	m_pOwner = pOwner;
    m_cRef = 0;
    m_punkOuter = (punkOuter == NULL) 
					? (IUnknown*)(INonDelegatingUnknown*)this 
					: punkOuter;

	// Create an enumerator.  Clone it if we're provided an enumerator from
	// which to clone.  Create it fresh otherwise.

	if (pEnumToClone != NULL)
	{
		*pHResult = pEnumToClone->m_pVerbEnum->Clone(&m_pVerbEnum);
	}
	else
	{
		*pHResult = OleRegEnumVerbs(clsidOwner, &m_pVerbEnum);
	}
}




CVerbEnumHelper::~CVerbEnumHelper()
{
	if (m_pVerbEnum != NULL)
	{
		m_pVerbEnum->Release();
	}
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[ ] class  [x] instance
//
// Method Category:	IUnknown methods
//
// Notes:			(none)
//===========================================================================

STDMETHODIMP			
CVerbEnumHelper::QueryInterface(
REFIID riid, 
LPVOID* ppv)
{ 
	return (m_punkOuter->QueryInterface(riid, ppv));
}




STDMETHODIMP_(ULONG)	
CVerbEnumHelper::AddRef()
{ 
	return (m_punkOuter->AddRef());
}




STDMETHODIMP_(ULONG)	
CVerbEnumHelper::Release()
{ 
	return (m_punkOuter->Release());
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[ ] class  [x] instance
//
// Method Category:	NonDelegatingUnknown methods
//
// Notes:			(none)
//===========================================================================

STDMETHODIMP 
CVerbEnumHelper::NonDelegatingQueryInterface(
REFIID riid, 
LPVOID* ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown*)(INonDelegatingUnknown*)this;
	}
	else if (IsEqualIID(riid, IID_IEnumOLEVERB))
	{
        *ppv = (IEnumOLEVERB*)this;
	}
    else
	{
        return (E_NOINTERFACE);
	}

    ((IUnknown*)*ppv)->AddRef();
	return (S_OK);
}




STDMETHODIMP_(ULONG) 
CVerbEnumHelper::NonDelegatingAddRef()
{
	return (++m_cRef);
}




STDMETHODIMP_(ULONG) 
CVerbEnumHelper::NonDelegatingRelease()
{
	m_cRef--;
    if (m_cRef == 0L)
    {
        Delete this;
	}
	return (m_cRef);
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[ ] class  [x] instance
//
// Method Category:	IEnumOLEVerb methods
//
// Notes:			(none)
//===========================================================================

STDMETHODIMP 
CVerbEnumHelper::Next(
ULONG celt,
OLEVERB* rgVerb,
ULONG* pceltFetched)
{
	HRESULT hr, hrReturn;
	int iVerb;
	ULONG celtFetched;
		// the number of elements actually fetched

	// Preconditions -- According to the OLE spec, <pceltFetched> may be
	// NULL iff <celt> is 1.

	ASSERT(pceltFetched != NULL || celt == 1);

	// Get the next verb(s).

	if (FAILED(hrReturn = m_pVerbEnum->Next(celt, rgVerb, &celtFetched)))
	{
		goto Exit;
	}

	// Iterate through the verbs, and adjust their state depending on
	// the state of the underlying object.

	for (iVerb = 0; iVerb < (int)celtFetched; iVerb++)
	{
		if (FAILED(hr = (*m_pCallback)(rgVerb + iVerb, m_pOwner)))
		{
			hrReturn = hr;
			goto Exit;
		}
	}

Exit:
	
	if (pceltFetched != NULL)
	{
		*pceltFetched = celtFetched;
	}
	return (hrReturn);
}




STDMETHODIMP 
CVerbEnumHelper::Skip(
ULONG celt)
{
	return (m_pVerbEnum->Skip(celt));
}




STDMETHODIMP 
CVerbEnumHelper::Reset()
{
	return (m_pVerbEnum->Reset());
}




STDMETHODIMP 
CVerbEnumHelper::Clone( 
IEnumOLEVERB** ppenum)
{
	HRESULT	hResult = S_OK;

	// Preconditions

	ASSERT(ppenum != NULL);

	// Allocate a new numerator based on this one.

    *ppenum = AllocVerbEnumHelper(m_punkOuter, m_pOwner, m_clsidOwner, 
								  m_pCallback, this);
	if (ppenum == NULL)
	{
		hResult = E_OUTOFMEMORY;
	}

	return (hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\ftrace.h ===
//================================================================================
// File:		ftrace.h
//
// Description:	This file contains all the declarations for the Function Trace 
//				(FT) package.
//================================================================================

#ifndef _FTRACE_H_
#define _FTRACE_H_




//--------------------------------------------------------------------------------
// Trace Macros
//
// Note:	Code which used function tracing should only use these macros.  The 
//			actual trace *functions* should never be called directly.  This is for 
//			two reasons: (a) all tracing code will be removed automatically if 
//			_FTRACE isn't defined; and, (b) the trace functions aren't designed to 
//			be called directly.
//--------------------------------------------------------------------------------

// Option flags (used by FT_OPTIONS)

#define FTOPT_NO_VARS			0x00000001
#define FTOPT_NO_PRINTS			0x00000002
#define FTOPT_NO_LEAVES			0x00000004
#define FTOPT_NO_INDENTATION	0x00000008
#define FTOPT_NO_BLANK_LINES	0x00000010


#ifdef _FTRACE

	// executing a trace script

	#define FT_RUN_SCRIPT(fileName) \
				FTrace_RunScript(__FILE__, fileName)

	// turning tracing on and off

	#define FT_ON(writeToDebugWindow, logFileName, appendToLogFile) \
				FTrace_On(writeToDebugWindow, logFileName, appendToLogFile)
	#define FT_OFF() \
				FTrace_Off()
	#define FT_IS_ON() \
				FTrace_IsOn()

	// pausing and unpausing tracing

	#define FT_PAUSE() \
				FTrace_Pause()
	#define FT_RESUME() \
				FTrace_Resume()
	#define FT_IS_PAUSED() \
				FTrace_IsPaused()

	// setting options

	#define	FT_OPTIONS(dwOptions) \
				FTrace_Options(dwOptions)

	// including modules

	#define FT_INCLUDE_ALL_MODULES() \
				FTrace_IncludeAllModules()
	#define FT_INCLUDE_MODULES_FROM_FILE(fileName) \
				FTrace_IncludeModulesFromFile(fileName)
	#define FT_INCLUDE_MODULE(moduleName) \
				FTrace_IncludeModule(moduleName)
	#define FT_INCLUDE_THIS_MODULE() \
				FTrace_IncludeModule(__FILE__)
	#define FT_STOP_INCLUDING_MODULE(moduleName) \
				FTrace_StopIncludingModule(moduleName)
	#define FT_STOP_INCLUDING_THIS_MODULE() \
				FTrace_StopIncludingModule(__FILE__)
	#define FT_ALL_MODULES_ARE_INCLUDED() \
				FTrace_AllModulesAreIncluded()
	#define FT_MODULE_IS_INCLUDED(moduleName) \
				FTrace_ModuleIsIncluded(moduleName)
	#define FT_THIS_MODULE_IS_INCLUDED() \
				FTrace_ModuleIsIncluded(__FILE__)

	// excluding modules

	#define FT_EXCLUDE_ALL_MODULES() \
				FTrace_ExcludeAllModules()
	#define FT_EXCLUDE_MODULES_FROM_FILE(fileName) \
				FTrace_ExcludeModulesFromFile(fileName)
	#define FT_EXCLUDE_MODULE(moduleName) \
				FTrace_ExcludeModule(moduleName)
	#define FT_EXCLUDE_THIS_MODULE() \
				FTrace_ExcludeModule(__FILE__)
	#define FT_STOP_EXCLUDING_MODULE(moduleName) \
				FTrace_StopExcludingModule(moduleName)
	#define FT_STOP_EXCLUDING_THIS_MODULE() \
				FTrace_StopExcludingModule(__FILE__)
	#define FT_ALL_MODULES_ARE_EXCLUDED() \
				FTrace_AllModulesAreExcluded()
	#define FT_MODULE_IS_EXCLUDED(moduleName) \
				FTrace_ModuleIsExcluded(moduleName)
	#define FT_THIS_MODULE_IS_EXLCUDED() \
				FTrace_ModuleIsExcluded(__FILE__)

	// tracing function entry and exit points

	#define FT_ENTER(functionName, returnFormat) \
				FTrace_Enter(__FILE__, functionName, returnFormat)
	#define FT_ENTER_VOID(functionName) \
				FTrace_EnterVoid(__FILE__, functionName)
	#define FT_ENTER_OBJ(functionName, returnType) \
				FTrace_EnterObj(__FILE__, functionName, #returnType)

	#define FT_LEAVE(returnValue) \
				{ \
				/* Make sure that return value doesn't have any side effects since */ \
				/* it is evaluated twice -- not once -- by this macro. */ \
				/*ASSERT(returnValue == returnValue);*/ \
				FTrace_Leave(__FILE__, returnValue); \
				return (returnValue); \
				}
	#define	FT_LEAVE_VOID() \
				{ \
				FTrace_LeaveVoid(__FILE__); \
				return; \
				}
	#define FT_LEAVE_OBJ(returnValue) \
				{ \
				FTrace_LeaveObj(__FILE__); \
				return (returnValue); \
				}

	// printing variables and messages

	#define FT_VAR(var, format) \
				FTrace_PrintVar(__FILE__, #var, format, var)
	#define FT_BOOL(var) \
				FTrace_PrintVar(__FILE__, #var, "%s", (var) ? _T("true") : _T("false"))
	#define FT_STR(var, format) \
				if (var != NULL) \
					FTrace_PrintVar(__FILE__, #var, format, var); \
				else \
					FTrace_PrintVar(__FILE__, #var, "(null)")
	#define FT_PTR(ptr, format) \
				{ \
				/* Make sure that the ptr doesn't have any side effects since */ \
				/* it is evaluated twice -- not once -- by this macro. */ \
				/*ASSERT((ptr) == (ptr));*/ \
				if ((ptr) == NULL) \
					FTrace_Print(__FILE__, #ptr" = (null)"); \
				else \
					FTrace_PrintVar(__FILE__, "*"#ptr, format, *ptr); \
				}
	#define FT_PRINT(str) \
				FT_PRINT0(str)
	#define FT_PRINT0(str) \
				FTrace_Print(__FILE__, str)
	#define FT_PRINT1(format, arg) \
				FTrace_Print(__FILE__, format, arg)
	#define FT_PRINT2(format, arg1, arg2) \
				FTrace_Print(__FILE__, format, arg1, arg2)
	#define FT_PRINT3(format, arg1, arg2, arg3) \
				FTrace_Print(__FILE__, format, arg1, arg2, arg3)
	#define FT_PRINT4(format, arg1, arg2, arg3, arg4) \
				FTrace_Print(__FILE__, format, arg1, arg2, arg3, arg4)
	#define FT_PRINT5(format, arg1, arg2, arg3, arg4, arg5) \
				FTrace_Print(__FILE__, format, arg1, arg2, arg3, arg4, arg5)

#else

	// executing a trace script

	#define FT_RUN_SCRIPT(fileName)

	// turning tracing on and off

	#define FT_ON(writeToDebugWindow, logFileName, appendToLogFile)
	#define FT_OFF()		
	#define FT_IS_ON() \
				FALSE

	// pausing and unpausing tracing

	#define FT_PAUSE()		
	#define FT_RESUME()	
	#define FT_IS_PAUSED() \
				TRUE

	// setting options

	#define	FT_OPTIONS(dwOptions)

	// including modules

	#define FT_INCLUDE_THIS_MODULE();
	#define FT_INCLUDE_ALL_MODULES()
	#define FT_INCLUDE_MODULES_FROM_FILE(fileName)
	#define FT_INCLUDE_MODULE(moduleName)
	#define FT_STOP_INCLUDING_MODULE(moduleName)
	#define FT_MODULE_IS_INCLUDED(moduleName) \
				FALSE
	#define FT_ALL_MODULES_ARE_INCLUDED()

	// excluding modules

	#define FT_EXCLUDE_THIS_MODULE();
	#define FT_EXCLUDE_ALL_MODULES()
	#define FT_EXCLUDE_MODULES_FROM_FILE(fileName)
	#define FT_EXCLUDE_MODULE(moduleName)
	#define FT_STOP_EXCLUDING_MODULE(moduleName)
	#define FT_MODULE_IS_EXCLUDED(moduleName) \
				TRUE
	#define FT_ALL_MODULES_ARE_EXCLUDED()

	// tracing function entry and exit points

	#define FT_ENTER(functionName, returnFormat)
	#define FT_ENTER_VOID(functionName)
	#define FT_ENTER_OBJ(functionName, returnType)

	#define FT_LEAVE(returnValue) \
				return (returnValue)
	#define FT_LEAVE_OBJ(returnValue) \
				return (returnValue)
	#define FT_LEAVE_VOID() \
				return

	// printing variables and messages

	#define FT_VAR(var, format)
	#define FT_BOOL(var)
	#define FT_STR(var, format)
	#define FT_PTR(ptr, format)
	#define FT_PRINT(format)
	#define FT_PRINT0(format)
	#define FT_PRINT1(format, arg)
	#define FT_PRINT2(format, arg1, arg2)
	#define FT_PRINT3(format, arg1, arg2, arg3)
	#define FT_PRINT4(format, arg1, arg2, arg3, arg4)
	#define FT_PRINT5(format, arg1, arg2, arg3, arg4, arg5)

#endif // _FTRACE




//--------------------------------------------------------------------------------
// Trace Functions
// 
// Note: Don't use these functions directly -- use the macros (above) instead.
//--------------------------------------------------------------------------------

#define DllExport __declspec(dllexport)

// executing a trace script

DllExport void	FTrace_RunScript(
					const TCHAR* pModuleName,
					const TCHAR* pScriptFileName);

// turning tracing on and off

DllExport void	FTrace_On(
					BOOL writeToDebugWindow,
					const TCHAR* pLogFileName,
					BOOL appendToLogFile);
DllExport void 	FTrace_Off();
DllExport BOOL 	FTrace_IsOn();

// pausing and resuming tracing

DllExport void 	FTrace_Pause();
DllExport void	FTrace_Resume();
DllExport BOOL	FTrace_IsPaused();

// setting options

DllExport void	FTrace_Options(
					DWORD dwOptions);

// including modules

DllExport void	FTrace_IncludeAllModules();
DllExport void	FTrace_IncludeModulesFromFile(
					const TCHAR* pFileName);
DllExport void	FTrace_IncludeModule(
					const TCHAR* pModuleName);
DllExport void	FTrace_StopIncludingModule(
					const TCHAR* pModuleName);
DllExport BOOL	FTrace_AllModulesAreIncluded();
DllExport BOOL	FTrace_ModuleIsIncluded(
					const TCHAR* pModuleName);

// excluding modules

DllExport void	FTrace_ExcludeAllModules();
DllExport void	FTrace_ExcludeModulesFromFile(
					const TCHAR* pFileName);
DllExport void	FTrace_ExcludeModule(
					const TCHAR* pModuleName);
DllExport void	FTrace_StopExcludingModule(
					const TCHAR* pModuleName);
DllExport BOOL	FTrace_AllModulesAreExcluded();
DllExport BOOL	FTrace_ModuleIsExcluded(
					const TCHAR* pModuleName);

// tracing function entry and exit points

DllExport void	FTrace_Enter(
					const TCHAR* pModuleName,
					const TCHAR* pFunctionName,
					const TCHAR* pReturnFormat);
DllExport void	FTrace_EnterObj(
					const TCHAR* pModuleName,
					const TCHAR* pFunctionName,
					const TCHAR* pReturnFormat);
DllExport void	FTrace_EnterVoid(
					const TCHAR* pModuleName,
					const TCHAR* pFunctionName);

DllExport void	FTrace_Leave(
					const TCHAR* pModuleName,
					...);
DllExport void	FTrace_LeaveObj(
					const TCHAR* pModuleName);
DllExport void	FTrace_LeaveVoid(
					const TCHAR* pModuleName);

// printing variables and messages

DllExport void	FTrace_PrintVar(
					const TCHAR* pModuleName,
					const TCHAR* pVarName,
					const TCHAR* pFormat,
					...);
DllExport void	FTrace_Print(
					const TCHAR* pModuleName,
					const TCHAR* pFormat,
					...);



#endif // _FTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\globals.h ===
// Globals.h
//
// Global declarations.
//
// If you add a declaration here, add a corresponding definition to Globals.cpp.

#ifndef _GLOBALS_H_
#define _GLOBALS_H_


// DLL instance handle.
extern HINSTANCE g_hinst;				

// A critical section used within OCHelp.
extern CRITICAL_SECTION g_criticalSection;		


#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\hgci.cpp ===
// hgci.cpp
//
// Implements HelpGetClassInfo.
//
// WARNING: HelpGetClassInfo makes assumptions about the script engine calling
// it.  Currently, this works with VBS, but the VBS group will not guarantee
// that the assumptions made by HelpGetClassInfo will remain valid in the
// future, so use at your own risk!  Consider using HelpGetClassInfoFromTypeLib
// instead.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


//////////////////////////////////////////////////////////////////////////////
// CType -- Implements ITypeInfo and ITypeLib
//

struct CType : ITypeInfo, ITypeLib
{
///// state
    int             m_iType;
    char *          m_szEventList;
    CLSID           m_clsid;

///// construction, destruction
    CType(int iType, REFCLSID rclsid, char *szEventList, HRESULT *phr);
    ~CType();

///// IUnknown implementation
protected:
    ULONG           m_cRef;         // reference count
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// ITypeInfo methods
protected:
    STDMETHODIMP GetTypeAttr(TYPEATTR **pptypeattr);
    STDMETHODIMP GetTypeComp(ITypeComp **pptcomp);
    STDMETHODIMP GetFuncDesc(UINT index, FUNCDESC **pppfuncdesc);
    STDMETHODIMP GetVarDesc(UINT index, VARDESC **ppvardesc);
    STDMETHODIMP GetNames(MEMBERID memid, BSTR *rgbstrNames, UINT cMaxNames,
        UINT *pcNames);
    STDMETHODIMP GetRefTypeOfImplType(UINT index, HREFTYPE *hpreftype);
    STDMETHODIMP GetImplTypeFlags(UINT index, INT *pimpltypeflags);
    STDMETHODIMP GetIDsOfNames(OLECHAR **rglpszNames, UINT cNames,
        MEMBERID *rgmemid);
    STDMETHODIMP Invoke(void *pvInstance, MEMBERID memid, WORD wFlags,
        DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo,
        UINT *puArgErr);
    STDMETHODIMP GetDocumentation(MEMBERID memid, BSTR *pbstrName,
        BSTR *pbstrDocString, DWORD *pdwHelpContext, BSTR *pbstrHelpFile);
    STDMETHODIMP GetDllEntry(MEMBERID memid, INVOKEKIND invkind,
        BSTR *pbstrDllName, BSTR *pbstrName, WORD *pwOrdinal);
    STDMETHODIMP GetRefTypeInfo(HREFTYPE hreftype, ITypeInfo **pptinfo);
    STDMETHODIMP AddressOfMember(MEMBERID memid, INVOKEKIND invkind,
        void **ppv);
    STDMETHODIMP CreateInstance(IUnknown *puncOuter, REFIID riid,
        void **ppvObj);
    STDMETHODIMP GetMops(MEMBERID memid, BSTR *pbstrMops);
    STDMETHODIMP GetContainingTypeLib(ITypeLib **pptlib, UINT *pindex);
    STDMETHODIMP_(void) ReleaseTypeAttr(TYPEATTR *ptypeattr);
    STDMETHODIMP_(void) ReleaseFuncDesc(FUNCDESC *pfuncdesc);
    STDMETHODIMP_(void) ReleaseVarDesc(VARDESC *pvardesc);

///// ITypeLib methods
protected:
    STDMETHODIMP_(UINT) GetTypeInfoCount(void);
    STDMETHODIMP GetTypeInfo(UINT index, ITypeInfo **ppitinfo);
    STDMETHODIMP GetTypeInfoType(UINT index, TYPEKIND *ptkind);
    STDMETHODIMP GetTypeInfoOfGuid(REFGUID guid, ITypeInfo **pptinfo);
    STDMETHODIMP GetLibAttr(TLIBATTR **pptlibattr);
    // STDMETHODIMP GetTypeComp(ITypeComp **pptcomp); // see ITypeInfo above
    STDMETHODIMP GetDocumentation(INT index, BSTR *pbstrName,
        BSTR *pbstrDocString, DWORD *pdwHelpContext, BSTR *pbstrHelpFile);
    STDMETHODIMP IsName(LPOLESTR szNameBuf, ULONG lHashVal, BOOL *pfName);
    STDMETHODIMP FindName(LPOLESTR szNameBuf, ULONG lHashVal,
        ITypeInfo **rgptinfo, MEMBERID *rgmemid, USHORT *pcFound);
    STDMETHODIMP_(void) ReleaseTLibAttr(TLIBATTR *ptlibattr);
};


//////////////////////////////////////////////////////////////////////////////
// CType Construction & Destruction
//


/* @func HRESULT | HelpGetClassInfo |

        Helps implement <om IProvideClassInfo.GetClassInfo>.  The
        implementation provides very limited class information -- just
        enough to allow firing events to VBS.  <f Warning\:> you should
        probably use <f HelpGetClassInfoFromTypeLib> instead.  See comments
        for more information.

@parm   LPTYPEINFO * | ppti | Where to return the pointer to the
        newly-allocated <i ITypeInfo> interface.  NULL is stored in
        *<p ppti> on error.

@parm   REFCLSID | rclsid | The class ID of the object that is implementing
        <i IProvideClassInfo>.

@parm   char * | szEventList | A list of events that can be fired by the
        parent object that is implementing <i IProvideClassInfo>.  The event
        names are concatenated, and each event name is terminated by a
        newline character.  The first member name is assigned DISPID value 0,
        the second 1, and so on.  For example, if <p szEventList> is
        "\\nFoo\\nBar\\n", then "Foo" is assigned DISPID value 1 and "Bar"
        is assigned 2 (because the first element is "").  (These DISPID values
        are passed to functions such as <om IConnectionPointHelper.FireEvent>
        to invoke events on objects such as VBS scripts connected to the
        parent object.)

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   <b WARNING:> HelpGetClassInfo makes assumptions about the script
        engine calling it.  Currently, this works with VBS, but the VBS group
        will not guarantee that the assumptions made by HelpGetClassInfo will
        remain valid in the future, so use at your own risk!  Consider using
        <f HelpGetClassInfoFromTypeLib> instead.

@ex     In the following example, <c CMyControl> is a class that implements
        (among other things) <i IConnectionPointContainer> and
        <i IProvideClassInfo>.  The first part of this example shows how
        <om IProvideClassInfo.GetClassInfo> is implemented by <c CMyControl>.
        The second part of the example shows how an event is fired,
        assuming <p m_pconpt> is a <i IConnectionPointHelper> object.
        (It's not required that you use <o ConnectionPointHelper>, but
        it's helpful.) |

        // IDispatch IDs for events fired by this object, and the
        // corresponding method/property names (the order MUST MATCH)
        #define DISPID_EVENT_FOO        1
        #define DISPID_EVENT_BAR        2
        #define EVENT_NAMES "\n" \
                            "Foo\n" \
                            "Bar\n"

        STDMETHODIMP CMyControl::GetClassInfo(LPTYPEINFO FAR* ppTI)
        {
            return HelpGetClassInfo(ppTI, CLSID_CMyControl, EVENT_NAMES, 0);
        }

        // fire the "Bar" event (which has 3 parameters, which in BASIC
        // are of these types: Integer, String, Boolean)
        m_pconpt->FireEvent(DISPID_EVENT_BAR, VT_INT, 300 + i,
            VT_LPSTR, ach, VT_BOOL, TRUE, 0);
*/
STDAPI HelpGetClassInfo(LPTYPEINFO *ppti, REFCLSID rclsid, char *szEventList,
    DWORD dwFlags)
{
    TRACE("HelpGetClassInfo\n");
    HRESULT hr;
    if ((*ppti = (LPTYPEINFO) New CType(0, rclsid, szEventList, &hr)) == NULL)
        hr = E_OUTOFMEMORY;
    return hr;
}

CType::CType(int iType, REFCLSID rclsid, char *szEventList, HRESULT *phr)
{
    TRACE("CType(%d) 0x%08lx created\n", iType, this);

    // initialize IUnknown state
    m_cRef = 1;

    // other initialization
    m_iType = iType;
    m_szEventList = New char[lstrlen(szEventList) + 1];
    if (m_szEventList == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return;
    }
    lstrcpy(m_szEventList, szEventList);
    m_clsid = rclsid;

    *phr = S_OK;
}

CType::~CType()
{
    TRACE("CType(%d) 0x%08lx destroyed\n", m_iType, this);
    if (m_szEventList != NULL)
        Delete [] m_szEventList;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CType::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("CType(%d)::QI('%s')\n", m_iType, DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITypeInfo))
        *ppv = (IUnknown *) (ITypeInfo *) this;
    else
    if (IsEqualIID(riid, IID_ITypeLib))
        *ppv = (ITypeLib *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CType::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CType::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


//////////////////////////////////////////////////////////////////////////////
// ITypeInfo Implementation
//

STDMETHODIMP CType::GetTypeAttr(TYPEATTR **pptypeattr)
{
    TYPEATTR *      pta = NULL;     // type attributes

    TRACE("CType(%d): ITypeInfo::GetTypeAttr: ", m_iType);

    // set <pta> to an allocated TYPEATTR -- assume a zero-initializing 
    // new() operator
    if ((pta = (TYPEATTR *) TaskMemAlloc(sizeof(TYPEATTR))) == NULL)
        return E_OUTOFMEMORY;
    TRACE("0x%08lx\n", pta);

    switch (m_iType)
    {

    case 0:

        // initialize <*pta>
        pta->guid = m_clsid;
        // pta->lcid;
        // pta->dwReserved;
        pta->memidConstructor = MEMBERID_NIL;
        pta->memidDestructor = MEMBERID_NIL;
        // pta->lpstrSchema;
        // pta->cbSizeInstance;
        pta->typekind = TKIND_COCLASS;
        // pta->cFuncs;
        // pta->cVars;
        pta->cImplTypes = 2;
        // pta->cbSizeVft;
        pta->cbAlignment = 4;
        pta->wTypeFlags = TYPEFLAG_FCONTROL | TYPEFLAG_FCANCREATE;
        // pta->wMajorVerNum;
        // pta->wMinorVerNum;
        // pta->tdescAlias;
        // pta->idldescType;
        break;

    case 1:

        // initialize <*pta>
        pta->guid = IID_IDispatch;
        // pta->lcid;
        // pta->dwReserved;
        pta->memidConstructor = MEMBERID_NIL;
        pta->memidDestructor = MEMBERID_NIL;
        // pta->lpstrSchema;
        // pta->cbSizeInstance;
        pta->typekind = TKIND_DISPATCH;
        pta->cFuncs = 2;
        // pta->cVars;
        pta->cImplTypes = 1;
        // pta->cbSizeVft;
        pta->cbAlignment = 4;
        // pta->wTypeFlags;
        // pta->wMajorVerNum;
        // pta->wMinorVerNum;
        // pta->tdescAlias;
        // pta->idldescType;
        break;

    default:

        TRACE("UNKNOWN m_iType!\n");
        break;

    }

    *pptypeattr = pta;
    return S_OK;
}

STDMETHODIMP CType::GetTypeComp(ITypeComp **pptcomp)
{
    TRACE("CType(%d): ITypeInfo::GetTypeComp: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetFuncDesc(UINT index, FUNCDESC **pppfuncdesc)
{
    TRACE("CType(%d): ITypeInfo::GetFuncDesc(%d)\n", m_iType, index);

    // point <pfd> to a newly-allocated structure describing
    // function number <index> (where index==i for the method with
    // DISPID i+1)
    FUNCDESC *pfd = New FUNCDESC;
    if (pfd == NULL)
        return E_OUTOFMEMORY;

    // initialize and return <pfd>
    pfd->memid = index + 1; // this is the DISPID of the event method
    pfd->funckind = FUNC_DISPATCH;
    pfd->invkind = INVOKE_FUNC;
    pfd->callconv = CC_STDCALL;
    *pppfuncdesc = pfd;

    return S_OK;
}

STDMETHODIMP CType::GetVarDesc(UINT index, VARDESC **ppvardesc)
{
    TRACE("CType(%d): ITypeInfo::GetVarDesc: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetNames(MEMBERID memid, BSTR *rgbstrNames,
    UINT cMaxNames, UINT *pcNames)
{
    TRACE("CType(%d): ITypeInfo::GetNames(%d, %d)\n", m_iType,
        memid, cMaxNames);

    if (cMaxNames == 0)
    {
        *pcNames = 0;
        return S_OK;
    }

    // store the name of the event method <memid> in <aoch>
    int cch;
    OLECHAR aoch[_MAX_PATH];
    const char *sz;
    if ((sz = FindStringByIndex(m_szEventList, memid, &cch)) == NULL)
        return TYPE_E_ELEMENTNOTFOUND;
    MultiByteToWideChar(CP_ACP, 0, sz, cch, aoch,
        sizeof(aoch) / sizeof(*aoch) - 1);
    aoch[cch] = 0; // null-terminate

    // return the method name
    rgbstrNames[0] = SysAllocString(aoch);
    *pcNames = 1;

    return S_OK;
}

STDMETHODIMP CType::GetRefTypeOfImplType(UINT index, HREFTYPE *hpreftype)
{
    TRACE("CType(%d): ITypeInfo::GetRefTypeOfImplType(%d)\n", m_iType, index);
    *hpreftype = index; // could be any value I choose
    return S_OK;
}

STDMETHODIMP CType::GetImplTypeFlags(UINT index, INT *pimpltypeflags)
{
    TRACE("CType(%d): ITypeInfo::GetImplTypeFlags(%d)\n", m_iType, index);
    if (index == 0)
        *pimpltypeflags = IMPLTYPEFLAG_FDEFAULT;
    else
    if (index == 1)
        *pimpltypeflags = IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE;
    else
        return E_INVALIDARG;

    return S_OK;
}

STDMETHODIMP CType::GetIDsOfNames(OLECHAR **rglpszNames, UINT cNames,
    MEMBERID *rgmemid)
{
    TRACE("CType(%d): ITypeInfo::GetIDsOfNames: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::Invoke(void *pvInstance, MEMBERID memid, WORD wFlags,
    DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo,
    UINT *puArgErr)
{
    TRACE("CType(%d): ITypeInfo::Invoke: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetDocumentation(MEMBERID memid, BSTR *pbstrName,
    BSTR *pbstrDocString, DWORD *pdwHelpContext, BSTR *pbstrHelpFile)
{
    TRACE("CType(%d): ITypeInfo::GetDocumentation: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetDllEntry(MEMBERID memid, INVOKEKIND invkind,
    BSTR *pbstrDllName, BSTR *pbstrName, WORD *pwOrdinal)
{
    TRACE("CType(%d): ITypeInfo::GetDllEntry: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetRefTypeInfo(HREFTYPE hreftype, ITypeInfo **pptinfo)
{
    TRACE("CType(%d): ITypeInfo::GetRefTypeInfo(%d)\n", m_iType);
    HRESULT hr;
    if ((*pptinfo = New CType(hreftype, m_clsid, m_szEventList, &hr)) == NULL)
        hr = E_OUTOFMEMORY;
    return hr;
}

STDMETHODIMP CType::AddressOfMember(MEMBERID memid, INVOKEKIND invkind,
    void **ppv)
{
    TRACE("CType(%d): ITypeInfo::AddressOfMember: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::CreateInstance(IUnknown *puncOuter, REFIID riid,
    void **ppvObj)
{
    TRACE("CType(%d): ITypeInfo::CreateInstance: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetMops(MEMBERID memid, BSTR *pbstrMops)
{
    TRACE("CType(%d): ITypeInfo::GetMops: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetContainingTypeLib(ITypeLib **pptlib, UINT *pindex)
{
    TRACE("CType(%d): ITypeInfo::GetContainingTypeLib\n", m_iType);
    *pptlib = (ITypeLib *) this;
    (*pptlib)->AddRef();
    if (pindex != NULL)
        *pindex = m_iType;
    return S_OK;
}

STDMETHODIMP_(void) CType::ReleaseTypeAttr(TYPEATTR *ptypeattr)
{
    TRACE("CType(%d): ITypeInfo::ReleaseTypeAttr(0x%08lx)\n", m_iType,
        ptypeattr);
    TaskMemFree(ptypeattr);
}

STDMETHODIMP_(void) CType::ReleaseFuncDesc(FUNCDESC *pfuncdesc)
{
    TRACE("CType(%d): ITypeInfo::ReleaseFuncDesc\n", m_iType);
    Delete pfuncdesc;
}

STDMETHODIMP_(void) CType::ReleaseVarDesc(VARDESC *pvardesc)
{
    TRACE("CType(%d): ITypeInfo::ReleaseVarDesc: E_NOTIMPL\n", m_iType);
}

//////////////////////////////////////////////////////////////////////////////
// ITypeLib Implementation
//

STDMETHODIMP_(UINT) CType::GetTypeInfoCount(void)
{
    TRACE("CType(%d): ITypeLib::GetTypeInfoCount: E_NOTIMPL\n", m_iType);
    return 0;
}

STDMETHODIMP CType::GetTypeInfo(UINT index, ITypeInfo **ppitinfo)
{
    TRACE("CType(%d): ITypeLib::GetTypeInfo: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetTypeInfoType(UINT index, TYPEKIND *ptkind)
{
    TRACE("CType(%d): ITypeLib::GetTypeInfoType(%d)\n", m_iType, index);
    if (index == 0)
    {
        *ptkind = TKIND_DISPATCH;
        return S_OK;
    }
    else
        return TYPE_E_ELEMENTNOTFOUND;
}

STDMETHODIMP CType::GetTypeInfoOfGuid(REFGUID guid, ITypeInfo **pptinfo)
{
    TRACE("CType(%d): ITypeLib::GetTypeInfoOfGuid: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetLibAttr(TLIBATTR **pptlibattr)
{
    TRACE("CType(%d): ITypeLib::GetLibAttr: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetDocumentation(INT index, BSTR *pbstrName,
    BSTR *pbstrDocString, DWORD *pdwHelpContext, BSTR *pbstrHelpFile)
{
    TRACE("CType(%d): ITypeLib::GetDocumentation: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::IsName(LPOLESTR szNameBuf, ULONG lHashVal,
    BOOL *pfName)
{
    TRACE("CType(%d): ITypeLib::IsName: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::FindName(LPOLESTR szNameBuf, ULONG lHashVal,
    ITypeInfo **rgptinfo, MEMBERID *rgmemid, USHORT *pcFound)
{
    TRACE("CType(%d): ITypeLib::FindName: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP_(void) CType::ReleaseTLibAttr(TLIBATTR *ptlibattr)
{
    TRACE("CType(%d): ITypeLib::ReleaseTLibAttr: E_NOTIMPL\n", m_iType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\helpmem.cpp ===
// helpmem.cpp
//
// Implements HelpMemAlloc, HelpMemFree, and HelpMemDetectLeaks.
// Includes documentation for the macros TaskMemAlloc, TaskMemFree,
// HelpNew, and HelpDelete.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "Globals.h"
#include "debug.h"


#define HM_LEAKFIND 0 // 1 to enable memory leak finding


// EricLe: Chris Guzak says we shouldn't be calling OutputDebugString in a
// release build, and we never used this feature anyway, so I disabled it.
// #define HM_ODS // enable OutputDebugString in a release build


// globals
static ULONG _g_cbUnfreedBytes;   
    // the number of unfreed bytes allocated with HM_LEAKDETECT
static ULONG _g_cUnfreedBlocks;    
    // the number of unfreed blocks allocated with HM_LEAKDETECT

#ifdef _DEBUG
static ULONG _g_cCallsToHelpMemAlloc;
    // the number of calls made to HelpMemAlloc() since the last call to
    // HelpMemSetFailureMode()
static ULONG _g_ulFailureParam;
static DWORD _g_dwFailureMode;
    // these values are used to simulate memory allocation failures
#endif // _DEBUG




/* @func LPVOID | HelpMemAlloc |

        Allocates memory using either <f GlobalAlloc> or the task memory
        allocator retrieved using <f CoGetMalloc>.  Optionally
        zero-initializes the memory.  Optionally performs simple memory leak
        detection.

@rdesc  Returns a pointer to the allocated block of memory.  Returns NULL on
        error.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   HM_TASKMEM | The memory is allocated using <om IMalloc.Alloc>
                (using the task memory allocator retrieved from
                <f CoGetMalloc>).  If HM_TASKMEM is not specified, then
                <f GlobalAlloc> is used to allocate the memory.

        @flag   HM_ZEROINIT | The memory is zero-initialized.

        @flag   HM_LEAKDETECT | This DLL will keep track of the allocated
                memory block using a simple leak detection mechanism.
                <b Important>: If HM_LEAKDETECT is specified, then the
                returned memory pointer cannot be freed directly by
                <f GlobalFree> or <om IMalloc.Free> -- it must be freed
                using <f HelpMemFree>.

@parm   ULONG | cb | The number of bytes of memory to allocate.

@comm   This function allocates a block of <p cb> bytes of memory, using
        the allocation function (and optional zero-initialization) specified
        by <p dwFlags>.

        If HM_LEAKDETECT is specified, then an extra few bytes is allocated
        to keep track of leak detection information, and the returned pointer
        actually points several bytes beyond the beginning of the memory block.
        Therefore, <f HelpMemFree> must be called to free the block of memory.

        If HM_LEAKDETECT is <b not> specified, then <f GlobalFree> or
        <om IMalloc.Free> (depending on <p dwFlags>) can be called directly
        to free the block of memory.  (<f HelpMemFree> may also be used to
        free the memory block).

        If <f HelpMemFree> is called, the HM_TASKMEM and HM_LEAKDETECT flags
        (if any) specified for <f HelpMemAlloc> must also be passed to
        <f HelpMemFree>.

        Leak detection occurs automatically when this DLL unloads in the
		debug build: if an unfreed block is detected, a message box is
		displayed.
*/
STDAPI_(LPVOID) HelpMemAlloc(DWORD dwFlags, ULONG cb)
{
    IMalloc *       pmalloc;        // task allocator object
    ULONG           cbAlloc;        // bytes to actually allocate
    LPVOID          pv;             // allocated memory block

#if HM_LEAKFIND
        {
            EnterCriticalSection(&g_criticalSection);
            static int iAlloc = 0;
            TRACE("++HelpMem(%d) %d\n", ++iAlloc, cb);
            LeaveCriticalSection(&g_criticalSection);
        }
#endif

    // Possibly simulate an allocation failure.
#ifdef _DEBUG
    {
        BOOL fFail = FALSE;
        EnterCriticalSection(&g_criticalSection);

        // Count the call to HelpMemAlloc().
        _g_cCallsToHelpMemAlloc++;

        // Simulate a failure if the conditions are right.
        if (_g_dwFailureMode & HM_FAILAFTER)
        {
            fFail = (_g_cCallsToHelpMemAlloc > _g_ulFailureParam);
        }
        else if (_g_dwFailureMode & HM_FAILUNTIL)
        {
            fFail = (_g_cCallsToHelpMemAlloc <= _g_ulFailureParam);
        }
        else if (_g_dwFailureMode & HM_FAILEVERY)
        {
            fFail = ((_g_cCallsToHelpMemAlloc % _g_ulFailureParam) == 0);
        }
/*
        else if (_g_dwFailureMode & HM_FAILRANDOMLY)
        {
        }
*/
        LeaveCriticalSection(&g_criticalSection);
        if (fFail)
        {
            TRACE("HelpMemAlloc: simulated failure\n");
            return (NULL);
        }
    }
#endif

    // allocate <cb> bytes (plus 4 additional bytes if HM_LEAKDETECT is
    // specified, to store the length of the block for leak detection
    // purposes); point <pv> to the allocated block
    cbAlloc = cb + ((dwFlags & HM_LEAKDETECT) ? sizeof(ULONG) : 0);

    // set <pv> to the allocate memory block
    if (dwFlags & HM_TASKMEM)
    {
        // allocate using the tasks's IMalloc allocator
        if (FAILED(CoGetMalloc(1, &pmalloc)))
            return NULL;
        pv = pmalloc->Alloc(cbAlloc);
        pmalloc->Release();
    }
    else
    {
        // allocate using GlobalAlloc() (the following is copied from
        // <windowsx.h>)
        HGLOBAL h = GlobalAlloc(GMEM_MOVEABLE, cbAlloc);
        pv = GlobalLock(h);
    }

    if (pv != NULL)
    {
        // if HM_LEAKDETECT is specified, store <cb> at the beginning of the
        // block of memory and return a pointer to the byte beyond where <cb>
        // is stored, and keep track of memory allocated and not yet freed
        if (dwFlags & HM_LEAKDETECT)
        {
            *((ULONG *) pv) = cb;
            pv = (LPVOID) (((ULONG *) pv) + 1);
            EnterCriticalSection(&g_criticalSection);
            _g_cbUnfreedBytes += cb;
            _g_cUnfreedBlocks++;
            LeaveCriticalSection(&g_criticalSection);
        }

        // if HM_ZEROINIT is specified, zero-initialize the rest of the
        // memory block
        if (pv != NULL)
            memset(pv, 0, cb);
    }

    return pv;
}




/* @func void | HelpMemFree |

        Frees a block of memory previously allocated using <f HelpMemAlloc>.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   HM_TASKMEM | The memory was allocated using <om IMalloc.Alloc>
                (using the task memory allocator retrieved from
                <f CoGetMalloc>).  If HM_TASKMEM is not specified, then it
                is assumed that <f GlobalAlloc> is used to allocate the memory.

        @flag   HM_LEAKDETECT | The memory was allocated using <f HelpMemAlloc>
                with the HM_LEAKDETECT flag specified.

@parm   LPVOID | pv | A pointer to the block of memory that was previously
        allocated using <f HelpMemAlloc> or a NULL pointer.

@comm   The HM_TASKMEM and HM_LEAKDETECT flags (if any) specified for
        <f HelpMemAlloc> must also be passed to <f HelpMemFree>.
*/
STDAPI_(void) HelpMemFree(DWORD dwFlags, LPVOID pv)
{
    IMalloc *       pmalloc;        // task allocator object

    if (pv == NULL)
        return;

    // if HM_LEAKDETECT is specified, retrieve the byte count stored
    // just before <pv>, and move <pv> to the true beginning of the block
    // (the start of the byte count), and keep track of memory allocated
    // and not yet freed
    if (dwFlags & HM_LEAKDETECT)
    {
        // keep track of memory allocated and not yet freed
        pv = (LPVOID) (((ULONG *) pv) - 1);
        ULONG cb = *((ULONG *) pv);

#if HM_LEAKFIND
            TRACE("++HelpMem %d\n", -(int) cb);
#endif

        EnterCriticalSection(&g_criticalSection);
        _g_cbUnfreedBytes -= cb;
        _g_cUnfreedBlocks--;
        LeaveCriticalSection(&g_criticalSection);
    }

    if (dwFlags & HM_TASKMEM)
    {
        // memory was allocated using the tasks's IMalloc allocator
        if (FAILED(CoGetMalloc(1, &pmalloc)))
            return;
        pmalloc->Free(pv);
        pmalloc->Release();
    }
    else
    {
        // memory was allocated using GlobalAlloc() (the following is copied
        // from <windowsx.h>)
        HGLOBAL h = (HGLOBAL) GlobalHandle(pv);
        GlobalUnlock(h);
        GlobalFree(h);
    }
}




/* @func void | HelpMemSetFailureMode |

        Sets failure conditions for the memory allocator.  This can be used
        to simulate low-memory conditions and test a system's ability to 
        detect and/or handle these conditions.

@parm   LONG | lParam | 
        Argument used in conjunction with <p dwFlags>.

@parm   DWORD | dwFlags | 
        May contain the following flags (all of which are mutually exclusive):

        @flag   HM_FAILNEVER |
                Never fail memory allocation unless memory is truly exhausted.
                <p ulParam> is ignored.  This is the default failure mode for
                the memory allocator.

        @flag   HM_FAILAFTER |
                Begin failing memory allocation after <p ulParam> allocations have
                been attempted.  If, for example, <p ulParam> is 100, the next
                100 calls to <f HelpMemAlloc> will succeed (memory availability
                permitting), but the 101-st, 102-nd, etc. calls will fail.

        @flag   HM_FAILUNTIL |
                Start failing memory allocation immediately and continue until
                <p ulParam> allocations have been attempted.  If, for example,
                <p ulParam> is 100, the next 100 calls to <f HelpMemAlloc> will fail,
                but the 101-st, 102-nd, etc. calls will succeed (memory availability
                permitting).

        @flag   HM_FAILEVERY |
                Fail every <p ulParam>-th attempted memory allocation.  If,
                for example, <p ulParam> is 3, every third call to <f HelpMemAlloc>
                will fail.

        @flag   HM_FAILRANDOMLY |
                Simulate random memory allocation failure.  (<p ulParam> mod 100) 
                indicates the percentage chance that a given call to 
                <f HelpMemAlloc> will fail.  (Note: This flag currently has the
                same effect as HM_FAILNEVER.)

@comm   This function is only available in DEBUG builds of <l OCHelp>.  (There
        is a stub implementation that does nothing in the release builds.)
        Also, this function resets the allocation counter.  So, <p ulParam> is
        counted relative to the last call to this function.
*/
STDAPI_(void) HelpMemSetFailureMode(ULONG ulParam, DWORD dwFlags)
{   
#ifdef _DEBUG
    EnterCriticalSection(&g_criticalSection);

    // Reset the allocation counter.
    _g_cCallsToHelpMemAlloc = 0;

    // Save the failure settings.
    _g_ulFailureParam = ulParam;
    _g_dwFailureMode = dwFlags;

    LeaveCriticalSection(&g_criticalSection);
#endif // _DEBUG
}




// HelpMemDetectLeaks()
//
// (Called when DLL exits.)  Displays a message box (in debug build)
#ifdef HM_ODS
// or an OutputDebugString() message (in a release build)
#endif
// if any memory leaks were detected.
//
STDAPI_(void) HelpMemDetectLeaks()
{
    char ach[200];

#ifdef HM_ODS
    OutputDebugString("HelpMemDetectLeaks: ");
#endif

    // see if any allocated memory was not yet freed
    EnterCriticalSection(&g_criticalSection);
    if ((_g_cUnfreedBlocks != 0) || (_g_cbUnfreedBytes != 0))
    {
        // warn the user
        wsprintf(ach, "Detected memory leaks: %d unreleased blocks,"
            " %d unreleased bytes\n", _g_cUnfreedBlocks, _g_cbUnfreedBytes);
        LeaveCriticalSection(&g_criticalSection);
#ifdef HM_ODS
        OutputDebugString(ach);
#endif
#ifdef _DEBUG
        MessageBox(NULL, ach, "OCHelp HelpMemDetectLeaks",
            MB_ICONEXCLAMATION | MB_OK);
#endif
    }
    else
    {
        LeaveCriticalSection(&g_criticalSection);
#ifdef HM_ODS
        OutputDebugString("(none detected)");
#endif
    }

#ifdef HM_ODS
    OutputDebugString("\n");
#endif
}




/* @func LPVOID | TaskMemAlloc |

        Allocates memory using the task memory allocator (see <f CoGetMalloc>).
        This is simply a macro that calls <f HelpMemAlloc> with specific flags.

@rdesc  Returns a pointer to the allocated block of memory.  Returns NULL on
        error.

@parm   ULONG | cb | The number of bytes of memory to allocate.

*/


/* @func void | TaskMemFree |

        Frees a block of memory previously allocated using <f TaskMemAlloc>.
        This is simply a macro that calls <f HelpMemFree> with specific flags.

@parm   LPVOID | pv | A pointer to the block of memory to allocate.

*/


/* @func void * | HelpNew |

        Helps implement a version of the "new" operator that doesn't
        use the C runtime.  Zero-initializes the allocated memory.
        This is simply a macro that calls <f HelpMemAlloc> with specific flags.

@rdesc  Returns a pointer to the allocated block of memory.  Returns NULL on
        error.

@parm   size_t | cb | The number of bytes to allocate.

@ex     The following example shows how to use <f HelpNew> and <f HelpDelete>
        to define default "new" and "delete" operators. |

        void * operator new(size_t cb)
        {
            return HelpNew(cb);
        }

        void operator delete(void *pv)
        {
            HelpDelete(pv);
        }
*/


/* @func void | HelpDelete |

        Frees memory allocated by <f HelpNew>.  This is simply a macro that
        calls <f HelpMemFree> with specific flags.

@parm   void * | pv | The pointer to the memory to free.

@comm   See <f HelpNew> for more information.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\himetric.cpp ===
// himetric.cpp
//
// Implements HIMETRIC helper functions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"




/* @func void | PixelsToHIMETRIC |

        Converts a width and height from pixels (on the default monitor)
        to HIMETRIC units.

@parm   int | cx | The input width in pixels.

@parm   int | cy | The input height in pixels.

@parm   SIZE * | psize | The output size in HIMETRIC units.

*/
STDAPI_(void) PixelsToHIMETRIC(int cx, int cy, LPSIZEL psize)
{
    HDC hdc = GetDC(NULL);
    psize->cx = (cx * HIMETRIC_PER_INCH) / GetDeviceCaps(hdc, LOGPIXELSX);
    psize->cy = (cy * HIMETRIC_PER_INCH) / GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(NULL, hdc);
}


/* @func void | HIMETRICToPixels |

        Converts a width and height from HIMETRIC units to pixels
        (on the default monitor).

@parm   int | cx | The input width in HIMETRIC units.

@parm   int | cy | The input height in HIMETRIC units.

@parm   SIZE * | psize | The output size in pixels.

*/
STDAPI_(void) HIMETRICToPixels(int cx, int cy, SIZE *psize)
{
    HDC hdc = GetDC(NULL);
    psize->cx = (cx * GetDeviceCaps(hdc, LOGPIXELSX) + HIMETRIC_PER_INCH - 1)
        / HIMETRIC_PER_INCH;
    psize->cy = (cy * GetDeviceCaps(hdc, LOGPIXELSY) + HIMETRIC_PER_INCH - 1)
        / HIMETRIC_PER_INCH;
    ReleaseDC(NULL, hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\guid2tch.cpp ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		guid2tch.cpp
//				
// Description:	This file contains the implementation of the function,
//				TCHARFromGUID.
//
// History:		04/30/96	a-swehba
//					Created.
//				08/27/96	a-swehba
//					TCHARFromGUID() -- pass #chars to StringFromGUID2 instead
//						of #bytes.
//
// @doc MMCTL
//===========================================================================

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"




//---------------------------------------------------------------------------
// @func	TCHAR* | TCHARFromGUID |
//			Converts a GUID to a TCHAR-based string representation.
//
// @parm	REFGUID | guid |
//			[in] The GUID to convert.
//
// @parm	TCHAR* | pszGUID |
//			[out] The string form of the <p guid>.  Can't be NULL.
//
// @parm	int | cchMaxGUIDLen |
//			[in] <p szGUID> is, on entry, assumed to point to a buffer of
//			at least <p cchMaxGUIDLen> characters in length.  Must be
//			greater at least 39.
//
// @rdesc	Returns an alias to <p pszGUID>.
//
// @comm	Unlike <f StringFromGUID2> which always returns an OLECHAR form
//			of the GUID string, this function returns a wide or single-byte
//			form of the string depending on the build environment.
//
// @xref	<f CLSIDFromTCHAR>
//---------------------------------------------------------------------------

STDAPI_(TCHAR*) TCHARFromGUID(
REFGUID guid,
TCHAR* pszGUID,
int cchMaxGUIDLen)
{
	const int c_cchMaxGUIDLen = 50;
	OLECHAR aochGUID[c_cchMaxGUIDLen + 1];

	// Preconditions

	ASSERT(pszGUID != NULL);
	ASSERT(cchMaxGUIDLen >= 39);
	
	// Convert the guid to a UNICODE string.

	if (StringFromGUID2(guid, aochGUID, c_cchMaxGUIDLen) == 0)
	{
		return (NULL);
	}

	// Convert or copy the UNICODE string into a TCHAR form.

#ifdef UNICODE
	lstrcpy(pszGUID, aochGUID);
#else
	UNICODEToANSI(pszGUID, aochGUID, cchMaxGUIDLen);
#endif
	return (pszGUID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\lpbfs.cpp ===
// lpbfs.cpp
//
// Implements LoadPropertyBagFromStream.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | LoadPropertyBagFromStream |

        Load properties that are stored in an <i IStream> (in the simple
        tagged binary format written by <f WriteVariantProperty>) into an
        <i IPropertyBag> object.

@rvalue S_OK | Success.

@rvalue E_FAIL | I/O error.

@parm   IStream * | pstream | The stream to read from.

@parm   IPropertyBag * | ppb | The property bag to write to.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   Note that this function does not (cannot, in fact) empty <p ppb>
        prior to loading property name/value pairs from <p pstream>.
*/
STDAPI LoadPropertyBagFromStream(IStream *pstream, IPropertyBag *ppb,
    DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    VariantProperty vp;             // a property name/value pair in <pmvio>

    // ensure correct cleanup
    VariantPropertyInit(&vp);

    // loop once for each property in the stream
    while (TRUE)
    {
        // set <vp> to the next property name/value pair in <pstream>
        VariantPropertyClear(&vp);
        if (FAILED(hrReturn = ReadVariantProperty(pstream, &vp, 0)))
            goto ERR_EXIT;
        if (hrReturn == S_FALSE)
        {
            // hit end of stream
            hrReturn = S_OK;
            break;
        }

        // wrote <vp> to the property bag
        if (FAILED(hrReturn = ppb->Write(vp.bstrPropName, &vp.varValue)))
            goto ERR_EXIT;
    }

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    VariantPropertyClear(&vp);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\lib.cpp ===
// StaticLib.cpp
//
// Implements functions for initializing and uninitializing the static version
// of OCHelp.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "Globals.h"
#include "debug.h"

void CleanupUrlmonStubs();	// see urlmon.cpp

/*----------------------------------------------------------------------------
	@func BOOL | InitializeStaticOCHelp |
	
	Initialize the static version of OCHelp.

	@comm
	If your control links to the static version of the OCHelp library, you must
	call this function before you call any other OCHelp APIs.  The ideal place
	to do this is within your control's _DllMainCRTStartup implementation.  You
	must also call <f UninitializeStaticOCHelp> when you're done with the
	library.

	@rvalue TRUE | Success.
	@rvalue FALSE | Failure: DLL will not load.

	This isn't required when using the DLL version of OCHelp.

  ----------------------------------------------------------------------------*/

STDAPI_(BOOL)
InitializeStaticOCHelp
(
	HINSTANCE hInstance  // @parm  Application instance.
)
{
	ASSERT(hInstance != NULL);

	g_hinst = hInstance;

	::InitializeCriticalSection(&g_criticalSection);

	return TRUE;
}


/*----------------------------------------------------------------------------
	@func void | UninitializeStaticOCHelp |
	
	Uninitialize the static version of OCHelp.

	@comm
	If your control links to the static version of the OCHelp library, you must
	call this when your control is done using the library.  The ideal place to
	do this is within your control's _DllMainCRTStartup implementation.  You
	must also call <f InitializeStaticOCHelp> before you use the library.

	Do not call any OCHelp APIs after calling this function.

	This isn't required when using the DLL version of OCHelp.

  ----------------------------------------------------------------------------*/

STDAPI_(void)
UninitializeStaticOCHelp()
{
	ASSERT(g_hinst != NULL);

#ifndef _M_ALPHA
	::CleanupUrlmonStubs();
#endif
	::HelpMemDetectLeaks();
	::DeleteCriticalSection(&g_criticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\objsafe.cpp ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		objsafe.cpp
//				
// Description:	This file contains the implementation of the function,
//				GetObjectSafety().
//
// History:		07/12/96	a-swehba
//					Created.
//				07/19/96	a-swehba
//					Changed comment.
//
// @doc MMCTL
//===========================================================================

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "precomp.h"
#include <objsafe.h>			// IObjectSafety
#include "..\..\inc\catid.h"	// CATID_SafeForScripting2, etc.
#include "debug.h"				// ASSERT()
#include "..\..\inc\ochelp.h"		// TCHARFromCLSID()




//---------------------------------------------------------------------------
// Local Function Declarations
//---------------------------------------------------------------------------

static void		_GetObjectSafetyViaIObjectSafety(
					IObjectSafety* pObjectSafety,
					va_list iidList,
					BOOL* pfSafeForScripting,
					BOOL* pfSafeForInitializing);
static HRESULT	_GetObjectSafetyViaRegistry(
					CLSID* pclsid,
					BOOL* pfSafeForScripting, 
					BOOL* pfSafeForInitializing);




/*---------------------------------------------------------------------------
@func	HRESULT | GetObjectSafety |
		Determines if an object is safe-for-scripting and/or
		safe-for-initializing vis-a-vis a given set of interfaces.

@parm	BOOL* | pfSafeForScripting |
		[out] If non-NULL, set to TRUE if the object is safe-for-scripting.

@parm	BOOL* | pfSafeForInitializing |
		[out] If non-NULL, set to TRUE if the object is safe-for-initializing

@parm	IUnknown* | punk |
		[in] The object's IUnknown interface.  If non-NULL, an attempt
		will be made to assess the object's safety via its <i IObjectSafety>
		interface.  If NULL, or the the object doesn't support this interface, 
		its safety will be assessed using <p pclsid> and the system registry.

@parm	CLSID* | pclsid |
		[in] The object's class ID.  If <p punk> is NULL or the object
		doesn't support <i IObjectSafety>, then <p pclsid> will be used
		to look up the object's safety in the system registry (as long
		as <p pclsid> is also non-NULL).

@parm	IID* | (interfaces) |
		[in] A variable number of interfaces pointers, the last of which
		must be NULL.  If the object's safety is assessed via 
		<i IObjectSafety> (see <p punk>) then it's safety is assessed 
		vis-a-vis this set of interfaces.  These interfaces are not used 
		if the object's safety is examined via the system registry.

@rvalue	S_OK |
		Success.  The object's safety was assessible and *<p pfSafeForScripting>
		and/or *<p pfSafeForInitializing> have been set accordingly.

@rvalue	E_FAIL |
		Failure.  The object's safety couldn't be assessed.  The values
		of *<p pfSafeForScripting> and *<p pfSafeForInitializing> are
		indeterminate.

@comm	If your code uses OCMisc (i.e., #includes ocmisc.h), it should also
		[#include <lt>objsafe.h<gt>] whereever it #includes <lt>initguid.h<gt>.  This will
		cause IID_IObjectSafety to be defined.

@ex		The following example shows how to test whether an object is 
		safe-for-scripting and safe-for-initializing by checking the system 
		registry only: |

			BOOL fSafeForScripting;
			BOOL fSafeForInitializing;
			GetObjectSafety(&fSafeForScripting, &fSafeForInitializing,
				NULL, &CLSID_MyObject, NULL);

@ex		The following example shows how to test whether an object is
		safe-for-scripting via IDispatch using the object's <i IObjectSafety>
		interface: |

			BOOL fSafeForScripting;
			GetObjectSafety(&fSafeForScripting, NULL, punk, NULL, 
				&IID_IDispatch, NULL);

@ex		The following example shows how to test whether an object is 
		safe-for-initialzing via IPersistStream, IPersistStreamInit, or
		IPersistPropertyBag using the object's <i IObjectSafety> interface
		or, if <i IObjectSafety> is not supported, the registry: |

			BOOL fSafeForInitializing;
			GetObjectSafety(NULL, &safeForInitializing, punk, &CLSID_MyObject, 
				&IID_IPersistStream, &IID_IPersistStreamInit,
				&IID_IPersistPropertyBag, NULL);
---------------------------------------------------------------------------*/

HRESULT __cdecl GetObjectSafety(
BOOL* pfSafeForScripting,
BOOL* pfSafeForInitializing,
IUnknown* punk,
CLSID* pclsid,
...)
{
	IObjectSafety* pObjectSafety = NULL;
		// <punk>'s IObjectSafety interface
    va_list interfaces;
		// optional OLE interface IDs to use when checking safety via
		// IObjectSafety
	HRESULT hr = S_OK;
		// function return value


	// If supplied with an IUnknown pointer to the object, first try to 
	// find the object's safety through IObjectSafety.

	if (punk != NULL)
	{
		hr = punk->QueryInterface(IID_IObjectSafety, (void**)&pObjectSafety);
		if (SUCCEEDED(hr))
		{
			va_start(interfaces, pclsid);
			_GetObjectSafetyViaIObjectSafety(pObjectSafety, 
										     interfaces, 
										     pfSafeForScripting,
										     pfSafeForInitializing);
			va_end(interfaces);
			pObjectSafety->Release();
			goto Exit;
		}
	}

	// If no pointer to the object was supplied, or the object doesn't
	// support IObjectSafety, try to find if the object is safe via
	// the registry.

	hr = _GetObjectSafetyViaRegistry(pclsid,
									 pfSafeForScripting, 
									 pfSafeForInitializing);

Exit:

	return (hr);
}




//---------------------------------------------------------------------------
// Function:	_GetObjectSafetyViaIObjectSafety
//
// Synopsis:	Determine an object's safety via the object's IObjectSafety
//				interface.
//
// Arguments:	[in] pObjectSafety
//					A pointer to the object's IObjectSafety interface.
//				[in] iidList
//					A of IID*'s.  Must end with NULL.
//				[out] pfSafeForScripting
//					If non-NULL, set to TRUE if the object associated with
//					<pObjectSafety> is safe-for-scripting via any of the 
//					interfaces in <iidList>.  Set to FALSE otherwise.
//				[out] pfSafeForInitializing
//					If non-NULL, set to TRUE if the object associated with
//					<pObjectSafety> is safe-for-initializing via any of the
//					interfaces in <iidList>.  Set to FALSE otherwise.
//
// Returns:		(nothing)
//
// Requires:	pObjectSafety != NULL
//
// Ensures:		(nothing)
//
// Notes:		(none)
//---------------------------------------------------------------------------

static void _GetObjectSafetyViaIObjectSafety(
IObjectSafety* pObjectSafety,
va_list iidList,
BOOL* pfSafeForScripting,
BOOL* pfSafeForInitializing)
{
	IID* piid;
	BOOL fSafeForScripting = FALSE;
	BOOL fSafeForInitializing = FALSE;
	DWORD dwOptionsSetMask;
	DWORD dwEnabledOptions;

	// Preconditions

	ASSERT(pObjectSafety != NULL);

	// As long as the object isn't safe

	while ((piid = va_arg(iidList, IID*)) != NULL)
	{
		// Try to make the object safe for scripting via the current
		// interface.

		if (!fSafeForScripting)
		{
			dwOptionsSetMask = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			dwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			fSafeForScripting = 
				(SUCCEEDED(pObjectSafety->SetInterfaceSafetyOptions(
											*piid,
											dwOptionsSetMask,
											dwEnabledOptions)));
		}

		// Try to make the object safe for initializing via the current
		// interface.

		if (!fSafeForInitializing)
		{
			dwOptionsSetMask = INTERFACESAFE_FOR_UNTRUSTED_DATA;
			dwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
			fSafeForInitializing = 
				(SUCCEEDED(pObjectSafety->SetInterfaceSafetyOptions(
											*piid,
											dwOptionsSetMask,
											dwEnabledOptions)));
		}
	}

	// Set the return arguments.

	if (pfSafeForScripting != NULL)
	{
		*pfSafeForScripting = fSafeForScripting;
	}
	if (pfSafeForInitializing != NULL)
	{
		*pfSafeForInitializing = fSafeForInitializing;
	}
}




//---------------------------------------------------------------------------
// Function:	_GetObjectSafetyViaRegistry
//
// Synopsis:	Determine an object's safety via the system registry.
//
// Arguments:	[in] pclsid
//					The class ID of the object.  If NULL, the function
//					returns E_FAIL.
//				[out] pfSafeForScripting
//					If non-NULL on entry, set to TRUE if the class/object
//					is registered as safe-for-scripting and FALSE if it 
//					isn't.
//				[out] pfSafeForInitializing
//					If non-NULL on entry, set to TRUE if the class/object
//					is registered as safe-for-initializing and FALSE if it
//					isn't.
//
// Returns:		S_OK
//					Success.  <pclsid> is a registered class ID.  
//					<*pfSafeForScripting> and/or <*pfSafeForInitializing>
//					have been set.
//				E_FAIL
//					Failure.  Either <pclsid> is NULL or there was a problem
//					reading the registry.  In either case, <*pfSafeFor-
//					Scripting> and <*pfSafeForInitializing> aren't altered.
//
// Requires:	(nothing)
//
// Ensures:		(nothing)
//
// Notes:		(none)
//---------------------------------------------------------------------------

static HRESULT _GetObjectSafetyViaRegistry(
CLSID* pclsid,
BOOL* pfSafeForScripting, 
BOOL* pfSafeForInitializing)
{
	const int c_cchMaxCLSIDLen = 100;
		// maximum length (in characters) of a class ID represented as a
		// string
	TCHAR szCLSID[c_cchMaxCLSIDLen + 1];
		// <*pclsid> as a string
	TCHAR szKeyPath[c_cchMaxCLSIDLen + 100];
		// a registry key path
	HKEY hKey1 = NULL;
	HKEY hKey2 = NULL;
	HKEY hKey3 = NULL;
		// registry keys
	HRESULT hr = S_OK;
		// function return value

	// If no class ID was supplied, we can't get very far in the registry.

	if (pclsid == NULL)
	{
		goto ExitFail;
	}

	// hKey1 = HKEY_CLASSES_ROOT\CLSID\<*pclsid>

	lstrcpy(szKeyPath, _T("CLSID\\"));
	lstrcat(szKeyPath, TCHARFromGUID(*pclsid, szCLSID, c_cchMaxCLSIDLen));
	if (RegOpenKey(HKEY_CLASSES_ROOT, szKeyPath, &hKey1) != ERROR_SUCCESS)
	{
		goto ExitFail;
	}

	// hKey2 = HKEY_CLASSES_ROOT\CLSID\<*pclsid>\"Implemented Categories"

	if (RegOpenKey(hKey1, _T("Implemented Categories"), &hKey2) != ERROR_SUCCESS)
	{
		hKey2 = NULL;
	}

	// Look to see if the class is registered as safe-for-scripting.

	if (pfSafeForScripting != NULL)
	{
		if (hKey2 == NULL)
		{
			*pfSafeForScripting = FALSE;
		}
		else
		{
			TCHARFromGUID(CATID_SafeForScripting2, szCLSID, c_cchMaxCLSIDLen);
			*pfSafeForScripting = (RegOpenKey(hKey2, szCLSID, &hKey3) == 
									ERROR_SUCCESS);
		}
	}

	// Look to see if the class is registered as safe-for-initializing.

	REG_CLOSE_KEY(hKey3);
	if (pfSafeForInitializing != NULL)
	{
		if (hKey2 == NULL)
		{
			*pfSafeForInitializing = FALSE;
		}
		else
		{
			TCHARFromGUID(CATID_SafeForInitializing2, szCLSID, c_cchMaxCLSIDLen);
			*pfSafeForInitializing = (RegOpenKey(hKey2, szCLSID, &hKey3) == 
										ERROR_SUCCESS);
		}
	}

Exit:

	REG_CLOSE_KEY(hKey1);
	REG_CLOSE_KEY(hKey2);
	REG_CLOSE_KEY(hKey3);
	return (hr);

ExitFail:

	hr = E_FAIL;
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\msgwnd.cpp ===
// msgwnd.cpp
//
// Implements the hidden message-passing window.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "Globals.h"
#include "debug.h"


// byte offsets of extra window long values
#define WL_MSGWNDCALLBACK   (0 * sizeof(LONG_PTR))  // contains a MsgWndCallback *
#define WL_LPARAM           (1 * sizeof(LONG_PTR))  // contains a LPARAM
#define WL_TIMERCALLBACK    (2 * sizeof(LONG_PTR))  // contains a MsgWndCallback *
#define WL_LPARAMTIMER      (3 * sizeof(LONG_PTR))  // LPARAM for timer functions

#define _WL_COUNT           4                   // count of window longs


// MsgWndProc
//
// This is the window procedure for the hidden message-passing window.
//
LRESULT CALLBACK MsgWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam,
    LPARAM lParam)
{
    if (uiMsg == WM_COMMAND)
    {
        TRACE("MsgWnd 0x%x: WM_COMMAND %d\n", hwnd, LOWORD(wParam));

        // the callback function pointer and parameter have been temporarily
        // stored in window longs -- get them
        MsgWndCallback *pprocCaller = (MsgWndCallback *)
            GetWindowLongPtr(hwnd, WL_MSGWNDCALLBACK);
        LPARAM lParamCaller = (LPARAM) GetWindowLongPtr(hwnd, WL_LPARAM);

        ASSERT(pprocCaller != NULL);
                if (pprocCaller == NULL)
                        return 0;
        pprocCaller(uiMsg, wParam, lParamCaller);

        // clear the window longs
        SetWindowLongPtr(hwnd, WL_MSGWNDCALLBACK, (LONG_PTR) NULL);
        SetWindowLongPtr(hwnd, WL_LPARAM, (LONG_PTR) NULL);
        return 0;
    }

        if (uiMsg == WM_TIMER)
        {
        // TRACE("MsgWnd 0x%x: WM_TIMER\n", hwnd);

        // the callback function pointer has been stored in a window long,
                // as has the caller-supplied LPARAM (which is a parameter to pass
                // back to the callback; this LPARAM is typically used to store a
                // class "this" pointer)
        MsgWndCallback *pprocCaller = (MsgWndCallback *)
            GetWindowLongPtr(hwnd, WL_TIMERCALLBACK);
        LPARAM lParamCaller = (LPARAM) GetWindowLongPtr(hwnd, WL_LPARAMTIMER);
        ASSERT(pprocCaller != NULL);
                if (pprocCaller == NULL)
                        return 0;
        pprocCaller(WM_TIMER, wParam, lParamCaller);
                return 0;
        }
        else
    if ((uiMsg >= WM_USER) && (uiMsg <= 0x7FFF))
    {
        // TRACE("MsgWnd 0x%x: WM_USER+%d\n", hwnd, uiMsg - WM_USER);
        ((MsgWndCallback *) wParam)(uiMsg, 0, lParam);
        return 0;
    }

    switch (uiMsg)
    {
    case WM_CREATE:
        TRACE("MsgWnd 0x%x: WM_CREATE\n", hwnd);
        break;
    case WM_DESTROY:
        TRACE("MsgWnd 0x%x: WM_DESTROY\n", hwnd);
        break;
    }

    return DefWindowProc(hwnd, uiMsg, wParam, lParam);
}


/* @func HWND | MsgWndCreate |

        Creates the hidden message-passing window (if it doesn't exist).
        This window is used by <f MsgWndSendToCallback>,
        <f MsgWndPostToCallback>, and <f MsgWndTrackPopupMenuEx>.

@rdesc  Returns the handle of the message-passing window.  Returns NULL on
        error.

@comm   You should call <f MsgWndCreate> in the constructor of your
        control to ensure that the window gets created on the same thread
        as the thread which created your control.

        You should call <f MsgWndDestroy> in the destructor of your control.
*/
STDAPI_(HWND) MsgWndCreate()
{
    HWND            hwnd = NULL;    // hidden message-passing window

    // create the hidden message-passing window <hwnd>
    WNDCLASS wc;
    memset(&wc, 0, sizeof(wc));
    wc.lpfnWndProc = MsgWndProc; 
    wc.cbWndExtra = _WL_COUNT * sizeof(LONG_PTR);
    wc.hInstance = g_hinst; 
    wc.lpszClassName = "__EricLeMsgWnd__";
    RegisterClass(&wc); // okay if this fails (multiple registration)
    hwnd = CreateWindow(wc.lpszClassName, "", WS_POPUP,
        0, 0, 0, 0, NULL, NULL, g_hinst, NULL);
    if (hwnd != NULL)
    {
        // zero-initialize the window longs
        SetWindowLongPtr(hwnd, WL_MSGWNDCALLBACK, (LONG_PTR) NULL);
        SetWindowLongPtr(hwnd, WL_LPARAM, (LONG_PTR) NULL);
    }

    return hwnd;
}


/* @func LRESULT | MsgWndDestroy |

        Destroys a hidden message-passing window that was previously created
        by calling <f MsgWndCreate>.  If the MWD_DISPATCHALL flag is included in
        dwFlags, all the window's pending messages are dispatched before the window
        is destroyed.

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   DWORD | dwFlags | May contain the following flag:

        @flag   MWD_DISPATCHALL | Dispatch all the window's messages before
                                                                   destroying the window.  By default, any
                                                                   messages left in the queue are lost.

@parm   <f MsgWndDestroy> is typically called in the destructor of a control.

        <f MsgWndDestroy> should only be called in the thread that called
        <f MsgWndCreate>.
*/
STDAPI_(void) MsgWndDestroy(HWND hwnd, DWORD dwFlags)
{
    TRACE("MsgWndDestroy(0x%x)\n", hwnd);
        ASSERT(0 == dwFlags || MWD_DISPATCHALL == dwFlags);

        if (dwFlags & MWD_DISPATCHALL)
        {
                MSG msg;
                while (PeekMessage(&msg, hwnd, 0, (UINT) -1, PM_REMOVE))
                {
                // TRACE("MsgWnd 0x%x: dispatching message %u\n", hwnd, msg.message);
                DispatchMessage(&msg);
                }
        }

    DestroyWindow(hwnd);
}


/* @func LRESULT | MsgWndSendToCallback |

        Sends a message to the control's hidden message-passing window
        (typically created by calling <f MsgWndCreate> in the control's
        constructor).  When the window receives the message, it calls a given
        callback function.  This can be used to safely pass information
        between threads.

@rdesc  Returns the value returned by <f SendMessage> (-1 on error).

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   MsgWndCallback * | pproc | The callback function that is to receive
        the message.  This function will be called on whatever thread
        calls <f DispatchMessage>.  The <p wParam> parameter of this function
        should be ignored by the callback function.

@parm   UINT | uiMsg | A message number to pass to <p pproc>.  This is a
        window message number, so it must be in the range WM_USER through
        0x7FFF.

@parm   LPARAM | lParam | A parameter to pass to <p pproc>.

@comm   Message <p uiMsg> is sended (via <f SendMessage>) to the hidden
        message-passing window <p hwnd>.  When the window receives the
        message, it calls <p pproc>(<p uiMsg>, <p lParam>).

        Note that the calling thread blocks until the message is processed
        by the receiving thread.

@ex     The following example declares a callback function and calls it
        via <f MsgWndSendToCallback>.  Note that <p wParam> is for internal
        use by <f MsgWndPostToCallback> and should be ignored by the
        callback function.  |

        void CALLBACK MyMsgWndCallback(UINT uiMsg, WPARAM wParam, LPARAM lParam)
        {
            TRACE("got the callback: uiMsg=%u, lParam=%d\n", uiMsg, lParam);
        }

        ...
        MsgWndSendToCallback(MyMsgWndCallback, WM_USER, 42);
*/
STDAPI_(LRESULT) MsgWndSendToCallback(HWND hwnd, MsgWndCallback *pproc,
    UINT uiMsg, LPARAM lParam)
{
    ASSERT(hwnd != NULL); // if this fails, see new MsgWnd* documentation
    ASSERT(IsWindow(hwnd)); // if this fails, see new MsgWnd* documentation
    return SendMessage(hwnd, uiMsg, (WPARAM) pproc, lParam);
}


/* @func LRESULT | MsgWndPostToCallback |

        Posts a message to the control's hidden message-passing window
        (typically created by calling <f MsgWndCreate> in the control's
        constructor).  When the window receives the message, it calls a given
        callback function.  This can be used to safely pass information
        between threads.

@rdesc  Returns the value returned by <f PostMessage> (-1 on error).

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   MsgWndCallback * | pproc | The callback function that is to receive
        the message.  This function will be called on whatever thread
        calls <f DispatchMessage>.  The <p wParam> parameter of this function
        should be ignored by the callback function.

@parm   UINT | uiMsg | A message number to pass to <p pproc>.  This is a
        window message number, so it must be in the range WM_USER through
        0x7FFF.

@parm   LPARAM | lParam | A parameter to pass to <p pproc>.

@comm   Message <p uiMsg> is posted (via <f PostMessage>) to the hidden
        message-passing window <p hwnd>.  When the window receives the
        message, it calls <p pproc>(<p uiMsg>, <p lParam>).

@ex     The following example declares a callback function and calls it
        via <f MsgWndPostToCallback>.  Note that <p wParam> is for internal
        use by <f MsgWndPostToCallback> and should be ignored by the
        callback function. |

        void CALLBACK MyMsgWndCallback(UINT uiMsg, WPARAM wParam, LPARAM lParam)
        {
            TRACE("got the callback: uiMsg=%u, lParam=%d\n", uiMsg, lParam);
        }

        ...
        MsgWndPostToCallback(MyMsgWndCallback, WM_USER, 42);
*/
STDAPI_(LRESULT) MsgWndPostToCallback(HWND hwnd, MsgWndCallback *pproc,
    UINT uiMsg, LPARAM lParam)
{
    ASSERT(hwnd != NULL); // if this fails, see new MsgWnd* documentation
    ASSERT(IsWindow(hwnd)); // if this fails, see new MsgWnd* documentation
    return PostMessage(hwnd, uiMsg, (WPARAM) pproc, lParam);
}


/* @func LRESULT | MsgWndTrackPopupMenuEx |

        Calls <f TrackPopupMenuEx> to display a popup menu, and directs
        WM_COMMAND messages to a given callback function.  Can be used by
        a windowless control to display a popup context menu.

@rdesc  Returns the value returned by <f TrackPopupMenuEx> (FALSE on error).
        Returns FALSE if the message window is currently being used for
        another popup menu.

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   HMENU | hmenu | See <f TrackPopupMenuEx>.

@parm   UINT | fuFlags | See <f TrackPopupMenuEx>.

@parm   int | x | See <f TrackPopupMenuEx>.

@parm   int | y | See <f TrackPopupMenuEx>.

@parm   LPTPMPARAMS | lptpm | See <f TrackPopupMenuEx>.

@parm   MsgWndCallback * | pproc | The callback function that is to receive
        WM_COMMAND messages.  The <p wParam> parameter of this function
        is the <p wParam> of the WM_COMMAND message.  The <p lParam> parameter
        of this function is the <p lParam> of <f MsgWndTrackPopupMenuEx>.

@parm   LPARAM | lParam | A parameter to pass to <p pproc>.

@comm   This function calls <f TrackPopupMenuEx>.  Any WM_COMMAND messages
        from <f TrackPopupMenuEx> are passed to <p pproc>.

        The hidden message-passing window is used to receive WM_COMMAND
        messages; this window is created if it doesn't yet exist.
*/
STDAPI_(BOOL) MsgWndTrackPopupMenuEx(HWND hwnd, HMENU hmenu, UINT fuFlags,
    int x, int y, LPTPMPARAMS lptpm, MsgWndCallback *pproc, LPARAM lParam)
{
    ASSERT(hwnd != NULL); // if this fails, see new MsgWnd* documentation
    ASSERT(IsWindow(hwnd)); // if this fails, see new MsgWnd* documentation
    SetWindowLongPtr(hwnd, WL_MSGWNDCALLBACK, (LONG_PTR) pproc);
    SetWindowLongPtr(hwnd, WL_LPARAM, (LONG_PTR) lParam);
    return TrackPopupMenuEx(hmenu, fuFlags, x, y, hwnd, lptpm);
}


/* @func LRESULT | MsgWndSetTimer |

        Calls <f SetTimer> to cause WM_TIMER messages to be sent to the
                the control's hidden message-passing window (typically created
                by calling <f MsgWndCreate> in the control's constructor).
                When the window receives the message, it calls a given
        callback function.

@rdesc  Returns the value returned by <f SetTimer> (0 on error).

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   MsgWndCallback * | pproc | The callback function that is called
        when the timer fires.  This function will be called on whatever thread
        calls <f DispatchMessage>.  When <p pproc> receives WM_TIMER, <p wParam>
        is <p nIDEvent> and <p lParam> is the value of <p lParam> passed
        to <f MsgWndSetTimer>.

@parm   UINT | nIDEvent | See WM_TIMER.

@parm   UINT | uElapse | See WM_TIMER.

@parm   LPARAM | lParam | A parameter to pass to <p pproc>.

@comm   Note that only one callback function <p pproc> can be used per
        message-passing HWND.
*/
STDAPI_(UINT_PTR) MsgWndSetTimer(HWND hwnd, MsgWndCallback *pproc, UINT nIDEvent,
        UINT uElapse, LPARAM lParam)
{
    ASSERT(hwnd != NULL); // if this fails, see new MsgWnd* documentation
    ASSERT(IsWindow(hwnd)); // if this fails, see new MsgWnd* documentation
    SetWindowLongPtr(hwnd, WL_TIMERCALLBACK, (LONG_PTR) pproc);
    SetWindowLongPtr(hwnd, WL_LPARAMTIMER, (LONG_PTR) lParam);
    return SetTimer(hwnd, nIDEvent, uElapse, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\pc.cpp ===
// pc.cpp
//
// Implements PersistChild.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | PersistChild |

        Loads or saves a child of a given container object from/to a given.
        <i IVariantIO> object.  Used to help implement persistence in control
        containers.

@rvalue S_OK | Success.

@rvalue S_FALSE | <p pvio> is in loading mode, and collection <p szCollection>
        does not contain a child numbered <p iChild>.  (This typically tells
        the container that it can stop trying to load children.)

@parm   IVariantIO * | pvio | The <i IVariantIO> object to read properties from
        or write properties to.

@parm   LPCSTR | szCollection | The name of the collection that the child
        object belongs to.  See <f PersistSiteProperties> for more information
        about collections.

@parm   int | iChild | The index (into the collection named by <p szCollection>)
        of the child object whose site properties are being persisted by this
        call to <f PersistSiteProperties>.  Conventionally, indices are 1-based
        (i.e. the first child object in the collection is numbered 1, not 0).
        See <f PersistSiteProperties> for more information.

@parm   LPUNKNOWN | punkOuter | The controlling unknown to use for the
        new child object, if the child object is loaded (i.e. if <p pvio>
        is in loading mode and if a child object is successfully loaded).

@parm   DWORD | dwClsContext | Specifies the context in which the executable
        is to be run. The values are taken from the enumeration CLSCTX.
        A typical value is CLSCTX_INPROC_SERVER.  This parameter is ignored
        unless if <p pvio> is in loading mode and a child object is
        successfully loaded.

@parm   LPUNKNOWN * | ppunk | A pointer to an LPUNKNOWN variable that currently
        contains (if <p pvio> is in saving mode) or into which will be stored
        (if <p pvio> is in loading mode) the pointer to the child control.

@parm   CLSID * | pclsid | Where to store the class ID of the child object,
        if <p pvio> is in loading mode.  If <p pclsid> is NULL then this
        information is not returned.  If <p pvio> is in saving mode and
        <p pclsid> is not NULL, then on entry *<p pclsid> is assumed to contain
        the class ID of the child object (useful if the child object does not
        implement <i IPersist>); if not specified, the class ID of the child
        is obtained by calling <i IPersist> on the child.

@parm	BOOL * | pfSafeForScripting | If non-NULL, *<p pfSafeForScripting> is
		set to TRUE or FALSE depending on whether the control is safe-for-scripting.

@parm	BOOL * | pfSafeForInitializing | If non-NULL, *<p pfSafeForInitializing> is
		set to TRUE or FALSE depending on whether the control is safe-for-initializing.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@ex     See <f PersistSiteProperties> for an example of how <f PersistChild>
        is used. |
*/
STDAPI PersistChild(IVariantIO *pvio, LPCSTR szCollection,
    int iChild, LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk,
    CLSID *pclsid, BOOL *pfSafeForScripting, BOOL *pfSafeForInitializing,
	DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    CLSID           clsid;          // class ID of the child
    IPropertyBag *  ppb = NULL;     // interface onto <pvio>
    IPersist *      ppersist = NULL; // interface on child
    IPersistPropertyBag *pppb = NULL; // interface on child
    IPersistStream *pps = NULL;     // interface on child
    IPropertyBag *  ppbChild = NULL; // child's "virtual property bag"
    IStream *       psBuf = NULL;   // memory-based stream containing temp. data
    ULONG           cbBuf;          // no. bytes in <psBuf>
    char            achPropPrefix[_MAX_PATH]; // child property name prefix
    char            achPropName[_MAX_PATH]; // a property name
    LARGE_INTEGER   liZero = {0, 0};
    ULARGE_INTEGER  uliCurPos;
    char            ach[_MAX_PATH];
    OLECHAR         oach[_MAX_PATH];
    VARIANT         var;
    ULONG           cb;

    // ensure correct cleanup
    VariantInit(&var);

	if (pvio->IsLoading() == S_OK)
	{
		*ppunk = NULL;
	}

    // make <ppb> be an IPropertyBag interface onto <pvio>
    if (FAILED(hrReturn = pvio->QueryInterface(IID_IPropertyBag,
            (LPVOID *) &ppb)))
        goto ERR_EXIT;

	// If <iChild> is less then 0, we are not really a collection and we 
	// set <achPropPrefix> to simply the property name (e.g. "Controls.".
    // Otherwise set <achPropPrefix> to the property name prefix for this child
    // (e.g. "Controls(7)." if <szCollection> is "Controls" and <iChild> is 7)
	if(iChild < 0)
		wsprintf(achPropPrefix, "%s.", szCollection);
	else
		wsprintf(achPropPrefix, "%s(%d).", szCollection, iChild);

    // set <achPropName> to the name of the class ID property
    // (class ID of child gets saved as e.g. "Controls(7)._clsid")
    lstrcpy(achPropName, achPropPrefix);
    lstrcat(achPropName, "_clsid");

    // if <pvio> is in loading mode, create the control <*ppunk> based on
    // the control's "_clsid" property stored in <pvio>; if <pvio> is in
    // saving mode, save the control's "_clsid" property to <pvi>
    if (pvio->IsLoading() == S_OK)
    {
        // set <ach> to the string form of the class ID of the child control
        // we need to load
        ach[0] = 0;
        if (FAILED(hrReturn = pvio->Persist(0, achPropName, VT_LPSTR, ach,
                NULL)))
            goto ERR_EXIT;
        if (ach[0] == 0)
        {
            // no more children to load
            hrReturn = S_FALSE;
            goto EXIT;
        }

        // create the requested control
        if (FAILED(hrReturn = CreateControlInstance(ach, punkOuter,
            dwClsContext, ppunk, pclsid, pfSafeForScripting, 
			pfSafeForInitializing, 0)))
            goto ERR_EXIT;
    }
    else
    {
        // set <clsid> to the class ID of the child object
        if (pclsid != NULL)
            clsid = *pclsid;
        else
        if (SUCCEEDED((*ppunk)->QueryInterface(IID_IPersist,
                (LPVOID *) &ppersist)) &&
            SUCCEEDED(ppersist->GetClassID(&clsid)))
            ;
        else
            goto ERR_FAIL; // can't persist if we can't determine class ID

        // convert <clsid> to string form and write as value of
        // property <achPropName>
        if (StringFromGUID2(clsid, oach, sizeof(oach) / sizeof(*oach)) == 0)
            goto ERR_FAIL;
        UNICODEToANSI(ach, oach, sizeof(ach));
        if (FAILED(hrReturn = pvio->Persist(0, achPropName, VT_LPSTR, ach,
                NULL)))
            goto ERR_EXIT;
    }

    // attempt to get persistence interfaces onto the child control
    (*ppunk)->QueryInterface(IID_IPersistPropertyBag, (LPVOID *) &pppb);
    if (FAILED((*ppunk)->QueryInterface(IID_IPersistStream, (LPVOID *) &pps)))
        (*ppunk)->QueryInterface(IID_IPersistStreamInit, (LPVOID *) &pps);

    if (pppb != NULL)
    {
        // set <ppbChild> to be a property bag that the child object can
        // use to read/write its properties (whose names are prefixed by
        // <achPropPrefix>) from/to <ppbParent>
        if (FAILED(hrReturn = AllocChildPropertyBag(ppb, achPropPrefix,
                0, &ppbChild)))
            goto ERR_EXIT;

        // tell the child to persist itself using <ppbChild>
        if (pvio->IsLoading() == S_OK)
        {
            // tell the object to read its properties from the property bag
            // <ppbChild>
            if (FAILED(hrReturn = pppb->Load(ppbChild, NULL)))
                goto ERR_EXIT;
        }
        else
        {
            // tell the object to write its properties to the property bag
            // <ppbChild>
            if (FAILED(hrReturn = pppb->Save(ppbChild, TRUE, TRUE)))
                goto ERR_EXIT;
        }
    }
    else
    if (pps != NULL)
    {
        // set <oach> to be the name of this child's "_data" property
        // (e.g. "Controls(7)._data")
        lstrcpy(ach, achPropPrefix);
        lstrcat(ach, "_data");
        ANSIToUNICODE(oach, ach, sizeof(oach) / sizeof(*oach));

        // set <psbuf> to be a new empty memory-based stream
        if (FAILED(hrReturn = CreateStreamOnHGlobal(NULL, TRUE, &psBuf)))
            goto ERR_EXIT;

        if (pvio->IsLoading() == S_OK)
        {
            // read the child's data (a stream of bytes) from the "_data"
            // property of the parent, then tell the child to load its
            // data from that stream...

            // set <var> to the value of the "_data" property
            VariantClear(&var);
            var.vt = VT_BSTR;
            var.bstrVal = NULL; // some property bags (e.g. IE) need this
            if (FAILED(hrReturn = ppb->Read(oach, &var, NULL)))
            {
                VariantInit(&var);
                goto ERR_EXIT;
            }
            if (var.vt != VT_BSTR)
                goto ERR_FAIL;

            // write the string value of the "_data" property to <psBuf>
            cbBuf = SysStringLen(var.bstrVal) * sizeof(wchar_t);
            if (FAILED(psBuf->Write(var.bstrVal, cbBuf, &cb)) || (cb != cbBuf))
                goto ERR_FAIL;
            // seek the current position of <psBuf> back to the beginning of
            // the stream
            if (FAILED(hrReturn = psBuf->Seek(liZero, SEEK_SET, NULL)))
                return hrReturn;

            // tell the control to read its data from <psBuf>
            if (FAILED(hrReturn = pps->Load(psBuf)))
                goto ERR_EXIT;
        }
        else
        {
            // tell the child to save its data to a stream, and then set the
            // "_data" property for the child to that stream's data...

            // tell the control to write its data to <psBuf>
            if (FAILED(hrReturn = pps->Save(psBuf, TRUE)))
                goto ERR_EXIT;

            // set <cbBuf> to the number of bytes in <psbuf>
            if (FAILED(hrReturn = psBuf->Seek(liZero, SEEK_CUR, &uliCurPos)))
                return hrReturn;
            if (uliCurPos.HighPart != 0)
                goto ERR_FAIL;
            cbBuf = uliCurPos.LowPart;

            // seek the current position of <psBuf> back to the beginning of
            // the stream
            if (FAILED(hrReturn = psBuf->Seek(liZero, SEEK_SET, NULL)))
                return hrReturn;

            // set <var> to be a string containing the bytes from <psBuf>
            VariantClear(&var);
            var.bstrVal = SysAllocStringLen(NULL, (cbBuf + 1) / 2);
            if (var.bstrVal == NULL)
                goto ERR_OUTOFMEMORY;
            var.vt = VT_BSTR;

            // store <var> as the value of the child's "_data" property
            if (FAILED(hrReturn = ppb->Write(oach, &var)))
                goto ERR_EXIT;
        }
    }

    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_FAIL:

    hrReturn = E_FAIL;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    if (*ppunk != NULL && pvio->IsLoading() == S_OK)
        (*ppunk)->Release();
    *ppunk = NULL;
    goto EXIT;

EXIT:

    // normal cleanup
    if (ppb != NULL)
        ppb->Release();
    if (pppb != NULL)
        pppb->Release();
    if (pps != NULL)
        pps->Release();
    if (ppbChild != NULL)
        ppbChild->Release();
    if (ppersist != NULL)
        ppersist->Release();
    if (psBuf != NULL)
        psBuf->Release();
    VariantClear(&var);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\precomp.h ===
// precomp.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#include <windows.h>
#include <tchar.h>
#include <servprov.h> // for IServiceProvider 
#include "..\..\inc\mmctl.h"
#include "memlayer.h"

/*
// default new and delete operators
void * _cdecl operator new(size_t cb);
void _cdecl operator delete(void *pv);
*/

// memory leak detection
STDAPI_(void) HelpMemDetectLeaks();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\precomp.cpp ===
// precomp.cpp : source file that includes just the standard includes
//  precomp.pch will be the pre-compiled header
//  precomp.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\prophelp.cpp ===
// prophelp.cpp
//
// Implements AllocPropPageHelper.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


//////////////////////////////////////////////////////////////////////////////
// CPropPageHelper
//


/* @object PropPageHelper |

        Implements <i IPropertyPage>.  Designed to be aggregated by an
        object that wants to provide a specific propery page implementation.

@supint IPropertyPage | Standard OLE property page implementation.  The
        information about the property page is maintained in a
        <t PropPageHelperInfo> structure that's allocated by the
        aggregator and shared with <o PropPageHelper>.

@comm   See <f AllocPropPageHelper> for more information.

*/


/* @struct PropPageHelperInfo |

        Maintains information describing a property page.  Used by
        <o PropPageHelper>, but allocated by the object that aggregates
        <o PropPageHelper>.

@field  int | idDialog | ID of propery page dialog resource.

@field  int | idTitle | ID of a string resource containing the page's title
        (used on the page tab).

@field  HINSTANCE | hinst | The instance of the DLL that contains the
        resources specified by <p idDialog> and <p idTitle>.

@field  PropPageHelperProc | pproc | A callback function that receives property
        page window messages.  <p pproc> is similar to a DLGPROC but has
        extra parameters: a pointer to this structure, and a pointer to
        an HRESULT to be used when responding to the following special
        messages:

        @flag   WM_PPH_APPLY | <p pproc> should apply any property page
                changes to the objects <p ppunk> that the property page
                is operating on.  This is the same as <om IPropertyPage.Apply>.

        @flag   WM_PPH_HELP | Identical to <om IPropertyPage.Help>.
                The WPARAM parameter of <p pproc> contains the
                LPCOLESTR argument of <om IPropertyPage.Help>.

        @flag   WM_PPH_TRANSLATEACCELERATOR | Identical to
                <om IPropertyPage.TranslateAccelerator>.
                The WPARAM parameter of <p pproc> contains the
                LPMSG argument of <om IPropertyPage.TranslateAccelerator>.

@field  IID | iid | The interface that will be used to communicate with
        objects that the property page will operate upon.

@field  DWORD | dwUser | Arbitrary information stored by the caller of
        <f AllocPropPageHelper>.

@field  IPropertyPageSite * | psite | The frame's page site object.

@field  LPUNKNOWN * | ppunk | An array of <p cpunk> pointers to the objects
        that this property page will operate upon.  The interface ID of
        each element of <p ppunk> is actually <p iid>.  If <p cpunk>==0,
        then presumably none of the objects that the property page was
        requested to operate upon supports the interface <p iid>.

@field  int | cpunk | The number of elements in <p ppunk>.

@field  HWND | hwnd | The property page window.

@field  BOOL | fDirty | TRUE if changes to the property page have not yet
        been applied to the objects in <p ppunk>, FALSE otherwise.  (If TRUE,
        the Apply button should be visible.)

@field  BOOL | fLockDirty | If TRUE, <p fDirty> should not be changed.
        <p fLockDirty> is TRUE during initialization of the property page
        (during which time it's inappropriate to be telling the property
        page that it's dirty).

@comm   See <f AllocPropPageHelper> for more information.
*/

struct CPropPageHelper : public INonDelegatingUnknown, public IPropertyPage
{
///// non-delegating IUnknown implementation
    ULONG           m_cRef;         // object reference count
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

///// delegating IUnknown implementation
    LPUNKNOWN       m_punkOuter;    // controlling unknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

///// IPropertyPage implementation
    PropPageHelperInfo *m_pInfo;    // object state (maintained by aggregator)
    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite);
    STDMETHODIMP Activate(HWND hwndParent, LPCRECT lprc, BOOL bModal);
    STDMETHODIMP Deactivate();
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty();
    STDMETHODIMP Apply();
    STDMETHODIMP Help(LPCOLESTR lpszHelpDir);
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg);
};


//////////////////////////////////////////////////////////////////////////////
// PropPageHelper Construction
//

/* @func HRESULT | AllocPropPageHelper |

        Allocates a <o PropPageHelper> object which helps a control implement
        a property page.

@parm   LPUNKNOWN | punkOuter | The <i IUnknown> of the control's property page
        object.  Will be used as the controlling unknown of <o PropPageHelper>.

@parm   PropPageHelperInfo * | pInfo | Points to a <t PropPageHelperInfo>
        structure allocated within the control's property page object.
        Note that <o PropPageHelper> will hold onto a pointer to this
        structure.  These fields of <p pInfo> must be initialized by the
        caller: <p idDialog>, <p idTitle>, <p hinst>, <p pproc>, <p iid>, and
        <p dwUser>.  The other fields will be initialized by <o PropPageHelper>.

@parm   UINT | cbInfo | The size of the structure pointed to by <p punkOuter>
        (used for version checking).

@parm   LPUNKNOWN * | ppunk | Where to store a pointer to the non-delegating
        <i IUnknown> of the allocatedd <o PropPageHelper> object.  NULL is
        stored in *<p ppunk> on error.
*/
STDAPI AllocPropPageHelper(LPUNKNOWN punkOuter, PropPageHelperInfo *pInfo,
    UINT cbInfo, LPUNKNOWN *ppunk)
{
    HRESULT         hrReturn = S_OK; // function return code
    CPropPageHelper *pthis = NULL;  // allocated object

    // make sure the version of <pInfo> is compatible with this object
    if (cbInfo != sizeof(*pInfo))
        return E_INVALIDARG;

    // set <pthis> to point to new object instance
    if ((pthis = New CPropPageHelper) == NULL)
        goto ERR_OUTOFMEMORY;
    TRACE("CPropPageHelper 0x%08lx created\n", pthis);

    // initialize IUnknown state
    pthis->m_cRef = 1;
    pthis->m_punkOuter = (punkOuter == NULL ?
        (IUnknown *) (INonDelegatingUnknown *) pthis : punkOuter);

    // initialize IPropertyPage state
    pthis->m_pInfo = pInfo;

    // initialize the parts of <*m_pInfo> we are responsible for initializing
    pthis->m_pInfo->psite = NULL;
    pthis->m_pInfo->ppunk = NULL;
    pthis->m_pInfo->cpunk = 0;
    pthis->m_pInfo->hwnd = NULL;
    pthis->m_pInfo->fDirty = FALSE;
    pthis->m_pInfo->fLockDirty = FALSE;

    // return a pointer to the non-delegating IUnknown implementation
    *ppunk = (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    if (pthis != NULL)
        Delete pthis;
    *ppunk = NULL;
    goto EXIT;

EXIT:

    // normal cleanup
    // (nothing to do)

    return hrReturn;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CPropPageHelper::NonDelegatingQueryInterface(REFIID riid,
    LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("PropPageHelper::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (IUnknown *) (INonDelegatingUnknown *) this;
    else
    if (IsEqualIID(riid, IID_IPropertyPage))
        *ppv = (IPropertyPage *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CPropPageHelper::NonDelegatingAddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPropPageHelper::NonDelegatingRelease()
{
    if (--m_cRef == 0L)
    {
        // free the object
        TRACE("CPropPageHelper 0x%08lx destroyed\n", this);
        SetPageSite(NULL);
        SetObjects(0, NULL);
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


//////////////////////////////////////////////////////////////////////////////
// Propery Page Dialog Procedure
//

INT_PTR CALLBACK PropPageHelperDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam,
    LPARAM lParam)
{
    CPropPageHelper *pthis;         // property page object
    const char *    szPropName = "this"; // property to store <pthis>
    HRESULT         hr;

    // set <pthis> to the property page object
    if ((pthis = (CPropPageHelper *) GetProp(hwnd, szPropName)) == NULL)
    {
        if ((uiMsg == WM_INITDIALOG) && (lParam != 0))
        {
            pthis = (CPropPageHelper *) lParam;
            SetProp(hwnd, szPropName, (HANDLE) pthis);
            pthis->m_pInfo->fLockDirty = TRUE;
            BOOL f = pthis->m_pInfo->pproc(hwnd, WM_INITDIALOG, wParam, lParam,
                pthis->m_pInfo, &hr);
            pthis->m_pInfo->fLockDirty = FALSE;
            return f;
        }
        else
            return FALSE;
    }

    // do nothing if this instance of this property page window
    // was only created to get information about the property page
    // (in which case NULL is passed for the last parameter of
    // CreateDialogParam())
    if (pthis == NULL)
        return FALSE;

    if (uiMsg == WM_DESTROY)
        RemoveProp(hwnd, szPropName);

    return pthis->m_pInfo->pproc(hwnd, uiMsg, wParam, lParam, pthis->m_pInfo,
        &hr);
}


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage Implementation
//

STDMETHODIMP CPropPageHelper::SetPageSite(LPPROPERTYPAGESITE pPageSite)
{
    TRACE("CPropPageHelper::SetPageSite\n");

    // store new site pointer
    if (m_pInfo->psite != NULL)
        m_pInfo->psite->Release();
    m_pInfo->psite = pPageSite;
    if (m_pInfo->psite != NULL)
        m_pInfo->psite->AddRef();
    
    return S_OK;
}

STDMETHODIMP CPropPageHelper::Activate(HWND hwndParent, LPCRECT prc,
    BOOL bModal)
{
    TRACE("CPropPageHelper::Activate\n");

    // create the property page dialog box (if it doesn't exist already)
    if (m_pInfo->hwnd == NULL)
    {
        if ((m_pInfo->hwnd = CreateDialogParam(m_pInfo->hinst,
                MAKEINTRESOURCE(m_pInfo->idDialog), hwndParent,
                PropPageHelperDlgProc,
                (LPARAM) this)) == NULL)
            return E_OUTOFMEMORY;
    }

    // set the dialog box position to <prc>
    Move(prc);

    return S_OK;
}

STDMETHODIMP CPropPageHelper::Deactivate()
{
    TRACE("CPropPageHelper::Deactivate\n");
    if (m_pInfo->hwnd != NULL)
    {
        DestroyWindow(m_pInfo->hwnd);
        m_pInfo->hwnd = NULL;
    }
    return S_OK;
}

STDMETHODIMP CPropPageHelper::GetPageInfo(LPPROPPAGEINFO pPageInfo)
{
    TRACE("CPropPageHelper::GetPageInfo\n");

    // default value
    pPageInfo->pszDocString = NULL;
    pPageInfo->pszHelpFile = NULL;
    pPageInfo->dwHelpContext = 0;

    HWND hwnd = NULL;    // page window

    // temporarily create the page window so we can get information from it
    if ((hwnd = CreateDialogParam(m_pInfo->hinst,
            MAKEINTRESOURCE(m_pInfo->idDialog), GetDesktopWindow(),
            PropPageHelperDlgProc, 0)) != NULL)
    {
        TCHAR           ach[200];
        RECT            rc;
        int             cch;

        // set the <pPageInfo->size> to the dimensions of the window
        GetWindowRect(hwnd, &rc);
        pPageInfo->size.cx = rc.right - rc.left;
        pPageInfo->size.cy = rc.bottom - rc.top;

        // set the <pPageInfo->pszTitle> to the page title
        if ((cch = LoadString(m_pInfo->hinst, m_pInfo->idTitle, ach, sizeof(ach)))
            == 0)
            ach[0] = 0;
        if ((pPageInfo->pszTitle = (OLECHAR *)
                TaskMemAlloc(sizeof(OLECHAR) * (cch + 1))) != NULL)
            ANSIToUNICODE(pPageInfo->pszTitle, ach, cch + 1);

        DestroyWindow(hwnd);
    }
    else
    {
        // set defaults for <*pPageInfo>

        // random default dimensions of the window
        pPageInfo->size.cx = pPageInfo->size.cy = 300;

        // default page title. MUST be set, assigning to NULL will cause crash!
        static TCHAR szDefault[] = "Control";
        if ((pPageInfo->pszTitle = (OLECHAR *)
                TaskMemAlloc(sizeof(OLECHAR) * (sizeof(szDefault)/sizeof(TCHAR)))) != NULL)
            ANSIToUNICODE(pPageInfo->pszTitle, szDefault, sizeof(szDefault));
    }

    return S_OK;
}

STDMETHODIMP CPropPageHelper::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk)
{
    TRACE("CPropPageHelper::SetObjects\n");

    // release all pointers in <m_pInfo->ppunk>, then release <m_pInfo->ppunk>
    // itself
    if (m_pInfo->ppunk != NULL)
    {
        for (int ipunk = 0; ipunk < m_pInfo->cpunk; ipunk++)
            m_pInfo->ppunk[ipunk]->Release();
        Delete [] m_pInfo->ppunk;
        m_pInfo->ppunk = NULL;
        m_pInfo->cpunk = 0;
    }

    // if the caller just wanted to free the existing pointer, we're done
    if (cObjects == 0)
        return S_OK;

    // set <m_pInfo->ppunk> to an array of pointers to the controls
    // that this property page is operating on
    if ((m_pInfo->ppunk = New LPUNKNOWN [cObjects]) == NULL)
        return E_OUTOFMEMORY;
    for ( ; cObjects > 0; cObjects--, ppunk++)
    {
        if (SUCCEEDED((*ppunk)->QueryInterface(m_pInfo->iid,
            (LPVOID *) (m_pInfo->ppunk + m_pInfo->cpunk))))
            m_pInfo->cpunk++;
    }

    return S_OK;
}

STDMETHODIMP CPropPageHelper::Show(UINT nCmdShow)
{
    TRACE("CPropPageHelper::Show\n");

    if (m_pInfo->hwnd != NULL)
    {
        ShowWindow(m_pInfo->hwnd, nCmdShow);
        if ((nCmdShow == SW_SHOW) || (nCmdShow == SW_SHOWNORMAL))
            SetFocus(m_pInfo->hwnd);
    }

    return S_OK;
}

STDMETHODIMP CPropPageHelper::Move(LPCRECT prc)
{
    TRACE("CPropPageHelper::Move\n");

    if (m_pInfo->hwnd != NULL)
        SetWindowPos(m_pInfo->hwnd, NULL, prc->left, prc->top,
            prc->right - prc->left, prc->bottom - prc->top, SWP_NOZORDER);

    return S_OK;
}

STDMETHODIMP CPropPageHelper::IsPageDirty()
{
    TRACE("CPropPageHelper::IsPageDirty\n");
    return (m_pInfo->fDirty ? S_OK : S_FALSE);
}

STDMETHODIMP CPropPageHelper::Apply()
{
    TRACE("CPropPageHelper::Apply\n");
    HRESULT hr = E_NOTIMPL;
    m_pInfo->pproc(m_pInfo->hwnd, WM_PPH_APPLY, 0, 0, m_pInfo, &hr);
    return hr;
}

STDMETHODIMP CPropPageHelper::Help(LPCOLESTR lpszHelpDir)
{
    TRACE("CPropPageHelper::Help\n");
    HRESULT hr = S_FALSE;
    m_pInfo->pproc(m_pInfo->hwnd, WM_PPH_HELP, (WPARAM) lpszHelpDir, 0,
        m_pInfo, &hr);
    return hr;
}

// helper for TranslateAccelerator(...), it find out the current focused
// child control is at the end of the tab list for the property page.
//
// hwndPage: the window handle of the property page
// nCmd: GW_HWNDPREV or GW_HWNDNEXT, indicates the moving direction for tab.
//
static BOOL IsEndOfTabList(HWND hwndPage, UINT nCmd)
{
        if ((SendMessage(hwndPage, WM_GETDLGCODE, 0, 0) &
                (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
        {
                HWND hwnd = GetFocus();
                if (IsChild(hwndPage, hwnd))
                {
                        // Get top level child for controls with children, like combo.
                        while (GetParent(hwnd) != hwndPage)
                        {
                                hwnd = GetParent(hwnd);
                                ASSERT(IsWindow(hwnd));
                        }

            // check if at the end of the tab list
                        do
                        {
                                if ((hwnd = GetWindow(hwnd, nCmd)) == NULL)
                                        return TRUE;
                        }
                        while ((GetWindowLong(hwnd, GWL_STYLE) & 
                   (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
                }
        }

        return FALSE;
}

// helper for TranslateAccelerator(...), it processes key board input messages
//
// hwndPage: the window handle of the property page.
// lpMsg: the message to process.
//
static BOOL PreTranslateMessage(HWND hwndPage, LPMSG lpMsg)
{
    // Return key or Escape key.
        if ((lpMsg->message == WM_KEYDOWN) &&
                ((lpMsg->wParam == VK_RETURN) || (lpMsg->wParam == VK_ESCAPE)))
        {
                // Special case: if control with focus is an edit control with
                // ES_WANTRETURN style, let it handle the Return key.

                TCHAR szClass[10];
                HWND hwndFocus = GetFocus();
                if ((lpMsg->wParam == VK_RETURN) &&
                        (hwndFocus != NULL) && IsChild(hwndPage, hwndFocus) &&
                        (GetWindowLong(hwndFocus, GWL_STYLE) & ES_WANTRETURN) &&
                        GetClassName(hwndFocus, szClass, 10) &&
                        (lstrcmpi(szClass, _T("EDIT")) == 0))
                {
                        SendMessage(hwndFocus, WM_CHAR, lpMsg->wParam, lpMsg->lParam);
                        return TRUE;
                }

                return FALSE;
        }

    // don't translate non-input events
        if ((lpMsg->message < WM_KEYFIRST || lpMsg->message > WM_KEYLAST) &&
                (lpMsg->message < WM_MOUSEFIRST || lpMsg->message > WM_MOUSELAST))
                return FALSE;

    BOOL bHandled;

        // If it's a WM_SYSKEYDOWN, temporarily replace the hwnd in the
        // message with the hwnd of our first control, and try to handle
        // the message for ourselves.
        if ((lpMsg->message == WM_SYSKEYDOWN) && !IsChild(hwndPage, lpMsg->hwnd))
        {
                HWND hWndSave = lpMsg->hwnd;
                lpMsg->hwnd = GetWindow(hwndPage, GW_CHILD);
                bHandled = IsDialogMessage(hwndPage, lpMsg);
                lpMsg->hwnd = hWndSave;
        }
        else
        {
                bHandled = IsDialogMessage(hwndPage, lpMsg);
        }

    return bHandled;
}

STDMETHODIMP CPropPageHelper::TranslateAccelerator(LPMSG lpMsg)
{
    TRACE("CPropPageHelper::TranslateAccelerator\n");

    ASSERT(m_pInfo);
    ASSERT(IsWindow(m_pInfo->hwnd));

    HWND hwndPage = m_pInfo->hwnd; // for convience

    // let the dialog proc get a chance to process it first
    {
        HRESULT hr = E_NOTIMPL;
        m_pInfo->pproc(hwndPage, WM_PPH_TRANSLATEACCELERATOR,
            (WPARAM)lpMsg, 0, m_pInfo, &hr);

        if (hr == S_OK)
            return hr;
    }

        if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_TAB &&
                GetKeyState(VK_CONTROL) >= 0)
        {
                if (IsChild(hwndPage, GetFocus()))
                {
                        // We already have the focus.  Let's determine whether we should
                        // pass focus up to the frame.

                        if (IsEndOfTabList(hwndPage, GetKeyState(VK_SHIFT) < 0 ?
                                GW_HWNDPREV : GW_HWNDNEXT))
                        {
                                // fix for default button border
                                DWORD dwDefID = (DWORD) SendMessage(hwndPage, DM_GETDEFID, 0, 0);
                                if (HIWORD(dwDefID) == DC_HASDEFID)
                                {
                                        HWND hwndDef = GetDlgItem(hwndPage, LOWORD(dwDefID));
                                        if (hwndDef != NULL && IsWindowEnabled(hwndDef))
                        SendMessage(hwndPage, WM_NEXTDLGCTL, (WPARAM)hwndDef, 1L);
                                }

                                // Pass focus to the frame by letting the page site handle
                                // this message.
                                if (m_pInfo->psite
                    && m_pInfo->psite->TranslateAccelerator(lpMsg) == S_OK)
                    return S_OK;
                        }
                }
                else
                {
                        // We don't already have the focus.  The frame is passing the
                        // focus to us.

                        HWND hwnd = GetTopWindow(hwndPage);
                        if (hwnd != NULL)
                        {
                                UINT gwInit;
                                UINT gwMove;

                                if (GetKeyState(VK_SHIFT) >= 0)
                                {
                                        // Set the focus to the first tabstop in the page.
                                        gwInit = GW_HWNDFIRST;
                                        gwMove = GW_HWNDNEXT;
                                }
                                else
                                {
                                        // Set the focus to the last tabstop in the page.
                                        gwInit = GW_HWNDLAST;
                                        gwMove = GW_HWNDPREV;
                                }

                                hwnd = GetWindow(hwnd, gwInit);
                                while (hwnd != NULL)
                                {
                    if ((GetWindowLong(hwnd, GWL_STYLE) & 
                        (WS_DISABLED | WS_TABSTOP)) == WS_TABSTOP)
                                        {
                        SendMessage(hwndPage, WM_NEXTDLGCTL, (WPARAM)hwnd, 1L);
                                                return S_OK;
                                        }
                                        hwnd = GetWindow(hwnd, gwMove);
                                }
                        }
                }
        }

    return PreTranslateMessage(hwndPage, lpMsg) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\ole.cpp ===
// OLE.cpp
//
// Implements OLE utility functions.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func ULONG | SafeRelease |

		Releases an interface pointer if the pointer isn't NULL, and sets the
		pointer to NULL.

@rdesc  Value returned by the Release call, or 0 if <p ppunk> is NULL.

@parm   LPUNKNOWN | ppunk | Pointer to a pointer to the interface to release.
		Can be NULL.

@comm	The interface pointer must be cast to an (IUnknown **) before calling
		this function:

@iex	SafeRelease( (LPUNKNOWN *)&pInterface );
*/

STDAPI_(ULONG) SafeRelease (LPUNKNOWN *ppunk)
{
    if (*ppunk != NULL)
	{
		ULONG cRef;

        cRef = (*ppunk)->Release();
        *ppunk = NULL;
        return (cRef);
	}

	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\pseudoev.cpp ===
// pseudoev.cpp
//
// Implements FirePseudoEvent and FirePseudoEventList.
//
// @doc MMCTL

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"

static HRESULT FireViaPseudoEventSinkService(SAFEARRAY *psa, IDispatch *pctl);


/* @func HRESULT | FirePseudoEvent |

		Fires an MM Controls pseudo-event through the SPseudoEventSink service
		if that service is available, or by sending a registered Windows
		message to a specified window.

@parm   HWND | hwnd | Window where the registered message should be sent, if
		the SPseudoEventSink service isn't available through <p pctl>.

@parm   LPCOLESTR | pochEventName | Name of the pseudo-event.  "Click", for
        example.

@parm   IDispatch * | pctl | Pointer to the caller's IDispatch interface.  The
		interface must support a "name" parameter that provides the name of the
		control.  If the interface supports the SPseudoEventSink service, the
		pseudo-event is fired using this service.  Otherwise, a registered
		window message is used.

@parm   (varying) | (arguments) | The arguments of the pseudo-event.  These
		must consist of N pairs of arguments followed by a 0 (zero value).  N
		must be less than or equal to 10.  In each pair, the first argument is
		a VARTYPE value that indicates the type of the second argument.  The
		following VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int.  <f FirePseudoEvent>
                passes this as VT_I4, so this parameter should be declared as a
				Long in BASIC.

        @flag   VT_I2 | The following argument is a short.  In BASIC this
				parameter should be declared as Integer.

        @flag   VT_I4 | The following argument is a long.  In BASIC this
				parameter should be declared as Long.

        @flag   VT_R4 | The following argument is a float.  In BASIC this
				parameter should be declared as Single.

        @flag   VT_R8 | The following argument is a double.  In BASIC this
				parameter should be declared as Double.

        @flag   VT_BOOL | The following argument is a BOOL (<y not> a
				VARIANT_BOOL).  In BASIC this parameter should be declared as
				Boolean or Integer.  Note that this behavior differs slightly
				from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR or an OLECHAR *.  In
				BASIC this parameter should be declared as String.

        @flag   VT_LPSTR | The following argument is an LPSTR.
				<f FirePseudoEvent> passes this as a BSTR, so this parameter
				should be declared as a String in BASIC.  Note that this
				behavior differs from the usual definition of VT_LPSTR.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH.  In
                BASIC this parameter should be declared as an Object.

        @flag   VT_VARIANT | The following arguement is a VARIANT.  This allows
				arbitrary parameters to be passed using this function.  Note
				that this behavior differs from the usual definition of
				VT_VARIANT.

@ex		The following example fires pseudo-event named "MouseDown" with integer
		parameters 100 and 200: |

		FirePseudoEvent(m_hwndSite, OLESTR("MouseDown"), m_pdispSite,
            VT_INT, 100, VT_INT, 200, 0);
*/
HRESULT __cdecl FirePseudoEvent(HWND hwnd, LPCOLESTR oszEvName, 
	IDispatch *pctl, ...)
{
	ASSERT(IsWindow(hwnd));
	ASSERT(oszEvName != NULL);
	ASSERT(pctl != NULL);

    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, pctl);

    hrReturn = FirePseudoEventList(hwnd, oszEvName, pctl, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @func HRESULT | FirePseudoEventList |

		Fires an MM Controls pseudo-event through the SPseudoEventSink service
		if that service is available, or by sending a registered window message
		to a specified window.

		A control container can receive pseudo-events by either implementing
		the SPseudoEventSink service on the control site, or by processing the
		registered window message.

@parm   HWND | hwnd | Window where the registered message should be sent, if
		the SPseudoEventSink service isn't available through <p pctl>.

@parm   LPCOLESTR | pochEventName | Name of the pseudo-event.  "Click", for
        example.

@parm   IDispatch * | pctl | Pointer to the caller's IDispatch interface.  The
		interface must support a "name" parameter that provides the name of the
		control.  If the interface supports the SPseudoEventSink service, the
		pseudo-event is fired using this service.  Otherwise, a registered
		window message is used.

@parm   va_list | args | The arguments to pass to the method or property.  See
		<f FirePseudoEvent> for a description of the organization of <p args>.
*/
STDAPI FirePseudoEventList(HWND hwnd, LPCOLESTR oszEvName, IDispatch *pctl,
	va_list args)
{
	ASSERT(IsWindow(hwnd));
	ASSERT(oszEvName != NULL);
	ASSERT(pctl != NULL);

    HRESULT         hrReturn = S_OK; // function return code
	SAFEARRAY *		psa = NULL;		// safearray
	const int		MAXELEM = 10;	// maximum no. arguments
	VARIANT *		pvar = NULL;	// pointer into <psa>
	int				cvar;			// number of arguments in <psa>
	SAFEARRAYBOUND	sab;

	// create the SafeArray large enough to hold the max. number of
	// pseudo-event arguments
	sab.lLbound = -1;
	sab.cElements = MAXELEM+2;
	if ((psa = SafeArrayCreate(VT_VARIANT, 1, &sab)) == NULL)
		goto ERR_OUTOFMEMORY;

	// make <pvar> point to the first element of <psa>
	if (FAILED(hrReturn = SafeArrayAccessData(psa, (LPVOID *) &pvar)))
	{
		ASSERT(NULL == pvar);
		goto ERR_EXIT;
	}

    // element -1 of <psa> is <control> argument
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pctl;
    V_DISPATCH(pvar)->AddRef();
    pvar++;

    // element 0 of <psa> is <event> argument
	if ((V_BSTR(pvar) = SysAllocString(oszEvName)) == NULL)
		goto ERR_OUTOFMEMORY;
	V_VT(pvar) = VT_BSTR;
    pvar++;

	// loop once for each optional argument
	for (cvar = 0; cvar < MAXELEM; cvar++, pvar++)
	{
		LPSTR           sz;
		OLECHAR         aoch[300];

        if ((V_VT(pvar) = va_arg(args, VARTYPE)) == 0)
            break;
		switch (pvar->vt)
		{
    		case VT_I2:
				pvar->iVal = va_arg(args, short);
				break;
			case VT_I4:
				pvar->lVal = va_arg(args, long);
				break;
			case VT_INT:
				pvar->vt = VT_I4;
				pvar->lVal = va_arg(args, int);
    			break;
			case VT_R4:
				V_R4(pvar) = va_arg(args, float);
				break;
			case VT_R8:
				V_R8(pvar) = va_arg(args, double);
				break;
			case VT_BOOL:
				V_BOOL(pvar) = (va_arg(args, BOOL) == 0 ? 0 : -1);
				break;
			case VT_BSTR:
				if ( (pvar->bstrVal = va_arg(args, LPOLESTR)) &&
					 ((pvar->bstrVal = SysAllocString(pvar->bstrVal))
															== NULL) )
				{
					goto ERR_OUTOFMEMORY;
				}
				break;
			case VT_DISPATCH:
				pvar->punkVal = va_arg(args, LPUNKNOWN);
				if (pvar->punkVal != NULL)
					pvar->punkVal->AddRef();
				break;
			case VT_VARIANT:
				VariantInit(pvar);
				if (FAILED(VariantCopy(pvar, &va_arg(args, VARIANT))))
				{
					goto ERR_EXIT;
				}
				break;
			case VT_LPSTR:
				sz = va_arg(args, LPSTR);
				pvar->vt = VT_BSTR;
				MultiByteToWideChar(CP_ACP, 0, sz, -1, aoch,
					sizeof(aoch) / sizeof(*aoch));
				if ((pvar->bstrVal = SysAllocString(aoch)) == NULL)
				{
					goto ERR_OUTOFMEMORY;
				}
				break;
			default:
				goto ERR_FAIL;
		}
	}

	// invalidate <pvar>.  (This must be done before the SafeArrayRedim call.)
	SafeArrayUnaccessData(psa);
	pvar = NULL;

	// make <psa> just large enough to hold the <cvar> arguments stored in it
	sab.cElements = cvar+2;
	if (FAILED(hrReturn = SafeArrayRedim(psa, &sab)))
		goto ERR_EXIT;

	// Try to fire the pseudo-event by using the SPseudoEventSink service.

	switch (FireViaPseudoEventSinkService(psa, pctl))
	{
		case S_OK:

			// The service was available and it worked.
			break;

		case S_FALSE:
		{
			// The service wasn't available.  Use a registered window message.

			const UINT uiMsg = RegisterWindowMessage( TEXT("HostLWEvent") );

			ASSERT(uiMsg != 0);

			if (uiMsg)
			   SendMessage( hwnd, uiMsg, (WPARAM) psa, 0 );

			break;
		}

		default:
			goto ERR_FAIL;
	}

	goto EXIT;

ERR_OUTOFMEMORY:

	hrReturn = E_OUTOFMEMORY;
	goto ERR_EXIT;

ERR_FAIL:

	hrReturn = E_FAIL;
	goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
	// (nothing to do)
    goto EXIT;

EXIT:

	// invalidate <pvar> if not already invalidated
	if (pvar != NULL)
		SafeArrayUnaccessData(psa);

    // normal cleanup
	if (psa != NULL)
		SafeArrayDestroy(psa); // cleans up <varArgs> too

    return hrReturn;
}


// Try to fire the pseudo-event by using the SPseudoEventSink service.  If
// successful, S_OK is returned.  If the service isn't available, S_FALSE is
// returned.  If the service is available but a failure occurs, E_FAIL is
// returned.

HRESULT FireViaPseudoEventSinkService
(
	SAFEARRAY *psa,
	IDispatch *pctl
)
{
	ASSERT(psa != NULL);
	ASSERT(pctl != NULL);

	IServiceProvider *pIServiceProvider = NULL;
	IPseudoEventSink *pIPseudoEventSink = NULL;
	HRESULT hrReturn = S_FALSE;

	// Check whether the SPseudoEventSink service is available on the IDispatch
	// interface.

	if (
	    SUCCEEDED( pctl->QueryInterface(IID_IServiceProvider,
										(void**)&pIServiceProvider) )
		&&
		SUCCEEDED( pIServiceProvider->
		 		   QueryService(SID_SPseudoEventSink, IID_IPseudoEventSink,
				   			    (void**)&pIPseudoEventSink) )
	   )
	{
		// It's available.  Fire the pseudo-event.

		hrReturn = pIPseudoEventSink->OnEvent(psa);

		if (hrReturn != S_OK)
		{
			ASSERT(FALSE);
			hrReturn = E_FAIL;
		}
	}

	::SafeRelease( (IUnknown **)&pIServiceProvider );
	::SafeRelease( (IUnknown **)&pIPseudoEventSink );

	return (hrReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\pvio.cpp ===
// pvio.cpp
//
// Implements PersistVariantIO.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | PersistVariantIO |

        Loads or saves a list of property name/value pairs, specified as a
        variable-length list of arguments that's formatted in the same way as
		<om IVariantIO.Persist>, to/from an <i IPropertyBag> object.

@rvalue S_OK | Success.  At least one of the variables listed in
        <p (arguments)> was written to, so the control may want to update
        itself accordingly.

@rvalue S_FALSE | None of the variables listed in <p (arguments)> were
        written to (either because the <i IVariantIO> object is in
        saving mode or because none of the properties named in
        <p (arguments)> exist in the <i IVariantIO> object.

@rvalue DISP_E_BADVARTYPE |
        One of the VARTYPE values in <p (arguments)> is invalid.

@rvalue E_FAIL | A failure occurred while reading from the property bag, other
		than "property doesn't exist."  This can happen if the caller specified
		a type to which the property bag could not coerce the property, for
		example.

@rvalue E_OUTOFMEMORY | Out of memory.

@parm	IPropertyBag * | ppb | The property bag used to load or save the
		specified properties.

@parm   DWORD | dwFlags | May contain the same flags passed to
		<om IManageVariantIO.SetMode> (e.g. VIO_ISLOADING).

@parm   (varying) | (arguments) | The names, types, and pointers to variables
        containing the properties to persist.  These must consist of a series
        of argument triples (sets of 3 arguments) followed by a NULL.
		See <om IVariantIO.Persist> for information about the format of
		these arguments.
*/
STDAPI PersistVariantIO(IPropertyBag *ppb, DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // fire the event with the specified arguments
    hrReturn = PersistVariantIOList(ppb, dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
//#define VERSIONFLAGS                    0

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\queryhit.cpp ===
// queryhit.cpp
//
// Implements HelpQueryHitPoint.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | HelpQueryHitPoint |

        Helps implement <om IViewObjectEx.QueryHitPoint> on a control by
        drawing the control into a small bitmap (centered on the point
        being hit-tested) and checking if any pixels were drawn.

@parm   IViewObject * | pvo | The <i IViewObject> interface on the control
        being hit-tested.

@parm   DWORD | dwAspect | See <om IViewObjectEx.QueryHitPoint>.

@parm   LPCRECT | prcBounds | See <om IViewObjectEx.QueryHitPoint>.

@parm   POINT | ptLoc | See <om IViewObjectEx.QueryHitPoint>.

@parm   LONG | lCloseHint | See <om IViewObjectEx.QueryHitPoint>.

@parm   DWORD * | pHitResult | See <om IViewObjectEx.QueryHitPoint>.

@comm   This function helps implement <om IViewObjectEx.QueryHitPoint>
        for the object <p pvo>, by drawing <p pvo> into a small
        monochrome bitmap centered on <p ptLoc> <p pHitResult> is set to
        HITRESULT_HIT if <p ptLoc> is directly over a non-transparent
        pixel of <p pvo>; HITRESULT_CLOSE if <p ptLoc> is within
        <p lCloseHint> himetric units of a non-transparent pixel of
        <p pvo>; HITRESULT_OUTSIDE otherwise.

        In order for this function to work, <p pvo> must implement
        DVASPECT_MASK (as the first parameter to IViewObject::Draw),
        which is defined to be the same as DVASPECT_CONTENT except
        that non-transparent parts of the object are drawn black, and
        transparent parts are either left untouched or drawn in
        white.
*/
STDAPI HelpQueryHitPoint(IViewObject *pvo, DWORD dwAspect, LPCRECT prcBounds,
    POINT ptLoc, LONG lCloseHint, DWORD *pHitResult)
{
    HRESULT         hrReturn = S_OK; // function return code
    HBITMAP         hbm = NULL;     // bitmap to draw into
    HDC             hdc = NULL;     // DC onto <hbm>
    int             xyCloseHint;    // <lCloseHint> converted to pixels
    WORD *          pwBits = NULL;  // bits (pixels) of <hbm>
    int             cwBits;         // number of WORDs in <pwBits>
    int             cx, cy;         // width and height of test bitmap
    SIZE            size;
    WORD *          pw;
    int             cw;
    COLORREF        rgb;

    // default <pHitResult> to "missed"
    *pHitResult = HITRESULT_OUTSIDE;

    // set <xyCloseHint> to <lCloseHint> converted to pixels
    HIMETRICToPixels(lCloseHint, 0, &size);
    xyCloseHint = size.cx;

    // we're going to get the control to paint itself black into a <cx> by <cy>
    // pixel bitmap (centered over <ptLoc>) that's initially white, then we'll
    // test to see if there are any black pixels in the bitmap; we'll make
    // the width of the test bitmap be a multiple of 16 pixels wide to simplify
    // the GetBitmapBits() call
    if ((cx = ((2 * xyCloseHint + 15) >> 4) << 4) == 0)
        cx = 16;
    if ((cy = 2 * xyCloseHint) == 0)
        cy = 16;

    // create a monochrome bitmap <hbm> to draw the control into; the bitmap
    // only has to be large enough to contain the area within <xyCloseHint>
    // pixels of <ptLoc>
    if ((hbm = CreateBitmap(cx, cy, 1, 1, NULL)) == NULL)
        goto ERR_OUTOFMEMORY;

    // select <hbm> into DC <hdc>
    if ((hdc = CreateCompatibleDC(NULL)) == NULL)
        goto ERR_OUTOFMEMORY;
    if (SelectObject(hdc, hbm) == NULL)
        goto ERR_FAIL;

    // fill the bitmap with white, since the IViewObject::Draw call below
    // will draw the object using black pixels
    if (!(PatBlt(hdc, 0, 0, cx, cy, WHITENESS)))
		goto ERR_FAIL;

    // adjust the origin so that <ptLoc> lines up with the center of
    // the bitmap, and make the clipping rectangle only include
    // the area we want to hit-test
    if (!(SetWindowOrgEx(hdc, ptLoc.x - xyCloseHint, ptLoc.y - xyCloseHint,
																	NULL)))
		goto ERR_FAIL;

    if (ERROR == IntersectClipRect(hdc, ptLoc.x - xyCloseHint,
	    ptLoc.y - xyCloseHint, ptLoc.x + xyCloseHint, ptLoc.y + xyCloseHint))
		goto ERR_FAIL;

    // draw the control into the bitmap
    if (FAILED(hrReturn = pvo->Draw(DVASPECT_MASK, -1, NULL, NULL, NULL, hdc,
            (LPCRECTL) prcBounds, NULL, NULL, 0)))
        goto ERR_EXIT;

#if 0
#ifdef _DEBUG
    // for debugging purposes, draw <hbm> to the top-left corner
    // of the screen
    {
        HDC hdcScreen = GetDC(NULL);
		ASSERT( hdcScreen );
        BitBlt(hdcScreen, 0, 0, cx, cy,
            hdc, ptLoc.x - xyCloseHint, ptLoc.y - xyCloseHint, SRCCOPY);
        ReleaseDC(NULL, hdcScreen);
    }
#endif	// _DEBUG
#endif	// #if 0

    if (CLR_INVALID == (rgb = GetPixel(hdc, ptLoc.x, ptLoc.y)))
	    goto ERR_FAIL;

    if (rgb == RGB(0, 0, 0))
    {
        // <ptLoc> is directly over a non-transparent part
        // of the control
        *pHitResult = HITRESULT_HIT;
        goto EXIT;
    }

    // if the caller only wanted to check for a direct hit, we're done
    if (xyCloseHint == 0)
        goto EXIT;

    // get the pixels of <hbm> and see if they contain any black pixels
    cwBits = (cx >> 4) * cy;
    if ((pwBits = (WORD *) TaskMemAlloc(cwBits * 2)) == NULL)
        goto ERR_OUTOFMEMORY;
    if (GetBitmapBits(hbm, cwBits * 2, pwBits) != cwBits * 2)
        goto ERR_FAIL;
    for (pw = pwBits, cw = cwBits; cw > 0; pw++, cw--)
    {
        if (*pw != 0xFFFF)
        {
            // black pixel found -- <ptLoc> is within <xyCloseHint>
            // pixels of a non-transparent part of the control
            *pHitResult = HITRESULT_CLOSE;
            goto EXIT;
        }
    }

    // <ptLoc> is nowhere near the control
    goto EXIT;

ERR_FAIL:

    hrReturn = E_FAIL;
    goto ERR_EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
	ASSERT(FALSE);
    goto EXIT;

EXIT:

    // normal cleanup
	if (hdc != NULL)
		DeleteDC(hdc);
    if (hbm != NULL)
        DeleteObject(hbm);
    if (pwBits != NULL)
        TaskMemFree(pwBits);

#ifdef _DEBUG
	if (HITRESULT_OUTSIDE == *pHitResult)
	{
		// TRACE( "QueryHitPoint: 'outside'\n" );
	}
#endif	// _DEBUG

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\rvp.cpp ===
// rvp.cpp
//
// Implements ReadVariantProperty.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @struct VariantPropertyHeader |

        The beginning part of a record (in a stream) that contains the
        serialized data of a <t VariantProperty>.

@field  int | iType | The type of the record.  If this value is greater than
        or equal to zero, then it represents a VARTYPE, and the record
        represents a property name/value pair, and the type of the value is
        specified by the VARTYPE.  In this case, the data following the
        <t VariantPropertyHeader> consists of the property name followed by
        the property value (coerced to a string value by <f VariantChangeType>);
        each string is a non-null-terminated Unicode string preceded by an
        unsigned 32-bit integer count of Unicode characters.  <p iType> is
        not a known VARTYPE value, then the record should be skipped when read
        (by skipping the <p cbData> bytes that follow the
        <t VariantPropertyHeader> rather than generating an error.

@field  unsigned int | cbData | The number of bytes of data that follow
        this <t VariantPropertyHeader>.  In other words, the total length
        of the header is <p cbData> + sizeof(<t VariantPropertyHeader>).

@comm   This structure helps define the file format used by
        <f WriteVariantProperty> and <f ReadVariantProperty>.
*/


/* @func HRESULT | ReadVariantProperty |

        Reads a <t VariantProperty> from an <i IStream> in a simple tagged
        binary format.

@rvalue S_OK | Success.

@rvalue S_FALSE | The end-of-stream marker was read in.  (This is the data
        that's written using <f WriteVariantProperty> with NULL <p pvp>.)

@parm   IStream * | pstream | The stream to read from.

@parm   VariantProperty * | pvp | Where to store the property name/value pair
        that's read in.  Any unknown records in <p pstream> are automatically
        skipped.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   See <t VariantPropertyHeader> for a description of the format of
        the data read from <p pstream> by this function.
*/
STDAPI ReadVariantProperty(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    unsigned int    cchPropName;    // no. wide characters in property name
    VARIANT         varValue;       // the property value (as a string)
    unsigned int    cchValue;       // no. wide characters in <varValue>
    VariantPropertyHeader vph;      // header of record
    ULONG           cb;

    // ensure correct cleanup
    VariantInit(&varValue);
    VariantPropertyInit(pvp);

    // skip unknown record types; on loop exit, <vph> contains the record
    // header of a known record type
    while (TRUE)
    {
        // read a VariantPropertyHeader
        if (FAILED(hrReturn = pstream->Read(&vph, sizeof(vph), &cb)))
			goto ERR_EXIT;
        if ((vph.iType == -1) || (cb == 0))
        {
            // hit end-of-stream marker
            hrReturn = S_FALSE;
            goto EXIT;
        }
		if (cb != sizeof(vph))
		{
			hrReturn = E_FAIL;
			goto EXIT;
		}

        // if this record does not specify a property name/value pair, skip it
        if ((vph.iType < 0) || (vph.iType > 0xFFFF))
        {
            LARGE_INTEGER liSeek;
            liSeek.LowPart = vph.cbData;
            liSeek.HighPart = 0;
            if (FAILED(hrReturn = pstream->Seek(liSeek, SEEK_CUR, NULL)))
                goto ERR_EXIT;
        }
        else
            break;
    }

    // read the property name into <pvp->bstrPropName>
    if (FAILED(hrReturn = pstream->Read(&cchPropName, sizeof(cchPropName),
            &cb)) ||
        (cb != sizeof(cchPropName)))
        goto ERR_EXIT;
    if ((pvp->bstrPropName = SysAllocStringLen(NULL, cchPropName)) == NULL)
        goto ERR_OUTOFMEMORY;
    if (FAILED(hrReturn = pstream->Read(pvp->bstrPropName,
            cchPropName * sizeof(OLECHAR), &cb)) ||
        (cb != cchPropName * sizeof(OLECHAR)))
        goto ERR_EXIT;
    pvp->bstrPropName[cchPropName] = 0; // null-terminate

    // read the property value (in string form) into <varValue>
    varValue.vt = VT_BSTR;
    if (FAILED(hrReturn = pstream->Read(&cchValue, sizeof(cchValue),
            &cb)) ||
        (cb != sizeof(cchValue)))
        goto ERR_EXIT;
    if ((varValue.bstrVal = SysAllocStringLen(NULL, cchValue)) == NULL)
        goto ERR_OUTOFMEMORY;
    if (FAILED(hrReturn = pstream->Read(varValue.bstrVal,
            cchValue * sizeof(OLECHAR), &cb)) ||
        (cb != cchValue * sizeof(OLECHAR)))
        goto ERR_EXIT;
    varValue.bstrVal[cchValue] = 0; // null-terminate

    // coerce <varValue> from a string to the VARTYPE specified in <vph> 
    if (FAILED(hrReturn = VariantChangeType(&pvp->varValue, &varValue, 0,
            (VARTYPE) vph.iType)))
        goto ERR_EXIT;

    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    VariantPropertyClear(pvp);
    goto EXIT;

EXIT:

    // normal cleanup
    VariantClear(&varValue);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\reg.cpp ===
// reg.cpp
//
// Implements RegisterControls.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include <comcat.h>				// ICatRegister, etc.
#include "..\..\inc\ochelp.h"
#include "..\..\inc\mmctlg.h"	// CATID_MMControl
#include "..\..\inc\catid.h"	// CATID_Safe...
#include "debug.h"


//****************************************************************************
//*  Defines
//*
//*  @doc None
//****************************************************************************

#define GUID_CCH  39  // Characters in string form of a GUID, including '\0'.

#define ARRAY_SIZE(Array) \
	( sizeof(Array) / sizeof( Array[0] ) )


//****************************************************************************
//*  Structures
//*
//*  @doc MMCTL
//****************************************************************************

/* @struct ControlInfo |

        Contains information used by <f RegisterControls> to register and
        unregister a control.

@field  UINT | cbSize | The size of this structure (used for version
        control).  Must be set to sizeof(ControlInfo).

@field  LPCTSTR | tszProgID | The ProgID of the object, e.g.
        "MYCTLLIB.TinyCtl.1".

@field  LPCTSTR | tszFriendlyName | The human-readable name of the object
        (at most 40 characters or so), e.g. "My Control".

@field  const CLSID * | pclsid | Points to the class ID of the object.

@field  HMODULE | hmodDLL | The module handle of the DLL implementing the
        object.

@field  LPCTSTR | tszVersion | The version number of the object, e.g. "1.0".

@field  int | iToolboxBitmapID | The resource ID of the toolbox bitmap of
        the object, if the object is a control.  The resource must be located
        in the same DLL specified by <p tszDLLPath> and/or <p hmodDLL>.
        If <p iToolboxBitmapID> is -1, it is ignored.

@field  DWORD | dwMiscStatusDefault | The MiscStatus bits (OLEMISC_XXX)
        to use for all display apsects except DVASPECT_CONTENT.  Typically 0.

@field  DWORD | dwMiscStatusContent | The MiscStatus bits (OLEMISC_XXX)
        to use for display aspect DVASPECT_CONTENT.  See the example below.

@field  GUID * | pguidTypeLib | The object's type library GUID, or NULL if
        the object doesn't have a type library.

@field  AllocOCProc * | pallocproc | Function which can allocate an instance
        of the OLE control and return an <f AddRef>'d <i IUnknown> pointer
        to it.

@field  ULONG * | pcLock | Points to a DLL lock count variable defined as a
        global variable in your DLL.  This global variable maintains a count
        of locks used by <om IClassFactory.LockServer>.  To increment or
		decrement this lock count, use <f InterlockedIncrement> and
		<f InterlockedDecrement> instead of modifying it directly.  This will
		ensure that access to the lock count is synchronized between your
		control's server and the OCHelp-supplied class factory.

@field  DWORD | dwFlags | Zero or more of the following:

        @flag   CI_INSERTABLE | Marks the COM object as "Insertable".  Probably
                should not be used for ActiveX controls.

        @flag   CI_CONTROL | Marks the COM object as a "Control".  Probably
                should not be used for ActiveX controls.

		@flag	CI_MMCONTROL | Marks the COM object as a "Multimedia Control".

		@flag	CI_SAFEFORSCRIPTING | Marks the COM object as "safe-for-scripting"
				meaning that the object promises that, no matter how malicious a
				script is, the object's automation model does not allow any harm
				to the user, either in the form of data corruption or security leaks.
				If a control is not "safe-for-scripting", the user will receive a warning
				dialog whenever the control is inserted on an untrusted page in
				Internet Explorer (IE), asking whether the object should be visible from scripts.
				(This is only at medium security level, at high security, the object
				is never visible to scripts, and at low, always visible.)  If a
				control, C1, can potentially contain another control, C2, which might
				be unsafe, then C1 should probably not declare itself "safe-for-scripting".

		@flag	CI_SAFEFORINITIALIZING | Marks the COM object as "safe-for-initializing"
				meaning that it guarantees to do nothing bad regardless of the data with
				which it is initialized.  From IE, the user will be given a warning
				dialog (described above) if an untrusted page attempts to initialize
				a control that is not "safe-for-initializing".

		@flag	CI_NOAPARTMENTTHREADING | By default, <f RegisterControls> will register
				a control as "apartment-aware".  If this flag is set, the control will
				*not* be registered as apartment-aware.

        @flag   CI_DESIGNER | Marks the COM object as an "Active Designer" (i.e., the
                object supports IActiveDesigner).

@field  ControlInfo* | pNext | A pointer to a <p ControlInfo> struct for the next
        control that <f RegisterControls> should register.  Use this field to
        chain together a linked-list of all the controls that <f RegisterControls>
        should register.  <p pNext> should set to NULL for the last <p ControlInfo>
        struct in the list.

@field  UINT | uiVerbStrID | A string resource ID.  The string is a definition
        of an OLE verb applicable to the control.  The string is assumed to
        have the following format:

            \<verb_number>=\<name>, \<menu_flags>, \<verb_flags>

        See help on <om IOleObject.EnumVerbs> for a description of each field.
        <f RegisterControls> will call <f LoadString> to read all the
        consecutively-numbered string resources beginning with <p uiVerbStrID>
        until either <f LoadString> fails (i.e., the resource doesn't exist) or
        an empty string is returned.  <f RegisterControls> will
        register/unregister each verb string it reads.

@comm   This structure is used by <f RegisterControls> and
        <f HelpCreateClassObject>.

        <y Important\:> The objects pointed to by pointer fields of
        <p ControlInfo> must be defined statically in the DLL, since functions
        that use <p ControlInfo> holds onto this pointer.  This can be
        accomplished by making <p ControlInfo> and all the data it points to
        be global variables/literals in your DLL.
*/


// Information about the component categories that need to be added to the
// registry under the "HKCR\Component Categories" key.

struct CatInfo
{
	const CATID *pCatID;    // Category ID.
	LPCTSTR szDescription;  // Category description.
};

// Information about the component categories that may need to be registered
// for a single control.

struct CatInfoForOneControl
{
	DWORD dwFlagToCheck;  // The CI_ flag to check to determine whether the
						  //  category should be registered for the control.
						  // (CI_CONTROL, for example.)
	const CATID *pCatID;  // The Category ID to register.
};


//****************************************************************************
//*  Prototypes for private helper functions
//*
//*  @doc None
//****************************************************************************

static HRESULT _RegisterOneControl(const ControlInfo *pControlInfo,
								   ICatRegister *pCatRegister);
static BOOL _UnregisterOneControl(const ControlInfo *pControlInfo);
static BOOL _RegisterTypeLib(const ControlInfo *pControlInfo);
static BOOL _UnregisterTypeLib(const ControlInfo *pControlInfo);
static BOOL _LoadTypeLib(const ControlInfo *pControlInfo, ITypeLib **ppTypeLib);
static BOOL _SetComponentCategories(const CatInfoForOneControl
									  *pCatInfoForOneControl,
									int iEntries, ICatRegister *pCatRegister,
									const ControlInfo *pControlInfo);
static BOOL _TCHARFromGUID2(const GUID *pGUID, TCHAR *ptchGUID);
static BOOL _GetUnicodeModuleName(const ControlInfo *pControlInfo,
								  OLECHAR *pochModule);

static TCHAR* _lstrchr(const TCHAR* sz, const TCHAR ch);
static HRESULT _SetRegKey(LPCTSTR tszKey, LPCTSTR tszSubkey, LPCTSTR tszValue);
static HRESULT _SetRegKeyValue(LPCTSTR szKey, LPCTSTR szSubkey,
							   LPCTSTR szValueName, LPCTSTR szValue);
static void _DelRegKeyValue(LPCTSTR szKey, LPCTSTR szSubkey,
							LPCTSTR szValueName);

static BOOL RegDeleteTreeSucceeded(LONG error);
static void UnregisterInterfaces(ITypeLib* pTypeLib);


//****************************************************************************
//*  Public functions
//*
//*  @doc MMCTL
//****************************************************************************

/* @func HRESULT | RegisterControls |

        Registers or unregisters one or more controls.  Helps implement
        <f DllRegisterServer> and <f DllUnregisterServer>.

@rvalue S_OK |
        Success.

@rvalue E_FAIL |
        The operation failed.

@parm   ControlInfo * | pctlinfo | Information about the control that's
        being registered or unregistered.  See <t ControlInfo> for more
        information.

@parm   DWORD | dwAction | Must be one of the following:

        @flag   RC_REGISTER | Registers the control.

        @flag   RC_UNREGISTER | Unregisters the control.

@comm   You can register more than one control by making a linked list
        out of your <t ControlInfo> structures -- set each <p pNext>
        field to the next structure, and set the last <p pNext> to NULL.

		All controls which are registered by this function are registered
		as "safe for scripting" and "safe for initializing".

@ex     The following example shows how to implement <f DllRegisterServer>
        and <f DllUnregisterServer> using <f RegisterControls>. |

        STDAPI DllRegisterServer(void)
        {
            return RegisterControls(&g_ctlinfo, RC_REGISTER);
        }

        STDAPI DllUnregisterServer(void)
        {
            return RegisterControls(&g_ctlinfo, RC_UNREGISTER);
        }
*/


// Information about the component categories that need to be added to the
// registry under the "HKCR\Component Categories" key.

static const CatInfo aCatInfo[] =
{
	{ &CATID_Insertable,		   _T("Insertable") },
	{ &CATID_Control,			   _T("Control") },
	{ &CATID_MMControl,			   _T("MMControl") },
	{ &CATID_SafeForScripting2,    _T("Safe for scripting") },
	{ &CATID_SafeForInitializing2, _T("Safe for initializing") },
};


STDAPI
RegisterControls
(
	ControlInfo *pControlInfo,
	DWORD dwAction
)
{
	ASSERT(pControlInfo != NULL);
	ASSERT(RC_REGISTER == dwAction || RC_UNREGISTER == dwAction);

	HRESULT hr = S_OK;
	ICatRegister *pCatRegister = NULL;
	CATEGORYINFO CategoryInfo;
	const BOOL bRegister = (RC_REGISTER == dwAction);
	int i;

	// Since the function is most likely called directly from a control's
	// DllRegisterServer or DllUnRegisterServer, OLE has probably not been
	// initialized.  Initialize it now.

	::OleInitialize(NULL);

	// Get the component category manager.

	if ( FAILED( ::CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
								    CLSCTX_INPROC_SERVER, IID_ICatRegister,
								    (void**)&pCatRegister) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Register all the component categories in the aCatInfo array.

	CategoryInfo.lcid = LOCALE_SYSTEM_DEFAULT;

	for (i = 0; i < ARRAY_SIZE(aCatInfo); i++)
	{
		// Fill in the CATEGORYINFO array.

		CategoryInfo.catid = *aCatInfo[i].pCatID;

		#ifdef UNICODE
		::lstrcpy(CategoryInfo.szDescription, aCatInfo[i].szDescription);
		#else
		::ANSIToUNICODE( CategoryInfo.szDescription, aCatInfo[i].szDescription,
					     ARRAY_SIZE(CategoryInfo.szDescription) );
		#endif

		// Register the category.

		if ( FAILED( pCatRegister->RegisterCategories(1, &CategoryInfo) ) )
		{
			ASSERT(FALSE);
			goto ERR_EXIT;
		}
	}

    // Register or unregister each control in the linked list "pControlInfo".

    for ( ; pControlInfo != NULL; pControlInfo = pControlInfo->pNext)
    {
		if (bRegister)
		{
			if ( FAILED( ::_RegisterOneControl(pControlInfo, pCatRegister) ) )
				goto ERR_EXIT;
		}
		else
		{
			if ( !::_UnregisterOneControl(pControlInfo) )
				goto ERR_EXIT;
		}
    }

EXIT:

	::SafeRelease( (IUnknown **)&pCatRegister );
	::OleUninitialize();
    return (hr);

ERR_EXIT:

	hr = E_FAIL;
	goto EXIT;
}


//****************************************************************************
//*  Private helper functions
//*
//*  @doc None
//****************************************************************************

// Information about the component categories that may need to be registered
// for a single control.

static const CatInfoForOneControl aCatInfoForOneControl[] =
{
	{CI_INSERTABLE, 		 &CATID_Insertable},
	{CI_CONTROL, 			 &CATID_Control},
	{CI_MMCONTROL, 			 &CATID_MMControl},
	{CI_DESIGNER, 			 &CATID_Designer},
	{CI_SAFEFORSCRIPTING,    &CATID_SafeForScripting2},
	{CI_SAFEFORINITIALIZING, &CATID_SafeForInitializing2},
};


/*----------------------------------------------------------------------------
	@func BOOL | _RegisterOneControl |
	
	Register a single control.

	@rvalue TRUE | The control was registered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

HRESULT
_RegisterOneControl
(
	const ControlInfo *pControlInfo,  // @parm  Information structure for the
									  //         control.
	ICatRegister *pCatRegister		  // @parm  Pointer to the component
									  //		 category manager.
)
{
	ASSERT(pControlInfo != NULL);
	ASSERT(pCatRegister != NULL);

    TCHAR atchCLSID[GUID_CCH];
    TCHAR atchCLSIDKey[100];
    TCHAR atchModule[_MAX_PATH];
    TCHAR atch[400];
    TCHAR atch2[100];
	HRESULT hr = S_OK;


	//***************************************************
	//*  Setup
	//***************************************************

    // Check the cbSize field for the correct version.

    if ( pControlInfo->cbSize != sizeof(*pControlInfo) )
    {
		ASSERT(FALSE);
        goto ERR_EXIT;
    }

	// Convert the CLSID to a Unicode or ANSI string and store it in atchCLSID.
    // Example: {1C0DE070-2430-...}"

	if ( !::_TCHARFromGUID2(pControlInfo->pclsid, atchCLSID) )
    {
		ASSERT(FALSE);
        goto ERR_EXIT;
    }

	// Store "CLSID\<clsid>", in atchCLSIDKey.
    // Example: "CLSID\{1C0DE070-2430-...}"

	::wsprintf(atchCLSIDKey, _T("CLSID\\%s"), atchCLSID);

	// Store the module name in atchModule.
    // Example: "C:\Temp\MyCtl.ocx"

    ASSERT(pControlInfo->hmodDLL != NULL);

    if (NULL == pControlInfo->hmodDLL ||
		::GetModuleFileName( pControlInfo->hmodDLL, atchModule,
							 ARRAY_SIZE(atchModule) ) == 0)
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}


	//***************************************************
	//*  ProgID entries
	//***************************************************

    // Set "<tszProgID>=<tszFriendlyName>".
    // Example: "MyCtl.MyCtl.1=My Control"

    if ( FAILED( ::_SetRegKey(pControlInfo->tszProgID, NULL,
						      pControlInfo->tszFriendlyName) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

    // Set "<tszProgID>\CLSID=<clsid>"
    // Example: "MyCtl.MyCtl.1\CLSID={1C0DE070-2430-...}"

    if ( FAILED( ::_SetRegKey(pControlInfo->tszProgID, _T("\\CLSID"),
						      atchCLSID) ) )
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}

    // Set "<tszProgID>\Insertable" so that control shows up in
	// OleUIInsertObject dialog on Trident on Win 95.  Not needed on NT.

    if (pControlInfo->dwFlags & CI_INSERTABLE)
    {
        if ( FAILED( ::_SetRegKey( pControlInfo->tszProgID, _T("\\Insertable"),
							       _T("") ) ) )
	    {
		    ASSERT(FALSE);
            goto ERR_EXIT;
	    }
    }
    else
    {
        /*
            To ensure that control which are marked not insertable do not have an
            Insertable key because they had been marked insertable previously, we
            delete the Insertable subkey if it exists
        */

        TCHAR tchRegKey[256];

        if (pControlInfo->tszProgID && (lstrlen(pControlInfo->tszProgID) > 0))
        {
            ::wsprintf(tchRegKey, _T("%s\\Insertable"), pControlInfo->tszProgID);
#ifdef _DEBUG
            LONG lRet =
#endif // _DEBUG
                ::RegDeleteKey(HKEY_CLASSES_ROOT, tchRegKey);

#ifdef _DEBUG
            ASSERT((ERROR_SUCCESS == lRet) || (ERROR_FILE_NOT_FOUND == lRet));
#endif // _DEBUG
        }
    }


	//***************************************************
	//*  CLSID entries
	//***************************************************

    // Set "CLSID\<clsid>=<tszFriendlyName>".
    // Example: "CLSID\{1C0DE070-2430-...}=My Control"

    if ( FAILED( ::_SetRegKey(_T("CLSID\\"), atchCLSID,
						      pControlInfo->tszFriendlyName) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

    // Set "CLSID\<clsid>\ProgID=<tszProgID>".
    // Example: "CLSID\{1C0DE070-2430-...}\ProgID=MyCtl.MyCtl.1"

    // Set "CLSID\<clsid>\InprocServer32=<atchModule>".
    // Example "CLSID\{1C0DE070-2430-...}\InprocServer32="C:\Temp\MyCtl.ocx".

    if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\ProgID"),
							  pControlInfo->tszProgID) )
		 ||
    	 FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\InprocServer32"),
		 					  atchModule) ) )
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}

	// Add the named value "ThreadingModel=Apartment" under the
	// "InprocServer32" key.

	if (pControlInfo->dwFlags & CI_NOAPARTMENTTHREADING)
	{
		_DelRegKeyValue( atchCLSIDKey, _T("InprocServer32"),
						 _T("ThreadingModel") );
	}
	else if ( FAILED( ::_SetRegKeyValue( atchCLSIDKey, _T("InprocServer32"),
									    _T("ThreadingModel"),
									    _T("Apartment") ) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Set "CLSID\<clsid>\Version=<tszVersion>".
	// Example: "CLSID\{1C0DE070-2430-...}\Version=1.0"

    if ( pControlInfo->tszVersion != NULL &&
         FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\Version"),
		 				     pControlInfo->tszVersion) ) )
    {
		ASSERT(FALSE);
		goto ERR_EXIT;
    }

    if (pControlInfo->iToolboxBitmapID >= 0)
    {
        // Set "CLSID\<clsid>\ToolboxBitmap32=<atchModule>, <iToolboxBitmapID>".
        // Example:
		//   "CLSID\{1C0DE070-2430-...}\ToolboxBitmap32=C:\Temp\MyCtl.ocx, 1"

        ::wsprintf(atch, "%s, %u", atchModule, pControlInfo->iToolboxBitmapID);

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\ToolboxBitmap32"),
								  atch) ) )
		{
			ASSERT(FALSE);
            goto ERR_EXIT;
		}
    }

	if ( (pControlInfo->dwMiscStatusDefault != 0) ||
		 (pControlInfo->dwMiscStatusContent != 0) )
    {
        // Set "CLSID\<clsid>\MiscStatus=<dwMiscStatusDefault>".
        // Example:
		//   "CLSID\{1C0DE070-2430-...}\MiscStatus=<dwMiscStatusDefault>"

        :: wsprintf(atch, "%lu", pControlInfo->dwMiscStatusDefault);

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\MiscStatus"), atch) ) )
		{
			ASSERT(FALSE);
			goto ERR_EXIT;
		}
    }

    if (pControlInfo->dwMiscStatusContent != 0)
    {
        // Set "CLSID\<clsid>\MiscStatus\1=<dwMiscStatusContent>".
        // Example: "CLSID\{1C0DE070-2430-...}\MiscStatus\1=132497"

        :: wsprintf(atch, "%lu", pControlInfo->dwMiscStatusContent);

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\MiscStatus\\1"), atch) ) )
            goto ERR_EXIT;
    }


	//***************************************************
	//*  Component category entries
	//***************************************************

    if (pControlInfo->dwFlags & CI_INSERTABLE)
    {
        // Set "CLSID\<clsid>\Insertable".
        // Example: "CLSID\{1C0DE070-2430-...}\Insertable"

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\Insertable"), "") ) )
		{
			ASSERT(FALSE);
            goto ERR_EXIT;
		}
	}

    if (pControlInfo->dwFlags & CI_CONTROL)
    {
        // Set "CLSID\<clsid>\Control".
        // Example: "CLSID\{1C0DE070-2430-...}\Control"

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\Control"), "") ) )
		{
			ASSERT(FALSE);
            goto ERR_EXIT;
		}
    }

	// Make sure that the class is registered "safe-for-scripting" or "safe-
	// for-initializing" only if it declares that it is.

	pCatRegister->
	  UnRegisterClassImplCategories(*pControlInfo->pclsid, 1,
	  								(CATID*)&CATID_SafeForScripting2);
	pCatRegister->
	  UnRegisterClassImplCategories(*pControlInfo->pclsid, 1,
	  							    (CATID*)&CATID_SafeForInitializing2);

	// Set the component categories indicated by pControlInfo->dwFlags.

	if ( !_SetComponentCategories(aCatInfoForOneControl,
								  ARRAY_SIZE(aCatInfoForOneControl),
								  pCatRegister, pControlInfo) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}


	//***************************************************
	//*  Verb entries
	//***************************************************

    // Form a key of the form, "CLSID\<clsid>\Verb".

    ::lstrcpy(atch, atchCLSIDKey);
    ::lstrcat(atch, _T("\\Verb"));

    // Unregister any verbs currently associated with the control.

    if ( !RegDeleteTreeSucceeded( RegDeleteTree(HKEY_CLASSES_ROOT, atch) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

    // Register the control's verbs.

    if (pControlInfo->uiVerbStrID != 0)
    {

		// Set "CLSID\<clsid>\Verb".

		if ( FAILED( ::_SetRegKey(atch, NULL, "") ) )
		{
			ASSERT(FALSE);
			goto ERR_EXIT;
		}

        // Iterate through the consecutively numbered string resources
        // corresponding to the control's verbs.

        atch2[0] = _T('\\');

        for (UINT resid = pControlInfo->uiVerbStrID; TRUE; resid++)
        {
            // Load the string.

            if (LoadString(pControlInfo->hmodDLL, resid, atch2 + 1,
                           ARRAY_SIZE(atch2) - 2) == 0)
            {
                break;
            }

            // Parse out the key and value.

            TCHAR* ptchValue = _lstrchr(atch2, _T('='));

            if (ptchValue == NULL)
            {
                break;
            }

            *ptchValue = _T('\0');
            ptchValue++;

            if (*ptchValue == _T('\0'))
            {
                break;
            }

            // Register the key.

            if ( FAILED( ::_SetRegKey(atch, atch2, ptchValue) ) )
			{
				ASSERT(FALSE);
                goto ERR_EXIT;
			}
        }

    }


	//***************************************************
	//*  Type library entries
	//***************************************************

    if ( pControlInfo->pguidTypeLib != NULL)
	{
		TCHAR atchLIBID[GUID_CCH];

		// Convert the LIBID to an ANSI or Unicode string and store it in
		// atchLIBID.
		//
        // Set "CLSID\<clsid>\TypeLib=<*pguidTypeLib>"
        // Example: "CLSID\{1C0DE070-2430-...}\TypeLib={D4DBE870-2695-...}"
		//
		// Register the type library.

		if ( !::_TCHARFromGUID2(pControlInfo->pguidTypeLib, atchLIBID) ||
             FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\TypeLib"), atchLIBID) ) ||
		     !::_RegisterTypeLib(pControlInfo) )
		{
			ASSERT(FALSE);
			goto ERR_EXIT;
		}
	}

EXIT:

    return hr;

ERR_EXIT:

    TRACE("RegisterControls FAILED!\n");
	hr = E_FAIL;
	goto EXIT;
}


/*----------------------------------------------------------------------------
	@func BOOL | _UnregisterOneControl |
	
	Unregister a single control.

	@rvalue TRUE | The control was unregistered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_UnregisterOneControl
(
	const ControlInfo *pControlInfo  // @parm  Information structure for the
									 //         control.
)
{
	TCHAR atchCLSID[GUID_CCH];
	TCHAR szKey[_MAX_PATH];
	BOOL bRetVal = TRUE;

	// Convert the CLSID to a Unicode or ANSI string.

	if ( !::_TCHARFromGUID2(pControlInfo->pclsid, atchCLSID) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Recursively delete the key "CLSID\<clsid>".
    // Example: "CLSID\{1C0DE070-2430-...}"

	::wsprintf(szKey, _T("CLSID\\%s"), atchCLSID);

    if ( !RegDeleteTreeSucceeded(
	       RegDeleteTree(HKEY_CLASSES_ROOT, szKey) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

    // Recursively delete the ProgID "<tszProgID>".
    // Example: "MyCtl.MyCtl.1"

	if ( pControlInfo->tszProgID != NULL &&
		 !RegDeleteTreeSucceeded(
		   RegDeleteTree(HKEY_CLASSES_ROOT, (LPTSTR)pControlInfo->tszProgID) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Unregister the type library, if there is one.

    if ( pControlInfo->pguidTypeLib != NULL &&
		 !::_UnregisterTypeLib(pControlInfo) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

EXIT:

	return (bRetVal);

ERR_EXIT:

	bRetVal = FALSE;
	goto EXIT;
}


/*----------------------------------------------------------------------------
	@func BOOL | _RegisterTypeLib |
	
	Register the type library indicated by "pControlInfo".

	@comm
	This will fail if the module indicated by pControlInfo->hmodDLL doesn't
	contain a type library.  You can check for this before calling this
	function by looking at pControlInfo->pguidTypeLib, which should be NULL if
	there is no type library.

	@rvalue TRUE | The type library was registered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_RegisterTypeLib
(
	const ControlInfo *pControlInfo  // @parm  Information structure for the
									 //         control.
)
{
	ITypeLib *pTypeLib = NULL;
	OLECHAR aochModule[_MAX_PATH];
	BOOL bRetVal = TRUE;

	// Load and register the type library.

	if ( !::_LoadTypeLib(pControlInfo, &pTypeLib) ||
		 !_GetUnicodeModuleName(pControlInfo, aochModule) ||
		 FAILED( ::RegisterTypeLib(pTypeLib, aochModule, NULL) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

EXIT:

	::SafeRelease( (IUnknown **)&pTypeLib );
    return (bRetVal);

ERR_EXIT:

	bRetVal = FALSE;
	goto EXIT;
}


/*----------------------------------------------------------------------------
	@func BOOL | _UnregisterTypeLib |
	
	Unregister the type library indicated by "pControlInfo".

	@comm
	This will fail if the module indicated by pControlInfo->hmodDLL doesn't
	contain a type library.  You can check for this before calling this
	function by looking at pControlInfo->pguidTypeLib, which should be NULL if
	there is no type library.

	@rvalue TRUE | The type library was unregistered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_UnregisterTypeLib
(
	const ControlInfo *pControlInfo  // @parm  Information structure for the
									 //         control.
)
{
    TCHAR atchLIBID[GUID_CCH];
    TCHAR atchLIBIDKey[100];
	BOOL bRetVal = TRUE;
	ITypeLib *pTypeLib = NULL;

	// There is an UnRegisterTypeLib function in the OleAut32 DLL that
	// complements the RegisterTypeLib function in the same DLL, but there are
	// two problems with it.  First, it only unregisters the version and locale
	// you specify.  That's not good, because we really want to unregister all
	// versions and all locales.  Second, I've heard (but haven't been able to
	// confirm) that the OleAut32 DLL that went out with Win95 is missing this
	// function.
	//
	// To work around this, I've gone the route taken by MFC
	// (AfxOleUnregisterTypeLib in the MFC version delivered with VC 4.2b),
	// which manually deletes the keys it knows that RegisterTypeLib added.

	// Convert the LIBID to an ANSI or Unicode string and store it in atchLIBID.

	if ( !::_TCHARFromGUID2(pControlInfo->pguidTypeLib, atchLIBID) )
    {
		ASSERT(FALSE);
        goto ERR_EXIT;
    }

	// Recursively delete the key "TypeLib\<libid>".
    // Example: "TypeLib\{1C0DE070-2430-...}"

	::wsprintf(atchLIBIDKey, _T("TypeLib\\%s"), atchLIBID);

    if ( !::RegDeleteTreeSucceeded(
	       ::RegDeleteTree(HKEY_CLASSES_ROOT, atchLIBIDKey) ) )
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}

	// Load the type library.

	if ( !::_LoadTypeLib(pControlInfo, &pTypeLib) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Unregister the interfaces in the library.  (This is an MFC function that
	// doesn't return an error code.)

	::UnregisterInterfaces(pTypeLib);

EXIT:

	::SafeRelease( (IUnknown **)&pTypeLib );
    return (bRetVal);

ERR_EXIT:

	bRetVal = FALSE;
	goto EXIT;
}


/*----------------------------------------------------------------------------
	@func BOOL | _LoadTypeLib |
	
	Load the type library indicated by "pControlInfo".

	@comm
	This will fail if the module indicated by pControlInfo->hmodDLL doesn't
	contain a type library.  You can check for this before calling this
	function by looking at pControlInfo->pguidTypeLib, which should be NULL if
	there is no type library.

	@rvalue TRUE | The type library was loaded.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_LoadTypeLib
(
	const ControlInfo *pControlInfo,  // @parm  Information structure for the
									  //         control.
	ITypeLib **ppTypeLib			  // @parm  Storage for the type library
									  //	     pointer.  Gets set to NULL on
									  //		 error.
)
{
	ASSERT(pControlInfo != NULL);
	ASSERT(ppTypeLib != NULL);

    OLECHAR aochModule[_MAX_PATH];

	*ppTypeLib = NULL;

	// Get the module name and load the type library.

	if ( !_GetUnicodeModuleName(pControlInfo, aochModule) ||
	     FAILED( ::LoadTypeLib(aochModule, ppTypeLib) ) )
	{
		ASSERT(FALSE);
		return (FALSE);
	}

	return (TRUE);
}


/*----------------------------------------------------------------------------
	@func BOOL | _SetComponentCategories |
	
	Set the component categories for a single control.

	@rvalue TRUE | The categories were registered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_SetComponentCategories
(
	// @parm Array of flags and CatIDs.
	const CatInfoForOneControl *pCatInfoForOneControl,

	// @parm  Number of elements in pCatInfoForOneControl.
	int iEntries,

	// Pointer to the component category manager.
	ICatRegister *pCatRegister,

	// @parm  Information structure for the control.
	const ControlInfo *pControlInfo
)
{
	ASSERT(pCatInfoForOneControl != NULL);
	ASSERT(pCatRegister != NULL);
	ASSERT(pControlInfo != NULL);

	int i;

	// Loop through all elements in the array.

	for (i = 0; i < iEntries; i++, pCatInfoForOneControl++)
	{
		// If dwFlags includes dwFlagToCheck, register the category pCatID for
		// the control.

		if ( (pControlInfo->dwFlags & pCatInfoForOneControl->dwFlagToCheck) &&
			 FAILED(pCatRegister->
			   RegisterClassImplCategories(*pControlInfo->pclsid, 1,
			   							   (CATID *)pCatInfoForOneControl->
										     pCatID) ) )
		{
			return (FALSE);
		}
	}

	return (TRUE);
}


/*----------------------------------------------------------------------------
	@func BOOL | _TCHARFromGUID2 |
	
	Convert a GUID to a Unicode or ANSI string.

	@comm
	This converts "pGUID" to either a Unicode or an ANSI string, depending on
	whether Unicode is defined.

	@rvalue TRUE | The GUID was converted.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_TCHARFromGUID2
(
	const GUID *pGUID,  // @parm  Pointer to the GUID to convert.
    TCHAR *ptchGUID 	// @parm  Storage for the string.  Must be at least
						//         GUID_CCH characters long.  Define as
						//		   TCHAR atchGUID[GUID_CCH].
)
{
	ASSERT(pGUID != NULL);
    ASSERT(ptchGUID != NULL);

	if (::TCHARFromGUID(*pGUID, ptchGUID, GUID_CCH) == NULL)
	{
		ASSERT(FALSE);
		return (FALSE);
	}

	return (TRUE);
}


/*----------------------------------------------------------------------------
	@func BOOL | _GetUnicodeModuleName |
	
	Get the module name, in Unicode.

	@comm
	This gets the module name for "pControlInfo" and stores it at "pochModule"
	in Unicode format.  "pochModule" must be defined as
	OLECHAR pochModule[_MAX_PATH].

	@rvalue TRUE | The GUID was converted.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_GetUnicodeModuleName
(
	const ControlInfo *pControlInfo,  // @parm  Information structure for the
									  //         control.
	OLECHAR *pochModule				  // @parm  Must be defined as
									  //         OLECHAR pochModule[_MAX_PATH].
)
{
	ASSERT(pControlInfo != NULL);
	ASSERT(pochModule != NULL);

    TCHAR atchModule[_MAX_PATH];
	BOOL bRetVal = TRUE;

    pochModule[0] = 0;

	// Store the module name in atchModule.
    // Example: "C:\Temp\MyCtl.ocx"

    ASSERT(pControlInfo->hmodDLL != NULL);

    if (NULL == pControlInfo->hmodDLL ||
		::GetModuleFileName( pControlInfo->hmodDLL, atchModule,
							 ARRAY_SIZE(atchModule) ) == 0)
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}

	// Convert the file name to Unicode.

	#ifdef UNICODE
	::lstrcpy(pochModule, atchModule);
	#else
	::ANSIToUNICODE(pochModule, atchModule, _MAX_PATH);
	#endif

EXIT:

    return (bRetVal);

ERR_EXIT:

	bRetVal = FALSE;
	goto EXIT;
}


TCHAR* _lstrchr(
const TCHAR* sz,
const TCHAR ch)
{
    const TCHAR* pch = NULL;

    if (sz != NULL)
    {
        for (pch = sz; (*pch != _T('\0')) && (*pch != ch); pch++)
        {
            ;
        }
        if (*pch == _T('\0'))
        {
            pch = NULL;
        }
    }

    return (const_cast<TCHAR*>(pch));
}


// hr = _SetRegKey(tszKey, tszSubkey, tszValue)
//
// Set the concatenated registry key name <tszKey><tszSubkey> (within
// HKEY_CLASSES_ROOT) to value <tszValue>.  If <tszSubkey> is NULL,
// it is ignored.

HRESULT _SetRegKey(LPCTSTR tszKey, LPCTSTR tszSubkey, LPCTSTR tszValue)
{
    TCHAR atchKey[500];   // a registry key

    lstrcpy(atchKey, tszKey);
    if (tszSubkey != NULL)
        lstrcat(atchKey, tszSubkey);

    return (RegSetValue(HKEY_CLASSES_ROOT, atchKey, REG_SZ, tszValue,
            lstrlen(tszValue)*sizeof(TCHAR)) == ERROR_SUCCESS) ? S_OK : E_FAIL;
}


// hr = _SetRegKeyValue(szKey, szSubkey, szValueName, szValue)
//
// Set the string value named <tszValueName> to <tszValue> associated
// with the registry key HKEY_CLASSES_ROOT\<szKey>\<szSubkey>
// where <szSubkey> may be NULL.

HRESULT _SetRegKeyValue(
LPCTSTR szKey,
LPCTSTR szSubkey,
LPCTSTR szValueName,
LPCTSTR szValue)
{
	HKEY hKey1 = NULL;
	HKEY hKey2 = NULL;
		// registry keys
	HKEY hKey = NULL;
		// an alias for <hKey1> or <hKey2>
	HRESULT hr = S_OK;
		// function return value

	// hKey = HKEY_CLASSES_ROOT\szKey, or
	//      = HKEY_CLASSES_ROOT\szKey\szSubkey

	if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hKey1) != ERROR_SUCCESS)
	{
		goto ERR_EXIT;
	}
	if (szSubkey != NULL)
	{
		if (RegOpenKey(hKey1, szSubkey, &hKey2) != ERROR_SUCCESS)
		{
			goto ERR_EXIT;
		}
		hKey = hKey2;
	}
	else
	{
		hKey = hKey1;
	}

	// Set the value.

	if (RegSetValueEx(hKey, szValueName, 0, REG_SZ, (BYTE*)szValue,
					  lstrlen(szValue) * sizeof(TCHAR)) != ERROR_SUCCESS)
	{
		goto ERR_EXIT;
	}

EXIT:

	if (hKey1 != NULL)
	{
		RegCloseKey(hKey1);
	}
	if (hKey2 != NULL)
	{
		RegCloseKey(hKey2);
	}
	return (hr);

ERR_EXIT:

	hr = E_FAIL;
	goto EXIT;
}


// _DelRegKeyValue(szKey, szSubkey, tszValueName)
//
// Delete the value named <szValueName> associated with the registry
// key, HKEY_CLASSES_ROOT\<szKeyName>\<szSubkeyName> where <szSubkeyName>
// may be NULL.

void _DelRegKeyValue(
LPCTSTR szKey,
LPCTSTR szSubkey,
LPCTSTR szValueName)
{
	HKEY hKey = NULL;
	HKEY hKey1 = NULL;
	HKEY hKey2 = NULL;
		// registry keys

	// hKey = HKEY_CLASSES_ROOT\szKey, or
	//      = HKEY_CLASSES_ROOT\szKey\szSubkey

	if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hKey1) != ERROR_SUCCESS)
	{
		goto EXIT;
	}
	if (szSubkey != NULL)
	{
		if (RegOpenKey(hKey1, szSubkey, &hKey2) != ERROR_SUCCESS)
		{
			goto EXIT;
		}
		hKey = hKey2;
	}
	else
	{
		hKey = hKey1;
	}

	// At this point, <hKey> is the registry key that owns the value.
	// Delete the value.
	
	RegDeleteValue(hKey, szValueName);

EXIT:
	if (hKey1 != NULL)
	{
		RegCloseKey(hKey1);
	}
	if (hKey2 != NULL)
	{
		RegCloseKey(hKey2);
	}
}


//****************************************************************************
//*  Functions stolen from MFC
//****************************************************************************

// [I took the code for RegDeleteTree directly from _AfxRecursiveRegDeleteKey
// in MFC from VC 4.2b.  The only changes I made were to remove remove the
// AFXAPI from the return type and add the diagnostics on szKeyName.
// -- Tony Capone]

// Under Win32, a reg key may not be deleted unless it is empty.
// Thus, to delete a tree,  one must recursively enumerate and
// delete all of the sub-keys.

#define ERROR_BADKEY_WIN16  2   // needed when running on Win32s

STDAPI_(LONG)
RegDeleteTree(HKEY hParentKey, LPCTSTR szKeyName)
{
	if ( HKEY_CLASSES_ROOT == hParentKey &&
	    (NULL == szKeyName ||
		::lstrcmpi( szKeyName, _T("") ) == 0 ||
		::lstrcmpi( szKeyName, _T("\\") ) == 0 ||
		::lstrcmpi( szKeyName, _T("CLSID") ) == 0 ||
		::lstrcmpi( szKeyName, _T("CLSID\\") ) == 0) )
	{
		ASSERT(FALSE);
		return (ERROR_BADKEY);
	}

	DWORD   dwIndex = 0L;
	TCHAR   szSubKeyName[256];
	HKEY    hCurrentKey;
	DWORD   dwResult;

	if ((dwResult = RegOpenKey(hParentKey, szKeyName, &hCurrentKey)) ==
		ERROR_SUCCESS)
	{
		// Remove all subkeys of the key to delete
		while ((dwResult = RegEnumKey(hCurrentKey, 0, szSubKeyName, 255)) ==
			ERROR_SUCCESS)
		{
			if ((dwResult = RegDeleteTree(hCurrentKey,
				szSubKeyName)) != ERROR_SUCCESS)
				break;
		}

		// If all went well, we should now be able to delete the requested key
		if ((dwResult == ERROR_NO_MORE_ITEMS) || (dwResult == ERROR_BADKEY) ||
			(dwResult == ERROR_BADKEY_WIN16))
		{
			dwResult = RegDeleteKey(hParentKey, szKeyName);
		}
	}

	RegCloseKey(hCurrentKey);
	return dwResult;
}


// [I took the code for RegDeleteTreeSucceeded directly from
// _AfxRegDeleteKeySucceeded in MFC in VC 4.2b.  // -- Tony Capone]

BOOL RegDeleteTreeSucceeded(LONG error)
{
	return (error == ERROR_SUCCESS) || (error == ERROR_BADKEY) ||
		(error == ERROR_FILE_NOT_FOUND);
}


// [I took the code for UnregisterInterfaces directly from
// _AfxUnregisterInterfaces in MFC in VC 4.2b.  The changes I made are marked
// with my initials.  -- Tony Capone]

void UnregisterInterfaces(ITypeLib* pTypeLib)
{
	TCHAR szKey[128] = _T("Interface\\");
//	_tcscpy(szKey, _T("Interface\\"));
	LPTSTR pszGuid = szKey + (sizeof(_T("Interface\\")) / sizeof(TCHAR));

	int cTypeInfo = pTypeLib->GetTypeInfoCount();

	for (int i = 0; i < cTypeInfo; i++)
	{
		TYPEKIND tk;
		if (SUCCEEDED(pTypeLib->GetTypeInfoType(i, &tk)) &&
			(tk == TKIND_DISPATCH || tk == TKIND_INTERFACE))
		{
			ITypeInfo* pTypeInfo = NULL;
			if (SUCCEEDED(pTypeLib->GetTypeInfo(i, &pTypeInfo)))
			{
				TYPEATTR* pTypeAttr;
				if (SUCCEEDED(pTypeInfo->GetTypeAttr(&pTypeAttr)))
				{
					#if 0  // TC
#ifdef _UNICODE
					StringFromGUID2(pTypeAttr->guid, pszGuid, GUID_CCH);
#else
					WCHAR wszGuid[39];
					StringFromGUID2(pTypeAttr->guid, wszGuid, GUID_CCH);
					_wcstombsz(pszGuid, wszGuid, GUID_CCH);
#endif
					#else  // TC

					VERIFY( ::_TCHARFromGUID2(&pTypeAttr->guid, pszGuid) );

					#endif  // TC

					#if 0  // TC
					_AfxRecursiveRegDeleteKey(HKEY_CLASSES_ROOT, szKey);
					#else  // TC
					RegDeleteTree(HKEY_CLASSES_ROOT, szKey);
					#endif  // TC

					pTypeInfo->ReleaseTypeAttr(pTypeAttr);
				}

				pTypeInfo->Release();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\pviol.cpp ===
// pviol.cpp
//
// Implements PersistVariantIOList.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | PersistVariantIOList |

        Loads or saves a list of property name/value pairs, specified as a
        va_list array that's formatted in the same way as
        <om IVariantIO.Persist>, to/from an <i IPropertyBag> object.

@rvalue S_OK | Success.  At least one of the variables listed in
        <p args> was written to, so the control may want to update
        itself accordingly.

@rvalue S_FALSE | None of the variables listed in <p args> were
        written to (either because the <i IVariantIO> object is in
        saving mode or because none of the properties named in
        <p args> exist in the <i IVariantIO> object).

@rvalue DISP_E_BADVARTYPE | One of the VARTYPE values in <p args> is invalid.

@rvalue E_FAIL | A failure occurred while reading from the property bag, other
		than "property doesn't exist."  This can happen if the caller specified
		a type to which the property bag could not coerce the property, for
		example.

@rvalue E_OUTOFMEMORY | Out of memory.

@parm	IPropertyBag * | ppb | The property bag used to load or save the
		specified properties.

@parm   DWORD | dwFlags | May contain the same flags passed to
        <om IManageVariantIO.SetMode> (e.g. VIO_ISLOADING).

@parm   va_list | args | The arguments to pass.  See <om IVariantIO.Persist>
        for information about the organization of these arguments.
*/
STDAPI PersistVariantIOList(IPropertyBag *ppb, DWORD dwFlags, va_list args)
{
    HRESULT         hrReturn = S_OK; // function return code
    LPSTR           szArg;          // property name from <args>
    VARTYPE         vtArg;          // variable type from <args>
    LPVOID          pvArg;          // variable pointer from <args>
    VARIANT         varProp;        // value of the property named <szArg>
    BOOL            fWroteToVar = FALSE; // TRUE if wrote to a var. in <args>
    VARIANT         varArg;         // value of an variable in <args>
    VARTYPE         vtRequested;    // type to coerce property value to
	BOOL			fVarNon0 = TRUE; // TRUE if variant to save is non-zero
    BSTR            bstr = NULL;
    OLECHAR         oach[_MAX_PATH];
    VARIANT         var;
    int             cch;
    HRESULT         hrTemp;

    // invariant: <varProp> and <var> each either contain data that
    // this function must clean up using VariantClear() or contain
    // no data (i.e. have been initialized using VariantInit() or
    // cleared already using VariantClear()) -- but note that this
    // invariant doesn't apply to <varArg> (i.e. <varArg> should
    // not be cleared by this function)
    VariantInit(&varProp);
    VariantInit(&var);

    // loop once for each (name, VARTYPE, value) triplet in <args>
    while ((szArg = va_arg(args, LPSTR)) != NULL)
    {
        // <szArg> is the name of the property in the current triplet;
        // set <vtArg> to the type of the variable pointer, and set
        // <pvArg> to the variable pointer
        vtArg = va_arg(args, VARTYPE);
        pvArg = va_arg(args, LPVOID);

        if (dwFlags & VIO_ISLOADING)
        {
            // we need to copy data from the property named <szArg> to
            // the variable at location <pvArg>...

            // set <vtRequested> to the type to coerce the property value to;
            // set <vtRequested> to VT_EMPTY if the caller wants the property
            // in its default type
            if (vtArg == VT_VARIANT)
                vtRequested = VT_EMPTY;
            else
            if (vtArg == VT_INT)
                vtRequested = VT_I4;
            else
            if (vtArg == VT_LPSTR)
                vtRequested = VT_BSTR;
            else
                vtRequested = vtArg;

            // set <varProp> to a copy of the property named <szArg>
            memset(&varProp, 0, sizeof(varProp)); // clear <vt> and <bstrVal>
            ANSIToUNICODE(oach, szArg, sizeof(oach) / sizeof(*oach) - 1);
            varProp.vt = vtRequested;
            hrTemp = ppb->Read(oach, &varProp, NULL);
            if (E_INVALIDARG == hrTemp)
            {
				// The specified property doesn't exist in the property bag.
				// This isn't an error; the property will just remain at its
				// default value.
                VariantInit(&varProp);
                continue;
            }
			else
            if (FAILED(hrTemp))
            {
				// The property bag was unable to read the specified property.
				// This can happen if the caller specified a type to which the
				// property bag could not coerce the property, for example.
				// This is an error.
                hrReturn = hrTemp;
                goto ERR_EXIT;
            }
            else
            if ((vtRequested != VT_EMPTY) && (varProp.vt != vtRequested))
            {
                VariantClear(&varProp);
                continue;
            }

            // store the value of <varProp> into <pvArg>
            switch (vtArg)
            {
            case VT_VARIANT:
                VariantClear((VARIANT *) pvArg);
                *((VARIANT *) pvArg) = varProp;
                VariantInit(&varProp); // hand over ownership to <pvArg>
                break;
            case VT_I2:
                *((short *) pvArg) = varProp.iVal;
                break;
            case VT_I4:
            case VT_INT:
                *((long *) pvArg) = varProp.lVal;
                break;
            case VT_R4:
                *((float *) pvArg) = V_R4(&varProp);
                break;
            case VT_R8:
                *((double *) pvArg) = V_R8(&varProp);
                break;
            case VT_BOOL:
                *((BOOL *) pvArg) = (V_BOOL(&varProp) == 0 ? 0 : 1);
                break;
            case VT_BSTR:
                SysFreeString(*((BSTR *) pvArg));
                *((BSTR *) pvArg) = varProp.bstrVal;
                VariantInit(&varProp); // hand over ownership to <pvArg>
                break;
            case VT_UNKNOWN:
            case VT_DISPATCH:
                if (*((LPUNKNOWN *) pvArg) != NULL)
                    (*((LPUNKNOWN *) pvArg))->Release();
                *((LPUNKNOWN *) pvArg) = varProp.punkVal;
                if (*((LPUNKNOWN *) pvArg) != NULL)
                    (*((LPUNKNOWN *) pvArg))->AddRef();
                break;
            case VT_LPSTR:
                UNICODEToANSI((LPSTR) pvArg, varProp.bstrVal, _MAX_PATH - 1);
                break;
            default:
                hrReturn = DISP_E_BADVARTYPE;
                goto ERR_EXIT;
            }

            fWroteToVar = TRUE;
        }
        else
        {
            // we need to copy data from the variable at location <pvArg>
            // to the property named <szArg>...

            // make <varArg> contain the data (not a copy of the data) of the
            // variable at location <pvArg>
            if (vtArg == VT_VARIANT)
                varArg = *((VARIANT *) pvArg);
            else
            {
				varArg.vt = vtArg;
				switch (vtArg)
				{
				case VT_I2:
					varArg.iVal = *((short *) pvArg);
					break;
				case VT_I4:
				case VT_INT:
					varArg.lVal = *((long *) pvArg);
					varArg.vt = VT_I4;
					break;
                case VT_R4:
                    V_R4(&varArg) = *((float *) pvArg);
                    break;
               case VT_R8:
                    V_R8(&varArg) = *((double *) pvArg);
                    break;
				case VT_BOOL:
					V_BOOL(&varArg) = (*((BOOL *) pvArg) ? -1 : 0);
					break;
				case VT_BSTR:
					varArg.bstrVal = *((BSTR *) pvArg);
					break;
				case VT_UNKNOWN:
				case VT_DISPATCH:
					varArg.punkVal = *((LPUNKNOWN *) pvArg);
					break;
				case VT_LPSTR:
					SysFreeString(bstr);
					cch = lstrlen((LPSTR) pvArg);
					bstr = SysAllocStringLen(NULL, cch);
					if (bstr == NULL)
						goto ERR_OUTOFMEMORY;
					ANSIToUNICODE(bstr, (LPSTR) pvArg, cch + 1);
					varArg.bstrVal = bstr;
					varArg.vt = VT_BSTR;
					break;
				default:
					hrReturn = DISP_E_BADVARTYPE;
					goto ERR_EXIT;
				}

				// is the value to be saved non-zero?
				switch (vtArg)
				{
				case VT_I2:
					fVarNon0 = varArg.iVal;
					break;
				case VT_I4:
				case VT_INT:
				case VT_R4:
				case VT_BOOL:
				case VT_UNKNOWN:
				case VT_DISPATCH:
				case VT_BSTR:
					fVarNon0 = varArg.lVal;
					break;
				case VT_LPSTR:
					fVarNon0 = cch;
					break;
				case VT_R8:
					fVarNon0 = (varArg.dblVal != 0);
					break;
				default:
					hrReturn = DISP_E_BADVARTYPE;
					goto ERR_EXIT;
				}
            }

			// only save the variant if it's value isn't 0, or if we're saving
			// even 0 default values
			if (fVarNon0 || !(dwFlags & VIO_ZEROISDEFAULT))
			{
				// set the value of the property named <szArg> to be a copy of
				// <varArg>
				ANSIToUNICODE(oach, szArg, sizeof(oach) / sizeof(*oach) - 1);
				if (FAILED(ppb->Write(oach, &varArg)))
					goto ERR_OUTOFMEMORY;
			}
        }
    }

    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)

    goto EXIT;

EXIT:

    // normal cleanup
    VariantClear(&varProp);
    VariantClear(&var);
    SysFreeString(bstr);

    if (FAILED(hrReturn))
        return hrReturn;
    return (fWroteToVar ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\typelib.cpp ===
// typelib.cpp
//
// Type information support (events only -- not for properties and methods)
// using type libraries.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | HelpGetClassInfoFromTypeLib |

        Helps implement <om IProvideClassInfo.GetClassInfo> using a
        caller-provided type library.

@parm   LPTYPEINFO * | ppti | Where to return the pointer to the
        newly-allocated <i ITypeInfo> interface.  NULL is stored in
        *<p ppti> on error.

@parm   REFCLSID | rclsid | The class ID of the object that is implementing
        <i IProvideClassInfo>.

@parm   ITypeLib * | plib | The type library containing events.  Should be
        NULL if <p plib> is non-NULL.

@parm   HINSTANCE | hinst | The DLL instance containing a type library
        resource.  Should be NULL if <p plib> is non-NULL.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   This function accesses type information in the type library specified
        by either <p plib> (if the type library is already loaded) or
        <p hinst> (in which case this function loads the type library).

        It is assumed that the type library contains a "coclass" typeinfo
        and a an outgoing (source) "dispinterface" typeinfo.  The class ID
        of the "coclass" typeinfo should be <p rclsid>.

@ex     In the following example, <c CMyControl> is a class that implements
        (among other things) <i IConnectionPointContainer> and
        <i IProvideClassInfo>.  The first part of this example shows how
        <om IProvideClassInfo.GetClassInfo> is implemented by <c CMyControl>.
        The second part of the example shows how an event is fired,
        assuming <p m_pconpt> is a <i IConnectionPointHelper> object.
        (It's not required that you use <o ConnectionPointHelper>, but
        it's helpful.) |

        // in MyControl.h...

        // IDispatch IDs for events fired by this object
        #define DISPID_EVENT_BAR        1
        #define DISPID_EVENT_LOAD       2

        // class ID
        #define _CLSID_CMyControl 3CE08A80-9440-11CF-B705-00AA00BF27FD
        #ifndef __MKTYPLIB__
        DEFINE_GUID(CLSID_CMyControl, 0x3CE08A80L, 0x9440, 0x11CF,
            0xB7, 0x05, 0x00, 0xAA, 0x00, 0xBF, 0x27, 0xFD);
        #endif

        // dispinterface ID for event set
        #define _DIID_DMyControlEvents 296CC160-9F5A-11CF-B705-00AA00BF27FD
        #ifndef __MKTYPLIB__
        DEFINE_GUID(DIID_DMyControlEvents, 0x296CC160L, 0x9F5A, 0x11CF,
            0xB7, 0x05, 0x00, 0xAA, 0x00, 0xBF, 0x27, 0xFD);
        #endif

        // in the .odl  file...

        #include <olectl.h>
        #includ  "MyControl.h"

        [ uuid(B1179240-9445-11CF-B705-00AA00BF27FD), version(1.0), control ]
        library MyControlLib
        {
            importlib(STDOLE_TLB);
            importlib(STDTYPE_TLB);

            // event dispatch interface for CMyControl
            [ uuid(_DIID_DMyControlEvents) ]
            dispinterface _DMyControlEvents
            {
                properties:
                methods:
                    [id(DISPID_EVENT_BAR)] void Bar(long i, BSTR sz, boolean f);
                    [id(DISPID_EVENT_LOAD)] void Load();
            };

            // class information for CMyControl
            [ uuid(_CLSID_CMyControl), control ]
            coclass MyControl
            {
                [default, source] dispinterface _DMyControlEvents;
            };
        };

        // in some .cpp file...

        STDMETHODIMP CMyControl::GetClassInfo(LPTYPEINFO FAR* ppTI)
        {
            return HelpGetClassInfoFromTypeLib(ppTI, CLSID_CMyControl, NULL,
                g_hinst, 0);
        }

        // in some .cpp file...

        // fire the "Bar" event (which has 3 parameters, which in BASIC
        // are of these types: Integer, String, Boolean)
        m_pconpt->FireEvent(DISPID_EVENT_BAR, VT_INT, 300 + i,
            VT_LPSTR, ach, VT_BOOL, TRUE, 0);
*/
STDAPI HelpGetClassInfoFromTypeLib(LPTYPEINFO *ppTI, REFCLSID rclsid,
    ITypeLib *plib, HINSTANCE hinst, DWORD dwFlags)
{
    TRACE("HelpGetClassInfoFromTypeLib\n");

    if (plib == NULL)
    {
        char ach[_MAX_PATH];
        if (GetModuleFileName(hinst, ach, sizeof(ach)) == 0)
            return E_FAIL;
        HRESULT hr;
        ITypeLib *plib;
        OLECHAR aoch[_MAX_PATH];
        ANSIToUNICODE(aoch, ach, _MAX_PATH);
        if (FAILED(hr = LoadTypeLib(aoch, &plib)))
            return hr;
        hr = plib->GetTypeInfoOfGuid(rclsid, ppTI);
        plib->Release();
        return hr;
    }
    else
        return plib->GetTypeInfoOfGuid(rclsid, ppTI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\ucat.cpp ===
// ucat.cpp
//
// Implements UNICODEConcat.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func wchar_t * | UNICODEConcat |

        Concatenates one UNICODE string to another.

@rdesc  Returns a pointer to the NULL at the end of <p wpchDst>.

@parm   wchar_t * | wpchDst | Where to copy <p wpchSrc> to.

@parm   const wchar_t * | wpchSrc | String to copy.

@parm   int | wcchDstMax | Capacity of <p wpchDst> (in wide characters).
        If <p wcchDstMax> is less than or equal to zero, this function
        does nothing.

@comm   Provided <p wcchDstMax> greater than zero, <p wpchDst> is always
        null-terminated.
*/
STDAPI_(wchar_t *) UNICODEConcat(wchar_t *wpchDst, const wchar_t *wpchSrc,
    int wcchDstMax)
{
    while (*wpchDst != 0)
        wpchDst++, wcchDstMax--;
    return UNICODECopy(wpchDst, wpchSrc, wcchDstMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\ucopy.cpp ===
// ucopy.cpp
//
// Implements UNICODECopy.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func wchar_t * | UNICODECopy |

        Copies one UNICODE string to another.

@rdesc  Returns a pointer to the NULL at the end of <p wpchDst>, unless
        <p wpchDstMax> is less than or equal to zero.  In that case, returns
		<p wpchDst>.

@parm   wchar_t * | wpchDst | Where to copy <p wpchSrc> to.

@parm   const wchar_t * | wpchSrc | String to copy.

@parm   int | wcchDstMax | Capacity of <p wpchDst> (in wide characters).
        If <p wcchDstMax> is less than or equal to zero, this function
        does nothing.

@comm   Provided <p wcchDstMax> greater than zero, <p wpchDst> is always
        null-terminated.
*/
STDAPI_(wchar_t *) UNICODECopy(wchar_t *wpchDst, const wchar_t *wpchSrc,
    int wcchDstMax)
{
    if (wcchDstMax <= 0)
        goto EXIT;

    while (*wpchSrc != 0)
    {
        if (--wcchDstMax == 0)
            break;
        *wpchDst++ = *wpchSrc++; 
    }
    *wpchDst = 0;

	EXIT:
		return wpchDst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unicode.cpp ===
// unicode.cpp
//
// Implements UNICODE helper functions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func int | UNICODEToANSI |

        Converts a UNICODE string to ANSI.

@rdesc  Returns the same integer as WideCharToMultiByte.  0 means "failed."

@parm   LPSTR | pchDst | The buffer that will hold the output ANSI string.

@parm   LPCWSTR | pwchSrc | The input UNICODE string.  NULL is interpreted as
        a zero-length string.

@parm   int | cchDstMax | The size of <p pchDst>, in characters.  If <p pchDst>
		is declared as char pchDst[32], for example, <p cchDstMax> should be 32.
		If <p pchDst> isn't large enough to hold the ANSI string (including the
		terminating NULL), <p pchDst> is set to zero length and 0 is returned.
		(In debug versions, an assertion also occurs.)

@comm   If you want to determine the ANSI buffer size required for a given
		UNICODE string pwchSrc, you can call UNICODEToANSI(NULL, pwchSrc, 0).
		This returns the required buffer size in characters, including space
		for the terminating NULL.

@ex		Here is code (without debug checks) that dynamically allocates the ANSI
		buffer and converts the UNICODE string pwchSrc: |

			int cchDst;
			char *pchDst;
			cchDst = UNICODEToANSI(NULL, pwchSrc, 0);
			pchDst = new char [cchDst];
			UNICODEToANSI(pchDst, pwchSrc, cchDst)

*/
STDAPI_(int) UNICODEToANSI(LPSTR pchDst, LPCWSTR pwchSrc, int cchDstMax)
{
	// (We allow the caller to pass a cchDstMax value of 0 and a NULL pchDst to
	// indicate "tell me the buffer size I need, including the NULL.")

	ASSERT(pchDst != NULL || 0 == cchDstMax);
	ASSERT(cchDstMax >= 0);

	#ifdef _DEBUG

	// Make sure we won't exceed the length of the user-supplied buffer,
	// pchDst.  The following call returns the number of characters required to
	// store the converted string, including the terminating NULL.

    if(cchDstMax > 0)
	{
		int iChars;
	
		iChars =
		  	WideCharToMultiByte(CP_ACP, 0, pwchSrc ? pwchSrc : OLESTR(""),
							    -1, NULL, 0, NULL, NULL); 
		ASSERT(iChars <= cchDstMax);
	}

	#endif

	int iReturn;

	iReturn = WideCharToMultiByte(CP_ACP, 0, pwchSrc ? pwchSrc : OLESTR( "" ), 
								  -1, pchDst, cchDstMax, NULL, NULL); 

	if (0 == iReturn)
	{
		// The conversion failed.  Return an empty string.

		if (pchDst != NULL)
			pchDst[0] = 0;

		ASSERT(FALSE);
	}

	return (iReturn);
}


/* @func int | ANSIToUNICODE |

        Converts an ANSI string to UNICODE.

@parm   LPWSTR | pwchDst | The buffer that will hold the output UNICODE string.

@parm   LPCSTR | pchSrc | The input ANSI string.

@parm   int | cwchDstMax | The size of <p pwchDst>, in wide characters.  If
		pwchDst is declared as OLECHAR pwchDst[32], for example, cwchDstMax
		should be 32.

*/
STDAPI_(int) ANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc, int cwchDstMax)
{

	ASSERT( pwchDst );
	ASSERT( pchSrc );

    return MultiByteToWideChar(CP_ACP, 0, pchSrc, -1, pwchDst, cwchDstMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unklist.cpp ===
// unklist.cpp
//
// Defines CUnknownList, which maintains a simple ordered list of LPUNKNOWNs.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//

#include "precomp.h"
#include "unklist.h"

//////////////////////////////////////////////////////////////////////////////
// CUnknownItem -- an item in a CUnknownList
//


// CUnknownItem(punk, pitemNext, pitemPrev)
//
// Construct a CUnknownItem containing <punk> (which is AddRef'd if it's
// not NULL).
//
CUnknownItem::CUnknownItem(LPUNKNOWN punk, CUnknownItem *pitemNext,
    CUnknownItem *pitemPrev, DWORD dwCookie)
{
    if ((m_punk = punk) != NULL)
        m_punk->AddRef();
    m_pitemNext = pitemNext;
    m_pitemPrev = pitemPrev;
    pitemNext->m_pitemPrev = this;
    pitemPrev->m_pitemNext = this;
    m_dwCookie = dwCookie; 
}


// ~CUnknownItem()
//
// Destroy the CUnknownItem, including calling Release() on the LPUNKNOWN it
// holds (if it's not NULL).
//
CUnknownItem::~CUnknownItem()
{
    if (m_punk != NULL)
        m_punk->Release();
    m_pitemPrev->m_pitemNext = m_pitemNext;
    m_pitemNext->m_pitemPrev = m_pitemPrev;
}


// punk = Contents()
//
// Returns the LPUNKNOWN contained in the item.  AddRef() is called on
// this LPUNKNOWN (if it's not NULL) -- the caller is responsible for
// calling Release().
//
LPUNKNOWN CUnknownItem::Contents()
{
    if (m_punk != NULL)
        m_punk->AddRef();
    return m_punk;
}


//////////////////////////////////////////////////////////////////////////////
// CUnknownList -- a list of LPUNKNOWNs
// 


// CUnknownList()
//
// Construct the list to be initially empty.
//
CUnknownList::CUnknownList() :
    m_itemHead(NULL, &m_itemHead, &m_itemHead, 0)

{
    m_citem = 0;
    m_pitemCur = &m_itemHead;
    m_dwNextCookie = 1;
}


// ~CUnknownList()
//
// Destroy the list.  Release() is called on each non-NULL LPUNKNOWN in the
// list.
//
CUnknownList::~CUnknownList()
{
    EmptyList();
}


// EmptyList()
//
// Empty the list.  Release() is called on each non-NULL LPUNKNOWN in the list.
// 
void CUnknownList::EmptyList()
{
    while (NumItems() > 0)
        DeleteItem(m_itemHead.m_pitemNext);
}


// DeleteItem(pitem)
//
// Delete item <pitem> from the list.  Release() is called on its LPUNKNOWN
// (if its not NULL).  The current item is reset so that the next item
// returned by GetNextItem() is the first item in the list (if any).
//
void CUnknownList::DeleteItem(CUnknownItem *pitem)
{
    Delete pitem;
    m_citem--;
    m_pitemCur = &m_itemHead;
}

// takes a cookie and returns the address of the item associated
// with tth cookie.
CUnknownItem *CUnknownList::GetItemFromCookie(DWORD dwCookie)
{
    int i;
    CUnknownItem *pCur;
    if (m_citem > 0)
    {
        pCur = m_itemHead.m_pitemNext;
    }
    for (i = 0; i < m_citem; i++)
    {
        if (pCur->m_dwCookie == dwCookie)
        {
            return pCur;
        }
        pCur = pCur->m_pitemNext;    
    }
    return NULL;
}

// fOK = AddItem(punk)
//
// Add <punk> to the end of the list.  AddRef() is called on <punk> (if it's
// not NULL).  Return TRUE on success, FALSE if out of memory.
//
BOOL CUnknownList::AddItem(LPUNKNOWN punk)
{
    CUnknownItem *pitem = New CUnknownItem(punk, &m_itemHead,
        m_itemHead.m_pitemPrev, m_dwNextCookie);
    m_dwNextCookie++;
    if (pitem == NULL)
        return FALSE;
    m_citem++;
    return TRUE;
}


// fOK = CopyItems(CUnknownList *plistNew)
//
// Copy the items from this list to <plistNew>.  Also, for whichever item is
// the current item in this list (i.e. the item that will be retrieved by
// the next call to GetNextItem()), the duplicate of that item in <plistNew>
// is made the current item in <plistNew>.
//
BOOL CUnknownList::CopyItems(CUnknownList *plistNew)
{
    BOOL            fOK = TRUE;     // function return value
    CUnknownItem *  pitemCur;       // current item in <this>
    LPUNKNOWN       punk;
    CUnknownItem *  pitem;

    // remember what the "current item" (returned by Next() and GetNextItem())
    // is, so we can restore it after we finish walking the list
    pitemCur = m_pitemCur;

    // add each item from this list to <plistNew>
    Reset();
    while (TRUE)
    {
        // get the next item <pitem> from this list, and add it to <plistNew>
        if ((pitem = GetNextItem()) == NULL)
            break;
        punk = pitem->Contents();
        fOK = plistNew->AddItem(punk);
        punk->Release();
        if (!fOK)
            goto EXIT;

        // if <pitem> was the current item in this list before we entered
        // this function, make the newly-created item in <plistNew> be
        // the current item
        if (pitem == pitemCur)
            plistNew->m_pitemCur = plistNew->m_itemHead.m_pitemPrev;
    }

    goto EXIT;

EXIT:

    // restore the previous "current item" pointer
    m_pitemCur = pitemCur;

    return fOK;
}


// plistNew = Clone()
//
// Create and return a duplicate of this list.  Return NULL on out-of-memory.
//
CUnknownList *CUnknownList::Clone()
{
    CUnknownList *  plistNew = NULL; // the clone of this list

    // allocate <plistNew> to be the new list (initially empty)
    if ((plistNew = New CUnknownList) == NULL)
        goto ERR_EXIT;

    // copy items from this list to <plistNew>
    if (!CopyItems(plistNew))
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    if (plistNew != NULL)
        Delete plistNew;
    plistNew = NULL;
    goto EXIT;

EXIT:

    return plistNew;
}


// pitem = GetNextItem()
//
// Returns a pointer to the next item in the list.  NULL is returned if there
// are no more items in the list.
//
//To retrieve the LPUNKNOWN/ stored in this item, call pitem->Contents().
//
CUnknownItem *CUnknownList::GetNextItem()
{
    if (m_pitemCur->m_pitemNext == &m_itemHead)
        return NULL;
    m_pitemCur = m_pitemCur->m_pitemNext;
    return m_pitemCur;
}


// hr = Next(celt, rgelt, pceltFetched)
//
// Identical to IEnumUnknown::Next().
//
STDMETHODIMP CUnknownList::Next(ULONG celt, LPUNKNOWN *rgelt,
    ULONG *pceltFetched)
{
    if (pceltFetched != NULL)
        *pceltFetched = 0;
    while (celt > 0)
    {
        CUnknownItem *pitem = GetNextItem();
        if (pitem == NULL)
            break;
        if (rgelt != NULL)
            *rgelt++ = pitem->Contents();
        celt--;
        if (pceltFetched != NULL)
            (*pceltFetched)++;
    }

    return (celt == 0 ? S_OK : S_FALSE);
}


// hr = Skip(celt)
//
// Identical to IEnumUnknown::Skip().
//
STDMETHODIMP CUnknownList::Skip(ULONG celt)
{
    return Next(celt, NULL, NULL);
}


// hr = Reset()
//
// Identical to IEnumUnknown::Reset().
//
STDMETHODIMP CUnknownList::Reset()
{
    m_pitemCur = &m_itemHead;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unkenum.cpp ===
// unkenum.cpp
//
// Defines CEnumUnknown, which implements a simple ordered list of
// LPUNKNOWNs (by being based on CUnknownList) and which is also
// a lightweight unregistered COM object that implements IEnumUnknown
// (useful for implementing any enumerator that enumerates COM
// objects).
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//

#include "precomp.h"
#include "unklist.h"
#include "unkenum.h"


//////////////////////////////////////////////////////////////////////////////
// Construction & Destruction
//
// In the constructor, <riid> is the IID that the object will consider its
// own (e.g. this could be IID_IEnumUnknown, IID_IEnumConnectionPoints, etc.).
//

CEnumUnknown::CEnumUnknown(REFIID riid)
{
    m_cRef = 1;
    m_iid = riid;
}

CEnumUnknown::~CEnumUnknown()
{
    EmptyList();
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Methods
//

STDMETHODIMP CEnumUnknown::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, m_iid))
    {
        *ppvObj = (IEnumUnknown *) this;
        AddRef();
        return NOERROR;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CEnumUnknown::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEnumUnknown::Release()
{
    if (--m_cRef == 0L)
    {
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


//////////////////////////////////////////////////////////////////////////////
// IEnumUnknown Methods
//

STDMETHODIMP CEnumUnknown::Next(ULONG celt, IUnknown **rgelt,
    ULONG *pceltFetched)
{
    return CUnknownList::Next(celt, rgelt, pceltFetched);
}

STDMETHODIMP CEnumUnknown::Skip(ULONG celt)
{
    return CUnknownList::Skip(celt);
}

STDMETHODIMP CEnumUnknown::Reset()
{
    return CUnknownList::Reset();
}

STDMETHODIMP CEnumUnknown::Clone(IEnumUnknown **ppenum)
{
    CEnumUnknown *penum = NULL;

    // make <penum> be a new CEnumUnknown with the same attributes
    // as this object
    if ((penum = New CEnumUnknown(m_iid)) == NULL)
        goto ERR_OUTOFMEMORY;

    // copy the list of LPUNKNOWNs from this object to <penum>
    if (!CopyItems(penum))
        goto ERR_OUTOFMEMORY;

    // return <penum>
    *ppenum = penum;

    return S_OK;

ERR_OUTOFMEMORY:

    if (penum != NULL)
        Delete penum;

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unklist.h ===
// unklist.h
//
// Defines CUnknownList, which maintains a simple ordered list of LPUNKNOWNs.
//

struct CUnknownItem
{
///// object state
    LPUNKNOWN       m_punk;         // the AddRef'd LPUNKNOWN of this item
    CUnknownItem *  m_pitemNext;    // next item in the list
    CUnknownItem *  m_pitemPrev;    // previous item in the list
    DWORD           m_dwCookie;     // the cookie that will be used for this item
///// object operations
    CUnknownItem(LPUNKNOWN punk, CUnknownItem *pitemNext,
        CUnknownItem *pitemPrev, DWORD dwCookie);
    ~CUnknownItem();
    LPUNKNOWN Contents();
};

struct CUnknownList
{
///// object state
    CUnknownItem     m_itemHead;     // m_itemHead.Next() is first item in list
    CUnknownItem *   m_pitemCur;     // current item in list
    int              m_citem;        // number of items in list
    DWORD            m_dwNextCookie;

///// object operations
    CUnknownList();
    ~CUnknownList();
    int NumItems() { return m_citem; }
    CUnknownItem *LastItemAdded() { return m_itemHead.m_pitemPrev; }
    DWORD LastCookieAdded() { return (m_itemHead.m_pitemPrev)->m_dwCookie; }
    void EmptyList();
    void DeleteItem(CUnknownItem *pitem);
    CUnknownItem *GetItemFromCookie(DWORD dwCookie);
    BOOL AddItem(LPUNKNOWN punk);
    BOOL CopyItems(CUnknownList *plistNew);
    CUnknownList *Clone();
    CUnknownItem *GetNextItem();
    STDMETHODIMP Next(ULONG celt, IUnknown **rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unkenum.h ===
// unkenum.h
//
// Defines CEnumUnknown, which implements a simple ordered list of
// LPUNKNOWNs (by being based on CUnknownList) and which is also
// a lightweight unregistered COM object that implements IEnumUnknown
// (useful for implementing any enumerator that enumerates COM
// objects).
//

struct CEnumUnknown : CUnknownList, IEnumUnknown
{
///// object state
    ULONG           m_cRef;         // object reference count
    IID             m_iid;          // interface ID of this object

///// construction & destruction
    CEnumUnknown(REFIID riid);
    ~CEnumUnknown();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IEnumUnknown methods
    STDMETHODIMP Next(ULONG celt, IUnknown **rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumUnknown **ppenum);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\vpc.cpp ===
// vpc.cpp
//
// Implements VariantPropertyClear.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func void | VariantPropertyClear |

        Frees data maintained in a <t VariantProperty> structure.

@parm   VariantProperty * | pvp | The structure to clear.

@comm   This function calls <f SysFreeString> on <p pvp>-<gt><p bstrPropName>
        and <f VariantClear> on <p pvp>-<gt><p varValue>.

        Unlike <f VariantPropertyInit>, this function <b does> assume
        that <p pvp> was correctly initialized before this function
        was called.
*/
STDAPI_(void) VariantPropertyClear(VariantProperty *pvp)
{
    SysFreeString(pvp->bstrPropName);
	pvp->bstrPropName = NULL;
    VariantClear(&pvp->varValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\urlmon.cpp ===
/****************************************************************************\
	urlmon.cpp - Wrappers for URLMON functions

	This code is part of ochelp.dll.
	The Netscape plugin runs without urlmon.dll. It implements a subset
	of URLMON's functions. The MM Controls all call through these wrappers
	instead of directly calling into urlmon.dll.
	We need to detect whether we're running in the context of IE or
	Navigator and load urlmon.dll or NPHost.dll accordingly.
	In order to detect the Netscape case, we call the FInitCheck()
	entrypoint in NPHost.dll. If the DLL isn't available or the
	call fails, we know we're not running Navigator.
	Finally, we clean up in _DllMainCrtStartup.

	Copyright (c) 1997 Microsoft Corp. All rights reserved.
\****************************************************************************/

#include "precomp.h"
#include <urlmon.h>			// for IBindHost
#include "..\..\inc\ochelp.h"
#include "debug.h"

HINSTANCE hinstUrlmon = NULL;

typedef HRESULT (STDAPICALLTYPE *PFN_CREATEASYNCBINDCTX)(DWORD, IBindStatusCallback *, IEnumFORMATETC *, IBindCtx **);
typedef HRESULT (STDAPICALLTYPE *PFN_CREATEURLMONIKER)(LPMONIKER, LPCWSTR, LPMONIKER FAR *);
typedef HRESULT (STDAPICALLTYPE *PFN_MKPARSEDISPLAYNAMEEX)(IBindCtx *, LPCWSTR, ULONG *, LPMONIKER *);
typedef HRESULT (STDAPICALLTYPE *PFN_REGISTERBINDSTATUSCALLBACK)(LPBC, IBindStatusCallback *, IBindStatusCallback**, DWORD);
typedef HRESULT (STDAPICALLTYPE *PFN_REVOKEBINDSTATUSCALLBACK)(LPBC, IBindStatusCallback *);
typedef HRESULT (STDAPICALLTYPE *PFN_URLOPENSTREAMA)(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
typedef HRESULT (STDAPICALLTYPE *PFN_URLDOWNLOADTOCACHEFILEA)(LPUNKNOWN,LPCSTR,LPTSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
typedef BOOL	(STDAPICALLTYPE *PFN_FINITCHECK)();

PFN_CREATEASYNCBINDCTX			pfnCreateAsyncBindCtx;
PFN_CREATEURLMONIKER			pfnCreateURLMoniker;
PFN_MKPARSEDISPLAYNAMEEX		pfnMkParseDisplayNameEx;
PFN_REGISTERBINDSTATUSCALLBACK	pfnRegisterBindStatusCallback;
PFN_REVOKEBINDSTATUSCALLBACK	pfnRevokeBindStatusCallback;
PFN_URLOPENSTREAMA				pfnURLOpenStreamA;
PFN_URLDOWNLOADTOCACHEFILEA		pfnURLDownloadToCacheFileA;
PFN_FINITCHECK					pfnFInitCheck;

// These references must be the same in urlmon.dll and nphost.dll.
// Use strings rather than ordinals just to be safe.
const LPCSTR szCreateAsyncBindCtx =			(LPCSTR)"CreateAsyncBindCtx";		//0x0003;	note collision in NPHost
const LPCSTR szCreateURLMoniker =			(LPCSTR)"CreateURLMoniker";			//0x0006;
const LPCSTR szMkParseDisplayNameEx =		(LPCSTR)"MkParseDisplayNameEx";		//0x0019;
const LPCSTR szRegisterBindStatusCallback =	(LPCSTR)"RegisterBindStatusCallback";//0x001A;
const LPCSTR szRevokeBindStatusCallback =	(LPCSTR)"RevokeBindStatusCallback";	//0x001E;
const LPCSTR szURLDownloadToCacheFileA =	(LPCSTR)"URLDownloadToCacheFileA";	//0x0021;
const LPCSTR szURLOpenStreamA =				(LPCSTR)"URLOpenStreamA";			//0x002A;

// This function is only in nphost.dll.
const LPCSTR szFInitCheck =					(LPCSTR)"FInitCheck";

void CleanupUrlmonStubs()
{
	if (hinstUrlmon)
	{
		FreeLibrary(hinstUrlmon);
		hinstUrlmon = NULL;
	}
}

// Really initialize the function pointers.
BOOL FInitStubs()
{
	if (hinstUrlmon)
	{
		// Error: this means the pointers are NULL but we've already loaded a DLL.
		ASSERT(FALSE);
		return FALSE;
	}

	if ((hinstUrlmon = LoadLibrary("nphost.dll")) != NULL)
	{
		// We found nphost.dll. Make sure it's already been
		// initialized by Netscape.

		pfnFInitCheck = (PFN_FINITCHECK)GetProcAddress(hinstUrlmon, szFInitCheck);
		if (pfnFInitCheck && pfnFInitCheck())
		{
#if defined(_DEBUG) || defined(_DESIGN)
			::OutputDebugString("Using NPHOST.DLL instead of URLMON.DLL\n");
#endif
		}
		else
		{
			FreeLibrary(hinstUrlmon);
			hinstUrlmon = NULL;
		}
	
	}

	if (!hinstUrlmon)
	{
		hinstUrlmon = LoadLibrary("urlmon.dll");
		if (hinstUrlmon == NULL)
		{
			// We already checked this at init time so it should succeed here.
			ASSERT(FALSE);
			return FALSE;
		}
	}

	pfnCreateAsyncBindCtx =			(PFN_CREATEASYNCBINDCTX)		GetProcAddress(hinstUrlmon, szCreateAsyncBindCtx);
	pfnCreateURLMoniker =			(PFN_CREATEURLMONIKER)			GetProcAddress(hinstUrlmon, szCreateURLMoniker);
	pfnMkParseDisplayNameEx =		(PFN_MKPARSEDISPLAYNAMEEX)		GetProcAddress(hinstUrlmon, szMkParseDisplayNameEx );
	pfnRegisterBindStatusCallback =	(PFN_REGISTERBINDSTATUSCALLBACK)GetProcAddress(hinstUrlmon, szRegisterBindStatusCallback);
	pfnRevokeBindStatusCallback =	(PFN_REVOKEBINDSTATUSCALLBACK)	GetProcAddress(hinstUrlmon, szRevokeBindStatusCallback);
	pfnURLOpenStreamA =				(PFN_URLOPENSTREAMA)			GetProcAddress(hinstUrlmon, szURLOpenStreamA);
	pfnURLDownloadToCacheFileA =	(PFN_URLDOWNLOADTOCACHEFILEA)	GetProcAddress(hinstUrlmon, szURLDownloadToCacheFileA);

	if (!pfnCreateAsyncBindCtx			||
		!pfnMkParseDisplayNameEx		||
		!pfnRegisterBindStatusCallback	||
		!pfnRevokeBindStatusCallback	||
		!pfnURLOpenStreamA				||
		!pfnURLDownloadToCacheFileA)
	{
		CleanupUrlmonStubs();
		return FALSE;
	}

	return TRUE;
}


STDAPI HelpCreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEFetc, IBindCtx **ppBC)
{
	if (!pfnCreateAsyncBindCtx && !FInitStubs())
		return E_UNEXPECTED;

	return pfnCreateAsyncBindCtx(reserved, pBSCb, pEFetc, ppBC);
}

STDAPI HelpCreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk)
{
	if (!pfnCreateURLMoniker && !FInitStubs())
		return E_UNEXPECTED;

	return pfnCreateURLMoniker(pMkCtx, szURL, ppmk);
}

STDAPI HelpMkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten, LPMONIKER *ppmk)
{
	if (!pfnMkParseDisplayNameEx && !FInitStubs())
		return E_UNEXPECTED;

	return pfnMkParseDisplayNameEx(pbc, szDisplayName, pchEaten, ppmk);
}

STDAPI HelpRegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback** ppBSCBPrev, DWORD dwReserved)
{
	if (!pfnRegisterBindStatusCallback && !FInitStubs())
		return E_UNEXPECTED;

	return pfnRegisterBindStatusCallback(pBC, pBSCb, ppBSCBPrev, dwReserved);
}

STDAPI HelpRevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb)
{
	if (!pfnRevokeBindStatusCallback && !FInitStubs())
		return E_UNEXPECTED;

	return pfnRevokeBindStatusCallback(pBC, pBSCb);
}

STDAPI HelpURLOpenStreamA(LPUNKNOWN punk, LPCSTR szURL, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc)
{
	if (!pfnURLOpenStreamA && !FInitStubs())
		return E_UNEXPECTED;

	return pfnURLOpenStreamA(punk, szURL, dwReserved, pbsc);
}

STDAPI HelpURLDownloadToCacheFileA(LPUNKNOWN punk, LPCSTR szURL, LPTSTR szFile, DWORD cch, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc)
{
	if (!pfnURLDownloadToCacheFileA && !FInitStubs())
		return E_UNEXPECTED;

	return pfnURLDownloadToCacheFileA(punk, szURL, szFile, cch, dwReserved, pbsc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\wvp.cpp ===
// wvp.cpp
//
// Implements WriteVariantProperty.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | WriteVariantProperty |

        Writes a <t VariantProperty> to an <i IStream> in a simple tagged
        binary format.

@parm   IStream * | pstream | The stream to write to.

@parm   VariantProperty * | pvp | The property name/value pair to write.
        If <p pvp> is NULL, then this function writes a VariantPropertyHeader
        containing <p iType>==-1 and <p cbData>==0 to mark the end of the
        stream.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   See <t VariantPropertyHeader> for a description of the format of
        the data written to <p pstream> by this function.
*/
STDAPI WriteVariantProperty(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    unsigned int    cchPropName;    // no. wide characters in property name
    VARIANT         varValue;       // the property value (as a string)
    unsigned int    cchValue;       // no. wide characters in <varValue>
    VariantPropertyHeader vph;      // header of record to write out

    // ensure correct cleanup
    VariantInit(&varValue);

    // initialize <vbh> to be the header to write out
    if (pvp == NULL)
    {
        vph.iType = -1;
        vph.cbData = 0;
    }
    else
    {
        // set <cchPropName> to the length of the property name
        cchPropName = SysStringLen(pvp->bstrPropName);

        // set <varValue.bstrVal> (and length <cchValue>) the value of <*pvp>
        // coerced to a string
        if (FAILED(hrReturn = VariantChangeType(&varValue, &pvp->varValue, 0,
                VT_BSTR)))
            goto ERR_EXIT;
        cchValue = SysStringLen(varValue.bstrVal);

        // initialize the record header
        vph.iType = pvp->varValue.vt;
        vph.cbData = sizeof(cchPropName) + cchPropName * sizeof(OLECHAR) +
            sizeof(cchValue) + cchValue * sizeof(OLECHAR);
    }

    // write out a VariantPropertyHeader
    if (FAILED(hrReturn = pstream->Write(&vph, sizeof(vph), NULL)))
        goto ERR_EXIT;

    if (pvp != NULL)
    {
        // write out the property name
        if (FAILED(hrReturn = pstream->Write(&cchPropName, sizeof(cchPropName),
                NULL)))
            goto ERR_EXIT;
        if (FAILED(hrReturn = pstream->Write(pvp->bstrPropName,
                cchPropName * sizeof(OLECHAR), NULL)))
            goto ERR_EXIT;

        // write out the property value
        if (FAILED(hrReturn = pstream->Write(&cchValue, sizeof(cchValue),
                NULL)))
            goto ERR_EXIT;
        if (FAILED(hrReturn = pstream->Write(varValue.bstrVal,
                cchValue * sizeof(OLECHAR), NULL)))
            goto ERR_EXIT;
    }

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    VariantClear(&varValue);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\vpi.cpp ===
// vpi.cpp
//
// Implements VariantPropertyInit.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func void | VariantPropertyInit |

        Initializes a <t VariantProperty> structure.

@parm   VariantProperty * | pvp | The structure to initialize.

@comm   Unlike <f VariantPropertyClear>, this function does not assume
        that <p pvp> contained valid data on entry.
*/
STDAPI_(void) VariantPropertyInit(VariantProperty *pvp)
{
    memset(pvp, 0, sizeof(*pvp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\actq.h ===
/*-----------------------------------------------------------------------------
@doc
@module actq.h | Action queue class declarations.
@author 2-18-97 | pauld | Created
-----------------------------------------------------------------------------*/

#ifndef _ACTQ_H__
#define _ACTQ_H__

class CAction;

struct CActionQueueItem
{
	CActionQueueItem (CAction * pcAction, DWORD dwTimeToFire)
		{Proclaim (NULL != pcAction); m_pcAction = pcAction; m_dwTimeToFire = dwTimeToFire;}

	CAction * m_pcAction;
	DWORD m_dwTimeToFire;
};

typedef CPtrDrg<CActionQueueItem> CActionQueueItemDrg;

class CActionQueue
{

 public :

	CActionQueue (void);
	~CActionQueue (void);

	HRESULT Add (CAction * pcAction, DWORD dwNextAdviseTime);
	HRESULT Execute (DWORD dwBaseTime, DWORD dwCurrentTime);

 protected :

	HRESULT AddNewItemToQueue (CActionQueueItem * pcNewQueueItem);
	CActionQueueItemDrg m_cdrgActionsToFire;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\actq.cpp ===
/*-----------------------------------------------------------------------------
@doc
@module actq.cpp | Action set class declarations.
@author 12-9-96 | pauld | Autodoc'd
-----------------------------------------------------------------------------*/

#include "..\ihbase\precomp.h"
#include "memlayer.h"
#include "..\ihbase\debug.h"
#include "debug.h"
#include "drg.h"
#include "strwrap.h"
#include "caction.h"
#include "actq.h"

/*-----------------------------------------------------------------------------
@method | CActionQueue | CActionQueue | Constructor
-----------------------------------------------------------------------------*/
CActionQueue::CActionQueue (void)
{
}

/*-----------------------------------------------------------------------------
@method | CActionQueue | ~CActionQueue | Destructor
-----------------------------------------------------------------------------*/
CActionQueue::~CActionQueue (void)
{
}


/*-----------------------------------------------------------------------------
@method | CActionQueue | AddNewItemToQueue | Adds an action to the list, sorted first by time, then by tiebreak.
@rdesc	Success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionQueue::AddNewItemToQueue (CActionQueueItem * pcNewQueueItem)
{
	HRESULT hr = E_FAIL;
	int iCount = m_cdrgActionsToFire.Count();

	Proclaim(NULL != pcNewQueueItem);
	Proclaim(NULL != pcNewQueueItem->m_pcAction);
	if ((NULL != pcNewQueueItem) && (NULL != pcNewQueueItem->m_pcAction))
	{
		CAction * pcNewAction = pcNewQueueItem->m_pcAction;

		for (register int i = 0; i < iCount; i++)
		{
			CActionQueueItem * pcItemInQueue = m_cdrgActionsToFire[i];
			Proclaim(NULL != pcItemInQueue);
			Proclaim(NULL != pcItemInQueue->m_pcAction);
			if ((NULL != pcItemInQueue) && (NULL != pcItemInQueue->m_pcAction))
			{
				CAction * pcActionInQueue = pcItemInQueue->m_pcAction;
				// First sort by time.
				// Next look at tiebreak numbers.
				if ((pcNewQueueItem->m_dwTimeToFire < pcItemInQueue->m_dwTimeToFire) ||
					 (pcNewAction->GetTieBreakNumber() < pcActionInQueue->GetTieBreakNumber()))
				{
					if (m_cdrgActionsToFire.Insert(pcNewQueueItem, i))
					{
						hr = S_OK;
					}
					break;
				}
			}
			else
			{
				break;
			}
		}

		// It goes last in the queue.
		if (iCount == i)
		{
			if (m_cdrgActionsToFire.Insert(pcNewQueueItem))
			{
				hr = S_OK;
			}
		}
	}

	return hr;
}

/*-----------------------------------------------------------------------------
@method | CActionQueue | Add | Adds an action to the list, sorted first by time, then by tiebreak.
@rdesc	Success or failure code.
-----------------------------------------------------------------------------*/
HRESULT 
CActionQueue::Add (CAction * pcAction, DWORD dwTimeToFire)
{
	HRESULT hr = E_FAIL;

	Proclaim(NULL != pcAction);
	if ((NULL != pcAction) && (pcAction->IsValid()))
	{
		CActionQueueItem * pcNewQueueItem = New CActionQueueItem(pcAction, dwTimeToFire);

		Proclaim(NULL != pcNewQueueItem);
		if (NULL != pcNewQueueItem) 
		{
			hr = AddNewItemToQueue(pcNewQueueItem);
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method | CActionQueue | Execute | Execute all of the actions in the list.
@comm We do not currently report failures from Invoke.  Failure only occurs when the list items are munged.
@rdesc	Success or failure code.  
-----------------------------------------------------------------------------*/
HRESULT 
CActionQueue::Execute (DWORD dwBaseTime, DWORD dwCurrentTime)
{
	HRESULT hr = S_OK;
	int iCount = m_cdrgActionsToFire.Count();

#ifdef DEBUG_TIMER_QUEUE
	TCHAR szBuffer[0x100];
	CStringWrapper::Sprintf(szBuffer, "Firing %d actions\n", iCount);
	::OutputDebugString(szBuffer);
#endif

	for (register int i = 0; i < iCount; i++)
	{
		CActionQueueItem * pcQueueItem = m_cdrgActionsToFire[0];

		// The pointer will be NULL only when the queue is munged.
		// We want to bail out immediately.
		Proclaim(NULL != pcQueueItem);
		Proclaim(NULL != pcQueueItem->m_pcAction);
		if ((NULL != pcQueueItem) && (NULL != pcQueueItem->m_pcAction))
		{
			// We do not report errors on individual action invokes.
			pcQueueItem->m_pcAction->FireMe(dwBaseTime, dwCurrentTime);
			// Remove the item from the queue, and delete the timing wrapper.
			m_cdrgActionsToFire.Remove(0);
			Delete pcQueueItem;
		}
		else
		{
			hr = E_FAIL;
			break;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\caction.h ===
//	IHammer CAction class definition
//	Van Kichline

#ifndef _CACTION_H_
#define _CACTION_H_

#include "utils.h"

interface IHTMLWindow2;
class CActionSet;

//	Represents an automation object and method.
//
class CAction
{
public:
	CAction (BOOL fBindEngine);
	virtual	~CAction ();

    STDMETHODIMP_( void ) Destroy( void );

	STDMETHODIMP_(BOOL) SetScriptletName (BSTR bstrScriptlet);
	STDMETHODIMP_( ULONG ) GetStartTime ( void )				{ return m_nStartTime; }
	STDMETHODIMP_( void	 ) SetStartTime ( ULONG nStartTime );

	STDMETHODIMP_( ULONG ) GetRepeatCount ( void )	{ return m_nRepeatCount; }
	STDMETHODIMP_( void  ) SetRepeatCount ( ULONG nRepeatCount);
	STDMETHODIMP_( ULONG ) GetSamplingRate ( void )	{ return m_nSamplingRate; }
	STDMETHODIMP_( void  ) SetSamplingRate ( ULONG nSamplingRate);

	STDMETHODIMP ResolveActionInfo ( LPOLECONTAINER piocContainer);
	STDMETHODIMP FireMe ( DWORD dwBaseTime, DWORD dwCurrentTime);
	DWORD GetNextTimeDue (DWORD dwBaseTime);
	ULONG GetExecIteration (void);
	ULONG InitExecState (void);
	void SetCountersForTime (DWORD dwBaseTime, DWORD dwNewTimeOffset);
	void AccountForPauseTime (DWORD dwPausedTicks);

	// Is the action fully specified?
	STDMETHODIMP_( BOOL	) IsValid ();

	// Do we have an active advise sink?
	STDMETHODIMP_( BOOL) IsBusy (void);

	STDMETHODIMP IsActive (void);

	STDMETHODIMP_( DWORD) GetTieBreakNumber	( void )		{ return m_dwTieBreakNumber; }
	STDMETHODIMP_( void ) SetTieBreakNumber	( DWORD dwTieBreakNumber ) { m_dwTieBreakNumber = dwTieBreakNumber; }
	STDMETHODIMP_( DWORD) GetDropTolerance	( void )		{ return m_dwDropTolerance; }
	STDMETHODIMP_( void ) SetDropTolerance	( DWORD dwDropTolerance ) { m_dwDropTolerance = dwDropTolerance; }

#ifdef DEBUG_TIMER_RESOLUTION
	void	SampleInvokes (PDWORD pdwInvokeTime, PDWORD pdwNumInvokes)
		{ *pdwInvokeTime = m_dwTotalInInvokes; *pdwNumInvokes = m_dwInvokes; }
#endif // DEBUG_TIMER_RESOLUTION

protected:

	void			CleanUp ( void );
	ULONG			DecrementExecIteration (void);

private:
	HRESULT         GetRootUnknownForObjectModel (LPOLECONTAINER piocContainer, LPUNKNOWN * ppiunkRoot);
	HRESULT         ResolveActionInfoForScript (LPOLECONTAINER piocContainer);
	BOOL MakeScriptletJScript (BSTR bstrScriptlet);
	void Deactivate (void);

	BSTR m_bstrScriptlet;

	BOOL m_fBindEngine;

	IHTMLWindow2 *  m_piHTMLWindow2; // Reference to the window object - we use this to get to the script engine.
	VARIANT m_varLanguage;	// Holds the language string we pump to the script engine.
	IDispatch		*m_pid;				// Pointer to the XObject or the control
	DISPID			m_dispid;			// DISPID of the selected command
	ULONG			m_nStartTime;		// Offset in time to start of action
	ULONG			m_nSamplingRate;	// At what frequency do we repeat?
	ULONG			m_nRepeatCount;		// How many times do we repeat?

	DWORD m_dwLastTimeFired;
	DWORD m_dwNextTimeDue;
	DWORD			m_dwTieBreakNumber;	// Resolves execution collision issues.  When two
										// actions are due to fire at the same time, the higher
										// tiebreak number wins.
	DWORD			m_dwDropTolerance;  // How many milliseconds can we delay executing this action beyond it's
	                                    // proper firing time before we have to drop it?
	ULONG			m_ulExecIteration;	// How many times have we executed this action?

#ifdef DEBUG_TIMER_RESOLUTION
	DWORD m_dwInvokes;
	DWORD m_dwTotalInInvokes;
#endif // DEBUG_TIMER_RESOLUTION

};

#endif _CACTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\cactset.cpp ===
/*-----------------------------------------------------------------------------
@doc
@module cactset.cpp | Action set class declarations.
@author 12-9-96 | pauld | Autodoc'd
-----------------------------------------------------------------------------*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include <ocmm.h>
#include <htmlfilter.h>
#include "tchar.h"
#include "IHammer.h"
#include "drg.h"
#include "strwrap.h"
#include "actdata.h"
#include "actq.h"
#include "ochelp.h"
#include "seqctl.h"
#include "cactset.h"
#include "CAction.h"

#define cDataBufferDefaultLength    (0x100)
#define cMinimumTimerGranularity (20)
static const int	knStreamVersNum	= 0xA1C50001;	// Version number of stream format

/*-----------------------------------------------------------------------------
@method void | CActionSet | CActionSet | Like it's the Ctor.
@comm   We don't add a reference to this IUnknown since it's the IUnknown of
        the sequencer which contains us. If we did ad a ref we'd have a circular
		ref counting problem. MAKE SURE that this IUnknown is the same one you
		get as when you sequencer->QueryInterface( IUnknown )
-----------------------------------------------------------------------------*/
CActionSet::CActionSet (CMMSeq * pcSeq, BOOL fBindToEngine)
{
	m_ulRefs = 1;
	m_fBindToEngine = fBindToEngine;
	// Weak reference to the control that contain this class.
	m_pcSeq = pcSeq;
	InitTimerMembers();
#ifdef DEBUG_TIMER_RESOLUTION
	m_dwTotalIntervals = 0;
	m_dwIntervals = 0;
	m_dwLastTime = 0;
	m_dwTotalInSink = 0;
#endif
}


CActionSet::~CActionSet ( void )
{
	Clear ();
}

STDMETHODIMP
CActionSet::QueryInterface (REFIID riid, LPVOID * ppv)
{
	HRESULT hr = E_POINTER;

	if (NULL != ppv)
	{
		hr = E_NOINTERFACE;
		if (::IsEqualIID(riid, IID_ITimerSink) || (::IsEqualIID(riid, IID_IUnknown)))
		{
			*ppv = (ITimerSink *)this;
			AddRef();
			hr  = S_OK;
		}
	}

	return hr;
}

STDMETHODIMP_(ULONG)
CActionSet::AddRef (void)
{
	return ++m_ulRefs;
}

STDMETHODIMP_(ULONG)
CActionSet::Release (void)
{
	// We shouldn't ever dip below a refcount of 1.
	Proclaim (1 < m_ulRefs);
	// This object is only used as a timer sink ... we do not 
	// want to delete it after the last external reference 
	// is removed.
	return --m_ulRefs;
}

/*-----------------------------------------------------------------------------
@method void | CActionSet | InitTimerMembers | Initialize all timer-related members.
@comm	Use ClearTimer() to release a timer reference.  We merely NULL the pointer here.
-----------------------------------------------------------------------------*/
void
CActionSet::InitTimerMembers (void)
{
	m_piTimer = NULL;
	m_dwBaseTime = 0;
	m_dwTimerCookie = 0;
	m_fAdvised = FALSE;
	m_fPendingAdvise = FALSE;
	m_dwTimePaused = g_dwTimeInfinite;
	m_fIgnoreAdvises  = FALSE;
}

/*-----------------------------------------------------------------------------
@method void | CActionSet | ClearTimer | Clear the timer.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CActionSet::ClearTimer (void)
{
	// Let go of the timer.
	if (NULL != m_piTimer)
	{
		if (IsBusy())
		{
			Unadvise();
		}
		m_piTimer->Release();
		m_piTimer = NULL;
	}
}


/*-----------------------------------------------------------------------------
@method void | CActionSet | SetTimer | Set the timer.
@comm	The timer value can be NULL.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CActionSet::SetTimer (ITimer * piTimer)
{
	// Let go of the previous timer.
	ClearTimer();
	m_piTimer = piTimer;
	if (NULL != m_piTimer)
	{
		m_piTimer->AddRef();
	}
}


/*-----------------------------------------------------------------------------
@method DWORD | CActionSet | EvaluateOneActionForFiring | Determine which actions are due now 
                                                          and when to request the next advise.
@rdesc Returns the next time (after now that is) this action is due to fire.
-----------------------------------------------------------------------------*/
DWORD
CActionSet::EvaluateOneActionForFiring (CAction * pcAction, CActionQueue * pcFireList, DWORD dwCurrentTime)
{
	DWORD dwNextAdviseTime = pcAction->GetNextTimeDue(m_dwBaseTime);
	ULONG ulRepeatsLeft = pcAction->GetExecIteration();

	// If this action is due, add it to the firing list.
	while ((0 < ulRepeatsLeft) && (dwNextAdviseTime <= dwCurrentTime))
	{
		pcFireList->Add(pcAction, dwNextAdviseTime);
		// Is this a periodic action with iterations remaining?
		if (1 < ulRepeatsLeft)
		{
			dwNextAdviseTime += pcAction->GetSamplingRate();
			ulRepeatsLeft--;
		}
		else
		{
			dwNextAdviseTime = g_dwTimeInfinite;
		}
	}

	return dwNextAdviseTime;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | EvaluateActionsForFiring | Determine which actions are due now 
                                                          and when to request the next advise.
@rdesc Returns success or error value.  An error occurs when the action set is munged.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::EvaluateActionsForFiring (CActionQueue * pcFireList, DWORD dwCurrentTime, DWORD * pdwNextAdviseTime)
{
	HRESULT hr = S_OK;
	int iNumActions = m_cdrgActions.Count();

	// We assume the pointer is valid as this is called internally.
	*pdwNextAdviseTime = g_dwTimeInfinite;
	for (register int i = 0; i < iNumActions; i++)
	{
		CAction * pcAction = (CAction *)m_cdrgActions[i];

		Proclaim(NULL != pcAction);
		if (NULL != pcAction)
		{
			// Puts the action into the fire list if appropriate.
			DWORD dwLookaheadFireTime = EvaluateOneActionForFiring(pcAction, pcFireList, dwCurrentTime);
			if (dwLookaheadFireTime < (*pdwNextAdviseTime))
			{
				*pdwNextAdviseTime = dwLookaheadFireTime;
			}
		}
		else
		{
			hr = E_FAIL;
			break;
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Advise | Set up the next advise.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::Advise (DWORD dwNextAdviseTime)
{
	HRESULT hr = E_FAIL;

	Proclaim(NULL != m_piTimer);
	if (NULL != m_piTimer)
	{
		VARIANT varTimeAdvise;
		VARIANT varTimeMax;
		VARIANT varTimeInterval;

		VariantInit(&varTimeAdvise);
		V_VT(&varTimeAdvise) = VT_UI4;
		V_UI4(&varTimeAdvise) = dwNextAdviseTime;
		VariantInit(&varTimeMax);
		V_VT(&varTimeMax) = VT_UI4;
		V_UI4(&varTimeMax) = 0;
		VariantInit(&varTimeInterval);
		V_VT(&varTimeInterval) = VT_UI4;
		V_UI4(&varTimeInterval) = 0;

		hr = m_piTimer->Advise(varTimeAdvise, varTimeMax, varTimeInterval, 0, (ITimerSink *)this, &m_dwTimerCookie);
		Proclaim(SUCCEEDED(hr));
		if (SUCCEEDED(hr))
		{
			m_fAdvised = TRUE;
		}

#ifdef DEBUG_TIMER_ADVISE
		TCHAR szBuffer[0x100];
		CStringWrapper::Sprintf(szBuffer, "%p Advising %u (%u)\n", this, dwNextAdviseTime - m_dwBaseTime, hr);
		::OutputDebugString(szBuffer);
#endif
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Unadvise | Cancel any pending advises.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::Unadvise (void)
{
	HRESULT hr = E_FAIL;

	// Short circuit any pending advises.
	m_fPendingAdvise = FALSE;

	// Wipe out the outstanding advise.
	Proclaim(NULL != m_piTimer);
	if (NULL != m_piTimer)
	{
		if (m_fAdvised)
		{
			Proclaim(0 != m_dwTimerCookie);
			hr = m_piTimer->Unadvise(m_dwTimerCookie);
			m_dwTimerCookie = 0;
			m_fAdvised = FALSE;
		}
		else
		{
			hr = S_OK;
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | GetCurrentTickCount | Get the current time from our timer.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::GetCurrentTickCount (PDWORD pdwCurrentTime)
{
	HRESULT hr = E_FAIL;
	Proclaim(NULL != pdwCurrentTime);
	if (NULL != pdwCurrentTime)
	{
		Proclaim(NULL != m_piTimer);
		if (NULL != m_piTimer)
		{
			VARIANT varTime;
			VariantInit(&varTime);
			HRESULT hrTimer = m_piTimer->GetTime(&varTime);
			Proclaim(SUCCEEDED(hrTimer) && (VT_UI4 == V_VT(&varTime)));
			if (SUCCEEDED(hrTimer) && (VT_UI4 == V_VT(&varTime)))
			{
				*pdwCurrentTime = V_UI4(&varTime);
				hr = S_OK;
			}
		}
	}
	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | PlayNowAndAdviseNext | Play current actions, set next advise.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::PlayNowAndAdviseNext (DWORD dwCurrentTime)
{
	HRESULT hr = S_OK;
	DWORD dwNextAdviseTime = g_dwTimeInfinite;
	CActionQueue cFireList;

	// Clear the advised flag.
	m_fAdvised = FALSE;

	// If the action is due to fire, insert it into the fire list, sorted 
	// according to time/tiebreak number.  Find out the next time we
	// need to request an advise.
	hr = EvaluateActionsForFiring(&cFireList, dwCurrentTime, &dwNextAdviseTime);
	Proclaim(SUCCEEDED(hr));

	// What time is it now?
	if (SUCCEEDED(hr))
	{
		Proclaim(NULL != m_piTimer);
		if (NULL != m_piTimer)
		{
			hr = GetCurrentTickCount(&dwCurrentTime);
			Proclaim(SUCCEEDED(hr));
		}
	}

	// Flag the pending advise call.
	if (SUCCEEDED(hr))
	{
		if (g_dwTimeInfinite != dwNextAdviseTime)
		{
			m_fPendingAdvise = TRUE;
		}
	}

	// Fire the current list.
	if (SUCCEEDED(hr))
	{
		hr = cFireList.Execute(m_dwBaseTime, dwCurrentTime);
		Proclaim(SUCCEEDED(hr));
	}

	// Set up the next advise.  If there's something 
	// wrong with the action set, quit playing and return 
	// an error.
	if (SUCCEEDED(hr))
	{
		if (m_fPendingAdvise)
		{
			m_fPendingAdvise = FALSE;
			hr = Advise(dwNextAdviseTime);
			Proclaim(SUCCEEDED(hr));
		}
#ifdef DEBUG_TIMER_RESOLUTION
		else
		{
			ShowSamplingData();
		}
#endif
	}
	else
	{
		Stop();
	}

	// If we don't have another advise pending, tell the control to 
	// fire its stopped event.
	if (!IsBusy())
	{
		Proclaim(NULL != m_pcSeq);
		if (NULL != m_pcSeq)
		{
			m_pcSeq->NotifyStopped();
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method void | CActionSet | SetBaseTime | Set the baseline time. 
@comm	This is the time at which we last started to play these actions.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
void
CActionSet::SetBaseTime (void)
{
	// What's the point without a timer?
	Proclaim (NULL != m_piTimer);
	if (NULL != m_piTimer)
	{
		GetCurrentTickCount(&m_dwBaseTime);
	}
}


/*-----------------------------------------------------------------------------
@method void | CActionSet | SetBaseTime | Set the baseline time to account for a new offset. 
@comm	This is the time at which we last started to play these actions, less the new offset.
-----------------------------------------------------------------------------*/
void
CActionSet::SetNewBase (DWORD dwNewOffset)
{
	m_dwBaseTime += dwNewOffset;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | InitActionCounters | Tell the actions to initialize their counters.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::InitActionCounters (void)
{
	HRESULT hr = S_OK;	
	int iNumActions = m_cdrgActions.Count();

	for (register int i = 0; i < iNumActions; i++)
	{
		CAction * pcAction = (CAction *)m_cdrgActions[i];

		Proclaim(NULL != pcAction);
		if (NULL != pcAction)
		{
			pcAction->InitExecState();
		}
		else
		{
			hr = E_FAIL;
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | FastForwardActionCounters | Forward the action counters to their states at a given time.
-----------------------------------------------------------------------------*/
void
CActionSet::FastForwardActionCounters (DWORD dwNewTimeOffset)
{
	int iCount = CountActions();
	for (register int i = 0; i < iCount; i++)
	{
		CAction * pcAction = (CAction *)m_cdrgActions[i];
		Proclaim(NULL != pcAction);
		if (NULL != pcAction)
		{
			pcAction->SetCountersForTime(m_dwBaseTime, dwNewTimeOffset);
		}
	}
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | GetTime | Get the current time offset.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT 
CActionSet::GetTime (PDWORD pdwCurrentTime)
{
	HRESULT hr = E_POINTER;

	Proclaim(NULL != pdwCurrentTime);
	if (NULL != pdwCurrentTime)
	{
		*pdwCurrentTime = 0;
		hr = S_OK;

		if (!IsPaused())
		{
			// If the sequencer is stopped, we don't use the
			// current tick ... the time is zero (set above).
			if (NULL != m_piTimer)
			{
				hr = GetCurrentTickCount(pdwCurrentTime);
				Proclaim(SUCCEEDED(hr));
				if (SUCCEEDED(hr))
				{
					// Subtract out the absolute offset for the time 
					// we started playing this sequencer.
					*pdwCurrentTime -= m_dwBaseTime;
				}
			}
		}
		else
		{
			*pdwCurrentTime = m_dwTimePaused - m_dwBaseTime;
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | ReviseTimeOffset| Set the current time offset.
-----------------------------------------------------------------------------*/
void
CActionSet::ReviseTimeOffset (DWORD dwCurrentTick, DWORD dwNewTimeOffset)
{
	dwCurrentTick = dwCurrentTick - m_dwBaseTime;
	 m_dwBaseTime = m_dwBaseTime - dwNewTimeOffset + dwCurrentTick;
	// Reset the execution counters based on the new offset.
	FastForwardActionCounters(dwNewTimeOffset);
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Seek | Set the current time offset, obeying current play state.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT 
CActionSet::Seek (DWORD dwNewTimeOffset)
{
	HRESULT hr = S_OK;
	DWORD dwCurrentTick = 0;
	BOOL fWasPlaying = IsBusy();

	// Unadvise if we have anything pending.
	Unadvise();
	// Clear all of the execution counters - start from scratch..
	InitActionCounters();
	
	// Account for the new time offset in the baseline time.
	if (!IsPaused())
	{
		hr = GetCurrentTickCount(&dwCurrentTick);
		Proclaim(SUCCEEDED(hr));
	}
	else
	{
		dwCurrentTick = m_dwTimePaused;
	}

	if (SUCCEEDED(hr))
	{
		ReviseTimeOffset(dwCurrentTick, dwNewTimeOffset);
		// Resume playing if we were before.
		if (fWasPlaying)
		{
			hr = Advise(m_dwBaseTime);
			Proclaim(SUCCEEDED(hr));
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | At | Attach actions dynamically.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT 
CActionSet::At (BSTR bstrScriptlet, double dblStart, int iRepeatCount, double dblSampleRate,
		                 int iTiebreakNumber, double dblDropTol)
{
	HRESULT hr = E_FAIL;

	// An infinite repeat count indicator might be a negative value.
	if ((g_dwTimeInfinite == iRepeatCount) || (0 < iRepeatCount))
	{
		// Fix up any wierd incoming data.
		// Negative start time set to zero.
		if (0. > dblStart)
		{
			dblStart = 0.0;
		}
		// Low sampling rates set to minimum granularity.
		if (( (double)(cMinimumTimerGranularity) / 1000.) > dblSampleRate)
		{
			dblSampleRate = (double)(cMinimumTimerGranularity) / 1000.;
		}
		// Negative tiebreaks set to the maximum value - they will occur behind anything else.
		if (-1 > iTiebreakNumber)
		{
			iTiebreakNumber = -1;
		}
		// Negative drop tolerances set to the maximum value - they will never be dropped.
		if (((double)SEQ_DEFAULT_DROPTOL != dblDropTol) && (0. > dblDropTol))
		{
			dblDropTol = SEQ_DEFAULT_DROPTOL;
		}
		CAction* pcAction = New CAction(m_fBindToEngine);
		Proclaim ( NULL != pcAction );
		if ( NULL != pcAction )
		{
			// Set the members of the action.
			pcAction->SetScriptletName(bstrScriptlet);
			pcAction->SetStartTime((ULONG)(dblStart * 1000.));
			pcAction->SetRepeatCount((ULONG)iRepeatCount);
			if ((g_dwTimeInfinite == iRepeatCount) || (1 < iRepeatCount))
			{
				pcAction->SetSamplingRate((ULONG)(dblSampleRate * 1000.));
			}
			pcAction->SetTieBreakNumber((ULONG)iTiebreakNumber);
			pcAction->SetDropTolerance((g_dwTimeInfinite != (DWORD)dblDropTol) ? (DWORD)(dblDropTol * 1000.) : g_dwTimeInfinite);
			hr = AddAction ( pcAction ) ? S_OK : E_FAIL;

			// If we're already underway, we'll want to treat this is if we'd just started playing.
			if (IsBusy())
			{
				hr = Unadvise();
				Proclaim(SUCCEEDED(hr));
				pcAction->InitExecState();
				hr = Advise(m_dwBaseTime);
				Proclaim(SUCCEEDED(hr));
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// Repeat count of zero?  It's okay with us.
		hr = S_OK;
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Play | Start the timed actions.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP
CActionSet::Play (ITimer * piTimer, DWORD dwStartFromTime)
{
	HRESULT hr = E_POINTER;
	
	if (NULL != piTimer)
	{
		if (SUCCEEDED(hr = InitActionCounters()))
		{
			SetTimer(piTimer);
			SetBaseTime();

			// Play from a time other than 0.
			if (0 != dwStartFromTime)
			{
				ReviseTimeOffset(m_dwBaseTime, dwStartFromTime);
			}

			hr = Advise(m_dwBaseTime);
		}

	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | IsPaused | Is the action set paused?
-----------------------------------------------------------------------------*/
BOOL 
CActionSet::IsPaused (void) const
{
	return (g_dwTimeInfinite != m_dwTimePaused);
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | IsServicingActions | Are we currently processing actions?
-----------------------------------------------------------------------------*/
BOOL 
CActionSet::IsServicingActions (void) const
{
	return m_fIgnoreAdvises;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Pause | Pause the sequencer, preserving the run state.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP
CActionSet::Pause (void)
{
	HRESULT hr = S_OK;

	// Don't do the work if there's no timer, if we're not currently playing,
	// or if we're already paused.
	if ((NULL != m_piTimer) && (IsBusy()) && (!IsPaused()))
	{
		hr = Unadvise();
		Proclaim(SUCCEEDED(hr));
		if (SUCCEEDED(hr))
		{
			GetCurrentTickCount(&m_dwTimePaused);
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Resume | Resume playing after a pause.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP
CActionSet::Resume (void)
{
	HRESULT hr = E_FAIL;

	if (IsPaused())
	{
		if (NULL != m_piTimer)
		{
			// Reset the base time to account for the pause.
			DWORD dwCurrentTime = g_dwTimeInfinite;

			hr = GetCurrentTickCount(&dwCurrentTime);
			Proclaim(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
			{
				int iNumActions = CountActions();
				DWORD dwPausedTicks = dwCurrentTime - m_dwTimePaused;
				SetNewBase(dwPausedTicks);
				m_dwTimePaused = g_dwTimeInfinite;

				// Account for the paused time in all actions.
				for (int i = 0; i < iNumActions; i++)
				{
					CAction * pcAction = GetAction(i);
					Proclaim(NULL != pcAction);
					if (NULL != pcAction)
					{
						pcAction->AccountForPauseTime(dwPausedTicks);
					}
					else
					{
						// If our action drg is messed up we should bail out.
						hr = E_FAIL;
						break;
					}
				}

				if (SUCCEEDED(hr))
				{
					hr = Advise(dwCurrentTime);
					Proclaim(SUCCEEDED(hr));
				}
			}
		}
	}
	else
	{
		// Don't care.
		hr = S_OK;
	}

	return hr;
}

#ifdef DEBUG_TIMER_RESOLUTION
/*-----------------------------------------------------------------------------
@method | SCODE | CActionSet | ShowSamplingData | Echo sampling data.
@comm Should only be called from #ifdef'd code!!
@author 11-27-96 | pauld | wrote it
@xref   <m CActionSet::Stop>
-----------------------------------------------------------------------------*/
void
CActionSet::ShowSamplingData (void)
{
	// Calculate the average overhead associated with getting the time.
	DWORD dwSecond = 0;
	DWORD dwFirst = ::timeGetTime();
	for (register int i = 0; i < 100; i++)
	{
		dwSecond = ::timeGetTime();
	}
	float fltAvgOverhead = ((float)dwSecond - (float)dwFirst) / (float)100.0;

	// Find out how long the average invoke took in this action set.
	int iCount = CountActions();
	DWORD dwTotalInvokeTime = 0;
	DWORD dwOneActionInvokeTime = 0;
	DWORD dwTotalInvokes = 0;
	DWORD dwOneActionInvokes = 0;

	// Total the amount of time spent inside of invoke.
	for (i = 0; i < iCount; i++)
	{
		CAction * pcAction = (CAction *)m_cdrgActions[i];
		pcAction->SampleInvokes(&dwOneActionInvokeTime, &dwOneActionInvokes);
		dwTotalInvokeTime += dwOneActionInvokeTime;
		dwTotalInvokes += dwOneActionInvokes;
	}

	// There are two calls to ::timeGetTime per invoke sample.
	float fltAverageInvokeTime = ((float)dwTotalInvokeTime - (fltAvgOverhead * (float)	2.0 * (float)dwTotalInvokes))/ (float)dwTotalInvokes;
	float fltAvgInterval = ((float)m_dwTotalIntervals -  (fltAvgOverhead * (float)m_dwIntervals))/ (float)m_dwIntervals;
	float fltAvgInSink = (float)m_dwTotalInSink / ((float)m_dwIntervals + (float)1.0);

	TCHAR szBuffer[0x200];
	CStringWrapper::Sprintf(szBuffer, "average invoke time %8.2f ms\naverage interval %8.2f ms\naverge time in sink %8.2f ms (Timing overhead averaged %8.2f ms per call)\n", 
		fltAverageInvokeTime, fltAvgInterval, fltAvgInSink, fltAvgOverhead);
	::OutputDebugString(szBuffer);
	::MessageBox(NULL, szBuffer, "Interval Data", MB_OK);
}

#endif // DEBUG_TIMER_RESOLUTION


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Stop | Stop all timed actions.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP
CActionSet::Stop (void)
{
	HRESULT hr = S_OK;
	
	if (NULL != m_piTimer)
	{
		ClearTimer();
		InitTimerMembers();
	}

#ifdef DEBUG_TIMER_RESOLUTION
	ShowSamplingData();
#endif // DEBUG_TIMER_RESOLUTION

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | OnTimer | The timer sink has been called.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP 
CActionSet::OnTimer (VARIANT varTimeAdvise)
{
	HRESULT hr = E_FAIL;

#ifdef DEBUG_TIMER_RESOLUTION
	DWORD m_dwThisTime = ::timeGetTime();
	if (0 < m_dwLastTime)
	{
		DWORD dwThisInterval = m_dwThisTime - m_dwLastTime;
		m_dwIntervals++;
		m_dwTotalIntervals += dwThisInterval;
	}
	m_dwLastTime = m_dwThisTime;
#endif // DEBUG_TIMER_RESOLUTION

	// Protect against sink re-entrancy.
	if (!m_fIgnoreAdvises)
	{
		m_fIgnoreAdvises = TRUE;
		Proclaim (VT_UI4 == V_VT(&varTimeAdvise));
		if (VT_UI4 == V_VT(&varTimeAdvise))
		{
			DWORD dwCurrentTime = V_UI4(&varTimeAdvise);

			hr = PlayNowAndAdviseNext(dwCurrentTime);
			Proclaim(SUCCEEDED(hr));
		}
		m_fIgnoreAdvises = FALSE;
	}
	else
	{
		// We're currently lodged in an advise sink.
		hr = S_OK;
	}

#ifdef DEBUG_TIMER_RESOLUTION
	DWORD m_dwEndTime = ::timeGetTime();
	DWORD dwInSink = m_dwEndTime - m_dwThisTime;
	m_dwTotalInSink += dwInSink;
#endif // DEBUG_TIMER_RESOLUTION

	return hr;
}

/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Clear | Clear out the action set and destroy any actions.
-----------------------------------------------------------------------------*/
void CActionSet::Clear ( void )
{
	CAction * pcAction = NULL;
	int nActions = m_cdrgActions.Count();

	for ( int i = 0; i < nActions; i++ )
	{
		pcAction = m_cdrgActions[0];
		m_cdrgActions.Remove(0);
		pcAction->Destroy ();
	}

	m_fBindToEngine = FALSE;
	ClearTimer();
	InitTimerMembers();
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | AddAction | Add this action to the action set.
@rdesc  Returns one of the following:
@flag       TRUE          | We successfully added the action.
@flag       FALSE         | We could not insert the action into the set. 
                            This is likely a memory problem.
-----------------------------------------------------------------------------*/
BOOL CActionSet::AddAction(CAction * pAction )
{
	BOOL fAdded = FALSE;
	int nActions = m_cdrgActions.Count() + 1;

	if (m_cdrgActions.Insert(pAction, DRG_APPEND))
	{
		// If we're already underway, we'll want to hook this action up.
		if (IsBusy() || IsPaused())
		{
			LPOLECONTAINER piContainer = NULL;
			if (SUCCEEDED(m_pcSeq->GetSiteContainer(&piContainer)))
			{
				pAction->ResolveActionInfo(piContainer);
				piContainer->Release();
				fAdded = TRUE;
			}
		}
		else
		{
			fAdded = TRUE;
		}
	}

	return fAdded;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | CountActions | How many actions are in the action set?
@comm   We do not validate actions here.  We count both valid and invalid ones.
@rdesc  Returns the action count.
-----------------------------------------------------------------------------*/
int CActionSet::CountActions( void ) const
{
	return m_cdrgActions.Count();
}


/*-----------------------------------------------------------------------------
@method CAction *| CActionSet | GetAction | Return the nth action in the set.
@comm   We do not validate actions here.  The returned action might be invalid.
@rdesc  Returns a CAction pointer, or NULL if n exceeds the number in the set.
-----------------------------------------------------------------------------*/
CAction* CActionSet::GetAction ( int n ) const
{
	CAction * pcAction = NULL;

	if ( n < m_cdrgActions.Count())
	{
		pcAction = m_cdrgActions[n];
	}

	return pcAction;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | DeriveDispatches| Derive the dispatches, dispids, and param info
                                                 for each action in the set.
@rdesc  Always returns S_OK.
-----------------------------------------------------------------------------*/
HRESULT CActionSet::DeriveDispatches ( LPOLECONTAINER piocContainer)
{
	HRESULT hr = S_OK;
	int nActions = m_cdrgActions.Count();
	CAction * pcAction = NULL;

	for (int i = 0; i < nActions; i++)
	{
		pcAction = m_cdrgActions[i];
		Proclaim(NULL != pcAction);
		if (NULL != pcAction)
		{
			pcAction->ResolveActionInfo(piocContainer);
		}
	}

	return hr;
}

/*-----------------------------------------------------------------------------
@method  BOOL | CActionSet | IsBusy | Do we have actions pending?
@rdesc   Returns TRUE if there are actions pending
-----------------------------------------------------------------------------*/
STDMETHODIMP_( BOOL) 
CActionSet::IsBusy (void)
{
	return (m_fAdvised || m_fPendingAdvise);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\enumobj.h ===
#ifndef __ENUMOBJ_H__
#define __ENUMOBJ_H__

DECLARE_INTERFACE_( ILoadEnum, IUnknown ) 
{
    STDMETHOD( Count   )( THIS_ ULONG * ) PURE;
    STDMETHOD( IsEmpty )( THIS_ BOOL * ) PURE;

    STDMETHOD( Add    )( THIS_ DWORD, IUnknown * ) PURE;
    STDMETHOD( Freeze )( THIS ) PURE;
}; // End ILoadEnum

#define CTRL_MAX 50

class CEnumObjects :
public IEnumDispatch
{
    public:
        CEnumObjects( IEnumControl* );

        // IUnknown methods
        STDMETHODIMP           QueryInterface( REFIID, LPVOID * );
        STDMETHODIMP_( ULONG ) AddRef();
        STDMETHODIMP_( ULONG ) Release();
        
        // IEnumDispatch methods
        STDMETHODIMP Next ( DWORD, IDispatch**, LPDWORD );
	    STDMETHODIMP Skip ( DWORD );
	    STDMETHODIMP Reset( void );
	    STDMETHODIMP Clone( PENUMDISPATCH * );

        // Custom methods
        STDMETHODIMP Init();

        static CEnumObjects * Create( IEnumControl * );

    protected:
        virtual ~CEnumObjects();

        IEnumControl * m_qieoSourceEnum;
        long           m_lRefs;
        IDispatch *    m_aqdspControls[CTRL_MAX];
        ULONG          m_ulNumCtrls;
        ULONG          m_ulCurCtrlIdx;
}; // End Class CEnumObjects

SCODE CreateEnumObjects(IForm * p_qfmSource, IEnumDispatch ** p_qqiedObjects);

#endif // __ENUMOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\cactset.h ===
/*-----------------------------------------------------------------------------
@doc
@module cactset.h | Action set class definition.
@author 12-9-96 | pauld | Autodoc'd
-----------------------------------------------------------------------------*/

#ifndef	_CACTSET_H_
#define _CACTSET_H_

interface ITimer;
interface ITimerSink;
class CActionQueue;
class CMMSeq;

typedef CPtrDrg<CAction> CActionPtrDrg;

class CActionSet :
	public ITimerSink
{
public:
	CActionSet (CMMSeq * pcSeq, BOOL fBindToEngine);
	virtual ~CActionSet ( void );

	STDMETHOD( DeriveDispatches )(LPOLECONTAINER piocContainer);
	// Current Time property.
	HRESULT GetTime (PDWORD pdwCurrentTime);

	HRESULT Seek (DWORD dwCurrentTime);
	// Attach actions dynamically.
	HRESULT At (BSTR bstrScriptlet, double fltStart, int iRepeatCount, double fltSampleRate,
		                  int iTiebreakNumber, double fltDropTol);
	// Play/Pause/Stop the actions.
	STDMETHOD(Play) (ITimer * piTimer, DWORD dwPlayFrom);
	STDMETHOD(Pause) (void);
	STDMETHOD(Resume) (void);
	STDMETHOD(Stop) (void);

	STDMETHOD_(BOOL, IsPaused) (void) const;
	STDMETHOD_(BOOL, IsServicingActions) (void) const;

    // How many actions live in this action set?
    STDMETHOD_( int, CountActions )( void ) const;

	// Return action[n] in the set.
    STDMETHOD_( CAction *, GetAction )( int n ) const;

	// Convenience wrapper for GetAction(n).
    virtual CAction *  operator[](int n ) const
		{  return GetAction(n);  }

	// Do we have any pending actions?
	STDMETHOD_( BOOL, IsBusy ) (void);
	// Revoke any pending advise.
	HRESULT Unadvise (void);
	// Clean out the action set, and destroy all of the actions in it.
	void Clear ( void );

	// For the timer sink.
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
	STDMETHOD_(ULONG, AddRef) (void);
	STDMETHOD_(ULONG, Release) (void);
	STDMETHOD(OnTimer) (VARIANT varTimeAdvise);

protected:

	// Clear the timer variables.  Note : This does not release any valid pointers.  Call ClearTimer for that.
	void InitTimerMembers (void);

	// Add the new action to the action set.
    virtual BOOL AddAction      ( CAction * pcAction );

	// Set or clear the timer.
	STDMETHOD_(void, SetTimer) (ITimer * piTimer);
	STDMETHOD_(void, ClearTimer) (void);

	// The base time is the time all of the actions' start offsets are relative to.
	// We query the timer for it.
	void SetBaseTime (void);
	// Factor a new time offset in with the baseline time.
	void SetNewBase (DWORD dwNewOffset);
	// Request the next advise from the timer.
	HRESULT Advise(DWORD dwNextAdviseTime);
	// Examine the action to see whether it is due to fire, adds it to the action queue if so.  Returns the next time the action
	// is due to fire.
	DWORD EvaluateOneActionForFiring (CAction * pcAction, CActionQueue * pcFireList, DWORD dwCurrentTime);
	// Examine the actions to determine which are due now, and when the next advise should occur.
	HRESULT EvaluateActionsForFiring (CActionQueue * pcFireList, DWORD dwCurrentTime, DWORD * pdwNextAdviseTime);
	// Tell the actions to reset their counters.
	HRESULT InitActionCounters (void);
	// Fast forward the action counter states to the given time offsets.
	void FastForwardActionCounters (DWORD dwNewTimeOffset);
	// Revise the time variables and action counters to reflect a new time offset.
	void ReviseTimeOffset (DWORD dwCurrentTick, DWORD dwNewTimeOffset);
	// Play actions due now, and set up the next timer advise.
	HRESULT PlayNowAndAdviseNext (DWORD dwCurrentTime);
	// Get the current time from the timer service.  Convert from VARIANT.
	HRESULT GetCurrentTickCount (PDWORD pdwCurrentTime);

private:

#ifdef DEBUG_TIMER_RESOLUTION
	void SampleActions (void);
	void ShowSamplingData (void);

	DWORD m_dwIntervals;
	DWORD m_dwTotalIntervals;
	DWORD m_dwLastTime;
	DWORD m_dwTotalInSink;
#endif // DEBUG_TIMER_RESOLUTION

	// The list of actions.
	CActionPtrDrg   m_cdrgActions;
	CMMSeq * m_pcSeq;	
	ITimer * m_piTimer;
	DWORD m_dwBaseTime;
	DWORD m_dwTimerCookie;
	BOOL m_fAdvised;
	BOOL m_fPendingAdvise;
	DWORD m_dwTimePaused;
	BOOL m_fBindToEngine;
	BOOL m_fIgnoreAdvises;
	ULONG m_ulRefs;

};

#endif _CACTSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\purevirt.c ===
// purevirt.c
//
// Avoids use of C runtime.
//

void __cdecl _purecall(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\enumseq.h ===
#ifndef __ENUMSEQ_H__
#define __ENUMSEQ_H__

//interface IEnumVARIANT : IUnknown 
//{  
//	virtual HRESULT Next(unsigned long celt, 
//					VARIANT FAR* rgvar, 
//					unsigned long FAR* pceltFetched) = 0;
//	virtual HRESULT Skip(unsigned long celt) = 0;
//	virtual HRESULT Reset() = 0;
//	virtual HRESULT Clone(IEnumVARIANT FAR* FAR* ppenum) = 0;
//};

class CEnumVariant : public IEnumVARIANT
{
protected:
	ULONG m_cRef;
	CMMSeqMgr* m_pCMMSeqMgr;
	DWORD m_dwIndex;
	CListElement<CSeqHashNode>* m_pcListElement;
	BOOL m_fReset;

public:
	CEnumVariant(CMMSeqMgr* pCMMSeqMgr);
	virtual ~CEnumVariant();
	STDMETHOD (QueryInterface)(REFIID refiid, LPVOID* ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);

	STDMETHOD (Next)(unsigned long celt, VARIANT FAR* rgvar, unsigned long FAR* pceltFetched);
	STDMETHOD (Skip)(unsigned long celt);
	STDMETHOD (Reset)();
	STDMETHOD (Clone)(IEnumVARIANT FAR* FAR* ppenum);
};

#endif //__ENUMSEQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include <itimer.iid>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\ihbase.h"
#include "seqctl.h"
#include "seqinit.h"
#include "seqmgr.h"


//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
HINSTANCE       g_hinst;        // DLL instance handle
ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfoSeq, g_ctlinfoSeqMgr;
#ifdef _DEBUG
BOOL			g_fLogDebugOutput; // Controls logging of debug info
#endif

#define USELOGGING
extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInst);
        TRACE("SeqCtl DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;
#ifdef _DEBUG
#ifdef USELOGGING
		g_fLogDebugOutput = TRUE;
#else
		g_fLogDebugOutput = FALSE;
#endif // USELOGGING
#endif // USELOGGING

        InitSeqControlInfo(hInst, &g_ctlinfoSeq, AllocSeqControl);
        InitSeqControlInfo(hInst, &g_ctlinfoSeqMgr, AllocSequencerManager);
	g_ctlinfoSeq.pNext = &g_ctlinfoSeqMgr;
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE("SeqCtl DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    return RegisterControls(&g_ctlinfoSeq, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
	return RegisterControls(&g_ctlinfoSeq, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfoSeq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\caction.cpp ===
//      IHammer CAction class
//      Van Kichline

#include "..\ihbase\precomp.h"
#include <htmlfilter.h>
#include "mbstring.h"
#include "..\ihbase\debug.h"
#include "actdata.h"
#include <itimer.iid>
#undef Delete
#include "mshtml.h"
#define Delete delete
#include "tchar.h"
#include "objbase.h"
#include "IHammer.h"
#include "strwrap.h"
#include "CAction.h"

#define cTagBufferLength            (0x20)
#define cDataBufferDefaultLength    (0x100)

#pragma warning(disable:4355)   // Using 'this' in constructor

CAction::CAction (BOOL fBindEngine)
{
        m_bstrScriptlet = NULL;
        m_fBindEngine = fBindEngine;
        m_piHTMLWindow2 = NULL;
        ::VariantInit(&m_varLanguage);
        m_pid                   = NULL;
        m_dispid                = DISPID_UNKNOWN;       // Non-existant DISPID
        m_nStartTime    = 0;
        m_nSamplingRate = 0;
        m_nRepeatCount  = 1;
        m_dwTieBreakNumber = 0;
        m_dwDropTolerance = g_dwTimeInfinite;
        InitExecState();

#ifdef DEBUG_TIMER_RESOLUTION
        m_dwInvokes = 0;
        m_dwTotalInInvokes = 0;
#endif // DEBUG_TIMER_RESOLUTION

}
#pragma warning(default:4355)   // Using 'this' in constructor

CAction::~CAction ()
{
        CleanUp ();

}

/*-----------------------------------------------------------------------------
@method void | CAction | Destroy | Instead of calling the C++ delete function
        one must call this Destroy member.
@comm   
-----------------------------------------------------------------------------*/
STDMETHODIMP_( void ) CAction::Destroy( void ) 
{
        Delete this;
} // End CAction::Destroy

/*-----------------------------------------------------------------------------
@method ULONG | CAction | InitExecState | Initialize the execution iteration count and next time due.
@rdesc  Returns the number of times we have yet to execute this action.
-----------------------------------------------------------------------------*/
ULONG 
CAction::InitExecState (void)
{
        m_dwNextTimeDue = g_dwTimeInfinite;
        m_dwLastTimeFired = g_dwTimeInfinite;
        m_ulExecIteration = m_nRepeatCount;
        return m_ulExecIteration;
}


/*-----------------------------------------------------------------------------
@method ULONG | CAction | GetExecIteration | Get the execution iteration count.
@rdesc  Returns the number of times we have yet to execute this action.
-----------------------------------------------------------------------------*/
ULONG
CAction::GetExecIteration (void)
{
        return m_ulExecIteration;
}


/*-----------------------------------------------------------------------------
@method ULONG | CAction | DecrementExecIteration | Bump the execution iteration count down.
@comm   We do not decrement past zero, and we do not decrement when we have an infinite repeat count.
@rdesc  Returns the number of times we've called this method.
-----------------------------------------------------------------------------*/
ULONG
CAction::DecrementExecIteration (void)
{
        // Never decrement past zero,
        // and never decrement when we're
        // supposed to execute infinitely.
        if ((0 != m_ulExecIteration) && (g_dwTimeInfinite != m_ulExecIteration))
        {
                --m_ulExecIteration;
        }

        return m_ulExecIteration;
}


/*-----------------------------------------------------------------------------
@method void | CAction | Deactivate | Deactivate this action - it won't happen again.
-----------------------------------------------------------------------------*/
void
CAction::Deactivate (void)
{
        m_ulExecIteration = 0;
        m_dwNextTimeDue = g_dwTimeInfinite;
}


/*-----------------------------------------------------------------------------
@method void | CAction | SetCountersForTime | Bump the execution iteration count up to the value appropriate for the given time.
-----------------------------------------------------------------------------*/
void 
CAction::SetCountersForTime (DWORD dwBaseTime, DWORD dwNewTimeOffset)
{
        m_dwNextTimeDue = dwBaseTime + m_nStartTime;
        while (m_dwNextTimeDue < (dwBaseTime + dwNewTimeOffset))
        {
                m_dwLastTimeFired = m_dwNextTimeDue;
                DecrementExecIteration();
                if (0 < GetExecIteration())
                {
                        m_dwNextTimeDue += m_nSamplingRate;
                }
                else
                {
                        m_dwNextTimeDue = g_dwTimeInfinite;
                }
        }
}


/*-----------------------------------------------------------------------------
@method void | CAction | AccountForPauseTime | Factor pause time into the last fired and next due vars.
-----------------------------------------------------------------------------*/
void 
CAction::AccountForPauseTime (DWORD dwPausedTicks)
{
        if (g_dwTimeInfinite != m_dwLastTimeFired)
        {
                m_dwLastTimeFired += dwPausedTicks;
        }
        if (g_dwTimeInfinite != m_dwNextTimeDue)
        {
                m_dwNextTimeDue += dwPausedTicks;
        }
}

/*-----------------------------------------------------------------------------
@method ULONG | CAction | GetNextTimeDue | Gets the next time this action is due to fire.
@comm   This method factors in the the base time, the current time and the drop tolerance.
@rdesc  Returns the next time we're due to fire, or g_dwTimeInfinite if it will never be due.
-----------------------------------------------------------------------------*/
DWORD
CAction::GetNextTimeDue (DWORD dwBaseTime)
{
        // This won't be initialized the first time through.
        if (g_dwTimeInfinite == m_dwLastTimeFired)
        {
                m_dwNextTimeDue = dwBaseTime + m_nStartTime;
        }

        return m_dwNextTimeDue;
}

CAction::IsValid ( void )
{
        BOOL    fValid  = FALSE;

        // If we're bound to the script engine check for 
        // a reference to the window object.  Otherwise,
        // check the dispatch/dispid.
        if ((m_fBindEngine && (NULL != m_piHTMLWindow2)) ||
                (( NULL != m_pid ) && ( DISPID_UNKNOWN != m_dispid )))
        {
                Proclaim(NULL != m_bstrScriptlet);
                fValid = (NULL != m_bstrScriptlet);
        }
        return fValid;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CAction | GetRootUnknownForObjectModel | Find the root unknown for the trident object model.
@rdesc  Returns success or failure code.
@xref   <m CAction::ResolveActionInfoFromObjectModel>
-----------------------------------------------------------------------------*/
HRESULT
CAction::GetRootUnknownForObjectModel (LPOLECONTAINER piocContainer, LPUNKNOWN * ppiunkRoot)
{
        HRESULT hr = E_FAIL;

        ASSERT(NULL != ppiunkRoot);
        ASSERT(NULL != piocContainer);

        if ((NULL != ppiunkRoot) && (NULL != piocContainer))
        {
                LPUNKNOWN piunkContainer = NULL;

                // Get the container's IUnknown.
                if (SUCCEEDED(hr = piocContainer->QueryInterface(IID_IUnknown, (LPVOID *)&piunkContainer)))
                {
                        // Get the container's HTML Document.
                        IHTMLDocument * piHTMLDoc = NULL;

                        if (SUCCEEDED(hr = piunkContainer->QueryInterface(IID_IHTMLDocument, (LPVOID *)&piHTMLDoc)))
                        {
                                // Ask the HTML document for the window object's dispatch.
                                hr = piHTMLDoc->get_Script((LPDISPATCH *)ppiunkRoot);
                                ASSERT(SUCCEEDED(hr));
                                piHTMLDoc->Release();
                        }
                        piunkContainer->Release();
                }
        }
        else
        {
                hr = E_POINTER;
        }

        return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CAction | ResolveActionInfoForScript | Derive the IDispatch, DISPID,
        and parameter info of this script action, using the trident object model.
@rdesc  Returns success or failure code.
@xref   <m CAction::ResolveActionInfo>
-----------------------------------------------------------------------------*/
HRESULT
CAction::ResolveActionInfoForScript (LPOLECONTAINER piocContainer)
{
        HRESULT hr = E_FAIL;

        if (m_fBindEngine)
        {
                LPUNKNOWN piUnknownRoot = NULL;

                Proclaim(NULL == m_piHTMLWindow2);
                // Get a reference to the root window object.
                if (SUCCEEDED(piocContainer->QueryInterface(IID_IUnknown, (LPVOID *)&piUnknownRoot)))
                {
                        IHTMLDocument * piHTMLDoc = NULL;
                        if (SUCCEEDED(piUnknownRoot->QueryInterface(IID_IHTMLDocument, (LPVOID *)&piHTMLDoc)))
                        {
                                LPDISPATCH piWindowDispatch = NULL;

                                if (SUCCEEDED(hr = piHTMLDoc->get_Script(&piWindowDispatch)))
                                {
                                        if (SUCCEEDED(hr = piWindowDispatch->QueryInterface(IID_IHTMLWindow2, (LPVOID *)&m_piHTMLWindow2)))
                                        {
                                                // Allocate the language string for the setTimeout call.
                                                V_VT(&m_varLanguage) = VT_BSTR;
                                                V_BSTR(&m_varLanguage) = ::SysAllocString(L"JScript");
                                        }
                                        piWindowDispatch->Release();
                                }
                                piHTMLDoc->Release();
                        }
                        piUnknownRoot->Release();
                }
        }
        else
        {
                // Get the container's IUnknown.
                Proclaim(NULL == m_pid);
                Proclaim(DISPID_UNKNOWN == m_dispid);
                if (SUCCEEDED(hr = GetRootUnknownForObjectModel(piocContainer, (LPUNKNOWN *)&m_pid)))
                {
                                OLECHAR * rgwcName[1] = {m_bstrScriptlet};
                                hr = m_pid->GetIDsOfNames( IID_NULL, (OLECHAR **)rgwcName, 1, 409, &m_dispid);
                }
        }

        return hr;
}

/*-----------------------------------------------------------------------------
@method HRESULT | CAction | ResolveActionInfo | Derive the IDispatch, DISPID, and parameter info
        of this action.
@rdesc  Returns E_FAIL if one of the lookups fails, or if we're trying to talk to ourselves.
-----------------------------------------------------------------------------*/
HRESULT
CAction::ResolveActionInfo ( LPOLECONTAINER piocContainer)
{
        HRESULT hr = E_FAIL;

        if ((m_fBindEngine && (NULL == m_piHTMLWindow2)) || 
                ((!m_fBindEngine) && (NULL == m_pid)))
        {
                // Make sure we've got what we need to start with.
                if (NULL != m_bstrScriptlet)
                {
                        hr = ResolveActionInfoForScript(piocContainer);
                }
        }
        else
        {
                // This object has already been initialized!  Just return.
                hr = S_OK;
        }

        return hr;
}


#ifdef DEBUG_TIMER_RESOLUTION
#include "MMSYSTEM.H"
#endif //DEBUG_TIMER_RESOLUTION

HRESULT CAction::FireMe (DWORD dwBaseTime, DWORD dwCurrentTime)
{
        HRESULT hr = E_FAIL;
        DISPID dispIDNamedArgument = DISPID_UNKNOWN;
        BOOL fDropped = ((dwCurrentTime - m_dwNextTimeDue) > m_dwDropTolerance);

#ifdef DEBUG_TIMER
        TCHAR szBuffer[0x100];
        CStringWrapper::Sprintf(szBuffer, "(%u)\n", m_nRepeatCount - GetExecIteration());
        ::OutputDebugString(szBuffer);
#endif

        DecrementExecIteration();
        m_dwLastTimeFired = dwCurrentTime;

        // If we have not exceeded the drop tolerance invoke the action.
        if (!fDropped)
        {

#ifdef DEBUG_TIMER_RESOLUTION
                m_dwInvokes++;
                DWORD dwTimeStart = ::timeGetTime();
#endif // DEBUG_TIMER_RESOLUTION

                if (m_fBindEngine && (NULL != m_piHTMLWindow2))
                {
                        VARIANT varRet;
                        VariantInit(&varRet);
                        hr = m_piHTMLWindow2->execScript(m_bstrScriptlet, V_BSTR(&m_varLanguage), &varRet);
                }
                else if (NULL != m_pid)
                {
                        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
                        hr = m_pid->Invoke(m_dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                                           DISPATCH_METHOD, &dispparamsNoArgs, NULL, NULL, NULL);
                }

#ifdef DEBUG_TIMER_RESOLUTION
                DWORD dwTimeFinish = ::timeGetTime();
                m_dwTotalInInvokes += (dwTimeFinish - dwTimeStart);
#endif // DEBUG_TIMER_RESOLUTION

        }
        // If the action was dropped - then we DO want it to happen again.
        else
        {
                hr = S_OK;
        }

        // Set up the next time due.  It will be g_dwTimeInfinite when we've executed 
        // for the last time.
        if (0 < GetExecIteration())
        {
                // If the action did not succeed, don't let it happen again.
                if (SUCCEEDED(hr))
                {
                        m_dwNextTimeDue += GetSamplingRate();
                }
                else
                {
                        Deactivate();
                }
        }
        else
        {
                m_dwNextTimeDue = g_dwTimeInfinite;
        }

        return hr;
}

BOOL
CAction::MakeScriptletJScript (BSTR bstrScriptlet)
{
        BOOL fRet = FALSE;
        int iLastPos = CStringWrapper::WStrlen(bstrScriptlet) - 1;

        // Make sure to trim any whitespace off of the end of the scriptlet.
        while ((iLastPos > 0) && (CStringWrapper::Iswspace(bstrScriptlet[iLastPos])))
        {
                --iLastPos;
        }

        // We need to have more than zero characters here in order to care.
        if (0 <= iLastPos)
        {
                // We're not passing params, so we need to append parens.
                if ((wchar_t)')' != bstrScriptlet[iLastPos])
                {
                                // Append parens so that we can execute as jscript.
                                OLECHAR * olestrParens = L"()";
                                unsigned int uiLength = CStringWrapper::WStrlen(bstrScriptlet)  + CStringWrapper::WStrlen(olestrParens);
                                m_bstrScriptlet = ::SysAllocStringLen(NULL, uiLength);
                                Proclaim(NULL != m_bstrScriptlet);
                                if (NULL != m_bstrScriptlet)
                                {
                                        CStringWrapper::WStrcpy(m_bstrScriptlet, bstrScriptlet);
                                        CStringWrapper::WStrcat(m_bstrScriptlet, olestrParens);
                                        fRet = TRUE;
                                }
                }
                else
                {
                        m_bstrScriptlet = ::SysAllocString(bstrScriptlet);
                        Proclaim(NULL != m_bstrScriptlet);
                        if (NULL != m_bstrScriptlet)
                        {
                                fRet = TRUE;
                        }
                }
        }
        return fRet;
}

BOOL
CAction::SetScriptletName (BSTR bstrScriptlet)
{
        BOOL fRet = FALSE;

        // Wipe out the prior command name if there is one.
        if (NULL != m_bstrScriptlet)
        {
                ::SysFreeString(m_bstrScriptlet);
                m_bstrScriptlet = NULL;
        }
        // Copy the new name to the command member.
        Proclaim(NULL != bstrScriptlet);
        if (NULL != bstrScriptlet)
        {
                if (m_fBindEngine)
                {
                        // Append parens if necessary, so we can execute this as jscript.
                        fRet = MakeScriptletJScript(bstrScriptlet);
                }
                else
                {
                        m_bstrScriptlet = ::SysAllocString(bstrScriptlet);
                        Proclaim (NULL != m_bstrScriptlet);
                        if (NULL != m_bstrScriptlet)
                        {
                                fRet = TRUE;
                        }
                }
        }

        return fRet;
}


void CAction::CleanUp ( void )
{
        if (NULL != m_bstrScriptlet)
        {
                ::SysFreeString(m_bstrScriptlet);
                m_bstrScriptlet = NULL;
        }

        if (NULL != m_piHTMLWindow2)
        {
                m_piHTMLWindow2->Release();
                m_piHTMLWindow2 = NULL;
        }
        ::VariantClear(&m_varLanguage);
        if ( NULL != m_pid )
        {
                m_pid->Release ();
                m_pid = NULL;
        }
        m_dispid                = DISPID_UNKNOWN;

        m_nStartTime    = 0;

        m_dwTieBreakNumber = 0;
        m_dwDropTolerance = g_dwTimeInfinite;
        InitExecState();

#ifdef DEBUG_TIMER_RESOLUTION
        m_dwInvokes = 0;
        m_dwTotalInInvokes = 0;
#endif // DEBUG_TIMER_RESOLUTION

}

/*-----------------------------------------------------------------------------
@method  void | CAction | SetStartTime | Sets the start time
@comm
@rdesc   Returns nothing
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CAction::SetStartTime(ULONG nStartTime)
{
        m_nStartTime = nStartTime;
}

/*-----------------------------------------------------------------------------
@method  void | CAction | SetRepeatCount | Sets the repeat count
@comm
@rdesc   Returns nothing
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CAction::SetRepeatCount (ULONG nRepeatCount)
{
        m_nRepeatCount = nRepeatCount;
}

/*-----------------------------------------------------------------------------
@method  void | CAction | SetSamplingRate | Sets the sampling rate
@comm
@rdesc   Returns nothing
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CAction::SetSamplingRate ( ULONG nSamplingRate)
{
        m_nSamplingRate = nSamplingRate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\enumseq.cpp ===
/*++

Module: 
	enumseq.cpp

Author: 
	ThomasOl

Created: 
	April 1997

Description:
	Implements Sequencer Manager

History:
	4-02-1997	Created

++*/

#include "..\ihbase\precomp.h"
#include "servprov.h"
#include <htmlfilter.h>

#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "memlayer.h"

#include "debug.h"
#include "drg.h"
#include "strwrap.h"
#include "seqmgr.h"
#include "enumseq.h"


CEnumVariant::CEnumVariant(CMMSeqMgr* pCMMSeqMgr)
{
	m_pCMMSeqMgr = pCMMSeqMgr;
	if (m_pCMMSeqMgr)
		m_pCMMSeqMgr->AddRef();
	m_cRef = 1;
	Reset();
}

CEnumVariant::~CEnumVariant()
{
	if (m_pCMMSeqMgr)
		m_pCMMSeqMgr->Release();
}

STDMETHODIMP CEnumVariant::QueryInterface(REFIID refiid, LPVOID* ppvObj)
{
	if (!ppvObj)
		return E_INVALIDARG;

	if (IsEqualGUID(refiid, IID_IUnknown) || IsEqualGUID(refiid, IID_IEnumVARIANT))
	{
		*ppvObj = (LPVOID)(IEnumVARIANT*)this;
		AddRef();
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CEnumVariant::AddRef(void)
{
	return (ULONG)InterlockedIncrement((LPLONG)&m_cRef);
}

STDMETHODIMP_(ULONG) CEnumVariant::Release(void)
{
	ULONG cRef = (ULONG)InterlockedDecrement((LPLONG)&m_cRef);
	if (!cRef)
	 	delete this;
	return cRef;
}

STDMETHODIMP CEnumVariant::Next(ULONG cElements, VARIANT FAR* pvar,	ULONG FAR* pcElementFetched)
{
	ULONG cCur = 0;
	DWORD dwIndex;
	CListElement<CSeqHashNode>* pcListElement;
	CSeqHashNode* pcSeqHashNode;

	if (pcElementFetched != NULL)
		*pcElementFetched = 0;

	Proclaim(m_pCMMSeqMgr);
	if (!m_pCMMSeqMgr)
		return E_FAIL;

	Proclaim(pvar);
	if (!pvar)
		return E_INVALIDARG;

	//save the current values
	dwIndex = m_pCMMSeqMgr->m_hashTable.m_dwIndex;
    pcListElement = m_pCMMSeqMgr->m_hashTable.m_pcListElement;

	//set to last call
	m_pCMMSeqMgr->m_hashTable.m_dwIndex = m_dwIndex;
    m_pCMMSeqMgr->m_hashTable.m_pcListElement = m_pcListElement;

	while (cCur < cElements)
	{
		pcSeqHashNode = (!m_pcListElement) ?
			m_pCMMSeqMgr->m_hashTable.FindFirst() : 
			m_pCMMSeqMgr->m_hashTable.FindNext();

		if (!pcSeqHashNode)
			break;

		VariantInit(&pvar[cCur]);
		pvar[cCur].vt = VT_DISPATCH;
		pvar[cCur].pdispVal = pcSeqHashNode->m_piMMSeq;
		Proclaim(pcSeqHashNode->m_piMMSeq);
		cCur++;
	}

	// Set count of elements retrieved.
	if (pcElementFetched != NULL)
		*pcElementFetched = cCur;

	//save for next call
	m_dwIndex = m_pCMMSeqMgr->m_hashTable.m_dwIndex;
    m_pcListElement = m_pCMMSeqMgr->m_hashTable.m_pcListElement;

	//restore current values
	m_pCMMSeqMgr->m_hashTable.m_dwIndex = dwIndex;
    m_pCMMSeqMgr->m_hashTable.m_pcListElement = pcListElement;

	return (cCur < cElements) ? ResultFromScode(S_FALSE) : NOERROR;
}

STDMETHODIMP CEnumVariant::Skip(ULONG cElements)
{
	VARIANT var;
	ULONG   cActual = 0;
	HRESULT hr;

	while (cActual < cElements)
	{
		hr = Next(1, &var, NULL);

		if (S_OK != hr)
			break;
		
		cActual++;
	}
	return (cActual < cElements) ? ResultFromScode(S_FALSE) : S_OK;
}

STDMETHODIMP CEnumVariant::Reset()
{
	m_dwIndex = 0;
	m_pcListElement = NULL;
	m_fReset = FALSE;
	return S_OK;
}

STDMETHODIMP CEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
	CEnumVariant* pEV;
	HRESULT hr=E_FAIL;

	Proclaim(ppenum);
	if (!ppenum)
		return E_INVALIDARG;

	pEV = New CEnumVariant(m_pCMMSeqMgr);
	if (pEV)
	{
		hr = pEV->QueryInterface(IID_IEnumVARIANT, (LPVOID*)ppenum);
		pEV->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\seqevent.h ===
/*++

Module: 
	events.h

Author: 
	IHammer Team (SimonB)

Created: 
	October 1996

Description:
	Macros to make firing events easier and safer.  Each macro can be customised for 
	the particular event.  However, the general form should be:

	#define FIRE_EVENTNAME(pConnectionPoint, param1, param2) \
		PConnectionPoint->FireEvent(DISPID_EVENT_EVENTNAME, \
			<VT for param1>, param1, \
			<VT for param2>, param2, \
			0) 
	
	NOTE: The terminating 0 is extremly important !!!

History:
	10-21-1996	Created

++*/

#include "dispids.h"

#ifndef _EVENTS_H_
#define _EVENTS_H_


#define FIRE_SEQLOAD(pConnectionPoint) \
	pConnectionPoint->FireEvent(DISPID_SEQLOAD_EVENT, 0)


#endif // This header file not included

// End of file events.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\seqinit.h ===
/*++

Module: 
	seqinit.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Header for control-specific initialisation

History:
	05-27-1997	Created (SimonB)

++*/
#include "..\mmctl\inc\ochelp.h" // for ControlInfo

#ifndef __SEQINIT_H__
#define __SEQINIT_H__

void InitSeqControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);
void InitSeqMgrControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);

#endif // __SEQINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\seqinit.cpp ===
/*++

Module: 
	seqinit.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Performs control-specific initialisation

History:
	05-26-1997	Created (SimonB)

++*/

#include "..\ihbase\ihbase.h"
#include "..\mmctl\inc\ochelp.h" // for ControlInfo
#include "seqinit.h"
#include "..\resource.h"
#include <daxpress.h>

extern ULONG g_cLock;


void InitSeqControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.Sequence");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Sequence");
    pCtlInfo->pclsid = &CLSID_MMSeq;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = "1.0";
    pCtlInfo->iToolboxBitmapID = -1;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; // TODO: Change as appropriate
}


void InitSeqMgrControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.SequencerControl");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Sequencer");
    pCtlInfo->pclsid = &CLSID_SequencerControl;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = "1.0";
    pCtlInfo->iToolboxBitmapID = IDB_ICON_SEQUENCER;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_CONTROL | CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING | CI_MMCONTROL;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; // TODO: Change as appropriate
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\seqctl.h ===
/*++

Module: 
	seqctl.h

Author: 
	IHammer Team (SimonB)

Created: 
	October 1996

Description:
	Defines the control's class

History:
	10-21-1996	Templatized (SimonB)
	10-01-1996	Created

++*/
#ifndef __SEQCTL_H__
#define __SEQCTL_H__

#include "precomp.h"
#include "ihammer.h"
#include "ihbase.h"
#include <daxpress.h>

#define SEQ_DEFAULT_REPEAT_COUNT 1
#define SEQ_DEFAULT_SAMPLING_RATE 0
#define SEQ_DEFAULT_TIEBREAK -1
#define SEQ_DEFAULT_DROPTOL -1

#define SEQ_BASECLASS	\
	CIHBaseCtl <	\
	CMMSeq,			\
	IMMSeq,			\
	&CLSID_MMSeq,	\
	&IID_IMMSeq,	\
	&LIBID_DAExpressLib,	\
	&DIID_IMMSeqEvents>

class CActionSet;

class CMMSeq:
	public IMMSeq,
	public SEQ_BASECLASS
	
{
friend LPUNKNOWN __stdcall AllocSeqControl(LPUNKNOWN punkOuter);

// Template stuff
	typedef SEQ_BASECLASS CMyIHBaseCtl;

public:

	// Callback for the action set.
	void NotifyStopped (void);
	HRESULT GetSiteContainer (LPOLECONTAINER * ppiContainer);

protected:

	// 
	// Constructor and destructor
	// 
	CMMSeq(IUnknown *punkOuter, HRESULT *phr);

    ~CMMSeq();

	// Overrides
	STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
	
	STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);
	
	///// IDispatch implementation
	protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   

	///// delegating IUnknown implementation
	protected:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

	
	//
	// IMMSeq methods 
	//
	protected:
    STDMETHODIMP get_Time (THIS_ double FAR* pdblCurrentTime);
    STDMETHODIMP put_Time (THIS_ double dblCurrentTime);
	STDMETHODIMP get_PlayState (THIS_ int FAR * piPlayState);
    STDMETHOD(put__Cookie)(THIS_ long lCookie) 
		{m_lCookie=lCookie;return S_OK;}
    STDMETHOD(get__Cookie)(THIS_ long FAR* plCookie) 
		{if (!plCookie) return E_POINTER; *plCookie = m_lCookie;return S_OK;}

	STDMETHODIMP Play (void);
	STDMETHODIMP Pause (void);
	STDMETHODIMP Stop (void);
    STDMETHODIMP At (VARIANT varStartTime, BSTR bstrScriptlet, VARIANT varRepeatCount, VARIANT varSampleRate, VARIANT varTiebreakNumber, VARIANT varDropTolerance);
	STDMETHODIMP Clear (void);
    STDMETHODIMP Seek(double dblSeekTime);


	protected:

	enum 
	{
		SEQ_STOPPED = 0,
		SEQ_PLAYING = 1,
		SEQ_PAUSED = 2,
	} PlayState;

	BOOL InitActionSet (BOOL fBindToEngine);
	void Shutdown (void);
	HRESULT DeriveDispatches (void);
	BOOL IsBusy (void);
	HRESULT FindContainerTimer (ITimer ** ppiTimer);
	HRESULT FindDefaultTimer (ITimer ** ppiTimer);
	HRESULT FindTimer (ITimer ** ppiTimer);
	BOOL FurnishDefaultAtParameters (VARIANT * pvarStartTime, VARIANT * pvarRepeatCount, VARIANT * pvarSampleRate, 
			                                              VARIANT * pvarTiebreakNumber, VARIANT * pvarDropTolerance);
	void FireStoppedEvent (void);

	CActionSet * m_pActionSet;
	unsigned long m_ulRef;

	long m_lCookie;
    BOOL m_fSeekFiring;
	DWORD m_dwPlayFrom;

};

#endif // __SEQCTL_H__

// end of file seqctl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\seqmgr.h ===
/*++

Module: 
        seqmgr.h

Author: 
        ThomasOl

Created: 
        April 2

Description:
        Defines the Sequencer Manager class

History:
        4-02-1997       Created

++*/

#ifndef __SEQMGR_H__
#define __SEQMGR_H__

#include <ihammer.h>
#include "precomp.h"
#include "ihbase.h"
#include <ctype.h>
#include <hash.h>
#include <unknown.h>
#include "daxpress.h"
#include "dispids.h"

struct CookieList {
    long cookie;
    void * pnode;
};

/*
***************************************************************************************************************
*
*
*
*
*
*
***************************************************************************************************************
*/

class CSeqHashNode
{
public:
        TCHAR m_rgchName[CCH_ID];
        IMMSeq* m_piMMSeq;
        IConnectionPoint* m_piConnectionPoint;
        DWORD m_dwUnadviseCookie;

        CSeqHashNode() 
                {m_rgchName[0]=NULL;m_piMMSeq=NULL;m_dwUnadviseCookie=0;m_piConnectionPoint=NULL;}
        CSeqHashNode(TCHAR* prgchName, IMMSeq* piMMSeq) 
        {
                Proclaim(prgchName);
                m_rgchName[0] = 0;
                if (prgchName)
                        lstrcpy(m_rgchName, prgchName);
                m_piMMSeq = piMMSeq;
                if (m_piMMSeq)
                        m_piMMSeq->AddRef();
                m_dwUnadviseCookie=0;
                m_piConnectionPoint=NULL;
        }
        virtual ~CSeqHashNode()
        {
                if (m_piMMSeq)
                        m_piMMSeq->Release();
                if (m_piConnectionPoint)
                {
                        if (m_dwUnadviseCookie)
                                m_piConnectionPoint->Unadvise(m_dwUnadviseCookie);
                        m_piConnectionPoint->Release();
                }
        }
    int operator==(const CSeqHashNode& node) const
    {
                return (lstrcmpi(m_rgchName, node.m_rgchName) == 0);
    }
        CSeqHashNode& operator=(const CSeqHashNode& node)
        {
                lstrcpy(m_rgchName, node.m_rgchName);
                if (m_piMMSeq)
                        m_piMMSeq->Release();
                m_piMMSeq = node.m_piMMSeq;
                if (m_piMMSeq)
                        m_piMMSeq->AddRef();
                m_dwUnadviseCookie = node.m_dwUnadviseCookie;
                return *this;
        }
};

/*
***************************************************************************************************************
*
*
*
*
*
*
***************************************************************************************************************
*/
#define RotBitsLeft(lVal, cBits) (lVal << cBits | lVal >> (32 - cBits))

class CSeqHashTable : public CHashTable<CSeqHashNode>
{
        friend class CEnumVariant;
protected:
    DWORD Hash(CSeqHashNode* pnode)
    {
            DWORD dwVal=0;
    
                if (pnode)
                {
                for (int i = 0; i < 5 && pnode->m_rgchName[i]; i++)
                        dwVal = (DWORD)(_toupper(pnode->m_rgchName[i])) + RotBitsLeft(dwVal, 5);
                }
            return (dwVal % NUM_HASH_BUCKETS);
    }
};


/*
***************************************************************************************************************
*
*
*
*
*
*
***************************************************************************************************************
*/

class CEventHandler : public IDispatch
{
protected:
        IMMSeqMgr* m_pSeqMgr;
        ULONG m_cRef;

public:
        CEventHandler(IMMSeqMgr* pSeqMgr)
                {m_pSeqMgr=pSeqMgr;if (m_pSeqMgr) m_pSeqMgr->AddRef();m_cRef=1;}
        virtual ~CEventHandler() {if (m_pSeqMgr) m_pSeqMgr->Release();}

public:
        /* Overrides*/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj)
        {
                if (!ppvObj) return E_POINTER;
                if (IsEqualGUID(riid, IID_IUnknown) || IsEqualGUID(riid, IID_IDispatch))
                {
                        *ppvObj = (LPVOID)(IDispatch*)this;
                        AddRef();
                        return S_OK;
                }
                return E_NOINTERFACE;
        }
        STDMETHOD_(ULONG,AddRef)  (THIS)
                {return InterlockedIncrement((LPLONG)&m_cRef);}
    STDMETHOD_(ULONG,Release) (THIS)
                {
                        ULONG cRef = InterlockedDecrement((LPLONG)&m_cRef);
                        if (!cRef)
                                delete this;
                        return cRef;
                }

        //IDispatch methods
protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) {return E_NOTIMPL;}
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) {return E_NOTIMPL;}
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid) {return E_NOTIMPL;}
    STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr)
        {
                if (m_pSeqMgr)
                {
                        //      typedef struct FARSTRUCT tagDISPPARAMS{
                        //              VARIANTARG FAR* rgvarg;                 // Array of arguments.
                        //              DISPID FAR* rgdispidNamedArgs;  // Dispatch IDs of named arguments.
                        //              unsigned int cArgs;                             // Number of arguments.
                        //              unsigned int cNamedArgs;                // Number of named arguments.
                        //      } DISPPARAMS;

                        switch(dispid)
                        {
                                case DISPID_SEQ_EVENT_ONPLAY:
                                case DISPID_SEQ_EVENT_ONSTOP:
                                case DISPID_SEQ_EVENT_ONPAUSE:
                {
                                        Proclaim(pdispparams);
                                        Proclaim(pdispparams->rgvarg);
                                        Proclaim(1==pdispparams->cArgs);
                                        Proclaim(VT_I4 == pdispparams->rgvarg[0].vt);

                                        if (pdispparams && pdispparams->rgvarg && 
                                                1==pdispparams->cArgs &&
                                                VT_I4 == pdispparams->rgvarg[0].vt )
                                        {
                                                m_pSeqMgr->RelayEvent(dispid, pdispparams->rgvarg[0].lVal, 0.0f);
                                        }
                }
                                break;

                case DISPID_SEQ_EVENT_ONSEEK:
                {
                                        Proclaim(pdispparams);
                                        Proclaim(pdispparams->rgvarg);
                                        Proclaim(2==pdispparams->cArgs);
                    Proclaim(VT_R8 == pdispparams->rgvarg[0].vt);
                                        Proclaim(VT_I4 == pdispparams->rgvarg[1].vt);

                                        if (pdispparams && pdispparams->rgvarg && 
                                                2==pdispparams->cArgs &&
                                                VT_I4 == pdispparams->rgvarg[1].vt &&
                        VT_R8 == pdispparams->rgvarg[0].vt)
                                        {
                                                m_pSeqMgr->RelayEvent(dispid, pdispparams->rgvarg[1].lVal, pdispparams->rgvarg[0].dblVal);
                                        }

                }
                break;

                        }
                }
                return S_OK;
        }
};


/*
***************************************************************************************************************
*
*
*
*
*
*
***************************************************************************************************************
*/

#undef BASECLASS
#define BASECLASS       \
        CIHBaseCtl <    \
        CMMSeqMgr,              \
        IMMSeqMgr,              \
        &CLSID_SequencerControl,\
        &IID_IMMSeqMgr, \
        &LIBID_DAExpressLib,    \
        &DIID_IMMSeqMgrEvents>

class CEnumVariant;


class CMMSeqMgr:
        public IMMSeqMgr,
        public BASECLASS
        
{
        friend LPUNKNOWN __stdcall AllocSequencerManager(LPUNKNOWN punkOuter);
        friend class CEnumVariant;
        typedef BASECLASS CMyIHBaseCtl;

protected:

        void FireInit (void);

        BOOL m_fLoadFired;
        BOOL m_fInited;
        long m_fCurCookie;
        CookieList *m_PointerList;
        unsigned long m_ulRef;
        CSeqHashTable m_hashTable;
        IDispatch* m_pidispEventHandler;
        bool m_bUnloaded;
        bool m_bUnloadedStarted;
        // 
        // Constructor and destructor
        // 
public:
        CMMSeqMgr(IUnknown *punkOuter, HRESULT *phr);
    virtual ~CMMSeqMgr();

        // Overrides
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
        
        STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);
        
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
         BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue);

        ///// IDispatch implementation
public:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   
    STDMETHOD(get_Item)(THIS_ VARIANT variant, IDispatch ** ppdispatch);
        STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* pUnk);
    STDMETHOD(get_Count)(THIS_ long FAR* plCount);
    
        STDMETHOD(RelayEvent)(long dispid, long lCookie, double dblSeekTime);

        // IOleObject overrides
        STDMETHOD (Close)(DWORD dwSaveOption);

        ///// delegating IUnknown implementation
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

#ifdef SUPPORTONLOAD
        void OnWindowLoad();
        void OnWindowUnload();
#endif //SUPPORTONLOAD

};



#endif // __SEQMGR_H__

// end of file SEQMGR.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\seqctl.cpp ===
/*++

Module:
	control.cpp

Author:
	IHammer Team (SimonB)
	pauld

Created:
	March 1997

Description:
	Implements any control-specific members, as well as the control's interface

History:
	3-15-97 Used template for new sequencer
	12-03-1996	Fixed painting code
	10-01-1996	Created

++*/

#include "..\ihbase\precomp.h"
#include "servprov.h"
#include <ocmm.h>
#include <htmlfilter.h>

#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "memlayer.h"
#include "debug.h"
#include "drg.h"
#include <actclass.iid>
#include <itimer.iid>
#include "strwrap.h"
#include "caction.h"
#include "cactset.h"
#include "seqctl.h"
#include "winver.h"
#include "seqevent.h"

extern ControlInfo     g_ctlinfoSeq, g_ctlinfoSeqMgr;

//
// CMMSeq Creation/Destruction
//

LPUNKNOWN __stdcall AllocSeqControl(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr = S_OK;
    CMMSeq *pthis = New CMMSeq(punkOuter, &hr);
    DEBUGLOG("AllocControl : Allocating object\n");
    if (pthis == NULL)
        return NULL;
    if (FAILED(hr))
    {
        Delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

//
// Beginning of class implementation
//

CMMSeq::CMMSeq(IUnknown *punkOuter, HRESULT *phr):
	CMyIHBaseCtl(punkOuter, phr),
	m_pActionSet(NULL),
	m_ulRef(1),
	m_fSeekFiring(FALSE),
	m_dwPlayFrom(0)
{
	DEBUGLOG("MMSeq: Allocating object\n");
	if (NULL != phr)
	{
		// We used to query against the version 
		// number of mshtml.dll to determine whether
		// or not to bind directly to the script 
		// engine.  Since this was a pre-PP2 
		// restriction it seems reasonable to 
		// rely on script engine binding now.
		if (InitActionSet(TRUE))
		{
			::InterlockedIncrement((long *)&(g_ctlinfoSeq.pcLock));
			*phr = S_OK;
		}
		else
		{
			*phr = E_FAIL;
		}
	}
}


CMMSeq::~CMMSeq()
{
	DEBUGLOG("MMSeq: Destroying object\n");
	Shutdown();
	::InterlockedDecrement((long *)&(g_ctlinfoSeq.pcLock));
}


void
CMMSeq::Shutdown (void)
{
	// Kill any pending actions.
	if (IsBusy())
	{
		ASSERT(NULL != m_pActionSet);
		if (NULL != m_pActionSet)
		{
			m_pActionSet->Unadvise();
		}
	}

	if (NULL != m_pActionSet)
	{
		Delete m_pActionSet;
		m_pActionSet = NULL;
	}
}

STDMETHODIMP CMMSeq::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
	//		Add support for any custom interfaces

	HRESULT hRes = S_OK;
	BOOL fMustAddRef = FALSE;

    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("MMSeq::QI('%s')\n", DebugIIDName(riid, ach));
#endif

	if ((IsEqualIID(riid, IID_IMMSeq)) || (IsEqualIID(riid, IID_IDispatch)))
	{
		if (NULL == m_pTypeInfo)
		{
			HRESULT hRes = S_OK;

			// Load the typelib
			hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_IMMSeq, LIBID_DAExpressLib, NULL);

			if (FAILED(hRes))
			{
				ODS("Unable to load typelib\n");
				m_pTypeInfo = NULL;
			}
			else
				*ppv = (IMMSeq *) this;

		}
		else
			*ppv = (IMMSeq *) this;

	}
    else // Call into the base class
	{
		DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);

	}

    if (NULL != *ppv)
	{
		DEBUGLOG("MMSeq: Interface supported in control class\n");
		((IUnknown *) *ppv)->AddRef();
	}

    return hRes;
}


BOOL
CMMSeq::InitActionSet (BOOL fBindToEngine)
{
	BOOL fRet = FALSE;

	ASSERT(NULL == m_pActionSet);
	if (NULL == m_pActionSet)
	{
		m_pActionSet = New CActionSet(this, fBindToEngine);
		ASSERT(NULL != m_pActionSet);
		if (NULL != m_pActionSet)
		{
			fRet = TRUE;
		}
	}

	return fRet;
}

STDMETHODIMP CMMSeq::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
    // clear the dirty bit if requested
    if (dwFlags & PVIO_CLEARDIRTY)
        m_fDirty = FALSE;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
// IDispatch Implementation
//

STDMETHODIMP CMMSeq::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CMMSeq::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
	HRESULT hr = E_POINTER;

	if (NULL != pptinfo)
	{
		*pptinfo = NULL;

		if(itinfo == 0)
		{
			m_pTypeInfo->AddRef();
			*pptinfo = m_pTypeInfo;
			hr = S_OK;
		}
		else
		{
			hr = DISP_E_BADINDEX;
		}
    }

    return hr;
}

STDMETHODIMP CMMSeq::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{

	return ::DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}


STDMETHODIMP CMMSeq::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
	return ::DispInvoke((IMMSeq *)this,
		m_pTypeInfo,
		dispidMember, wFlags, pdispparams,
		pvarResult, pexcepinfo, puArgErr);
}


//
// IMMSeq implementation
//

STDMETHODIMP
CMMSeq::get_Time (THIS_ double FAR* pdblCurrentTime)
{
	HRESULT hr = E_POINTER;

	ASSERT(NULL != pdblCurrentTime);
	if (NULL != pdblCurrentTime)
	{
		hr = E_FAIL;

		ASSERT(NULL != m_pActionSet);
		if (NULL != m_pActionSet)
		{

			if (IsBusy() || m_pActionSet->IsPaused() || m_pActionSet->IsServicingActions())
			{
				DWORD dwCurrentMS = 0;
				hr = m_pActionSet->GetTime(&dwCurrentMS);
				*pdblCurrentTime = (double)dwCurrentMS;
			}
			else
			{
				*pdblCurrentTime = (double)m_dwPlayFrom;
				hr = S_OK;
			}
			(*pdblCurrentTime) /= 1000.0;
		}
	}

	return hr;
}

STDMETHODIMP
CMMSeq::put_Time (THIS_ double dblCurrentTime)
{
	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		m_pActionSet->Seek((DWORD)(dblCurrentTime * 1000.0));
	}
	return S_OK;
}


STDMETHODIMP 
CMMSeq::get_PlayState (THIS_ int FAR * piPlayState)
{
	HRESULT hr = E_FAIL;

	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		ASSERT(NULL != piPlayState);
		if (NULL != piPlayState)
		{
			if (m_pActionSet->IsBusy())
			{
				*piPlayState = (int)SEQ_PLAYING;
			}
			else if (m_pActionSet->IsPaused())
			{
				*piPlayState = (int)SEQ_PAUSED;
			}
			else
			{
				*piPlayState = (int)SEQ_STOPPED;
			}
			hr = S_OK;
		}
		else
		{
			hr = E_POINTER;
		}
	}

	return hr;
}

STDMETHODIMP
CMMSeq::Play (void)
{
	HRESULT hr = E_FAIL;
	BOOL fPlayed = FALSE;

	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		// If we're already playing, leave things be.
		if (!IsBusy() && (!m_pActionSet->IsPaused()))
		{
			ITimer * piTimer = NULL;

			if (SUCCEEDED(FindTimer(&piTimer)))
			{
				DeriveDispatches();
				hr = m_pActionSet->Play(piTimer, m_dwPlayFrom);
				piTimer->Release();
				m_dwPlayFrom = 0;
				fPlayed = TRUE;
			}
		}
		// If we're paused, resume playing.
		else if (m_pActionSet->IsPaused())
		{
			hr = m_pActionSet->Resume();
			fPlayed = TRUE;
		}
		// Already playing.
		else
		{
			hr = S_OK;
		}
	}

	if (SUCCEEDED(hr) && m_pconpt && fPlayed)
	{
	 	m_pconpt->FireEvent(DISPID_SEQ_EVENT_ONPLAY, VT_I4, m_lCookie, NULL);
	}

	return hr;
}


STDMETHODIMP
CMMSeq::Pause (void)
{
	HRESULT hr = E_FAIL;
	BOOL fWasPlaying = IsBusy();

	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		hr = m_pActionSet->Pause();
	}

	if (SUCCEEDED(hr) && m_pconpt && fWasPlaying)
	{
	 	m_pconpt->FireEvent(DISPID_SEQ_EVENT_ONPAUSE, VT_I4, m_lCookie, NULL);
	}
	return hr;
}


STDMETHODIMP
CMMSeq::Stop (void)
{
	HRESULT hr = E_FAIL;
	BOOL fStopped = FALSE;

	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		if (IsBusy() || (m_pActionSet->IsPaused()))
		{
			hr = m_pActionSet->Stop();
			fStopped = TRUE;
		}
		else
		{
			// Already stopped.
			hr = S_OK;
		}
	}

	if (SUCCEEDED(hr) && fStopped)
	{
		FireStoppedEvent();
	}
	return hr;
}


void
CMMSeq::FireStoppedEvent (void)
{
	if (NULL != m_pconpt)
	{
	 	m_pconpt->FireEvent(DISPID_SEQ_EVENT_ONSTOP, VT_I4, m_lCookie, NULL);
	}
}


void
CMMSeq::NotifyStopped (void)
{
	FireStoppedEvent();
}


HRESULT 
CMMSeq::GetSiteContainer (LPOLECONTAINER * ppiContainer)
{
	HRESULT hr = E_FAIL;
	
	if ((NULL != m_pocs) && (NULL != ppiContainer))
	{
		hr = m_pocs->GetContainer(ppiContainer);
	}

	return hr;
}


BOOL
CMMSeq::FurnishDefaultAtParameters (VARIANT * pvarStartTime, VARIANT * pvarRepeatCount, VARIANT * pvarSampleRate,
                                                            VARIANT * pvarTiebreakNumber, VARIANT * pvarDropTolerance)
{
	BOOL fValid = TRUE;

	// Supply plausible default values or convert any 
	// incoming variant types to types we expect.

	if (VT_R8 != V_VT(pvarStartTime))
	{
		fValid = SUCCEEDED(VariantChangeType(pvarStartTime, pvarStartTime, 0, VT_R8));
		ASSERT(fValid);
	}

	if (fValid)
	{
		if (VT_ERROR == V_VT(pvarRepeatCount))
		{
			VariantClear(pvarRepeatCount);
			V_VT(pvarRepeatCount) = VT_I4;
			V_I4(pvarRepeatCount) = SEQ_DEFAULT_REPEAT_COUNT;
		}
		else if (VT_I4 != V_VT(pvarRepeatCount))
		{
			fValid = SUCCEEDED(VariantChangeType(pvarRepeatCount, pvarRepeatCount, 0, VT_I4));
			ASSERT(fValid);
		}
	}

	if (fValid)
	{
		if (VT_ERROR == V_VT(pvarSampleRate))
		{
			VariantClear(pvarSampleRate);
			V_VT(pvarSampleRate) = VT_R8;
			V_R8(pvarSampleRate) = (double)SEQ_DEFAULT_SAMPLING_RATE;
		}
		else if (VT_R8 != V_VT(pvarSampleRate))
		{
			fValid = SUCCEEDED(VariantChangeType(pvarSampleRate, pvarSampleRate, 0, VT_R8));
			ASSERT(fValid);
		}
	}

	if (fValid)
	{
		if (VT_ERROR == V_VT(pvarTiebreakNumber))
		{
			VariantClear(pvarTiebreakNumber);
			V_VT(pvarTiebreakNumber) = VT_I4;
			V_I4(pvarTiebreakNumber) = SEQ_DEFAULT_TIEBREAK;
		}
		else if (VT_I4 != V_VT(pvarTiebreakNumber))
		{
			fValid = SUCCEEDED(VariantChangeType(pvarTiebreakNumber, pvarTiebreakNumber, 0, VT_I4));
			ASSERT(fValid);
		}
	}

	if (fValid)
	{
		if (VT_ERROR == V_VT(pvarDropTolerance))
		{
			VariantClear(pvarDropTolerance);
			V_VT(pvarDropTolerance) = VT_R8;
			V_R8(pvarDropTolerance) = (double)SEQ_DEFAULT_DROPTOL;
		}
		else if (VT_R8 != V_VT(pvarDropTolerance))
		{
			fValid = SUCCEEDED(VariantChangeType(pvarDropTolerance, pvarDropTolerance, 0, VT_R8));
			ASSERT(fValid);
		}
	}

	return fValid;
}


STDMETHODIMP
CMMSeq::At (VARIANT varStartTime, BSTR bstrScriptlet,
			         VARIANT varRepeatCount, VARIANT varSampleRate,
					 VARIANT varTiebreakNumber, VARIANT varDropTolerance)
{
	HRESULT hr = DISP_E_TYPEMISMATCH;

	if (VT_ERROR != V_VT(&varStartTime) &&
		FurnishDefaultAtParameters(&varStartTime, &varRepeatCount, &varSampleRate, &varTiebreakNumber, &varDropTolerance))
	{
		Proclaim(NULL != m_pActionSet);
		if (NULL != m_pActionSet)
		{
			hr = m_pActionSet->At(bstrScriptlet, V_R8(&varStartTime), V_I4(&varRepeatCount), V_R8(&varSampleRate),
											   V_I4(&varTiebreakNumber), V_R8(&varDropTolerance));
		}
	}

	return hr;
}


STDMETHODIMP 
CMMSeq::Clear (void)
{
	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		m_pActionSet->Clear();
	}
	return S_OK;
}


STDMETHODIMP 
CMMSeq::Seek(double dblSeekTime)
{
	HRESULT hr = DISP_E_OVERFLOW;

	if (0.0 <= dblSeekTime)
	{
		if (NULL != m_pActionSet)
		{
			if (IsBusy() || m_pActionSet->IsPaused())
			{
				hr = put_Time(dblSeekTime);
			}
			else
			{
				m_dwPlayFrom = (DWORD)(dblSeekTime * 1000);
				hr = S_OK;
			}
		}
		else
		{
			hr = E_FAIL;
		}
	}

    if (SUCCEEDED(hr) && !m_fSeekFiring && (NULL != m_pconpt))
    {
        m_fSeekFiring = TRUE;
        m_pconpt->FireEvent(DISPID_SEQ_EVENT_ONSEEK, VT_I4, m_lCookie, VT_R8, dblSeekTime, NULL);
        m_fSeekFiring = FALSE;
    }

    return hr;
}

/*-----------------------------------------------------------------------------
@method | SCODE | CMMSeq | DeriveDispatches | Resolve all of the actions in the sequencer.
-----------------------------------------------------------------------------*/
HRESULT
CMMSeq::DeriveDispatches (void)
{
	HRESULT hr = E_FAIL;
	LPOLECONTAINER piocContainer = NULL;

	ASSERT(NULL != m_pocs);
	ASSERT(NULL != m_pActionSet);

	if ((NULL != m_pocs) && (NULL != m_pActionSet) &&
		(SUCCEEDED( m_pocs->GetContainer(&piocContainer))))
	{
		hr = m_pActionSet->DeriveDispatches(piocContainer);
		piocContainer->Release();
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CMMSeq | FindTimer | Finds a timer provided by the container.
@rdesc	Returns success or failure code.
@xref	<m CMMSeq::FindTimer>
-----------------------------------------------------------------------------*/
HRESULT
CMMSeq::FindContainerTimer (ITimer ** ppiTimer)
{
	HRESULT hr = E_FAIL;
	LPUNKNOWN piUnkSite = NULL;

	IServiceProvider * piServiceProvider = NULL;

	ASSERT(NULL != m_pocs);
	if ((NULL != m_pocs) && SUCCEEDED(hr = m_pocs->QueryInterface(IID_IServiceProvider, (LPVOID *)&piServiceProvider)))
	{
		ITimerService * piTimerService = NULL;

		if (SUCCEEDED(hr = piServiceProvider->QueryService(IID_ITimerService, IID_ITimerService, (LPVOID *)&piTimerService)))
		{
			hr = piTimerService->CreateTimer(NULL, ppiTimer);
			ASSERT(NULL != ppiTimer);
			piTimerService->Release();
		}
		piServiceProvider->Release();
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CMMSeq | FindTimer | Finds a timer provided by a registered server.
@rdesc	Returns success or failure code.
@xref	<m CMMSeq::FindTimer>
-----------------------------------------------------------------------------*/
HRESULT
CMMSeq::FindDefaultTimer (ITimer ** ppiTimer)
{
	HRESULT hr = E_FAIL;
	ITimerService * pITimerService = NULL;

	// Get the timer service.  From this, we can create a timer for ourselves.
	hr = CoCreateInstance(CLSID_TimerService, NULL, CLSCTX_INPROC_SERVER, IID_ITimerService, (LPVOID *)&pITimerService);
	ASSERT(SUCCEEDED(hr) && (NULL != pITimerService));
	if (SUCCEEDED(hr) && (NULL != pITimerService))
	{
		// Create a timer, using no reference timer.
		hr = pITimerService->CreateTimer(NULL, ppiTimer);
		pITimerService->Release();
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CMMSeq | FindTimer | Finds a timer provided either by the container or from a registered server.
@rdesc	Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CMMSeq::FindTimer (ITimer ** ppiTimer)
{
	HRESULT hr = E_FAIL;

	if (FAILED(hr = FindContainerTimer(ppiTimer)))
	{
		hr = FindDefaultTimer(ppiTimer);
	}

	ASSERT(NULL != (*ppiTimer));

	return hr;
}


//
// IMMSeq methods
//

BOOL
CMMSeq::IsBusy (void)
{
	BOOL fBusy = FALSE;

	if (NULL != m_pActionSet)
	{
		fBusy = m_pActionSet->IsBusy();
	}

	return fBusy;
}

// End of file: control.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\path\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"
#include "pathctl.h"
#include "pathinit.h"


//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
HINSTANCE       g_hinst;        // DLL instance handle
ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfo;      // information about the control

#ifdef _DEBUG
BOOL			g_fLogDebugOutput; // Controls logging of debug info
#endif

//#define USELOGGING
extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE("PathCtl DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;
#ifdef _DEBUG
#ifdef USELOGGING
		g_fLogDebugOutput = TRUE;
#else
		g_fLogDebugOutput = FALSE;
#endif // USELOGGING
#endif // USELOGGING

        InitPathControlInfo(hInst, &g_ctlinfo, AllocPathControl);
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE("PathCtl DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    return RegisterControls(&g_ctlinfo, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
	return RegisterControls(&g_ctlinfo, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\path\pathinit.cpp ===
/*++

Module: 
	pathinit.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Performs control-specific initialisation

History:
	05-24-1997	Created (SimonB)

++*/

#include "..\ihbase\ihbase.h"
#include "..\mmctl\inc\ochelp.h" // for ControlInfo
#include "pathinit.h"
#include "..\resource.h"
#include <daxpress.h>

extern ULONG g_cLock;


void InitPathControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.PathControl");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Path");
    pCtlInfo->pclsid = &CLSID_PathControl;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = TEXT("1.0");
    pCtlInfo->iToolboxBitmapID = IDB_ICON_PATH;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_CONTROL | CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING | CI_MMCONTROL;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\path\pathctl.cpp ===
/*==========================================================================*\

    Module:
            pathctl.cpp

    Author:
            IHammer Team (SimonB)

    Created:
            May 1997

    Description:
            Implements any control-specific members, as well as the control's interface

    History:

\*==========================================================================*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "pathctl.h"
#include "pathevnt.h"
#include "ctstr.h"
#include <parser.h>
#include <strwrap.h>

/*==========================================================================*/

// NOTE:
//
// The following DISPID comes from the Scripting group (ShonK specifically).
// It's not part of any header files at this point, so we define it locally.
//
// SimonB, 06-11-1997
//

#define DISPID_GETSAFEARRAY   -2700

// Define the number of characters per point for Shape persistence
#define CHARSPERNUMBER 16

/*==========================================================================*/
//
// CPathCtl Creation/Destruction
//

#define NUMSHAPES               6

#define SHAPE_INVALID         (-1)
#define SHAPE_OVAL              0
#define SHAPE_RECT              1
#define SHAPE_POLYLINE          2
#define SHAPE_POLYGON           3
#define SHAPE_SPLINE            4
#define SHAPE_POLYSPLINETIME    5

typedef struct tagShapeInfo
{
    TCHAR  rgchShapeName[11];   // The string representation
    BOOL   fIncludesPointCount; // Is the first param the point count ?
    int    iParamsPerPoint;     // How many parameters are expected (per element or in total)
} ShapeInfo;

const ShapeInfo g_ShapeInfoTable[NUMSHAPES] = 
{
    { TEXT("OVAL"),       FALSE, 4 },
    { TEXT("RECT"),       FALSE, 4 },
    { TEXT("POLYLINE"),   TRUE,  2 }, 
    { TEXT("POLYGON"),    TRUE,  2 },
    { TEXT("SPLINE"),     TRUE,  2 },
    { TEXT("KEYFRAME"),   TRUE,  3 }
};

LPUNKNOWN __stdcall AllocPathControl(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr;

    CPathCtl *pthis = New CPathCtl(punkOuter, &hr);

    if (pthis == NULL)
        return NULL;

    if (FAILED(hr))
    {
        delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

/*==========================================================================*/
//
// Beginning of class implementation
//

CPathCtl::CPathCtl(IUnknown *punkOuter, HRESULT *phr):
        CMyIHBaseCtl(punkOuter, phr),
    m_ptmFirst(NULL),
    m_fOnWindowLoadFired(false)
{
    // Initialise members
    m_bRelative = false;
    m_pointRelative.x = 0;
    m_pointRelative.y = 0;

    m_dblDuration = 0.0f;
    m_enumPlayState = Stopped;
    m_enumDirection = Forward;
    m_lRepeat = 1;
    m_fBounce = FALSE;
    m_bstrTarget = NULL;
    m_fStarted = FALSE;
    m_fAlreadyStartedDA = FALSE;
    m_lBehaviorID = 0;
    m_fAutoStart = FALSE;
    m_ea = eaInvalid;
    m_pdblPoints = NULL;
    m_iNumPoints = 0;
    m_iShapeType = -1; // Invalid shape
    m_dblTimerInterval = 0.1; // Default Timer Interval
    m_fOnSeekFiring = false;
    m_fTargetValidated = false;
    m_fOnStopFiring = false;
    m_fOnPlayFiring = false;
    m_fOnPauseFiring = false;

    // Tie into the DANIM DLL now...
    if (phr)
    {
        if (SUCCEEDED(*phr))
        {
            *phr = CoCreateInstance(
                CLSID_DAView,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAView,
                (void **) &m_ViewPtr);
        }

        if (SUCCEEDED(*phr))
        {
            *phr = ::CoCreateInstance(
                CLSID_DAStatics,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAStatics,
                (void **) &m_StaticsPtr);
        }

        if (SUCCEEDED(*phr))
        {
            m_bstrLanguage = SysAllocString(L"VBScript");

            //
            // setup all the time stuff
            //

            DoStop();
        }

        m_clocker.SetSink((CClockerSink *)this);
//        m_clocker.SetTimerType(CClocker::CT_WMTimer);
    }
}
        
/*==========================================================================*/

CPathCtl::~CPathCtl()
{
    StopModel();

    //if (m_fStarted && m_ViewPtr) {
    if (m_ViewPtr)
    {
        if (m_fStarted)
        {
            m_ViewPtr->RemoveRunningBvr(m_lBehaviorID);
        }

        //always need to call StopModel on the view.
        m_ViewPtr->StopModel();
    }

    if (m_bstrTarget)
    {
        SysFreeString(m_bstrTarget);
        m_bstrTarget = NULL;
    }

    if (m_bstrLanguage)
    {
        SysFreeString(m_bstrLanguage);
        m_bstrLanguage = NULL;
    }

    m_drgXSeries.MakeNullAndDelete();
    m_drgYSeries.MakeNullAndDelete();

    if (NULL != m_pdblPoints)
        Delete [] m_pdblPoints;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
        HRESULT hRes = S_OK;
        BOOL fMustAddRef = FALSE;

    if (ppv)
        *ppv = NULL;
    else
        return E_POINTER;

#ifdef _DEBUG
    char ach[200];
    TRACE("PathCtl::QI('%s')\n", DebugIIDName(riid, ach));
#endif

        if ((IsEqualIID(riid, IID_IPathCtl)) || (IsEqualIID(riid, IID_IDispatch)))
        {
                if (NULL == m_pTypeInfo)
                {
                        HRESULT hRes;
                        
                        // Load the typelib
                        hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_IPathCtl, LIBID_DAExpressLib, NULL);

                        if (FAILED(hRes))
                        {
                                m_pTypeInfo = NULL;
                        }
                        else    
                                *ppv = (IPathCtl *) this;

                }
                else
                        *ppv = (IPathCtl *) this;
                
        }
    else // Call into the base class
        {
                DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);

        }

    if (NULL != *ppv)
        {
                DEBUGLOG("PathCtl: Interface supported in control class\n");
                ((IUnknown *) *ppv)->AddRef();
        }

    return hRes;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
        HRESULT hr = S_OK;
    UINT iDirection = (UINT) m_enumDirection;

        BOOL fIsLoading = (S_OK == pvio->IsLoading());
    BOOL fRelative = m_bRelative;

    if (fIsLoading)
    {
        if (m_bstrTarget)
        {
            SysFreeString(m_bstrTarget);
            m_bstrTarget = NULL;
        }
    }

    if (FAILED(hr = pvio->Persist(0,
        "Autostart",     VT_BOOL, &m_fAutoStart,
        "Bounce",        VT_BOOL, &m_fBounce,
        "Direction",     VT_I4,   &iDirection,
        "Duration",      VT_R8,   &m_dblDuration,
        "Repeat",        VT_I4,   &m_lRepeat,
        "Target",        VT_BSTR, &m_bstrTarget,
        "Relative",      VT_BOOL, &fRelative,
        NULL)))
        return hr;


    if (fIsLoading)
    {
        m_fTargetValidated = false;

        m_bRelative = (boolean) fRelative;
        if (FAILED(hr = pvio->Persist(0,
            "TimerInterval", VT_R8,   &m_dblTimerInterval,
            NULL)))
            return hr;

        if (S_OK != hr)
        {
            int iTickInterval = 0;

            if (FAILED(hr = pvio->Persist(0,
                "TickInterval", VT_I4, &iTickInterval,
                NULL)))
                return hr;
            else if (S_OK == hr)
                m_dblTimerInterval = ((double)iTickInterval) / 1000;
        }

        // Do range checking and conversions, using defaults where invalid values are specified
        if ( (iDirection == 0) || (iDirection == 1) )
            m_enumDirection = (DirectionConstant) iDirection;
        else
            m_enumDirection = Forward; 
        
        if (m_lRepeat < -1)
            m_lRepeat = -1 * m_lRepeat;

        if (FAILED(hr = pvio->Persist(0,
            "EdgeAction", VT_I2, &m_ea,
            NULL)))
            return hr;

        switch (m_ea)
        {
            case eaStop:
            {
                m_lRepeat = 1;
                m_fBounce = FALSE;
            }
            break;

            case eaReverse:
            {
                m_lRepeat = -1;
                m_fBounce = TRUE;
            }
            break;

            case eaWrap:
            {
                m_lRepeat = -1;
                m_fBounce = FALSE;
            }
            break;
        }
    }
    else // Saving
    {
        // EdgeAction
        if (m_ea != eaInvalid)
            pvio->Persist(0,
                "EdgeAction", VT_I4, &m_ea,
                 NULL);

        if (FAILED(hr = pvio->Persist(0,
             "TimerInterval", VT_R8,   &m_dblTimerInterval,
             NULL)))
             return hr;
    }


    if (FAILED(PersistTimeMarkers(pvio, fIsLoading)))
        {} // Ignore failure

    if (FAILED(PersistSeries(pvio, fIsLoading, "XSeries", &m_drgXSeries)))
        {} // Ignore failure

    if (FAILED(PersistSeries(pvio, fIsLoading, "YSeries", &m_drgYSeries)))
        {} // Ignore failure

    if (FAILED(PersistShape(pvio, fIsLoading)))
        {} // Ignore failure

    // clear the dirty bit if requested
    if (dwFlags & PVIO_CLEARDIRTY)
        m_fDirty = FALSE;

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    HRESULT hr = S_OK;
    
    if (FAILED(hr = CMyIHBaseCtl::GetMiscStatus(dwAspect, pdwStatus)))
        return hr;
    
    *pdwStatus |= OLEMISC_INVISIBLEATRUNTIME;

    return S_OK;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
     DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
     LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
     BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue)
{

    HBRUSH          hbr;            // brush to draw with
    HBRUSH          hbrPrev;        // previously-selected brush
    HPEN            hpenPrev;       // previously-selected pen

    if (m_fDesignMode)
    {
        if ((hbr = (HBRUSH) GetStockObject(WHITE_BRUSH)) != NULL)
        {

            hbrPrev = (HBRUSH) SelectObject(hdcDraw, hbr);
            hpenPrev = (HPEN) SelectObject(hdcDraw, GetStockObject(BLACK_PEN));
            Rectangle(hdcDraw, 
                m_rcBounds.left, m_rcBounds.top,
                m_rcBounds.right, m_rcBounds.bottom);

            SelectObject(hdcDraw, hbrPrev);
            SelectObject(hdcDraw, hpenPrev);
            DeleteObject(hbr);
        }
    }
    return S_OK;
}

/*==========================================================================*/
//
// IDispatch Implementation
//

STDMETHODIMP CPathCtl::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
        
        *pptinfo = NULL;

    if(itinfo != 0)
        return ResultFromScode(DISP_E_BADINDEX);

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;

    return NOERROR;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{

        return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
        HRESULT hr;

        hr = DispInvoke((IPathCtl *)this,
                m_pTypeInfo,
                dispidMember, wFlags, pdispparams,
                pvarResult, pexcepinfo, puArgErr);

        return hr;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = CMyIHBaseCtl::SetClientSite(pClientSite);

    if (m_ViewPtr)
    {
        m_ViewPtr->put_ClientSite(pClientSite);
    }
    m_clocker.SetHost(pClientSite);
    m_ViewPtr->put_ClientSite(pClientSite);
    m_StaticsPtr->put_ClientSite(pClientSite);

    if (!pClientSite)
        StopModel();

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::AddTimeMarkerElement(CTimeMarker **ppNewMarker)
{
        HRESULT hRes = S_OK;

        if ( (*ppNewMarker) && (NULL != (*ppNewMarker)->m_pwszMarkerName) )
        {
                m_drgTimeMarkers.Insert(*ppNewMarker);
        }
        else
        {
                if (NULL != *ppNewMarker)
                {
                        Delete *ppNewMarker;
                        *ppNewMarker = NULL;
                }

                hRes = E_OUTOFMEMORY;
        }

        return hRes;
}

/*==========================================================================*/

HRESULT CPathCtl::PersistTimeMarkers(IVariantIO* pvio, BOOL fLoading)
{
        HRESULT hRes = S_OK;

        if (fLoading)
        {
                int iLine = 1;

                // Poor design - We have two references to 
                // the first time marker in the list.  We need
                // to NULL this pointer out, and defer the 
                // actual deletion to the 
                // m_drgTimeMarkers.MakeNullAndDelete call.
                if (NULL != m_ptmFirst)
                {
                        m_ptmFirst = NULL;
                }
                m_drgTimeMarkers.MakeNullAndDelete();
                CTimeMarker *pTimeMarker;

                while (S_OK == hRes)
                {
            hRes = ParseTimeMarker(pvio, iLine++, &pTimeMarker, &m_ptmFirst);
                        if (S_OK == hRes)
                        {
                                hRes = AddTimeMarkerElement(&pTimeMarker);
                        }
                }
        }
        else // Saving
        {
                int iLine = 1;
                int iNumItems = m_drgTimeMarkers.Count();

                while ( (iLine <= iNumItems) && (S_OK == hRes) )
                {
                        hRes = WriteTimeMarker(pvio, iLine, m_drgTimeMarkers[iLine - 1]);
                        iLine++;
                }

        }
        return hRes;
}

/*==========================================================================*/

HRESULT CPathCtl::ParseSeriesSegment(LPTSTR pszSegment, CSeriesMarker **ppMarker)
{
    HRESULT hr = S_OK;

    if (ppMarker == NULL)
        return E_POINTER;

    *ppMarker = NULL;
    
    CLineParser SegmentParser(pszSegment, FALSE);
    
    if (SegmentParser.IsValid())
    {
        int iTick = 0, iPosition = 0;
        HRESULT hrLine = S_OK;

        SegmentParser.SetCharDelimiter(TEXT(','));

        if (S_OK != (hrLine = SegmentParser.GetFieldInt(&iTick, TRUE)))
        {
            hr = E_FAIL;
        }
        else
        {
            if (S_FALSE != (hrLine = SegmentParser.GetFieldInt(&iPosition, TRUE)))
            {
                hr = E_FAIL;
            }
            else
            {
                // Got both field successfully
                *ppMarker = New CSeriesMarker(iTick, iPosition);
                if (NULL == *ppMarker)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;

}

/*==========================================================================*/

HRESULT CPathCtl::PersistSeries(IVariantIO* pvio, BOOL fLoading, LPSTR pszSeriesName, CSeriesMarkerDrg *pSeriesDrg)
{
    HRESULT hr = S_OK;

    if (fLoading)
    {
        pSeriesDrg->MakeNullAndDelete();
        BSTR bstrLine = NULL;
        
        hr = pvio->Persist(0,
            pszSeriesName, VT_BSTR, &bstrLine,
            NULL);
        
        if ((S_OK != hr) || (NULL == bstrLine))
        {
            if (S_FALSE == hr)
                hr = S_OK;

            return hr;
        }

        // Got the string, now parse it out ...
        CLineParser LineParser(bstrLine);
        CTStr tstrSegment(lstrlenW(bstrLine));
        LPTSTR pszSegment = tstrSegment.psz();
        CSeriesMarker *pMarker = NULL;

        SysFreeString(bstrLine);

        if ( (!LineParser.IsValid()) || (NULL == pszSegment) )
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        
        LineParser.SetCharDelimiter(TEXT(';'));

        while (S_OK == hr)
        {
            HRESULT hrLine = S_OK;
            
            hr = LineParser.GetFieldString(pszSegment, TRUE);
            if (SUCCEEDED(hr))
            {
                if (SUCCEEDED(hrLine = ParseSeriesSegment(pszSegment, &pMarker)))
                {
                    if (!pSeriesDrg->Insert(pMarker))
                        hr = E_FAIL;
                }
            }
            
            if (FAILED(hrLine))
                hr = hrLine;
        }
    }
    else // Save
    {
        int iCount = pSeriesDrg->Count();

        if (0 == iCount)
            return S_OK;

        CTStr tstrLine(iCount * 50); // Allocate 50 chars per entry
        LPTSTR pszLine = tstrLine.psz();

        CTStr tstrSegment(50);
        LPSTR pszSegment = tstrSegment.psz();

        if ( (NULL == pszLine) || (NULL == pszSegment) )
            hr = E_OUTOFMEMORY;
        else
        {
            int i = 0, iFmt = 0;
            CSeriesMarker *pMarker = NULL;
            TCHAR tchFormat[][10] = { TEXT("%lu,%lu"), TEXT(";%lu,%lu")};

            while (i < iCount)
            {
                pMarker = (*pSeriesDrg)[i];
                
                wsprintf(pszSegment, tchFormat[iFmt], pMarker->m_iTickNumber, pMarker->m_iPosition);
                
                iFmt = (i > 0 ? 1 : 0);

                CStringWrapper::Strcat(pszLine, pszSegment);
                
                i++;
            }

            BSTR bstrLine = tstrSegment.SysAllocString();
            hr = pvio->Persist(0,
                pszSeriesName, VT_BSTR, &bstrLine,
                NULL);

            SysFreeString(bstrLine);
        }
    }

    return hr;
}


/*==========================================================================*/
//
// IPathCtl implementation
//

HRESULT STDMETHODCALLTYPE CPathCtl::get_Target(BSTR __RPC_FAR *bstrTarget)
{
    HANDLENULLPOINTER(bstrTarget);

    if (m_bstrTarget)
    {
        // Give back a copy of our current target name...
        *bstrTarget = SysAllocString(m_bstrTarget);
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Target(BSTR bstrTarget)
{
    HRESULT hr = S_OK;

    if (m_bstrTarget)
    {
        SysFreeString(m_bstrTarget);
        m_bstrTarget = NULL;
    }

    m_bstrTarget = SysAllocString(bstrTarget);

    hr = (m_bstrTarget != NULL) ? S_OK : E_POINTER;
    
    if (SUCCEEDED(hr))
        m_fTargetValidated = false;

    
    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Duration(double __RPC_FAR *dblDuration)
{
    HANDLENULLPOINTER(dblDuration);

    *dblDuration = m_dblDuration;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Duration(double dblDuration)
{
    m_dblDuration = dblDuration;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_TimerInterval(double __RPC_FAR *pdblTimerInterval)
{
    HANDLENULLPOINTER(pdblTimerInterval);

    *pdblTimerInterval = m_dblTimerInterval;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_TimerInterval(double dblTimerInterval)
{
    m_dblTimerInterval = dblTimerInterval;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Library(IDAStatics __RPC_FAR **ppLibrary)
{
    HANDLENULLPOINTER(ppLibrary);

        if (!m_fDesignMode)
        {
                if (m_StaticsPtr)
                {
                        // AddRef since this is really a Query...
                        m_StaticsPtr.p->AddRef();

                        // Set the return value...
                        *ppLibrary = m_StaticsPtr.p;
                }
        }
        else
        {
                return CTL_E_GETNOTSUPPORTED;
        }

    return S_OK;
}



/*==========================================================================*/

// Yanked largely (and modified) from DirectAnimation, server\cbvr.cpp.

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)

class CSafeArrayOfDoublesAccessor
{
  public:
    CSafeArrayOfDoublesAccessor(VARIANT v, HRESULT *phr);
    ~CSafeArrayOfDoublesAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    HRESULT ToDoubleArray(unsigned int size, double *array);

    bool IsNullArray() {
                return (_s == NULL);
    }
    
  protected:
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        double * _pDbl;
        IUnknown ** _ppUnk;
        void *_v;
    };
    
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    unsigned int _numObjects;
    CComVariant _retVar;
};

CSafeArrayOfDoublesAccessor::CSafeArrayOfDoublesAccessor(VARIANT v,
                                                                                                                 HRESULT *phr)
: _inited(false),
  _isVar(false),
  _s(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
                        *phr = DISP_E_TYPEMISMATCH;
                        return;
                }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LOCALE_USER_DEFAULT,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
                        *phr = DISP_E_TYPEMISMATCH;
                        return;
                }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
                        *phr = DISP_E_TYPEMISMATCH;
                        return;
                }
    }
    
    // If it is an object then we know how to handle it
    if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
        !IS_VARTYPE(pVar,VT_DISPATCH)) {
                
        // If it is a variant then just delay the check
        if (IS_VARIANT(pVar)) {
            _isVar = true;
                        // Check the type to see if it is one of the options
                } else if (IS_VARTYPE(pVar, VT_R8)) {
                        _isVar = false;
                } else {
                        *phr = DISP_E_TYPEMISMATCH;
                        return;
                }
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (NULL == _s) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
    }

    if (SafeArrayGetDim(_s) != 1) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
        }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
        }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
        }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
        }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        if (GetArraySize() > 0) {
            // Check the first argument to see its type
            // If it is not an object then we assume we will need to
            // use the alternative type.

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

        }
    }

    _numObjects = GetArraySize();
}

CSafeArrayOfDoublesAccessor::~CSafeArrayOfDoublesAccessor()
{
    if (_inited && !IsNullArray())
        SafeArrayUnaccessData(_s);
}

HRESULT
CSafeArrayOfDoublesAccessor::ToDoubleArray(unsigned int size, double *array)
{
        HRESULT hr;

        if (size > _numObjects) {
                return E_INVALIDARG;
        }
        
    if (IsNullArray()) {
                return S_OK;
    }

        for (unsigned int i = 0; i < size; i++) {
                
                double dbl;
                
                if (_isVar) {
                        CComVariant num;
                    
                        hr = ::VariantChangeTypeEx(&num, &_pVar[i], LANGID_USENGLISH, 0, VT_R8);
                    
                        if (FAILED(hr)) {
                                return DISP_E_TYPEMISMATCH;
                        }

                        dbl = num.dblVal;
                } else {
                        dbl = _pDbl[i];
                }

                array[i] = dbl;
        }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::KeyFrame(unsigned int numPoints,
                                                                                         VARIANT varPoints,
                                                                                         VARIANT varTimePoints)
{
        CComPtr<IDANumber> finalTimeBvr;
        CComPtr<IDANumber> interpolator;
        CComPtr<IDAPoint2> splinePoint;
        CComPtr<IDAPath2>  polyline;
        double             accumulation = 0;
    HRESULT            hr = S_OK;
        int                iNumPoints = numPoints;

    if (numPoints < 2) {
        return E_INVALIDARG;
    }

        // Need to go through the points and convert them to an array of
        // Point2's.
        CSafeArrayOfDoublesAccessor safePts(varPoints, &hr);
        if (FAILED(hr)) return hr;
        
        CSafeArrayOfDoublesAccessor safeTimes(varTimePoints, &hr);
        if (FAILED(hr)) return hr;

        int i;
        
        double *safePtsDoubles = New double[iNumPoints * 2];
        double *safeTimesDoubles = New double[iNumPoints - 1];

        typedef IDAPoint2 *IDAPoint2Ptr;
        typedef IDANumber *IDANumberPtr;
        IDAPoint2 **pts = New IDAPoint2Ptr[iNumPoints];
        IDANumber **knots = New IDANumberPtr[iNumPoints];
        
        if (!pts || !knots || !safePtsDoubles || !safeTimesDoubles) {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
        }

        if (FAILED(hr = safePts.ToDoubleArray(iNumPoints*2,
                                                                                  safePtsDoubles)) ||
                FAILED(hr = safeTimes.ToDoubleArray(iNumPoints - 1,
                                                                                        safeTimesDoubles))) {
                hr = E_FAIL;
                goto Cleanup;
        }
        
        // Null out so we can always free exactly what's been allocated
        for (i = 0; i < iNumPoints; i++) {
                pts[i] = NULL;
                knots[i] = NULL;
        }

        // Fill in the points
        double x, y;
        for (i = 0; i < iNumPoints; i++) {
                x = safePtsDoubles[2*i+0];
                y = safePtsDoubles[2*i+1];
                if (FAILED(hr = m_StaticsPtr->Point2(x, y, &pts[i]))) {
                        hr = E_FAIL;
                        goto Cleanup;
                }
        }
        
        // First knot is zero.
        if (FAILED(hr = m_StaticsPtr->DANumber(0, &knots[0]))) {
                goto Cleanup;
        }

        for (i = 1; i < iNumPoints; i++) {
                double interval = safeTimesDoubles[i-1];
                accumulation += interval;
                if (FAILED(hr = m_StaticsPtr->DANumber(accumulation,
                                                                                           &knots[i]))) {
                        goto Cleanup;
                }

        }

        // Release any m_keyFramePoint we may have previously been holding
        // onto.
        m_keyFramePoint.Release();

    m_dblKeyFrameDuration = accumulation;

        if (
           FAILED(hr = m_StaticsPtr->get_LocalTime(&interpolator))
        || FAILED(hr = m_StaticsPtr->Point2BSplineEx(1, iNumPoints, knots, iNumPoints, pts, 0, NULL, interpolator, &m_keyFramePoint))
        || FAILED(hr = m_StaticsPtr->PolylineEx(iNumPoints, pts, &polyline))
       ) {
                goto Cleanup;
        }

        // Although we're going to animate through m_keyFramePoint,
        // provide a polyline that traverses the path so that getPath
        // works correctly.
        hr = UpdatePath(polyline);
    m_isKeyFramePath = true;

Cleanup:
        for (i = 0; i < iNumPoints; i++) {
                if (pts[i]) pts[i]->Release();
                if (knots[i]) knots[i]->Release();
        }

        Delete [] safePtsDoubles;
        Delete [] safeTimesDoubles;
        Delete [] pts;
        Delete [] knots;

        return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Spline(unsigned int iNumPoints, VARIANT varPoints)
{
    HRESULT hr = E_FAIL;

    if (iNumPoints >= 3) {
        VARIANT varKnots;
        double *pArray = NULL;
        SAFEARRAY *psa = NULL;

        psa = SafeArrayCreateVector(VT_R8, 0, iNumPoints + 2);

        if (NULL == psa)
            return E_OUTOFMEMORY;

        // Try and get a pointer to the data
        if (SUCCEEDED(SafeArrayAccessData(psa, (LPVOID *)&pArray)))
        {
            for(unsigned int index = 2; index < iNumPoints; index++) {
                pArray[index] = index;
            }

            pArray[0] = pArray[1] = pArray[2];
            pArray[iNumPoints + 1] = pArray[iNumPoints] = pArray[iNumPoints - 1];

            hr = SafeArrayUnaccessData(psa);
            ASSERT(SUCCEEDED(hr));

            // Our variant is going to be an array of VT_R8s
            VariantInit(&varKnots);
            varKnots.vt = VT_ARRAY | VT_R8;
            varKnots.parray = psa;

            CComPtr<IDAPath2> PathPtr;
            if (SUCCEEDED(hr = m_StaticsPtr->CubicBSplinePath(varPoints, varKnots, &PathPtr))) {

                hr = UpdatePath(PathPtr);
            }
        }

        if (NULL != psa)
        {
            SafeArrayDestroy(psa);
        }

    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Repeat(long __RPC_FAR *lRepeat)
{
    HANDLENULLPOINTER(lRepeat);

    *lRepeat = m_lRepeat;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Repeat(long lRepeat)
{
    m_lRepeat = lRepeat;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Bounce(VARIANT_BOOL __RPC_FAR *fBounce)
{
    HANDLENULLPOINTER(fBounce);

    *fBounce = BOOL_TO_VBOOL(m_fBounce);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Bounce(VARIANT_BOOL fBounce)
{
    m_fBounce = VBOOL_TO_BOOL(fBounce);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_AutoStart(VARIANT_BOOL __RPC_FAR *fAutoStart)
{
    HANDLENULLPOINTER(fAutoStart);

    if (m_fDesignMode)
    {
        *fAutoStart = BOOL_TO_VBOOL(m_fAutoStart);
        return S_OK;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_AutoStart(VARIANT_BOOL fAutoStart)
{
    if (m_fDesignMode)
    {
        m_fAutoStart = VBOOL_TO_BOOL(fAutoStart);
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Relative(VARIANT_BOOL __RPC_FAR *bRelative)
{
    HANDLENULLPOINTER(bRelative);

    *bRelative = BOOL_TO_VBOOL(m_bRelative);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Relative(VARIANT_BOOL bRelative)
{
    m_bRelative = VBOOL_TO_BOOL(bRelative);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_PlayState(PlayStateConstant __RPC_FAR *State)
{
    HANDLENULLPOINTER(State);

    *State = (PlayStateConstant) 0;

    // This property is only available at run-time
    if (m_fDesignMode)
        return CTL_E_GETNOTSUPPORTED;

    *State = m_enumPlayState;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Time(double __RPC_FAR *pdblTime)
{
    HANDLENULLPOINTER(pdblTime);

    // This property is only available at run-time
    if (m_fDesignMode)
        return CTL_E_GETNOTSUPPORTED;

        DWORD dwTick = (DWORD)((m_dblCurrentTick - m_dblBaseTime + 0.0005) * 1000);
    *pdblTime = (double)dwTick / 1000.;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Direction(DirectionConstant __RPC_FAR *Dir)
{
    HANDLENULLPOINTER(Dir);

    *Dir = m_enumDirection;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Direction(DirectionConstant Dir)
{
    if (Dir == 1) {
        m_enumDirection = Backward;
    } else {
        m_enumDirection = Forward;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Path(IDAPath2 __RPC_FAR **ppPath)
{
    HANDLENULLPOINTER(ppPath);

    if (ppPath)
    {
        IDAPath2 *pPath = m_PathPtr;

        if (pPath)
        {
            // AddRef since this is really a Query...
            pPath->AddRef();

            // Set the return value...
            *ppPath = pPath;
        }
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Path(IDAPath2 __RPC_FAR *pPath)
{
    HRESULT hr = S_OK;

    HANDLENULLPOINTER(pPath);

    if (pPath)
    {
        hr = UpdatePath(pPath);
    }

    return hr;
}

/*==========================================================================*/

void FirePathMarker(IConnectionPointHelper* pconpt, CTimeMarker* pmarker, boolean bPlaying)
{
    BSTR bstrName = SysAllocString(pmarker->m_pwszMarkerName);
    if (bPlaying) {
        pconpt->FireEvent(DISPID_PATH_EVENT_ONPLAYMARKER, VT_BSTR, bstrName, 0);
    }

    pconpt->FireEvent(DISPID_PATH_EVENT_ONMARKER, VT_BSTR, bstrName, 0);

    SysFreeString(bstrName);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::AddTimeMarker(double dblTime, BSTR bstrMarker, VARIANT varAbsolute)
{
    HANDLENULLPOINTER(bstrMarker);

    BOOL fAbsolute = TRUE;

    if (!ISEMPTYARG(varAbsolute))
    {
        VARIANT varTarget;
        VariantInit(&varTarget);

        if (SUCCEEDED(VariantChangeTypeEx(&varTarget, &varAbsolute, LANGID_USENGLISH, 0, VT_BOOL)))
            fAbsolute = VBOOL_TO_BOOL(V_BOOL(&varTarget));
        else
            return DISP_E_TYPEMISMATCH;
    }

    if (dblTime < 0) {
        return E_FAIL;
    }

    CTimeMarker *pNewMarker = New CTimeMarker(&m_ptmFirst, dblTime, bstrMarker, (boolean) fAbsolute);

        return AddTimeMarkerElement(&pNewMarker);
}

/*==========================================================================*/

void CPathCtl::DoPause(void)
{
     m_dblCurrentTick =
      m_dblTimePaused = GetCurrTime();
}

/*==========================================================================*/

void CPathCtl::DoSeek(double dblTime)
{
    double dblDelta = dblTime - m_dblPreviousTime;

    if (dblTime > m_dblPreviousTime) {
        if (m_fOnWindowLoadFired) {
            FireMarkersBetween(
                m_pconpt,
                m_ptmFirst,
                FirePathMarker,
                m_dblPreviousTime,
                dblTime,
                m_dblInstanceDuration,
                Playing == m_enumPlayState
            );
        }
    }

    SetTimeOffset(m_dblTimeOffset - dblDelta);

    m_dblBaseTime = m_dblCurrentTick - dblTime;

    m_dblPreviousTime = dblTime;
}

/*==========================================================================*/

void CPathCtl::DoResume()
{
    double dblDelta = GetCurrTime() - m_dblTimePaused;

    m_dblTickBaseTime += dblDelta;
    m_dblBaseTime     += dblDelta;
    m_dblCurrentTick  += dblDelta;
}

/*==========================================================================*/

void CPathCtl::DoStop()
{
    m_dblTickBaseTime =
        m_dblBaseTime =
        m_dblTimePaused =
        m_dblCurrentTick = GetCurrTime();

    m_dblPreviousTime = 0;
    SetTimeOffset(0);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Stop(void)
{
    HRESULT hr = S_OK;

    if (m_enumPlayState != Stopped) {
        if (m_enumPlayState == Playing) {
                    if (FAILED(hr = m_clocker.Stop())) return hr;
        }

        if (FAILED(hr = StopModel())) return hr;

        DoStop();

        m_enumPlayState = Stopped;

        FIRE_ONSTOP(m_pconpt);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Pause(void)
{
        HRESULT hr = S_OK;

    if (Playing == m_enumPlayState)
    {
                // Stop the clock from ticking.
                hr = m_clocker.Stop();
                ASSERT(SUCCEEDED(hr));

                if (SUCCEEDED(hr))
                {
            DoPause();
                        m_enumPlayState = Paused;
                }

        FIRE_ONPAUSE(m_pconpt);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE 
CPathCtl::Seek(double dblTime)
{
        if (dblTime < 0) {
        return E_INVALIDARG;

        }

    DoSeek(dblTime);

        FIRE_ONSEEK(m_pconpt, dblTime);

        return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Play(void)
{
    HRESULT hr = S_OK;

    if (Playing != m_enumPlayState) 
    {
        if (Paused != m_enumPlayState) 
        {
            if (m_bRelative) 
            {
                if (FAILED(GetPoint(m_pointRelative))) return hr;
            } 
            else 
            {
                if (!m_fTargetValidated)
                {
                    IHTMLElement *pElement = NULL;

                    // First make sure the target exists by checking in the object model
                    hr = HTMLElementFromName(m_bstrTarget, &pElement);

                    if ((NULL == pElement) || FAILED(hr))
                        return hr;
                    else
                        SafeRelease((LPUNKNOWN *)&pElement);

                }
                m_pointRelative.x = 0;
                m_pointRelative.y = 0;
            }

            m_fTargetValidated = true;

            if (FAILED(hr = StartModel())) return hr;

            VARIANT_BOOL vBool;
            if (FAILED(hr = m_ViewPtr->Tick(0.0001, &vBool))) return hr;
        }

        DoResume();

        m_clocker.SetInterval((int)(m_dblTimerInterval * 1000));
        if (FAILED(hr = m_clocker.Start())) return hr;

        m_enumPlayState = Playing;

        FIRE_ONPLAY(m_pconpt);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Oval(
    double StartX,
    double StartY,
    double Width,
    double Height)
{
    HRESULT hr;

    CComPtr<IDATransform2> translate;
    CComPtr<IDATransform2> rotate;
    CComPtr<IDATransform2> xf1;
    CComPtr<IDATransform2> xf;
    CComPtr<IDAPath2> PathPtr;
    CComPtr<IDAPath2> TransformedPathPtr;

    if (FAILED(hr = m_StaticsPtr->Rotate2(-pi / 2, &rotate))) return hr;
    if (FAILED(hr = m_StaticsPtr->Translate2(StartX + Width / 2, StartY + Height / 2, &translate))) return hr;

    if (FAILED(hr = m_StaticsPtr->Compose2(translate, rotate, &xf))) return hr;

    if (FAILED(hr = m_StaticsPtr->Oval(Height, Width, &PathPtr))) return hr;
    if (FAILED(hr = PathPtr->Transform(xf, &TransformedPathPtr))) return hr;

    return UpdatePath(TransformedPathPtr);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Rect(
    double StartX,
    double StartY,
    double Width,
    double Height)
{
    HRESULT hr;

    CComPtr<IDATransform2> translate;
    CComPtr<IDATransform2> rotate;
    CComPtr<IDATransform2> xf;
    CComPtr<IDAPath2> PathPtr;
    CComPtr<IDAPath2> TransformedPathPtr;

    if (FAILED(hr = m_StaticsPtr->Rotate2(pi, &rotate))) return hr;
    if (FAILED(hr = m_StaticsPtr->Translate2(StartX + Width / 2, StartY + Height / 2, &translate))) return hr;

    if (FAILED(hr = m_StaticsPtr->Compose2(translate, rotate, &xf))) return hr;

    if (FAILED(hr = m_StaticsPtr->Rect(Width, Height, &PathPtr))) return hr;
    if (FAILED(hr = PathPtr->Transform(xf, &TransformedPathPtr))) return hr;

    return UpdatePath(TransformedPathPtr);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Polyline(long nPoints, VARIANT Points)
{
    HRESULT hr = S_FALSE;

    CComPtr<IDAPath2> PathPtr;

    if (SUCCEEDED(hr = m_StaticsPtr->Polyline(Points, &PathPtr)))
    {
        hr = UpdatePath(PathPtr);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Polygon(long nPoints, VARIANT Points)
{
    HRESULT hr = S_FALSE;

    CComPtr<IDAPath2> PathPtr;
    CComPtr<IDAPath2> ClosedPathPtr;

    if (SUCCEEDED(hr = m_StaticsPtr->Polyline(Points, &PathPtr)) &&
        SUCCEEDED(hr = PathPtr->Close(&ClosedPathPtr)))
    {
        hr = UpdatePath(ClosedPathPtr);
    }

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::GetPointArray(long iNumPoints, VARIANT vPoints, double **ppPoints)
{
#ifdef NEEDGETPOINTARRAY
    HRESULT hr = E_POINTER;

    if (ppPoints)
    {
        ASSERT(V_ISARRAY(&vPoints));

        SAFEARRAY *psaPoints;
                
        if (V_VT(&vPoints) & VT_BYREF)
                    psaPoints = *(vPoints.pparray);
            else
                    psaPoints = vPoints.parray;
            
            // Now we check that it's a 1D array
            if (1 != SafeArrayGetDim(psaPoints))
                    return DISP_E_TYPEMISMATCH;

            //
            // Now we make sure it's something we can use
            //

        switch (V_VT(&vPoints) & VT_TYPEMASK)
        {
            // If it's a variant, try and coerce it to something we can use
            case VT_VARIANT:
            {
                        long ix = 0;
                        VARIANTARG vaDest, vaSrc;

                        VariantInit(&vaDest);
                        VariantInit(&vaSrc);
                        // Set the type up
                        SafeArrayGetElement(psaPoints, &ix, &vaSrc);
                        if (FAILED(VariantChangeTypeEx(&vaDest, &vaSrc, LANGID_USENGLISH, 0, VT_R8)))
                                // Couldn't convert
                                return  DISP_E_TYPEMISMATCH;
            }
            break;

            case VT_I2:
            case VT_I4:
            case VT_R4:
            case VT_R8:
            {
                // We support all these types
            }
            break;

            default:
            {
                return DISP_E_TYPEMISMATCH;
            }
        }

            //
        // Do we have the correct number of elements ?
        // 

            long iLBound = 0, iUBound = 0;

            if ( FAILED(SafeArrayGetLBound(psaPoints, 1, &iLBound)) || FAILED(SafeArrayGetUBound(psaPoints, 1, &iUBound)) )
                    return E_FAIL;

            //
        // Check that we have the correct number of data points
        // (3 == number of entries in the array per data point)
        //

            if (((iUBound - iLBound) + 1) / 3 != iNumPoints)
                    return DISP_E_TYPEMISMATCH;

            //
        // Data looks OK: Allocate an array 
        // 

        *ppPoints = New double[iNumPoints * 3];

            if (NULL == *ppPoints)
                    return E_OUTOFMEMORY;

            //
        // And now (finally!) we can on with building the array
        //

        switch (V_VT(&vPoints) & VT_TYPEMASK)
        {
            // If it's a variant, try and coerce it to something we can use
            case VT_VARIANT:
            {
                        VARIANTARG vaDest;
                        VARIANT *pvaPoints = NULL;
                        int i;

                        hr = SafeArrayAccessData(psaPoints, (void **) &pvaPoints);
                        if (SUCCEEDED(hr))
                        {
                    int iNumElements = iNumPoints * 3;

                                VariantInit (&vaDest);

                                for (i = 0; i < iNumElements; i++)
                                {
                                        hr = VariantChangeTypeEx(&vaDest, &pvaPoints[i], LANGID_USENGLISH, 0, VT_R8);
                                        if (SUCCEEDED(hr))
                                                (*ppPoints)[i] = V_R8(&vaDest);
                                        else
                                                break;

                                        VariantClear(&vaDest);
                                }
                        
                                // Don't want to lose the HRESULT
                                if (SUCCEEDED(hr))
                                        hr = SafeArrayUnaccessData(psaPoints);
                                else
                                        SafeArrayUnaccessData(psaPoints);
                        }
            }
            break;

            case VT_I2:
            case VT_I4:
            {
                int i;

                        // We have to deal with VT_I2 and VT_I4 separately
                        if ((V_VT(&vPoints) & VT_TYPEMASK) == VT_I2)
                        {
                                int *piPoints2 = NULL;

                                hr = SafeArrayAccessData(psaPoints, (void **)&piPoints2);
                                if (SUCCEEDED(hr))
                                {
                                        for (i = 0; i < (iUBound - iLBound); i++)
                                                *ppPoints[i] = (double) (piPoints2[i + iLBound]);
                                }
                        }
                        else // iIntSize == 4
                        {
                                int *piPoints4 = NULL;

                                hr = SafeArrayAccessData(psaPoints, (void **)&piPoints4);
                                if (SUCCEEDED(hr))
                                {
                                        for (i = 0; i < (iUBound - iLBound); i++)
                                                *ppPoints[i] = (double) (piPoints4[i + iLBound]);
                                }
                        }

                        hr = SafeArrayUnaccessData(psaPoints);

            }
            break;

            case VT_R4:
            case VT_R8:
            {
                if ((V_VT(&vPoints) & VT_TYPEMASK) == VT_R4)
                        {
                    // floats
                                float *piPoints = NULL;

                                hr = SafeArrayAccessData(psaPoints, (void **)&piPoints);
                                if (SUCCEEDED(hr))
                                {
                                        for (int i = 0; i < (iUBound - iLBound); i++)
                                                *ppPoints[i] = (double) (piPoints[i + iLBound]);
                                }
                        }
                        else 
                        {
                    // We can optimize the VT_R8 case ...
                                double *piPoints = NULL;

                                hr = SafeArrayAccessData(psaPoints, (void **)&piPoints);
                                if (SUCCEEDED(hr))
                                {
                        CopyMemory(*ppPoints, piPoints, (iUBound - iLBound) * sizeof(double));
                                }
                        }

                        hr = SafeArrayUnaccessData(psaPoints);
            }
            break;

            default:
            {
                // We should never get here, but just in case ...
                return DISP_E_TYPEMISMATCH;
            }
        }

            if ((FAILED(hr)) && (*ppPoints))
            {
                    Delete [] *ppPoints;
            *ppPoints = NULL;
            }
            
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
#else
    return E_FAIL;
#endif // NEEDGETPOINTARRAY
}

/*==========================================================================*/

HRESULT CPathCtl::SetTimeOffset(double offset)
{
    HRESULT hr;

    if (m_OffsetPtr != NULL) {
        CComPtr<IDANumber> NumberPtr;

        if (FAILED(hr = m_StaticsPtr->DANumber(offset, &NumberPtr))) return hr;
        if (FAILED(hr = m_OffsetPtr->SwitchTo(NumberPtr))) return hr;
    }

    m_dblTimeOffset = offset;

    return S_OK;
}

/*==========================================================================*/

HRESULT CPathCtl::BuildInterpolant(IDANumber **ppInterpolant, double dblDuration)
{
    //
    // Create the path interpolant
    //

    HRESULT hr;
    
    //
    // zero = 0;
    // one = 1;
    // two = 2;
    // time = localTime;
    //

    CComPtr<IDANumber> ZeroPtr;
    if (FAILED(hr = m_StaticsPtr->DANumber(0, &ZeroPtr))) return hr;

    CComPtr<IDANumber> OnePtr;
    if (FAILED(hr = m_StaticsPtr->DANumber(1, &OnePtr))) return hr;

    CComPtr<IDANumber> TwoPtr;
    if (FAILED(hr = m_StaticsPtr->DANumber(2, &TwoPtr))) return hr;

    CComPtr<IDANumber> TimePtr;
    if (FAILED(hr = m_StaticsPtr->get_GlobalTime(&TimePtr))) return hr;

    //
    // offset
    //

    if (m_OffsetPtr == NULL) {
        CComPtr<IDANumber> NumberPtr;
        if (FAILED(hr = m_StaticsPtr->DANumber(m_dblTimeOffset, &NumberPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->ModifiableBehavior(NumberPtr, &m_OffsetPtr))) return hr;
    }

    CComQIPtr<IDANumber, &IID_IDANumber> OffsetPtr(m_OffsetPtr);

    //
    // FakeTime = localTime - Offset
    //

    CComPtr<IDANumber> FakeTimePtr;
    if (FAILED(hr = m_StaticsPtr->Sub(TimePtr, OffsetPtr, &FakeTimePtr))) return hr;

    //
    // DTime = FakeTime / duration;
    //

    CComPtr<IDANumber> DurationPtr;
    CComPtr<IDANumber> DTimePtr;

    if (FAILED(hr = m_StaticsPtr->DANumber(dblDuration, &DurationPtr))) return hr;
    if (FAILED(hr = m_StaticsPtr->Div(FakeTimePtr, DurationPtr, &DTimePtr))) return hr;

    //
    // Forward = mod(dtime, 1)
    //

    CComPtr<IDANumber> ForwardPtr;
    if (FAILED(hr = m_StaticsPtr->Mod(DTimePtr, OnePtr, &ForwardPtr))) return hr;

    //
    // Backward = 1 - Forward
    //

    CComPtr<IDANumber> BackwardPtr;
    if (FAILED(hr = m_StaticsPtr->Sub(OnePtr, ForwardPtr, &BackwardPtr))) return hr;

    //
    // if (m_enumDirection == Backward) switch forward and backward
    // lastValue = if (m_enumDirection == Forward) then 1 else 0
    //

    CComPtr<IDANumber> lastValuePtr;

    if (m_enumDirection == Forward) {
        if (m_fBounce) {
            lastValuePtr = ZeroPtr;
        } else {
            lastValuePtr = OnePtr;
        }
    } else {
        if (m_fBounce) {
            lastValuePtr = OnePtr;
        } else {
            lastValuePtr = ZeroPtr;
        }

        CComPtr<IDANumber> TempPtr = ForwardPtr;
        ForwardPtr = BackwardPtr;
        BackwardPtr = TempPtr;
    }

    //
    // Seek =
    //      if (m_fBounce) {
    //          if (mod(dtime, 2) < 1) forward else backward;
    //      } else {
    //          forward
    //      }
    //

    CComPtr<IDABehavior> SeekPtr;

    if (m_fBounce) {
        CComPtr<IDANumber>   APtr;
        CComPtr<IDABoolean>  BPtr;

        if (FAILED(hr = m_StaticsPtr->Mod(DTimePtr, TwoPtr, &APtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->LT(APtr, OnePtr, &BPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->Cond(BPtr, ForwardPtr, BackwardPtr, &SeekPtr))) return hr;
    } else {
        SeekPtr = ForwardPtr;
    }

    //
    // calculate the duration
    //

    if (m_fBounce) {
        m_dblInstanceDuration = dblDuration * 2;
    } else {
        m_dblInstanceDuration = dblDuration;
    }

    switch (m_lRepeat) {
        case  0: m_dblTotalDuration = 0; break;
        case  1: m_dblTotalDuration = m_dblInstanceDuration; break;
        case -1: m_dblTotalDuration = -1; break;
        default: m_dblTotalDuration = m_dblInstanceDuration * m_lRepeat; break;
    }

    //
    // dseek = if (fakeTime >= totalduration) then 1 else seek
    //

    CComPtr<IDABehavior> DSeekPtr;

    if (m_dblTotalDuration == -1) {
        DSeekPtr = SeekPtr;
    } else {
        CComPtr<IDANumber>   TotalDurationPtr;
        CComPtr<IDABoolean>  GreaterPtr;

        if (FAILED(hr = m_StaticsPtr->DANumber(m_dblTotalDuration, &TotalDurationPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->GTE(FakeTimePtr, TotalDurationPtr, &GreaterPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->Cond(GreaterPtr, lastValuePtr, SeekPtr, &DSeekPtr))) return hr;
    }

    //
    // cast to a Number
    //

    CComQIPtr<IDANumber, &IID_IDANumber> InterpolatePtr(DSeekPtr);
    if (!InterpolatePtr) return E_FAIL;

    //
    // Fill in and addref (since we're returning)
    //

    *ppInterpolant = InterpolatePtr;
    (*ppInterpolant)->AddRef();
    
    return S_OK;
}

/*==========================================================================*/

HRESULT CPathCtl::UpdatePath(IDAPath2 *pPath)
{
    m_PathPtr = pPath;
    m_isKeyFramePath = false;
    return S_OK;
}

/*==========================================================================*/


// Update path takes either a point or a path, and uses whichever is
// non-null as the animator for the path, adding the appropriate
// interpolater on top.
HRESULT CPathCtl::CreatePath()
{
    HRESULT hr = S_OK;

    CComPtr<IDAPoint2> AnimatedPointPtr;

        if (m_isKeyFramePath) {
                ASSERT(m_keyFramePoint.p); // should be set by this point.

        CComPtr<IDANumber> NumberPtr;
        CComPtr<IDANumber> KeyInterpolatePtr;
        CComPtr<IDABehavior> SubPtr;
        CComPtr<IDANumber> InterpolatePtr;
        if (FAILED(hr = BuildInterpolant(&InterpolatePtr, m_dblKeyFrameDuration))) return hr;


        if (FAILED(hr = m_StaticsPtr->DANumber(m_dblKeyFrameDuration, &NumberPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->Mul(InterpolatePtr, NumberPtr, &KeyInterpolatePtr))) return hr;
        if (FAILED(hr = m_keyFramePoint->SubstituteTime(KeyInterpolatePtr, &SubPtr))) return hr;
        if (FAILED(hr = SubPtr->QueryInterface(IID_IDAPoint2, (void**)&AnimatedPointPtr))) return hr;
        } else {
        CComPtr<IDANumber> InterpolatePtr;
        if (FAILED(hr = BuildInterpolant(&InterpolatePtr, m_dblDuration))) return hr;

                //
                // get a transform from the path and the interpolant
                //

                CComPtr<IDATransform2> TransformPtr;
                if (FAILED(hr = m_StaticsPtr->FollowPathAnim(m_PathPtr, InterpolatePtr, &TransformPtr))) return hr;

                //
                // Get an animated point from the transform
                //

                CComPtr<IDAPoint2> PointPtr;

                if (FAILED(hr = m_StaticsPtr->get_Origin2(&PointPtr))) return hr;
                if (FAILED(hr = PointPtr->Transform(TransformPtr, &AnimatedPointPtr))) return hr;
        }

    //
    // offset the animated point by point offset
    //

    CComPtr<IDAVector2> PointOffsetPtr;
    if (FAILED(hr = m_StaticsPtr->Vector2(m_pointRelative.x, m_pointRelative.y, &PointOffsetPtr))) return hr;

    CComPtr<IDAPoint2> PreFinalPointPtr;
    if (FAILED(hr = m_StaticsPtr->AddPoint2Vector(AnimatedPointPtr, PointOffsetPtr, &PreFinalPointPtr))) return hr;

    //
    // create the final animated behavior
    //

        CComPtr<IDAPoint2> FinalPointPtr;

        if (m_bstrTarget && m_bstrLanguage) {
                if (FAILED(
                        hr = PreFinalPointPtr->AnimateControlPosition(
                                m_bstrTarget,
                                m_bstrLanguage,
                                0,
                                0.000000001,
                                &FinalPointPtr)
                        )) return hr;
        } else {
                if (FAILED(hr = m_StaticsPtr->get_Origin2(&FinalPointPtr))) return hr;
        }
    m_BehaviorPtr = FinalPointPtr;

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::StartModel(void)
{
    HRESULT hr;

    if (!m_fStarted)
    {
        CComPtr<IDASound> SoundPtr;
        CComPtr<IDAPoint2> PointPtr;
        CComPtr<IDAImage> ImagePtr;

        if (FAILED(hr = CreatePath()))
            return hr;

        if (FAILED(hr = m_ViewPtr->put_DC(NULL)))
            return hr;

        if (FAILED(hr = m_StaticsPtr->get_Silence(&SoundPtr)))
            return hr;

        if (FAILED(hr = m_StaticsPtr->get_EmptyImage(&ImagePtr)))
            return hr;

        // If DA view already started, don't restart it, just restart
        // by switching into m_BehaviorPtr again.   This would avoid
        // the overhead of start the view on every path start.
        if (!m_fAlreadyStartedDA) {
            if (FAILED(hr =
                       m_StaticsPtr->ModifiableBehavior(m_BehaviorPtr,
                                                        &m_SwitcherPtr)))
                return hr;

            if (FAILED(hr = m_ViewPtr->AddBvrToRun(m_SwitcherPtr, &m_lBehaviorID)))
                return hr;

            if (FAILED(hr = m_ViewPtr->StartModel(ImagePtr, SoundPtr, 0)))
                return hr;

            m_fAlreadyStartedDA = TRUE;
        } else {
            m_SwitcherPtr->SwitchTo(m_BehaviorPtr);
        }

        m_fStarted = TRUE;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT CPathCtl::StopModel(void)
{
    //HRESULT hr;

    // Stop any currently running model...
    if (m_fStarted) {
        //if (FAILED(hr = m_ViewPtr->RemoveRunningBvr(m_lBehaviorID))) return hr;

        //m_BehaviorPtr = NULL;
        //m_lBehaviorID = 0;

        //if (FAILED(hr = m_ViewPtr->StopModel())) return hr;

        m_fStarted = FALSE;
    }

    return S_OK;
}

/*==========================================================================*/

DWORD CPathCtl::GetCurrTimeInMillis()
{
    return timeGetTime();
}

/*==========================================================================*/

HRESULT CPathCtl::PersistShape(IVariantIO *pvio, BOOL fLoading)
{
    HRESULT hr = S_OK;

    if (fLoading)
    {
        BSTR bstrLine = NULL;

        if (FAILED(hr = pvio->Persist(0,
            "Shape", VT_BSTR, &bstrLine,
            NULL)))
            return hr;

        if (NULL != bstrLine)
        {
            CTStr tstrLine;
            int i = 0;

#ifdef _UNICODE
            tstrLine.SetStringPointer(bstrLine);
#else
            tstrLine.SetString(bstrLine);
#endif
            LPTSTR pszLine = tstrLine.psz();

            // First move past any leading junk
            while (IsJunkChar(*pszLine))
                pszLine++;
            
            // Locate the left paren
            while ((pszLine[i]) && (pszLine[i] != TEXT('(')))
                i++;

            // There are no strings longer than 15 chars, so a 15 char buffer is allocated below.  
            // Make sure that the string is going to fit.  If not, it's obviously wrong.

            if ((pszLine[i]) && (i < 14)) 
            {
                TCHAR tchNameUpper[15];
                
                // Make a copy of the string, and uppercase it
                memcpy(tchNameUpper, pszLine, i);
                tchNameUpper[i] = TEXT('\0');
                CharUpper(tchNameUpper);
                
                int j = 0;

                // Try and locate the token
                while ((j < NUMSHAPES) && (0 != lstrcmp(g_ShapeInfoTable[j].rgchShapeName, tchNameUpper)))
                    j++;

                if (j < NUMSHAPES)
                {
                    if (SUCCEEDED(hr = ConvertStringToArray(
                        &pszLine[i+1], 
                        g_ShapeInfoTable[j].iParamsPerPoint, 
                        g_ShapeInfoTable[j].fIncludesPointCount, 
                        &m_pdblPoints, 
                        &m_iNumPoints, 
                        TRUE)))
                        m_iShapeType = j;
                
                    if ((S_OK == hr) && (!m_fDesignMode))
                    {
                        switch (j)
                        {
                            case SHAPE_OVAL:
                            {
                                hr = Oval(
                                    m_pdblPoints[0], 
                                    m_pdblPoints[1], 
                                    m_pdblPoints[2], 
                                    m_pdblPoints[3]);
                            }
                            break;

                            case SHAPE_RECT:
                            {
                                hr = Rect(
                                    m_pdblPoints[0], 
                                    m_pdblPoints[1], 
                                    m_pdblPoints[2], 
                                    m_pdblPoints[3]);
                            }
                            break;

                            case SHAPE_POLYLINE:
                            case SHAPE_POLYGON:
                            case SHAPE_SPLINE:
                            {
                                VARIANT varArray;
                                VariantInit(&varArray);

                                hr = ConstructSafeArray(
                                    m_pdblPoints, 
                                    m_iNumPoints * g_ShapeInfoTable[j].iParamsPerPoint, 
                                    VT_R8, 
                                    &varArray);
                                
                                switch (j)
                                {
                                    case SHAPE_POLYLINE:
                                    {
                                        if (SUCCEEDED(hr))
                                            hr = Polyline(m_iNumPoints, varArray);
                                    }
                                    break;

                                    case SHAPE_POLYGON:
                                    {
                                        if (SUCCEEDED(hr))
                                            hr = Polygon(m_iNumPoints, varArray);
                                    }
                                    break;


                                    case SHAPE_SPLINE:
                                    {
                                        if (SUCCEEDED(hr))
                                            hr = Spline(m_iNumPoints, varArray);

                                    }
                                    break;
                                }

                                SafeArrayDestroy(varArray.parray);

                            }
                            break;

                            case SHAPE_POLYSPLINETIME:
                            {
                                VARIANT varPtArray, varTimeArray;
                                int iTimeOffset = m_iNumPoints * 2;

                                VariantInit(&varPtArray);
                                VariantInit(&varTimeArray);

                                hr = ConstructSafeArray(
                                    m_pdblPoints, 
                                    iTimeOffset, 
                                    VT_R8, 
                                    &varPtArray);

                                if (SUCCEEDED(hr))
                                    hr = ConstructSafeArray(
                                    &m_pdblPoints[iTimeOffset], 
                                    m_iNumPoints, 
                                    VT_R8, 
                                    &varTimeArray);

                                if (SUCCEEDED(hr))
                                    hr = KeyFrame(m_iNumPoints,
                                                                                                  varPtArray,
                                                                                                  varTimeArray);

                                if (NULL != varPtArray.parray)
                                    SafeArrayDestroy(varPtArray.parray);

                                if (NULL != varTimeArray.parray)
                                    SafeArrayDestroy(varTimeArray.parray);

                            }
                            break;
                        }

                    }
                }
                else
                {
                    // Couldn't convert the string correctly
                    DEBUGLOG(TEXT("CPathCtl::PersistShape - bad Shape parameter specified"));
                    if (!m_fDesignMode)
                        hr = E_FAIL;
                }
            }
            else
            {
                // User specified a bad string
                DEBUGLOG(TEXT("CPathCtl::PersistShape - bad Shape parameter specified"));
                hr = E_FAIL;
            }

#ifdef _UNICODE
            tstrLine.SetStringPointer(NULL, FALSE);
#endif
        }
        SysFreeString(bstrLine);
    }
    else
    {
        if (NULL != m_pdblPoints)
        {
            int iNumElements = 0;

            // Compute the number of elements
            if (g_ShapeInfoTable[m_iShapeType].fIncludesPointCount)
            {
                iNumElements = m_iNumPoints * g_ShapeInfoTable[m_iShapeType].iParamsPerPoint;
            }
            else
            {
                iNumElements = m_iNumPoints;

                ASSERT(iNumElements == g_ShapeInfoTable[m_iShapeType].iParamsPerPoint);
            }

            int cchBufferSize = lstrlen(g_ShapeInfoTable[m_iShapeType].rgchShapeName) + // Length of the shape name
                                1 +  // beginning Parens
                                1 +  // Comma
                                11 + // lstrlen(MAXINT)
                                (iNumElements * (CHARSPERNUMBER + 1)) + // CHARSPERNUMBER chars per point, plus a comma
                                1 + // Closing Parens
                                1  // Null terminator(paranoia)
                                ;

            CTStr tstrLine(cchBufferSize); // Allocate a buffer
            LPTSTR pszLine = tstrLine.psz(); // Get a pointer to the buffer
            
            if (NULL != pszLine)
            {

                // Point to the end of the buffer
                LPTSTR pchLineMac = pszLine + cchBufferSize;
        
                if (g_ShapeInfoTable[m_iShapeType].fIncludesPointCount)
                {
                    wsprintf(pszLine, TEXT("%s(%lu,"), g_ShapeInfoTable[m_iShapeType].rgchShapeName, m_iNumPoints);
                }
                else
                {
                    wsprintf(pszLine, TEXT("%s("), g_ShapeInfoTable[m_iShapeType].rgchShapeName);
                }

                TCHAR rgtchPoint[CHARSPERNUMBER];
                int cchPointLength = 0;

                pszLine += lstrlen(pszLine);

                // Concatenate all the points
                for (int i = 0; i < iNumElements; i++)
                {
                    // Concatenate a comma if necessary
                    if (i > 0)
                    {
                        CStringWrapper::Strcpy(pszLine, TEXT(","));
                        pszLine++;  
                    }

                    // We are using the DA Pixel library, so there is no point in saving
                    // any fractional data.  Truncation is appropriate.
                    wsprintf(rgtchPoint, TEXT("%li"), (int)m_pdblPoints[i]);
                
                    cchPointLength = lstrlen(rgtchPoint);

                    // Make sure we don't overflow the buffer
                    if ((pszLine + cchPointLength + 1) >= pchLineMac)
                    {
                        // We are about to overflow our buffer - don't !
                        ASSERT(0); 
                        hr = E_FAIL;
                        break;
                    }
                
                    // Concatenate the point
                    CStringWrapper::Strcpy(pszLine, rgtchPoint);

                    // Move the pointer along
                    pszLine += cchPointLength;

                }

                if (SUCCEEDED(hr))
                {
                    // Now add the closing bracket if it's safe.  Look both ways before crossing.
                    if (pszLine < (pchLineMac - 2)) // 1 for paren, 1 for NULL
                    {
                        CStringWrapper::Strcpy(pszLine, TEXT(")"));

                        BSTR bstrLine = tstrLine.SysAllocString();

                        hr = pvio->Persist(0,
                            "Shape", VT_BSTR, &bstrLine,
                            NULL);

                        SysFreeString(bstrLine);
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::ConstructSafeArray(double *pPoints, UINT iNumPoints, VARTYPE vtDest, VARIANT *pvarDest)
{
    HRESULT hr = S_OK;
    double *pArray = NULL;
    int iBytesPerElement = 0;

    ASSERT(pvarDest != NULL);
    HANDLENULLPOINTER(pvarDest);

    SAFEARRAY *psa = NULL;

    switch (vtDest)
    {
        case VT_I2:
        {
            iBytesPerElement = sizeof(short);
        }
        break;

        case VT_I4:
        {
            iBytesPerElement = sizeof(long);
        }
        break;

        case VT_R4:
        {
            iBytesPerElement = sizeof(float);
        }
        break;

        case VT_R8:
        {
            iBytesPerElement = sizeof(double);
        }
        break;
    }

    if (iBytesPerElement == 0)
        return E_FAIL;

    psa = SafeArrayCreateVector(vtDest, 0, iNumPoints);

    if (NULL == psa)
        return E_OUTOFMEMORY;

    if (FAILED(hr = SafeArrayAccessData(psa, (LPVOID *)&pArray)))
        return hr;

    // memcpy will be faster than iterating

    memcpy(pArray, pPoints, iNumPoints * iBytesPerElement);

    hr = SafeArrayUnaccessData(psa);

    // Our variant is going to be an array of VT_R8s
    pvarDest->vt = VT_ARRAY | vtDest;
    pvarDest->parray = psa;

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::ConvertStringToArray(LPTSTR pszLine, UINT iValuesPerPoint, BOOL fExpectPointCount, double **ppPoints, UINT *piNumPoints, BOOL fNeedPointCount)
{
    HRESULT hr = S_OK;
    UINT iNumPoints = 0;

    if ((NULL == ppPoints) || (NULL == pszLine) || (NULL == piNumPoints))
        return E_POINTER;

    *ppPoints = NULL;

    // fNeedPointCount means that the string is preceded with the point count, and
    // *piNumPoints should be set
    if (fNeedPointCount)
        *piNumPoints = 0;
    else
        iNumPoints = *piNumPoints;

    // Truncate the string to remove the trailing paren if necessary
    if (pszLine[lstrlen(pszLine) - 1] == TEXT(')'))
        pszLine[lstrlen(pszLine) - 1] = TEXT('\0');

    // Give the parser the string starting from the 2nd char if necessary, 
    // to eliminate the leading paren
    if (pszLine[0] == TEXT('('))
        pszLine++;
    
    // Create and initialise the string parser.  Copy is required, to compact
    CLineParser parser(pszLine);
    parser.SetCharDelimiter(TEXT(','));

    if (!parser.IsValid())
        return E_OUTOFMEMORY;
    
    if (fNeedPointCount)
    {
        // Get the number of points from the string if necessary
        if (fExpectPointCount)
        {
            if (FAILED(hr = parser.GetFieldUInt(&iNumPoints)))
                return hr;

            *piNumPoints = iNumPoints;
        }
        else
        {
            // If no point count is included in the string, expect iValuesPerPoint entries
            *piNumPoints = iValuesPerPoint;
            iNumPoints = iValuesPerPoint;
        }
    }

    // Allocate the array 
    if (fExpectPointCount)
        *ppPoints = New double[iNumPoints * iValuesPerPoint];
    else
        *ppPoints = New double[iNumPoints];

    if (NULL == *ppPoints)
        return E_OUTOFMEMORY;

    double dblValue = 0.0f; 
    UINT i = 0, iNumElements = iNumPoints * (fExpectPointCount ? iValuesPerPoint : 1);

    while (SUCCEEDED(hr) && (i < iNumElements))
    {
        // Get the data
        hr = parser.GetFieldDouble(&(*ppPoints)[i]);
        i++;
    }

#ifdef _DEBUG
    if (S_OK == hr)
        DEBUGLOG(TEXT("CPathCtl::ConvertStringToArray - incorrect number of points in array\n"));
#endif

    // Unless we got the exact number of points specified, fail and delete the array
    if ( (i < iNumElements) || (S_FALSE != hr) )
    {
        Delete [] *ppPoints;
        *ppPoints = NULL;
        *piNumPoints = 0;

        // Means there was more data available.  Not good.
        if (S_OK == hr)
            hr = E_FAIL;
    }
    else
    {
        // If we don't do this, hr == S_FALSE
        hr = S_OK;
    }

    return hr;
}


/*==========================================================================*/

void CPathCtl::OnTimer(DWORD dwTime)
{
    VARIANT_BOOL vBool;

        m_dblCurrentTick = dwTime / 1000.0;

    double time = m_dblCurrentTick - m_dblBaseTime;
    double tickTime = m_dblCurrentTick - m_dblTickBaseTime;

    HRESULT hr = m_ViewPtr->Tick(tickTime, &vBool);
    ASSERT(SUCCEEDED(hr));

    if (m_fOnWindowLoadFired) {
        FireMarkersBetween(
            m_pconpt,
            m_ptmFirst,
            FirePathMarker,
            m_dblPreviousTime,
            m_dblTotalDuration != -1 && time > m_dblTotalDuration ?
                m_dblTotalDuration : time,
            m_dblInstanceDuration,
            true
        );
    }

    m_dblPreviousTime = time;

    if (m_dblTotalDuration != -1 && time >= m_dblTotalDuration) {
        Stop();
    }
}

/*==========================================================================*/

#ifdef SUPPORTONLOAD
void 
CPathCtl::OnWindowLoad (void) 
{
    m_fOnWindowLoadFired = TRUE;
        if (m_fAutoStart)
        {
                Play();
        }
}

/*==========================================================================*/

void 
CPathCtl::OnWindowUnload (void) 
{
    m_fOnWindowLoadFired = FALSE;
        StopModel();
}

/*==========================================================================*/

#endif //SUPPORTONLOAD

/*==========================================================================*/

HRESULT CPathCtl::GetOffsetPoint(IHTMLElement* pelem, POINT& point)
{
    if(FAILED(pelem->get_offsetLeft(&(point.x)))) return(E_FAIL);
    if(FAILED(pelem->get_offsetTop(&(point.y)))) return(E_FAIL);
    return S_OK;

    /*
    IHTMLElement* pelemNext;
    HRESULT hr = pelem->get_offsetParent(&pelemNext);

    while (SUCCEEDED(hr) && pelemNext) {
        pelem = pelemNext;

        POINT pnt;
        if(FAILED(pelem->get_offsetLeft(&(pnt.x)))) return(E_FAIL);
        if(FAILED(pelem->get_offsetTop(&(pnt.y)))) return(E_FAIL);
        point.x += pnt.x;
        point.y += pnt.y;

        hr = pelem->get_offsetParent(&pelemNext);
        SafeRelease((IUnknown**)&pelem);
    }

    return hr;
    */
}

/*==========================================================================*/

HRESULT CPathCtl::HTMLElementFromName(BSTR bstrElementName, IHTMLElement** ppElement)
{
    HRESULT hr;
    IHTMLElementCollection* pihtmlElementCollection = NULL;
    IHTMLElement*           pihtmlElement = NULL;
    IHTMLDocument2*         pHTMLDoc = NULL;
    IOleContainer*          pContainer = NULL;
    VARIANT    varName;
    VARIANT    varEmpty;
    IDispatch* pidispElement = NULL;

    HANDLENULLPOINTER(ppElement);
    *ppElement = NULL;
    
    ASSERT(m_pocs != NULL);

    // Can't do anything without a client site - fail gracefully (BUG 11315)
    if (NULL == m_pocs)
        return E_FAIL; 

    if (FAILED(hr = m_pocs->GetContainer(&pContainer)))
        return hr;

    // Get the HTML doc.
    hr = pContainer->QueryInterface(IID_IHTMLDocument2, (LPVOID*)&pHTMLDoc);
    SafeRelease((IUnknown**)&pContainer);
    
    if (FAILED(hr))
    {
        return hr;
    }
    
    // Get the element collection
    hr = pHTMLDoc->get_all(&pihtmlElementCollection);
    SafeRelease((IUnknown**)&pHTMLDoc);

    if (FAILED(hr)) 
    {
        // Couldn't get the collection - this shouldn't happen

        ASSERT(FALSE);
        return E_FAIL;
    }

    ASSERT(pihtmlElementCollection);

    VariantInit(&varName);
    varName.vt = VT_BSTR;
    varName.bstrVal = bstrElementName;

    VariantInit(&varEmpty);
    
    // Now get the item with the name we specified
    if (SUCCEEDED(hr = pihtmlElementCollection->item(varName, varEmpty, &pidispElement)) && (NULL != pidispElement))
    {
        if (SUCCEEDED(hr = pidispElement->QueryInterface(IID_IHTMLElement, (LPVOID *)&pihtmlElement)))
        {
            hr = S_OK;
            *ppElement = pihtmlElement;
        }
        SafeRelease((IUnknown**)&pidispElement);
    }
    else if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
    }


    SafeRelease((IUnknown**)&pihtmlElementCollection);

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::GetPoint(POINT& point)
{
    IHTMLElement* pihtmlElement = NULL;
    HRESULT hr = S_OK;
    
    if (SUCCEEDED(hr = HTMLElementFromName(m_bstrTarget, &pihtmlElement)))
    {
        hr = GetOffsetPoint(pihtmlElement, point);
        SafeRelease((IUnknown**)&pihtmlElement);
    }

    return hr;
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\path\pathctl.h ===
/*==========================================================================*\

    Module: 
            pathctl.h

    Author: 
            IHammer Team (SimonB)

    Created: 
            May 1997

    Description:
            Defines the control's class

    History:
            05-24-1997  Created

\*==========================================================================*/

#ifndef __PATHCTL_H__
#define __PATHCTL_H__

const double pi = 3.14159265359;

#include "..\ihbase\precomp.h"
#include "..\ihbase\ihbase.h"
#include "..\ihbase\timemark.h"
#include <daxpress.h>
#include "..\ihbase\clocker.h"
#undef Delete
#include <mshtml.h>
#define Delete delete

class CSeriesMarker
{
public:
    UINT m_iTickNumber;
    UINT m_iPosition;

    CSeriesMarker(UINT iTickNumber = 0, UINT iPosition = 0)
    {
        m_iTickNumber = iTickNumber; 
        m_iPosition = iPosition;
    }

    ~CSeriesMarker() {}
};

typedef CPtrDrg<CSeriesMarker> CSeriesMarkerDrg;


// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>

/*==========================================================================*/

/*
CIHBaseCtl <    
        CPathCtl,                       //Name of the derived class
        IIHCtl,                         //Name of interface defining methods and properties
        &CLSID_IHCtl,           //CLSID of the control  Get this from ihctl.h
        &IID_IIHCtl,            //IID of the interface above.  Get this from ihctl.h
        &LIBID_IHCtl,           //LIBID of the typelib.  Get this from ihctl.h
        &DIID_IHCtlEvents > //IID of the event interface.  Get this from ihctl.h

*/

#define PATH_BASECLASS      \
CIHBaseCtl <                \
    CPathCtl,               \
    IPathCtl,               \
    &CLSID_PathControl,         \
    &IID_IPathCtl,          \
    &LIBID_DAExpressLib,    \
    &DIID_IPathCtlEvents>

/*==========================================================================*/

// EdgeAction enumeration
typedef enum {eaStop = 0, eaReverse, eaWrap, eaInvalid} EA;

class CPathCtl:         
    public IPathCtl,
    public PATH_BASECLASS,
    public CClockerSink
{
friend LPUNKNOWN __stdcall AllocPathControl(LPUNKNOWN punkOuter);

// Template stuff
    typedef PATH_BASECLASS CMyIHBaseCtl;

private:
    BOOL    m_fAutoStart;
    BOOL    m_fBounce;
    double  m_dblDuration;
    EA      m_ea;
    long    m_lRepeat;
    BSTR    m_bstrTarget;
    BSTR    m_bstrLanguage;
    double* m_pdblPoints;
    UINT    m_iNumPoints;
    UINT    m_iShapeType;
    double  m_dblTimerInterval;
    bool    m_fOnSeekFiring;
    boolean m_fOnWindowLoadFired;
    bool    m_fOnStopFiring;
    bool    m_fOnPlayFiring;
    bool    m_fOnPauseFiring;

    PlayStateConstant      m_enumPlayState;
    DirectionConstant      m_enumDirection;
    CPtrDrg<CTimeMarker>   m_drgTimeMarkers;
    CTimeMarker*           m_ptmFirst;
    CSeriesMarkerDrg       m_drgXSeries;
    CSeriesMarkerDrg       m_drgYSeries;

    CComPtr<IDAStatics>    m_StaticsPtr;
    CComPtr<IDAView>       m_ViewPtr;
    CComPtr<IDABehavior>   m_OffsetPtr;
    CComPtr<IDAPoint2>     m_keyFramePoint;
    CComPtr<IDAPath2>      m_PathPtr;
    CComPtr<IDABehavior>   m_BehaviorPtr;
    CComPtr<IDABehavior>   m_SwitcherPtr;

    BOOL                   m_fAlreadyStartedDA;

    BOOL                   m_fStarted;
    long                   m_lBehaviorID;
    CClocker               m_clocker;
        double                 m_dblBaseTime;
        double                 m_dblCurrentTick;
        double                 m_dblTimePaused;

    double                 m_dblTimeOffset;
    double                 m_dblTickBaseTime;

    double                 m_dblInstanceDuration;
    double                 m_dblTotalDuration;
    double                 m_dblPreviousTime;

    boolean                m_bRelative;
    POINT                  m_pointRelative;

    bool                   m_fTargetValidated;

    // key frame members

    BOOL   m_isKeyFramePath;
    double m_dblKeyFrameDuration;

protected:

        // 
        // Constructor and destructor
        // 
    CPathCtl(IUnknown *punkOuter, HRESULT *phr);

    ~CPathCtl();

        // Overides
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
        
        STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);
    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);

    STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
         BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue);
        
        ///// IDispatch implementation
        protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   
    ///// IOleObject implementation
    protected:
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

        ///// delegating IUnknown implementation
        protected:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

        private:

    HRESULT AddTimeMarkerElement(CTimeMarker **ppNewMarker);
    HRESULT PersistTimeMarkers(IVariantIO* pvio, BOOL fLoading);
    HRESULT ParseSeriesSegment(LPTSTR pszSegment, CSeriesMarker **ppMarker);
    HRESULT PersistSeries(IVariantIO* pvio, BOOL fLoading, LPSTR pszSeriesName, CSeriesMarkerDrg *pSeriesDrg);

        //
        // IPathCtl methods 
        //
        
protected:

    HRESULT STDMETHODCALLTYPE get_Target(BSTR __RPC_FAR *bstrTarget);
    HRESULT STDMETHODCALLTYPE put_Target(BSTR bstrTarget);
    HRESULT STDMETHODCALLTYPE get_Duration(double __RPC_FAR *dblDuration);
    HRESULT STDMETHODCALLTYPE put_Duration(double dblDuration);
    HRESULT STDMETHODCALLTYPE get_TimerInterval(double __RPC_FAR *pdblTimerInterval);
    HRESULT STDMETHODCALLTYPE put_TimerInterval(double dblTimerInterval);
    HRESULT STDMETHODCALLTYPE get_Library(IDAStatics __RPC_FAR *__RPC_FAR *ppLibrary);
    HRESULT STDMETHODCALLTYPE get_Repeat(long __RPC_FAR *iRepeat);
    HRESULT STDMETHODCALLTYPE put_Repeat(long iRepeat);
    HRESULT STDMETHODCALLTYPE get_Relative(VARIANT_BOOL __RPC_FAR *bRelative);
    HRESULT STDMETHODCALLTYPE put_Relative(VARIANT_BOOL bRelative);
    HRESULT STDMETHODCALLTYPE get_Bounce(VARIANT_BOOL __RPC_FAR *fBounce);
    HRESULT STDMETHODCALLTYPE put_Bounce(VARIANT_BOOL fBounce);
    HRESULT STDMETHODCALLTYPE get_AutoStart(VARIANT_BOOL __RPC_FAR *fAutoStart); 
    HRESULT STDMETHODCALLTYPE put_AutoStart(VARIANT_BOOL fAutoStart); 
    HRESULT STDMETHODCALLTYPE get_PlayState(PlayStateConstant __RPC_FAR *State);
    HRESULT STDMETHODCALLTYPE get_Time(double __RPC_FAR *pdblTime);
    HRESULT STDMETHODCALLTYPE get_Direction(DirectionConstant __RPC_FAR *Dir);
    HRESULT STDMETHODCALLTYPE put_Direction(DirectionConstant Dir);
    HRESULT STDMETHODCALLTYPE get_Path(IDAPath2 __RPC_FAR **ppPath);
    HRESULT STDMETHODCALLTYPE put_Path(IDAPath2 __RPC_FAR *pPath);
    HRESULT STDMETHODCALLTYPE Seek(double dblTime);
    HRESULT STDMETHODCALLTYPE Stop(void);
    HRESULT STDMETHODCALLTYPE Pause(void);
    HRESULT STDMETHODCALLTYPE Play(void);
    HRESULT STDMETHODCALLTYPE Oval(double StartX, double StartY, double Width, double Height);
    HRESULT STDMETHODCALLTYPE Rect(double StartX, double StartY, double Width, double Height);
    HRESULT STDMETHODCALLTYPE Polyline(long nPoints, VARIANT Points);
    HRESULT STDMETHODCALLTYPE Polygon(long nPoints,VARIANT Points);
    HRESULT STDMETHODCALLTYPE AddTimeMarker(double dblTime,BSTR bstrMarker, VARIANT varAbsolute);
    HRESULT STDMETHODCALLTYPE KeyFrame(unsigned int iNumPoints, VARIANT varPoints, VARIANT varTimePoints);
    HRESULT STDMETHODCALLTYPE Spline(unsigned int iNumPoints, VARIANT varPoints);

#ifdef SUPPORTONLOAD
        void OnWindowLoad (void);
        void OnWindowUnload (void);
#endif //SUPPORTONLOAD

private:
    HRESULT GetPointArray(long iNumPoints, VARIANT vPoints, double **ppPoints);
    HRESULT PersistShape(IVariantIO *pvio, BOOL fLoading);
    HRESULT ConstructSafeArray(double *pPoints, UINT iNumPoints, VARTYPE vtDest, VARIANT *pvarDest);
    HRESULT ConvertStringToArray(LPTSTR pszLine, UINT iValuesPerPoint, BOOL fExpectPointCount, double **ppPoints, UINT *piNumPoints, BOOL fNeedPointCount);
    HRESULT UpdatePath(IDAPath2 *pPath);
    HRESULT CreatePath();
    HRESULT BuildInterpolant(IDANumber **ppInterpolant, double dlbDuration);
    HRESULT AnimateControl(IDAPoint2 *pointToAnimateBy);
    HRESULT StartModel(void);
    HRESULT StopModel(void);
    HRESULT SetTimeOffset(double offset);

    void DoPause();
    void DoStop();
    void DoSeek(double);
    void DoResume();

    HRESULT GetOffsetPoint(IHTMLElement* pelem, POINT& point);
    HRESULT HTMLElementFromName(BSTR bstrElementName, IHTMLElement** ppElement);
    HRESULT GetPoint(POINT& point);

    // Timing info:
    DWORD GetCurrTimeInMillis(void);
    double GetCurrTime() { return (double)(GetCurrTimeInMillis()) / 1000.0; }

public:
    virtual void OnTimer(DWORD dwTime);
};

/*==========================================================================*/

#endif // __PATHCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\path\pathevnt.h ===
/*++

Module: 
    pathevnt.h

Author: 
    IHammer Team (SimonB)

Created: 
    May 1997

Description:
    Macros to make firing events easier and safer.  Each macro can be customised for 
    the particular event.  However, the general form should be:

    #define FIRE_EVENTNAME(pConnectionPoint, param1, param2) \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_EVENTNAME, \
            <VT for param1>, param1, \
            <VT for param2>, param2, \
            0) 

    NOTE: The terminating 0 is extremly important !!!

History:
    05-24-1997  Created (SimonB)

++*/

#include <dispids.h>

#ifndef __PATHEVNT_H__
#define __PATHEVNT_H__

#define FIRE_ONSTOP(pConnectionPoint) \
    if (m_fOnWindowLoadFired && !m_fOnStopFiring) \
    { \
        m_fOnStopFiring = true; \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_ONSTOP, 0); \
        m_fOnStopFiring = false; \
    }

#define FIRE_ONPLAY(pConnectionPoint) \
    if (m_fOnWindowLoadFired && !m_fOnPlayFiring) \
    { \
        m_fOnPlayFiring = true; \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_ONPLAY, 0); \
        m_fOnPlayFiring = false; \
    }


#define FIRE_ONPAUSE(pConnectionPoint) \
    if (m_fOnWindowLoadFired && !m_fOnPauseFiring) \
    { \
        m_fOnPauseFiring = true; \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_ONPAUSE, 0); \
        m_fOnPauseFiring = false; \
    }

#define FIRE_ONSEEK(pConnectionPoint, SeekTime) \
    if (m_fOnWindowLoadFired && !m_fOnSeekFiring) \
    { \
        m_fOnSeekFiring = true; \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_ONSEEK, VT_R8, SeekTime, 0); \
        m_fOnSeekFiring = false; \
    }


#endif // __PATHEVNT_H__

// End of file pathevnt.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\mmseq\seqmgr.cpp ===
/*++

Module: 
        seqmgr.cpp

Author: 
        ThomasOl

Created: 
        April 1997

Description:
        Implements Sequencer Manager

History:
        4-02-1997       Created

++*/

#include "..\ihbase\precomp.h"
#include "servprov.h"
#include <htmlfilter.h>
#include <string.h>
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "memlayer.h"
#include "debug.h"
#include "drg.h"
#include "strwrap.h"
#include "seqmgr.h"
#include "enumseq.h"
#include "dispids.h"

// function that create's an IEnumDispatch object from the given ole container.
//
// CMMSeqMgr Creation/Destruction
//

extern ControlInfo     g_ctlinfoSeq, g_ctlinfoSeqMgr;

LPUNKNOWN __stdcall AllocSequencerManager(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr = S_OK;
    CMMSeqMgr *pthis = New CMMSeqMgr(punkOuter, &hr);
    DEBUGLOG("AllocSequencerManager : Allocating object\n");
    if (pthis == NULL)
        return NULL;
    if (FAILED(hr))
    {
        Delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

//
// Beginning of class implementation
// 

CMMSeqMgr::CMMSeqMgr(IUnknown *punkOuter, HRESULT *phr):
        CMyIHBaseCtl(punkOuter, phr),
        m_fLoadFired(FALSE),
        m_fInited(FALSE),
        m_pidispEventHandler(NULL),
        m_ulRef(1),
        m_fCurCookie(0),
        m_PointerList(NULL),
        m_bUnloaded(false),
        m_bUnloadedStarted(false)
{       
        DEBUGLOG("MMSeqMgr: Allocating object\n");
        if (NULL != phr)
        {
                ::InterlockedIncrement((long *)&(g_ctlinfoSeqMgr.pcLock));
                *phr = S_OK;
        }
}

        
CMMSeqMgr::~CMMSeqMgr()
{
        DEBUGLOG("MMSeqMgr: Destroying object\n");

        if (m_pidispEventHandler)
                m_pidispEventHandler->Release();

    Delete [] m_PointerList;
    m_PointerList=NULL;
    
    ::InterlockedDecrement((long *)&(g_ctlinfoSeqMgr.pcLock));
}


STDMETHODIMP CMMSeqMgr::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
        //              Add support for any custom interfaces

        HRESULT hRes = S_OK;
        BOOL fMustAddRef = FALSE;

    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("MMSeqMgr::QI('%s')\n", DebugIIDName(riid, ach));
#endif
    
        if ((IsEqualIID(riid, IID_IMMSeqMgr)) || (IsEqualIID(riid, IID_IDispatch)))
        {
                if (NULL == m_pTypeInfo)
                {
                        HRESULT hRes = S_OK;
                        
                        // Load the typelib
                        hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_IMMSeqMgr, LIBID_DAExpressLib, NULL); 

                        if (FAILED(hRes))
                        {
                                ODS("Unable to load typelib\n");
                                m_pTypeInfo = NULL;
                        }
                        else    
                                *ppv = (IMMSeqMgr *) this;

                }
                else
                        *ppv = (IMMSeqMgr *) this;
                    
        }
    else // Call into the base class
        {
                DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);

        }

    if (NULL != *ppv)
        {
                DEBUGLOG("MMSeqMgr: Interface supported in control class\n");
                ((IUnknown *) *ppv)->AddRef();
        }

    return hRes;
}


STDMETHODIMP CMMSeqMgr::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
        if (!m_fInited)
        {
                FireInit();
        }
        return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IDispatch Implementation
//

STDMETHODIMP CMMSeqMgr::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CMMSeqMgr::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
        HRESULT hr = E_POINTER;

        if (NULL != pptinfo)
        {
                *pptinfo = NULL;
     
                if(itinfo == 0)
                {
                        m_pTypeInfo->AddRef(); 
                        *pptinfo = m_pTypeInfo;
                        hr = S_OK;
                }
                else
                {
                        hr = DISP_E_BADINDEX;
                }
    }

    return hr;
}

STDMETHODIMP CMMSeqMgr::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{

        return ::DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}


STDMETHODIMP CMMSeqMgr::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
        return ::DispInvoke((IMMSeqMgr *)this, 
                m_pTypeInfo,
                dispidMember, wFlags, pdispparams,
                pvarResult, pexcepinfo, puArgErr); 
}


STDMETHODIMP CMMSeqMgr::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = CMyIHBaseCtl::SetClientSite(pClientSite);

    // Now we enumerate through all the sequencers to set their client sites too

    IOleObject *pObject = NULL;
    CSeqHashNode *pNode = m_hashTable.FindFirst();

    while (pNode)
    {
        if (pNode->m_piMMSeq)
        {
            if (SUCCEEDED(pNode->m_piMMSeq->QueryInterface(IID_IOleObject, (LPVOID *) &pObject)))
            {
                if (pObject)
                {
                    pObject->SetClientSite(pClientSite);
                    SafeRelease((LPUNKNOWN *)&pObject);
                }
            }
        }

        pNode = m_hashTable.FindNext();
    }

    return hr;
}


STDMETHODIMP CMMSeqMgr::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
     DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
     LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
     BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue)
{
        // The sequencer has no runtime drawing code.
        if (m_fDesignMode)
        {
            // draw an ellipse using palette entry <m_ipeCur> in the palette
                HBRUSH          hbr;            // brush to draw with
                HBRUSH          hbrPrev;        // previously-selected brush
                HPEN            hpenPrev;       // previously-selected pen

                if ((hbr = (HBRUSH)GetStockObject(WHITE_BRUSH)) != NULL)
                {
                        TCHAR strComment[] = TEXT("Sequencer Control");
                        HFONT hfontPrev = (HFONT)SelectObject(hdcDraw, GetStockObject(SYSTEM_FONT));
                        
                        hbrPrev = (HBRUSH)SelectObject(hdcDraw, hbr);
                        hpenPrev = (HPEN)SelectObject(hdcDraw, GetStockObject(BLACK_PEN));
                        Rectangle(hdcDraw, m_rcBounds.left, m_rcBounds.top,
                                m_rcBounds.right, m_rcBounds.bottom);

                        TextOut(hdcDraw, m_rcBounds.left + 1, m_rcBounds.top + 1,
                                strComment, lstrlen(strComment));

                        SelectObject(hdcDraw, hbrPrev);
                        SelectObject(hdcDraw, hpenPrev);
                        SelectObject(hdcDraw, hfontPrev);
                        DeleteObject(hbr);
                }

        } 
    return S_OK;
}


//
// IMMSeqMgr implementation
//

/*==========================================================================*/


STDMETHODIMP CMMSeqMgr::get_Count(THIS_ long FAR* plCount)
{
        if (!plCount)
                return E_INVALIDARG;
        *plCount = m_hashTable.Count();
        return S_OK;
}

/*==========================================================================*/


STDMETHODIMP CMMSeqMgr::get__NewEnum(IUnknown FAR* FAR* ppunkEnum)
{
        CEnumVariant* pEV;
        HRESULT hr=E_FAIL;

        if (!ppunkEnum)
                return E_INVALIDARG;
        pEV = New CEnumVariant(this);
        if (pEV)
        {
                hr = pEV->QueryInterface(IID_IEnumVARIANT, (LPVOID*)ppunkEnum);
                pEV->Release();
        }
        return hr;
}


/*==========================================================================*/


STDMETHODIMP CMMSeqMgr::get_Item(THIS_ VARIANT variant, IDispatch * FAR* ppdispatch)
{
        HRESULT hr;
        IMMSeq* piMMSeq=NULL;                                   
        VARIANT *pvarVariant = &variant;
        IConnectionPointContainer* piConnectionPointContainer;
        
        if (!ppdispatch)
                return E_POINTER;

        *ppdispatch = NULL;

        if (m_bUnloaded)
        {
            return E_FAIL;                                    
        }

        // If we haven't yet fired the init event - do so now.
        if (!m_fInited)
        {
                FireInit();
        }

    if (V_VT(pvarVariant) & VT_VARIANT)
        {
                if (V_VT(pvarVariant) & VT_BYREF)
                        pvarVariant = V_VARIANTREF(pvarVariant);
        }

    //Seq("button_onclick"). dereference using string
    if ( (pvarVariant->vt & VT_BSTR) == VT_BSTR )
    {
        TCHAR rgchName[CCH_ID];
        BSTR  *pbstrName = NULL;

        // We have to deal with BYREFs
        if (pvarVariant->vt & VT_BYREF)
            pbstrName = pvarVariant->pbstrVal;
        else
            pbstrName = &pvarVariant->bstrVal;

                Proclaim(pbstrName);

        // BUGBUG: should use lstrlenW, not SysStringLen.  SysStringLen just returns the size
        // of the allocated memory block, not the length of the string.

                if (pbstrName && (0 < ::SysStringLen(*pbstrName)))              //did they pass a valid BSTR?
                {                                                       
                                                                        //our hash class is MBCS
                        if (WideCharToMultiByte(CP_OEMCP, NULL, *pbstrName, -1, rgchName, sizeof(rgchName),NULL,NULL))
                        {
                                CSeqHashNode node(rgchName, NULL);              //construct a temp node
                                CSeqHashNode *pnode = m_hashTable.Find(&node);  //is it in the hash table already?
                                
                                if (pnode)                                              //yup, just addref and return
                                {
                                        *ppdispatch = pnode->m_piMMSeq;
                                        Proclaim(*ppdispatch);
                                        (*ppdispatch)->AddRef();
                                        return S_OK;
                                }
                                
                                //if the unload has started then fail here
                                //so that no new nodes are created.
                                if (m_bUnloadedStarted)
                                {
                                    return E_FAIL;
                                }

                                if (!m_pidispEventHandler)                              //have we allocated an event handler?
                                {
                                        CEventHandler* pcEventHandler = New CEventHandler((IMMSeqMgr*)this);

                                        if (pcEventHandler)
                                        {
                                                hr = pcEventHandler->QueryInterface(IID_IDispatch, (LPVOID*)&m_pidispEventHandler);
                                                pcEventHandler->Release();
                                        }

                                        if (!m_pidispEventHandler)                      //something is messed up.
                                                return E_OUTOFMEMORY;
                                }
                                                                                                                
                                //create a new sequencer.
                                hr = CoCreateInstance(CLSID_MMSeq, NULL, CLSCTX_INPROC_SERVER, IID_IMMSeq, (LPVOID*)&piMMSeq);

                                if (SUCCEEDED(hr))      
                                {
                                        CSeqHashNode node(rgchName, piMMSeq); //construct a temp node
                                                                                                                //okay, now insert into hash table
                                        hr = (TRUE == m_hashTable.Insert(&node)) ? S_OK : E_FAIL;
                                }
                                Proclaim(SUCCEEDED(hr));  //this is either OOM or duplicate insertion--check Find
                                pnode = m_hashTable.Find(&node);        //is it in the hash table already?
                                Proclaim(pnode);

                                if (SUCCEEDED(hr))              //no need to addref--CoCreate did it.
                                {
                                        *ppdispatch = piMMSeq;
                                        IOleObject* piOleObject;

                                        m_fCurCookie++;
                                        piMMSeq->put__Cookie(m_fCurCookie); //give the sequencer a cookie!
                                        //store the pointer in a table of cookies.

                                        int CurCount = m_hashTable.Count();

                                        // we allocate an entirely new structure with one additional element.
                                        // since nodes are small and hopefully not too numerous, this should
                                        // be ok. 

                                        CookieList *tempPointerList = New CookieList[m_fCurCookie];

                                        if(tempPointerList==NULL)
                                            return E_OUTOFMEMORY;

                                        if(m_PointerList!=NULL) {
                                            memcpy(tempPointerList, m_PointerList, sizeof(CookieList) * (m_fCurCookie - 1));
                                            Delete [] m_PointerList;
                                        }

                                        //should never have more nodes in hashtable than cookies
                                        ASSERT(CurCount<=m_fCurCookie);

                                        tempPointerList[m_fCurCookie-1].cookie = m_fCurCookie;
                                        tempPointerList[m_fCurCookie-1].pnode = (void *)pnode;

                                        m_PointerList = tempPointerList;

                                        if (SUCCEEDED(piMMSeq->QueryInterface(IID_IOleObject, (LPVOID*)&piOleObject)))
                                        {
                                                Proclaim(piOleObject);
                                                piOleObject->SetClientSite(m_pocs);
                                                piOleObject->Release();
                                        }

                                        Proclaim(m_pidispEventHandler);

                                        if (!pnode->m_dwUnadviseCookie && 
                                                m_pidispEventHandler &&
                                                SUCCEEDED(piMMSeq->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&piConnectionPointContainer)))
                                        {
                                                if (SUCCEEDED(piConnectionPointContainer->FindConnectionPoint(DIID_IMMSeqEvents, &pnode->m_piConnectionPoint)))
                                                {
                                                        if (!SUCCEEDED(pnode->m_piConnectionPoint->Advise(m_pidispEventHandler, &pnode->m_dwUnadviseCookie)))
                                                        {
                                                                Proclaim(FALSE);
                                                        }
                                                }
                                                piConnectionPointContainer->Release();
                                        }
                                }

                                return hr;
                        }
                        return DISP_E_MEMBERNOTFOUND; // S_FALSE
                }
        else // NULL string
        {
            return E_INVALIDARG;
        }

    }
    else // Anything other than a BSTR
    {
        return DISP_E_TYPEMISMATCH;
    }
}

STDMETHODIMP CMMSeqMgr::Close(DWORD dwSaveOption)
{
        CSeqHashNode* pnode = m_hashTable.FindFirst();

        if (pnode)
        {
                do
                {
                        if (pnode->m_piConnectionPoint)                                         //release the connection point
                        {
                                if (pnode->m_dwUnadviseCookie)
                                {
                                        pnode->m_piConnectionPoint->Unadvise(pnode->m_dwUnadviseCookie);
                                        pnode->m_dwUnadviseCookie = 0;
                                }
                                pnode->m_piConnectionPoint->Release();
                                pnode->m_piConnectionPoint = NULL;
                        }
                        
                        Proclaim(pnode->m_piMMSeq);
                        if (pnode->m_piMMSeq)
                        {
                                IOleObject* piOleObject;
                                                                
                                if (SUCCEEDED(pnode->m_piMMSeq->QueryInterface(IID_IOleObject,
                                        (LPVOID*)&piOleObject)))
                                {
                                        piOleObject->Close(OLECLOSE_NOSAVE);
                    piOleObject->SetClientSite(NULL);
                                        piOleObject->Release();
                                }

                                pnode->m_piMMSeq->Clear();
                                pnode->m_piMMSeq->Release();
                                pnode->m_piMMSeq = NULL;
                        }
                        m_hashTable.Remove(pnode);
                }
                while ((pnode = m_hashTable.FindNext()));
        }

        if (m_pidispEventHandler)
        {
                m_pidispEventHandler->Release();
                m_pidispEventHandler = NULL;
        }
        
        return CMyIHBaseCtl::Close(dwSaveOption);
}

STDMETHODIMP CMMSeqMgr::RelayEvent(long dispid, long lCookie, double dblSeekTime)
{
        if (lCookie && m_pconpt)
        {
                CSeqHashNode* pnode = (CSeqHashNode*)m_PointerList[lCookie-1].pnode;
                WCHAR rgwchName[CCH_ID];

#ifdef _DEBUG
                ASSERT(pnode!=NULL && "Internal error: Sequencer Pointer Structure contains a null ptr");

                if(!pnode)
                    return E_POINTER;
#endif
                
                if (MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,pnode->m_rgchName,-1,rgwchName,sizeof(rgwchName)/sizeof(rgwchName[0])))
                {
                        switch(dispid)
                        {       
                                case DISPID_SEQMGR_EVENT_ONPLAY:
                                case DISPID_SEQMGR_EVENT_ONPAUSE:
                                case DISPID_SEQMGR_EVENT_ONSTOP:
                                case DISPID_SEQMGR_EVENT_ONSEEK:
                                {
                                        BSTR bstrName = SysAllocString(rgwchName);

                                        if (DISPID_SEQMGR_EVENT_ONSEEK != dispid)
                                                m_pconpt->FireEvent(dispid, VT_BSTR, bstrName, 0.0f);
                                        else
                                                m_pconpt->FireEvent(dispid, VT_BSTR, bstrName, VT_R8, dblSeekTime, NULL);
                                    
                                        SysFreeString(bstrName);
                                }
                                break;
                        }
                }
        }
        return S_OK;
}


void
CMMSeqMgr::FireInit (void)
{
        if (m_pconpt)
        {
                m_fInited = TRUE;
                m_pconpt->FireEvent(DISPID_SEQMGR_EVENT_INIT, NULL, NULL);
        }
}

#ifdef SUPPORTONLOAD
void CMMSeqMgr::OnWindowLoad() 
{
        if (!m_fInited)
        {
                FireInit();
        }
        return;
}

void CMMSeqMgr::OnWindowUnload() 
{ 
        CSeqHashNode* pnode = m_hashTable.FindFirst();

        m_bUnloadedStarted = true;

        m_fInited = FALSE;
        if (pnode)
        {
                do
                {
                        Proclaim(pnode->m_piMMSeq);
                        if (pnode->m_piMMSeq)
                        {
                                // Only stop an action set that is playing or is paused.
                                int iPlayState = 0;
                                HRESULT hr = pnode->m_piMMSeq->get_PlayState(&iPlayState);

                                ASSERT(SUCCEEDED(hr));
                                if (SUCCEEDED(hr))
                                {
                                        if (0 != iPlayState)
                                        {
                                                pnode->m_piMMSeq->Stop();
                                        }
                                        pnode->m_piMMSeq->Clear();
                                }
                        }
                }
                while ((pnode = m_hashTable.FindNext()));
        }
        m_bUnloaded = true;
        return; 
}
#endif //SUPPORTONLOAD

// End of file: seqmgr.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\path\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\path\purevirt.cpp ===
// purevirt.c
//
// Avoids use of C runtime.
//

#include "..\ihbase\precomp.h"

extern "C" int __cdecl _purecall(void)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\purevirt.cpp ===
// purevirt.c
//
// Avoids use of C runtime.
//

#include "..\ihbase\precomp.h"

extern "C" int __cdecl _purecall(void)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\path\pathinit.h ===
/*++

Module: 
	pathinit.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Header for control-specific initialisation

History:
	05-24-1997	Created (SimonB)

++*/
#include "..\mmctl\inc\ochelp.h" // for ControlInfo

#ifndef __PATHINIT_H__
#define __PATHINIT_H__

void InitPathControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);

#endif // __PATHINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\parser.h ===
/*==========================================================================*\

Module:
    parser.h

Author:
    IHammer Team (MByrd)

Created:
    November 1996

Description:
    CParser Class Definition

History:
    11-07-1996  Created

\*==========================================================================*/

#ifndef __PARSER_H__
#define __PARSER_H__

#include "ihammer.h"
#include "drg.h"
#include "strwrap.h"
#include "grobj.h"

/*==========================================================================*/

// This should be consistent with MAX_STRING_LENGTH defined in grobj.h
#define MAX_PARAM_LENGTH 65536L
#define MAX_PARSE_NAME       32
#define SRC_BUFFER_SIZE     512

#define START_PARAM  _T('(')
#define END_PARAM    _T(')')
#define PARAM_SEP    _T(',')
#define START_STRING _T('\'')
#define END_STRING   _T('\'')
#define LITERAL      _T('\\')

/*==========================================================================*/

typedef CGraphicObject *(* CREATEGRAPHICPROC)(BOOL fFilled);

/*==========================================================================*/

class CParser
{
private:
    typedef struct PARSERLOOKUP_tag
    {
        TCHAR             rgtchName[MAX_PARSE_NAME];
        WORD              wObjectType;
        BOOL              fFilled;
        CREATEGRAPHICPROC pCreateGraphicProc;
    } PARSERLOOKUP;

protected:
    CDrg m_cdrgObjectInfo;
    IVariantIO *m_pvio;
    HFILE m_hfileSource;
	LPTSTR m_pszParam;
    int m_iParamLineIndex;
    int m_iParamIndex;
    int m_iCurrentParamIndex;
    LPTSTR m_lptstrCurrentParam;

private:
    static CGraphicObject * CreateArc(BOOL fFilled);
    static CGraphicObject * CreateOval(BOOL fFilled);
    static CGraphicObject * CreatePolygon(BOOL fFilled);
    static CGraphicObject * CreatePolyBez(BOOL fFilled);
    static CGraphicObject * CreateRect(BOOL fFilled);
    static CGraphicObject * CreateRoundRect(BOOL fFilled);
    static CGraphicObject * CreateString(BOOL fFilled);
    static CGraphicObject * CreateFillColor(BOOL fFilled);
    static CGraphicObject * CreateFillStyle(BOOL fFilled);
    static CGraphicObject * CreateGradientFill(BOOL fFilled);
    static CGraphicObject * CreateGradientShape(BOOL fFilled);
    static CGraphicObject * CreateLineColor(BOOL fFilled);
    static CGraphicObject * CreateLineStyle(BOOL fFilled);
    static CGraphicObject * CreateHatchFill(BOOL fFilled);
    static CGraphicObject * CreateFont(BOOL fFilled);
    static CGraphicObject * CreateTextureFill(BOOL fFilled);

    static PARSERLOOKUP s_parserlookupTable[];

    CGraphicObject *InstantiateObject(LPTSTR lptstrParam);
    BOOL ReadSourceLine(LPTSTR lptstrParam);
    BOOL WriteSourceLine(LPTSTR lptstrParam);

    void AppendCharToParam(TCHAR ch)
    {
        TCHAR rgtchTemp[4];

        rgtchTemp[0] = ch;
        rgtchTemp[1] = 0;
        rgtchTemp[2] = 0;

		CStringWrapper::Strcat(m_pszParam, rgtchTemp);
    }

public:
    //
    // Constructor and destructor
    //
    CParser();
    ~CParser();

    void Cleanup();

	HRESULT AddPrimitive(LPTSTR pszLine);
    HRESULT LoadObjectInfo(IVariantIO *pvio, BSTR bstrSourceURL, 
                           IUnknown * punkContainer = NULL, BOOL fCleanFirst = TRUE );

    BOOL AnimatesOverTime(void);

    BOOL InsertObject(CGraphicObject *pGraphicObject);

    HRESULT SaveObjectInfo(IVariantIO *pvio);
    HRESULT PlaybackObjectInfo(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord);

    BOOL GetParam(int iParamIndex, LPTSTR *lplptstrParam);
    BOOL GetIntegerParam(int iParamIndex, int *piValue);
    BOOL GetLongParam(int iParamIndex, long *plValue) { return GetIntegerParam(iParamIndex, (int *)plValue); }
    BOOL GetByteParam(int iParamIndex, BYTE *pbValue)
    {
        BOOL fResult = FALSE;
        int iValue = 0;

        fResult = GetIntegerParam(iParamIndex, &iValue);

        if (fResult)
        {
            *pbValue = (BYTE)iValue;
        }

        return fResult;
    }

    BOOL GetFloatParam(int iParamIndex, float *pfValue);
    BOOL GetStringParam(int iParamIndex, LPTSTR lptstrValue);

    BOOL PutIntegerParam(int iValue);
    BOOL PutLongParam(long lValue) { return PutIntegerParam((int)lValue); }
    BOOL PutByteParam(BYTE bValue) { return PutIntegerParam((int)bValue); }
    BOOL PutFloatParam(float fValue);
    BOOL PutStringParam(LPTSTR lptstrValue);
};


#endif // __PARSER_H__

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\sgevent.h ===
/*++

Module: 
	sgevent.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Macros to make firing events easier and safer.  Each macro can be customised for 
	the particular event.  However, the general form should be:

	#define FIRE_EVENTNAME(pConnectionPoint, param1, param2) \
		pConnectionPoint->FireEvent(DISPID_SG_EVENT_EVENTNAME, \
			<VT for param1>, param1, \
			<VT for param2>, param2, \
			0) 
	
	NOTE: The terminating 0 is extremly important !!!

History:
	05-28-1997	Created (SimonB)

++*/

#include <dispids.h>

#ifndef __SGEVENT_H__
#define __SGEVENT_H__

// Shift/Ctrl/Alt, and mouse button states for events
#define KEYSTATE_SHIFT  1
#define KEYSTATE_CTRL   2
#define KEYSTATE_ALT    4

#define MOUSEBUTTON_LEFT     1
#define MOUSEBUTTON_RIGHT    2
#define MOUSEBUTTON_MIDDLE   4

// Event firing macros

#define FIRE_MOUSEMOVE(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_MOUSEMOVE, \
	    	VT_I4, BUTTON, \
	    	VT_I4, SHIFT, \
	    	VT_I4, X, \
	    	VT_I4, Y, \
	    	0)

#define FIRE_MOUSEDOWN(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_MOUSEDOWN, \
	    	VT_I4, BUTTON, \
	    	VT_I4, SHIFT, \
	    	VT_I4, X, \
	    	VT_I4, Y, \
	    	0)

#define FIRE_MOUSEUP(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_MOUSEUP, \
	    	VT_I4, BUTTON, \
	    	VT_I4, SHIFT, \
	    	VT_I4, X, \
	    	VT_I4, Y, \
	    	0)

#define FIRE_DBLCLICK(pConnectionPoint) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_DBLCLICK, 0)


#define FIRE_CLICK(pConnectionPoint) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_CLICK, 0)

#endif // __SGEVENT_H__

// End of file sgevent.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\parser.cpp ===
/*==========================================================================*\

Module:
    parser.cpp

Author:
    IHammer Team (MByrd)

Created:
    November 1996

Description:
    CParser Class Implementation

History:
    11-07-1996  Created

\*==========================================================================*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include <urlarchv.h>
#include "utils.h"
#include "strwrap.h"
#include "sgrfx.h"
#include "parser.h"

#ifndef ARRAYDIM
  #define ARRAYDIM(a)  (sizeof(a) / sizeof(a[0]))
#endif // ARRAYDIM

/*==========================================================================*\
    CParser Class Implementation:
\*==========================================================================*/

CGraphicObject * CParser::CreateArc(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicArc(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateOval(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicOval(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreatePolygon(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicPolygon(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreatePolyBez(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicPolyBez(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateRect(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicRect(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateRoundRect(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicRoundRect(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateString(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicString();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateFillColor(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicFillColor();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateFillStyle(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicFillStyle();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateGradientFill(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicGradientFill();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateGradientShape(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicGradientShape();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateLineColor(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicLineColor();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateLineStyle(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicLineStyle();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateHatchFill(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicHatchFill();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateFont(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicFont();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateTextureFill(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicTextureFill();

    return pResult;
}

/*==========================================================================*/

CParser::PARSERLOOKUP CParser::s_parserlookupTable[] =
{
    { _T("Arc"),                GR_ARC,         FALSE, (CREATEGRAPHICPROC)CParser::CreateArc},
    { _T("Oval"),               GR_OVAL,        TRUE,  (CREATEGRAPHICPROC)CParser::CreateOval},
    { _T("Pie"),                GR_ARC,         TRUE,  (CREATEGRAPHICPROC)CParser::CreateArc},
    { _T("Polyline"),           GR_POLYGON,     FALSE, (CREATEGRAPHICPROC)CParser::CreatePolygon},
    { _T("Polygon"),            GR_POLYGON,     TRUE,  (CREATEGRAPHICPROC)CParser::CreatePolygon},
    { _T("PolySpline"),         GR_POLYBEZ,     FALSE, (CREATEGRAPHICPROC)CParser::CreatePolyBez},
    { _T("FillSpline"),         GR_POLYBEZ,     TRUE,  (CREATEGRAPHICPROC)CParser::CreatePolyBez},
    { _T("Rect"),               GR_RECT,        TRUE,  (CREATEGRAPHICPROC)CParser::CreateRect},
    { _T("RoundRect"),          GR_ROUNDRECT,   TRUE,  (CREATEGRAPHICPROC)CParser::CreateRoundRect},
    { _T("Text"),               GR_STRING,      FALSE, (CREATEGRAPHICPROC)CParser::CreateString},
    { _T("SetFillColor"),       GR_FILLCOLOR,   FALSE, (CREATEGRAPHICPROC)CParser::CreateFillColor},
    { _T("SetFillStyle"),       GR_FILLSTYLE,   FALSE, (CREATEGRAPHICPROC)CParser::CreateFillStyle},
    { _T("SetGradientFill"),    GR_GRADFILL,    FALSE, (CREATEGRAPHICPROC)CParser::CreateGradientFill},
    { _T("SetGradientShape"),   GR_GRADSHAPE,   FALSE, (CREATEGRAPHICPROC)CParser::CreateGradientShape},
    { _T("SetLineColor"),       GR_LINECOLOR,   FALSE, (CREATEGRAPHICPROC)CParser::CreateLineColor},
    { _T("SetLineStyle"),       GR_LINESTYLE,   FALSE, (CREATEGRAPHICPROC)CParser::CreateLineStyle},
    { _T("SetHatchFill"),       GR_HATCHFILL,   FALSE, (CREATEGRAPHICPROC)CParser::CreateHatchFill},
    { _T("SetFont"),            GR_FONT,        FALSE, (CREATEGRAPHICPROC)CParser::CreateFont},
    { _T("SetTextureFill"),     GR_TEXTUREFILL, FALSE, (CREATEGRAPHICPROC)CParser::CreateTextureFill},
    { _T("\0"),                 GR_UNKNOWN,     FALSE, (CREATEGRAPHICPROC)NULL}
};

/*==========================================================================*/

CParser::CParser()
{
    m_cdrgObjectInfo.SetNonDefaultSizes(sizeof(CGraphicObject *));
    m_cdrgObjectInfo.MakeNull();

    m_pvio = (IVariantIO *)NULL;
    m_iParamLineIndex = -1;
    m_iParamIndex = -1;
    m_hfileSource = (HFILE)NULL;
    m_iCurrentParamIndex = -1;
    m_lptstrCurrentParam = (LPTSTR)NULL;
	m_pszParam = NULL;
}

/*==========================================================================*/

CParser::~CParser()
{
    Cleanup();
}

/*==========================================================================*/

void CParser::Cleanup()
{
    int iCount = m_cdrgObjectInfo.Count();

    if (iCount)
    {
        int iIndex = 0;

        for(iIndex=0;iIndex<iCount;iIndex++)
        {
            CGraphicObject **pGraphicObject = (CGraphicObject **)m_cdrgObjectInfo.GetAt(iIndex);

            if (pGraphicObject && *pGraphicObject)
            {
                Delete *pGraphicObject;
            }
        }
    }

    m_cdrgObjectInfo.MakeNull();
	
	if (NULL != m_pszParam)
		Delete [] m_pszParam;
}

/*==========================================================================*/

CGraphicObject *CParser::InstantiateObject(LPTSTR lptstrParam)
{
    CGraphicObject *pResult = NULL;

    if (lptstrParam && (CStringWrapper::Strlen(lptstrParam) > 0))
    {
        int iIndex = 0;
        int iMax   = sizeof(s_parserlookupTable) / sizeof(PARSERLOOKUP);

        // Strip leading whitespace
        while(*lptstrParam == _T(' ') || *lptstrParam == _T('\t'))
            lptstrParam = CStringWrapper::Strinc(lptstrParam);

        while(iIndex < iMax)
        {
            PARSERLOOKUP *pWalker = &s_parserlookupTable[iIndex];
            int iParseLen = CStringWrapper::Strlen(pWalker->rgtchName);

            if (iParseLen > 0 &&
                CStringWrapper::Strnicmp(pWalker->rgtchName, lptstrParam, iParseLen) == 0)
            {
                if (pWalker->pCreateGraphicProc)
                {
                    // Create the proper object type...
                    pResult = (*(pWalker->pCreateGraphicProc))(pWalker->fFilled);
                }

                break;
            }

            iIndex++;
        }
    }

    return pResult;
}

/*==========================================================================*/

BOOL CParser::GetParam(int iParamIndex, LPTSTR *lplptstrParam)
{
    BOOL fResult = FALSE;

    if (iParamIndex >= 0 && lplptstrParam)
    {
        TCHAR *ptchNext = (TCHAR *)m_pszParam;
        int iCurrIndex=0;

        *lplptstrParam = (LPTSTR)NULL;

        if (iParamIndex == m_iCurrentParamIndex)
        {
            // Special-case for current parameter...
            *lplptstrParam = m_lptstrCurrentParam;
            fResult = TRUE;
        }
        else
        {
            BOOL fGotParen = FALSE;

            if (m_iCurrentParamIndex < 0 || m_iCurrentParamIndex > iParamIndex)
            {
                // First, find the starting '(' ...
                while(*ptchNext && *ptchNext != START_PARAM)
                    ptchNext = CStringWrapper::Strinc(ptchNext);

                m_iCurrentParamIndex = -1;
                m_lptstrCurrentParam = (LPTSTR)NULL;
            }
            else
            {
                iCurrIndex = m_iCurrentParamIndex;
                ptchNext   = m_lptstrCurrentParam;
                fGotParen  = TRUE;
            }

            if (!fGotParen)
            {
                // Found the open parenthesis!
                if (*ptchNext == START_PARAM)
                {
                    // Skip the open parenthesis...
                    ptchNext = CStringWrapper::Strinc(ptchNext);
                    fGotParen = TRUE;
                }
            }

            if (fGotParen)
            {
                while(iParamIndex > iCurrIndex)
                {
                    BOOL fString  = FALSE;
                    BOOL fLiteral = FALSE;

                    // Look for a comma (PARAM_SEP)...
                    while(*ptchNext)
                    {
                        if (!fString)
                        {
                            if (*ptchNext == PARAM_SEP)
                            {
                                iCurrIndex++;

                                if (iParamIndex == iCurrIndex)
                                {
                                    ptchNext = CStringWrapper::Strinc(ptchNext);
                                    break;
                                }
                            }

                            if (*ptchNext == START_STRING)
                                fString = TRUE;

                            if (*ptchNext == END_PARAM)
                            {
                                ptchNext = (TCHAR *)NULL;
                                break;
                            }
                        }
                        else
                        {
                            if (!fLiteral)
                            {
                                if (*ptchNext == LITERAL)
                                {
                                    fLiteral = TRUE;
                                }
                                else
                                {
                                    if (*ptchNext == END_STRING)
                                        fString = FALSE;
                                }
                            }
                            else
                            {
                                // Completely ignore character following '\'
                                fLiteral = FALSE;
                            }
                        }

                        ptchNext = CStringWrapper::Strinc(ptchNext);
                    }

                    if (!ptchNext || !*ptchNext)
                        break;
                }

                // At this point, the offset should be correct...
                if (iParamIndex == iCurrIndex && ptchNext)
                {
                    // Skip any whitespace...
                    while(*ptchNext)
                    {
                        if (*ptchNext != _T(' ') &&
                            *ptchNext != _T('\r') &&
                            *ptchNext != _T('\n') &&
                            *ptchNext != _T('\t'))
                        {
                            break;
                        }

                        ptchNext = CStringWrapper::Strinc(ptchNext);
                    }

                    // Return the result...
                    if (*ptchNext)
                    {
                        m_iCurrentParamIndex = iParamIndex;
                        *lplptstrParam = ptchNext;
                        m_lptstrCurrentParam = ptchNext;
                        fResult = TRUE;
                    }
                }
            }
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::GetIntegerParam(int iParamIndex, int *piValue)
{
    BOOL fResult = FALSE;

    if (iParamIndex >= 0 && piValue)
    {
        LPTSTR lptstrParam = (LPTSTR)NULL;

        *piValue = 0;

        if (GetParam(iParamIndex, &lptstrParam))
        {
            *piValue = CStringWrapper::Atoi(lptstrParam);
            fResult = TRUE;
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::GetFloatParam(int iParamIndex, float *pfValue)
{
    BOOL fResult = FALSE;

    if (iParamIndex >= 0 && pfValue)
    {
        LPTSTR lptstrParam = (LPTSTR)NULL;

        *pfValue = 0.0f;

        if (GetParam(iParamIndex, &lptstrParam))
        {
            double  dbl;

			CStringWrapper::Sscanf1(lptstrParam, "%lf", &dbl);
            // *pdValue = CStringWrapper::Atof(lptstrParam); PAULD There's no TCHAR version of atof
            *pfValue = static_cast<float>(dbl);
            fResult = TRUE;
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::GetStringParam(int iParamIndex, LPTSTR lptstrValue)
{
    BOOL fResult = FALSE;

    if (iParamIndex >= 0 && lptstrValue)
    {
        LPTSTR lptstrParam = (LPTSTR)NULL;

        // Null-terminate the output string...
        lptstrValue[0] = 0;
        lptstrValue[1] = 0;

        if (GetParam(iParamIndex, &lptstrParam))
        {
            BOOL fString  = FALSE;
            BOOL fLiteral = FALSE;
            TCHAR *ptchNext = (TCHAR *)lptstrParam;

            // Look for a comma (PARAM_SEP)...
            while(*ptchNext)
            {
                if (!fString)
                {
                    if (*ptchNext == PARAM_SEP)
                        break;

                    if (*ptchNext == END_PARAM)
                        break;

                    if (*ptchNext == START_STRING)
                    {
                        fString = TRUE;
                    }
                }
                else
                {
                    TCHAR rgtchTemp[4];

                    rgtchTemp[0] = 0;
                    rgtchTemp[1] = 0;
                    rgtchTemp[2] = 0;
                    rgtchTemp[3] = 0;

                    if (!fLiteral)
                    {
                        if (*ptchNext == LITERAL)
                        {
                            fLiteral = TRUE;
                        }
                        else
                        {
                            if (*ptchNext == END_STRING)
                            {
                                fString = FALSE;
								fResult = TRUE;
                                break;
                            }
                            else
                            {
                                CStringWrapper::Strncpy(rgtchTemp, ptchNext, 1);
                                CStringWrapper::Strcat(lptstrValue, rgtchTemp);
                            }
                        }
                    }
                    else
                    {
                        // Copy over the literal character...
                        fLiteral = FALSE;

                        CStringWrapper::Strncpy(rgtchTemp, ptchNext, 1);
                        CStringWrapper::Strcat(lptstrValue, rgtchTemp);
                    }
                }

                ptchNext = CStringWrapper::Strinc(ptchNext);
            }
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::PutIntegerParam(int iValue)
{
    TCHAR rgtchTemp[80];

    if (m_iParamIndex != 0)
        AppendCharToParam(PARAM_SEP);

    m_iParamIndex++;

	CStringWrapper::Sprintf(rgtchTemp, "%d", iValue);
    CStringWrapper::Strcat(m_pszParam, rgtchTemp);

    return TRUE;
}

/*==========================================================================*/

BOOL CParser::PutFloatParam(float fValue)
{
    
	TCHAR rgtchTemp[80];
    double   dbl = static_cast<double>(fValue);

    if (m_iParamIndex != 0)
        AppendCharToParam(PARAM_SEP);

    m_iParamIndex++;
    
	CStringWrapper::Sprintf(rgtchTemp, "%.6lf", dbl);
    CStringWrapper::Strcat(m_pszParam, rgtchTemp);
    
	return TRUE;
}

/*==========================================================================*/

BOOL CParser::PutStringParam(LPTSTR lptstrValue)
{
	BOOL fResult = FALSE;

    if (lptstrValue)
    {
        TCHAR *ptchNext = (TCHAR *)lptstrValue;

        if (m_iParamIndex != 0)
            AppendCharToParam(PARAM_SEP);

        m_iParamIndex++;

        AppendCharToParam(START_STRING);

        // Walk the source string and replace any END_STRING chars with
        // LITERAL/END_STRING chars...

        while(*ptchNext)
        {
            TCHAR rgtchTemp[4];

            // zero out the temp string buffer...
            rgtchTemp[0] = 0;
            rgtchTemp[1] = 0;
            rgtchTemp[2] = 0;
            rgtchTemp[3] = 0;

            if (*ptchNext == END_STRING)
            {
                AppendCharToParam(LITERAL);
            }

            CStringWrapper::Strncpy(rgtchTemp, ptchNext, 1);
            CStringWrapper::Strcat(m_pszParam, rgtchTemp);

            ptchNext = CStringWrapper::Strinc(ptchNext);
        }

        AppendCharToParam(END_STRING);

        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::ReadSourceLine(LPTSTR lptstrParam)
{
    BOOL fResult = FALSE;

    if (m_hfileSource)
    {
        // Force the line to be NULL-terminated by default...
        lptstrParam[0] = 0;
        lptstrParam[1] = 0;

        fResult = TRUE;
    }
    else if (m_pvio)
    {
        HRESULT hRes = S_OK;
        BSTR bstrParamLine = NULL;
        TCHAR rgchLineName[80];

		CStringWrapper::Sprintf(rgchLineName, "Line%04d", m_iParamLineIndex+1);

        // Read from the variant info...
        hRes = m_pvio->Persist(0, rgchLineName, VT_BSTR, &bstrParamLine, NULL);

        if (SUCCEEDED(hRes) && bstrParamLine)
        {
            // Convert to LPTSTR!
#ifdef UNICODE
            CStringWrapper::Strcpy(lptstrParam, bstrParamLine);
            fResult = TRUE;
#else // !UNICODE
			int iLen = WideCharToMultiByte(CP_ACP, 
				0, 
				bstrParamLine, 
				-1,
				NULL, 
				0, 
				NULL,
				NULL);

            if (iLen < MAX_PARAM_LENGTH)
            {
                CStringWrapper::Wcstombs(lptstrParam, bstrParamLine, MAX_PARAM_LENGTH);
				WideCharToMultiByte(CP_ACP, 
					0, 
					bstrParamLine, 
					-1,
					lptstrParam, 
					MAX_PARAM_LENGTH, 
					NULL,
					NULL);
                fResult = TRUE;
            }
#endif // !UNICODE

            SysFreeString(bstrParamLine);
        }

        // Make sure to strip off any leading whitespace...
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::WriteSourceLine(LPTSTR lptstrParam)
{
    BOOL fResult = FALSE;

    if (m_pvio && lptstrParam)
    {
        LPWSTR pwszParam = NULL;
        BSTR bstrParamLine = NULL;
        HRESULT hRes = S_OK;
        TCHAR rgchLineName[80];

        pwszParam = New WCHAR[MAX_PARAM_LENGTH];

        // Make sure our allocation succeeded
        if (NULL == pwszParam)
            return FALSE;

        CStringWrapper::Sprintf(rgchLineName, "Line%04d", m_iParamLineIndex+1);
        CStringWrapper::Memset(pwszParam, 0, MAX_PARAM_LENGTH * sizeof(WCHAR));

#ifdef UNICODE
        CStringWrapper::Strcpy(pwszParam, lptstrParam);
        fResult = TRUE;
#else // !UNICODE
        CStringWrapper::Mbstowcs(pwszParam, lptstrParam, CStringWrapper::Strlen(lptstrParam));
#endif // !UNICODE

        // Convert the lptstrParam to a BSTR...
        bstrParamLine = SysAllocString(pwszParam);

        Delete pwszParam;

        // iff the allocation worked,  persist the parameter line...
        if (bstrParamLine)
        {
            // Write to the variant info...
            hRes = m_pvio->Persist(0, rgchLineName, VT_BSTR, &bstrParamLine, NULL);

            // Return code based upon success of Persist...
            fResult = SUCCEEDED(hRes);

            // Cleanup...
            SysFreeString(bstrParamLine);
        }
    }

    return fResult;
}

/*==========================================================================*/

HRESULT CParser::AddPrimitive(LPTSTR pszLine)
{
	HRESULT hr = S_OK;
	CGraphicObject *pGraphicObject = NULL;

    m_iCurrentParamIndex = -1;
    m_lptstrCurrentParam = (LPTSTR)NULL;
	m_pszParam = pszLine;
	pGraphicObject = InstantiateObject(m_pszParam);

	if (pGraphicObject)
	{
		if (pGraphicObject->LoadObject(*this))
		{
			m_cdrgObjectInfo.Insert((LPVOID)&pGraphicObject, DRG_APPEND);
		}
		else
		{
			hr = E_FAIL;
			Delete pGraphicObject;
		}
	}
	else
	{
		hr = E_FAIL;
	}

	m_pszParam = NULL;

	return hr;
}


/*==========================================================================*/

HRESULT CParser::LoadObjectInfo(IVariantIO *pvio, 
                                BSTR bstrSourceURL, 
                                IUnknown * punkContainer,
                                BOOL       fCleanFirst)
{
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;

    // Get rid of any previous object info...
    if( fCleanFirst )
        Cleanup();

	m_pszParam = New TCHAR[MAX_PARAM_LENGTH*2];

	if (NULL == m_pszParam)
		return E_OUTOFMEMORY;

    // First attempt to open the source URL...
    if (bstrSourceURL)
    {
		CURLArchive urlArchive(punkContainer);

        if( SUCCEEDED( hr = urlArchive.Create(bstrSourceURL) ) )
        {
            CStringWrapper::Memset(m_pszParam, 0, (MAX_PARAM_LENGTH*2) * sizeof(TCHAR));

            while(urlArchive.ReadLine(m_pszParam, (MAX_PARAM_LENGTH*2)))
            {
                CGraphicObject *pGraphicObject = NULL;            

                m_iCurrentParamIndex = -1;
                m_lptstrCurrentParam = (LPTSTR)NULL;

                pGraphicObject = InstantiateObject(m_pszParam);

                if (pGraphicObject)
                {
                    if (pGraphicObject->LoadObject(*this))
                    {
                        m_cdrgObjectInfo.Insert((LPVOID)&pGraphicObject, DRG_APPEND);
                    }
                    else
                    {
                        Delete pGraphicObject;
                    }
                }
            }
            
        }
        //fDone = TRUE;
    }

    // Next read the html PARAM tags...
    if (pvio && !fDone)
    {
        int iParamIndex = 0;        

        // Walk the parameter lines...
        m_pvio = pvio;
        m_iParamLineIndex = 0;

		CStringWrapper::Memset(m_pszParam, 0, (MAX_PARAM_LENGTH*2) * sizeof(TCHAR)); 

        while(ReadSourceLine(m_pszParam))
        {
            CGraphicObject *pGraphicObject = NULL;

            m_iCurrentParamIndex = -1;
            m_lptstrCurrentParam = (LPTSTR)NULL;

            pGraphicObject = InstantiateObject(m_pszParam);

            if (pGraphicObject)
            {
                if (pGraphicObject->LoadObject(*this))
                {
                    m_cdrgObjectInfo.Insert((LPVOID)&pGraphicObject, DRG_APPEND);
                }
                else
                {
#ifdef _DEBUG
					TCHAR tchLine[80];
					wsprintf(tchLine, TEXT("CParser::LoadObjectInfo - error loading on line %lu\n"), m_iParamLineIndex);
					ODS(tchLine);
#endif
                    Delete pGraphicObject;
                }
            }

			CStringWrapper::Memset(m_pszParam, 0, sizeof(m_pszParam)); // BUGBUG

            m_iParamLineIndex++;
        }

        m_pvio = NULL;
        m_iParamLineIndex = -1;
    }

	if (m_pszParam)
	{
		Delete [] m_pszParam;
		m_pszParam = NULL;
	}

    return hr;
}

/*==========================================================================*/

BOOL CParser::InsertObject(CGraphicObject *pGraphicObject)
{
	return m_cdrgObjectInfo.Insert((LPVOID)&pGraphicObject, DRG_APPEND);
}
/*==========================================================================*/

HRESULT CParser::SaveObjectInfo(IVariantIO *pvio)
{
    HRESULT hr = S_OK;

    if (pvio)
    {
		m_pszParam = New TCHAR[MAX_PARAM_LENGTH*2];

		if (NULL == m_pszParam)
			return E_OUTOFMEMORY;

        int iObjectCount = m_cdrgObjectInfo.Count();
        int iObjectIndex = 0;

        // Output the internal object info...
        m_pvio = pvio;
        m_iParamLineIndex = 0;

        while(iObjectIndex < iObjectCount)
        {
            CGraphicObject **pGraphicObject = (CGraphicObject **)m_cdrgObjectInfo.GetAt(iObjectIndex);

            // Make sure we start with an empty parameter line...
            m_pszParam[0] = 0;

            // Is the CDrg Valid?
            if (pGraphicObject && *pGraphicObject)
            {
                WORD wObjectType = (*pGraphicObject)->GetObjectType();
                BOOL fFilled     = (*pGraphicObject)->IsFilled();
                int iTableIndex = 0;
                int iTableMax   = sizeof(s_parserlookupTable) / sizeof(PARSERLOOKUP);

                // This assumes that the object was found in the
                // Parse table
                while(iTableIndex < iTableMax)
                {
                    PARSERLOOKUP *pWalker = &s_parserlookupTable[iTableIndex];

                    if (pWalker->wObjectType == wObjectType &&
                        pWalker->fFilled     == fFilled)
                    {
                        CStringWrapper::Strcpy(m_pszParam, pWalker->rgtchName);
                        AppendCharToParam(START_PARAM);
                        break;
                    }

                    iTableIndex++;
                }

                // Keep track of the parameters...
                m_iParamIndex = 0;

                if ((*pGraphicObject)->SaveObject(*this))
                {
                    AppendCharToParam(END_PARAM);
                    WriteSourceLine(m_pszParam);
                    m_iParamLineIndex ++;
                }
            }

            iObjectIndex++;
        }

        // Cleanup...
        m_pvio = NULL;
        m_iParamLineIndex = -1;
        m_iParamIndex = -1;

		if (m_pszParam)
		{
			Delete [] m_pszParam;
			m_pszParam = NULL;
		}

    }
	
    return hr;
}

/*==========================================================================*/

HRESULT CParser::PlaybackObjectInfo(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    HRESULT hr = S_OK;

    if (pIDADrawingSurface && pIDAStatics)
    {
        int iCount = m_cdrgObjectInfo.Count();
        int iIndex = 0;

        while(iIndex < iCount)
        {
            CGraphicObject **pGraphicObject = (CGraphicObject **)m_cdrgObjectInfo.GetAt(iIndex);

            if (pGraphicObject && *pGraphicObject)
                (*pGraphicObject)->Execute(pIDADrawingSurface, pIDAStatics, fFlipCoord);

            iIndex++;
        }
    }

    return hr;
}

/*==========================================================================*/

BOOL CParser::AnimatesOverTime(void)
{
    BOOL fResult = FALSE;

    int iCount = m_cdrgObjectInfo.Count();
    int iIndex = 0;

    while(iIndex < iCount)
    {
        CGraphicObject **pGraphicObject = (CGraphicObject **)m_cdrgObjectInfo.GetAt(iIndex);

        if (pGraphicObject && *pGraphicObject)
        {
            if ((*pGraphicObject)->AnimatesOverTime())
            {
                fResult = TRUE;
                break;
            }
        }

        iIndex++;
    }

    return fResult;
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\sginit.cpp ===
/*++

Module: 
	sginit.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Performs control-specific initialisation

History:
	05-28-1997	Created (SimonB)

++*/

#include "..\ihbase\ihbase.h"
#include "..\mmctl\inc\ochelp.h" // for ControlInfo
#include "sginit.h"
#include "..\resource.h"
#include <daxpress.h>

extern ULONG g_cLock;


void InitSGrfxControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.StructuredGraphicsControl");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Structured Graphics");
    pCtlInfo->pclsid = &CLSID_StructuredGraphicsControl;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = TEXT("1.0");
    pCtlInfo->iToolboxBitmapID = IDB_ICON_SGRFX;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_CONTROL | CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING | CI_MMCONTROL;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\grobj.cpp ===
/*==========================================================================*\

Module:
    grobj.cpp

Author:
    IHammer Team (MByrd)

Created:
    November 1996

Description:
    CGraphicObject derived Class Implementations

History:
    11-07-1996  Created

\*==========================================================================*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "utils.h"
#include "strwrap.h"
#include "sgrfx.h"
#include "parser.h"

/*==========================================================================*/

static BOOL SetColor(int iR, int iG, int iB, COLORREF *clrrefColor)
{
    if ((iR >= 0 && iR <= 255) &&
        (iG >= 0 && iG <= 255) &&
        (iB >= 0 && iB <= 255))
    {
        *clrrefColor = RGB(iR, iG, iB);
        return TRUE;
    }
	else
	{
		return FALSE;
	}
}

/*==========================================================================*/

static double FlipY(BOOL fFlipCoord, double dblYIn)
{
    double dblResult = dblYIn;

    // Due to changes in the handed-ness of the DAnim pixel mode
    // coordinate system (bug 8349), we reverse the polarity of the
    // test here to make everything work out right.
    if (!fFlipCoord)
        dblResult *= -1.0;

    return dblResult;
}

/*==========================================================================*/

static double PixelsToPoints(int iPixels, IDAStatics *pIDAStatics)
{
    double dblResult = (double)iPixels;

    if (pIDAStatics)
    {
        CComPtr<IDANumber> PixelPtr;
        double dblPixel = 0.0;

        //
        // NOTE : The Pixel behavior is currently constant!
        // This will break if this changes! (REVIEW : MBYRD,KGALLO)
        //

        if (SUCCEEDED(pIDAStatics->get_Pixel(&PixelPtr)) &&
            SUCCEEDED(PixelPtr->Extract(&dblPixel)))
        {
            double dblFactor = (72.0 * 39.370);

            dblResult = (dblPixel * dblFactor) * dblResult;
        }
    }

    return dblResult;
}

/*==========================================================================*/

static BOOL CreateDAColor(COLORREF clrrefColor, IDAStatics *pIDAStatics, IDAColor **ppColor)
{
    BOOL fResult = FALSE;

    if (ppColor && pIDAStatics)
    {
        fResult = SUCCEEDED(pIDAStatics->ColorRgb255(
            GetRValue(clrrefColor),
            GetGValue(clrrefColor),
            GetBValue(clrrefColor),
            ppColor));
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicObject Class Implementation:
\*==========================================================================*/

CGraphicObject::CGraphicObject()
{
    m_iXPosition = 0;
    m_iYPosition = 0;
    m_iCenterX = 0;
    m_iCenterY = 0;
    m_fltRotation = 0.0f;
}

/*==========================================================================*/

CGraphicObject::~CGraphicObject()
{
}

/*==========================================================================*/

BOOL CGraphicObject::WriteData(int iSizeData, LPVOID lpvData)
{
    return FALSE;
}

/*==========================================================================*/

BOOL CGraphicObject::ReadData(int iSizeData, LPVOID lpvData)
{
    return FALSE;
}

/*==========================================================================*/

BOOL CGraphicObject::ApplyRotation(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = TRUE;

    if (m_fltRotation != 0.0)
    {
        CComPtr<IDATransform2> RotateTransformPtr;
        CComPtr<IDATransform2> TranslateTransformPtr;
        CComPtr<IDATransform2> InvTranslateTransformPtr;
        double dblRotation = (double)m_fltRotation;

        if (fFlipCoord)
            dblRotation *= -1.0;

        if (SUCCEEDED(pIDAStatics->Rotate2Degrees(dblRotation, &RotateTransformPtr)) &&
            SUCCEEDED(pIDAStatics->Translate2(m_iCenterX, FlipY(fFlipCoord, m_iCenterY), &TranslateTransformPtr)) &&
            SUCCEEDED(pIDAStatics->Translate2(-m_iCenterX, -FlipY(fFlipCoord, m_iCenterY), &InvTranslateTransformPtr)) &&
            SUCCEEDED(pIDADrawingSurface->SaveGraphicsState()) &&
            SUCCEEDED(pIDADrawingSurface->Transform(TranslateTransformPtr)) &&
            SUCCEEDED(pIDADrawingSurface->Transform(RotateTransformPtr)) &&
            SUCCEEDED(pIDADrawingSurface->Transform(InvTranslateTransformPtr)))
        {
            fResult = TRUE;
        }
        else
        {
            fResult = FALSE;
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicObject::RemoveRotation(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics)
{
    BOOL fResult = TRUE;

    if (m_fltRotation != 0.0)
        fResult = SUCCEEDED(pIDADrawingSurface->RestoreGraphicsState());

    return fResult;
}

/*==========================================================================*\
    CGraphicArc Class Implementation:
\*==========================================================================*/

CGraphicArc::CGraphicArc(BOOL fFilled)
    : CGraphicObject()
{
    m_iWidth = 0;
    m_iHeight = 0;
    m_fStartAngle = 0.0f;
    m_fArcAngle = 0.0f;
    m_fFilled = fFilled;
}

/*==========================================================================*/

CGraphicArc::~CGraphicArc()
{
}

/*==========================================================================*/

BOOL CGraphicArc::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

        if (fResult)
        {
            if (m_fFilled)
            {
                fResult = SUCCEEDED(pIDADrawingSurface->PieDegrees(
                    (double)m_iXPosition,
                    FlipY(fFlipCoord, (double)m_iYPosition),
                    (double)m_fStartAngle,
                    (double)m_fStartAngle+m_fArcAngle,
                    (double)m_iWidth,
                    FlipY(fFlipCoord, (double)m_iHeight)));
            }
            else
            {
                fResult = SUCCEEDED(pIDADrawingSurface->ArcDegrees(
                    (double)m_iXPosition,
                    FlipY(fFlipCoord, (double)m_iYPosition),
                    (double)m_fStartAngle,
                    (double)m_fStartAngle+m_fArcAngle,
                    (double)m_iWidth,
                    FlipY(fFlipCoord, (double)m_iHeight)));
            }
        }

        if (fResult)
            RemoveRotation(pIDADrawingSurface, pIDAStatics);
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicArc::ValidateObject()
{
	return (m_fArcAngle != 0.0f);
}

/*==========================================================================*/

BOOL CGraphicArc::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetIntegerParam(0, &m_iXPosition) &&
        parser.GetIntegerParam(1, &m_iYPosition) &&
        parser.GetIntegerParam(2, &m_iWidth) &&
        parser.GetIntegerParam(3, &m_iHeight) &&
        parser.GetFloatParam(4, &m_fStartAngle) &&
        parser.GetFloatParam(5, &m_fArcAngle))
    {
        fResult = ValidateObject();

        if (fResult)
        {
            m_fltRotation = 0.0f;
            parser.GetFloatParam(6, &m_fltRotation);

            m_iCenterX = m_iXPosition + m_iWidth/2;
            m_iCenterY = m_iYPosition + m_iHeight/2;
        }
	}

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicArc::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition) &&
        parser.PutIntegerParam(m_iWidth) &&
        parser.PutIntegerParam(m_iHeight) &&
        parser.PutFloatParam(m_fStartAngle) &&
        parser.PutFloatParam(m_fArcAngle))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicOval Class Implementation:
\*==========================================================================*/

CGraphicOval::CGraphicOval(BOOL fFilled)
    : CGraphicObject()
{
    m_iWidth = 0;
    m_iHeight = 0;
    m_fFilled = fFilled;
}

/*==========================================================================*/

CGraphicOval::~CGraphicOval()
{
}

/*==========================================================================*/

BOOL CGraphicOval::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

        if (fResult)
        {
            fResult = SUCCEEDED(pIDADrawingSurface->Oval(
                (double)m_iXPosition,
                FlipY(fFlipCoord, (double)m_iYPosition),
                (double)m_iWidth,
                FlipY(fFlipCoord, (double)m_iHeight)));
        }

        if (fResult)
            RemoveRotation(pIDADrawingSurface, pIDAStatics);
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicOval::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetIntegerParam(0, &m_iXPosition) &&
        parser.GetIntegerParam(1, &m_iYPosition) &&
        parser.GetIntegerParam(2, &m_iWidth) &&
        parser.GetIntegerParam(3, &m_iHeight))
    {
        fResult = TRUE;

        m_fltRotation = 0.0f;
        parser.GetFloatParam(4, &m_fltRotation);

        m_iCenterX = m_iXPosition + m_iWidth/2;
        m_iCenterY = m_iYPosition + m_iHeight/2;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicOval::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition) &&
        parser.PutIntegerParam(m_iWidth) &&
        parser.PutIntegerParam(m_iHeight))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicPolygon Class Implementation:
\*==========================================================================*/

CGraphicPolygon::CGraphicPolygon(BOOL fFilled)
    : CGraphicObject()
{
    m_fFilled = fFilled;
    m_lpPolyPoints  = (LPPOINT)NULL;
    m_iPointCount = 0;
}

/*==========================================================================*/

CGraphicPolygon::~CGraphicPolygon()
{
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = (LPPOINT)NULL;
        m_iPointCount = 0;
    }
}

/*==========================================================================*/

BOOL CGraphicPolygon::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && m_iPointCount >= 2)
    {
        SAFEARRAY * s = SafeArrayCreateVector(VT_R8, 0, m_iPointCount * 2);

        if (s)
        {
            VARIANT v;
            VariantInit(&v);
    
            V_ARRAY(&v) = s;
            v.vt = VT_ARRAY | VT_R8;

            // There is no reason to worry about locking the data
            // since we just created it.  So just grab the data
            // pointer and setup the double array
    
            double * pDbl = (double *) s->pvData;
    
            for (int i = 0;i < m_iPointCount;i++)
            {
                pDbl[i * 2]     = (double)m_lpPolyPoints[i].x;
                pDbl[i * 2 + 1] = FlipY(fFlipCoord, (double)m_lpPolyPoints[i].y);
            }
    
            fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

            if (fResult)
            {
                if (m_fFilled)
                {
                    fResult = SUCCEEDED(pIDADrawingSurface->Polygon(v));
                }
                else
                {
                    fResult = SUCCEEDED(pIDADrawingSurface->Polyline(v));
                }
            }

            if (fResult)
                fResult = RemoveRotation(pIDADrawingSurface, pIDAStatics);

            // Perhaps we should check the return value but for now
            // just ignore it
            SafeArrayDestroy(s);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicPolygon::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    // Clear the point array...
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = NULL;
        m_iPointCount = 0;
    }

    if (parser.GetIntegerParam(0, &m_iPointCount) && m_iPointCount >= 2)
    {
        int iPointIndex = 0;
        int iParamIndex = 1;

        m_lpPolyPoints = New POINT [m_iPointCount];

        if (m_lpPolyPoints)
        {
            int iMinX = 32000;
            int iMaxX = -32000;
            int iMinY = 32000;
            int iMaxY = -32000;

            fResult = TRUE;

            for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
            {
                int iValue1 = 0;
                int iValue2 = 0;

                if (parser.GetIntegerParam(iParamIndex,   &iValue1) &&
                    parser.GetIntegerParam(iParamIndex+1, &iValue2))
                {
                    m_lpPolyPoints[iPointIndex].x = iValue1;
                    m_lpPolyPoints[iPointIndex].y = iValue2;

                    if (iValue1 < iMinX)
                        iMinX = iValue1;
                    if (iValue1 > iMaxX)
                        iMaxX = iValue1;
                    if (iValue2 < iMinY)
                        iMinY = iValue2;
                    if (iValue2 > iMaxY)
                        iMaxY = iValue2;
                }
                else
                {
                    fResult = FALSE;
                    break;
                }

                iParamIndex += 2;
            }

            m_iCenterX = (iMaxX + iMinX) / 2;
            m_iCenterY = (iMaxY + iMinY) / 2;
        }

        if (!fResult)
        {
            m_iPointCount = 0;

            if (m_lpPolyPoints)
            {
                Delete [] m_lpPolyPoints;
                m_lpPolyPoints = (LPPOINT)NULL;
            }
        }
        else
        {
            m_fltRotation = 0.0f;
            parser.GetFloatParam(iParamIndex, &m_fltRotation);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicPolygon::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iPointCount))
    {
        int iPointIndex = 0;

        fResult = TRUE;

        for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
        {
            if (!parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].x) ||
                !parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].y))
            {
                fResult = FALSE;
                break;
            }
        }

        if (fResult && m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicPolyBez Class Implementation:
\*==========================================================================*/

CGraphicPolyBez::CGraphicPolyBez(BOOL fFilled)
    : CGraphicObject()
{
    m_fFilled = fFilled;

    m_iPointCount  = 0;
    m_lpPolyPoints = (LPPOLYBEZPOINT)NULL;
    m_lpPointArray = (LPPOINT)NULL;
    m_lpByteArray  = (LPBYTE)NULL;
}

/*==========================================================================*/

CGraphicPolyBez::~CGraphicPolyBez()
{
    if (m_iPointCount)
    {
        if (m_lpPolyPoints)
        {
            Delete [] m_lpPolyPoints;
            m_lpPolyPoints = (LPPOLYBEZPOINT)NULL;
        }

        if (m_lpPointArray)
        {
            Delete [] m_lpPointArray;
            m_lpPointArray = (LPPOINT)NULL;
        }

        if (m_lpByteArray)
        {
            Delete [] m_lpByteArray;
            m_lpByteArray = (LPBYTE)NULL;
        }

        m_iPointCount = 0;
    }
}

/*==========================================================================*/

BOOL CGraphicPolyBez::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && m_iPointCount)
    {
        SAFEARRAY * saPoints = SafeArrayCreateVector(VT_R8, 0, m_iPointCount * 2);
        SAFEARRAY * saCodes  = SafeArrayCreateVector(VT_R8, 0, m_iPointCount);

        if (saPoints && saCodes)
        {
            VARIANT varPoints;
            VARIANT varCodes;
            double *pdblPoints;
            double *pdblCodes;

            VariantInit(&varPoints);
            VariantInit(&varCodes);

            V_ARRAY(&varPoints) = saPoints;
            varPoints.vt = VT_ARRAY | VT_R8;

            V_ARRAY(&varCodes) = saCodes;
            varCodes.vt = VT_ARRAY | VT_R8;

            pdblPoints = (double *)saPoints->pvData;
            pdblCodes = (double *)saCodes->pvData;

            for(int i=0;i<m_iPointCount;i++)
            {
                pdblPoints[(i*2)  ] = (double)m_lpPointArray[i].x;
                pdblPoints[(i*2)+1] = FlipY(fFlipCoord, (double)m_lpPointArray[i].y);

                pdblCodes[i] = (double)ConvertFlags(m_lpByteArray[i]);
            }

            fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

            if (fResult)
            {
                CComPtr<IDAPath2> PathPtr;

                fResult = SUCCEEDED(pIDAStatics->PolydrawPath(varPoints, varCodes, &PathPtr));

                if (fResult)
                {
                    if (m_fFilled)
                    {
                        fResult = SUCCEEDED(pIDADrawingSurface->FillPath(PathPtr));
                    }
                    else
                    {
                        fResult = SUCCEEDED(pIDADrawingSurface->DrawPath(PathPtr));
                    }
                }
            }

            if (fResult)
                fResult = RemoveRotation(pIDADrawingSurface, pIDAStatics);
        }

        if (saPoints)
        {
            SafeArrayDestroy(saPoints);
        }

        if (saCodes)
        {
            SafeArrayDestroy(saCodes);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicPolyBez::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
	LPPOLYBEZPOINT pPolyPoints = NULL;
	int iPointCount = 0;
    int iPointIndex = 0;

    // Clear the point array...
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = NULL;
        m_iPointCount = 0;
    }

    if (parser.GetIntegerParam(0, &iPointCount))
    {
        int iParamIndex = 1;

        if (iPointCount >= 2)
        {
            pPolyPoints = New POLYBEZPOINT [iPointCount];

            if (pPolyPoints)
            {
                fResult = TRUE;

                for(iPointIndex = 0;iPointIndex < iPointCount;iPointIndex++)
                {
                    BYTE bValue = 0;
                    int iValue1 = 0;
                    int iValue2 = 0;

                    if (parser.GetByteParam(iParamIndex, &bValue) &&
                        parser.GetIntegerParam(iParamIndex+1, &iValue1) &&
                        parser.GetIntegerParam(iParamIndex+2, &iValue2))
                    {
                        pPolyPoints[iPointIndex].iFlags = bValue;
                        pPolyPoints[iPointIndex].iX     = iValue1;
                        pPolyPoints[iPointIndex].iY     = iValue2;
                    }
                    else
                    {
                        fResult = FALSE;
                        break;
                    }

                    iParamIndex += 3;
                }

            }
        }

        if (!fResult)
        {
            if (pPolyPoints)
            {
                Delete [] pPolyPoints;
                pPolyPoints = (LPPOLYBEZPOINT)NULL;
            }

            m_iPointCount = 0;
        }
        else
        {
            m_fltRotation = 0.0f;
            parser.GetFloatParam(iParamIndex, &m_fltRotation);
        }
    }

    // Go ahead and create the arrays for PolyDraw...
    if (fResult)
    {
	    // Cast the array of longs to an array of POLYBEZPOINTS
	    m_lpPolyPoints = (LPPOLYBEZPOINT)pPolyPoints;
	    m_iPointCount = iPointCount;

	    // Copy all the points across
        m_lpPointArray = New POINT [m_iPointCount];
        m_lpByteArray  = New BYTE [m_iPointCount];

        if (m_lpPointArray && m_lpByteArray)
        {
            int iMinX = 32000;
            int iMaxX = -32000;
            int iMinY = 32000;
            int iMaxY = -32000;

            for(iPointIndex = 0;iPointIndex < m_iPointCount; iPointIndex++)
            {
                m_lpPointArray[iPointIndex].x = m_lpPolyPoints[iPointIndex].iX;
                m_lpPointArray[iPointIndex].y = m_lpPolyPoints[iPointIndex].iY;
                m_lpByteArray[iPointIndex]    = (BYTE)m_lpPolyPoints[iPointIndex].iFlags;

                if (m_lpPointArray[iPointIndex].x < iMinX)
                    iMinX = m_lpPointArray[iPointIndex].x;
                if (m_lpPointArray[iPointIndex].x > iMaxX)
                    iMaxX = m_lpPointArray[iPointIndex].x;
                if (m_lpPointArray[iPointIndex].y < iMinY)
                    iMinY = m_lpPointArray[iPointIndex].y;
                if (m_lpPointArray[iPointIndex].y > iMaxY)
                    iMaxY = m_lpPointArray[iPointIndex].y;

            }

            m_iCenterX = (iMaxX + iMinX) / 2;
            m_iCenterY = (iMaxY + iMinY) / 2;
        }
        else
        {
            m_iPointCount = 0;

            if (m_lpPolyPoints)
            {
                Delete [] m_lpPolyPoints;
                m_lpPolyPoints = (LPPOLYBEZPOINT)NULL;
            }

            if (m_lpPointArray)
            {
                Delete [] m_lpPointArray;
                m_lpPointArray = (LPPOINT)NULL;
            }

            if (m_lpByteArray)
            {
                Delete [] m_lpByteArray;
                m_lpByteArray = (LPBYTE)NULL;
            }

            fResult = FALSE;
        }
	}

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicPolyBez::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iPointCount))
    {
        int iPointIndex = 0;

        fResult = TRUE;

        for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
        {
            if (!parser.PutByteParam((BYTE)(m_lpPolyPoints[iPointIndex].iFlags)) ||
                !parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].iX) ||
                !parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].iY))
            {
                fResult = FALSE;
                break;
            }
        }

        if (fResult && m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicRect Class Implementation:
\*==========================================================================*/

CGraphicRect::CGraphicRect(BOOL fFilled)
    : CGraphicObject()
{
    m_iWidth = 0;
    m_iHeight = 0;
    m_fFilled = fFilled;
}

/*==========================================================================*/

CGraphicRect::~CGraphicRect()
{
}

/*==========================================================================*/

BOOL CGraphicRect::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

        if (fResult)
        {
            fResult = SUCCEEDED(pIDADrawingSurface->Rect(
                (double)m_iXPosition,
                FlipY(fFlipCoord, (double)m_iYPosition),
                (double)m_iWidth,
                FlipY(fFlipCoord, (double)m_iHeight)));
        }

        if (fResult)
        {
            fResult = RemoveRotation(pIDADrawingSurface, pIDAStatics);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicRect::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetIntegerParam(0, &m_iXPosition) &&
        parser.GetIntegerParam(1, &m_iYPosition) &&
        parser.GetIntegerParam(2, &m_iWidth) &&
        parser.GetIntegerParam(3, &m_iHeight))
    {
        fResult = TRUE;

        m_fltRotation = 0.0f;
        parser.GetFloatParam(4, &m_fltRotation);

        m_iCenterX = m_iXPosition + m_iWidth / 2;
        m_iCenterY = m_iYPosition + m_iHeight / 2;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicRect::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition) &&
        parser.PutIntegerParam(m_iWidth) &&
        parser.PutIntegerParam(m_iHeight))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicRoundRect Class Implementation:
\*==========================================================================*/

CGraphicRoundRect::CGraphicRoundRect(BOOL fFilled)
    : CGraphicObject()
{
    m_iWidth = 0;
    m_iHeight = 0;
    m_iArcWidth = 0;
    m_iArcHeight = 0;
    m_fFilled = fFilled;
}

/*==========================================================================*/

CGraphicRoundRect::~CGraphicRoundRect()
{
}

/*==========================================================================*/

BOOL CGraphicRoundRect::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

        if (fResult)
        {
            fResult = SUCCEEDED(pIDADrawingSurface->RoundRect(
                (double)m_iXPosition,
                FlipY(fFlipCoord, (double)m_iYPosition),
                (double)m_iWidth,
                FlipY(fFlipCoord, (double)m_iHeight),
                (double)m_iArcWidth,
                (double)m_iArcHeight));
        }

        if (fResult)
            RemoveRotation(pIDADrawingSurface, pIDAStatics);
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicRoundRect::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetIntegerParam(0, &m_iXPosition) &&
        parser.GetIntegerParam(1, &m_iYPosition) &&
        parser.GetIntegerParam(2, &m_iWidth) &&
        parser.GetIntegerParam(3, &m_iHeight) &&
        parser.GetIntegerParam(4, &m_iArcWidth) &&
        parser.GetIntegerParam(5, &m_iArcHeight))
    {

#if 0 // Allow The DrawingSurface to handle these cases...
        if (m_iArcWidth > 0)
        {
            if (m_iArcWidth > m_iWidth)
                m_iArcWidth = m_iWidth;
        }
        else
        {
            if (m_iArcWidth < -m_iWidth)
                m_iArcWidth = -m_iWidth;
        }

        if (m_iArcHeight > 0)
        {
            if (m_iArcHeight > m_iHeight)
                m_iArcHeight = m_iHeight;
        }
        else
        {
            if (m_iArcHeight < -m_iHeight)
                m_iArcHeight = -m_iHeight;
        }
#endif // 0

        fResult = TRUE;

        m_fltRotation = 0.0f;
        parser.GetFloatParam(6, &m_fltRotation);

        m_iCenterX = m_iXPosition + m_iWidth / 2;
        m_iCenterY = m_iYPosition + m_iHeight / 2;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicRoundRect::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition) &&
        parser.PutIntegerParam(m_iWidth) &&
        parser.PutIntegerParam(m_iHeight) &&
        parser.PutIntegerParam(m_iArcWidth) &&
        parser.PutIntegerParam(m_iArcHeight))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicString Class Implementation:
\*==========================================================================*/

CGraphicString::CGraphicString()
    : CGraphicObject()
{
	m_pszString      = NULL;
    m_iPointCount    = 0;
    m_lpPointArray   = (LPPOINT)NULL;
    m_lpByteArray    = (LPBYTE)NULL;
}

/*==========================================================================*/

CGraphicString::~CGraphicString()
{
    if (m_iPointCount)
    {
        if (m_lpPointArray)
        {
            Delete [] m_lpPointArray;
            m_lpPointArray = (LPPOINT)NULL;
        }

        if (m_lpByteArray)
        {
            Delete [] m_lpByteArray;
            m_lpByteArray = (LPBYTE)NULL;
        }

        m_iPointCount = 0;
    }

	if (m_pszString)
		Delete [] m_pszString;
}

/*==========================================================================*/

BOOL CGraphicString::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        WCHAR *pwchText = New WCHAR [MAX_STRING_LENGTH];

        if (pwchText)
        {
            BSTR bstrText = NULL;
#ifdef UNICODE
            CStringWrapper::Strcpy(pwchText, m_pszString);
            fResult = TRUE;
#else // !UNICODE
            CStringWrapper::Mbstowcs(pwchText, m_pszString, CStringWrapper::Strlen(m_pszString));
#endif // !UNICODE

            fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

            if (fResult)
            {
                bstrText = SysAllocString(pwchText);

                if (bstrText)
                {
                    fResult = SUCCEEDED(pIDADrawingSurface->Text(
                        bstrText,
                        (double)m_iXPosition,
                        FlipY(fFlipCoord, (double)m_iYPosition)));

                    SysFreeString(bstrText);
                }
            }

            if (fResult)
            {
                fResult = RemoveRotation(pIDADrawingSurface, pIDAStatics);
            }

            Delete [] pwchText;
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicString::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    // Because of a possible bug in the Alpha compiler, the temporary array 
    // will have to be dynamically allocated, rather than statically.  Bleh.
    LPTSTR pszTempString = New TCHAR[MAX_STRING_LENGTH*2];

    if (NULL != pszTempString)
    {
        pszTempString[0] = 0;

        if (parser.GetStringParam(0, pszTempString) &&
            parser.GetIntegerParam(1, &m_iXPosition) &&
            parser.GetIntegerParam(2, &m_iYPosition))
        {
            m_pszString = New TCHAR[lstrlen(pszTempString) + 1];

            if (NULL != m_pszString)
            {
                fResult = TRUE;
                CStringWrapper::Strncpy(m_pszString, pszTempString, lstrlen(pszTempString) + 1);
                m_fltRotation = 0.0f;
                parser.GetFloatParam(3, &m_fltRotation);
                m_iCenterX = m_iXPosition;
                m_iCenterY = m_iYPosition;
            }
        }

        Delete pszTempString;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicString::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutStringParam(m_pszString) &&
        parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicFont Class Implementation:
\*==========================================================================*/

CGraphicFont::CGraphicFont()
    : CGraphicObject()
{
    CStringWrapper::Memset(&m_logfont, 0, sizeof(LOGFONT));
}

/*==========================================================================*/

CGraphicFont::~CGraphicFont()
{
}

/*==========================================================================*/

BOOL CGraphicFont::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        WCHAR *pwchFont = New WCHAR [MAX_STRING_LENGTH];

        if (pwchFont)
        {
            BSTR bstrFontFace = NULL;
#ifdef UNICODE
            CStringWrapper::Strcpy(pwchFont, m_logfont.lfFaceName);
            fResult = TRUE;
#else // !UNICODE
            CStringWrapper::Mbstowcs(pwchFont, m_logfont.lfFaceName, CStringWrapper::Strlen(m_logfont.lfFaceName));
#endif // !UNICODE

            bstrFontFace = SysAllocString(pwchFont);

            if (bstrFontFace)
            {
                fResult = SUCCEEDED(pIDADrawingSurface->Font(
                    bstrFontFace,
                    (int)PixelsToPoints(m_logfont.lfHeight, pIDAStatics),
                    m_logfont.lfWeight > 500,
                    m_logfont.lfItalic,
                    m_logfont.lfUnderline,
                    m_logfont.lfStrikeOut));

                SysFreeString(bstrFontFace);
            }

            Delete [] pwchFont;
        }
    }

    return fResult;
}
   
/*==========================================================================*/

BOOL CGraphicFont::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    TCHAR *ptchFont = New TCHAR [MAX_STRING_LENGTH];

    if (ptchFont)
    {
        // Zero out the logfont structure...
        CStringWrapper::Memset(&m_logfont, 0, sizeof(LOGFONT));

        if (parser.GetStringParam(0, ptchFont) &&
            parser.GetLongParam(1, &m_logfont.lfHeight))
        {
            CStringWrapper::Strncpy(m_logfont.lfFaceName, ptchFont, sizeof(m_logfont.lfFaceName));
            fResult = TRUE;
        }

        if (fResult)
        {
            // Read in the optional parameters...
            parser.GetLongParam(2, &m_logfont.lfWeight);
            parser.GetByteParam(3, &m_logfont.lfItalic);
            parser.GetByteParam(4, &m_logfont.lfUnderline);
            parser.GetByteParam(5, &m_logfont.lfStrikeOut);
        }

        Delete [] ptchFont;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFont::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutStringParam(m_logfont.lfFaceName) &&
        parser.PutLongParam(m_logfont.lfHeight) &&
        parser.PutLongParam(m_logfont.lfWeight) &&
        parser.PutByteParam(m_logfont.lfItalic) &&
        parser.PutByteParam(m_logfont.lfUnderline) &&
        parser.PutByteParam(m_logfont.lfStrikeOut))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicTextureFill Class Implementation:
\*==========================================================================*/

CGraphicTextureFill::CGraphicTextureFill()
    : CGraphicObject()
{
    m_pszTexture = (LPTSTR)NULL;
    m_fltStartX = 0.0;
    m_fltStartY = 0.0;
    m_iStyle = 0;
}

/*==========================================================================*/

CGraphicTextureFill::~CGraphicTextureFill()
{
    if (m_pszTexture)
    {
        Delete [] m_pszTexture;
        m_pszTexture = (LPTSTR)NULL;
    }
}

/*==========================================================================*/

BOOL CGraphicTextureFill::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        WCHAR *pwchTextureFill = New WCHAR [MAX_STRING_LENGTH];

        if (pwchTextureFill)
        {
            BSTR bstrTextureFill = NULL;
#ifdef UNICODE
            CStringWrapper::Strcpy(pwchTextureFill, m_pszTexture);
            fResult = TRUE;
#else // !UNICODE
            CStringWrapper::Mbstowcs(pwchTextureFill, m_pszTexture, CStringWrapper::Strlen(m_pszTexture));
#endif // !UNICODE

            bstrTextureFill = SysAllocString(pwchTextureFill);

            if (bstrTextureFill)
            {
                CComPtr<IDAImage> TexturePtr;
                CComPtr<IDAImage> TranslatedTexturePtr;
                CComPtr<IDAImage> EmptyImagePtr;
                CComPtr<IDATransform2> TransformPtr;
                CComPtr<IDAImportationResult> ImportationResultPtr;

                fResult =
                    SUCCEEDED(pIDAStatics->get_EmptyImage(&EmptyImagePtr)) &&
                    SUCCEEDED(pIDAStatics->ImportImageAsync(bstrTextureFill, EmptyImagePtr, &ImportationResultPtr)) &&
                    SUCCEEDED(ImportationResultPtr->get_Image(&TexturePtr)) &&
                    SUCCEEDED(pIDAStatics->Translate2(m_fltStartX, m_fltStartY, &TransformPtr)) &&
                    SUCCEEDED(TexturePtr->Transform(TransformPtr, &TranslatedTexturePtr));

                if (fResult)
                {
                    if (m_iStyle == 0)
                    {
                        fResult =
                            SUCCEEDED(pIDADrawingSurface->AutoSizeFillScale()) &&
                            SUCCEEDED(pIDADrawingSurface->FillImage(TranslatedTexturePtr));
                    }
                    else
                    {
                        fResult =
                            SUCCEEDED(pIDADrawingSurface->FixedFillScale()) &&
                            SUCCEEDED(pIDADrawingSurface->FillTexture(TranslatedTexturePtr));
                    }
                }

                SysFreeString(bstrTextureFill);
            }

            Delete [] pwchTextureFill;
        }
    }

    return fResult;
}
   
/*==========================================================================*/

BOOL CGraphicTextureFill::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    TCHAR *ptchTextureFill = New TCHAR [MAX_STRING_LENGTH];

    if (ptchTextureFill)
    {
        if (parser.GetFloatParam(0, &m_fltStartX) &&
            parser.GetFloatParam(1, &m_fltStartY) &&
            parser.GetStringParam(2, ptchTextureFill) &&
            parser.GetIntegerParam(3, &m_iStyle))
        {
            m_pszTexture = New TCHAR[CStringWrapper::Strlen(ptchTextureFill)];

            if (m_pszTexture)
            {
                CStringWrapper::Strncpy(m_pszTexture, ptchTextureFill, CStringWrapper::Strlen(ptchTextureFill));
                fResult = TRUE;
            }
        }

        Delete [] ptchTextureFill;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicTextureFill::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutFloatParam(m_fltStartX) &&
        parser.PutFloatParam(m_fltStartY) &&
        parser.PutStringParam(m_pszTexture) &&
        parser.PutIntegerParam(m_iStyle))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicFillColor Class Implementation:
\*==========================================================================*/

CGraphicFillColor::CGraphicFillColor()
    : CGraphicObject()
{
    m_clrrefFillFG = RGB(0, 0, 0);
    m_clrrefFillBG = RGB(255, 255, 255);
}

/*==========================================================================*/

CGraphicFillColor::~CGraphicFillColor()
{
}

/*==========================================================================*/

BOOL CGraphicFillColor::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && pIDAStatics)
    {
        CComPtr<IDAColor> FGColorPtr;
        CComPtr<IDAColor> BGColorPtr;

        if (CreateDAColor(m_clrrefFillFG, pIDAStatics, &FGColorPtr) &&
            CreateDAColor(m_clrrefFillBG, pIDAStatics, &BGColorPtr))
        {
            fResult =
                SUCCEEDED(pIDADrawingSurface->FillColor(FGColorPtr)) &&
                SUCCEEDED(pIDADrawingSurface->SecondaryFillColor(BGColorPtr));
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFillColor::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iValueR = 0;
    int iValueG = 0;
    int iValueB = 0;

    if (parser.GetIntegerParam(0, &iValueR) &&
        parser.GetIntegerParam(1, &iValueG) &&
        parser.GetIntegerParam(2, &iValueB))
    {
        if (SetColor(iValueR, iValueG, iValueB, &m_clrrefFillFG))
        {
            m_clrrefFillBG = m_clrrefFillFG;
            fResult = TRUE;
        }
    }

    if (fResult)
    {
        // Handle the optional BG color...
        if (parser.GetIntegerParam(3, &iValueR) &&
            parser.GetIntegerParam(4, &iValueG) &&
            parser.GetIntegerParam(5, &iValueB))
        {
			SetColor(iValueR, iValueG, iValueB, &m_clrrefFillBG);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFillColor::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(GetRValue(m_clrrefFillFG)) &&
        parser.PutIntegerParam(GetGValue(m_clrrefFillFG)) &&
        parser.PutIntegerParam(GetBValue(m_clrrefFillFG)) &&
        parser.PutIntegerParam(GetRValue(m_clrrefFillBG)) &&
        parser.PutIntegerParam(GetGValue(m_clrrefFillBG)) &&
        parser.PutIntegerParam(GetBValue(m_clrrefFillBG)))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicFillStyle Class Implementation:
\*==========================================================================*/

CGraphicFillStyle::CGraphicFillStyle()
    : CGraphicObject()
{
    m_lFillStyle = 0;
}

/*==========================================================================*/

CGraphicFillStyle::~CGraphicFillStyle()
{
}

/*==========================================================================*/

BOOL CGraphicFillStyle::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = SUCCEEDED(pIDADrawingSurface->FillStyle(m_lFillStyle));
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFillStyle::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iStyle = 0;

    if (parser.GetIntegerParam(0, &iStyle))
    {
        fResult = TRUE;

        m_lFillStyle = iStyle;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFillStyle::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    fResult = parser.PutLongParam(m_lFillStyle);

    return fResult;
}

/*==========================================================================*\
    CGraphicFillStyle Class Implementation:
\*==========================================================================*/

CGraphicGradientFill::CGraphicGradientFill()
    : CGraphicObject()
{
    m_lxStart = 0;
    m_lyStart = 0;
    m_lxEnd = 0;
    m_lyEnd = 0;
    m_fltRolloff = 1.0f;
}

/*==========================================================================*/

CGraphicGradientFill::~CGraphicGradientFill()
{
}

/*==========================================================================*/

BOOL CGraphicGradientFill::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult =
            SUCCEEDED(pIDADrawingSurface->GradientExtent((double)m_lxStart, FlipY(fFlipCoord, (double)m_lyStart), (double)m_lxEnd, FlipY(fFlipCoord, (double)m_lyEnd))) &&
            SUCCEEDED(pIDADrawingSurface->GradientRolloffPower((double)m_fltRolloff));
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicGradientFill::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetLongParam(0, &m_lxStart) &&
        parser.GetLongParam(1, &m_lyStart) &&
        parser.GetLongParam(2, &m_lxEnd) &&
        parser.GetLongParam(3, &m_lyEnd))
    {
        fResult = TRUE;
    }

    if (fResult)
    {
        float fTemp = 0.0f;

        m_fltRolloff = 1.0f;

        if (parser.GetFloatParam(4, &fTemp))
        {
            if (fTemp > 0.0f)
            {
                m_fltRolloff = fTemp;
            }
            else
            {
                // Invalid negative parameter!
                fResult = FALSE;
            }
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicGradientFill::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutLongParam(m_lxStart) &&
        parser.PutLongParam(m_lyStart) &&
        parser.PutLongParam(m_lxEnd) &&
        parser.PutLongParam(m_lyEnd) &&
        parser.PutFloatParam(m_fltRolloff))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicGradientShape Class Implementation:
\*==========================================================================*/

CGraphicGradientShape::CGraphicGradientShape()
    : CGraphicObject()
{
    m_lpPolyPoints  = (LPPOINT)NULL;
    m_iPointCount = 0;
}

/*==========================================================================*/

CGraphicGradientShape::~CGraphicGradientShape()
{
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = (LPPOINT)NULL;
        m_iPointCount = 0;
    }
}

/*==========================================================================*/

BOOL CGraphicGradientShape::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && m_iPointCount >= 2)
    {
        VARIANT varPoints;
#ifdef _DEBUG
        HRESULT hr;
#endif
        double *pArray = NULL;
        SAFEARRAY *psa = NULL;

        psa = SafeArrayCreateVector(VT_R8, 0, m_iPointCount << 1);

        if (NULL == psa)
            return E_OUTOFMEMORY;

        // Try and get a pointer to the data
        if (SUCCEEDED(SafeArrayAccessData(psa, (LPVOID *)&pArray)))
        {
            for(int iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
            {
                pArray[(iPointIndex<<1)]   = (double)m_lpPolyPoints[iPointIndex].x;
                pArray[(iPointIndex<<1)+1] = FlipY(fFlipCoord, (double)m_lpPolyPoints[iPointIndex].y);
            }
#ifdef _DEBUG
            hr = 
#endif
                SafeArrayUnaccessData(psa);
            ASSERT(SUCCEEDED(hr));

            // Our variant is going to be an array of VT_R8s
            VariantInit(&varPoints);
            varPoints.vt = VT_ARRAY | VT_R8;
            varPoints.parray = psa;

            fResult = SUCCEEDED(pIDADrawingSurface->GradientShape(varPoints));
        }

        if (NULL != psa)
        {
            SafeArrayDestroy(psa);
        }

    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicGradientShape::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    // Clear the point array...
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = NULL;
        m_iPointCount = 0;
    }

    if (parser.GetIntegerParam(0, &m_iPointCount) && m_iPointCount >= 2)
    {
        int iPointIndex = 0;
        int iParamIndex = 1;

        m_lpPolyPoints = New POINT [m_iPointCount];

        if (m_lpPolyPoints)
        {
            fResult = TRUE;

            for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
            {
                int iValue1 = 0;
                int iValue2 = 0;

                if (parser.GetIntegerParam(iParamIndex,   &iValue1) &&
                    parser.GetIntegerParam(iParamIndex+1, &iValue2))
                {
                    m_lpPolyPoints[iPointIndex].x = iValue1;
                    m_lpPolyPoints[iPointIndex].y = iValue2;
                }
                else
                {
                    fResult = FALSE;
                    break;
                }

                iParamIndex += 2;
            }
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicGradientShape::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iPointCount))
    {
        int iPointIndex = 0;

        fResult = TRUE;

        for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
        {
            if (!parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].x) ||
                !parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].y))
            {
                fResult = FALSE;
                break;
            }
        }
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicLineColor Class Implementation:
\*==========================================================================*/

CGraphicLineColor::CGraphicLineColor()
    : CGraphicObject()
{
    m_clrrefLine = RGB(0, 0, 0);
}

/*==========================================================================*/

CGraphicLineColor::~CGraphicLineColor()
{
}

/*==========================================================================*/

BOOL CGraphicLineColor::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        CComPtr<IDAColor> LineColorPtr;

        if (CreateDAColor(m_clrrefLine, pIDAStatics, &LineColorPtr))
        {
            fResult = 
                SUCCEEDED(pIDADrawingSurface->LineColor(LineColorPtr)) &&
                SUCCEEDED(pIDADrawingSurface->BorderColor(LineColorPtr));
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicLineColor::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iValueR = 0;
    int iValueG = 0;
    int iValueB = 0;

    if (parser.GetIntegerParam(0, &iValueR) &&
        parser.GetIntegerParam(1, &iValueG) &&
        parser.GetIntegerParam(2, &iValueB))
    {
        fResult = SetColor(iValueR, iValueG, iValueB, &m_clrrefLine);
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicLineColor::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(GetRValue(m_clrrefLine)) &&
        parser.PutIntegerParam(GetGValue(m_clrrefLine)) &&
        parser.PutIntegerParam(GetBValue(m_clrrefLine)))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicLineStyle Class Implementation:
\*==========================================================================*/

CGraphicLineStyle::CGraphicLineStyle()
    : CGraphicObject()
{
    m_lLineStyle = 0;
    m_lLineWidth = 0;
}

/*==========================================================================*/

CGraphicLineStyle::~CGraphicLineStyle()
{
}

/*==========================================================================*/

BOOL CGraphicLineStyle::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && pIDAStatics)
    {
        DA_DASH_STYLE daDashStyle = DAEmpty;

        switch(m_lLineStyle)
        {
            case 0 : daDashStyle = DAEmpty; break;
            case 1 : daDashStyle = DASolid; break;
            case 2 : daDashStyle = DADash; break;
            case 6 : daDashStyle = DASolid; break;

            default : daDashStyle = DASolid; break;
        }

        fResult =
            SUCCEEDED(pIDADrawingSurface->LineDashStyle(daDashStyle)) &&
            SUCCEEDED(pIDADrawingSurface->LineWidth(PixelsToPoints(m_lLineWidth, pIDAStatics))) &&
            SUCCEEDED(pIDADrawingSurface->LineJoinStyle(DAJoinRound)) &&
            SUCCEEDED(pIDADrawingSurface->LineEndStyle(DAEndRound)) &&
            SUCCEEDED(pIDADrawingSurface->BorderDashStyle(daDashStyle)) &&
            SUCCEEDED(pIDADrawingSurface->BorderJoinStyle(DAJoinRound)) &&
            SUCCEEDED(pIDADrawingSurface->BorderEndStyle(DAEndRound)) &&
            SUCCEEDED(pIDADrawingSurface->BorderWidth(PixelsToPoints(m_lLineWidth, pIDAStatics)));
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicLineStyle::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iStyle = 0;
    int iWidth = 0;

    if (parser.GetIntegerParam(0, &iStyle))
    {
        fResult = TRUE;

        // We don't care if this wasn't really set...
        if (!parser.GetIntegerParam(1, &iWidth))
            iWidth = 0;

        if (iWidth < 0)
            iWidth = 0;

        m_lLineStyle = iStyle;
        m_lLineWidth = iWidth;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicLineStyle::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    fResult =
        parser.PutLongParam(m_lLineStyle) &&
        parser.PutLongParam(m_lLineWidth);

    return fResult;
}

/*==========================================================================*\
    CGraphicHatchFill Class Implementation:
\*==========================================================================*/

CGraphicHatchFill::CGraphicHatchFill()
    : CGraphicObject()
{
    m_fHatchFill = 1;
}

/*==========================================================================*/

CGraphicHatchFill::~CGraphicHatchFill()
{
}

/*==========================================================================*/

BOOL CGraphicHatchFill::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        VARIANT_BOOL vBool = BOOL_TO_VBOOL(!m_fHatchFill);

        fResult = SUCCEEDED(pIDADrawingSurface->put_HatchFillTransparent(vBool));
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicHatchFill::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iStyle = 0;

    if (parser.GetIntegerParam(0, &iStyle))
    {
        fResult = TRUE;

        m_fHatchFill = (iStyle != 0) ? TRUE : FALSE;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicHatchFill::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iStyle = m_fHatchFill ? 1 : 0;

    fResult = parser.PutLongParam(iStyle);

    return fResult;
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\sginit.h ===
/*++

Module: 
	sginit.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Header for control-specific initialisation

History:
	05-28-1997	Created (SimonB)

++*/
#include "..\mmctl\inc\ochelp.h" // for ControlInfo

#ifndef __SGINIT_H__
#define __SGINIT_H__

void InitSGrfxControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);

#endif // __SGINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"
#include "sgrfx.h"
#include "sginit.h"


//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
HINSTANCE       g_hinst;        // DLL instance handle
ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfo;      // information about the control

//#define USELOGGING

#ifdef _DEBUG
BOOL			g_fLogDebugOutput=FALSE; // Controls logging of debug info
#endif

extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE("Sgrfx DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;
#ifdef _DEBUG
#ifdef USELOGGING
		g_fLogDebugOutput = TRUE;
#else
		g_fLogDebugOutput = FALSE;
#endif // USELOGGING
#endif // _DEBUG

        InitSGrfxControlInfo(hInst, &g_ctlinfo, AllocSGControl);
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE("Sgrfx DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    return RegisterControls(&g_ctlinfo, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
	return RegisterControls(&g_ctlinfo, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\grobj.h ===
/*==========================================================================*\

Module:
    grobj.h

Author:
    IHammer Team (MByrd)

Created:
    November 1996

Description:
    CGraphicObject derived Class Definitions

History:
    11-07-1996  Created

\*==========================================================================*/

#ifndef __GROBJ_H__
#define __GROBJ_H__

#include "ihammer.h"
#include <daxpress.h> // Needed for IDADrawingSurface definition

/*==========================================================================*/

#define GR_UNKNOWN     (WORD)0x0000
#define GR_ARC         (WORD)0x0001
#define GR_OVAL        (WORD)0x0002
#define GR_POLYGON     (WORD)0x0003
#define GR_POLYBEZ     (WORD)0x0004
#define GR_RECT        (WORD)0x0005
#define GR_ROUNDRECT   (WORD)0x0006
#define GR_STRING      (WORD)0x0007
#define GR_FILLCOLOR   (WORD)0x0008
#define GR_FILLSTYLE   (WORD)0x0009
#define GR_LINECOLOR   (WORD)0x000A
#define GR_LINESTYLE   (WORD)0x000B
#define GR_FONT        (WORD)0x000C
#define GR_GRADFILL    (WORD)0x000D
#define GR_HATCHFILL   (WORD)0x000E
#define GR_GRADSHAPE   (WORD)0x000F
#define GR_TEXTUREFILL (WORD)0x0010

// This should be consistent with MAX_PARAM_LENGTH defined in parser.h
#define MAX_STRING_LENGTH 65536L

/*==========================================================================*/

#define FS_SOLID            0
#define FS_NULL             1
#define FS_PATTERN_DIB      2
#define FS_HATCH_HORZ       3
#define FS_HATCH_VERT       4
#define FS_HATCH_FDIAG      5
#define FS_HATCH_BDIAG      6
#define FS_HATCH_CROSS      7
#define FS_HATCH_DIAGCROSS  8
#define FS_GRADIENT_HORZ    9
#define FS_GRADIENT_VERT    10
#define FS_GRADIENT_RADIAL  11
#define FS_GRADIENT_LINE    12
#define FS_GRADIENT_RECT    13
#define FS_GRADIENT_SHAPE   14

/*==========================================================================*/

class CParser;

/*==========================================================================*/

class CGraphicObject
{
protected:
    int m_iXPosition;
    int m_iYPosition;
    int m_iCenterX;
    int m_iCenterY;
    float m_fltRotation;

public:
    CGraphicObject();
    virtual ~CGraphicObject();

    virtual BOOL WriteData(int iSizeData, LPVOID lpvData);
    virtual BOOL ReadData(int iSizeData, LPVOID lpvData);

    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)=0;
    virtual BOOL LoadObject(CParser &parser)=0;
    virtual BOOL SaveObject(CParser &parser)=0;
    virtual WORD GetObjectType(void)=0;
    virtual int  GetDataSize(void)=0;
    virtual BOOL IsFilled(void) { return FALSE; }
    virtual BOOL AnimatesOverTime(void) { return FALSE; }

protected:
    BOOL ApplyRotation(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord);
    BOOL RemoveRotation(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics);
};

/*==========================================================================*/

class CGraphicArc : public CGraphicObject
{
private:
    int m_iWidth;
    int m_iHeight;
    float m_fStartAngle;
    float m_fArcAngle;
    BOOL m_fFilled;

public:
    CGraphicArc(BOOL fFilled);
    virtual ~CGraphicArc();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
	virtual BOOL ValidateObject();
	virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_ARC; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicArc); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicOval : public CGraphicObject
{
private:
    int m_iWidth;
    int m_iHeight;
    BOOL m_fFilled;

public:
    CGraphicOval(BOOL fFilled);
    virtual ~CGraphicOval();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_OVAL; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicOval); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicPolygon : public CGraphicObject
{
private:
    BOOL    m_fFilled;
    LPPOINT m_lpPolyPoints;
    int     m_iPointCount;

public:
    CGraphicPolygon(BOOL fFilled);
    virtual ~CGraphicPolygon();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_POLYGON; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicPolygon) + (m_iPointCount * sizeof(POINT)); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicPolyBez : public CGraphicObject
{
typedef struct POLYBEZPOINT_tag
{
    long iFlags;
    long iX;
    long iY;
} POLYBEZPOINT, FAR *LPPOLYBEZPOINT;

private:
    BOOL    m_fFilled;
    LPPOLYBEZPOINT m_lpPolyPoints;
    LPPOINT m_lpPointArray;
    LPBYTE  m_lpByteArray;
    int     m_iPointCount;

    BYTE ConvertFlags(BYTE bFlagsIn)
    {
        BYTE bResult = PT_MOVETO;

        switch(bFlagsIn)
        {
            case 0 : bResult = PT_MOVETO; break;
            case 1 : bResult = PT_LINETO; break;
            case 2 : bResult = PT_BEZIERTO; break;
            case 3 : bResult = PT_LINETO   | PT_CLOSEFIGURE; break;
            case 4 : bResult = PT_BEZIERTO | PT_CLOSEFIGURE; break;

            default : bResult = PT_MOVETO; break;
        }

        return bResult;
    }

public:
    CGraphicPolyBez(BOOL fFilled);
    virtual ~CGraphicPolyBez();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_POLYBEZ; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicPolyBez) + (m_iPointCount * sizeof(POLYBEZPOINT)); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicRect : public CGraphicObject
{
private:
    int m_iWidth;
    int m_iHeight;
    BOOL m_fFilled;

public:
    CGraphicRect(BOOL fFilled);
    virtual ~CGraphicRect();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_RECT; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicRect); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicRoundRect : public CGraphicObject
{
private:
    int m_iWidth;
    int m_iHeight;
    int m_iArcWidth;
    int m_iArcHeight;
    BOOL m_fFilled;

public:
    CGraphicRoundRect(BOOL fFilled);
    virtual ~CGraphicRoundRect();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
	virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_ROUNDRECT; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicRoundRect); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicString : public CGraphicObject
{
private:
	LPTSTR  m_pszString;
    int     m_iPointCount;
    LPPOINT m_lpPointArray;
    LPBYTE  m_lpByteArray;

public:
    CGraphicString();
    virtual ~CGraphicString();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_STRING; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicString); }
};

/*==========================================================================*/

class CGraphicFont : public CGraphicObject
{
private:
    LOGFONT m_logfont;

public:
    CGraphicFont();
    virtual ~CGraphicFont();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_FONT; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicFont); }
};

/*==========================================================================*/

class CGraphicTextureFill : public CGraphicObject
{
private:
    LPTSTR m_pszTexture;
    float  m_fltStartX;
    float  m_fltStartY;
    BOOL   m_iStyle;

public:
    CGraphicTextureFill();
    virtual ~CGraphicTextureFill();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_TEXTUREFILL; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicTextureFill); }
    virtual BOOL AnimatesOverTime(void) { return TRUE; }
};

/*==========================================================================*/

class CGraphicFillColor : public CGraphicObject
{
private:
    COLORREF m_clrrefFillFG;
    COLORREF m_clrrefFillBG;

public:
    CGraphicFillColor();
    virtual ~CGraphicFillColor();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
	virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_FILLCOLOR; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicFillColor); }
};

/*==========================================================================*/

class CGraphicFillStyle : public CGraphicObject
{
private:
    LONG m_lFillStyle;

public:
    CGraphicFillStyle();
    virtual ~CGraphicFillStyle();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_FILLSTYLE; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicFillStyle); }
};

/*==========================================================================*/

class CGraphicGradientFill : public CGraphicObject
{
private:
    LONG m_lxStart;
	LONG m_lyStart;
	LONG m_lxEnd;
	LONG m_lyEnd;
    float m_fltRolloff;

public:
    CGraphicGradientFill();
    virtual ~CGraphicGradientFill();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_GRADFILL; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicGradientFill); }
};

/*==========================================================================*/

class CGraphicGradientShape : public CGraphicObject
{
private:
    LPPOINT m_lpPolyPoints;
    int     m_iPointCount;

public:
    CGraphicGradientShape();
    virtual ~CGraphicGradientShape();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_GRADSHAPE; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicGradientShape) + (m_iPointCount * sizeof(POINT)); }
    virtual BOOL IsFilled(void) { return FALSE; }
};

/*==========================================================================*/

class CGraphicLineColor : public CGraphicObject
{
private:
    COLORREF m_clrrefLine;

public:
    CGraphicLineColor();
    virtual ~CGraphicLineColor();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_LINECOLOR; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicLineColor); }
};

/*==========================================================================*/

class CGraphicLineStyle : public CGraphicObject
{
private:
    LONG m_lLineStyle;
    LONG m_lLineWidth;

public:
    CGraphicLineStyle();
    virtual ~CGraphicLineStyle();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_LINESTYLE; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicLineStyle); }
};

/*==========================================================================*/

class CGraphicHatchFill : public CGraphicObject
{
private:
    BOOL m_fHatchFill;

public:
    CGraphicHatchFill();
    virtual ~CGraphicHatchFill();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_HATCHFILL; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicHatchFill); }
};

/*==========================================================================*/

#endif // __GROBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sprite\purevirt.cpp ===
// purevirt.c
//
// Avoids use of C runtime.
//

#include "..\ihbase\precomp.h"

extern "C" int __cdecl _purecall(void)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sprite\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sprite\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"
#include "sprite.h"
#include "sprinit.h"


//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
HINSTANCE       g_hinst;        // DLL instance handle
ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfo;      // information about the control

// #define USELOGGING

#ifdef _DEBUG
BOOL			g_fLogDebugOutput; // Controls logging of debug info
#endif

extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE("SpriteCtl DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;
#ifdef _DEBUG
#ifdef USELOGGING
		g_fLogDebugOutput = TRUE;
#else
		g_fLogDebugOutput = FALSE;
#endif // USELOGGING
#endif // USELOGGING

        InitSpriteControlInfo(hInst, &g_ctlinfo, AllocSpriteControl);
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE("SpriteCtl DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    return RegisterControls(&g_ctlinfo, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
	return RegisterControls(&g_ctlinfo, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sprite\sprinit.cpp ===
/*++

Module: 
	sprinit.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Performs control-specific initialisation

History:
	05-26-1997	Created (SimonB)

++*/

#include "..\ihbase\ihbase.h"
#include "..\mmctl\inc\ochelp.h" // for ControlInfo
#include "sprinit.h"
#include "..\resource.h"
#include <daxpress.h>

extern ULONG g_cLock;


void InitSpriteControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.SpriteControl");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Sprite");
    pCtlInfo->pclsid = &CLSID_SpriteControl;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = TEXT("1.0");
    pCtlInfo->iToolboxBitmapID = IDB_ICON_SPRITE;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_CONTROL | CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING | CI_MMCONTROL;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; // TODO: Change as appropriate
}

// end of file: sprinit.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sprite\sprevent.h ===
/*++

Module: 
    sprevent.h

Author: 
    IHammer Team (SimonB)

Created: 
    May 1997

Description:
    Macros to make firing events easier and safer.  Each macro can be customised for 
    the particular event.  However, the general form should be:

    #define FIRE_EVENTNAME(pConnectionPoint, param1, param2) \
        pConnectionPoint->FireEvent(DISPID_EVENT_EVENTNAME, \
            <VT for param1>, param1, \
            <VT for param2>, param2, \
            0) 

    NOTE: The terminating 0 is extremly important !!!

History:
    05-27-1997  Created (SimonB)

++*/

#include <dispids.h>

#ifndef __SPREVENT_H__
#define __SPREVENT_H__

// Shift/Ctrl/Alt, and mouse button states for events
#define KEYSTATE_SHIFT  1
#define KEYSTATE_CTRL   2
#define KEYSTATE_ALT    4

#define MOUSEBUTTON_LEFT     1
#define MOUSEBUTTON_RIGHT    2
#define MOUSEBUTTON_MIDDLE   4

#define FIRE_ONPLAYMARKER(pConnectionPoint, MARKER) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONPLAYMARKER, \
            VT_BSTR, MARKER, \
            0)

#define FIRE_ONMARKER(pConnectionPoint, MARKER) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONMARKER, \
            VT_BSTR, MARKER, \
            0)

#define FIRE_ONSTOP(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired && !m_fOnStopFiring) \
    { \
        m_fOnStopFiring = true; \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONSTOP, 0); \
        m_fOnStopFiring = false; \
    }

#define FIRE_ONPLAY(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired && !m_fOnPlayFiring) \
    { \
        m_fOnPlayFiring = true; \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONPLAY, 0); \
        m_fOnPlayFiring = false; \
    } 

#define FIRE_ONPAUSE(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired && !m_fOnPauseFiring) \
    { \
        m_fOnPauseFiring = true; \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONPAUSE, 0);\
        m_fOnPauseFiring = false;\
    } 

#define FIRE_CLICK(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_CLICK, 0)

#define FIRE_DBLCLICK(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_DBLCLICK, 0)

#define FIRE_MOUSEDOWN(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSEDOWN, \
            VT_I4, BUTTON, \
            VT_I4, SHIFT, \
            VT_I4, X, \
            VT_I4, Y, \
            0)

#define FIRE_MOUSEENTER(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSEENTER, 0)

#define FIRE_MOUSELEAVE(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSELEAVE, 0)

#define FIRE_MOUSEMOVE(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSEMOVE, \
            VT_I4, BUTTON, \
            VT_I4, SHIFT, \
            VT_I4, X, \
            VT_I4, Y, \
            0)

#define FIRE_MOUSEUP(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSEUP, \
            VT_I4, BUTTON, \
            VT_I4, SHIFT, \
            VT_I4, X, \
            VT_I4, Y, \
            0)

#define FIRE_ONMEDIALOADED(pConnectionPoint, URL) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONMEDIALOADED, \
            VT_BSTR, URL, \
            0)

#define FIRE_ONSEEK(pConnectionPoint, TIME) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONSEEK, \
            VT_R8, TIME, \
            0)

#define FIRE_ONFRAMESEEK(pConnectionPoint, FRAME) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONFRAMESEEK, \
            VT_I4, FRAME, \
            0)


#endif // __SPREVENT_H__

// End of file sprevent.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sprite\sprite.h ===
/*==========================================================================*\

    Module: 
            sprite.h

    Author: 
            IHammer Team (SimonB)

    Created: 
            May 1997

    Description:
            Defines the control's class

    History:
            05-27-1997  Created (SimonB)

\*==========================================================================*/

#ifndef __SPRITE_H__
#define __SPRITE_H__

#define USE_VIEWSTATUS_SURFACE
#include "..\ihbase\precomp.h"
#include "..\ihbase\ihbase.h"
#include "..\ihbase\timemark.h"
#include <drg.h>
#include <ctstr.h>
#include <daxpress.h>
#include "..\ihbase\clocker.h"
#include "ddraw.h"
#include "ddrawex.h"

// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>
#include <servprov.h>

/*==========================================================================*/

class CFrameMarker
{

public:
    unsigned long m_iFrame;
    BSTR m_bstrMarkerName;
    bool m_fAbsolute;

public:
    CFrameMarker() { m_iFrame = 0; }

    CFrameMarker(unsigned long iFrame, LPWSTR pwszName, bool fAbsolute = true)
    {
        m_iFrame = iFrame;
        m_fAbsolute = fAbsolute;
        m_bstrMarkerName = SysAllocString(pwszName);
    }


    ~CFrameMarker()
    {
        SysFreeString(m_bstrMarkerName);
    }

};

/*==========================================================================*/

class CFrameMap
{
public:
    int m_iImg;
    double m_dblDuration;
    CTStr m_tstrMarkerName;

public:
    CFrameMap() {m_iImg = 0;  m_dblDuration = 0.0f;}

    CFrameMap(unsigned int iImg, double dblDuration, LPTSTR pszMarkerName = NULL):
        m_tstrMarkerName(pszMarkerName)
    {
        m_iImg = iImg;  
        m_dblDuration = dblDuration;
    }

    ~CFrameMap() {}
};

/*==========================================================================*/

/*
CIHBaseCtl <    
        CSpriteCtl,                             //TODO: Name of the derived class
        IIHCtl,                         //TODO: Name of interface defining methods and properties
        &CLSID_IHCtl,           //TODO: CLSID of the control  Get this from ihctl.h
        &IID_IIHCtl,            //TODO: IID of the interface above.  Get this from ihctl.h
        &LIBID_IHCtl,           //TODO: LIBID of the typelib.  Get this from ihctl.h
        &DIID_IHCtlEvents > //TODO: IID of the event interface.  Get this from ihctl.h

*/

#define SPR_BASECLASS       \
CIHBaseCtl <                \
    CSpriteCtl,             \
    ISpriteCtl,             \
    &CLSID_SpriteControl,   \
    &IID_ISpriteCtl,        \
    &LIBID_DAExpressLib,    \
    &DIID_ISpriteCtlEvents>

class CSpriteCtl:               
    public ISpriteCtl,
    public SPR_BASECLASS,
    public CClockerSink

{
friend LPUNKNOWN __stdcall AllocSpriteControl(LPUNKNOWN punkOuter);

// Template stuff
    typedef SPR_BASECLASS CMyIHBaseCtl;

public:
    // Make PlayState public so that the CCalloutNotifier can access it
    PlayStateConstant     m_enumPlayState; 
private:

    BOOL                  m_fMouseInArea;
    BSTR                  m_bstrSourceURL; // Store the pointer to the image...
    BOOL                  m_fAutoStart;
    unsigned long         m_iPrerollAmount;
    int                   m_iLoopCount;
    int                   m_iInitialFrame;
    int                   m_iFinalFrame;
    long                  m_iRepeat;
    double                m_dblDuration;
    double                m_dblPlayRate;
    double                m_dblTimerInterval;
    double                m_dblUserPlayRate;
    double                m_dblUserTimerInterval;
    int                   m_iMaximumRate;
    int                   m_iNumFrames;
    int                   m_iNumFramesAcross;
    int                   m_iNumFramesDown;
    int                   m_byteColorKeyR, m_byteColorKeyG, m_byteColorKeyB;
    BOOL                  m_fOnSeekFiring;
    BOOL                  m_fOnFrameSeekFiring;
    BOOL                  m_fFireAbsoluteFrameMarker;
    bool                  m_fOnStopFiring, m_fOnPlayFiring, m_fOnPauseFiring;

    BOOL m_fUseColorKey;
    BOOL m_fMouseEventsEnabled;

    CPtrDrg<CFrameMarker> m_drgFrameMarkers;
    CPtrDrg<CTimeMarker>  m_drgTimeMarkers;
    CTimeMarker*          m_ptmFirst;
    CPtrDrg<CFrameMap>    m_drgFrameMaps;
    CTStr                 m_tstrFrameMap;
    CClocker              m_clocker;
    double                m_dblBaseTime;
    double                m_dblCurrentTick;
    double                m_dblTimePaused;
    double                m_dblPreviousTime;
    BOOL                  m_fPersistComplete;
    BOOL                  m_fOnWindowLoadFired;
    bool                  m_fOnWindowUnloadFired;
    bool                  m_fWaitForImportsComplete;
    HWND                  m_hwndParent;


    // DAnim Support:
    BOOL                      m_fStarted; // True iff the model has been started...
    CComPtr<IServiceProvider> m_ServiceProviderPtr;
    CComPtr<IDirectDraw3>     m_DirectDraw3Ptr;
    CComPtr<IDAStatics>       m_StaticsPtr;
    CComPtr<IDAView>          m_ViewPtr;
    CComPtr<IDAImage>         m_ImagePtr;
    CComPtr<IDAImage>         m_PlayImagePtr; // Switchable image selected into view..

    // Frame information (derived from m_ImagePtr on first play)
    unsigned int m_iFrame;
    CComPtr<IDANumber> m_imageWidth;
    CComPtr<IDANumber> m_imageHeight;
    CComPtr<IDANumber> m_frameWidth;
    CComPtr<IDANumber> m_frameHeight;
    CComPtr<IDANumber> m_initTransX;
    CComPtr<IDANumber> m_initTransY;
    CComPtr<IDAPoint2> m_minCrop;
    CComPtr<IDAPoint2> m_maxCrop;

    // Final sequenced behavior
    long m_iCurCycle;
    long m_iFrameCount;
    long m_iStartingFrame;
    CComPtr<IDABehavior>* m_pArrayBvr;
    double *m_durations;	// array of durations of each image
    CComPtr<IDABehavior> m_FinalBehaviorPtr;
    
    HRESULT InitializeImage(void);                          // Loads, updates and builds the image
    // Sequences the frames starting with iStartingFrame at dblDuration
    HRESULT SequenceFrames(int iStartingFrame, double dblDuration=0.0); 
    // Returns the frame and remaining duration at dblTime
    int GetFrameFromTime(double dblTime, double* pdblDuration=NULL); 
    double GetTimeFromFrame(int iFrame);                    // Returns the time at iFrame
    HRESULT SeekFrame(int iFrame, double dblDuration=0.0);  // Seek to iFrame
    HRESULT ShowImage(int iShowFrame, BOOL bPlayRate=FALSE);       // Shows the image at iShowFrame
    HRESULT FireFrameMarker(int iFrame, BOOL bPlayRate=TRUE);      // Fires a frame callout at iFrame
    HRESULT FireTimeMarker(double dblNewTime, BOOL bReset=FALSE);  // Fires time markers at dblNewTime

    void CalculateEffectiveTimerInterval();

protected:

    // 
    // Constructor and destructor
    // 
    CSpriteCtl(IUnknown *punkOuter, HRESULT *phr); //TODO: Change name

    ~CSpriteCtl(); //TODO: Change name as appropriate

    // Overides
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);

    STDMETHODIMP QueryHitPoint(DWORD dwAspect, LPCRECT prcBounds, POINT ptLoc, LONG lCloseHint, DWORD* pHitResult);

    STDMETHODIMP OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);

    STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
         BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue);

    ///// IDispatch implementation
    protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   
    ///// IOleObject implementation
    protected:
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    ///// delegating IUnknown implementation
    protected:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

    // Private members
    private:

    HRESULT ParseFrameMapEntry(LPTSTR pszEntry, CFrameMap **ppFrameMap);
    HRESULT PersistFrameMaps(IVariantIO *pvio, BOOL fLoading);
    HRESULT PersistFrameMarkers(IVariantIO *pvio, BOOL fIsLoading);
    HRESULT PersistTimeMarkers(IVariantIO* pvio, BOOL fLoading);
    HRESULT AddTimeMarkerElement(CTimeMarker **ppNewMarker);
    HRESULT AddFrameMarkerElement(CFrameMarker **ppNewMarker);
    //
    // ISpriteCtl methods 
    //

    protected:

    HRESULT STDMETHODCALLTYPE get_AutoStart(VARIANT_BOOL __RPC_FAR *fAutoStart); 
    HRESULT STDMETHODCALLTYPE put_AutoStart(VARIANT_BOOL fAutoStart); 
    HRESULT STDMETHODCALLTYPE get_Frame(unsigned int __RPC_FAR *piFrame); 
    HRESULT STDMETHODCALLTYPE put_Frame(unsigned int iFrame); 
    HRESULT STDMETHODCALLTYPE get_FrameMap(BSTR __RPC_FAR *FrameMap); 
    HRESULT STDMETHODCALLTYPE put_FrameMap(BSTR FrameMap); 
    HRESULT STDMETHODCALLTYPE get_InitialFrame(int __RPC_FAR *iFrame); 
    HRESULT STDMETHODCALLTYPE put_InitialFrame(int iFrame); 
    HRESULT STDMETHODCALLTYPE get_FinalFrame(int __RPC_FAR *iFrame);
    HRESULT STDMETHODCALLTYPE put_FinalFrame(int iFrame);
    HRESULT STDMETHODCALLTYPE get_Iterations(int __RPC_FAR *iRepeat); 
    HRESULT STDMETHODCALLTYPE put_Iterations(int iRepeat); 
    HRESULT STDMETHODCALLTYPE get_Library(IDAStatics __RPC_FAR *__RPC_FAR *ppLibrary);
    HRESULT STDMETHODCALLTYPE get_Repeat(int __RPC_FAR *iRepeat); 
    HRESULT STDMETHODCALLTYPE put_Repeat(int iRepeat); 
    HRESULT STDMETHODCALLTYPE get_PlayRate(double __RPC_FAR *dblSpeed); 
    HRESULT STDMETHODCALLTYPE put_PlayRate(double dblSpeed); 
    HRESULT STDMETHODCALLTYPE get_Time(double __RPC_FAR *pdblTime); 
    HRESULT STDMETHODCALLTYPE get_MaximumRate(unsigned int __RPC_FAR *iFps); 
    HRESULT STDMETHODCALLTYPE put_MaximumRate(unsigned int iFps); 
    HRESULT STDMETHODCALLTYPE get_NumFrames(unsigned int __RPC_FAR *iNumFrames); 
    HRESULT STDMETHODCALLTYPE put_NumFrames(unsigned int iNumFrames); 
    HRESULT STDMETHODCALLTYPE get_PlayState(PlayStateConstant __RPC_FAR *PlayState); 
    HRESULT STDMETHODCALLTYPE get_NumFramesAcross(unsigned int __RPC_FAR *iFrames); 
    HRESULT STDMETHODCALLTYPE put_NumFramesAcross(unsigned int iFrames); 
    HRESULT STDMETHODCALLTYPE get_NumFramesDown(unsigned int __RPC_FAR *iFrames); 
    HRESULT STDMETHODCALLTYPE put_NumFramesDown(unsigned int iFrames); 
    HRESULT STDMETHODCALLTYPE get_UseColorKey(VARIANT_BOOL __RPC_FAR *Solid); 
    HRESULT STDMETHODCALLTYPE put_UseColorKey(VARIANT_BOOL Solid); 
    HRESULT STDMETHODCALLTYPE get_Image(IDAImage __RPC_FAR **pImage); 
    HRESULT STDMETHODCALLTYPE put_Image(IDAImage __RPC_FAR *pImage); 
    HRESULT STDMETHODCALLTYPE get_ColorKey(IDAColor __RPC_FAR **ppColorKey); 
    HRESULT STDMETHODCALLTYPE put_ColorKey(IDAColor __RPC_FAR *pColorKey); 
    HRESULT STDMETHODCALLTYPE get_ColorKeyRGB(COLORREF* pColorKeyRGB); 
    HRESULT STDMETHODCALLTYPE put_ColorKeyRGB(COLORREF ColorKeyRGB); 
    HRESULT STDMETHODCALLTYPE get_SourceURL(BSTR __RPC_FAR *bstrSourceURL); 
    HRESULT STDMETHODCALLTYPE put_SourceURL(BSTR bstrSourceURL); 
    HRESULT STDMETHODCALLTYPE get_MouseEventsEnabled(VARIANT_BOOL __RPC_FAR *Enabled); 
    HRESULT STDMETHODCALLTYPE put_MouseEventsEnabled(VARIANT_BOOL Enabled); 
    HRESULT STDMETHODCALLTYPE get_TimerInterval(double *pdblTimerInterval);
    HRESULT STDMETHODCALLTYPE put_TimerInterval(double dblTimerInterval);
    HRESULT STDMETHODCALLTYPE AddFrameMarker(unsigned int iFrame, BSTR MarkerName, VARIANT varAbsolute); 
    HRESULT STDMETHODCALLTYPE AddTimeMarker(double dblTime, BSTR MarkerName, VARIANT varAbsolute); 
    HRESULT STDMETHODCALLTYPE Play(void); 
    HRESULT STDMETHODCALLTYPE Stop(void); 
    HRESULT STDMETHODCALLTYPE Pause(void); 
    HRESULT STDMETHODCALLTYPE Seek(double dblTime); 
    HRESULT STDMETHODCALLTYPE FrameSeek(unsigned int iFrame);

#ifdef SUPPORTONLOAD
    void OnWindowLoad (void);
    void OnWindowUnload (void);
#endif //SUPPORTONLOAD

private:
    HRESULT InitializeSurface(void);
    STDMETHODIMP PaintToDC(HDC hdcDraw, LPRECT lprcBounds, BOOL fBW);
    STDMETHODIMP InvalidateControl(LPCRECT pRect, BOOL fErase);

    HRESULT CreateBaseTransform(void);
    HRESULT UpdateImage(IDAImage *pImage);
    HRESULT LoadImage(BSTR bstrURL, IDAImage **ppImage);
    HRESULT GenerateFrameImage(int iFrameIndex, IDAImage *pImage, IDAImage **ppFrameImage);
    HRESULT BuildPlayImage(void);
    BOOL StopModel(void);
    BOOL StartModel(void);
    BOOL ReStartModel(void);
    HRESULT InitializeObjects(void);
    HRESULT StartPlaying (void);
    HRESULT Resume (void);
    
    BSTR* GetCallout(unsigned long);

    // Timing info:
    DWORD GetCurrTimeInMillis(void);
    double GetCurrTime() { return (double)(GetCurrTimeInMillis()) / 1000.0; }

public:
    virtual void OnTimer(DWORD dwTime);
};


/*==========================================================================*/

#endif // __SPRITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\sgrfx.h ===
/*==========================================================================*\

    Module: 
            sgrfx.h

    Author: 
            IHammer Team (SimonB)

    Created: 
            May 1997

    Description:
            Defines the control's class

    History:
            05-28-1997  Created

\*==========================================================================*/

#ifndef __SGRFX_H__
#define __SGRFX_H__

#define USE_VIEWSTATUS_SURFACE
#include "..\ihbase\precomp.h"
#include "..\ihbase\ihbase.h"
#include <daxpress.h>
#include "clocker.h"
#include "parser.h"
#include "ddraw.h"
#include "ddrawex.h"

// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>
#include <servprov.h>

/*==========================================================================*\
    HighQuality Support:
\*==========================================================================*/

//#define HQ_FACTOR 4
//#define HQ_LINE_FACTOR 5

#define HQ_FACTOR 2
#define HQ_LINE_FACTOR 3

#define WIDTHBYTES(i)           ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

#define DibWidth(lpbi)          (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biWidth)
#define DibHeight(lpbi)         (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biHeight)
#define DibBitCount(lpbi)       (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biBitCount)
#define DibCompression(lpbi)    (DWORD)(((LPBITMAPINFOHEADER)(lpbi))->biCompression)

#define DibWidthBytesN(lpbi, n) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(n))
#define DibWidthBytes(lpbi)     DibWidthBytesN(lpbi, (lpbi)->biBitCount)

#define DibSizeImage(lpbi)      ((lpbi)->biSizeImage == 0 \
                                    ? ((DWORD)(UINT)DibWidthBytes(lpbi) * (DWORD)(UINT)(lpbi)->biHeight) \
                                    : (lpbi)->biSizeImage)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))

#define DibFlipY(lpbi, y)       ((int)(lpbi)->biHeight-1-(y))

//HACK for NT BI_BITFIELDS DIBs
#define DibPtr(lpbi)            ((lpbi)->biCompression == BI_BITFIELDS \
                                    ? (LPVOID)(DibColors(lpbi) + 3) \
                                    : (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed))

#define DibColors(lpbi)         ((RGBQUAD FAR *)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)

#define DibXYN(lpbi,pb,x,y,n)   (LPVOID)(                                     \
                                (BYTE _huge *)(pb) +                          \
                                (UINT)((UINT)(x) * (UINT)(n) / 8u) +          \
                                ((DWORD)DibWidthBytesN(lpbi,n) * (DWORD)(UINT)(y)))

#define DibXY(lpbi,x,y)         DibXYN(lpbi,DibPtr(lpbi),x,y,(lpbi)->biBitCount)

#define FixBitmapInfo(lpbi)     if ((lpbi)->biSizeImage == 0)                 \
                                    (lpbi)->biSizeImage = DibSizeImage(lpbi); \
                                if ((lpbi)->biClrUsed == 0)                   \
                                    (lpbi)->biClrUsed = DibNumColors(lpbi);   \
                                if ((lpbi)->biCompression == BI_BITFIELDS && (lpbi)->biClrUsed == 0) \
                                    ; // (lpbi)->biClrUsed = 3;                    

#define DibInfo(pDIB)     ((BITMAPINFO FAR *)(pDIB))

/*==========================================================================*/

#ifdef DEADCODE
class CPickCallback : public IDAUntilNotifier {
protected:
    CComPtr<IConnectionPointHelper> m_pconpt;
    CComPtr<IDAStatics>             m_pstatics;
    CComPtr<IDAImage>               m_pimage;
    CComPtr<IDAImage>               m_pimagePick;
    CComPtr<IDAEvent>               m_peventEnter;
    CComPtr<IDAEvent>               m_peventLeave;
    boolean m_bInside;
    boolean& m_fOnWindowLoadFired;
    ULONG m_cRef;

public :
    CPickCallback(
        IConnectionPointHelper* pconpt,
        IDAStatics* pstatics,
        IDAImage* pimage,
        boolean& fOnWindowLoadFired,
        HRESULT& hr
    );
    ~CPickCallback();

    boolean Inside() { return m_bInside; }
    HRESULT GetImage(IDABehavior** ppimage);
    HRESULT STDMETHODCALLTYPE Notify(
            IDABehavior __RPC_FAR *eventData,
            IDABehavior __RPC_FAR *curRunningBvr,
            IDAView __RPC_FAR *curView,
            IDABehavior __RPC_FAR *__RPC_FAR *ppBvr);

    ///// IUnknown
public :

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void __RPC_FAR *__RPC_FAR *ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    ///// IDispatch implementation
protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid) { return E_NOTIMPL; }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { return E_NOTIMPL; }
};
#endif // DEADCODE

/*==========================================================================*/

/*
CIHBaseCtl <    
        CSGrfx,                         //TODO: Name of the derived class
        IIHCtl,                         //TODO: Name of interface defining methods and properties
        &CLSID_IHCtl,           //TODO: CLSID of the control  Get this from ihctl.h
        &IID_IIHCtl,            //TODO: IID of the interface above.  Get this from ihctl.h
        &LIBID_IHCtl,           //TODO: LIBID of the typelib.  Get this from ihctl.h
        &DIID_IHCtlEvents > //TODO: IID of the event interface.  Get this from ihctl.h

*/

#define SG_BASECLASS    \
CIHBaseCtl <        \
        CSGrfx,                 \
        ISGrfxCtl,                      \
        &CLSID_StructuredGraphicsControl,        \
        &IID_ISGrfxCtl, \
        &LIBID_DAExpressLib,    \
        &DIID_ISGrfxCtlEvents>

class CSGrfx:           
        public ISGrfxCtl,
        public SG_BASECLASS,
        public CClockerSink
        
{
friend LPUNKNOWN __stdcall AllocSGControl(LPUNKNOWN punkOuter);

// Template stuff
        typedef SG_BASECLASS CMyIHBaseCtl;

private:
    BOOL m_fMouseEventsEnabled;
    LPWSTR m_pwszSourceURL;
    CoordSystemConstant m_CoordSystem;
    int m_iExtentTop;
    int m_iExtentLeft;
    int m_iExtentWidth;
    int m_iExtentHeight;
    BOOL m_fPersistExtents, m_fIgnoreExtentWH, m_fMustSetExtent;
    BOOL m_fSetExtentsInSetIdentity;
    BOOL m_fUpdateDrawingSurface;
    BOOL m_fShowTiming;
    BOOL m_fPreserveAspectRatio;
    bool m_fRectsSetOnce;
    RECT m_rcLastRectScaled;
    boolean m_fOnWindowLoadFired;
    bool m_fNeedOnTimer;
    BOOL m_fInside;
    bool m_fExtentTopSet, m_fExtentLeftSet, m_fExtentWidthSet, m_fExtentHeightSet;

    // High Quality Support:
    BOOL       m_fHighQuality;
    BOOL       m_fHQStarted; // True iff the model has been started...
    HDC        m_hdcHQ;
    HBITMAP    m_hbmpHQOld;
    HBITMAP    m_hbmpHQ;
    BITMAPINFO m_bmInfoHQ;
    RGBQUAD    m_rgrgbqColorMap[256];
    LPBYTE     m_pHQDIBBits;

    CParser m_cparser;
    CClocker                   m_clocker;

    // DAnim Support:
    BOOL                       m_fStarted; // True iff the model has been started...
    CComPtr<IDATransform3>     m_FullTransformPtr;
    CComPtr<IDATransform2>     m_TransformPtr;
    CComPtr<IDAStatics>        m_StaticsPtr;
    CComPtr<IDAView>           m_ViewPtr;
    CComPtr<IDADrawingSurface> m_DrawingSurfacePtr;
    CComPtr<IDAImage>          m_ImagePtr;
    CComPtr<IDirectDraw3>      m_DirectDraw3Ptr;
    CComPtr<IServiceProvider>  m_ServiceProviderPtr;

    CComPtr<IDATransform3>     m_CachedRotateTransformPtr;
    double                     m_dblCachedRotateX;
    double                     m_dblCachedRotateY;
    double                     m_dblCachedRotateZ;

    CComPtr<IDATransform3>     m_CachedTranslateTransformPtr;
    double                     m_dblCachedTranslateX;
    double                     m_dblCachedTranslateY;
    double                     m_dblCachedTranslateZ;

    CComPtr<IDATransform3>     m_CachedScaleTransformPtr;
    double                     m_dblCachedScaleX;
    double                     m_dblCachedScaleY;
    double                     m_dblCachedScaleZ;

    // High-Quality Rendering...
    CComPtr<IDAView>           m_HQViewPtr;

    // Behavior constants
    CComPtr<IDANumber>         m_zero;
    CComPtr<IDANumber>         m_one;
    CComPtr<IDANumber>         m_negOne;
    CComPtr<IDAVector3>        m_xVector3;
    CComPtr<IDAVector3>        m_yVector3;
    CComPtr<IDAVector3>        m_zVector3;
    CComPtr<IDATransform2>     m_identityXform2;
    CComPtr<IDATransform2>     m_yFlipXform2;

#ifdef DEADCODE
    // picking
    CComPtr<CPickCallback>     m_pcallback;
#endif // DEADCODE

    double                     m_dblTime;
    double                     m_dblStartTime;

protected:

        //
        // Constructor and destructor
        // 
        CSGrfx(IUnknown *punkOuter, HRESULT *phr); 

    ~CSGrfx(); 

        // Overides
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);

    STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect);

        STDMETHODIMP QueryHitPoint(DWORD dwAspect, LPCRECT prcBounds, POINT ptLoc, LONG lCloseHint, DWORD* pHitResult);

        STDMETHODIMP OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
        
        STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);
        
        STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                 BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue);

        ///// IDispatch implementation
        protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   
    ///// IOleObject implementation
    protected:
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);
    
        ///// delegating IUnknown implementation
        protected:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

        //
        // ISGrfxCtl methods 
        //
        
protected:

    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SourceURL( 
                /* [retval][out] */ BSTR __RPC_FAR *bstrSourceURL);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SourceURL( 
                /* [in] */ BSTR bstrSourceURL);
        
    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CoordinateSystem( 
                /* [retval][out] */ CoordSystemConstant __RPC_FAR *CoordSystem);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CoordinateSystem( 
                /* [in] */ CoordSystemConstant CoordSystem);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MouseEventsEnabled( 
                /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fEnabled);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MouseEventsEnabled( 
                /* [in] */ VARIANT_BOOL fEnabled);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExtentTop( 
                /* [retval][out] */ int __RPC_FAR *iExtentTop);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ExtentTop( 
                /* [in] */ int iExtentTop);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExtentLeft( 
                /* [retval][out] */ int __RPC_FAR *iExtentLeft);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ExtentLeft( 
                /* [in] */ int iExtentLeft);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExtentWidth( 
                /* [retval][out] */ int __RPC_FAR *iExtentWidth);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ExtentWidth( 
                /* [in] */ int iExtentWidth);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExtentHeight( 
                /* [retval][out] */ int __RPC_FAR *iExtentHeight);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ExtentHeight( 
                /* [in] */ int iExtentHeight);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HighQuality( 
                /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHighQuality);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_HighQuality( 
                /* [in] */ VARIANT_BOOL fHighQuality);
        
    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Library( 
                /* [retval][out] */ IDAStatics __RPC_FAR **ppLibrary);

    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
                /* [retval][out] */ IDAImage __RPC_FAR **ppImage);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Image( 
                /* [in] */ IDAImage __RPC_FAR *pImage);
        
    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Transform( 
                /* [retval][out] */ IDATransform3 __RPC_FAR **ppTransform);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Transform( 
                /* [in] */ IDATransform3 __RPC_FAR *pTransform);

    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DrawingSurface( 
                /* [retval][out] */ IDADrawingSurface __RPC_FAR **ppDrawingSurface);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DrawingSurface( 
                /* [in] */ IDADrawingSurface __RPC_FAR *pDrawingSurface);
        
    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DrawSurface( 
                /* [retval][out] */ IDADrawingSurface __RPC_FAR **ppDrawingSurface);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DrawSurface( 
                /* [in] */ IDADrawingSurface __RPC_FAR *pDrawingSurface);

    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PreserveAspectRatio( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPreserve);
    
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PreserveAspectRatio( 
        /* [in] */ VARIANT_BOOL fPreserve);

    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void);
        
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Rotate( 
                /* [in] */ double dblXRot,
                /* [in] */ double dblYRot,
                /* [in] */ double dblZRot,
                /* [optional][in] */ VARIANT varReserved);

    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Scale( 
                /* [in] */ double dblXScale,
                /* [in] */ double dblYScale,
                /* [in] */ double dblZScale,
                /* [optional][in] */ VARIANT varReserved);

    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE SetIdentity( void);
        
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Transform4x4(/* [in] */ VARIANT matrix);
        
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Translate( 
                /* [in] */ double dblXOrigin,
                /* [in] */ double dblYOrigin,
                /* [in] */ double dblZOrigin,
                /* [optional][in] */ VARIANT varReserved);

#ifdef INCLUDESHEAR
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE ShearX( 
                /* [in] */ double dblShearAmount);
        
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE ShearY( 
                /* [in] */ double dblShearAmount);
#endif // INCLUDESHEAR
        
#ifdef SUPPORTONLOAD
        void OnWindowLoad (void);
        void OnWindowUnload (void);
#endif //SUPPORTONLOAD

private:
    HRESULT InitializeSurface(void);
    STDMETHODIMP PaintToDC(HDC hdcDraw, LPRECT lprcBounds, BOOL fBW);
    STDMETHODIMP InvalidateControl(LPCRECT pRect, BOOL fErase);
    void SetSGExtent();

    HRESULT CreateBaseTransform(void);
    HRESULT RecomposeTransform(BOOL fInvalidate);
    HRESULT UpdateImage(IDAImage *pImage, BOOL fInvalidate);
    BOOL StopModel(void);
    BOOL StartModel(void);
    BOOL ReStartModel(void);

    // HighQuality Support:
    BOOL PaintHQBitmap(HDC hdc);
    BOOL FreeHQBitmap();
    BOOL SmoothHQBitmap(LPRECT lprcBounds);

    // Timing info:
    DWORD GetCurrTimeInMillis(void);
    double GetCurrTime() { return (double)(GetCurrTimeInMillis()) / 1000.0; }

    BOOL InsideImage(POINT ptXY);

public:
    virtual void OnTimer(DWORD dwTime);
};

/*==========================================================================*/

#endif // __SGRFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sprite\sprinit.h ===
/*++

Module: 
	sprinit.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Header for control-specific initialisation

History:
	05-27-1997	Created (SimonB)

++*/
#include "..\mmctl\inc\ochelp.h" // for ControlInfo

#ifndef __SPRINIT_H__
#define __SPRINIT_H__

void InitSpriteControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);

#endif // __SPRINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sprite\sprite.cpp ===
/*==========================================================================*\

    Module:
            sprite.cpp

    Author:
            IHammer Team (SimonB)

    Created:
            May 1997

    Description:
            Implements any control-specific members, as well as the control's interface

    History:
            05-27-1997  Created (SimonB)

\*==========================================================================*/

#define USE_VIEWSTATUS_SURFACE
#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "sprite.h"
#include "sprevent.h"
#include "ddrawex.h"
#include <htmlfilter.h>
#include "..\ihbase\parser.h"
#include "..\ihbase\timemark.h"
#include <strwrap.h>

/*==========================================================================*/

extern ControlInfo g_ctlinfoSprite;

/*==========================================================================*/
//
// CSpriteCtl Creation/Destruction
//

LPUNKNOWN __stdcall AllocSpriteControl(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr;
    CSpriteCtl *pthis = New CSpriteCtl(punkOuter, &hr);

    if (pthis == NULL)
        return NULL;

    if (FAILED(hr))
    {
        Delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

/*==========================================================================*/
//
// Beginning of class implementation
//

CSpriteCtl::CSpriteCtl(IUnknown *punkOuter, HRESULT *phr):
    CMyIHBaseCtl(punkOuter, phr),
    m_ptmFirst(NULL)
{
    // Initialise members
    m_fMouseInArea = FALSE;
    m_bstrSourceURL = NULL;
    m_iLoopCount = 1;
    m_fAutoStart = FALSE;
    m_iPrerollAmount = 1000;
    m_enumPlayState = Stopped;
    m_iInitialFrame = 0;
    m_iFinalFrame = -1;     // Defaults to InitialFrame
    m_iRepeat = 1;
    m_dblDuration = 1.0;
    m_dblUserPlayRate = m_dblPlayRate = 1.0;
    m_dblUserTimerInterval = m_dblTimerInterval = 0.1;   // Initialized to 100 millisecs
    m_iMaximumRate = 30;
    m_iFrame = 0;
    m_iNumFrames = 1;
    m_iNumFramesAcross = 1;
    m_iNumFramesDown = 1;
    m_fUseColorKey = FALSE;
    m_fMouseEventsEnabled = TRUE;
    m_fStarted = FALSE;
    m_dblBaseTime = 0.0;
    m_dblPreviousTime = 0.0;
    m_dblCurrentTick = 0.0;
    m_dblTimePaused = 0.0;
    m_fPersistComplete = FALSE;
    m_fOnWindowLoadFired = FALSE;
    m_iCurCycle = 0;
    m_iFrameCount = 0;
    m_iStartingFrame = 0;
    m_pArrayBvr = NULL;
    m_fOnSeekFiring = FALSE;
    m_fOnFrameSeekFiring = FALSE;
    m_fFireAbsoluteFrameMarker =  FALSE;
    m_fOnWindowUnloadFired = false;
    m_fWaitForImportsComplete = true;
    m_fOnStopFiring = false;
    m_fOnPlayFiring = false;
    m_fOnPauseFiring = false;
    m_hwndParent = 0;
    m_byteColorKeyR = m_byteColorKeyG = m_byteColorKeyB = 0;
    m_durations = NULL;

    // Tie into the DANIM DLL now...
    if (phr)
    {
        if (SUCCEEDED(*phr))
        {
            *phr = CoCreateInstance(
                CLSID_DAView,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAView,
                (void **) &m_ViewPtr);
        }

        if (SUCCEEDED(*phr))
        {
            *phr = ::CoCreateInstance(
                CLSID_DAStatics,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAStatics,
                (void **) &m_StaticsPtr);
        }

        m_clocker.SetSink((CClockerSink *)this);
    }
}

/*==========================================================================*/

CSpriteCtl::~CSpriteCtl()
{
    StopModel();

    if (m_bstrSourceURL)
    {
        SysFreeString(m_bstrSourceURL);
        m_bstrSourceURL = NULL;
    }

        m_drgFrameMarkers.MakeNullAndDelete();
        m_drgTimeMarkers.MakeNullAndDelete();
        m_drgFrameMaps.MakeNullAndDelete();

        // Delete any array of behaviors
        if (m_pArrayBvr != NULL)
        {
                Delete [] m_pArrayBvr;
                m_pArrayBvr = NULL;
        }

        // Delete any array of durations
        if (m_durations != NULL)
        {
                Delete [] m_durations;
                m_durations = NULL;
        }               
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
        HRESULT hRes = S_OK;
        BOOL fMustAddRef = FALSE;

    if (ppv)
        *ppv = NULL;
    else
        return E_POINTER;

#ifdef _DEBUG
    char ach[200];
    TRACE("SpriteCtl::QI('%s')\n", DebugIIDName(riid, ach));
#endif

        if ((IsEqualIID(riid, IID_ISpriteCtl)) || (IsEqualIID(riid, IID_IDispatch)))
        {
                if (NULL == m_pTypeInfo)
                {
                        HRESULT hRes;

                        // Load the typelib
                        hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_ISpriteCtl, LIBID_DAExpressLib, NULL);

                        if (FAILED(hRes))
                        {
                                m_pTypeInfo = NULL;
                        }
                        else
                                *ppv = (ISpriteCtl *) this;

                }
                else
                        *ppv = (ISpriteCtl *) this;

        }
    else // Call into the base class
        {
                DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);

        }

    if (NULL != *ppv)
        {
                DEBUGLOG("SpriteCtl: Interface supported in control class\n");
                ((IUnknown *) *ppv)->AddRef();
        }

    return hRes;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::QueryHitPoint(
    DWORD dwAspect,
    LPCRECT prcBounds,
    POINT ptLoc,
    LONG lCloseHint,
    DWORD* pHitResult)
{
    if ((NULL != pHitResult) && (NULL != prcBounds) && m_fStarted)
    {
        *pHitResult = HITRESULT_OUTSIDE;

        if (!m_fMouseEventsEnabled)
            return S_OK;

        
/* Debug messages
        TCHAR sz[256];
        wsprintf (sz, "QueryHitPoint: dwa=%d, (%ld, %ld, %ld, %ld), (%ld, %ld), lCloseHint=%ld\r\n", 
            dwAspect, prcBounds->left, prcBounds->top, prcBounds->right, prcBounds->bottom, ptLoc.x, ptLoc.y, lCloseHint);
        DEBUGLOG(sz);
*/
        switch (dwAspect)
        {
            case DVASPECT_CONTENT:
            // Intentional fall-through
            case DVASPECT_TRANSPARENT:
            {
                // If we have a view, and we are inside the rectangle,
                // then we need to ask the view whether or not we've
                // hit the image inside.
                if (m_ViewPtr.p) {
                    HRESULT hr = m_ViewPtr->QueryHitPoint(dwAspect,
                                                          prcBounds,
                                                          ptLoc,
                                                          lCloseHint,
                                                          pHitResult);

                    // if we failed, assume that it didn't hit.
                    if (FAILED(hr)) {
                        *pHitResult = HITRESULT_OUTSIDE;
                    }
                }
                
                // Check for entry or departure
                if ((m_fMouseInArea) && (HITRESULT_OUTSIDE == *pHitResult))
                {
                    DEBUGLOG("Mouse out\r\n");
                    m_fMouseInArea = FALSE;
                    FIRE_MOUSELEAVE(m_pconpt);
                }
                else if ((!m_fMouseInArea) && (HITRESULT_HIT == *pHitResult))
                {
                    DEBUGLOG("Mouse In\r\n");
                    m_fMouseInArea = TRUE;
                    FIRE_MOUSEENTER(m_pconpt);
                }
            }
            return S_OK;

            default:
                return E_FAIL;
        }
    }
    else
    {
            return E_POINTER;
    }
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = S_FALSE;
    long lKeyState = 0;

    // Get the Keystate set up
    if (wParam & MK_CONTROL)
        lKeyState += KEYSTATE_CTRL;

    if (wParam & MK_SHIFT)
        lKeyState += KEYSTATE_SHIFT;

    if (GetAsyncKeyState(VK_MENU))
        lKeyState += KEYSTATE_ALT;

    switch (msg)
    {
        case WM_MOUSEMOVE:
        {
            // Need to get button state...
            long iButton=0;

            if (wParam & MK_LBUTTON)
                iButton += MOUSEBUTTON_LEFT;

            if (wParam & MK_MBUTTON)
                iButton += MOUSEBUTTON_MIDDLE;

            if (wParam & MK_RBUTTON)
                iButton += MOUSEBUTTON_RIGHT;

            FIRE_MOUSEMOVE(m_pconpt, iButton, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

#ifndef WM_MOUSEHOVER
#define WM_MOUSEHOVER 0x02a1
#endif
#ifndef WM_MOUSELEAVE
#define WM_MOUSELEAVE 0x02a3
#endif

        case WM_MOUSELEAVE:
           // Check for entry or departure
            if (m_fMouseInArea)
            {
                DEBUGLOG("Mouse out\r\n");
                m_fMouseInArea = FALSE;
                FIRE_MOUSELEAVE(m_pconpt);
            }
                        hr = S_OK;
            break;

        case WM_RBUTTONDOWN:
        {
            FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_RIGHT, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_MBUTTONDOWN:
        {
            FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_MIDDLE, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_LBUTTONDOWN:
        {
            FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_LEFT, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_RBUTTONUP:
        {
            FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_RIGHT, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_MBUTTONUP:
        {
            FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_MIDDLE, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_LBUTTONUP:
        {
            FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_LEFT, lKeyState, LOWORD(lParam), HIWORD(lParam));
            if (m_fMouseInArea)
                FIRE_CLICK(m_pconpt);
            hr = S_OK;
        }
        break;

        case WM_LBUTTONDBLCLK:
        {
            FIRE_DBLCLICK(m_pconpt);
            hr = S_OK;
        }
        break;
    }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
    HRESULT hRes = S_OK;
    BSTR bstrSourceURL = NULL;
    int iMaximumRate = m_iMaximumRate;

    BOOL fIsLoading = (S_OK == pvio->IsLoading());

    // Are we saving ?  If so, convert to BSTR
    if (!fIsLoading)
    {
        bstrSourceURL = SysAllocString(m_bstrSourceURL);
    }
        else
        {
                m_fFireAbsoluteFrameMarker = FALSE;
        }


    // load or save control properties
    if (fIsLoading)
        hRes = pvio->Persist(0, "URL", VT_BSTR, &bstrSourceURL, NULL);

    if (!fIsLoading || hRes != S_OK)
        hRes = pvio->Persist(0, "SourceURL", VT_BSTR, &bstrSourceURL, NULL);

    hRes = pvio->Persist(0, "AutoStart", VT_BOOL, &m_fAutoStart, NULL);

    if (fIsLoading)
    {
        hRes = pvio->Persist(0, "InitialFrame", VT_I4, &m_iInitialFrame, NULL);
        if (hRes == S_OK)
            put_InitialFrame(m_iInitialFrame);
    }
    else
    {
        int iInitialFrame = m_iInitialFrame + 1;
        hRes = pvio->Persist(0, "InitialFrame", VT_I4, &iInitialFrame, NULL);
    }

    if (fIsLoading)
    {
        hRes = pvio->Persist(0, "FinalFrame", VT_I4, &m_iFinalFrame, NULL);
        if (hRes == S_OK)
            put_FinalFrame(m_iFinalFrame);
    }
    else
    {
        int iFinalFrame = m_iFinalFrame + 1;
        hRes = pvio->Persist(0, "FinalFrame", VT_I4, &iFinalFrame, NULL);
    }

    if (fIsLoading)
    {
        hRes = pvio->Persist(0, "Iterations", VT_I4, &m_iRepeat, NULL);
        if (hRes == S_OK)
            put_Repeat(m_iRepeat);
    }

    hRes = pvio->Persist(0, "Repeat", VT_I4, &m_iRepeat, NULL);
    if (hRes == S_OK && fIsLoading)
        put_Repeat(m_iRepeat);

    hRes = pvio->Persist(0, "TimerInterval", VT_R8, &m_dblUserTimerInterval, NULL);
    if (hRes == S_OK && fIsLoading)
        put_TimerInterval(m_dblUserTimerInterval);
    hRes = pvio->Persist(0, "PlayRate", VT_R8, &m_dblUserPlayRate, NULL);
    if (hRes == S_OK && fIsLoading)
        put_PlayRate(m_dblUserPlayRate);

    hRes = pvio->Persist(0, "MaximumRate", VT_I4, &iMaximumRate, NULL);
    if (hRes == S_OK && fIsLoading)
        put_MaximumRate(iMaximumRate);
    
    hRes = pvio->Persist(0, "NumFramesAcross", VT_I4, &m_iNumFramesAcross, NULL);
    if (hRes == S_OK && fIsLoading)
        put_NumFramesAcross(m_iNumFramesAcross);
    
    hRes = pvio->Persist(0, "NumFramesDown", VT_I4, &m_iNumFramesDown, NULL);
    if (hRes == S_OK && fIsLoading)
        put_NumFramesDown(m_iNumFramesDown);
    
    hRes = pvio->Persist(0, "NumFrames", VT_I4, &m_iNumFrames, NULL);
    if (hRes == S_OK && fIsLoading)
        put_NumFrames(m_iNumFrames);

    hRes = pvio->Persist(0, "UseColorKey", VT_BOOL, &m_fUseColorKey, NULL);
    hRes = pvio->Persist(0, "MouseEventsEnabled", VT_BOOL, &m_fMouseEventsEnabled, NULL);

    if (FAILED(hRes = PersistFrameMaps(pvio, fIsLoading)))
        {} // Ignore failure

    if (FAILED(hRes = PersistFrameMarkers(pvio, fIsLoading)))
        {}

    if (FAILED(hRes = PersistTimeMarkers(pvio, fIsLoading)))
        {}

    // Handle ColorKey persistence
    if (m_fUseColorKey)
    {
        if (fIsLoading)
        {
            BSTR bstrColorKey = NULL;
        
            if (FAILED(hRes = pvio->Persist(0,
                "ColorKey", VT_BSTR, &bstrColorKey,
                NULL)))
                return hRes;

            // Anything other than S_OK means the property doesn't exists
            if (hRes == S_OK)
            {
                int iR, iG, iB;

                iR = iG = iB = 0;
                CLineParser parser(bstrColorKey);
                if (parser.IsValid())
                {
                    parser.SetCharDelimiter(TEXT(','));
                    hRes = parser.GetFieldInt(&iR);
                
                    if (S_OK == hRes)
                        hRes = parser.GetFieldInt(&iG);

                    if (S_OK == hRes)
                    {
                        hRes = parser.GetFieldInt(&iB);
                        if (S_FALSE != hRes)
                            hRes = E_FAIL;
                        else
                            hRes = S_OK;
                    }

                    m_byteColorKeyR = iR;
                    m_byteColorKeyG = iG;
                    m_byteColorKeyB = iB;
                }
            }

            SysFreeString(bstrColorKey);
        }
        else
        {
            // Save the data
            CTStr tstrRGB(12);
            wsprintf(tstrRGB.psz(), TEXT("%lu,%lu,%lu"), m_byteColorKeyR, m_byteColorKeyG, m_byteColorKeyB);

#ifdef _UNICODE
            BSTR bstrRGB = tstrRGB.SysAllocString();

            hRes = pvio->Persist(NULL,
                "ColorKey", VT_BSTR, &bstrRGB,
                NULL);
            
            SysFreeString(bstrRGB);
#else
            LPSTR pszRGB = tstrRGB.psz();
            hRes = pvio->Persist(NULL,
                "ColorKey", VT_LPSTR, pszRGB,
                NULL);
#endif
        }
    }



    if (fIsLoading)
    {
        // We loaded, so set the member variables to the appropriate values
        put_SourceURL(bstrSourceURL);
    }

    // At this point, it's safe to free the BSTR
    SysFreeString(bstrSourceURL);

    // if any properties changed, redraw the control
    if (SUCCEEDED(hRes) && (m_poipsw != NULL)) 
    {
        if (m_fControlIsActive)
            m_poipsw->InvalidateRect(NULL, TRUE);
        else
            m_fInvalidateWhenActivated = TRUE;
    }

    // clear the dirty bit if requested
    if (dwFlags & PVIO_CLEARDIRTY)
        m_fDirty = FALSE;

    if (fIsLoading && m_fOnWindowLoadFired && m_fAutoStart)
        Play();

    m_fPersistComplete = TRUE;

    return S_OK;
}

/*==========================================================================*/
//
// IDispatch Implementation
//

STDMETHODIMP CSpriteCtl::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
        *pptinfo = NULL;

    if(itinfo != 0)
        return ResultFromScode(DISP_E_BADINDEX);

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;

    return NOERROR;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{
        return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
        HRESULT hr;

        hr = DispInvoke((ISpriteCtl *)this,
                m_pTypeInfo,
                dispidMember, wFlags, pdispparams,
                pvarResult, pexcepinfo, puArgErr);

        return hr;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = CMyIHBaseCtl::SetClientSite(pClientSite);

    if (m_ViewPtr)
    {
        m_ViewPtr->put_ClientSite(pClientSite);
    }

    m_clocker.SetHost(pClientSite);
    m_ViewPtr->put_ClientSite(pClientSite);
    m_StaticsPtr->put_ClientSite(pClientSite);

    if (!pClientSite)
        {
        StopModel();
        }
        else
        {
                // Start and stop the clocker to initiate it (to create the window etc)
                m_clocker.Start();
                m_clocker.Stop();
        }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
     DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
     LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
     BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue)
{
    int iSaveContext = 0;
    RECT rectBounds = m_rcBounds;

    if(hdcDraw==NULL)
        return E_INVALIDARG;

    iSaveContext = ::SaveDC(hdcDraw);

    ::LPtoDP(hdcDraw, reinterpret_cast<LPPOINT>(&rectBounds), 2 );

    ::SetViewportOrgEx(hdcDraw, 0, 0, NULL);

    // Add code for high-quality here...
    PaintToDC(hdcDraw, &rectBounds, FALSE);

    ::RestoreDC(hdcDraw, iSaveContext);

    return S_OK;
}

/*==========================================================================*/

HRESULT CSpriteCtl::ParseFrameMapEntry(LPTSTR pszEntry, CFrameMap **ppFrameMap)
{
    HRESULT hRes = S_OK;

    ASSERT (ppFrameMap != NULL);

    *ppFrameMap = NULL;

    CLineParser parser(pszEntry, FALSE); // No compaction needed

    if (parser.IsValid())
    {
        parser.SetCharDelimiter(TEXT(','));
        *ppFrameMap = New CFrameMap();

        if (NULL != *ppFrameMap)
        {
            hRes = parser.GetFieldInt( &((*ppFrameMap)->m_iImg) );

            if (S_OK == hRes)
                hRes = parser.GetFieldDouble( &((*ppFrameMap)->m_dblDuration) );

            if (S_OK == hRes)
            {
                BOOL fAllocated = (*ppFrameMap)->m_tstrMarkerName.AllocBuffer(lstrlen(parser.GetStringPointer(TRUE)) + 1);

                if (fAllocated)
                    hRes = parser.GetFieldString( (*ppFrameMap)->m_tstrMarkerName.psz() );
            }

            if ( !SUCCEEDED(hRes) ) // It's OK if there isn't a name
            {
                // If we didn't get the whole thing, delete the FrameMap entry
                Delete *ppFrameMap;
                *ppFrameMap = NULL;
            }
            else
            {
                // Get the length correct
                (*ppFrameMap)->m_tstrMarkerName.ResetLength();
        
                if (S_FALSE == hRes)
                    hRes = S_OK;
            }

        }
        else
        {
            // Couldn't allocate a CFrameMap
            hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        // Couldn't initialize the parser
        hRes = E_OUTOFMEMORY;
    }

    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::PersistFrameMaps(IVariantIO *pvio, BOOL fLoading)
{
    HRESULT hRes = S_OK;

    if (fLoading)
    {
        BSTR bstrLine = NULL;

        hRes = pvio->Persist(0,
            "FrameMap", VT_BSTR, &bstrLine,
            NULL);

        if (S_OK == hRes)
        {
            hRes = put_FrameMap(bstrLine);
            SysFreeString(bstrLine);
        }
    }
    else
    {
        BSTR bstrLine = NULL;
        hRes = get_FrameMap(&bstrLine);

        if (SUCCEEDED(hRes))
        {
            hRes = pvio->Persist(0,
                "FrameMap", VT_BSTR, &bstrLine,
                NULL);
        }

        SysFreeString(bstrLine);
    }

    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::PersistFrameMarkers(IVariantIO *pvio, BOOL fLoading)
{
    HRESULT hRes = S_OK;

    if (fLoading)
    {
        char rgchTagName[20]; // Construct tag name in here (ANSI)
        int iLine = 1;
        BSTR bstrLine = NULL;

        int iFrame = 0;
        LPTSTR pszMarkerName = NULL;
        CLineParser parser;

        m_drgFrameMarkers.MakeNullAndDelete();
        CTStr tstrMarkerName;
        LPWSTR pszwMarkerName = NULL;

        while (S_OK == hRes)
        {
            pszMarkerName = NULL;

            wsprintf(rgchTagName, "AddFrameMarker%lu", iLine++);
            hRes = pvio->Persist(0,
                    rgchTagName, VT_BSTR, &bstrLine,
                    NULL);

            if (S_OK == hRes) // Read in the tag
            {
                parser.SetNewString(bstrLine);
                                parser.SetCharDelimiter(TEXT(','));
                SysFreeString (bstrLine);
                bstrLine = NULL;

                if (parser.IsValid())
                {
                    hRes = parser.GetFieldInt(&iFrame);
                    if (S_OK == hRes)
                    {
                        // Allocate space of at least the remaining length of the tag
                        pszMarkerName = New TCHAR [lstrlen(parser.GetStringPointer(TRUE))];

                        if (pszMarkerName)
                        {
                            // Get the string
                            hRes = parser.GetFieldString(pszMarkerName);
                            if (SUCCEEDED(hRes))
                            {
                                bool fAbsolute = false;

                                if (S_OK == hRes)
                                {
                                    int iTemp = 1;
                                    hRes = parser.GetFieldInt(&iTemp);

                                    // 0 is the only thing we consider
                                                                        fAbsolute = (0 == iTemp) ? false : true;
                                }

                                if (SUCCEEDED(hRes))
                                {
                                    // Set up the CTStr, so we can get back a Unicode string
                                    // No copies are involved, except for (possibly) the conversion to Unicode
                                    tstrMarkerName.SetStringPointer(pszMarkerName);
                                    pszwMarkerName = tstrMarkerName.pszW();
        
                                    if (NULL != pszwMarkerName)
                                    {
                                                                                // If absolute, set the absolute frame marker to TRUE. This will speed up sequence frames later
                                                                                if (!m_fFireAbsoluteFrameMarker && fAbsolute)
                                                                                        m_fFireAbsoluteFrameMarker =  TRUE;

                                        // Construct a FrameMarker object
                                        CFrameMarker *pFrameMarker = New CFrameMarker(iFrame, pszwMarkerName, fAbsolute);
                                
                                        hRes = AddFrameMarkerElement(&pFrameMarker);
                                    }
                                    else
                                    {
                                        hRes = E_OUTOFMEMORY;
                                    }

                                    // Let make sure we don't leak the string
                                    tstrMarkerName.SetStringPointer(NULL, FALSE);
                                
                                    if (NULL != pszwMarkerName)
                                    {
                                        Delete [] pszwMarkerName;
                                        pszwMarkerName = NULL;
                                    }
                                }
                            }

                        }
                        else
                        {
                                hRes = E_OUTOFMEMORY;
                        }

                        if (!parser.IsEndOfString())
                        {
                                hRes = E_FAIL;
                        }
                    }

                }
                else
                {
                    // Only reason parser isn't valid is if we don't have memory
                    hRes = E_OUTOFMEMORY;
                }

#ifdef _DEBUG
                if (E_FAIL == hRes)
                {
                    TCHAR rgtchErr[100];
                    wsprintf(rgtchErr, TEXT("SpriteCtl: Error in AddFrameMarker%lu \n"), iLine - 1);
                    DEBUGLOG(rgtchErr);
                }
#endif
            }

            // Free up the temporary string
            if (NULL != pszMarkerName)
                Delete [] pszMarkerName;
        }
    }
    else
    {
        // Save stuff out
        int iLine = 1;
        int iNumItems = m_drgFrameMarkers.Count();

        char rgchTagName[21];
        LPTSTR pszMarker = NULL;
        CTStr tstr;
        CTStr tstrMarkerName;
        CFrameMarker *pMarker;

        while ( (iLine <= iNumItems) && (S_OK == hRes) )
        {
            // Create the param name
            wsprintfA(rgchTagName, "AddFrameMarker%lu", iLine);

            // Now build up the tag
            pMarker = m_drgFrameMarkers[iLine - 1];
#ifdef _UNICODE
            // Avoid a redundant copy in Unicode
            tstrMarkerName.SetStringPointer(pMarker->m_bstrMarkerName);
#else
            // We need to do the conversion to ANSI anyway so copy
            tstrMarkerName.SetString(pMarker->m_bstrMarkerName);
#endif
            tstr.AllocBuffer(tstrMarkerName.Len() + 1);
            pszMarker = tstr.psz();

            int iAbsolute = (pMarker->m_fAbsolute) ? 1 : 0;

            // Because we used SetStringPointer. pszMarker is still valid
            wsprintf(pszMarker, TEXT("%lu,%s,%lu"), pMarker->m_iFrame, tstrMarkerName.psz(), iAbsolute);

            // Allocate a BSTR from what we constructed
            BSTR bstrLine = tstr.SysAllocString();

            // And write it out
            hRes = pvio->Persist(0,
                    rgchTagName, VT_BSTR, &bstrLine,
                    NULL);
            SysFreeString(bstrLine);

            iLine++;
#ifdef _UNICODE
            // For ANSI, the class will take care of freeing up any memory it has used
            tstrMarkerName.SetStringPointer(NULL, FALSE);
#endif
        }
    }

    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::PersistTimeMarkers(IVariantIO* pvio, BOOL fLoading)
{
    HRESULT hRes = S_OK;

    if (fLoading)
    {
        int iLine = 1;

                // Poor design - We have two references to 
                // the first time marker in the list.  We need
                // to NULL this pointer out, and defer the 
                // actual deletion to the 
                // m_drgTimeMarkers.MakeNullAndDelete call.
                if (NULL != m_ptmFirst)
                {
                        m_ptmFirst = NULL;
                }
        m_drgTimeMarkers.MakeNullAndDelete();
        CTimeMarker *pTimeMarker;

        while (S_OK == hRes)
        {
            hRes = ParseTimeMarker(pvio, iLine++, &pTimeMarker, &m_ptmFirst);
            if (S_OK == hRes)
            {
                hRes = AddTimeMarkerElement(&pTimeMarker);
            }
        }
    }
    else // Saving
    {
        int iLine = 1;
        int iNumItems = m_drgTimeMarkers.Count();

        while ( (iLine <= iNumItems) && (S_OK == hRes) )
        {
            hRes = WriteTimeMarker(pvio, iLine, m_drgTimeMarkers[iLine - 1]);
            iLine++;
        }

    }
    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::AddTimeMarkerElement(CTimeMarker **ppNewMarker)
{
    HRESULT hRes = S_OK;

    if ( (*ppNewMarker) && (NULL != (*ppNewMarker)->m_pwszMarkerName) )
    {
        m_drgTimeMarkers.Insert(*ppNewMarker);
    }
    else
    {
        if (NULL != *ppNewMarker)
        {
                Delete *ppNewMarker;
                *ppNewMarker = NULL;
        }

        hRes = E_OUTOFMEMORY;
    }

    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::AddFrameMarkerElement(CFrameMarker **ppNewMarker)
{
    HRESULT hRes = S_OK;

    if ( (*ppNewMarker) && (NULL != (*ppNewMarker)->m_bstrMarkerName) )
    {
        m_drgFrameMarkers.Insert(*ppNewMarker);
    }
    else
    {
        if (NULL != *ppNewMarker)
        {
            Delete *ppNewMarker;
            *ppNewMarker = NULL;
        }

        hRes = E_OUTOFMEMORY;
    }

    return hRes;
}

/*==========================================================================*/
//
// ISpriteCtl implementation
//

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_AutoStart(VARIANT_BOOL __RPC_FAR *fAutoStart)
{
    HANDLENULLPOINTER(fAutoStart);

    *fAutoStart = BOOL_TO_VBOOL(m_fAutoStart);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_AutoStart(VARIANT_BOOL fAutoStart)
{
    m_fAutoStart = VBOOL_TO_BOOL(fAutoStart);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Frame(unsigned int __RPC_FAR *piFrame)
{
    if (!m_fDesignMode)
    {
        HANDLENULLPOINTER(piFrame);

        if (Playing == m_enumPlayState)
        {
            int iFrame = GetFrameFromTime(m_dblCurrentTick-m_dblBaseTime);
            iFrame %= m_iFrameCount;
            *piFrame = (iFrame + 1);
        }
        else if (Paused == m_enumPlayState)
        {
            int iFrame = GetFrameFromTime(m_dblTimePaused-m_dblBaseTime);
            iFrame %= m_iFrameCount;
            *piFrame = (iFrame + 1);
        }
        else
        {
            *piFrame = (m_iInitialFrame + 1);
        }

        return S_OK;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_Frame(unsigned int iFrame)
{
    HRESULT hRes = S_OK;

    if (!m_fDesignMode)
    {
        hRes = FrameSeek(iFrame);
    }
    else
    {
        return CTL_E_SETNOTSUPPORTED;
    }

    return hRes;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_FrameMap(BSTR __RPC_FAR *FrameMap)
{
    HANDLENULLPOINTER(FrameMap);

    *FrameMap = m_tstrFrameMap.SysAllocString();

    // Do we need to check that BSTR allocation worked ?
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_FrameMap(BSTR FrameMap)
{
    HRESULT hRes = S_OK;

    if (m_enumPlayState == Stopped)
    {
        if (FrameMap == NULL)
            return S_OK;

        CLineParser parser(FrameMap);
        CTStr tstr(lstrlenW(FrameMap) + 1);

        if ( (NULL != tstr.psz()) && (parser.IsValid()) )
        {
            // Clear out the list
            m_drgFrameMaps.MakeNullAndDelete();
            m_tstrFrameMap.FreeBuffer();
            m_dblDuration = 0.0f;

            parser.SetCharDelimiter(TEXT(';'));

            while ( !parser.IsEndOfString() && (hRes == S_OK) )
            {
                hRes = parser.GetFieldString( tstr.psz() );

                if (SUCCEEDED(hRes))
                {
                    CFrameMap *pNewFrameMap;
                    hRes = ParseFrameMapEntry(tstr.psz(), &pNewFrameMap);
                    if (SUCCEEDED(hRes))
                    {
                        m_drgFrameMaps.Insert(pNewFrameMap);
                        m_dblDuration += pNewFrameMap->m_dblDuration;
                    }
                }
            }

            if ( SUCCEEDED(hRes) ) // S_FALSE and S_OK both permissible
            {
                m_tstrFrameMap.SetString(parser.GetStringPointer(FALSE));
                hRes = (NULL != m_tstrFrameMap.psz()) ? S_OK : E_OUTOFMEMORY;
            }
        }
        else
        {
                // Couldn't allocate a string for the line
                hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        return CTL_E_SETNOTPERMITTED;
    }

    return hRes;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_InitialFrame(int __RPC_FAR *iFrame)
{
    HANDLENULLPOINTER(iFrame);

    *iFrame = (m_iInitialFrame + 1);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_InitialFrame(int iFrame)
{
    if (iFrame < -1)
        return DISP_E_OVERFLOW;

    m_iInitialFrame = iFrame - 1;
    // Load the initial sprite
    ShowImage(m_iInitialFrame);

    // Set the m_iFrame 
    m_iFrame = (m_iInitialFrame < 0) ? 0 : m_iInitialFrame;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_FinalFrame(int __RPC_FAR *iFrame)
{
    HANDLENULLPOINTER(iFrame);

    *iFrame = (m_iFinalFrame + 1);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_FinalFrame(int iFrame)
{
    if (iFrame < -1)
        return DISP_E_OVERFLOW;

    m_iFinalFrame = iFrame - 1;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Iterations(int __RPC_FAR *iRepeat)
{
    HANDLENULLPOINTER(iRepeat);

    get_Repeat(iRepeat);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_Iterations(int iRepeat)
{
    put_Repeat(iRepeat);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Library(IDAStatics __RPC_FAR **ppLibrary)
{
    HANDLENULLPOINTER(ppLibrary);

    if (!m_fDesignMode)
    {
        if (m_StaticsPtr)
        {
            // AddRef since this is really a Query...
            m_StaticsPtr.p->AddRef();

            // Set the return value...
            *ppLibrary = m_StaticsPtr.p;
        }
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Repeat(int __RPC_FAR *iRepeat)
{
    HANDLENULLPOINTER(iRepeat);

    *iRepeat = m_iRepeat;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_Repeat(int iRepeat)
{
    m_iRepeat = iRepeat;
    if (m_iRepeat < -1)
        m_iRepeat = -1;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_PlayRate(double __RPC_FAR *dblSpeed)
{
    HANDLENULLPOINTER(dblSpeed);

    *dblSpeed = m_dblUserPlayRate;

    return S_OK;
}

void CSpriteCtl::CalculateEffectiveTimerInterval()
// Calculate the effective timer interval from the 
// current user timer interval and the current play rate
{
    // Convert m_dblTimerInterval to seconds and adjust the limits
    m_dblTimerInterval = m_dblUserTimerInterval / m_dblPlayRate;
    if (m_dblTimerInterval < 0.0) m_dblTimerInterval *= -1;
    m_dblTimerInterval = max(m_dblTimerInterval, 0.02);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_PlayRate(double dblSpeed)
{
    m_dblUserPlayRate = m_dblPlayRate = dblSpeed;

    // Check the limits of play rate
    if (m_dblPlayRate >= 0)
        m_dblPlayRate = max(m_dblPlayRate, 0.0000001);
    else
        m_dblPlayRate = min(m_dblPlayRate, -0.0000001);

    CalculateEffectiveTimerInterval();

    // TODO: Rebuild the imagelist and Update the sprite image
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Time(double __RPC_FAR *pdblTime)
{
    HANDLENULLPOINTER(pdblTime);

    // This property is only available at run-time
    if (m_fDesignMode)
        return CTL_E_GETNOTSUPPORTED;

    // Find the current time
        if (Stopped == m_enumPlayState || (DWORD)(m_dblDuration * 1000) == 0)
        {
                *pdblTime = 0.0;
        }
        else if (Playing == m_enumPlayState)
        {
                // Time passed so far in the current cycle
                DWORD dwTick = (DWORD)((m_dblCurrentTick - m_dblBaseTime) * 1000);
                dwTick %= (DWORD)(m_dblDuration * 1000);
                // Add any time during the previous cycles
                dwTick += (DWORD)(((m_iCurCycle-1) * m_dblDuration) * 1000);
                *pdblTime = (double)dwTick / 1000;
        }
        else if (Paused == m_enumPlayState)
        {
                // Time passed so far in the current cycle
                DWORD dwTick = (DWORD)((m_dblTimePaused - m_dblBaseTime) * 1000);
                dwTick %= (DWORD)(m_dblDuration * 1000);
                // Add any time during the previous cycles
                dwTick += (DWORD)(((m_iCurCycle-1) * m_dblDuration) * 1000);
                *pdblTime = (double)dwTick / 1000;
        }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_MaximumRate(unsigned int __RPC_FAR *iFps)
{
    HANDLENULLPOINTER(iFps);
    *iFps = m_iMaximumRate;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_MaximumRate(unsigned int iFps)
{
    if (iFps > 0)
        m_iMaximumRate = min(iFps,30);
    else
        return DISP_E_OVERFLOW;
    
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_NumFrames(unsigned int __RPC_FAR *iNumFrames)
{
    HANDLENULLPOINTER(iNumFrames);

    *iNumFrames = m_iNumFrames;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_NumFrames(unsigned int iNumFrames)
{
        // Set the number of frames and check its limits
    m_iNumFrames = iNumFrames;
        
    if (m_iNumFrames <= 0)
            m_iNumFrames = 1;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_PlayState(PlayStateConstant __RPC_FAR *PlayState)
{
    if (!m_fDesignMode)
    {
        HANDLENULLPOINTER(PlayState);

                if (m_fAutoStart && !m_fOnWindowLoadFired)
                {
                *PlayState = Playing;
                }
                else
                {
                *PlayState = m_enumPlayState;
                }
        return S_OK;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_NumFramesAcross(unsigned int __RPC_FAR *iFrames)
{
    HANDLENULLPOINTER(iFrames);

    *iFrames = m_iNumFramesAcross;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_NumFramesAcross(unsigned int iFrames)
{
        // Set the number of frames across and check its limits
    m_iNumFramesAcross = iFrames;
        if (m_iNumFramesAcross <= 0)
            m_iNumFramesAcross = 1;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_NumFramesDown(unsigned int __RPC_FAR *iFrames)
{
    HANDLENULLPOINTER(iFrames);

    *iFrames = m_iNumFramesDown;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_NumFramesDown(unsigned int iFrames)
{
        // Set the number of frames down and check its limits
    m_iNumFramesDown = iFrames;
        if (m_iNumFramesDown <= 0)
            m_iNumFramesDown = 1;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_UseColorKey(VARIANT_BOOL __RPC_FAR *Solid)
{
    HANDLENULLPOINTER(Solid);

    *Solid = BOOL_TO_VBOOL(m_fUseColorKey);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_UseColorKey(VARIANT_BOOL Solid)
{
    m_fUseColorKey = VBOOL_TO_BOOL(Solid);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Image(IDAImage __RPC_FAR **ppImage)
{
    HRESULT hr = S_OK;

    HANDLENULLPOINTER(ppImage);

    if (FAILED(hr = InitializeObjects()))
        return hr;

    if (m_ImagePtr)
    {
        // AddRef since this is really a Query...
        m_ImagePtr.p->AddRef();

        // Set the return value...
        *ppImage = m_ImagePtr.p;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_Image(IDAImage __RPC_FAR *pImage)
{
    HRESULT hr = S_OK;
    HANDLENULLPOINTER(pImage);

    // Stop any currently playing
    Stop();

    if (FAILED(hr = InitializeObjects()))
        return hr;

    // This will free any existing image and then use
    // the one passed into this method...
    if (SUCCEEDED(hr = UpdateImage(pImage)))
        hr = ShowImage(m_iInitialFrame);

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_ColorKey(IDAColor __RPC_FAR **pColorKey)
{
    if (!m_fDesignMode)
    {
        HANDLENULLPOINTER(*pColorKey);
        *pColorKey = NULL;
        HRESULT hr = S_OK;

        if (m_fUseColorKey)
        {
            CComPtr<IDAColor> ColorPtr;
        
            if (FAILED(hr = m_StaticsPtr->ColorRgb255( (short)m_byteColorKeyR, (short)m_byteColorKeyG, (short)m_byteColorKeyB, &ColorPtr)))
                return hr;

            ColorPtr.p->AddRef();
            *pColorKey = ColorPtr.p;
        }
        
        return hr;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_ColorKey(IDAColor __RPC_FAR *pColorKey)
{
    if (!m_fDesignMode)
    {
        HANDLENULLPOINTER(pColorKey);
        HRESULT hr = S_OK;
        double dblTemp;
        
        CComPtr<IDANumber> RedPtr, GreenPtr, BluePtr;

        // Make sure we get all the values successfully before converting
        if (FAILED(hr = pColorKey->get_Red(&RedPtr)))
            return hr;

        if (FAILED(hr = pColorKey->get_Green(&GreenPtr)))
            return hr;

        if (FAILED(hr = pColorKey->get_Blue(&BluePtr)))
            return hr;

        if (FAILED(hr = RedPtr->Extract(&dblTemp)))
            return hr;

        m_byteColorKeyR = (int)(dblTemp * 255.0);

        if (FAILED(hr = GreenPtr->Extract(&dblTemp)))
            return hr;

        m_byteColorKeyG = (int)(dblTemp * 255.0);

        if (FAILED(hr = BluePtr->Extract(&dblTemp)))
            return hr;

        m_byteColorKeyB = (int)(dblTemp * 255.0);

            // Stop any currently playing and reload the image
                Stop();
                UpdateImage(NULL);
                InitializeImage();
                ShowImage(m_iInitialFrame);
        
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTED;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_ColorKeyRGB(COLORREF* pColorKeyRGB)
{
    HANDLENULLPOINTER(pColorKeyRGB);

    if (m_fDesignMode)
    {
        *pColorKeyRGB = RGB((BYTE)m_byteColorKeyR, (BYTE)m_byteColorKeyG, (BYTE)m_byteColorKeyB);
        return S_OK;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_ColorKeyRGB(COLORREF ColorKeyRGB)
{
    if (m_fDesignMode)
    {
        m_byteColorKeyR = (int)GetRValue(ColorKeyRGB);
        m_byteColorKeyG = (int)GetGValue(ColorKeyRGB);
        m_byteColorKeyB = (int)GetBValue(ColorKeyRGB);
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_SourceURL(BSTR __RPC_FAR *bstrSourceURL)
{
    HANDLENULLPOINTER(bstrSourceURL);

    if (*bstrSourceURL)
        SysFreeString(*bstrSourceURL);

    *bstrSourceURL = SysAllocString(m_bstrSourceURL);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_SourceURL(BSTR bstrSourceURL)
{
    HRESULT hr = S_OK;

    if (bstrSourceURL)
    {
        BSTR bstrNewURL = SysAllocString(bstrSourceURL);

        if (bstrNewURL)
        {
            if (m_bstrSourceURL)
            {
                                // Stop any currently playing and reload the image
                                if (m_enumPlayState != Stopped) Stop();
                                UpdateImage(NULL);
                SysFreeString(m_bstrSourceURL);
                m_bstrSourceURL = NULL;
            }

            m_bstrSourceURL = bstrNewURL;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        if (m_bstrSourceURL)
        {
            SysFreeString(m_bstrSourceURL);
            m_bstrSourceURL = NULL;
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_MouseEventsEnabled(VARIANT_BOOL __RPC_FAR *Enabled)
{
    HANDLENULLPOINTER(Enabled);

    *Enabled = BOOL_TO_VBOOL(m_fMouseEventsEnabled);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_MouseEventsEnabled(VARIANT_BOOL Enabled)
{
    m_fMouseEventsEnabled = VBOOL_TO_BOOL(Enabled);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_TimerInterval(double *pdblTimerInterval)
{
    HANDLENULLPOINTER(pdblTimerInterval);

    *pdblTimerInterval = m_dblUserTimerInterval;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_TimerInterval(double dblTimerInterval)
{
    if (dblTimerInterval < 0.0)
        return E_INVALIDARG;

    m_dblUserTimerInterval = m_dblTimerInterval = dblTimerInterval;

    // Recalculate the timer interval using the user play rate
    CalculateEffectiveTimerInterval();

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::AddFrameMarker(unsigned int iFrame, BSTR MarkerName, VARIANT varAbsolute)
{
    BOOL fAbsolute = FALSE;

    if (!ISEMPTYARG(varAbsolute))
        {
        VARIANT varTarget;
        VariantInit(&varTarget);

        if (SUCCEEDED(VariantChangeTypeEx(&varTarget, &varAbsolute, LANGID_USENGLISH, 0, VT_BOOL)))
            fAbsolute = VBOOL_TO_BOOL(V_BOOL(&varTarget));
        else
            return DISP_E_TYPEMISMATCH;
        }

        // If absolute, set the absolute frame marker to TRUE. This will speed up sequence frames later
        if (!m_fFireAbsoluteFrameMarker && fAbsolute)
                m_fFireAbsoluteFrameMarker =  TRUE;

    CFrameMarker *pNewMarker = New CFrameMarker(iFrame, MarkerName, fAbsolute ? true : false);

    return AddFrameMarkerElement(&pNewMarker);
}

/*==========================================================================*/

void FireSpriteMarker(IConnectionPointHelper* pconpt, CTimeMarker* pmarker, boolean bPlaying)
{
    BSTR bstr = SysAllocString(pmarker->m_pwszMarkerName);

    if (bPlaying) {
        FIRE_ONPLAYMARKER(pconpt, bstr);
    }

    FIRE_ONMARKER(pconpt, bstr);

    SysFreeString(bstr);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::AddTimeMarker(double dblTime, BSTR bstrMarkerName, VARIANT varAbsolute)
{
    BOOL fAbsolute = TRUE;

    if (!ISEMPTYARG(varAbsolute))
        {
        VARIANT varTarget;
        VariantInit(&varTarget);

        if (SUCCEEDED(VariantChangeTypeEx(&varTarget, &varAbsolute, LANGID_USENGLISH, 0, VT_BOOL)))
            fAbsolute = VBOOL_TO_BOOL(V_BOOL(&varTarget));
        else
            return DISP_E_TYPEMISMATCH;
        }


    CTimeMarker *pNewMarker = New CTimeMarker(&m_ptmFirst, dblTime, bstrMarkerName, (boolean) fAbsolute);

    return AddTimeMarkerElement(&pNewMarker);
}

/*==========================================================================*/

double CSpriteCtl::GetTimeFromFrame(int iFrame)
// Returns the time at iFrame
{
    if (m_dblTimerInterval <= 0 || m_dblDuration <= 0 || iFrame <= 0)
            return 0;

    int nFrameMapsCount = m_drgFrameMaps.Count();

    if (nFrameMapsCount <= 0)
    // Regular animation using play rate
    {
            return iFrame * m_dblTimerInterval;
    }

    // Frame map; loop through each frame to get the time
    int nLoops = iFrame / nFrameMapsCount;
    double dblTotalTime = nLoops * m_dblDuration;   // Time of the frame maps
    for (int i=0; i < (iFrame % nFrameMapsCount); i++)
    {
        int j = (m_dblPlayRate >= 0.0) ? i : (nFrameMapsCount-1-i);
        dblTotalTime += m_durations[j]; // (m_drgFrameMaps[j]->m_dblDuration / m_dblPlayRate);
    }
    return dblTotalTime;
}

/*==========================================================================*/

int CSpriteCtl::GetFrameFromTime(double dblTime, double* pdblDuration/*=NULL*/)
// Returns the absolute frame at dblTime
// Assumes that m_dblTimerInterval and m_dblDuration are already set 
// Outs pdblDuration - the time remaining in the current frame
{
    if (m_dblTimerInterval <= 0 || m_dblDuration <= 0 || m_iFrameCount <= 0 || dblTime <= 0.0)
            return 0;

    // Initialize the duration to 0.0
    if (pdblDuration)
        *pdblDuration = 0.0;

    int nFrameMapsCount = m_drgFrameMaps.Count();

    if (nFrameMapsCount <= 0)
    // Regular animation using play rate
    {
        int iFrame = (int)(dblTime / m_dblTimerInterval);
        // Calculate the time remaining in iFrame
        if (pdblDuration)
            *pdblDuration = ((iFrame+1) * m_dblTimerInterval) - dblTime;
        return iFrame;
    }

    // Frame map; loop through each frame to get the frame
    double dblTotalTime = 0.0;      // Time of the frame maps
    int nLoops = (int)(dblTime/m_dblDuration);      // Number of loops traversed so far
    double dblFrameTime = dblTime - (nLoops * m_dblDuration);       // Relative time of the frame
    for (int i=0; i<nFrameMapsCount; i++)
    {
        int j = (m_dblPlayRate >= 0.0) ? i : (nFrameMapsCount-1-i);
        dblTotalTime += m_durations[j]; // (m_drgFrameMaps[j]->m_dblDuration / m_dblPlayRate);
        if (dblTotalTime > dblFrameTime)
        {
            // Calculate the time remaining in iFrame
            if (pdblDuration)
                *pdblDuration = dblTotalTime - dblFrameTime;
            break;
        }
    }
    return (i + (nLoops*nFrameMapsCount));
}

/*==========================================================================*/

HRESULT CSpriteCtl::Resume (void)
{
        HRESULT hr = S_OK;
        // Find the frame at which we paused
        double dblDuration=0.0;
        int iFrame = GetFrameFromTime(m_dblTimePaused - m_dblBaseTime, &dblDuration);

        // Resequence the frames starting with iFrame
        if (FAILED(hr = SequenceFrames(iFrame, dblDuration))) 
            return hr;

        // increment the current cycle
                m_iCurCycle++;

                // Update the base time to reflect the time paused
        double dblDelta = (GetCurrTime() - m_dblTimePaused); 
        m_dblBaseTime += dblDelta;
        m_dblCurrentTick += dblDelta;
        m_dblTimePaused = 0.0;

        // Restart the clock
        hr = m_clocker.Start();

                // Switch to the sequenced behaviour
                m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                // Fire any starting frame Callouts
                FireFrameMarker(m_iStartingFrame);

                return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::Play(void)
{
    HRESULT hr = S_OK;

    if (Playing != m_enumPlayState)
    {
        if (m_iRepeat == 0)
        {   // Need not play, so just show the initial sprite image
            return ShowImage(m_iInitialFrame);
        }

        if (Paused != m_enumPlayState)
        {
            hr = StartPlaying();
        }
        else
        {
            hr = Resume();
        }
        
        if (SUCCEEDED(hr))
        {
            m_enumPlayState = Playing;

                        FIRE_ONPLAY(m_pconpt);
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::Stop(void)
{
    HRESULT hr = S_OK;

    if (m_enumPlayState != Stopped)
    {
        m_enumPlayState = Stopped;
        m_dblBaseTime = m_dblCurrentTick = 0.0;
        m_dblPreviousTime = 0;

        // Show the initial sprite image
        if (m_iFinalFrame >= -1)
            ShowImage(m_iFinalFrame == -1 ? m_iInitialFrame : m_iFinalFrame);

        InvalidateControl(NULL, TRUE);

        m_clocker.Stop();

        m_iCurCycle = m_iStartingFrame = 0;
        m_iFrame = (m_iInitialFrame < 0) ? 0 : m_iInitialFrame;

                FIRE_ONSTOP(m_pconpt);
    }
    else    // REVIEW: Is this else block necessary???
    {
        // Show the final sprite image
        if (m_iFinalFrame >= -1)
            ShowImage(m_iFinalFrame == -1 ? m_iInitialFrame : m_iFinalFrame);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::Pause(void)
{
    HRESULT hr = S_OK;

    if (Playing == m_enumPlayState)
    {
        // Stop the clock from ticking.
        hr = m_clocker.Stop();
        ASSERT(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            m_enumPlayState = Paused;
            m_dblCurrentTick = m_dblTimePaused = GetCurrTime();
            int iFrame = GetFrameFromTime(m_dblCurrentTick-m_dblBaseTime);
            iFrame %= m_iFrameCount;
            ShowImage(iFrame, TRUE);

            FIRE_ONPAUSE(m_pconpt);
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::Seek(double dblTime)
// Seek to the frame at dblTime
{
    // Find the frame at dblTime and seek from that frame
    HRESULT hr = S_OK;
    double dblDuration = 0.0;
    int iFrame = GetFrameFromTime(dblTime, &dblDuration);

    if (iFrame >= 0)
    {
        hr = SeekFrame(iFrame, dblDuration);

        if (!m_fOnSeekFiring)
        {
            m_fOnSeekFiring = TRUE;
            FIRE_ONSEEK(m_pconpt, dblTime);
            m_fOnSeekFiring = FALSE;
        }
    }
    else
    {
        hr = DISP_E_OVERFLOW;
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::FrameSeek(unsigned int iFrame)
{
    HRESULT hr = S_OK;
    
    hr = SeekFrame(iFrame - 1);

    if (!m_fOnFrameSeekFiring)
    {
        m_fOnFrameSeekFiring = TRUE;
        FIRE_ONFRAMESEEK(m_pconpt, iFrame);
        m_fOnFrameSeekFiring = FALSE;
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::SeekFrame(int iFrame, double dblDuration/*=0.0*/)
// Seek to the frame at iFrame
{
    HRESULT hr = S_OK;

    // Make sure everything's been initialized
    if (FAILED(hr = InitializeImage()) || m_iFrameCount <= 0 || 
        iFrame < 0 || (m_iRepeat >= 0 && iFrame >= m_iRepeat*m_iFrameCount)) 
        return E_FAIL;

    // Set the frame number and the loop count
    m_iFrame = iFrame;
    m_iCurCycle = iFrame / m_iFrameCount;

    // Check if current cycle leaped bounds
    if (m_iRepeat >= 0 && m_iCurCycle >= m_iRepeat)
    {
        return Stop();
    }

    // Stop the current play if it's playing and restart at the new frame
    if (Playing == m_enumPlayState)
    {
        // Stop the clock from ticking.
        hr = m_clocker.Stop();
        ASSERT(SUCCEEDED(hr));

        // Sequence the frames from iFrame
        if (FAILED(hr = SequenceFrames(iFrame, dblDuration))) 
            return hr;

        // increment the current cycle
        m_iCurCycle++;

        // Reset the timers 
        m_dblCurrentTick = GetCurrTime();
        m_dblBaseTime = m_dblCurrentTick - GetTimeFromFrame(iFrame) - dblDuration;

        // Fire any time marker
        FireTimeMarker(m_dblCurrentTick - m_dblBaseTime);

        // Restart the clock
        hr = m_clocker.Start();

                // Switch to the sequenced behaviour
                m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                // Fire any starting frame Callouts
                FireFrameMarker(m_iStartingFrame);

                return hr;
    } 
    else 
    {
        // Switch to this frame
        hr = ShowImage(iFrame, TRUE);

        // Fire any time markers
        double dblNewTime = GetTimeFromFrame(iFrame) + dblDuration;
        FireTimeMarker(dblNewTime);
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::ShowImage(int iShowFrame, BOOL bPlayRate/*=FALSE*/)
// Shows the image at frame iShowFrame
// If the iShowFrame is out of bounds then nothing happens
// Assumes that m_pArray is set and everything else is initialized properly
{
    HRESULT hr = S_OK;

    // If we are already playing then don't show the image
    if (Playing == m_enumPlayState || !m_fOnWindowLoadFired)
        return hr;

    // Load the initial sprite if it hasn't been already
    if (m_pArrayBvr == NULL || m_iFrameCount <= 0) 
        if (FAILED(hr = InitializeImage()))
            return hr;

    if (m_pArrayBvr == NULL)
        return UpdateImage(NULL);

    // Check the limits of iShowFrame
    if (iShowFrame < 0 || (m_iRepeat >= 0 && iShowFrame >= m_iRepeat*m_iFrameCount))
        iShowFrame = m_iInitialFrame;

    // If m_iInitialFrame is -ve then just show a blank image
    if (iShowFrame < 0)
        return UpdateImage(NULL);

    // Set iShowFrame to array limits of frames
    iShowFrame %= m_iFrameCount;

    if (bPlayRate && m_dblPlayRate < 0.0)
    {
        // Count the frame backwards if the play rate is -ve
        iShowFrame = m_iFrameCount-1-iShowFrame;
    }

    // Switch to the loaded image
    hr = m_PlayImagePtr->SwitchTo(m_pArrayBvr[iShowFrame]);

    // Fire any frame markers at iShowFrame (note: don't use play rate)
    FireFrameMarker(iShowFrame, FALSE);

    // Cause the tick
    OnTimer((DWORD)GetCurrTime()*1000);

    // Update the sprite
    InvalidateControl(NULL, TRUE);

    return hr;
}

/*==========================================================================*/

BSTR *
CSpriteCtl::GetCallout(unsigned long frameNum)
// Assumes that frameNum is always relative
{
        // Add one because the frame markers are 1-based, and the array is 0-based.
    frameNum++;
        for (int i = 0; i < m_drgFrameMarkers.Count(); i++) 
        {
        CFrameMarker* pmarker = m_drgFrameMarkers[i];

                // If the frame marker is absolute then update frameNum
                unsigned long iFrame = (pmarker->m_fAbsolute) ? (frameNum+m_iCurCycle*m_iFrameCount) : frameNum;

                if (iFrame == pmarker->m_iFrame) 
                {
                        return &(m_drgFrameMarkers[i]->m_bstrMarkerName);
                }
        }

        return NULL;
}

/*==========================================================================*/

class CCalloutNotifier : public IDAUntilNotifier {


  protected:
    long                     _cRefs;
    CTStr                    m_pwszFrameCallout;
    int                      _frameNum;
    IConnectionPointHelper   *m_pconpt;
    CSpriteCtl               *m_pSprite;

  public:

    // IUnknown methods
    STDMETHODIMP_(ULONG) AddRef() { return InterlockedIncrement(&_cRefs); }
    
    STDMETHODIMP_(ULONG) Release() {
        ULONG refCount = InterlockedDecrement(&_cRefs);
        if ( 0 == refCount) {
            Delete this;
            return refCount;
        }
        return _cRefs;
    }
    
    STDMETHODIMP QueryInterface (REFIID riid, void **ppv) {
        if ( !ppv )
            return E_POINTER;

        *ppv = NULL;
        if (riid == IID_IUnknown) {
            *ppv = (void *)(IUnknown *)this;
        } else if (riid == IID_IDABvrHook) {
            *ppv = (void *)(IDAUntilNotifier *)this;
        }

        if (*ppv)
          {
              ((IUnknown *)*ppv)->AddRef();
              return S_OK;
          }

        return E_NOINTERFACE;
    }
        
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
                               LCID lcid, DISPID *rgdispid) { return E_NOTIMPL; }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
                        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
                        EXCEPINFO *pexcepinfo, UINT *puArgErr) { return E_NOTIMPL; }

    CCalloutNotifier(CSpriteCtl *pSprite, LPWSTR frameCallout, int frameNum, IConnectionPointHelper *pconpt)
        {
        ASSERT (pconpt != NULL);
        ASSERT (pSprite != NULL);

        m_pSprite = pSprite;
        
        _cRefs             = 1;
        
        // Increment the lock count on the server by one
        ::InterlockedIncrement((long *)&(g_ctlinfoSprite.pcLock));
                
        m_pwszFrameCallout.SetString(frameCallout);

                _frameNum          = frameNum;

        // The reason the pointer below is not AddRef'd is because we know we 
        // will never have to use it after the sprite control has gone away.  The 
        // sprite control maintains the refcount on the pointer
        m_pconpt           = pconpt;
        
        
        }


    ~CCalloutNotifier()
    {
        // Decrement the lock count on the server by one
        ::InterlockedDecrement((long *)&(g_ctlinfoSprite.pcLock));
    }


    STDMETHODIMP Notify(IDABehavior * eventData,
                        IDABehavior * curRunningBvr,
                        IDAView * curView,
                        IDABehavior ** ppBvr)
    {
                HANDLENULLPOINTER(ppBvr);
                HANDLENULLPOINTER(curRunningBvr);
                
                // TODO: SIMON, add script callout code here!!!  You have
                // access to the sprite object itself (_spr), and the frame
                // callout string that was passed in with AddFrameMarker
                // (_frameCallout).

        BSTR bstr = m_pwszFrameCallout.SysAllocString();
        
        if (bstr)
        {
            FIRE_ONMARKER(m_pconpt, bstr);

            if (Playing == m_pSprite->m_enumPlayState)
                FIRE_ONPLAYMARKER(m_pconpt, bstr);

            SysFreeString(bstr);
        }

                // Since this is being used in an Until() and not an
                // UntilEx(), the return value is ignored, but we need to pass
                // back a valid, correctly typed behavior, so we use
                // curRunningBvr. 
                curRunningBvr->AddRef();
                *ppBvr = curRunningBvr;
                
                return S_OK;
    }

};

HRESULT CSpriteCtl::SequenceFrames(int iStartingFrame, double dblDuration)
// Sequences the frames starting with iStarting frame
{
        HRESULT hr = S_OK;

        if (m_pArrayBvr == NULL || m_iFrameCount <= 0) 
                return E_FAIL;

    // Check if the starting frame is within our bounds
    if (iStartingFrame < 0 || (m_iRepeat >= 0 && iStartingFrame >= m_iRepeat*m_iFrameCount))
        return E_FAIL;

    // Calculate the current cycle
    m_iCurCycle = iStartingFrame / m_iFrameCount;

        // Make sure the starting frame is within the m_iFrameCount
        m_iStartingFrame = iStartingFrame % m_iFrameCount;

        // Sequence the array of behavior pointers
        CComPtr<IDABehavior> accumulatingUntil;
        bool firstTime = true;

        for (int i=m_iStartingFrame; i < m_iFrameCount; i++)
        {
        int iFrame = (m_dblPlayRate >= 0.0) ? (m_iFrameCount-1-i+m_iStartingFrame) : (i-m_iStartingFrame);

                // Get the frame marker name
        BSTR *pFrameCallout = GetCallout((m_dblPlayRate >= 0.0) ? (iFrame+1) : (iFrame-1));

                CComPtr<IDAUntilNotifier> myNotify;
                if (pFrameCallout) 
        {
            // Get the callout notifier (callback)
                        myNotify.p = (IDAUntilNotifier *) New CCalloutNotifier(this, *pFrameCallout, iFrame, m_pconpt);
                        if (!myNotify) return E_FAIL;
                }
                                
                if (firstTime) 
        {
                        if (pFrameCallout) 
            {
                // If there is a frame callback then 
                                CComPtr<IDAEvent> alwaysEvent;
                                CComPtr<IDAEvent> notifyEvent;
                                CComPtr<IDABehavior> calloutBvr;

                // Set the callout notifier to the image behavior
                if (FAILED(hr = m_StaticsPtr->get_Always(&alwaysEvent)) ||
                                        FAILED(hr = alwaysEvent->Notify(myNotify, &notifyEvent)) ||
                                        FAILED(hr = m_StaticsPtr->Until(m_pArrayBvr[iFrame], notifyEvent, m_pArrayBvr[iFrame], &calloutBvr))) 
                {
                                        return hr;
                                }
                                
                                accumulatingUntil = calloutBvr;
                                
                        } 
            else 
            {
                            // Else just set the behavior       
                                accumulatingUntil = m_pArrayBvr[iFrame];
                        }

                        firstTime = false;
                        
                } else {
                        
                        CComPtr<IDABehavior> BehaviorPtr;
                        CComPtr<IDAEvent> eventToUse;

            // Calculate the correct duration 
            double dblTime = (dblDuration && i == (m_iFrameCount-1)) ? dblDuration : m_durations[iFrame];

                        // Get the timer event for the duration
            if (FAILED(hr = m_StaticsPtr->Timer(dblTime, &eventToUse))) 
            {
                                return hr;
                        }

                        if (pFrameCallout) 
            {
                // If there is a callout add the callout notifier to the event
                                CComPtr<IDAEvent> notifyEvent;
                                if (FAILED(hr = eventToUse->Notify(myNotify, &notifyEvent))) 
                {
                                        return hr;
                                }
                                eventToUse = notifyEvent;
                        }

                        // Until the event to accumulating
            if (FAILED(hr = m_StaticsPtr->Until(m_pArrayBvr[iFrame], eventToUse, accumulatingUntil, &BehaviorPtr))) 
            {
                                return hr;
                        }
                    
                        accumulatingUntil = BehaviorPtr;
                }

        }

        m_FinalBehaviorPtr = accumulatingUntil;

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::FireTimeMarker(double dblNewTime, BOOL bReset/*=FALSE*/)
{
    HRESULT hr=S_OK;

    // If reset is TRUE, fire just the events at dblNewTime
    if (bReset)
    {
        m_dblPreviousTime = dblNewTime - 0.0001;
    }

    if (dblNewTime > m_dblPreviousTime) 
    {
        // Fire all time markers between m_dblPreviousTime and dblNewTime 
        FireMarkersBetween(m_pconpt, m_ptmFirst, FireSpriteMarker, 
            m_dblPreviousTime, dblNewTime, m_dblDuration, (Playing == m_enumPlayState));
    }

    // Update previous time
    m_dblPreviousTime = dblNewTime;

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::FireFrameMarker(int iFrame, BOOL bPlayRate/*=TRUE*/)
// If bPlayRate is TRUE then we will use the play rate to determine the frame
// iFrame passed in is relative. So we need to test it with the abs/rel flag
{
    HRESULT hr=S_OK;

    if (iFrame < 0 || m_iFrameCount <= 0 || (m_iRepeat >= 0 && iFrame >= m_iRepeat*m_iFrameCount)) 
        return E_FAIL;

    // Make sure iFrame is within the limits
    iFrame = iFrame % m_iFrameCount;

    if (bPlayRate && m_dblPlayRate < 0.0)
    {
        // Count the frame backwards if the play rate is -ve
        iFrame = m_iFrameCount-1-iFrame;
    }

    BSTR *pFrameCallout = GetCallout(iFrame);
    if (pFrameCallout)
    {
        BSTR bstr = SysAllocString(*pFrameCallout);
        if (bstr)
        {
            FIRE_ONMARKER(m_pconpt, bstr);
            FIRE_ONPLAYMARKER(m_pconpt, bstr);
            SysFreeString(bstr);
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::StartPlaying (void)
{
        HRESULT hr = InitializeImage();

        if (SUCCEEDED(hr))
        {
                // Sequence the frames starting at 0 and Set the behavior 
                if (SUCCEEDED(hr = SequenceFrames(m_iFrame)))
                {
                        // Set the clocker rate to sync with the desired frame rate
                        m_clocker.SetInterval(1000/m_iMaximumRate);
                        // Increment the current cycle (must be 1)
                        m_iCurCycle++;
                        // Start the clock only if m_fStarted; else let StartModel start the clock
                    if (m_fStarted)
                        {
                                // Calculate the base time and kick off the timer
                                m_dblCurrentTick = GetCurrTime();
                                m_dblBaseTime = m_dblCurrentTick - GetTimeFromFrame(m_iFrame);
                                m_dblPreviousTime = 0;
                                hr = m_clocker.Start();

                                // Switch to the sequenced behaviour
                                m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                                // Fire any starting frame Callouts
                                FireFrameMarker(m_iStartingFrame);
                        }
                        ASSERT(SUCCEEDED(hr));
                }

                InvalidateControl(NULL, TRUE);
        }

        return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::InitializeImage(void)
// Loads, updates and builds he sprite
{
        HRESULT hr = S_OK;

        // Load image if it hasn't been loaded yet
        if (!m_ImagePtr)
        {
                CComPtr<IDAImage> ImagePtr;

                if (FAILED(hr = LoadImage(m_bstrSourceURL, &ImagePtr)))
                        return hr;

                // S_FALSE means no SourceURL was specified.  No URL, no image, no action.
                // So we don't do anything further - just return.
                if (S_FALSE == hr)
                        return S_OK;

                if (ImagePtr)
                        hr = UpdateImage(ImagePtr);

                // Fire the media loaded event only if everything goes welll and m_ImagePtr is valid
            if (SUCCEEDED(hr) && m_ImagePtr != NULL && m_fStarted)
                    FIRE_ONMEDIALOADED(m_pconpt, m_bstrSourceURL);
        }
        else // Get an empty image and build the frames
        {
                hr = BuildPlayImage();
        }

        return hr;
}

STDMETHODIMP CSpriteCtl::PaintToDC(HDC hdcDraw, LPRECT lprcBounds, BOOL fBW)
{
    HRESULT hr = S_OK;
    CComPtr<IDirectDrawSurface> DDrawSurfPtr;
    double dblCurrentTime = GetCurrTime();

    if (!lprcBounds)
        lprcBounds = &m_rcBounds;

    if (!m_ServiceProviderPtr)
    {
        if (m_pocs)
        {
            // It's OK if this fails...
            hr = m_pocs->QueryInterface(IID_IServiceProvider, (LPVOID *)&m_ServiceProviderPtr);
        }
    }

    if (!m_DirectDraw3Ptr)
    {
        // It's OK if this fails...
        hr = m_ServiceProviderPtr->QueryService(
            SID_SDirectDraw3,
            IID_IDirectDraw3,
            (LPVOID *)&m_DirectDraw3Ptr);
    }

    if (m_DirectDraw3Ptr)
    {
        ASSERT((hdcDraw!=NULL) && "Error, NULL hdcDraw in PaintToDC!!!");

        // Use DirectDraw 3 rendering...
        if (SUCCEEDED(hr = m_DirectDraw3Ptr->GetSurfaceFromDC(hdcDraw, &DDrawSurfPtr)))
        {
            if (FAILED(hr = m_ViewPtr->put_IDirectDrawSurface(DDrawSurfPtr)))
            {
                return hr;
            }

            if (FAILED(hr = m_ViewPtr->put_CompositeDirectlyToTarget(TRUE)))
            {
                return hr;
            }
        }
        else
        {
            // Fall back to generic HDC rendering services...
            if (FAILED(hr = m_ViewPtr->put_DC(hdcDraw)))
            {
                return hr;
            }
        }
    }
    else
    {
        // Use generic HDC rendering services...
        if (FAILED(hr = m_ViewPtr->put_DC(hdcDraw)))
        {
            return hr;
        }
    }

    if (FAILED(hr = m_ViewPtr->SetViewport(
        lprcBounds->left,
        lprcBounds->top,
        lprcBounds->right - lprcBounds->left,
        lprcBounds->bottom - lprcBounds->top)))
    {
        return hr;
    }

    //
    // From the HDC, get the clip rect (should be region) in
    // DC coords and convert to Device coords
    //
    RECT rcClip;  // in dc coords
    GetClipBox(hdcDraw, &rcClip);

    LPtoDP(hdcDraw, (POINT *) &rcClip, 2);

    if (FAILED(hr = m_ViewPtr->SetClipRect(
        rcClip.left,
        rcClip.top,
        rcClip.right - rcClip.left,
        rcClip.bottom - rcClip.top)))
    {
        return hr;
    }

    if (FAILED(hr = m_ViewPtr->RePaint(
        rcClip.left,
        rcClip.top,
        rcClip.right - rcClip.left,
        rcClip.bottom - rcClip.top)))
    {
        return hr;
    }

    if (!m_fStarted)
    {
        // Wait until the data is loaded
        if (m_fWaitForImportsComplete)
        {
            m_clocker.Start();
        }
        // OnTimer will poll DA and set m_fWaitForImportsComplete to false 
        // when the imports are complete
        if (!m_fWaitForImportsComplete)
            StartModel();
    }

    if (m_fStarted)
    {
        // Finally,  render into the DC (or DirectDraw Surface)...
        hr = m_ViewPtr->Render();
    }

    if (DDrawSurfPtr)
    {
        if (FAILED(hr = m_ViewPtr->put_IDirectDrawSurface(NULL)))
        {
            return hr;
        }
    }

    return hr;
}

/*==========================================================================*/

DWORD CSpriteCtl::GetCurrTimeInMillis()
{
    return timeGetTime();
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::InvalidateControl(LPCRECT pRect, BOOL fErase)
{
    if (m_fStarted)
    {
        RECT rectPaint;

        if (pRect)
            rectPaint = *pRect;
        else
            rectPaint = m_rcBounds;
    }

    if (NULL != m_poipsw) // Make sure we have a site - don't crash IE 3.0
    {
        if (m_fControlIsActive)
            m_poipsw->InvalidateRect(pRect, fErase);
        else
            m_fInvalidateWhenActivated = TRUE;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT CSpriteCtl::UpdateImage(IDAImage *pImage)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = InitializeObjects()))
        return hr;

    if (m_PlayImagePtr)
    {
        CComPtr<IDAImage> ImagePtr = pImage;

        if (ImagePtr)
          {
              CComPtr<IDAImage> TransformedImagePtr;
              CComPtr<IDABbox2> pBox;
              CComPtr<IDAPoint2> pMin, pMax;
              CComPtr<IDANumber> pLeft, pTop, pRight, pBottom;
              CComPtr<IDANumber> framesAcross, framesDown;
              CComPtr<IDANumber> two;
              CComPtr<IDANumber> imwHalf, imhHalf;
              CComPtr<IDANumber> fmwHalf, fmhHalf;
              CComPtr<IDANumber> negFmwHalf, negFmhHalf;

              m_imageWidth = NULL;
              m_imageHeight = NULL;
              m_frameWidth = NULL;
              m_frameHeight = NULL;
              m_initTransX = NULL;
              m_initTransY = NULL;
              m_minCrop = NULL;
              m_maxCrop = NULL;
              
              // Calculate the width and height of the frame as
              // behaviors. 
              if (SUCCEEDED(hr = ImagePtr->get_BoundingBox(&pBox)) &&
                  // Get the left, top, right, bottom of the bounding box
                  SUCCEEDED(hr = pBox->get_Min(&pMin)) &&
                  SUCCEEDED(hr = pBox->get_Max(&pMax)) &&
                  SUCCEEDED(hr = pMin->get_X(&pLeft)) &&
                  SUCCEEDED(hr = pMin->get_Y(&pTop)) &&
                  SUCCEEDED(hr = pMax->get_X(&pRight)) &&
                  SUCCEEDED(hr = pMax->get_Y(&pBottom)) &&
                  // Convert m_iNumFramesAcross and m_iNumFramesDown to IDANumbers
                  SUCCEEDED(hr = m_StaticsPtr->DANumber(m_iNumFramesAcross, &framesAcross)) &&
                  SUCCEEDED(hr = m_StaticsPtr->DANumber(m_iNumFramesDown, &framesDown)) &&
                  // Get the image width (right-left) and height (bottom-top)
                  SUCCEEDED(hr = m_StaticsPtr->Sub(pRight, pLeft, &m_imageWidth)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Sub(pBottom, pTop, &m_imageHeight)) &&
                  // Get the frame width and height
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_imageWidth, framesAcross, &m_frameWidth)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_imageHeight, framesDown, &m_frameHeight)) &&

                  // Prepare values that will be used in GenerateFrameImage.
                  
                  // m_initTransX = m_imageWidth/2 - m_frameWidth/2
                  // m_initTransY = m_frameHeight/2 - m_imageHeight/2
                  SUCCEEDED(hr = m_StaticsPtr->DANumber(2, &two)) &&
                  // imwHalf = m_imageWidth/2 and fmwHalf = m_frameWidth/2
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_imageWidth, two, &imwHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_frameWidth, two, &fmwHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Sub(imwHalf, fmwHalf, &m_initTransX)) &&
                  // imhHalf = m_imageHeight/2 and fmhHalf = m_frameHeight/2
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_imageHeight, two, &imhHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_frameHeight, two, &fmhHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Sub(fmhHalf, imhHalf, &m_initTransY)) &&

                  // maxCrop = point2(frameWidth/2, frameHeight/2)
                  // minCrop = point2(-frameWidth/2, -frameHeight/2)
                  SUCCEEDED(hr = m_StaticsPtr->Point2Anim(fmwHalf, fmhHalf, &m_maxCrop)) &&
                  // Create -frameWidth/2 and -frameHeight/2
                  SUCCEEDED(hr = m_StaticsPtr->Neg(fmwHalf, &negFmwHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Neg(fmhHalf, &negFmhHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Point2Anim(negFmwHalf, negFmhHalf, &m_minCrop)))
                {
                }
              else
                {
                    return hr;
                }

            // Keep track of the current image...
            m_ImagePtr = ImagePtr;

            // Now build up the playable behavior from the
            // list of transform numbers...
            if (FAILED(hr = BuildPlayImage()))
                return hr;
        }
        else
        {
            // Get rid of previous image...
            m_ImagePtr = NULL;

            if (FAILED(hr = m_StaticsPtr->get_EmptyImage(&ImagePtr)))
                return hr;

            // Switch in the current image...
            hr = m_PlayImagePtr->SwitchTo(ImagePtr);
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::GenerateFrameImage(int iFrameIndex, IDAImage *pImage, IDAImage **ppFrameImage)
{
    HRESULT hr = S_OK;

    if (!pImage || !ppFrameImage)
        return E_POINTER;

    if ((iFrameIndex < 0) || (iFrameIndex > (int)m_iNumFrames))
      {
          hr = E_FAIL;
      }
    else
      {
          // Note: The following values have already been calculated in UpdateImage
          // m_initTransX = m_imageWidth/2 - m_frameWidth/2
          // m_initTransY = m_frameHeight/2 - m_imageHeight/2
          // maxCrop = point2(frameWidth/2, frameHeight/2)
          // minCrop = point2(-frameWidth/2, -frameHeight/2)
          CComPtr<IDATransform2> TransformPtr;

          int iFrameX = (iFrameIndex % m_iNumFramesAcross);
          int iFrameY = (iFrameIndex / m_iNumFramesAcross);

          // Find the translation points
          // transX = m_initTransX - frameWidth * iFrameX
          // transY = m_initTransY + frameHeight * iFrameY
        
          CComPtr<IDANumber> transX, transY;
          CComPtr<IDANumber> xOffsetBvr, yOffsetBvr;
          CComPtr<IDANumber> iFrameXBvr, iFrameYBvr;
          CComPtr<IDAImage> TransformedImagePtr;
          CComPtr<IDAImage> CroppedImagePtr;
        
          if (SUCCEEDED(hr = m_StaticsPtr->DANumber(iFrameX, &iFrameXBvr)) &&
              SUCCEEDED(hr = m_StaticsPtr->DANumber(iFrameY, &iFrameYBvr)) &&
              SUCCEEDED(hr = m_StaticsPtr->Mul(m_frameWidth, iFrameXBvr, &xOffsetBvr)) &&
              SUCCEEDED(hr = m_StaticsPtr->Mul(m_frameHeight, iFrameYBvr, &yOffsetBvr)) &&
              SUCCEEDED(hr = m_StaticsPtr->Sub(m_initTransX, xOffsetBvr, &transX)) &&
              SUCCEEDED(hr = m_StaticsPtr->Add(m_initTransY, yOffsetBvr, &transY)) &&

              // Build a translation by these points
              SUCCEEDED(hr = m_StaticsPtr->Translate2Anim(transX, transY, &TransformPtr)) &&
            
              SUCCEEDED(hr = pImage->Transform(TransformPtr, &TransformedImagePtr)) &&
              SUCCEEDED(hr = TransformedImagePtr->Crop(m_minCrop, m_maxCrop, &CroppedImagePtr)))
            {
                CroppedImagePtr.p->AddRef();
                *ppFrameImage = CroppedImagePtr.p;
            }
      }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::BuildPlayImage(void)
{
        HRESULT hr = S_OK;

        if (FAILED(hr = InitializeObjects()))
        {
                return hr;
        }
        else if (m_iNumFrames > 0)
        {
        // Make sure the user doesn't do something bad.  Makes one wonder
        // why we even need a NumFrames property
        if (m_iNumFrames > (m_iNumFramesDown * m_iNumFramesAcross))
            m_iNumFrames = m_iNumFramesDown * m_iNumFramesAcross;

                int iFrameIndex = 0;
                BOOL fUseFrameMap = (m_drgFrameMaps.Count() > 0); 
                m_iFrameCount = (fUseFrameMap ? m_drgFrameMaps.Count() : (int)m_iNumFrames);

                // Create the array of behaviors
                if (m_pArrayBvr != NULL)
                {
                        Delete [] m_pArrayBvr;
                        m_pArrayBvr = NULL;
                }
                m_pArrayBvr = New CComPtr<IDABehavior>[m_iFrameCount];

                // Create the array of frame durations
                if (m_durations != NULL)
                {
                        Delete [] m_durations;
                        m_durations = NULL;
                }
                m_durations = New double[m_iFrameCount];
                
                // Build an image behavior for each frame
                for(iFrameIndex=0, m_dblDuration=0;iFrameIndex<m_iFrameCount;iFrameIndex++)
                {
                        CComPtr<IDABehavior> BehaviorPtr1;
                        CComPtr<IDAImage> ImagePtr;

                        // Get the frame image
                        int iFrameImage = fUseFrameMap ? (m_drgFrameMaps[iFrameIndex]->m_iImg - 1) : iFrameIndex;
                        if (FAILED(hr = GenerateFrameImage(iFrameImage, m_ImagePtr, &ImagePtr)))
                                return hr;

                        // Set the duration of each frame
                        double dblDuration = fUseFrameMap ? (m_drgFrameMaps[iFrameIndex]->m_dblDuration / m_dblPlayRate) : m_dblTimerInterval;

            m_dblDuration += dblDuration;

                        // Add the behavior to the behavior list
                        m_pArrayBvr[iFrameIndex] = ImagePtr;
                        m_durations[iFrameIndex] = dblDuration;
                }
        }

        return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::LoadImage(BSTR bstrURL, IDAImage **ppImage)
{
    HRESULT hr = S_OK;
    CComPtr<IDAImage> ImagePtr;

    HANDLENULLPOINTER(ppImage);
    
    *ppImage = NULL;

    // Return S_FALSE if there is no URL.  This will allow us to determine
    // if we actually loaded an image or not, without causing failure

    if (NULL == bstrURL)
        return S_FALSE;

    if (!m_fUseColorKey)
        hr = m_StaticsPtr->ImportImage(bstrURL, &ImagePtr);
    else
        hr = m_StaticsPtr->ImportImageColorKey(bstrURL, (BYTE)m_byteColorKeyR, (BYTE)m_byteColorKeyG, (BYTE)m_byteColorKeyB, &ImagePtr);

    if (SUCCEEDED(hr))
    {
        ImagePtr.p->AddRef();
        *ppImage = ImagePtr.p;
        m_fWaitForImportsComplete = false;
        m_clocker.Start();
    }

    return hr;
}

/*==========================================================================*/

BOOL CSpriteCtl::StartModel(void)
{
    BOOL fResult = FALSE;

    if (!m_fStarted)
    {
        CComPtr<IDASound> SoundPtr;
        CComPtr<IDAImage> ImagePtr;

        if (FAILED(m_ViewPtr->put_ClientSite(m_pocs)))
            return FALSE;

        if (FAILED(m_StaticsPtr->get_Silence(&SoundPtr)))
            return FALSE;

        if (FAILED(InitializeObjects()))
            return FALSE;

        if (FAILED(m_ViewPtr->StartModel(m_PlayImagePtr, SoundPtr, GetCurrTime())))
            return FALSE;

        m_fStarted = TRUE;

        fResult = TRUE;

        if (Playing == m_enumPlayState && m_FinalBehaviorPtr != NULL)
                {
                        // If playing start the timer (to avoid delay between da and iham)
                        // Calculate the base time and kick off the timer
                        m_dblCurrentTick = GetCurrTime();
                        m_dblBaseTime = m_dblCurrentTick - GetTimeFromFrame(m_iFrame);
                        m_dblPreviousTime = 0;
                        m_clocker.Start();

            // Switch to the sequenced behaviour
                        m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                        // Fire any starting frame Callouts
                        FireFrameMarker(m_iStartingFrame);
                }
                else
                {
                        // Cause the tick (to update any initial frames)
                        OnTimer((DWORD)GetCurrTime()*1000);
                }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CSpriteCtl::StopModel(void)
{
    // Stop the play if necessary...
    Stop();

    // Stop any currently running model...
    if (m_fStarted)
    {
        BOOL fResult = SUCCEEDED(m_ViewPtr->StopModel());

        if (!fResult)
            return fResult;

        m_fStarted = FALSE;
    }

    return TRUE;
}

/*==========================================================================*/

BOOL CSpriteCtl::ReStartModel(void)
{
    BOOL fResult = FALSE;

    // Stop the running model so that it will restart for the
    // next paint...
    StopModel();

    InvalidateControl(NULL, TRUE);

    return fResult;
}

/*==========================================================================*/

HRESULT CSpriteCtl::InitializeObjects(void)
{
    HRESULT hr = S_OK;

    if (!m_PlayImagePtr)
    {
        CComPtr<IDAImage> ImagePtr;

        if (FAILED(hr = m_StaticsPtr->get_EmptyImage(&ImagePtr)))
            return hr;

        if (FAILED(hr = m_StaticsPtr->ModifiableBehavior(ImagePtr, (IDABehavior **)&m_PlayImagePtr)))
            return hr;
    }

    return hr;
}

/*==========================================================================*/

void CSpriteCtl::OnTimer(DWORD dwTime)
{
    VARIANT_BOOL vBool;

    //determine if the mouse is still in the area
    if (m_fMouseInArea)
    {
        POINT p;
        HWND CurWnd = 0, ParentWnd = 0;
    
        if (m_hwndParent == 0)  //if the parenthWnd has not been set, then grab the
        {                       //topmost window of the container object.
            HRESULT hr = S_OK;
            IOleWindow *poleWindow = NULL;
            IOleClientSite *pClientSite = NULL;

            if (m_ViewPtr)
            {
                hr = m_ViewPtr->get_ClientSite(&pClientSite);
            }

            hr = pClientSite->QueryInterface(IID_IOleWindow, reinterpret_cast<void**>(&poleWindow));
            pClientSite->Release();

            if (FAILED(hr))
            {
                return;
            }
            if (NULL == poleWindow)
            {
                return;
            }

            // Get HWND of OLE Container
            hr = poleWindow->GetWindow(&ParentWnd);
            poleWindow->Release();
            
            if (FAILED(hr))
            {
                return;
            }
            if (NULL == ParentWnd)
            {
                return;
            }

            while (ParentWnd) //get the topmost hwnd
            {
                m_hwndParent = ParentWnd;
                ParentWnd = GetParent(ParentWnd);
            }
        }

        GetCursorPos(&p);
  
        ParentWnd = WindowFromPoint(p);
        while (ParentWnd)
        {
            CurWnd = ParentWnd;
            ParentWnd = GetParent(CurWnd);
        }
        if (CurWnd != m_hwndParent)
        {
            DEBUGLOG("Mouse out\r\n");
            m_fMouseInArea = FALSE;
            FIRE_MOUSELEAVE(m_pconpt);
        }
    }
    if (m_fWaitForImportsComplete)
    {
        // Check if all data has been loaded
        VARIANT_BOOL bComplete;
        if (FAILED(m_StaticsPtr->get_AreBlockingImportsComplete(&bComplete)))
            return;
        if (!bComplete) // Still importing...
            return;

        // All data has been loaded; hence start animation
        m_fWaitForImportsComplete = false;
        m_clocker.Stop();

        // Fire the media loaded event only if everything goes welll and m_ImagePtr is valid
            if (m_ImagePtr != NULL)
                    FIRE_ONMEDIALOADED(m_pconpt, m_bstrSourceURL);

        // Invalidate the control; this will cause a :Draw and should StartModel()
        InvalidateControl(NULL, TRUE);
        return;
    }

    if (m_fStarted)
    {
        m_dblCurrentTick = dwTime / 1000.0;
    
        if (SUCCEEDED(m_ViewPtr->Tick(m_dblCurrentTick, &vBool)))
        {
            // Let the regular rendering path take care of this...
            if (vBool)
                InvalidateControl(NULL, TRUE);
        }

        if (Playing != m_enumPlayState)
            return;

        // Find the current time
        double time = m_dblCurrentTick - m_dblBaseTime;

        // Fire any time markers
        FireTimeMarker(time);

        if (m_iCurCycle * m_dblDuration <= time)
        // End of one cycle; see if we need to continue or stop
        {
            if (m_iRepeat < 0 || m_iRepeat > m_iCurCycle)
            {
                // Increment the current cycle
                m_iCurCycle++;

                // Restart the cycle
                ASSERT(m_FinalBehaviorPtr != NULL); 

                if (m_iStartingFrame == 0 && !m_fFireAbsoluteFrameMarker)
                {
                                        m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                                        // Fire any starting frame Callouts
                                        FireFrameMarker(m_iStartingFrame);
                }
                else    // Pause and resume; hence restart the sequence
                                {
                                        if (FAILED(SequenceFrames(m_iCurCycle*m_iFrameCount))) 
                        return;

                                        // Switch to the sequenced behaviour
                                        m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                                        // Fire any starting frame Callouts
                                        FireFrameMarker(m_iStartingFrame);
                                }
            }
            else    // We are done with the cycles
            {
                    // Stop if we are done...
                    Stop();
            }
        }
    }
}

/*==========================================================================*/

#ifdef SUPPORTONLOAD
void CSpriteCtl::OnWindowLoad (void) 
{
    m_fOnWindowLoadFired = TRUE;
    
    // Asserting to ensure that we are being constructed from scratch every time
    ASSERT(m_fOnWindowUnloadFired == false);
    m_fOnWindowUnloadFired = false;

    if (m_fAutoStart)
    {
        Play();
    }
    else
    {
        if (m_iInitialFrame >= -1)
        {
            // Show the initial sprite image
            ShowImage(m_iInitialFrame);
        }
    }
}

/*==========================================================================*/

void CSpriteCtl::OnWindowUnload (void) 
{ 
    m_fOnWindowUnloadFired = true;
    m_fOnWindowLoadFired = FALSE;
    StopModel();
}

/*==========================================================================*/

#endif //SUPPORTONLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\controls\sgrfx\sgrfx.cpp ===
/*==========================================================================*\

    Module:
        sgrfx.cpp

    Author:
        IHammer Team (SimonB)

    Created:
        June 1997

    Description:
        Implements any control-specific members, as well as the control's interface

    History:
        06-01-1997  Created

\*==========================================================================*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "sgrfx.h"
#include "sgevent.h"
#include "ddrawex.h"
#include <htmlfilter.h>
#include "urlmon.h"

#ifdef DEADCODE
/*==========================================================================*/
//
// The is a callback that will inform us if the mouse is inside or outside
// of the image
//
/*==========================================================================*/

extern ControlInfo     g_ctlinfoSG;

CPickCallback::CPickCallback(
    IConnectionPointHelper* pconpt,
    IDAStatics* pstatics,
    IDAImage* pimage,
    boolean& fOnWindowLoadFired,
    HRESULT& hr
) :
    m_pstatics(pstatics),
    m_pimage(pimage),
    m_pconpt(pconpt),
    m_fOnWindowLoadFired(fOnWindowLoadFired),
    m_cRef(1),
    m_bInside(false)
{
    ::InterlockedIncrement((long *)&(g_ctlinfoSG.pcLock));

    CComPtr<IDAPickableResult> ppickResult;

    if (FAILED(hr = m_pimage->Pickable(&ppickResult))) return;
    if (FAILED(hr = ppickResult->get_Image(&m_pimagePick))) return;
    if (FAILED(hr = ppickResult->get_PickEvent(&m_peventEnter))) return;
    if (FAILED(hr = m_pstatics->NotEvent(m_peventEnter, &m_peventLeave))) return;
}

CPickCallback::~CPickCallback()
{
    ::InterlockedDecrement((long *)&(g_ctlinfoSG.pcLock));
}

HRESULT CPickCallback::GetImage(IDABehavior** ppimage)
{
    CComPtr<IDAEvent> pevent;

    if (m_bInside) {
        pevent = m_peventLeave;
    } else {
        pevent = m_peventEnter;
    }

    return m_pstatics->UntilNotify(m_pimagePick, pevent, this, ppimage);
}

HRESULT STDMETHODCALLTYPE CPickCallback::Notify(
        IDABehavior __RPC_FAR *eventData,
        IDABehavior __RPC_FAR *curRunningBvr,
        IDAView __RPC_FAR *curView,
        IDABehavior __RPC_FAR *__RPC_FAR *ppBvr)
{
    if (m_bInside) {
        m_bInside = false;
        if (m_fOnWindowLoadFired) {
            m_pconpt->FireEvent(DISPID_SG_EVENT_MOUSELEAVE, 0);
        }
    } else {
        m_bInside = true;
        if (m_fOnWindowLoadFired) {
            m_pconpt->FireEvent(DISPID_SG_EVENT_MOUSEENTER, 0);
        }
    }

    return GetImage(ppBvr);
}

/*==========================================================================*/

///// IUnknown
HRESULT STDMETHODCALLTYPE CPickCallback::QueryInterface(
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (NULL == ppvObject)
        return E_POINTER;

    HRESULT hr = E_NOINTERFACE;

    *ppvObject = NULL;

    if (IsEqualGUID(riid, IID_IDAUntilNotifier))
    {
        IDAUntilNotifier *pThis = this;

        *ppvObject = (LPVOID) pThis;
        AddRef(); // Since we only provide one interface, we can just AddRef here

        hr = S_OK;
    }

    return hr;
}

/*==========================================================================*/

ULONG STDMETHODCALLTYPE CPickCallback::AddRef(void)
{
    return ::InterlockedIncrement((LONG *)(&m_cRef));
}

/*==========================================================================*/

ULONG STDMETHODCALLTYPE CPickCallback::Release(void)
{
    ::InterlockedDecrement((LONG *)(&m_cRef));
    if (m_cRef == 0)
    {
        Delete this;
        return 0;
    }

    return m_cRef;
}
#endif // DEADCODE

/*==========================================================================*/
//
// CSGrfx Creation/Destruction
//

LPUNKNOWN __stdcall AllocSGControl(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr;
    CSGrfx *pthis = New CSGrfx(punkOuter, &hr);

    if (pthis == NULL)
        return NULL;

    if (FAILED(hr))
    {
        delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

/*==========================================================================*/
//
// Beginning of class implementation
//

CSGrfx::CSGrfx(IUnknown *punkOuter, HRESULT *phr):
    CMyIHBaseCtl(punkOuter, phr),
    m_fOnWindowLoadFired(false)
{
    // Initialise members
    m_pwszSourceURL = NULL;
    m_CoordSystem = LeftHanded;
    m_fMouseEventsEnabled = FALSE;
    m_iExtentTop = 0;
    m_iExtentLeft = 0;
    m_iExtentWidth = 0;
    m_iExtentHeight = 0;
    m_fHighQuality = FALSE;
    m_fStarted = FALSE;
    m_fHQStarted = FALSE;
    m_fPersistExtents = FALSE;
    m_fIgnoreExtentWH = TRUE;
    m_fMustSetExtent = FALSE;
    m_fSetExtentsInSetIdentity = FALSE;
    m_fUpdateDrawingSurface = TRUE;
    m_fShowTiming = FALSE;
    m_fPreserveAspectRatio = TRUE;
    m_fRectsSetOnce = false;
    m_fNeedOnTimer = false;
    m_fInside = FALSE;
    m_fExtentTopSet = false; 
    m_fExtentLeftSet = false; 
    m_fExtentWidthSet = false; 
    m_fExtentHeightSet = false;

    ZeroMemory(&m_rcLastRectScaled, sizeof(m_rcLastRectScaled));

 // Tie into the DANIM DLL now...
    if (phr)
    {
        if (SUCCEEDED(*phr))
        {
            *phr = CoCreateInstance(
                CLSID_DAView,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAView,
                (void **) &m_ViewPtr);

            if (SUCCEEDED(*phr))
            {
#ifdef DEADCODE
                //
                // move the mouse completely outside of the window
                //

                m_ViewPtr->OnMouseMove(
                    0,
                    -1000000,
                    -1000000,
                    0
                );
#endif // DEADCODE

                // turn off Bitmap caching for SG controls, since trident changes the bitmap depth

                IDAPreferences *pPref = NULL;
                VARIANT vOptVal;

                VariantInit (&vOptVal);

                // from danim\src\appel\privinc\opt.h & appel\privinc\privpref.cpp

                BSTR bstr = SysAllocString(L"BitmapCachingOptimization");

                vOptVal.boolVal = VARIANT_FALSE;

                *phr = m_ViewPtr->get_Preferences(&pPref);

                if (SUCCEEDED(*phr))
                {
                    pPref->PutPreference(bstr, vOptVal);
                    pPref->Propagate();
                    pPref->Release();
                    pPref = NULL;
                }
                
                *phr = CoCreateInstance(
                    CLSID_DAView,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IDAView,
                    (void **)&m_HQViewPtr);

                if (SUCCEEDED(*phr)) {
                    *phr = m_HQViewPtr->get_Preferences(&pPref);

                    if (SUCCEEDED(*phr))
                    {
                        pPref->PutPreference(bstr, vOptVal);
                        pPref->Propagate();
                        pPref->Release();
                        pPref = NULL;
                    }
                }
                SysFreeString( bstr );

            }
        }

        if (SUCCEEDED(*phr))
        {
            *phr = ::CoCreateInstance(
                CLSID_DAStatics,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAStatics,
                (void **) &m_StaticsPtr);
        }

        if (SUCCEEDED(*phr))
        {
            VARIANT_BOOL vBool = VARIANT_TRUE;

            *phr = m_StaticsPtr->put_PixelConstructionMode(vBool);

            if (SUCCEEDED(*phr))
                *phr = m_StaticsPtr->NewDrawingSurface(&m_DrawingSurfacePtr);
        }

        if (SUCCEEDED(*phr))
        {   m_CachedRotateTransformPtr = NULL;
            m_CachedScaleTransformPtr = NULL;
            m_CachedTranslateTransformPtr = NULL;

            if (SUCCEEDED(*phr = m_StaticsPtr->DANumber(0, &m_zero)) &&
                SUCCEEDED(*phr = m_StaticsPtr->DANumber(1, &m_one)) &&
                SUCCEEDED(*phr = m_StaticsPtr->DANumber(-1, &m_negOne)) &&
                SUCCEEDED(*phr = m_StaticsPtr->get_XVector3(&m_xVector3)) &&
                SUCCEEDED(*phr = m_StaticsPtr->get_YVector3(&m_yVector3)) &&
                SUCCEEDED(*phr = m_StaticsPtr->get_ZVector3(&m_zVector3)) &&
                SUCCEEDED(*phr = m_StaticsPtr->get_IdentityTransform2(&m_identityXform2)) &&
                SUCCEEDED(*phr = m_StaticsPtr->Scale2Anim(m_one, m_negOne, &m_yFlipXform2)))
            {
                // All happy here...
            }

            m_clocker.SetSink((CClockerSink *)this);
        }
    }
}

/*==========================================================================*/

CSGrfx::~CSGrfx()
{
    StopModel();

    if (m_pwszSourceURL)
    {
        Delete [] m_pwszSourceURL;
        m_pwszSourceURL = NULL;
    }
    FreeHQBitmap();
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr = S_OK;
    BOOL fMustAddRef = FALSE;

    if (ppv)
        *ppv = NULL;
    else
        return E_POINTER;

#ifdef _DEBUG
    char ach[200];
    TRACE("SGrfx::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if ((IsEqualIID(riid, IID_ISGrfxCtl)) || (IsEqualIID(riid, IID_IDispatch)))
    {
        if (NULL == m_pTypeInfo)
        {
            HRESULT hr;

            // Load the typelib
            hr = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_ISGrfxCtl, LIBID_DAExpressLib, NULL);

            if (FAILED(hr))
            {
                m_pTypeInfo = NULL;
            }
            else
                *ppv = (ISGrfxCtl *) this;

        }
        else
            *ppv = (ISGrfxCtl *) this;

    }
    else // Call into the base class
    {
        DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);
    }

    if (NULL != *ppv)
    {
        DEBUGLOG("CSGrfx: Interface supported in control class\n");
        ((IUnknown *) *ppv)->AddRef();
    }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    double dblScaleX = 1.0f, dblScaleY = 1.0f;
    bool fIgnoreScale = false;
    RECT rectOld = m_rcBounds;

    if (m_fSetExtentsInSetIdentity)
    {
        if (m_fRectsSetOnce)
        {
            // If we are going to have to scale to 0 in any dimension, we don't want to do it
            fIgnoreScale = ( (1 > (lprcPosRect->right - lprcPosRect->left)) || (1 > (lprcPosRect->bottom - lprcPosRect->top)) );
        }
        else
        {
            // Initialise the first time through ...
            m_rcLastRectScaled = *lprcPosRect;
        }
    }

    HRESULT hRes = CMyIHBaseCtl::SetObjectRects(lprcPosRect, lprcClipRect);

    if (SUCCEEDED(hRes))
    {
        if (!EqualRect(&rectOld, &m_rcBounds))
        {
            // We have to let go of the bitmap at this point...
            FreeHQBitmap();
        }

        if (m_fMustSetExtent)
        {
            m_fMustSetExtent = FALSE; // Make sure we don't set extents again
            if (!m_fDesignMode)
                SetIdentity();
        }

        // Scale when the rect changes, if necessary
        if (m_fSetExtentsInSetIdentity && m_fRectsSetOnce)
        {
            if (!fIgnoreScale)
            {
                dblScaleX = ((double)(lprcPosRect->right - lprcPosRect->left) / (double)(m_rcLastRectScaled.right - m_rcLastRectScaled.left));
                dblScaleY = ((double)(lprcPosRect->bottom - lprcPosRect->top) / (double)(m_rcLastRectScaled.bottom - m_rcLastRectScaled.top));

                if (dblScaleX > 0.0f && dblScaleY > 0.0f)
                {
                    VARIANT vaEmpty;

                    vaEmpty.vt = VT_ERROR;
                    vaEmpty.scode = DISP_E_PARAMNOTFOUND;

                    Scale(dblScaleX, dblScaleY, 1.0f, vaEmpty);

                    m_rcLastRectScaled = *lprcPosRect;
                }
            }
        }

        m_fRectsSetOnce = true;
    }

    return hRes;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::QueryHitPoint(
    DWORD dwAspect,
    LPCRECT prcBounds,
    POINT ptLoc,
    LONG lCloseHint,
    DWORD* pHitResult)
{
    HRESULT hr = E_POINTER;

    if (pHitResult)
    {
        if ((!m_fDesignMode) && (NULL != prcBounds))
        {
            *pHitResult = HITRESULT_OUTSIDE;

            switch (dwAspect)
            {
                case DVASPECT_CONTENT:
                    // Intentional fall-through

                case DVASPECT_TRANSPARENT:
                {
                    if (FAILED(m_ViewPtr->QueryHitPoint(
                        dwAspect,
                        prcBounds,
                        ptLoc,
                        lCloseHint,
                        pHitResult)))
                    {
                        *pHitResult = HITRESULT_OUTSIDE;
                    }
                    hr = S_OK;
                }
                break;

                default:
                    hr = E_FAIL;
                break;
            }
        }
        else if (m_fDesignMode)
        {
            *pHitResult = HITRESULT_HIT;
            hr = S_OK;
        }
        else
        {
            hr = E_POINTER;
        }
    }

    return hr;
}

/*==========================================================================*/

BOOL CSGrfx::InsideImage(POINT ptXY)
{
    BOOL fResult = FALSE;
    DWORD dwHitResult = HITRESULT_OUTSIDE;
    RECT rectBounds = m_rcBounds;

    (void)m_ViewPtr->QueryHitPoint(DVASPECT_TRANSPARENT, &rectBounds, ptXY, 0, &dwHitResult);

    if (dwHitResult != HITRESULT_OUTSIDE)
        fResult = TRUE;

    return fResult;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = S_FALSE;

    if (m_fMouseEventsEnabled)
    {
        POINT ptXY;
        long lKeyState = 0;
        BOOL fInside = m_fInside;

#ifndef WM_MOUSEHOVER
#define WM_MOUSEHOVER 0x02a1
#endif
#ifndef WM_MOUSELEAVE
#define WM_MOUSELEAVE 0x02a3
#endif
        if (msg >= WM_MOUSEFIRST && msg <= WM_MOUSELAST)
        {
            // Note that this is only valid for WM_MOUSEXXXX messages.
            ptXY.x = LOWORD(lParam);
            ptXY.y = HIWORD(lParam);

            // Get the Keystate set up
            if (wParam & MK_CONTROL)
                lKeyState += KEYSTATE_CTRL;

            if (wParam & MK_SHIFT)
                lKeyState += KEYSTATE_SHIFT;

            if (GetAsyncKeyState(VK_MENU))
                lKeyState += KEYSTATE_ALT;

            m_fInside = InsideImage(ptXY);
        }

        switch (msg)
        {
            case WM_MOUSELEAVE:
                m_fInside = FALSE;
                hr = S_OK;
            break;

            case WM_MOUSEMOVE:
            {
                // Need to get button state...
                long iButton=0;

                if (wParam & MK_LBUTTON)
                    iButton += MOUSEBUTTON_LEFT;

                if (wParam & MK_MBUTTON)
                    iButton += MOUSEBUTTON_MIDDLE;

                if (wParam & MK_RBUTTON)
                    iButton += MOUSEBUTTON_RIGHT;

                FIRE_MOUSEMOVE(m_pconpt, iButton, lKeyState, LOWORD(lParam), HIWORD(lParam));
                hr = S_OK;
            }
            break;

            case WM_RBUTTONDOWN:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_RIGHT, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_MBUTTONDOWN:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_MIDDLE, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_LBUTTONDOWN:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_LEFT, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_RBUTTONUP:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_RIGHT, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_MBUTTONUP:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_MIDDLE, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_LBUTTONUP:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_LEFT, lKeyState, LOWORD(lParam), HIWORD(lParam));
                    FIRE_CLICK(m_pconpt);
                }
                hr = S_OK;
            }
            break;

            case WM_LBUTTONDBLCLK:
            {
                if (m_fInside)
                {
                    FIRE_DBLCLICK(m_pconpt);
                }
                hr = S_OK;
            }
            break;
        }

        if (fInside != m_fInside)
        {
            if (m_fOnWindowLoadFired)
            {
                if (m_fInside)
                {
                    m_pconpt->FireEvent(DISPID_SG_EVENT_MOUSEENTER, 0);
                }
                else
                {
                    m_pconpt->FireEvent(DISPID_SG_EVENT_MOUSELEAVE, 0);
                }
            }
        }
    }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    BSTR bstrSourceURL = NULL;

    BOOL fIsLoading = (S_OK == pvio->IsLoading());

    // Are we saving ?  If so, convert to BSTR
    if (!fIsLoading)
    {
        bstrSourceURL = SysAllocString(m_pwszSourceURL);
    }

    // load or save control properties
    if (FAILED(hr = pvio->Persist(0,
            "SourceURL", VT_BSTR, &bstrSourceURL,
            "CoordinateSystem", VT_I4, &m_CoordSystem,
            "MouseEventsEnabled", VT_BOOL, &m_fMouseEventsEnabled,
            "HighQuality", VT_BOOL, &m_fHighQuality,
            "PreserveAspectRatio", VT_BOOL, &m_fPreserveAspectRatio,
            NULL)))
        return hr;

    // Did we load ?
    if (fIsLoading)
    {
        HRESULT hResWidth = S_FALSE;
        HRESULT hResHeight = S_FALSE;

        // Wipe any previous data...
        m_cparser.Cleanup();

        hResWidth = pvio->Persist(0,
                "ExtentWidth", VT_I4, &m_iExtentWidth,
                NULL);

        hResHeight = pvio->Persist(0,
            "ExtentHeight", VT_I4, &m_iExtentHeight,
            NULL);

        hr = pvio->Persist(0,
            "ExtentTop", VT_I4, &m_iExtentTop,
            NULL);

        if (S_OK == hr)
        {
            hr = pvio->Persist(0,
                "ExtentLeft", VT_I4, &m_iExtentLeft,
                NULL);

            m_fPersistExtents = (SUCCEEDED(hr));
        }

        // Debugging helper...
        m_fShowTiming = FALSE;
        pvio->Persist(0, "ShowTiming", VT_BOOL, &m_fShowTiming, NULL);

        // Only set the extents if we read in both points, and they are valid
        // hRes MUST be successful, and hResWidth must equal hResHeight
        m_fMustSetExtent = ( (S_OK == hr) && (hResWidth == hResHeight) );
        m_fSetExtentsInSetIdentity = m_fMustSetExtent;

        m_fIgnoreExtentWH = ( (S_OK != hr) || (S_OK != hResWidth) || (S_OK != hResHeight) );

        // Invert for right-handed co-ordinate systems
        if ( (m_fMustSetExtent) && (m_CoordSystem == RightHanded) )
            m_iExtentHeight = -m_iExtentHeight;


#ifdef _DEBUG
        if (hResWidth != hResHeight)
            DEBUGLOG(TEXT("ExtentWidth and ExtentHeight both have to be specified, or not specified\n"));
#endif

        // Explictly disable drawing surface updates..
        m_fUpdateDrawingSurface = FALSE;

        // We loaded, so set the member variables to the appropriate values
        put_SourceURL(bstrSourceURL);

        // Explictly enable drawing surface updates..
        m_fUpdateDrawingSurface = TRUE;

        // Call the parser to instantiate the persisted primitives...
        m_cparser.LoadObjectInfo(pvio, NULL, NULL, FALSE);

        // Make sure to re-initialize the drawing state...
        InitializeSurface();

        // Finally, load the objects into our DrawingSurface...
        m_cparser.PlaybackObjectInfo(m_DrawingSurfacePtr, m_StaticsPtr, m_CoordSystem == LeftHanded);

        if (!m_fNeedOnTimer && m_cparser.AnimatesOverTime())
            m_fNeedOnTimer = TRUE;

        // Force the image to be updated...
        hr = UpdateImage(NULL, TRUE);

        // Make sure to set the proper identity matrix up...
        SetIdentity();
    }
    else
    {
        // Persist Top and Left if the loading code says we should, or if one was set through
        // properties.  It doesn't make sense to persist only one 
        if ( m_fPersistExtents || m_fExtentTopSet || m_fExtentLeftSet )
            hr = pvio->Persist(0,
                    "ExtentTop", VT_I4, &m_iExtentTop,
                    "ExtentLeft", VT_I4, &m_iExtentLeft,
                    NULL);

        // If the user didn't specify width and height, we take that to mean that
        // they want the defaults (ie the control's witdh and height as specified
        // by the container.  To preserve that, we don't i) change the value of
        // the member  variables unless the user sets them and ii) we don't persist
        // anything for those properties if they are set to 0

        // Also, if this is a design-time scenario and the user has set extents through the put_ methods,
        // they have to have set both width and height, as well as either of Top and Left.


        if (!m_fIgnoreExtentWH || ( (m_fExtentWidthSet && m_fExtentHeightSet) && (m_fExtentTopSet || m_fExtentLeftSet) ))
            hr = pvio->Persist(0,
                "ExtentWidth", VT_I4, &m_iExtentWidth,
                "ExtentHeight", VT_I4, &m_iExtentHeight,
                NULL);

        m_cparser.SaveObjectInfo( pvio );
    }

    // At this point, it's safe to free the BSTR
    if (bstrSourceURL)
        SysFreeString(bstrSourceURL);

    // if any properties changed, redraw the control
    if (SUCCEEDED(hr))
    {
        // If we are not active, we can't invalidate, so delay it if necessary
        if ( (m_fControlIsActive) && (m_poipsw != NULL) )
            m_poipsw->InvalidateRect(NULL, TRUE);
        else
            m_fInvalidateWhenActivated = TRUE;
    }
    // clear the dirty bit if requested
    if (dwFlags & PVIO_CLEARDIRTY)
        m_fDirty = FALSE;

    return S_OK;
}

/*==========================================================================*/
//
// IDispatch Implementation
//

STDMETHODIMP CSGrfx::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    *pptinfo = NULL;

    if(itinfo != 0)
        return ResultFromScode(DISP_E_BADINDEX);

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;

    return NOERROR;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr;

    hr = DispInvoke((ISGrfxCtl *)this,
        m_pTypeInfo,
        dispidMember, wFlags, pdispparams,
        pvarResult, pexcepinfo, puArgErr);

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = CMyIHBaseCtl::SetClientSite(pClientSite);

    if (m_ViewPtr)
    {
        m_ViewPtr->put_ClientSite(pClientSite);
    }
    m_clocker.SetHost(pClientSite);
    m_StaticsPtr->put_ClientSite(pClientSite);
    m_ViewPtr->put_ClientSite(pClientSite);

    if (!pClientSite)
        StopModel();

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
     DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
     LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
     BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue)
{
    int iSaveContext = 0;
    RECT rectBounds = m_rcBounds;
    RECT rcSavedBounds = m_rcBounds;
    BOOL fPainted = FALSE;
    DWORD dwTickStart = 0;
    double dblScaleX = 1.0f;
    double dblScaleY = 1.0f;
    boolean fScaled = false;

    if(hdcDraw==NULL)
      return E_INVALIDARG;

    if (m_fShowTiming)
        dwTickStart = GetTickCount();

    iSaveContext = ::SaveDC(hdcDraw);

    if (m_fHighQuality && !lprcBounds) 
    {
        // Make sure that everything is started properly...
        if (!m_fStarted)
        {
            RECT rectDummy;

            rectDummy.top=0;
            rectDummy.left=0;
            rectDummy.right=1;
            rectDummy.bottom=1;

            PaintToDC(hdcDraw, &rectDummy, FALSE);
        }

        // High-quality paint path...
        fPainted = PaintHQBitmap(hdcDraw);
    }

    if (!fPainted)
    {
        // Get scaling and bounds set up for the case where we are printing
        if (NULL != lprcBounds)
        {
            m_rcBounds.left = lprcBounds->left;
            m_rcBounds.top = lprcBounds->top;
            m_rcBounds.right = lprcBounds->right;
            m_rcBounds.bottom = lprcBounds->bottom;
            
            rectBounds = m_rcBounds;

            if (m_fMustSetExtent)
            {
                if (!m_fDesignMode)
                    SetIdentity();
            }
            else if (!m_fSetExtentsInSetIdentity)
            {
                // Scale to printer resolution
                HDC hScreenDC = ::GetDC(::GetDesktopWindow());
                int iHorzScreen = ::GetDeviceCaps(hScreenDC, LOGPIXELSX);
                int iVertScreen = ::GetDeviceCaps(hScreenDC, LOGPIXELSY);

                ::ReleaseDC(::GetDesktopWindow(), hScreenDC);

                int iHorzPrint = ::GetDeviceCaps(hdcDraw, LOGPIXELSX);
                int iVertPrint = ::GetDeviceCaps(hdcDraw, LOGPIXELSY);
                
                if (iHorzScreen && iVertScreen)
                {
                    dblScaleX = ((double)iHorzPrint / (double)iHorzScreen);
                    dblScaleY = ((double)iVertPrint / (double)iVertScreen);
               
                    if ((dblScaleX > 0) && (dblScaleY > 0))
                    {
                        VARIANT vaEmpty;

                        vaEmpty.vt = VT_ERROR;
                        vaEmpty.scode = DISP_E_PARAMNOTFOUND;

                        Scale(dblScaleX, dblScaleY, 1.0f, vaEmpty);
                        fScaled = true;
                    }
                }
            }
        }

        ::LPtoDP(hdcDraw, reinterpret_cast<LPPOINT>(&rectBounds), 2 );
        ::SetViewportOrgEx(hdcDraw, 0, 0, NULL);

        // Normal paint path...
        PaintToDC(hdcDraw, &rectBounds, FALSE);

        if (fScaled)
        {
            VARIANT vaEmpty;

            vaEmpty.vt = VT_ERROR;
            vaEmpty.scode = DISP_E_PARAMNOTFOUND;

            Scale(1 / dblScaleX, 1 / dblScaleY, 1.0f, vaEmpty);
        }

    }

    ::RestoreDC(hdcDraw, iSaveContext);

    if (m_fShowTiming)
    {
        DWORD dwTickEnd = 0;
        char rgchTicks[80];

        dwTickEnd = GetTickCount();

        wsprintf(rgchTicks, "Ticks : %ld", dwTickEnd - dwTickStart);

        TextOut(
            hdcDraw,
            m_rcBounds.left + 1, m_rcBounds.top + 1,
            rgchTicks, lstrlen(rgchTicks));
    }

    if (NULL != lprcBounds)
    {
        // Set extents back appropriately
        m_fMustSetExtent = FALSE; 
        if (!m_fDesignMode)
            SetIdentity();

        m_rcBounds = rcSavedBounds;
    }

    return S_OK;
}

/*==========================================================================*/
//
// ISGrfxCtl implementation
//

HRESULT STDMETHODCALLTYPE CSGrfx::get_SourceURL(BSTR __RPC_FAR *bstrSourceURL)
{
    HANDLENULLPOINTER(bstrSourceURL);

    if (*bstrSourceURL)
        SysFreeString(*bstrSourceURL);

    *bstrSourceURL = SysAllocString(m_pwszSourceURL);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_SourceURL(BSTR bstrSourceURL)
{
    HRESULT hr = S_OK;

    if (bstrSourceURL)
    {
        int iLen = lstrlenW(bstrSourceURL);
        LPWSTR pwszUrlToPersist = bstrSourceURL;

        // Allocate memory if necessary
        if ( (!m_pwszSourceURL) || (lstrlenW(m_pwszSourceURL) < lstrlenW(bstrSourceURL)) )
        {
            if (m_pwszSourceURL)
                Delete [] m_pwszSourceURL;

            m_pwszSourceURL = (LPWSTR) New WCHAR[lstrlenW(bstrSourceURL) + 1];

            // Return an appropriate error code if we failed
            if (!m_pwszSourceURL)
                hr = E_OUTOFMEMORY;

            m_pwszSourceURL[0] = 0;
            m_pwszSourceURL[1] = 0;
        }

        BSTRtoWideChar(bstrSourceURL, m_pwszSourceURL, iLen + 1);

        // Call the parser to instantiate the persisted primitives...
        m_cparser.LoadObjectInfo(NULL,
            pwszUrlToPersist,
            m_punkOuter,
            TRUE );

        if (m_fUpdateDrawingSurface)
        {
            // Make sure to re-initialize the drawing state...
            InitializeSurface();

            // Finally, load the objects into our DrawingSurface...
            m_cparser.PlaybackObjectInfo(m_DrawingSurfacePtr, m_StaticsPtr, m_CoordSystem == LeftHanded);

            if (!m_fNeedOnTimer && m_cparser.AnimatesOverTime())
                m_fNeedOnTimer = TRUE;

            hr = UpdateImage(NULL, TRUE);
        }
    }
    else // No string passed in, zap ours
    {
        Delete [] m_pwszSourceURL;
        m_pwszSourceURL = NULL;
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_CoordinateSystem(CoordSystemConstant __RPC_FAR *CoordSystem)
{
    HANDLENULLPOINTER(CoordSystem);

    *CoordSystem = m_CoordSystem;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_CoordinateSystem(CoordSystemConstant CoordSystem)
{
    if (m_fDesignMode)
    {
        HRESULT hr = S_OK;

        m_CoordSystem = CoordSystem;

        hr = RecomposeTransform(TRUE);

        return hr;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_MouseEventsEnabled(VARIANT_BOOL __RPC_FAR *fEnabled)
{
    HANDLENULLPOINTER(fEnabled);

    *fEnabled = BOOL_TO_VBOOL(m_fMouseEventsEnabled);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_MouseEventsEnabled(VARIANT_BOOL fEnabled)
{
    m_fMouseEventsEnabled = VBOOL_TO_BOOL(fEnabled);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_ExtentTop(int __RPC_FAR *iExtentTop)
{
    HANDLENULLPOINTER(iExtentTop);

    *iExtentTop = m_iExtentTop;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_ExtentTop(int iExtentTop)
{
    if (m_fDesignMode)
    {
        m_iExtentTop = iExtentTop;
        m_fExtentTopSet = true; 
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_ExtentLeft(int __RPC_FAR *iExtentLeft)
{
    HANDLENULLPOINTER(iExtentLeft);

    *iExtentLeft = m_iExtentLeft;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_ExtentLeft(int iExtentLeft)
{
    if (m_fDesignMode)
    {
        m_iExtentLeft = iExtentLeft;
        m_fExtentLeftSet = true; 
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_ExtentWidth(int __RPC_FAR *iExtentWidth)
{
    HANDLENULLPOINTER(iExtentWidth);

    *iExtentWidth = m_iExtentWidth;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_ExtentWidth(int iExtentWidth)
{
    if (m_fDesignMode)
    {
        // Only positive values are useful
        if (iExtentWidth > 0)
        {
            m_iExtentWidth = iExtentWidth;
            m_fExtentWidthSet = true; 
            return S_OK;
        }
        else
        {
            return DISP_E_OVERFLOW;
        }
        }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_ExtentHeight(int __RPC_FAR *iExtentHeight)
{
    HANDLENULLPOINTER(iExtentHeight);

    *iExtentHeight = m_iExtentHeight;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_ExtentHeight(int iExtentHeight)
{
    if (m_fDesignMode)
    {
        // Only positive values are useful
        if (iExtentHeight > 0)
        {
            m_iExtentHeight = iExtentHeight;
            m_fExtentHeightSet = true;
            return S_OK;
        }
        else
        {
            return DISP_E_OVERFLOW;
        }
        
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_HighQuality(VARIANT_BOOL __RPC_FAR *pfHighQuality)
{
    HANDLENULLPOINTER(pfHighQuality);

    *pfHighQuality = m_fHighQuality ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_HighQuality(VARIANT_BOOL fHighQuality)
{
    // Only bother with changing and invalidating if it really has changed
    if (m_fHighQuality != VBOOL_TO_BOOL(fHighQuality))
    {
        m_fHighQuality = VBOOL_TO_BOOL(fHighQuality);

        if (!m_fDesignMode)
            InvalidateControl(NULL, TRUE);
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_Library(IDAStatics __RPC_FAR **ppLibrary)
{
    HANDLENULLPOINTER(ppLibrary);

    if (!m_fDesignMode)
    {
        if (m_StaticsPtr)
        {
            // AddRef since this is really a Query...
            m_StaticsPtr.p->AddRef();

            // Set the return value...
            *ppLibrary = m_StaticsPtr.p;
        }
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_Image(IDAImage __RPC_FAR **ppImage)
{
    HRESULT hr = S_OK;

    HANDLENULLPOINTER(ppImage);

    if (!m_ImagePtr)
    {
        if (FAILED(hr = UpdateImage(NULL, FALSE)))
            return hr;
    }

    if (m_ImagePtr)
    {
        // AddRef since this is really a Query...
        m_ImagePtr.p->AddRef();

        // Set the return value...
        *ppImage = m_ImagePtr.p;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_Image(IDAImage __RPC_FAR *pImage)
{
    HRESULT hr = S_OK;
    HANDLENULLPOINTER(pImage);
    CComPtr<IDAImage> ImagePtr = pImage;
    CComPtr<IDAImage> TransformedImagePtr;

    // Apply the current control transform to the image...
    if (SUCCEEDED(hr = CreateBaseTransform()) &&
        SUCCEEDED(hr = RecomposeTransform(FALSE)) &&
        SUCCEEDED(hr = ImagePtr->Transform(m_TransformPtr, &TransformedImagePtr)))
    {
        // This will free any existing image and then use
        // the one passed into this method...
        hr = UpdateImage(TransformedImagePtr, TRUE);
        m_fNeedOnTimer = true;
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_Transform(IDATransform3 __RPC_FAR **ppTransform)
{
    HRESULT hr = S_OK;

    HANDLENULLPOINTER(ppTransform);

    if (!m_FullTransformPtr)
    {
        if (FAILED(hr = CreateBaseTransform()))
            return hr;
    }

    if (m_FullTransformPtr)
    {
        // AddRef since this is really a Query...
        m_FullTransformPtr.p->AddRef();

        // Set the return value...
        *ppTransform = m_FullTransformPtr.p;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_Transform(IDATransform3 __RPC_FAR *pTransform)
{
    HRESULT hr = S_OK;
    HANDLENULLPOINTER(pTransform);

    // This will free the old transform and select the new one in.
    m_FullTransformPtr = pTransform;

    // Recompose with the new transform...
    hr = RecomposeTransform(TRUE);
    
    m_fNeedOnTimer = true;

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_DrawingSurface(IDADrawingSurface __RPC_FAR **ppDrawingSurface)
{
    HANDLENULLPOINTER(ppDrawingSurface);

    if (m_DrawingSurfacePtr)
    {
        // AddRef since this is really a Query...
        m_DrawingSurfacePtr.p->AddRef();

        // Set the return value...
        *ppDrawingSurface = m_DrawingSurfacePtr.p;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_DrawingSurface(IDADrawingSurface __RPC_FAR *pDrawingSurface)
{
    HRESULT hr = S_OK;
    HANDLENULLPOINTER(pDrawingSurface);

    if (pDrawingSurface)
    {
        // This will free any existing drawing surface and then use
        // the one passed into this method...
        m_DrawingSurfacePtr = pDrawingSurface;

        hr = UpdateImage(NULL, TRUE);

        m_fNeedOnTimer = true;
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_DrawSurface(IDADrawingSurface __RPC_FAR **ppDrawingSurface)
{
    return get_DrawingSurface(ppDrawingSurface);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_DrawSurface(IDADrawingSurface __RPC_FAR *pDrawingSurface)
{
    return put_DrawingSurface(pDrawingSurface);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_PreserveAspectRatio(VARIANT_BOOL __RPC_FAR *pfPreserve)
{
    HANDLENULLPOINTER(pfPreserve);
    *pfPreserve = BOOL_TO_VBOOL(m_fPreserveAspectRatio);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_PreserveAspectRatio(VARIANT_BOOL fPreserve)
{
    m_fPreserveAspectRatio = VBOOL_TO_BOOL(fPreserve);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::Clear(void)
{
    HRESULT hr = S_OK;

    if (m_DrawingSurfacePtr)
    {
        // This wipes the internal representation...
        if (SUCCEEDED(hr = InitializeSurface()) &&
            SUCCEEDED(hr = UpdateImage(NULL, TRUE)))
        {
            // No need to invalidate because UpdateImage does...
            // InvalidateControl(NULL, TRUE);
        }
    }

    return hr;
}

/*==========================================================================*/

#define CHECK(stmt) if (FAILED(hr = (stmt))) return hr;

HRESULT STDMETHODCALLTYPE CSGrfx::Rotate(double dblXRot, double dblYRot, double dblZRot, VARIANT varReserved)
{
    HRESULT hr = S_OK;

    if (dblXRot != 0.0 ||
        dblYRot != 0.0 ||
        dblZRot != 0.0)
    {   CComPtr<IDATransform3> TransformPtr;
        CComPtr<IDATransform3> ResultTransformPtr;

        if (m_CachedRotateTransformPtr != NULL &&
            dblXRot == m_dblCachedRotateX &&
            dblYRot == m_dblCachedRotateY &&
            dblZRot == m_dblCachedRotateZ)

        { TransformPtr = m_CachedRotateTransformPtr;
        } else {
          CComPtr<IDATransform3> RotateYTransformPtr;
          CComPtr<IDATransform3> RotateZTransformPtr;

          if (FAILED(hr = CreateBaseTransform()))
            return hr;

          bool setXfYet = false;

          if (dblXRot != 0.0)
            {
              // First one we'd hit, so set TransformPtr directly.
              CHECK(m_StaticsPtr->Rotate3Degrees(m_xVector3,
                                                 dblXRot,
                                                 &TransformPtr));
              setXfYet = true;
            }

          if (dblYRot != 0.0)
            {
              CHECK(m_StaticsPtr->Rotate3Degrees(m_yVector3,
                                                 dblYRot,
                                                 &RotateYTransformPtr));
              if (setXfYet) {
                CHECK(m_StaticsPtr->Compose3(RotateYTransformPtr,
                                             TransformPtr,
                                             &ResultTransformPtr));

                TransformPtr = ResultTransformPtr;
                ResultTransformPtr = NULL;
              } else {
                TransformPtr = RotateYTransformPtr;
                setXfYet = true;
              }
            }

          if (dblZRot != 0.0)
            {
              double dblVector = -1.0;

              CHECK(m_StaticsPtr->Rotate3Degrees(m_zVector3,
                                                 dblZRot * dblVector,
                                                 &RotateZTransformPtr));
              if (setXfYet) {
                CHECK(m_StaticsPtr->Compose3(RotateZTransformPtr,
                                             TransformPtr,
                                             &ResultTransformPtr));

                TransformPtr = ResultTransformPtr;
                ResultTransformPtr = NULL;
              } else {
                TransformPtr = RotateZTransformPtr;
                setXfYet = true;
              }

              ASSERT(setXfYet == true);

            }
            m_CachedRotateTransformPtr = TransformPtr;
            m_dblCachedRotateX = dblXRot;
            m_dblCachedRotateY = dblYRot;
            m_dblCachedRotateZ = dblZRot;
        } /* else */

        CHECK(m_StaticsPtr->Compose3(TransformPtr,
                                     m_FullTransformPtr,
                                     &ResultTransformPtr));

        m_FullTransformPtr = ResultTransformPtr;

        hr = RecomposeTransform(TRUE);

    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::Scale(double dblXScale, double dblYScale, double dblZScale, VARIANT varReserved)
{
    HRESULT hr = S_OK;

    if (dblXScale != 1.0 ||
        dblYScale != 1.0 ||
        dblZScale != 1.0)
    { 
      CComPtr<IDATransform3> ScaleTransformPtr;
      CComPtr<IDATransform3> ResultTransformPtr;

      CHECK(CreateBaseTransform());

       /* check whether scale transform is already cached */

      if (m_CachedScaleTransformPtr != NULL &&
          dblXScale == m_dblCachedScaleX &&
          dblYScale == m_dblCachedScaleY &&
          dblZScale == m_dblCachedScaleZ)
        { ScaleTransformPtr = m_CachedScaleTransformPtr;
        } else {
          CComPtr<IDANumber> xs, ys, zs;

          if (dblXScale == 1) {
            xs = m_one;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblXScale, &xs));
          }

          if (dblYScale == 1) {
            ys = m_one;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblYScale, &ys));
          }

          if (dblZScale == 1) {
            zs = m_one;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblZScale, &zs));
          }
          CHECK(m_StaticsPtr->Scale3Anim(xs, ys, zs, &ScaleTransformPtr));

          /* cache scale transform */

          m_dblCachedScaleX = dblXScale;
          m_dblCachedScaleY = dblYScale;
          m_dblCachedScaleZ = dblZScale;
          m_CachedScaleTransformPtr = ScaleTransformPtr;

        } 
    
      CHECK(m_StaticsPtr->Compose3(ScaleTransformPtr, m_FullTransformPtr, &ResultTransformPtr));

      m_FullTransformPtr = ResultTransformPtr;

      hr = RecomposeTransform(TRUE);
    }

  return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::SetIdentity(void)
{
    HRESULT hr = S_OK;

    if (m_FullTransformPtr)
        m_FullTransformPtr = NULL;

    hr = RecomposeTransform(TRUE);

    if (m_fSetExtentsInSetIdentity)
        SetSGExtent();

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::Transform4x4(VARIANT matrix)
{
    HRESULT hr = S_OK;

    CComPtr<IDATransform3> TransformPtr;
    CComPtr<IDATransform3> ResultTransformPtr;

    if (SUCCEEDED(hr = m_StaticsPtr->Transform4x4Anim(matrix, &TransformPtr)) &&
        SUCCEEDED(hr = m_StaticsPtr->Compose3(TransformPtr, m_FullTransformPtr, &ResultTransformPtr)))
    {
        m_FullTransformPtr = ResultTransformPtr;

        hr = RecomposeTransform(TRUE);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::Translate(double dblXTranslate, double dblYTranslate, double dblZTranslate, VARIANT varReserved)
{
  HRESULT hr = S_OK;

  if (dblXTranslate != 0.0 ||
      dblYTranslate != 0.0 ||
      dblZTranslate != 0.0)
    {
      CComPtr<IDATransform3> TranslateTransformPtr;
      CComPtr<IDATransform3> ResultTransformPtr;

      CHECK(CreateBaseTransform());

      if (m_CachedTranslateTransformPtr != NULL &&
          dblXTranslate == m_dblCachedTranslateX &&
          dblYTranslate == m_dblCachedTranslateY &&
          dblZTranslate == m_dblCachedTranslateZ)
        { TranslateTransformPtr = m_CachedTranslateTransformPtr;
        } else {

          CComPtr<IDANumber> xs, ys, zs;

          if (m_CoordSystem == RightHanded)
            dblYTranslate = -dblYTranslate;

          if (dblXTranslate == 0.0) {
            xs = m_zero;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblXTranslate, &xs));
          }

          if (dblYTranslate == 0.0) {
            ys = m_zero;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblYTranslate, &ys));
          }

          if (dblZTranslate == 0.0) {
            zs = m_zero;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblZTranslate, &zs));
          }

          CHECK(m_StaticsPtr->Translate3Anim(xs, ys, zs, &TranslateTransformPtr));
          m_dblCachedTranslateX = dblXTranslate;
          m_dblCachedTranslateY = dblYTranslate;
          m_dblCachedTranslateZ  = dblZTranslate;
          m_CachedTranslateTransformPtr = TranslateTransformPtr;
        } 

      if (SUCCEEDED(hr = m_StaticsPtr->Compose3(TranslateTransformPtr, m_FullTransformPtr, &ResultTransformPtr)))
        {
          m_FullTransformPtr = ResultTransformPtr;

          hr = RecomposeTransform(TRUE);
        }
    }
    return S_OK;
}

/*==========================================================================*/
#ifdef INCLUDESHEAR
HRESULT STDMETHODCALLTYPE CSGrfx::ShearX(double dblShearAmount)
{
    HRESULT hr = S_OK;

    if (dblShearAmount != 0.0)
    {
        CComPtr<IDATransform3> ShearTransformPtr;
        CComPtr<IDATransform3> ResultTransformPtr;

        if (SUCCEEDED(hr = CreateBaseTransform()) &&
            SUCCEEDED(hr = m_StaticsPtr->XShear3(dblShearAmount, 0.0, &ShearTransformPtr)) &&
            SUCCEEDED(hr = m_StaticsPtr->Compose3(ShearTransformPtr, m_FullTransformPtr, &ResultTransformPtr)))
        {
            m_FullTransformPtr = ResultTransformPtr;

            hr = RecomposeTransform(TRUE);
        }
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::ShearY(double dblShearAmount)
{
    HRESULT hr = S_OK;

    if (dblShearAmount != 0.0)
    {
        CComPtr<IDATransform3> ShearTransformPtr;
        CComPtr<IDATransform3> ResultTransformPtr;

        if (SUCCEEDED(hr = CreateBaseTransform()) &&
            SUCCEEDED(hr = m_StaticsPtr->YShear3(dblShearAmount, 0.0, &ShearTransformPtr)) &&
            SUCCEEDED(hr = m_StaticsPtr->Compose3(ShearTransformPtr, m_FullTransformPtr, &ResultTransformPtr)))
        {
            m_FullTransformPtr = ResultTransformPtr;

            hr = RecomposeTransform(TRUE);
        }
    }

    return S_OK;
}
#endif // INCLUDESHEAR
/*==========================================================================*/

HRESULT CSGrfx::InitializeSurface(void)
{
    HRESULT hr = S_FALSE;

    if (m_DrawingSurfacePtr)
    {
        CComPtr<IDAColor> LineColorPtr;
        CComPtr<IDAColor> FGColorPtr;
        CComPtr<IDAColor> BGColorPtr;
        CComPtr<IDALineStyle> LineStylePtr;
        VARIANT_BOOL vBool = VARIANT_TRUE;

        if (SUCCEEDED(m_DrawingSurfacePtr->Clear()) &&
            SUCCEEDED(m_StaticsPtr->ColorRgb255(0, 0, 0, &LineColorPtr)) &&
            SUCCEEDED(m_StaticsPtr->ColorRgb255(255, 255, 255, &FGColorPtr)) &&
            SUCCEEDED(m_StaticsPtr->ColorRgb255(255, 255, 255, &BGColorPtr)) &&
            SUCCEEDED(m_StaticsPtr->get_DefaultLineStyle(&LineStylePtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->put_LineStyle(LineStylePtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->LineColor(LineColorPtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->LineDashStyle(DASolid)) &&
            SUCCEEDED(m_DrawingSurfacePtr->LineJoinStyle(DAJoinRound)) &&
            SUCCEEDED(m_DrawingSurfacePtr->LineEndStyle(DAEndRound)) &&
            SUCCEEDED(m_DrawingSurfacePtr->put_BorderStyle(LineStylePtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->BorderColor(LineColorPtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->BorderDashStyle(DASolid)) &&
            SUCCEEDED(m_DrawingSurfacePtr->BorderJoinStyle(DAJoinRound)) &&
            SUCCEEDED(m_DrawingSurfacePtr->BorderEndStyle(DAEndRound)) &&
            SUCCEEDED(m_DrawingSurfacePtr->FillColor(FGColorPtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->SecondaryFillColor(BGColorPtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->FillStyle(1)) &&
            SUCCEEDED(m_DrawingSurfacePtr->put_HatchFillTransparent(vBool)))
        {
            hr = S_OK;
        }
    }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::PaintToDC(HDC hdcDraw, LPRECT lprcBounds, BOOL fBW)
{
    HRESULT hr = S_OK;

    CComPtr<IDirectDrawSurface> DDrawSurfPtr;
    long lSurfaceLock = 0;

    if (!lprcBounds)
        lprcBounds = &m_rcBounds;

    if (IsRectEmpty(&m_rcBounds))
        return S_OK;

    if (!m_ServiceProviderPtr)
    {
        if (m_pocs)
        {
            // It's OK if this fails...
            hr = m_pocs->QueryInterface(IID_IServiceProvider, (LPVOID *)&m_ServiceProviderPtr);
        }
    }

    if ((!m_DirectDraw3Ptr) && (m_ServiceProviderPtr))
    {
        // It's OK if this fails...
        hr = m_ServiceProviderPtr->QueryService(
            SID_SDirectDraw3,
            IID_IDirectDraw3,
            (LPVOID *)&m_DirectDraw3Ptr);
    }

    if (m_DirectDraw3Ptr)
    {
        ASSERT(hdcDraw!=NULL && "Error, NULL hdcDraw in PaintToDC!!!");
        // Use DirectDraw 3 rendering...
        if (SUCCEEDED(hr = m_DirectDraw3Ptr->GetSurfaceFromDC(hdcDraw, &DDrawSurfPtr)))
        {
            if (FAILED(hr = m_ViewPtr->put_IDirectDrawSurface(DDrawSurfPtr)))
            {
                return hr;
            }

            if (FAILED(hr = m_ViewPtr->put_CompositeDirectlyToTarget(TRUE)))
            {
                return hr;
            }
        }
        else
        {
            // Fall back to generic HDC rendering services...
            if (FAILED(hr = m_ViewPtr->put_DC(hdcDraw)))
            {
                return hr;
            }
        }
    }
    else
    {
        // Use generic HDC rendering services...
        if (FAILED(hr = m_ViewPtr->put_DC(hdcDraw)))
        {
            return hr;
        }
    }

    if (FAILED(hr = m_ViewPtr->SetViewport(
        lprcBounds->left,
        lprcBounds->top,
        lprcBounds->right - lprcBounds->left,
        lprcBounds->bottom - lprcBounds->top)))
    {
        return hr;
    }

    //
    // From the HDC, get the clip rect (should be region) in
    // DC coords and convert to Device coords
    //
    RECT rcClip;  // in dc coords
    GetClipBox(hdcDraw, &rcClip);
    LPtoDP(hdcDraw, (POINT *) &rcClip, 2);

    if (FAILED(hr = m_ViewPtr->RePaint(
        rcClip.left,
        rcClip.top,
        rcClip.right-rcClip.left,
        rcClip.bottom-rcClip.top)))
    {
        return hr;
    }

    if (FAILED(hr = m_ViewPtr->SetClipRect(
        rcClip.left,
        rcClip.top,
        rcClip.right - rcClip.left,
        rcClip.bottom - rcClip.top)))
    {
        return hr;
    }

    if (!m_fStarted)
        StartModel();

    if (m_fStarted)
    {
        VARIANT_BOOL vBool;

        // Set the current time...
        hr = m_ViewPtr->Tick(m_dblTime, &vBool);

        // Finally,  render into the DC (or DirectDraw Surface)...
        hr = m_ViewPtr->Render();
    }

    if (DDrawSurfPtr)
    {
        if (FAILED(hr = m_ViewPtr->put_IDirectDrawSurface(NULL)))
        {
            return hr;
        }
    }

    return hr;
}

/*==========================================================================*/

DWORD CSGrfx::GetCurrTimeInMillis()
{
    return timeGetTime();
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::InvalidateControl(LPCRECT pRect, BOOL fErase)
{
    if (m_fStarted)
    {
        RECT rectPaint;

        if (pRect)
            rectPaint = *pRect;
        else
            rectPaint = m_rcBounds;
    }

    if (NULL != m_poipsw) // Make sure we have a site - don't crash IE 3.0
    {
        if (m_fControlIsActive)
            m_poipsw->InvalidateRect(pRect, fErase);
        else
            m_fInvalidateWhenActivated = TRUE;
    }

    return S_OK;
}

/*==========================================================================*/

void CSGrfx::SetSGExtent()
{
    float fltScaleRatioX = 0.0f, fltScaleRatioY = 0.0f, fltScaleRatio = 0.0f;
    VARIANT vaDummy;

    // Strictly speaking we don't need to do this, because the variant is totally
    // ignored, but we'll do this to be safe, in case this changes in the future
    vaDummy.vt = VT_ERROR;
    vaDummy.scode = DISP_E_PARAMNOTFOUND;

    // Figure out where to get the width and height from: either the user
    // specified it,or we use the control's width and height

    if (m_iExtentWidth == 0)
        m_iExtentWidth = m_rcBounds.right - m_rcBounds.left;

    if (m_iExtentHeight == 0)
        m_iExtentHeight = m_rcBounds.bottom - m_rcBounds.top;

    // Compute scaling factor, preserving aspect ratio
    fltScaleRatioX = ((float)(m_rcBounds.right - m_rcBounds.left) / (float)m_iExtentWidth);
    fltScaleRatioY = (float)((m_rcBounds.bottom - m_rcBounds.top) / (float)m_iExtentHeight);

    // Yranslate the origin, and scale appropriately
    Translate(
        -((float)m_iExtentLeft + ((float)m_iExtentWidth)/2),
        -((float)m_iExtentTop + ((float)m_iExtentHeight)/2),
        0.0f,
        vaDummy);

    if (m_fPreserveAspectRatio)
    {
        fltScaleRatio = (fltScaleRatioX < fltScaleRatioY) ? fltScaleRatioX : fltScaleRatioY;
        Scale(fltScaleRatio, fltScaleRatio, 1.0f, vaDummy);
    }   
    else
    {
        Scale(fltScaleRatioX, fltScaleRatioY, 1.0f, vaDummy);
    }
}

/*==========================================================================*/

HRESULT CSGrfx::CreateBaseTransform(void)
{
    HRESULT hr = S_OK;

    if (!m_FullTransformPtr)
    {
        if (SUCCEEDED(hr = m_StaticsPtr->get_IdentityTransform3(&m_FullTransformPtr)))
        {
            // Let the last hr value get returned...
        }

#if 0
        CComPtr<IDANumber>  NumberPtr;
        CComPtr<IDAVector3> VectorPtr;
        CComPtr<IDAVector3> VectorScaledPtr;

        if (SUCCEEDED(hr = m_StaticsPtr->get_Pixel(&NumberPtr)) &&
            SUCCEEDED(hr = m_StaticsPtr->Vector3(1.0, 1.0, 1.0, &VectorPtr)) &&
            SUCCEEDED(hr = VectorPtr->MulAnim(NumberPtr, &VectorScaledPtr)) &&
            SUCCEEDED(hr = m_StaticsPtr->Scale3Vector(VectorScaledPtr, &m_FullTransformPtr)))
        {
            // Let the last hr value get returned...
        }
#endif // 0
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSGrfx::RecomposeTransform(BOOL fInvalidate)
{
    HRESULT hr = S_OK;
    CComPtr<IDATransform2> ResultTransformPtr;

    CHECK(CreateBaseTransform());

    CHECK(m_FullTransformPtr->ParallelTransform2(&ResultTransformPtr));

    if (!m_TransformPtr)
    {
        CComPtr<IDABehavior> bvr;

        CHECK(m_StaticsPtr->ModifiableBehavior(m_identityXform2, &bvr));
        m_TransformPtr = (IDATransform2 *) bvr.p;
    }

#if BOGUS_CODE
    // TODO: Should be able to pre-compose this guy in once, rather
    // than every frame.

    if (m_CoordSystem == LeftHanded)
    {
        CComPtr<IDATransform2> TempTransformPtr;

        // Vertically flip the coordinate space...
        CHECK(m_StaticsPtr->Compose2(m_yFlipXform2,
                                     ResultTransformPtr,
                                     &TempTransformPtr));
        ResultTransformPtr = TempTransformPtr;
    }
#endif // 0

    CHECK(m_TransformPtr->SwitchTo(ResultTransformPtr));

    if (fInvalidate)
        InvalidateControl(NULL, TRUE);

    return hr;
}

/*==========================================================================*/

HRESULT CSGrfx::UpdateImage(IDAImage *pImage, BOOL fInvalidate)
{
    HRESULT hr = S_OK;

    if (m_DrawingSurfacePtr)
    {
        // We need a transform at this point...
        if (FAILED(hr = RecomposeTransform(FALSE)))
            return hr;

        if (!m_ImagePtr)
        {
            CComPtr<IDAImage> EmptyImagePtr;
            CComPtr<IDABehavior> BehaviorPtr;

            if (FAILED(hr = m_StaticsPtr->get_EmptyImage(&EmptyImagePtr)))
                return hr;

            if (FAILED(hr = m_StaticsPtr->ModifiableBehavior(EmptyImagePtr, &BehaviorPtr)))
                return hr;

            m_ImagePtr = (IDAImage *)BehaviorPtr.p;
        }

        if (m_ImagePtr)
        {
            CComPtr<IDAImage> ImagePtr = pImage;

            if (!ImagePtr)
            {
                CComPtr<IDAImage> TransformedImagePtr;

                if (FAILED(hr = m_DrawingSurfacePtr->get_Image(&ImagePtr)))
                    return hr;

                if (FAILED(hr = ImagePtr->Transform(m_TransformPtr, &TransformedImagePtr)))
                    return hr;

                ImagePtr = TransformedImagePtr;
                TransformedImagePtr = NULL;
            }

#ifdef DEADCODE
            if (m_fMouseEventsEnabled) {
                // turn on the picking callback

                CComPtr<IDABehavior> ppickedImage;

                m_pcallback = NULL;

                // Fill in class without AddRef'ing it
                *(&m_pcallback) = New CPickCallback(m_pconpt, m_StaticsPtr, ImagePtr, m_fOnWindowLoadFired, hr);
                if (FAILED(hr)) return hr;
                if (FAILED(hr = m_pcallback->GetImage(&ppickedImage))) return hr;

                // switch to the new image

                hr = m_ImagePtr->SwitchTo(ppickedImage);
            } else {
                hr = m_ImagePtr->SwitchTo(ImagePtr);
            }
#endif // DEADCODE

            hr = m_ImagePtr->SwitchTo(ImagePtr);

            if (SUCCEEDED(hr) && fInvalidate)
                InvalidateControl(NULL, TRUE);
        }
        else
        {
            hr = E_POINTER;
        }
    }

    return hr;
}

/*==========================================================================*/

BOOL CSGrfx::StopModel(void)
{
    // Stop any currently running model...
    if (m_fStarted)
    {
        BOOL fResult = SUCCEEDED(m_ViewPtr->StopModel());

        if (!fResult)
            return fResult;

        m_clocker.Stop();

        m_fStarted = FALSE;
    }

    if (m_fHQStarted)
    {
        m_HQViewPtr->StopModel();
        m_fHQStarted = FALSE;
    }

    return TRUE;
}

/*==========================================================================*/

BOOL CSGrfx::StartModel(void)
{
    BOOL fResult = FALSE;

    if (!m_fStarted)
    {
        CComPtr<IDASound> SoundPtr;

        m_ViewPtr->put_ClientSite(m_pocs);

        if (FAILED(RecomposeTransform(FALSE)))
            return FALSE;

        if (!m_ImagePtr)
        {
            CComPtr<IDAImage> ImagePtr;
            CComPtr<IDAImage> TransformedImagePtr;

            if (FAILED(m_DrawingSurfacePtr->get_Image(&ImagePtr)))
                return FALSE;

            // Transform based upon the given image...
            if (FAILED(ImagePtr->Transform(m_TransformPtr, &TransformedImagePtr)))
                return FALSE;

            // This will m_ImagePtr->SwitchTo...
            if (FAILED(UpdateImage(TransformedImagePtr, FALSE)))
                return FALSE;
        }

        if (FAILED(m_StaticsPtr->get_Silence(&SoundPtr)))
            return FALSE;

        if (FAILED(m_ViewPtr->StartModel(m_ImagePtr, SoundPtr, 0)))
            return FALSE;

        m_dblStartTime = GetCurrTime();
        m_dblTime = 0;

        m_clocker.Start();

        m_fStarted = TRUE;

        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CSGrfx::ReStartModel(void)
{
    BOOL fResult = FALSE;

    // Stop the running model so that it will restart for the
    // next paint...
    StopModel();

    InvalidateControl(NULL, TRUE);

    return fResult;
}

/*==========================================================================*/

BOOL CSGrfx::PaintHQBitmap(HDC hdc)
{
        BOOL fRet = FALSE;
        
    // If we don't have a DC, we need to create it
        if (!m_hdcHQ)
        {
                HDC hScreenDC = ::GetDC(NULL);

                // This should create a DC with a monochrome bitmap selected into it
                m_hdcHQ = ::CreateCompatibleDC(hScreenDC);
                ::ReleaseDC(NULL, hScreenDC);

        if (m_hdcHQ)
        {
            // Create the 24-bit offscreen for HQ rendering:
            m_bmInfoHQ.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            m_bmInfoHQ.bmiHeader.biWidth = (m_rcBounds.right - m_rcBounds.left) * HQ_FACTOR;
            m_bmInfoHQ.bmiHeader.biHeight = (m_rcBounds.bottom - m_rcBounds.top) * HQ_FACTOR;
            m_bmInfoHQ.bmiHeader.biPlanes = 1;
            m_bmInfoHQ.bmiHeader.biBitCount = 24;
            m_bmInfoHQ.bmiHeader.biCompression = BI_RGB;
            m_bmInfoHQ.bmiHeader.biSizeImage = 0;
            m_bmInfoHQ.bmiHeader.biXPelsPerMeter = 75000;
            m_bmInfoHQ.bmiHeader.biYPelsPerMeter = 75000;
            m_bmInfoHQ.bmiHeader.biClrUsed = 0;
            m_bmInfoHQ.bmiHeader.biClrImportant = 0;

            m_hbmpHQ = ::CreateDIBSection(
                m_hdcHQ,
                &m_bmInfoHQ,
                DIB_RGB_COLORS,
                (VOID **)&m_pHQDIBBits,
                0,
                0);

            if (m_hbmpHQ)
            {
                        m_hbmpHQOld = (HBITMAP)::SelectObject(m_hdcHQ, m_hbmpHQ);
                ::SetViewportOrgEx(m_hdcHQ, 0, 0, NULL);
            }
            else
            {
                ::DeleteDC(m_hdcHQ);
                m_hdcHQ = NULL;
            }
        }
        }

        if (m_hdcHQ)
        {
        RECT rcBounds = m_rcBounds;
        RECT rcClip;
        int iWidth = m_bmInfoHQ.bmiHeader.biWidth;
        int iHeight = m_bmInfoHQ.bmiHeader.biHeight;
        int iSaveContext = 0;
        int iSaveOffContext = 0;

        // Save the current device context...
        iSaveContext = ::SaveDC(hdc);
        iSaveOffContext = ::SaveDC(m_hdcHQ);

        ::OffsetViewportOrgEx(hdc, m_rcBounds.left, m_rcBounds.top, NULL);
        ::OffsetRect(&rcBounds, -m_rcBounds.left, -m_rcBounds.top);
        ::GetClipBox(hdc, &rcClip);

        ::IntersectRect(&rcClip, &rcBounds, &rcClip);

        // Make sure we have coordinates in a valid range...
        if (rcClip.left < 0)
            rcClip.left = 0;

        if (rcClip.left >= iWidth)
            rcClip.left = iWidth-1;

        if (rcClip.right < 0)
            rcClip.right = 0;

        if (rcClip.right >= iWidth)
            rcClip.right = iWidth-1;

        // Get the current background bits...
        fRet = ::StretchBlt(
            m_hdcHQ,
            0,
            0,
            (rcBounds.right  - rcBounds.left) * HQ_FACTOR,
            (rcBounds.bottom - rcBounds.top) * HQ_FACTOR,
            hdc,
            rcBounds.left,
            rcBounds.top,
            (rcBounds.right  - rcBounds.left),
            (rcBounds.bottom - rcBounds.top),
            SRCCOPY);

        if (fRet)
        {
            // Paint the source bitmap on the new HDC:
            do
            {
                CComPtr<IDAImage> ImagePtr;
                CComPtr<IDAImage> TransformedImagePtr;
                double dblCurrentTime = GetCurrTime();
                VARIANT_BOOL vBool;
                DWORD dwTickStart = 0;

                fRet = FALSE;

                if (FAILED(m_HQViewPtr->put_CompositeDirectlyToTarget(FALSE)))
                    break;

                if (FAILED(m_HQViewPtr->put_DC(m_hdcHQ)))
                    break;

                if (FAILED(m_HQViewPtr->SetViewport(
                    0,
                    0,
                    (rcBounds.right  - rcBounds.left) * HQ_FACTOR,
                    (rcBounds.bottom - rcBounds.top) * HQ_FACTOR)))
                    break;

                if (FAILED(m_ViewPtr->RePaint(
                    rcClip.left * HQ_FACTOR,
                    rcClip.top * HQ_FACTOR,
                    (rcClip.right-rcClip.left) * HQ_FACTOR,
                    (rcClip.bottom-rcClip.top) * HQ_FACTOR)))
                    break;

                if (FAILED(m_HQViewPtr->SetClipRect(
                    rcClip.left * HQ_FACTOR,
                    rcClip.top * HQ_FACTOR,
                    (rcClip.right-rcClip.left) * HQ_FACTOR,
                    (rcClip.bottom-rcClip.top) * HQ_FACTOR)))
                    break;

                if (!m_fHQStarted)
                {
                    CComPtr<IDASound> SoundPtr;
                    CComPtr<IDATransform2> TransformPtr;
                    CComPtr<IDAImage> TransformedImagePtr;

                    if (FAILED(m_StaticsPtr->get_Silence(&SoundPtr)))
                        break;

                    if (FAILED(m_StaticsPtr->Scale2(2.0, 2.0, &TransformPtr)))
                        break;

                    if (FAILED(m_HQViewPtr->put_ClientSite(m_pocs)))
                        break;

                    if (!m_ImagePtr)
                        break;

                    // Transform based upon the given image...
                    if (FAILED(m_ImagePtr->Transform(TransformPtr, &TransformedImagePtr)))
                        break;

                    if (FAILED(m_HQViewPtr->StartModel(TransformedImagePtr, SoundPtr, dblCurrentTime)))
                        break;

                    m_fHQStarted = TRUE;
                }

                // Set the current time...
                if (FAILED(m_HQViewPtr->Tick(dblCurrentTime, &vBool)))
                    break;

                // Finally, render into the DC...
                if (FAILED(m_HQViewPtr->Render()))
                    break;

                m_HQViewPtr->put_ClientSite(NULL);

                ::GdiFlush();

                fRet = TRUE;
            }
            while(0);
        }

        if (fRet)
        {
            // Smooth the bitmap and place the result in the proper location
            SmoothHQBitmap(&rcClip);

            // Now, finally BLT to the display...
            fRet = ::BitBlt(
                hdc,
                rcBounds.left,
                rcBounds.top,
                (rcBounds.right  - rcBounds.left),
                (rcBounds.bottom - rcBounds.top),
                m_hdcHQ,
                0,
                (rcBounds.bottom - rcBounds.top),
                SRCCOPY);
        }

        // Restore the previous device context...
        ::RestoreDC(hdc, iSaveContext);
        ::RestoreDC(m_hdcHQ, iSaveOffContext);
    }
        
        return fRet;
}

/*==========================================================================*/

BOOL CSGrfx::FreeHQBitmap()
{
        BOOL fRet = TRUE;

        if (m_hdcHQ)
        {
                // Free up the bitmap
                SelectObject(m_hdcHQ, m_hbmpHQOld);
        DeleteObject(m_hbmpHQ);

                m_hbmpHQOld = NULL;
        m_hbmpHQ = NULL;

                // Get rid of the DC
                fRet = DeleteDC(m_hdcHQ);
                m_hdcHQ = (HDC)NULL;
        }
        return fRet;
}

/*==========================================================================*/

#pragma optimize( "agt", on )

BOOL CSGrfx::SmoothHQBitmap(LPRECT lprcBounds)
{
    BOOL fRet = TRUE;

#if HQ_FACTOR == 4
    if (m_hdcHQ && m_pHQDIBBits)
    {
        int iBytesLine = DibWidthBytes((LPBITMAPINFOHEADER)&m_bmInfoHQ);

        int iRow;
        int iCol;
        LPBYTE lpSrcLine = m_pHQDIBBits;
        LPBYTE lpDstLine = m_pHQDIBBits;
        int iR1 = iBytesLine;
        int iR2 = iBytesLine << 1;
        int iR3 = (iBytesLine << 1) + iBytesLine;

        iRow = m_bmInfoHQ.bmiHeader.biHeight >> 2;

        while(iRow-- > 0)
        {
            if (iRow >= lprcBounds->top && iRow <= lprcBounds->bottom)
            {
                LPBYTE lpDst = lpDstLine;
                LPBYTE lpSrc = lpSrcLine;
                int iRedTotal;
                int iGrnTotal;
                int iBluTotal;

                lpDst += lprcBounds->left * 3;
                lpSrc += lprcBounds->left * 12;

                iCol = lprcBounds->right - lprcBounds->left;

                while(iCol-- > 0)
                {
                    // Process Row 1
                    iRedTotal = lpSrc[2] + lpSrc[5] + lpSrc[8] + lpSrc[11];
                    iGrnTotal = lpSrc[1] + lpSrc[4] + lpSrc[7] + lpSrc[10];
                    iBluTotal = lpSrc[0] + lpSrc[3] + lpSrc[6] + lpSrc[ 9];

                    // Process Row 2
                    iRedTotal += lpSrc[iR1 + 2] + lpSrc[iR1 + 5] + lpSrc[iR1 + 8] + lpSrc[iR1 + 11];
                    iGrnTotal += lpSrc[iR1 + 1] + lpSrc[iR1 + 4] + lpSrc[iR1 + 7] + lpSrc[iR1 + 10];
                    iBluTotal += lpSrc[iR1 + 0] + lpSrc[iR1 + 3] + lpSrc[iR1 + 6] + lpSrc[iR1 +  9];

                    // Process Row 3
                    iRedTotal += lpSrc[iR2 + 2] + lpSrc[iR2 + 5] + lpSrc[iR2 + 8] + lpSrc[iR2 + 11];
                    iGrnTotal += lpSrc[iR2 + 1] + lpSrc[iR2 + 4] + lpSrc[iR2 + 7] + lpSrc[iR2 + 10];
                    iBluTotal += lpSrc[iR2 + 0] + lpSrc[iR2 + 3] + lpSrc[iR2 + 6] + lpSrc[iR2 +  9];

                    // Process Row 4
                    iRedTotal += lpSrc[iR3 + 2] + lpSrc[iR3 + 5] + lpSrc[iR3 + 8] + lpSrc[iR3 + 11];
                    iGrnTotal += lpSrc[iR3 + 1] + lpSrc[iR3 + 4] + lpSrc[iR3 + 7] + lpSrc[iR3 + 10];
                    iBluTotal += lpSrc[iR3 + 0] + lpSrc[iR3 + 3] + lpSrc[iR3 + 6] + lpSrc[iR3 +  9];

                    lpDst[2] = iRedTotal >> 4;
                    lpDst[1] = iGrnTotal >> 4;
                    lpDst[0] = iBluTotal >> 4;

                    lpDst += 3; // One pixel
                    lpSrc += 12;  // Four pixels
                }
            }

            lpDstLine += iBytesLine; // One scanline
            lpSrcLine += iBytesLine << 2;  // Four scanlines
        }
    }
#endif // HQ_FACTOR == 4

#if HQ_FACTOR == 2
    if (m_hdcHQ && m_pHQDIBBits)
    {
        int iBytesLine = DibWidthBytes((LPBITMAPINFOHEADER)&m_bmInfoHQ);

        int iRow;
        int iCol;
        LPBYTE lpSrcLine = m_pHQDIBBits;
        LPBYTE lpDstLine = m_pHQDIBBits;
        int iR1 = iBytesLine;

        iRow = m_bmInfoHQ.bmiHeader.biHeight >> 1;

        while(iRow-- > 0)
        {
            if (iRow >= lprcBounds->top && iRow <= lprcBounds->bottom)
            {
                LPBYTE lpDst = lpDstLine;
                LPBYTE lpSrc = lpSrcLine;

                lpDst += lprcBounds->left * 3;
                lpSrc += lprcBounds->left * 6;

                iCol = lprcBounds->right - lprcBounds->left;

                while(iCol-- > 0)
                {
                    // Process Row 1
                    lpDst[2] = (lpSrc[2] + lpSrc[5] + lpSrc[iR1 + 2] + lpSrc[iR1 + 5]) >> 2;
                    lpDst[1] = (lpSrc[1] + lpSrc[4] + lpSrc[iR1 + 1] + lpSrc[iR1 + 4]) >> 2;
                    lpDst[0] = (lpSrc[0] + lpSrc[3] + lpSrc[iR1 + 0] + lpSrc[iR1 + 3]) >> 2;

                    lpDst += 3; // One pixel
                    lpSrc += 6;  // Two pixels
                }
            }

            lpDstLine += iBytesLine; // One scanline
            lpSrcLine += iBytesLine << 1;  // Four scanlines
        }
    }
#endif // HQ_FACTOR == 2
    return fRet;
}

#pragma optimize( "", on )

/*==========================================================================*/

void CSGrfx::OnTimer(DWORD dwTime)
{
    VARIANT_BOOL vBool;
    HRESULT hr = S_OK;

    // Always update current time...
    m_dblTime = (dwTime / 1000.0) - m_dblStartTime;

    // Leave early if 
    if (!m_fNeedOnTimer)
        return;

    if (m_fHighQuality && m_fHQStarted)
    {
        hr = m_HQViewPtr->Tick(m_dblTime, &vBool);
    }
    else
    {
        hr = m_ViewPtr->Tick(m_dblTime, &vBool);
    }

    if (SUCCEEDED(hr))
    {
        if (vBool)
        {
            // Let the regular rendering path take care of this...
            InvalidateControl(NULL, TRUE);
        }
    }
}

/*==========================================================================*/

#ifdef SUPPORTONLOAD
void
CSGrfx::OnWindowLoad (void)
{
    m_fOnWindowLoadFired = true;
}

/*==========================================================================*/

void
CSGrfx::OnWindowUnload (void)
{
    m_fOnWindowLoadFired = false;
    StopModel();
}

/*==========================================================================*/

#endif //SUPPORTONLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\builddef.h ===
#ifndef _BUILDDEF_H
#define _BUILDDEF_H

#define BUG318

// #define STRICT
#define SHOW_PARAM_PAGES_IN_AV

#endif // _BUILDDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\bitfield.h ===
#ifndef INC_BITFIELD_H_
#define INC_BITFIELD_H_
/*************************************
 *
 * Bitfield.h --
 * A quick-n'-dirty, fixed-size bitfield
 * class.
 *
 * Author: Norm Bryar     Apr., '97
 *
 *************************************/

namespace bargain {

	template< int N >
	class CBitField
	{
	public:
		CBitField( )
		{  
			for( int i=0; i<ctBytes; ++i )
				m_bits[i] = 0;
		}

		inline BOOL  Set( int bit )
		{
			BOOL fPrevious;
			int  idx   = bit / 8;
			BYTE mask = (1u << (bit % 8));

			fPrevious = !!(m_bits[ idx ]  & mask);
			m_bits[ idx ]  |= mask;
			return fPrevious;
		}

		inline BOOL  Clear( int bit )
		{
			BOOL fPrevious;
			int  idx   = bit / 8;
			BYTE mask = (1u << (bit % 8));

			fPrevious = !!(m_bits[ idx ]  & mask);
			m_bits[ idx ]  &= ~mask;
			return fPrevious;
		}

		inline BOOL operator[](int bit )
		{
			int  idx   = bit / 8;
			BYTE mask = (1u << (bit % 8));
			return !!(m_bits[ idx ] & mask);
		}

	private:
		enum { ctBytes = (N+7)/8 };
		BYTE   m_bits[ ctBytes ];	
	};

}; // end namespace bargain

#endif // INC_BITFIELD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\auto_ptr.h ===
/*-------------------------------------------------

  auto_ptr.h--
  auto_ptr declarations.
  (Just until VC implements their own).

  An auto_ptr automatically 
  frees its pointer in it's destructor,
  thus making it exception-safe and
  making all clean-up code implicit, beacuse
  objects are guaranteed to be destroyed
  when control leaves the containing scope.

  Caveats are marked with "note:" below.

  --USAGE:-----------------------------
  
  auto_ptr<CClass> pClass(new CClass);
  if( !pClass )
    // oopse, pClass did not allocate
  pClass->any_member_of_cclass
  *pClass.any_member_of_cclass


  auto_rg<CClass> prgClass( new CClass[5] );
  prgClass[2].member_of_cclass


  auto_com<IFace> pIface(ptr_to_real_interface); 
        or
  auto_com<IFace> pIface;
  CoGetMalloc( MEMCTX_TASK, &pIFace );
  pIFace->HeapMinimize();  // etc.
       or
  QueryInterface( IID_IDispatch, pIFace.SetVFace() ); //void **
  blahblah( pIFace.SetIFace() ); // IFace ** same as &pIFace

  -------------------------------------

  note: for all auto_... classes, assignment transfers ownership
  e.g. lvalautoptr = rvalautoptr;  
  means rvalautoptr's dtor will *not* free resources, but
  lvalautoptr has dumped whatever it did hold and will now
  free rvalautoptr's resource if rval was the rightful owner.

  -------------------------------------

  You can use auto_ptr instances both as locals
  and as class members.  An exception-safe alloc
  could go like this.

  class X
  {
        ...
        auto_rg<int> m_intarray1;
        auto_rg<int> m_intarray2;
  }

  X::X( )
  {
        auto_rg<int>  temp_intarray1( new int[500] );
        auto_rg<int>  temp_intarray2( new int[500] );
        // Either temp_ throws exception? Both temps clean-up automatically

        // No exceptions? transfer ownership to members
        // Resources will be automatically freed when X deletes
        temp_intarray1.TransferTo( m_intarray1 );
        temp_intarray2.TransferTo( m_intarray2 );        
  }

  Transfer a local auto_ptr to a real-live pointer by

        auto_ptr<X>  tempX( new X );
        pX = tempX.Relenquish();
  
        -----------------------------

  Norm Bryar    April, '96    Hammer 1.0
                Dec.,  '96    IHammer 1.0
				May 28, '97   VC5.0: auto_com copy-ctor, explicit

  Review(normb): consider making all derivations 
  from auto_base protected instead of public;
  there are no virtuals here, so no possible polymorphism.

  ------------------------------------------------*/
#ifndef INC_AUTO_PTR_H_
#define INC_AUTO_PTR_H_

namespace IHammer {

    #ifndef MEMBER_TEMPLATES_SUPPORTED
        // If member templates are not supported, we can't
        // assign or copy an auto_ptr to a derived class to
        // an auto_ptr of a base class quite as expected.
        // In VC5, allegedly these are supported.  Review(normb) True?
      #pragma message( "Member templates not supported" )
    #endif // MEMBER_TEMPLATES_SUPPORTED

        // The explicit keyword prevents implicit type conversion
        // when the compiler searches for methods to apply to the given type.
        // For instance, 
        //     array<int> a[5];  array<int> b[5];   if( a == b[i] )
        // would implcitly construct a temporary array of one item, b[i],
        // and compare 'a' to this temp array.  We'd rather the array ctor
        // not get called, rather the compiler to error.  
        // VC4 doesn't support this!
#if _MSC_VER < 1100
    #define explicit
#endif // pre VC5


    ////////////////////// auto_base class ////////////////        
    template<class T>
    class auto_base
    {
    public:
        explicit auto_base(T *p=NULL);

    protected:
            // note: That's right, you can't destroy auto_base!
            // I don't want this class instantiated, but I'm
            // not willing to incur vtable overhead 
            // just to make the class abstract.
        ~auto_base();

    public:
    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        auto_base(const auto_base<U>& rhs);

        template<class U>
        auto_base<T>& operator=(const auto_base<U>& rhs);
    #else
        auto_base(const auto_base<T>& rhs);
        auto_base<T>& operator=(const auto_base<T>& rhs);
    #endif // MEMBER_TEMPLATES_SUPPORTED        

        #pragma warning( disable: 4284 )
        // note: only use -> when T represents a class or struct
        T* operator->() const;
        #pragma warning( default: 4284 )
        
        BOOL operator!() const; // NULL-ptr test: if(!autoPtr)
        
        // If you just can't resist getting your hands on the dumb pointer
        // Preferable to defining operator void*, which lets us compare
        // pointers w/o respect for type.       
        T* Get() const;

    protected:
            // Typically deletes owned ptr, 
            // then points to p w/o taking ownership
            // note: not virtual for speed and size reasons
            // yet every derived class will implement this
            // differently; any base-class method calling
            // Reset must be re-implemented in derived classes
            // to invoke the proper Reset().
        void Reset(T *p=NULL);  

    protected:
        T     *m_ptr;
    };


    template<class T>
    inline auto_base<T>::auto_base( T * p) : m_ptr(p)
    { NULL; }


    template<class T>
    inline auto_base<T>::~auto_base( )
    { NULL; }        


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_base<T>::auto_base(const auto_base<U>& rhs)
    #else
    inline auto_base<T>::auto_base(const auto_base<T>& rhs)
    #endif
      : m_ptr(rhs.m_ptr)
    { NULL; }


        // see copy ctor note
    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_base<T>& auto_base<T>::operator=(const auto_base<U>& rhs)
    #else
    inline auto_base<T>& auto_base<T>::operator=(const auto_base<T>& rhs)
    #endif
    {         
            // protect against us = us;
        if( this != &rhs )
            Reset( rhs.m_ptr );
        return *this;
    }
    

    template<class T>
    inline T* auto_base<T>::operator->() const
    {  return m_ptr; }


    template<class T>
    inline BOOL auto_base<T>::operator!() const
    { return NULL == m_ptr; }


    template<class T>
    inline T* auto_base<T>::Get() const
    {  return m_ptr; }


    template<class T>
    inline void auto_base<T>::Reset( T *p)
    {  m_ptr = p; }



    //////////////////////// auto_ptr class //////////////////////
        
    template<class T>
    class auto_ptr : public auto_base<T>
    {
    public:
        explicit auto_ptr(T *p=NULL);
        ~auto_ptr();

    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        auto_ptr(const auto_ptr<U>& rhs);

        template<class U>
        auto_ptr<T>& operator=(auto_ptr<U>& rhs);
      
        template<class U>
        void TransferTo( auto_ptr<U>& rhs );
    
    #else
        auto_ptr(const auto_ptr<T>& rhs);
        auto_ptr<T>& operator=(auto_ptr<T>& rhs);
        void TransferTo( auto_ptr<T>& rhs );
    #endif // MEMBER_TEMPLATES_SUPPORTED

        T& operator*() const;

            // Like Get() but relenquishes ownership
        T * Relenquish( void );

    protected:
        void Reset(T *p=NULL);  // delete owned ptr, assume p.

    
            // operator void * is protected so you can't call
            //         delete pauto_ptr 
            // We can later define an operator T*() and still have
            // this errant-delete safe-guard; compiler will err
            // on ambiguity between T* and void* conversion ops.
        operator void *() const
        { return NULL; }

    protected:        
        BOOL  m_fOwner;

        friend BOOL operator==( const auto_ptr<T> &lhs,
                                const auto_ptr<T> &rhs );
    };


    template<class T>
    inline auto_ptr<T>::auto_ptr( T *p ) : auto_base<T>(p), m_fOwner(TRUE)
    { NULL; }


    template<class T>
    inline auto_ptr<T>::~auto_ptr()
    { 
        Reset( );
        m_fOwner = FALSE;
    }


        // note: when an auto_ptr is assigned or copied,
        // ownership of the dumb-ptr is *not* transferred.
        // We don't want to delete the dumb-ptr twice when
        // both auto_ptrs destroy.  The dumb-ptr deletes when
        // the origional auto_ptr goes out of scope.
    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_ptr<T>::auto_ptr(const auto_ptr<U>& rhs) : auto_base<T>(rhs)
    #else
    inline auto_ptr<T>::auto_ptr(const auto_ptr<T>& rhs) : auto_base<T>(rhs)
    #endif      
    { m_fOwner = FALSE; }


        // see copy ctor note
    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<U>& rhs)
    #else
    inline auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<T>& rhs)
    #endif            
    {         
            // protect against us = us;
        if( this != &rhs )      
        {
			rhs.TransferTo( *this );
        }
        return *this;
    }


    template<class T>
    inline T& auto_ptr<T>::operator*() const
    {  return *m_ptr; }


    template<class T>
    inline T * auto_ptr<T>::Relenquish( void )
    {  
        m_fOwner = FALSE;
        return Get( );
    }


    template<class T>
    inline void auto_ptr<T>::Reset( T *p)
    {  
        if( m_fOwner )
            delete m_ptr;
        auto_base<T>::Reset( p );  //m_ptr = p;
    }


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline void auto_ptr<T>::TransferTo( auto_ptr<U>& rhs )
    #else
      inline void auto_ptr<T>::TransferTo( auto_ptr<T>& rhs )
    #endif
    {
        BOOL fIOwnIt = m_fOwner;

        rhs.Reset( Get() );
		m_fOwner = FALSE;
        rhs.m_fOwner = fIOwnIt;        
    }


    template<class T>
    inline BOOL operator==( const auto_ptr<T> &lhs,
                            const auto_ptr<T> &rhs )
    {
        return lhs.m_ptr == rhs.m_ptr;
    }


    template<class T>
    inline BOOL operator!=( const auto_ptr<T> &lhs,
                            const auto_ptr<T> &rhs )
    {
        return !(lhs == rhs);
    }



    ///////////////////////// auto_rg class //////////////////////
            
    template<class T>
    class auto_rg : protected auto_ptr<T>
    {
    public:
        explicit auto_rg(T *p=NULL);
        ~auto_rg();

    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        auto_rg( const auto_rg<U>& rhs);   // copy ctor
        template<class U>
        auto_rg<T>& operator=(auto_rg<U>& rhs);
    #else
        auto_rg(const auto_rg<T>& rhs);   // copy ctor
        auto_rg<T>& operator=(auto_rg<T>& rhs);
    #endif // MEMBER_TEMPLATES_SUPPORTED

     T& operator[](int idx);

     const T & operator[](int idx) const;

     #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        void TransferTo( auto_rg<U>& rhs );
    #else        
        void TransferTo( auto_rg<T>& rhs );
    #endif // MEMBER_TEMPLATES_SUPPORTED

        // Methods valuable to auto_rg, too.
     using auto_ptr<T>::operator!;
     using auto_ptr<T>::Get;
     using auto_ptr<T>::Relenquish;

    protected:
        void Reset(T *p=NULL);

        friend BOOL operator==( const auto_rg<T> &lhs,
                                const auto_rg<T> &rhs );
    };

    
    template<class T>
    inline auto_rg<T>::auto_rg( T *p ) : auto_ptr<T>(p)
    { NULL; }


    template<class T>
    inline auto_rg<T>::~auto_rg()
    { 
        Reset();
        m_fOwner = FALSE;
    }
    

    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_rg<T>::auto_rg(const auto_rg<U>& rhs)
    #else
    inline auto_rg<T>::auto_rg(const auto_rg<T>& rhs)
    #endif
        : auto_ptr<T>(rhs)
    { NULL; }


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_rg<T>& auto_rg<T>::operator=(auto_rg<U>& rhs)
    #else
    inline auto_rg<T>& auto_rg<T>::operator=(auto_rg<T>& rhs)
    #endif
    {         
        if( this != &rhs )      
        {
			rhs.TransferTo( *this );            
        }
        return *this;
    }

    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline void auto_rg<T>::TransferTo( auto_rg<U>& rhs )
    #else        
    inline void auto_rg<T>::TransferTo( auto_rg<T>& rhs )
    #endif // MEMBER_TEMPLATES_SUPPORTED
    {          
          // Looks exactly like auto_ptr<T>::TransferTo,
          // but we can't call that implementation because
          // Reset is not virtual for speed's-sake.
		BOOL fIOwnIt = m_fOwner;

        rhs.Reset( Get() );
		m_fOwner = FALSE;
        rhs.m_fOwner = fIOwnIt;
    }


    template<class T>
    inline T& auto_rg<T>::operator[](int idx)
    {  return m_ptr[idx]; }


    template<class T>
    inline const T & auto_rg<T>::operator[](int idx) const
    {  return m_ptr[idx]; }


    template<class T>
    inline void auto_rg<T>::Reset( T *p)
    {
        if( m_fOwner )
            delete [] m_ptr;
        m_ptr = p;
    }


    template<class T>
    inline BOOL operator==( const auto_rg<T> &lhs,
                            const auto_rg<T> &rhs )
    {
        return lhs.m_ptr == rhs.m_ptr;
    }


    template<class T>
    inline BOOL operator!=( const auto_rg<T> &lhs,
                            const auto_rg<T> &rhs )
    {
        return !(lhs == rhs);
    }



    ///////////////////////// auto_com class /////////////////////
		// By the rules of COM, if you have a pointer, you're an owner  
    template<class T>
    class auto_com : public auto_base<T>
    {
    public:
        explicit auto_com(T *p=NULL); // default ctor

        ~auto_com();

        void * * SetVFace( void );
        T * *    SetIFace( void );
        T * *    operator&( void );
        
    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        auto_com( const auto_com<U>& rhs );
        
        template<class U>
        auto_com<T>& operator=(const auto_com<U>& rhs);
    #else
        auto_com( const auto_com<T>& rhs );
        auto_com<T>& operator=(const auto_com<T>& rhs);
    #endif // MEMBER_TEMPLATES_SUPPORTED

        T * Relenquish( void );

    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        void TransferTo( auto_com<U>& rhs );    
    #else        
        void TransferTo( auto_com<T>& rhs );
    #endif // MEMBER_TEMPLATES_SUPPORTED

    protected:
        void Reset( T *p=NULL );
        
        friend BOOL operator==( const auto_com<T> &lhs,
                                const auto_com<T> &rhs );	
    };


    template<class T>
    inline auto_com<T>::auto_com( T *p ) : auto_base<T>(p)
    { NULL; }

        
    template<class T>
    inline auto_com<T>::~auto_com()
    { 
        Reset( );  // note: C4702:unreachable code is benign here		
    }
    


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_com<T>::auto_com(const auto_com<U>& rhs)
    #else
    inline auto_com<T>::auto_com(const auto_com<T>& rhs)
    #endif
      : auto_base<T>(rhs.Get())
    { Get()->AddRef(); }


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_com<T>& auto_com<T>::operator=(const auto_com<U>& rhs)
    #else
    inline auto_com<T>& auto_com<T>::operator=(const auto_com<T>& rhs)
    #endif
    {
		    // protect against us = us;
        if( this != &rhs )      
        {
            Reset( rhs.Get() );            
        }
        return *this;        
    }
    
    
    template<class T>
    inline void * * auto_com<T>::SetVFace( void )
    {
        return (void * *) &m_ptr;
    }


    template<class T>
    inline T * * auto_com<T>::SetIFace( void )
    {
        return &m_ptr;
    }


    template<class T>
    inline T * * auto_com<T>::operator&( void )
    {
        return &m_ptr;
    }


    template<class T>
    inline T * auto_com<T>::Relenquish( void )
    {   
		Get()->AddRef( );	// We're giving away a pointer
							// we're going to Release in our dtor
        return Get();
    }



	    //note: occurrences of Reset() or Reset(NULL) will inline
        //an always-false if(NULL != p), unreachable code warning.
    #pragma warning( disable : 4702 )
    template<class T>
    inline void auto_com<T>::Reset( T *p)
    {   
		if( NULL != p )
			p->AddRef( );
		if( NULL != m_ptr )
			m_ptr->Release( );		
        m_ptr = p;
    }
    #pragma warning( default : 4702 )



    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        inline void auto_com<T>::TransferTo( auto_com<U>& rhs )
    #else        
    inline void auto_com<T>::TransferTo( auto_com<T>& rhs )
    #endif // MEMBER_TEMPLATES_SUPPORTED
    {
		rhs.Reset( Get() );		
    }


    template<class T>
    inline BOOL operator==( const auto_com<T> &lhs,
                            const auto_com<T> &rhs )
    {
        return lhs.m_ptr == rhs.m_ptr;
    }


    template<class T>
    inline BOOL operator!=( const auto_com<T> &lhs,
                            const auto_com<T> &rhs )
    {
        return !(lhs == rhs);
    }


    ///////////////////////// end /////////////////////

} // end namespace IHammer

#endif // INC_AUTO_PTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\actdata.h ===
#ifndef __ACTDATA_H__
#define __ACTDATA_H__

const DWORD g_dwTimeInfinite = (DWORD)(~0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\context.h ===
/*************************************************
CONTEXT.H:

Public header file used by users of Context Menus.

*************************************************/

#ifndef __CONTEXT_H__
#define __CONTEXT_H__

// Shared context message codes...
#define CM_ERROR                -1 // An error occurred
#define CM_CANCELLED            0  // Cancelled operation
#define CM_COMPLETED            1  // Completed operation
#define CM_CUTOBJECT            2  // Instruct Shell to Cut Object
#define CM_COPYOBJECT           3  // Instruct Shell to Copy Object
#define CM_PASTEOBJECT          4  // Instruct Shell to Paste Object
#define CM_DELETEOBJECT         5  // Instruct Shell to Delete Object
#define CM_OBJECTPROPERTIES     6  // Instruct Shell to launch Object Properties
#define CM_PLAYOBJECT           7  // Instruct Shell to Play Object
#define CM_STOPOBJECT           8  // Instruct Shell to Stop Object
#define CM_REWINDOBJECT         9  // Instruct Shell to Rewind Object
#define CM_COMMAND             10  // Instruct Shell to issue Command (string defined in lParam)
#define CM_EDITOBJECT          11  // Instruct Shell to launch object editor
#define CM_IMPORTOBJECTDATA    12  // Instruct Shell to launch object import dialog
#define CM_STEPOBJECTFWD       13  // Instruct Shell to step object forward
#define CM_STEPOBJECTBACK      14  // Instruct Shell to step object backward
#define CM_ACTIVATEOBJECT      15  // Instruct Shell to Activate (Deactivate) object
#define CM_RENAMEOBJECT        16  // Instruct Shell to Rename Object
#define CM_ASSIGNMEDIA         17  // Instruct Shell to Assign media to the object
#define CM_DELETESCENE         18  // Instruct Shell to Delete current scene
#define CM_SELECTALL           19  // Instruct to select all items
#define CM_MOVEUP              20  // Instruct to promote an item
#define CM_MOVEDOWN            21  // Instruct to demote an item
#define CM_CREATENEW           22  // Instruct to make a new item
#define CM_ZOOMIN              23  // Instruct to magnify view
#define CM_ZOOMOUT             24  // Instruct to diminish view

#define CM_CUSTOM            4000  // Base for Custom Context Messages...

#define CM_MESSAGE_ID_STRING  "Context Menu Message" // Do NOT localize!

// Use this macro to get the context message id
#define GetContextMenuID() (::RegisterWindowMessage(CM_MESSAGE_ID_STRING))

#endif // __CONTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\avl.h ===
#include <iostream.h>
#include <iomanip.h>
#include <ctype.h>

template <class T>
class CAVLNode
{
    friend class CAVLTree<T>;
    int       m_iBal;
    CAVLNode<T>* m_pLeft;
    CAVLNode<T>* m_pRight;
    T         m_T;
 
    CAVLNode( T Element = 0, CAVLNode *L = NULL, CAVLNode *R = NULL ) : 
        m_T( Element ), m_pLeft( L ), m_pRight( R ), m_iBal(0) {}
};



template <class T>
class CAVLTree
{
public:
    CAVLTree():m_pRoot(NULL){}
    void Insert(T& t) {ins(m_pRoot, t);}
    void Remove(T& t) {del(m_pRoot, t);}
    void Print() const {pr(m_pRoot, 0);}
private:
    CAVLNode<T>* m_pRoot;
    void LeftRotate(CAVLNode<T>* &p);
    void RightRotate(CAVLNode<T>* &p);
    int ins(CAVLNode<T>* &p, T& t);
    int del(CAVLNode<T>* &p, T& t);
#ifdef DO_STDOUT
    void pr(const CAVLNode<T> *p, int nSpace)const;
#endif //DO_STDOUT
};



template <class T>
void CAVLTree<T>::LeftRotate(CAVLNode<T>* &p)
{  CAVLNode<T> *q = p;
   p = p->m_pRight;
   q->m_pRight = p->m_pLeft;
   p->m_pLeft = q;
   q->m_iBal--;
   if (p->m_iBal > 0) q->m_iBal -= p->m_iBal;
   p->m_iBal--;
   if (q->m_iBal < 0) p->m_iBal += q->m_iBal;
}

template <class T>
void CAVLTree<T>::RightRotate(CAVLNode<T>* &p)
{  CAVLNode<T> *q = p;
   p = p->m_pLeft;
   q->m_pLeft = p->m_pRight;
   p->m_pRight = q;
   q->m_iBal++;
   if (p->m_iBal < 0) q->m_iBal -= p->m_iBal;
   p->m_iBal++;
   if (q->m_iBal > 0) p->m_iBal += q->m_iBal;
}

template <class T>
int CAVLTree<T>::ins(CAVLNode<T>* &p, T& t)
{  // Return value: increase in height (0 or 1) after
   // inserting x in the (sub)tree with root p
   int deltaH=0;
   if (p == NULL)
   {  
      p = new CAVLNode<T>(t);
      deltaH = 1; // Tree height increased by 1
   }  
   else
   if (t > p->m_T)
   {  if (ins(p->m_pRight, t))
      {  p->m_iBal++; // Height of right subtree increased 
         if (p->m_iBal == 1) deltaH = 1; else
         if (p->m_iBal == 2)
         {  if (p->m_pRight->m_iBal == -1) RightRotate(p->m_pRight);
            LeftRotate(p);
         }
      }
   }  
   else
   if (t < p->m_T)
   {  if (ins(p->m_pLeft, t))
      {  p->m_iBal--; // Height of left subtree increased 
         if (p->m_iBal == -1) deltaH = 1; else
         if (p->m_iBal == -2)
         {  if (p->m_pLeft->m_iBal == 1) LeftRotate(p->m_pLeft);
            RightRotate(p);
         }
      }
   }
   return deltaH;
}



/* Return value: decrease in height (0 or 1) of subtree
   with root p, after deleting the node with key x.
   (If there is no such node, 0 will be returned.)
*/

template <class T>
int CAVLTree<T>::del(CAVLNode<T>* &p, T& t)
{  
   CAVLNode<T>** qq, *p0;
   int deltaH=0;
   if (p == NULL) return 0;
   if (t < p->m_T)
   {  if (del(p->m_pLeft, t))
      {  p->m_iBal++; // Height left subtree decreased
         if (p->m_iBal == 0) deltaH = 1; else
         if (p->m_iBal == 2)
         {  if (p->m_pRight->m_iBal == -1) RightRotate(p->m_pRight);
            LeftRotate(p);
            if (p->m_iBal == 0) deltaH = 1;
         }
      }
   }  else
   if (t > p->m_T)
   {  if (del(p->m_pRight, t))
      {  p->m_iBal--; // Height right subtree decreased
         if (p->m_iBal == 0) deltaH = 1; else
         if (p->m_iBal == -2)
         {  if (p->m_pLeft->m_iBal == 1) LeftRotate(p->m_pLeft);
            RightRotate(p);
            if (p->m_iBal == 0) deltaH = 1;
         }
      }
   }  else  // t == p->m_T
   {  if (p->m_pRight == NULL)
      {  p0 = p; p = p->m_pLeft; delete p0; return 1;
      }  else
      if (p->m_pLeft == NULL)
      {  p0 = p; p = p->m_pRight; delete p0; return 1;
      }  else
      {  qq = & p->m_pLeft;
         while ((*qq)->m_pRight != NULL) qq = & (*qq)->m_pRight;
         p->m_T = (*qq)->m_T;
         (*qq)->m_T = t;
         if (del(p->m_pLeft, t))
         {  p->m_iBal++; // Height left subtree decreased
            if (p->m_iBal == 0) deltaH = 1; else
            if (p->m_iBal == 2)
            {  if (p->m_pRight->m_iBal == -1) RightRotate(p->m_pRight);
               LeftRotate(p);
               if (p->m_iBal == 0) deltaH = 1;
            }
         }
      }
   }
   return deltaH;
}

#ifdef DO_STDOUT

template <class T>
void CAVLTree<T>::pr(const CAVLNode<T> *p, int nSpace)const
{  if (p != NULL)
   {  pr(p->m_pRight, nSpace+=6);
      cout << setw(nSpace) << p->m_T << " " << p->m_iBal << endl;
      pr(p->m_pLeft, nSpace);
   }
}

#endif //DO_STDOUT

int main()
{  int x;
   char ch;
   CAVLTree<int> t;

	for (x = 0; x < 100; x++)
		t.Insert(x);

	t.Print();

    cout << "-------------------------------------------\n";

    for (x = 0; x < 100; x++)
        t.Remove(x);

	t.Print();

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\ctstr.h ===
/*++

Module:
	cstr.h

Description:
	Header for TSTR wrapper class

Author:
	Simon Bernstein (simonb)

--*/

#include <ihammer.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN

#ifndef __CTSTR_H__
#define __CTSTR_H__

class CTStr
{
public:
	EXPORT CTStr(LPWSTR pszStringW);       // Construct with Unicode string
	EXPORT CTStr(LPSTR pszStringA);        // Construct with ANSI string
	EXPORT CTStr(int iAllocateLength = 0); // Default constructor (optional preallocate)
	EXPORT CTStr(CTStr &rhs);              // Copy constructor
	
	EXPORT ~CTStr();
	
	EXPORT BOOL SetString(LPWSTR pszStringW);
	EXPORT BOOL SetString(LPSTR pszStringA);
	EXPORT BOOL SetStringPointer(LPTSTR pszString, BOOL fDealloc = TRUE);
	EXPORT BOOL AllocBuffer(int iAllocateLength, BOOL fDealloc = TRUE);
	EXPORT void FreeBuffer();

	EXPORT BSTR SysAllocString();

	EXPORT LPTSTR psz() {return m_pszString;}
	EXPORT LPSTR pszA();
	EXPORT LPWSTR pszW();
	EXPORT int Len() {return m_iLen;}
	EXPORT void ResetLength();

private:
	LPTSTR m_pszString;
	int m_iLen;

	int UNICODEToANSI(LPSTR pchDst, LPCWSTR pwchSrc, int cchDstMax);
	int ANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc, int cwchDstMax);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\cbtree.h ===
// cbtree.h place holder
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\dds_bs.h ===
#ifndef INC_DDS_BS_H_
#define INC_DDS_BS_H_
/***********************************************
 *
 *  DDS_BS.h --
 *  Adapter class to make an IBitmapSurface fit
 *  clients using IDirectDrawSurface.
 *
 *  Author:  Norm Bryar
 *  History:
 *		4/22/97 - Created
 *
 **********************************************/

#ifndef  __DDRAW_INCLUDED__
  #include <ddraw.h>
#endif // __DDRAW_INCLUDED__

	// forward declares
	struct lockpair;
	struct IBitmapSurface;
	class  lockcollection;


	class CDDSBitmapSurface : public IDirectDrawSurface
	{
	public:
		EXPORT CDDSBitmapSurface( IBitmapSurface * pibs );	   

		virtual ~CDDSBitmapSurface( );	

		STDMETHOD(QueryInterface)( REFIID riid, void * * ppv );

		STDMETHOD_(ULONG,   AddRef)( void );

		STDMETHOD_(ULONG,   Release)( void );

			// --- IDirectDrawSurface methods ---
		STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE);
		STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT);
		STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
		STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD );
		STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD);
		STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE);
		STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK);
		STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK);
		STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD);
		STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
		STDMETHOD(GetBltStatus)(THIS_ DWORD);
		STDMETHOD(GetCaps)(THIS_ LPDDSCAPS);
		STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*);
		STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY);
		STDMETHOD(GetDC)(THIS_ HDC FAR *);
		STDMETHOD(GetFlipStatus)(THIS_ DWORD);
		STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG );
		STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*);
		STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT);
		STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC);
		STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC);
		STDMETHOD(IsLost)(THIS);
		STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE);
		STDMETHOD(ReleaseDC)(THIS_ HDC);
		STDMETHOD(Restore)(THIS);
		STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER);
		STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY);
		STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG );
		STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE);
		STDMETHOD(Unlock)(THIS_ LPVOID);
		STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX);
		STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD);
		STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE);

	private:
		HRESULT  AddLockPair( lockpair & lp );
		HRESULT  RemoveLockPair( void * pv );
		HRESULT  UpdatePixFormat( void );	

	private:		
		IBitmapSurface * m_pibs;
		ULONG            m_ctRef;
		lockcollection * m_plockcollection;
		int              m_ctPairs;
		DDPIXELFORMAT    m_ddpixformat;

		friend  lockcollection;
	};	

#endif // INC_DDS_BS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\debug.h ===
/*********************************************************
MODULE: DEBUG.H
AUTHOR: Outlaw     

summer '93

DESCRIPTION: Header for debugging functions.
**********************************************************/

#ifndef __DEBUG_H
#define __DEBUG_H            

#include <windows.h>
#include <assert.h>
      
/*==================================================================================================*/

#ifndef EXPORT
#define EXPORT __declspec(dllexport)
#endif
                         
    void EXPORT FAR CDECL RetailEcho(LPSTR lpstr, ...);
                             
#ifdef _DEBUG
    void EXPORT WINAPI AssertDebugBreak(BOOL f, LPSTR lpstrAssert, LPSTR lpstrFile, UINT uLine);
    void EXPORT WINAPI AssertDebugBreakMessage(BOOL f, LPSTR lpstrAssert, LPSTR lpstrFile, UINT uLine, LPSTR lpMessage);
    void EXPORT FAR CDECL OldEcho(LPSTR lpstr, ...);

#define Proclaim(x)     if (!(x)) { AssertDebugBreak((x) ? TRUE : FALSE, #x, (LPSTR)__FILE__, (UINT)__LINE__); }

#define ProclaimMessage(x, y)  if (!(x)) { AssertDebugBreakMessage((x) ? TRUE : FALSE, #x, (LPSTR)__FILE__, (UINT)__LINE__, (LPSTR)y); }

	void 	EXPORT WINAPI InitMemFailSim(BOOL	fFail);
	BOOL	EXPORT WINAPI FMemFailOn();
	void	SetCountMemFailSim(long cFail);
	long	CFailGetMemFailSim();
	void	EXPORT WINAPI ResetAndIncMemFailSim();
	BOOL	FFailMemFailSim();
	void	EXPORT WINAPI MemSimDlg(HWND	hwnd);
	LONG	EXPORT WINAPI LIdGetVbDlg(HWND	hwnd);
#else
    #define Proclaim(x)     void(0)
	#define ProclaimMessage(x, y)  void(0)
#endif                                  
    
    // We NEVER care about this...
    inline void FAR CDECL Echo(LPSTR lpstr, ...) {}

#ifdef _DEBUG
     #define ProclaimShortFileName(x)   assert((lstrlen(x) < CCH_SHORT_FILENAME) && !_fstrchr(x, ':') && !_fstrchr(x, '\\'))
#else
     #define ProclaimShortFileName(x) void(0)
#endif

// Added by VK
#ifdef _DEBUG
	void EXPORT ShowWndProcParams ( HINSTANCE hInst, LPCSTR name, HWND hwnd, UINT message, UINT wParam, LONG lParam );
	void SetWndProcParamsRange ( UINT uMin, UINT uMax );
#else
	#define ShowWndProcParams(x1,x2,x3,x4,x5,x6) void(0)
	#define SetWndProcParamsRange(x1,x2) void(0)
#endif

/*=====================================================================================================*/      
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\dispids.h ===
/*++

Module: 
	dispids.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Lists DISPIDS for the DA/IHammer control object model

History:
    05-27-1997  Added SGrfx control ID's
    05-27-1997  Added sound control ID's
	05-24-1997	Created

++*/

#ifndef __DISPIDS_H__
#define __DISPIDS_H__


//////////////////////////////////////////////////////////////////
// Path control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_PATH_PROP_BASE             1

#define DISPID_PATH_PROP_TARGET           (DISPID_PATH_PROP_BASE + 0)
#define DISPID_PATH_PROP_DURATION         (DISPID_PATH_PROP_BASE + 1)
#define DISPID_PATH_PROP_REPEAT           (DISPID_PATH_PROP_BASE + 2)
#define DISPID_PATH_PROP_BOUNCE           (DISPID_PATH_PROP_BASE + 3)
#define DISPID_PATH_PROP_PLAYSTATE        (DISPID_PATH_PROP_BASE + 4)
#define DISPID_PATH_PROP_TIME             (DISPID_PATH_PROP_BASE + 5)
#define DISPID_PATH_PROP_DIRECTION        (DISPID_PATH_PROP_BASE + 6)
#define DISPID_PATH_PROP_PATH             (DISPID_PATH_PROP_BASE + 7)
#define DISPID_PATH_PROP_LIBRARY          (DISPID_PATH_PROP_BASE + 8)
#define DISPID_PATH_PROP_TIMERINTERVAL    (DISPID_PATH_PROP_BASE + 9)
#define DISPID_PATH_PROP_RELATIVE         (DISPID_PATH_PROP_BASE + 10)
#define DISPID_PATH_PROP_AUTOSTART        (DISPID_PATH_PROP_BASE + 11)
		
//
// Methods (start after properties)

#define DISPID_PATH_METH_BASE             (DISPID_PATH_PROP_BASE + 12)

#define DISPID_PATH_METH_STOP             (DISPID_PATH_METH_BASE + 0)
#define DISPID_PATH_METH_PAUSE            (DISPID_PATH_METH_BASE + 1)
#define DISPID_PATH_METH_PLAY             (DISPID_PATH_METH_BASE + 2)
#define DISPID_PATH_METH_SPIRAL           (DISPID_PATH_METH_BASE + 3)
#define DISPID_PATH_METH_OVAL             (DISPID_PATH_METH_BASE + 4)
#define DISPID_PATH_METH_RECT             (DISPID_PATH_METH_BASE + 5)
#define DISPID_PATH_METH_POLYLINE         (DISPID_PATH_METH_BASE + 6)
#define DISPID_PATH_METH_POLYGON          (DISPID_PATH_METH_BASE + 7)
#define DISPID_PATH_METH_KEYFRAME         (DISPID_PATH_METH_BASE + 8)
#define DISPID_PATH_METH_ADDTIMEMARKER    (DISPID_PATH_METH_BASE + 9)
#define DISPID_PATH_METH_SPLINE           (DISPID_PATH_METH_BASE + 10)
#define DISPID_PATH_METH_SEEK             (DISPID_PATH_METH_BASE + 11)

//
// Events (start from 0; different interface)


#define DISPID_PATH_EVENT_BASE 1

#define DISPID_PATH_EVENT_ONSTOP          (DISPID_PATH_EVENT_BASE + 0)
#define DISPID_PATH_EVENT_ONPLAY          (DISPID_PATH_EVENT_BASE + 1)
#define DISPID_PATH_EVENT_ONPAUSE         (DISPID_PATH_EVENT_BASE + 2)
#define DISPID_PATH_EVENT_ONSEEK          (DISPID_PATH_EVENT_BASE + 3)
#define DISPID_PATH_EVENT_ONPLAYMARKER    (DISPID_PATH_EVENT_BASE + 4)
#define DISPID_PATH_EVENT_ONMARKER        (DISPID_PATH_EVENT_BASE + 5)


//////////////////////////////////////////////////////////////////
// Sound control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_SND_PROP_BASE             1

#define DISPID_SND_PROP_SOURCEURL        (DISPID_SND_PROP_BASE + 0)
#define DISPID_SND_PROP_SOUNDTYPE        (DISPID_SND_PROP_BASE + 1)
#define DISPID_SND_PROP_CLOCK            (DISPID_SND_PROP_BASE + 2)
#define DISPID_SND_PROP_AUTOSTART        (DISPID_SND_PROP_BASE + 3)
#define DISPID_SND_PROP_AUTODOWNLOAD     (DISPID_SND_PROP_BASE + 4)
#define DISPID_SND_PROP_REPEAT           (DISPID_SND_PROP_BASE + 5)
#define DISPID_SND_PROP_PREROLLAMOUNT    (DISPID_SND_PROP_BASE + 6)
#define DISPID_SND_PROP_INITIALVOLUME    (DISPID_SND_PROP_BASE + 7)
#define DISPID_SND_PROP_PLAYSTATE        (DISPID_SND_PROP_BASE + 8)
#define DISPID_SND_PROP_SOUND            (DISPID_SND_PROP_BASE + 9)
#define DISPID_SND_PROP_LIBRARY          (DISPID_SND_PROP_BASE + 10)
//
// Methods (start after properties)

#define DISPID_SND_METH_BASE             (DISPID_SND_PROP_BASE + 11)

#define DISPID_SND_METH_PLAY             (DISPID_SND_METH_BASE + 0)
#define DISPID_SND_METH_PAUSE            (DISPID_SND_METH_BASE + 1)
#define DISPID_SND_METH_STOP             (DISPID_SND_METH_BASE + 2)
#define DISPID_SND_METH_REWIND           (DISPID_SND_METH_BASE + 3)
#define DISPID_SND_METH_ADDSOUND         (DISPID_SND_METH_BASE + 4)
#define DISPID_SND_METH_ADDTIMEMARKER	 (DISPID_SND_METH_BASE + 5)
#define DISPID_SND_METH_SEEK             (DISPID_SND_METH_BASE + 6)
//
// Events (start from 0; different interface)


#define DISPID_SND_EVENT_BASE 1

#define DISPID_SND_EVENT_ONSTOP          (DISPID_SND_EVENT_BASE + 0)
#define DISPID_SND_EVENT_ONPLAY          (DISPID_SND_EVENT_BASE + 1)
#define DISPID_SND_EVENT_ONPAUSE         (DISPID_SND_EVENT_BASE + 2)
#define DISPID_SND_EVENT_ONMEDIALOADED   (DISPID_SND_EVENT_BASE + 3)


//////////////////////////////////////////////////////////////////
// SGrfx control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_SG_PROP_BASE              1

#define DISPID_SG_PROP_SOURCEURL          (DISPID_SG_PROP_BASE + 0) 
#define DISPID_SG_PROP_COORDSYSTEM        (DISPID_SG_PROP_BASE + 1)
#define DISPID_SG_PROP_ENABLEMOUSEEVENTS  (DISPID_SG_PROP_BASE + 2)
#define DISPID_SG_PROP_EXTENTTOP          (DISPID_SG_PROP_BASE + 3)
#define DISPID_SG_PROP_EXTENTLEFT         (DISPID_SG_PROP_BASE + 4)
#define DISPID_SG_PROP_EXTENTWIDTH        (DISPID_SG_PROP_BASE + 5)
#define DISPID_SG_PROP_EXTENTHEIGHT       (DISPID_SG_PROP_BASE + 6)
#define DISPID_SG_PROP_HIQUALITY          (DISPID_SG_PROP_BASE + 7)
#define DISPID_SG_PROP_IMAGE              (DISPID_SG_PROP_BASE + 8)
#define DISPID_SG_PROP_DRAWSURFACE        (DISPID_SG_PROP_BASE + 9)
#define DISPID_SG_PROP_DRAWINGSURFACE     (DISPID_SG_PROP_BASE + 10)
#define DISPID_SG_PROP_LIBRARY            (DISPID_SG_PROP_BASE + 11)
#define DISPID_SG_PROP_TRANSFORM          (DISPID_SG_PROP_BASE + 12)
#define DISPID_SG_PROP_PRESERVEASPECTRATIO (DISPID_SG_PROP_BASE + 13)


//
// Methods  (start after properties)

#define DISPID_SG_METH_BASE              (DISPID_SG_PROP_BASE + 20)

#define DISPID_SG_METH_CLEAR             (DISPID_SG_METH_BASE + 0)
#define DISPID_SG_METH_ROTATE            (DISPID_SG_METH_BASE + 1)
#define DISPID_SG_METH_SCALE             (DISPID_SG_METH_BASE + 2)
#define DISPID_SG_METH_SETIDENTITY       (DISPID_SG_METH_BASE + 3)
#define DISPID_SG_METH_TRANSFORM4X4      (DISPID_SG_METH_BASE + 4)
#define DISPID_SG_METH_TRANSLATE         (DISPID_SG_METH_BASE + 5)
#define DISPID_SG_METH_XSHEAR            (DISPID_SG_METH_BASE + 6)
#define DISPID_SG_METH_YSHEAR            (DISPID_SG_METH_BASE + 7)
#define DISPID_SG_METH_ZSHEAR            (DISPID_SG_METH_BASE + 8)



//
// Events  (start from 0; different interface)


#define DISPID_SG_EVENT_BASE 1

#define DISPID_SG_EVENT_MOUSEMOVE        (DISPID_SG_EVENT_BASE + 0)
#define DISPID_SG_EVENT_MOUSEENTER       (DISPID_SG_EVENT_BASE + 1)
#define DISPID_SG_EVENT_MOUSELEAVE       (DISPID_SG_EVENT_BASE + 2)
#define DISPID_SG_EVENT_MOUSEDOWN        (DISPID_SG_EVENT_BASE + 3)
#define DISPID_SG_EVENT_MOUSEUP          (DISPID_SG_EVENT_BASE + 4)
#define DISPID_SG_EVENT_DBLCLICK         (DISPID_SG_EVENT_BASE + 5)
#define DISPID_SG_EVENT_CLICK            (DISPID_SG_EVENT_BASE + 6)

//////////////////////////////////////////////////////////////////
// Sprite control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_SPRITE_PROP_BASE                 1

#define DISPID_SPRITE_PROP_AUTOSTART            (DISPID_SPRITE_PROP_BASE + 0)
#define DISPID_SPRITE_PROP_FRAME                (DISPID_SPRITE_PROP_BASE + 1)
#define DISPID_SPRITE_PROP_FRAMEMAP             (DISPID_SPRITE_PROP_BASE + 2)
#define DISPID_SPRITE_PROP_INITIALFRAME         (DISPID_SPRITE_PROP_BASE + 3)
#define DISPID_SPRITE_PROP_ITERATIONS           (DISPID_SPRITE_PROP_BASE + 4)
#define DISPID_SPRITE_PROP_REPEAT               (DISPID_SPRITE_PROP_BASE + 5)
#define DISPID_SPRITE_PROP_PLAYRATE             (DISPID_SPRITE_PROP_BASE + 6)
#define DISPID_SPRITE_PROP_READYSTATE           (DISPID_SPRITE_PROP_BASE + 7)
#define DISPID_SPRITE_PROP_TIME                 (DISPID_SPRITE_PROP_BASE + 8)
#define DISPID_SPRITE_PROP_MAXIMUMRATE          (DISPID_SPRITE_PROP_BASE + 9)
#define DISPID_SPRITE_PROP_NUMFRAMES            (DISPID_SPRITE_PROP_BASE + 10)
#define DISPID_SPRITE_PROP_PLAYSTATE            (DISPID_SPRITE_PROP_BASE + 11)
#define DISPID_SPRITE_PROP_NUMFRAMESACROSS      (DISPID_SPRITE_PROP_BASE + 12)
#define DISPID_SPRITE_PROP_NUMFRAMESDOWN        (DISPID_SPRITE_PROP_BASE + 13)
#define DISPID_SPRITE_PROP_USECOLORKEY          (DISPID_SPRITE_PROP_BASE + 14)
#define DISPID_SPRITE_PROP_IMAGE                (DISPID_SPRITE_PROP_BASE + 15)
#define DISPID_SPRITE_PROP_COLORKEY             (DISPID_SPRITE_PROP_BASE + 16)
#define DISPID_SPRITE_PROP_SOURCEURL            (DISPID_SPRITE_PROP_BASE + 17)
#define DISPID_SPRITE_PROP_MOUSEEVENTSENABLED   (DISPID_SPRITE_PROP_BASE + 18)
#define DISPID_SPRITE_PROP_LIBRARY              (DISPID_SPRITE_PROP_BASE + 19)
#define DISPID_SPRITE_PROP_TIMERINTERVAL        (DISPID_SPRITE_PROP_BASE + 20)
#define DISPID_SPRITE_PROP_FINALFRAME           (DISPID_SPRITE_PROP_BASE + 21)
#define DISPID_SPRITE_PROP_COLORKEYRGB          (DISPID_SPRITE_PROP_BASE + 22)

//
// Methods  (start after properties)

#define DISPID_SPRITE_METH_BASE                 (DISPID_SPRITE_PROP_BASE + 23)

#define DISPID_SPRITE_METH_ADDFRAMEMARKER       (DISPID_SPRITE_METH_BASE + 0)
#define DISPID_SPRITE_METH_ADDTIMEMARKER        (DISPID_SPRITE_METH_BASE + 1)
#define DISPID_SPRITE_METH_PLAY                 (DISPID_SPRITE_METH_BASE + 2)
#define DISPID_SPRITE_METH_STOP                 (DISPID_SPRITE_METH_BASE + 3)
#define DISPID_SPRITE_METH_PAUSE                (DISPID_SPRITE_METH_BASE + 4)
#define DISPID_SPRITE_METH_SEEK                 (DISPID_SPRITE_METH_BASE + 5)
#define DISPID_SPRITE_METH_FRAMESEEK            (DISPID_SPRITE_METH_BASE + 6)


//
// Events  (start from 0; different interface)


#define DISPID_SPRITE_EVENT_BASE                1

#define DISPID_SPRITE_EVENT_ONPLAYMARKER        (DISPID_SPRITE_EVENT_BASE + 0)
#define DISPID_SPRITE_EVENT_ONMARKER            (DISPID_SPRITE_EVENT_BASE + 1)
#define DISPID_SPRITE_EVENT_MOUSEMOVE           (DISPID_SPRITE_EVENT_BASE + 2)
#define DISPID_SPRITE_EVENT_MOUSEENTER          (DISPID_SPRITE_EVENT_BASE + 3)
#define DISPID_SPRITE_EVENT_MOUSELEAVE          (DISPID_SPRITE_EVENT_BASE + 4)
#define DISPID_SPRITE_EVENT_MOUSEDOWN           (DISPID_SPRITE_EVENT_BASE + 5)
#define DISPID_SPRITE_EVENT_MOUSEUP             (DISPID_SPRITE_EVENT_BASE + 6)
#define DISPID_SPRITE_EVENT_DBLCLICK            (DISPID_SPRITE_EVENT_BASE + 7)
#define DISPID_SPRITE_EVENT_CLICK               (DISPID_SPRITE_EVENT_BASE + 8)
#define DISPID_SPRITE_EVENT_ONMEDIALOADED       (DISPID_SPRITE_EVENT_BASE + 9)
#define DISPID_SPRITE_EVENT_ONSEEK              (DISPID_SPRITE_EVENT_BASE + 10)
#define DISPID_SPRITE_EVENT_ONFRAMESEEK         (DISPID_SPRITE_EVENT_BASE + 11)
#define DISPID_SPRITE_EVENT_ONSTOP              (DISPID_SPRITE_EVENT_BASE + 12)
#define DISPID_SPRITE_EVENT_ONPAUSE             (DISPID_SPRITE_EVENT_BASE + 13)
#define DISPID_SPRITE_EVENT_ONPLAY              (DISPID_SPRITE_EVENT_BASE + 14)


//////////////////////////////////////////////////////////////////
// Sequencer control dispids
//////////////////////////////////////////////////////////////////

#define DISPID_SEQ_PROP_BASE                1

#define DISPID_SEQ_PROP_TIME                (DISPID_SEQ_PROP_BASE + 0)
#define DISPID_SEQ_PROP_COOKIE              (DISPID_SEQ_PROP_BASE + 1)
#define DISPID_SEQ_PROP_PLAYSTATE           (DISPID_SEQ_PROP_BASE + 2)

//
// Methods  (start after properties)

#define DISPID_SEQ_METH_BASE                (DISPID_SEQ_PROP_BASE + 3)
#define DISPID_SEQ_METH_PLAY                (DISPID_SEQ_METH_BASE + 0)
#define DISPID_SEQ_METH_PAUSE               (DISPID_SEQ_METH_BASE + 1)
#define DISPID_SEQ_METH_STOP                (DISPID_SEQ_METH_BASE + 2)
#define DISPID_SEQ_METH_AT                  (DISPID_SEQ_METH_BASE + 3)
#define DISPID_SEQ_METH_CLEAR               (DISPID_SEQ_METH_BASE + 4)
#define DISPID_SEQ_METH_SEEK                (DISPID_SEQ_METH_BASE + 5)


//
// Events  (start from 0; different interface)

#define DISPID_SEQ_EVENT_BASE               1
#define DISPID_SEQ_EVENT_ONPLAY             (DISPID_SEQ_EVENT_BASE + 0)
#define DISPID_SEQ_EVENT_ONSTOP             (DISPID_SEQ_EVENT_BASE + 1)
#define DISPID_SEQ_EVENT_ONPAUSE            (DISPID_SEQ_EVENT_BASE + 2)
#define DISPID_SEQ_EVENT_ONSEEK             (DISPID_SEQ_EVENT_BASE + 3)

//////////////////////////////////////////////////////////////////
// Sequencer Manager control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_SEQMGR_PROP_BASE             1

#define DISPID_SEQMGR_PROP_COUNT            (DISPID_SEQMGR_PROP_BASE + 0)

//
// Methods

#define DISPID_SEQMGR_METH_BASE             (DISPID_SEQMGR_PROP_BASE + 1)

#define DISPID_SEQMGR_METH_RELAYEVENT       (DISPID_SEQMGR_METH_BASE + 0)

//
// Events  (start from 0; different interface)

// The events which are being relayed from the sequencer *must* have the same dispids

#define DISPID_SEQMGR_EVENT_BASE            DISPID_SEQ_EVENT_ONSEEK + 1
#define DISPID_SEQMGR_EVENT_INIT            (DISPID_SEQMGR_EVENT_BASE + 0)
#define DISPID_SEQMGR_EVENT_ONPLAY          DISPID_SEQ_EVENT_ONPLAY
#define DISPID_SEQMGR_EVENT_ONSTOP          DISPID_SEQ_EVENT_ONSTOP
#define DISPID_SEQMGR_EVENT_ONPAUSE         DISPID_SEQ_EVENT_ONPAUSE
#define DISPID_SEQMGR_EVENT_ONSEEK          DISPID_SEQ_EVENT_ONSEEK

#endif

// End of file: dispids.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\dither.h ===
#ifndef __DITHER_H__
#define __DITHER_H__

#define PATTERN_ROWS 4
#define PATTERN_COLS 4

#ifndef DITHER_IMPL
  #define DLINKAGE __declspec( dllimport )
#else
  #define DLINKAGE __declspec( dllexport )
#endif  // DITHER_IMPL

    //forward declares...
struct IDirectDrawSurface;

typedef struct tagLOGPALETTE256
{
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256, *PLOGPALETTE256, *LPLOGPALETTE256;

	

class CHalftonePalette
{
    enum { significant_bits = 4,
           green_offset     = significant_bits,
           red_offset       = green_offset + significant_bits
         };

public:
	DLINKAGE CHalftonePalette( );
	DLINKAGE CHalftonePalette(HPALETTE hpal);
	virtual ~CHalftonePalette();

	STDMETHOD (Regenerate)( HPALETTE hPal );
	STDMETHOD_(BYTE,GetNearestPaletteIndex)(int iRed, int iGreen, int iBlue)
	{
		return m_pbQuantizationTable[ ((iRed>>significant_bits)<<red_offset) + 
                                      ((iGreen>>significant_bits)<<green_offset) + 
                                      (iBlue>>significant_bits) ];
	}

	STDMETHOD (GetPaletteEntry)(int iIndex, LPBYTE pbRedDst, LPBYTE pbGreenDst, LPBYTE pbBlueDst)
	{
		LPPALETTEENTRY pe = &m_logpal.palPalEntry[iIndex];
		*pbRedDst   = pe->peRed;
		*pbGreenDst = pe->peGreen;
		*pbBlueDst  = pe->peBlue;
		return S_OK;
	}

protected:
	STDMETHOD (Initialize)(void);

protected:
	LOGPALETTE256     m_logpal;
	LPBYTE            m_pbQuantizationTable;
	CRITICAL_SECTION  m_critSection;
};


class CHalftone
{
public:
	DLINKAGE CHalftone(HPALETTE hpal);
	virtual ~CHalftone();
	STDMETHOD (Initialize)(void);
	STDMETHOD (Dither32to1)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Dither32to8)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Blt32to555)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Blt32to565)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Blt32to24)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Blt32to32)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);

protected:
	BYTE m_rgPattern[ 256 * (PATTERN_ROWS * PATTERN_COLS) ];
	CHalftonePalette m_cpal;
};


// ------------------------- HANDY UTILITIES --------------------------

	// If you know this hdc has 16 bit colordepth,
	// this will evaluate it for 555 or 565 encoding.
	// Return values: 15u=>555 encoding, 16u=>565 encoding.
DLINKAGE DWORD  GetSigBitsFrom16BPP( HDC hdc );

#endif //__DITHER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\cstring.h ===
//=============================================================================
// CString.h
// This was taken from the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
//=============================================================================
#ifndef __CSTRING_H__
#define __CSTRING_H__
#define AFXAPI

#ifndef ASSERT
#ifdef Proclaim
#define ASSERT Proclaim
#else
#define ASSERT _ASSERTE
#endif // Proclaim
#endif // ASSERT


#ifndef EXPORT
	#define EXPORT __declspec(dllexport)
#endif

class CString;
EXPORT const CString& AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

// Useful formatting functions to handle the %1, & %2 type formatting
void AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void AfxFormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1,LPCTSTR lpsz2);
void AfxFormatStrings(CString& rString, UINT nIDS, LPCTSTR const* rglpsz, int nString);
void AfxFormatStrings(CString& rString, LPCTSTR lpszFormat, LPCTSTR const* rglpsz, int nString);

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	EXPORT CString();
	EXPORT CString(const CString& stringSrc);
	EXPORT CString(TCHAR ch, int nRepeat = 1);
	EXPORT CString(LPCSTR lpsz);
	EXPORT CString(LPCWSTR lpsz);
	EXPORT CString(LPCTSTR lpch, int nLength);
	EXPORT CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	EXPORT int GetLength() const;
	EXPORT BOOL IsEmpty() const;
	EXPORT void Empty();                       // free up the data

	EXPORT TCHAR GetAt(int nIndex) const;      // 0 based
	EXPORT TCHAR operator[](int nIndex) const; // same as GetAt
	EXPORT void SetAt(int nIndex, TCHAR ch);
	EXPORT operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	EXPORT const CString& operator=(const CString& stringSrc);
	EXPORT const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	EXPORT const CString& operator=(char ch);
#endif
	EXPORT const CString& operator=(LPCSTR lpsz);
	EXPORT const CString& operator=(LPCWSTR lpsz);
	EXPORT const CString& operator=(const unsigned char* psz);

	// string concatenation
	EXPORT const CString& operator+=(const CString& string);
	EXPORT const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	EXPORT const CString& operator+=(char ch);
#endif
	EXPORT const CString& operator+=(LPCTSTR lpsz);

	EXPORT friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	EXPORT friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	EXPORT friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	EXPORT friend CString AFXAPI operator+(const CString& string, char ch);
	EXPORT friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	EXPORT friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	EXPORT friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	EXPORT int Compare(LPCTSTR lpsz) const;         // straight character
	EXPORT int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	EXPORT int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	EXPORT CString Mid(int nFirst, int nCount) const;
	EXPORT CString Mid(int nFirst) const;
	EXPORT CString Left(int nCount) const;
	EXPORT CString Right(int nCount) const;

	EXPORT CString SpanIncluding(LPCTSTR lpszCharSet) const;
	EXPORT CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	EXPORT void MakeUpper();
	EXPORT void MakeLower();
	EXPORT void MakeReverse();

	// trimming whitespace (either side)
	EXPORT void TrimRight();
	EXPORT void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	EXPORT int Find(TCHAR ch) const;               // like "C" strchr
	EXPORT int ReverseFind(TCHAR ch) const;
	EXPORT int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	EXPORT int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	EXPORT void __cdecl Format(LPCTSTR lpszFormat, ...);
	EXPORT void __cdecl Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	EXPORT BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	EXPORT BOOL __cdecl FormatMessage(UINT nFormatID, ...);

	// Windows support
	EXPORT BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	EXPORT void AnsiToOem();
	EXPORT void OemToAnsi();
#endif

	// OLE BSTR support (use for OLE automation)
	EXPORT BSTR AllocSysString() const;
	EXPORT BSTR SetSysString(BSTR* pbstr) const;

	EXPORT HRESULT GetOLESTR(LPOLESTR* ppszString);

	// Access to string implementation buffer as "C" character array
	EXPORT LPTSTR GetBuffer(int nMinBufLength);
	EXPORT void ReleaseBuffer(int nNewLength = -1);
	EXPORT LPTSTR GetBufferSetLength(int nNewLength);
	EXPORT void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	EXPORT LPTSTR LockBuffer();
	EXPORT void UnlockBuffer();

// Implementation
public:
	EXPORT ~CString();
	EXPORT int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Conversion helpers.
int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// CString Inlines
inline CStringData* CString::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
inline void CString::Init()
	{ m_pchData = afxEmptyString.m_pchData; }
inline CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CString AFXAPI operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CString AFXAPI operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CString::operator LPCTSTR() const
	{ return m_pchData; }
inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
inline int CString::Compare(LPCTSTR lpsz) const
	{ return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CString::Collate(LPCTSTR lpsz) const
	{ return _tcscoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool AFXAPI operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool AFXAPI operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool AFXAPI operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool AFXAPI operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool AFXAPI operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool AFXAPI operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\editres.h ===
#ifndef __EDITRES_H
#define __EDITRES_H

#ifndef EXPORT
	#define EXPORT __declspec(dllexport)
#endif

	// This contains the defines for these resources
	#include "..\editres\resource.h"

	// Use this to get the Instance for the DLL containing the edit mode resources
	HINSTANCE EXPORT WINAPI HGetEditResInstance(void);

	// Time spin control 
	void EXPORT WINAPI RegisterTimeSpin(HINSTANCE hInstance);
	void EXPORT WINAPI UnregisterTimeSpin(HINSTANCE hInstance);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\dlgsup.h ===
#ifndef _DLGSUP_H
#define _DLGSUP_H

#include <strconv.h>
#include <commctrl.h>





BOOL EXPORT WINAPI StringToDouble(LPSTR lpszText, double FAR *qDoubleOut);
LPSTR EXPORT WINAPI DoubleToString(double dVal, LPSTR lpstrOut, int iLeadingDigits, int iPrecision);
BOOL EXPORT WINAPI IsValidDouble(LPTSTR lpszText);
BOOL EXPORT WINAPI IsValidLong(LPTSTR lpszText);
BOOL EXPORT WINAPI IsValidULong(LPTSTR lpszText);
EXPORT BOOL	SelectColor(CHOOSECOLOR* c);

// Review(RISC, a-rogerw): We need to merge these two ASAP

#ifdef _M_IX86
typedef struct _MYDLGDATA
{
    SHORT    cbExtra;
    DWORD	 pMyThis;
} MYDLGDATA, UNALIGNED *PMYDLGDATA;

#else // !_M_IX86

typedef struct _MYDLGDATA
{
    SHORT    cbExtra;
    DWORD	 pMyThis;
} MYDLGDATA;

typedef MYDLGDATA UNALIGNED *PMYDLGDATA;

#endif // _M_IX86

//@class	Displays a Wait Cursor in constructor, saving the current cursor \
		//  Restores saved cursor in destructor. Idea stolen from MFC
class CWaitCursor
{
	//	Note:		Because of how their constructors and destructors work,
	//				CWaitCursor objects are always declared as local variables
	//				they?re never declared as global variables, nor are they allocated
	//				with new.
	//
//@access Public Members
public:
	//@cmember,mfunc Constructor
	EXPORT WINAPI CWaitCursor(void);
	//@cmember,mfunc Destructor
	EXPORT WINAPI ~CWaitCursor(void);
	//@cmember,mfunc restores the previous cursor
	void EXPORT WINAPI Restore(void);

private:
	HCURSOR m_hSavedCursor;

};

//@class This is a generic (very limited) String class, use CString instead
class CStr
{
	public:
	//@cmember,mfunc Trims string on left
		EXPORT static void LTrim(LPTSTR String);
	//@cmember,mfunc Trims string on right
		EXPORT static void RTrim(LPTSTR String);
	//@cmember,mfunc Trims string on right, replacing bang ! with NULLS
		EXPORT static void RTrimBang(LPTSTR String);
	//@cmember,mfunc Trims string on left and right
		EXPORT static void AllTrim(LPTSTR String);
};


//***********************************************************************
//* This is a generic subclass class
//***********************************************************************
class CSubClassWnd
{
protected:
	WNDPROC	m_lpfnOldCltProc;
	BOOL m_fSubClassed;
	HWND m_hWnd;

public:
	static LONG EXPORT WINAPI LDefSubClassProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
	virtual EXPORT LONG CALLBACK LSubClassProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
	EXPORT WINAPI CSubClassWnd(void);
	virtual EXPORT WINAPI ~CSubClassWnd();
    EXPORT STDMETHOD_(void, SubClass)		(HWND hWnd);
    EXPORT STDMETHOD_(void, UnSubClass)	(void);
};




//***********************************************************************
//* This is the base class for controls
//***********************************************************************
class	CDlgCtrl
{

public:
	long	m_id;
	HWND	m_hdlg;		// The dialog this control belongs to.
	BOOL	m_fDirty;


public:
	EXPORT WINAPI CDlgCtrl();
	virtual ~CDlgCtrl(){};
	virtual EXPORT long	IdGet();
	virtual EXPORT void	SetId(long	id);
	virtual EXPORT void	SetHdlg(HWND	hdlg);
	virtual EXPORT HWND	HGetDlg()  const;
	virtual EXPORT HWND	HGetCtrl() const;
	virtual EXPORT void	Dirty(BOOL	fDirty);
	virtual EXPORT BOOL	FIsDirty();
	virtual EXPORT BOOL Initialize(long lID, HWND hWnd);
	virtual EXPORT void	InvalidateRect(const RECT* rect, BOOL fErase);
	virtual EXPORT void	InvalidateRect();
	virtual EXPORT void	UpdateWindow(void);
	virtual EXPORT void	SetFocusItem(void);
	virtual EXPORT void	Enable();
	virtual EXPORT void	Enable(BOOL	fEnable);
	virtual EXPORT BOOL	FIsEnabled();
	virtual EXPORT LRESULT	LResultSendMessage(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
	virtual EXPORT BOOL Show(int nShow);
	virtual EXPORT BOOL Show(void);
	virtual EXPORT BOOL Hide(void);
	virtual EXPORT BOOL	FIsVisible(void);
	virtual EXPORT BOOL Disable(void);
	virtual EXPORT BOOL	FSetText(LPCSTR	lpcstr);
	virtual EXPORT long	CchGetText(LPSTR	lpstr, long cch);
	virtual EXPORT BOOL	FGetClientRect(RECT* pRect);
	virtual EXPORT BOOL	FMoveWindow(int X,int Y,int nWidth,int nHeight,BOOL bRepaint);
};

class	CDlgIcon : virtual public CDlgCtrl
{
	public:
		virtual EXPORT void LoadFromResource(HINSTANCE hInst, LPCTSTR lpszName, int x = 32, int y = 32);
		virtual EXPORT BOOL LoadFromFile(HINSTANCE hInst, LPSTR lpszName, UINT uIconIndex);
		EXPORT STDMETHOD_(void, LoadFromFile)(LPSTR szName, HINSTANCE hInst = NULL, ULONG uDefault = NULL);
};


class	CDlgCursor : public CDlgIcon
{
	public:
		EXPORT WINAPI CDlgCursor() {};
		virtual ~CDlgCursor(){};
		EXPORT STDMETHOD_(void, LoadFromFile)(LPSTR szName, HINSTANCE hInst = NULL, ULONG uDefault = NULL);
};





//***********************************************************************
//* This is the class for text controls
//***********************************************************************
class	CDlgCtrlT : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlT() {};
		virtual ~CDlgCtrlT(){};
		virtual EXPORT void	SetLimitText(long	cbMax);
		virtual EXPORT void	Select(int	iStart, int	iEnd);
};


//***********************************************************************
//* This is the class for "intger" text controls
//***********************************************************************
class	CDlgCtrlIntT : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlIntT() {};
		virtual ~CDlgCtrlIntT(){};
		virtual EXPORT long	LValGet(BOOL	*pfParsed);
		virtual EXPORT BOOL	FSetLVal(long	lVal);
		virtual EXPORT long	ULValGet(BOOL	*pfParsed);
		virtual EXPORT BOOL	FSetULVal(long	lVal);
		virtual EXPORT void	Select(int	iStart, int	iEnd);
		virtual EXPORT void	SetLimitText(long	cbMax);
};


class	CDlgCtrlNumT : virtual public CDlgCtrlIntT, virtual public CStrConv
{
	public:
		virtual EXPORT long	LValGet(BOOL *pfParsed);

	private:
		char* lpszStopString;
};


//***********************************************************************
//* This is the class for slider controls
//***********************************************************************
class	CDlgCtrlSlider : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlSlider() {};
		virtual ~CDlgCtrlSlider(){};
		virtual EXPORT BOOL	FSetRange(BOOL	fRedraw, long	lMin, long	lMax);
		virtual EXPORT BOOL	FSetPos(long	lPos);
		virtual EXPORT long	LPosGet();
		virtual EXPORT void	SetTicFq(long	lFq, long	lPosStart);
};


//***********************************************************************
//* This is the class for button controls
//***********************************************************************
class	CDlgCtrlButn : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlButn() {};
		virtual ~CDlgCtrlButn(){};
};



//***********************************************************************
//* This is the class for button controls with a bitmap
//***********************************************************************
class  CDlgCtrlBitmapButn  : public virtual CDlgCtrlButn
{
	private:
		HBITMAP			m_hBitmap;		// Bitmap for button

	public:
		EXPORT WINAPI CDlgCtrlBitmapButn();
		virtual ~CDlgCtrlBitmapButn();
		virtual EXPORT void	Initialize(long lID, HWND hWnd, HINSTANCE hInst, long lBitmapID);
		virtual EXPORT LRESULT SetBitmap(HINSTANCE hInst, long lBitmapID);
		virtual EXPORT long SetImage(HBITMAP hBitmap);
		virtual EXPORT HBITMAP GetImage(void);
};




//***********************************************************************
//* This is the class for check box controls
//***********************************************************************
class	CDlgCtrlCheck : public CDlgCtrlButn
{
	public:
		EXPORT WINAPI CDlgCtrlCheck() {};
		virtual ~CDlgCtrlCheck(){};
		virtual EXPORT UINT	UintChecked(void);
		virtual EXPORT BOOL	FCheck(UINT	uCheck);
};

//***********************************************************************
//* This is the class for check box controls
//*
//* Warning, this is not the best of classes to use as it requires that
//* lFirstID > lLastId and that there be no other controls in between
//* the id's. If there are other controls in between these id #'s you
//* can have very wierd behaviour.
//***********************************************************************
class	CDlgCtrlRadio : public CDlgCtrlCheck
{
	private:
		LONG 	m_idFirst;
		LONG 	m_idLast;
		long	IdGetFirst;
		long	IdGetLast;


	public:
		EXPORT WINAPI CDlgCtrlRadio() {};
		virtual ~CDlgCtrlRadio(){};
		virtual EXPORT void SetId(long	id, long lFirstId, long lLastId);
		virtual EXPORT BOOL	FCheck(void);
};


//***********************************************************************
//* This is the class for list box controls
//***********************************************************************
class	CDlgCtrlListBox : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlListBox() {};
		virtual ~CDlgCtrlListBox(){};
		virtual EXPORT LRESULT	LResultSendMessage(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
		virtual EXPORT LONG SetItemData(UINT uIndex, DWORD dwData);
		virtual EXPORT LONG LGetItemData(UINT uIndex);
		virtual EXPORT LONG LAddString(LPSTR lpString);
		virtual EXPORT LONG LAddString(LPSTR lpString, DWORD dwData);
		virtual EXPORT void ResetContent(void);
		virtual EXPORT LONG LGetSel(UINT uIndex);
		virtual EXPORT LONG LSetSel(UINT uIndex, BOOL fSelected);
		virtual EXPORT LONG LSetCurSel(UINT uIndex);
		virtual EXPORT LONG LGetCurSel(void);
		virtual EXPORT LONG LInsertString(UINT uIndex, LPSTR lpString);
		virtual EXPORT LONG LInsertString(UINT uIndex, LPSTR lpString, DWORD dwData);
		virtual EXPORT LONG LDeleteString(UINT uIndex);
		virtual EXPORT LONG LGetText(UINT uIndex, LPSTR lpString);
		virtual EXPORT LONG LGetTextLen(UINT uIndex);
		virtual EXPORT LONG LGetCount(void);
		virtual EXPORT LONG LGetSelCount(void);
		virtual EXPORT LONG LGetSelItems(int* aItems, int cItems);

		/* Other possible, but not currently supported, list box messages
		LB_SELITEMRANGEEX
		LB_SELECTSTRING
		LB_DIR
		LB_GETTOPINDEX
		LB_FINDSTRING
		LB_SETTABSTOPS
		LB_GETHORIZONTALEXTENT
		LB_SETHORIZONTALEXTENT
		LB_SETCOLUMNWIDTH
		LB_ADDFILE
		LB_SETTOPINDEX
		LB_GETITEMRECT
		LB_SELITEMRANGE
		LB_SETANCHORINDEX
		LB_GETANCHORINDEX
		LB_SETCARETINDEX
		LB_GETCARETINDEX
		LB_SETITEMHEIGHT
		LB_GETITEMHEIGHT
		LB_FINDSTRINGEXACT
		LB_SETLOCALE
		LB_GETLOCALE
		LB_SETCOUNT
		LB_INITSTORAGE
		LB_ITEMFROMPOINT
		LB_MSGMAX

		*/
};


class	CDlgCtrlComboBox : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlComboBox() {};
		virtual ~CDlgCtrlComboBox(){};
		virtual EXPORT LONG LResultSendMessage(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
		virtual EXPORT LONG LAddString(LPSTR lpString);
		virtual EXPORT LONG LAddString(LPSTR lpString, DWORD dwData);
		virtual EXPORT void ResetContent(void);
		virtual EXPORT LONG LSetCurSel(UINT uIndex);
		virtual EXPORT LONG LGetCurSel(void);
		virtual EXPORT LONG LInsertString(UINT uIndex, LPSTR lpString);
		virtual EXPORT LONG LDeleteString(UINT uIndex);
		virtual EXPORT LONG LGetCount(void);
		virtual EXPORT DWORD DWLGetItemData(UINT uIndex);
		virtual EXPORT LONG SetItemData(UINT uIndex, DWORD dwData);
		virtual EXPORT LONG FindItemData(const DWORD dwData) ;
		virtual EXPORT LONG LGetLbTextLen(UINT uIndex);
		virtual EXPORT LONG LGetLbText(UINT uIndex, LPSTR lpStr, LONG lStrLen);
		virtual EXPORT LONG LFindString(UINT uIndex, LPSTR lpStr);
		virtual EXPORT LONG LSelectString(UINT uIndex, LPSTR lpStr);


		/* Other possible, but not supported combo box messages
		CB_GETEDITSEL
		CB_LIMITTEXT
		CB_SETEDITSEL
		CB_DIR
		CB_SHOWDROPDOWN
		CB_SETITEMHEIGHT
		CB_GETITEMHEIGHT
		CB_GETDROPPEDCONTROLRECT
		CB_SETEXTENDEDUI
		CB_GETEXTENDEDUI
		CB_GETDROPPEDSTATE
		CB_FINDSTRINGEXACT
		CB_SETLOCALE
		CB_GETLOCALE
		CB_GETTOPINDEX
		CB_SETTOPINDEX
		CB_GETHORIZONTALEXTENT
		CB_SETHORIZONTALEXTENT
		CB_GETDROPPEDWIDTH
		CB_SETDROPPEDWIDTH
		CB_INITSTORAGE
		CB_MSGMAX

		*/
};



class	CDlgCtrlSpin : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlSpin() {};
		virtual ~CDlgCtrlSpin(){};
		virtual EXPORT BOOL FSetRange(SHORT sMin, SHORT sMax);
		virtual EXPORT void GetRange(SHORT &sMin, SHORT &sMax);
		virtual EXPORT BOOL FSetRangeVisual(SHORT sMin, SHORT sMax);
		virtual EXPORT void LSetPosition(SHORT sPosition);
		virtual EXPORT LONG LGetPosition(void);
		virtual EXPORT LONG LSetBuddy(HWND hWnd);
		virtual EXPORT HWND HGetBuddy(HWND hWnd);
		virtual EXPORT HWND HGetBuddy();
		virtual EXPORT LONG LSetAccel(WORD cAccels, LPUDACCEL paAccels);
		virtual EXPORT LONG LGetAccel(WORD cAccels, LPUDACCEL paAccels);
		virtual EXPORT LONG LSetBase(WORD wBase);
		virtual EXPORT LONG LGetBase(void);
};



//***********************************************************************
//* This is the class for tab controls
//***********************************************************************
class	CDlgCtrlTab : public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlTab() {};
		virtual ~CDlgCtrlTab(){};
		EXPORT STDMETHOD_(BOOL, FIsWindow)(void) { return ::IsWindow(HGetCtrl()); } ;
		EXPORT STDMETHOD_(BOOL, FDeleteAllItems)(void);
        EXPORT STDMETHOD_(BOOL, FInsertItem)( int nIndex, LPTSTR szTabText);
        EXPORT STDMETHOD_(BOOL, FInsertItem)( int nIndex, TC_ITEM FAR *ptc_item);
        EXPORT STDMETHOD_(BOOL, FSetCurSel)	( int nIndex);
        EXPORT STDMETHOD_(BOOL, FSetItem)	( int nIndex, TC_ITEM FAR *ptc_item);
        EXPORT STDMETHOD_(int,  NGetCurSel)	( void );
};


class CSubClassCtrl : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CSubClassCtrl();
		virtual EXPORT WINAPI ~CSubClassCtrl();
		virtual EXPORT void Subclass(void);
		virtual EXPORT void	WINAPI UnSubclass(void);
		virtual EXPORT BOOL  IsSubclassed( void ) const;
		virtual EXPORT BOOL Initialize(long lID, HWND hWnd);
		// Subclasses override this
		virtual EXPORT LONG CALLBACK	FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

	private:
		static	EXPORT LONG	CALLBACK FNewProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

	protected:
		WNDPROC		m_lpfnOldCltProc;	// Used to store dialog proc

	private:
		BOOL m_fSubClassed;
};


class CColorCtrl : public virtual CSubClassCtrl
{
	public:
		EXPORT WINAPI CColorCtrl();
		virtual ~CColorCtrl(){};
		virtual EXPORT void		SetColor(COLORREF crColor);
		virtual EXPORT COLORREF	GetColor(void);
		virtual EXPORT void		Refresh(void);
		virtual EXPORT BOOL		SelColor(void);
		virtual EXPORT LONG CALLBACK	FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

	private:
		COLORREF		m_crColor;
};



//---------------------------------------------
// Filename control support
//---------------------------------------------
class	CDlgFilename : virtual public CDlgCtrlT
{
	public:
		EXPORT WINAPI CDlgFilename(){};
		virtual ~CDlgFilename(){};
		virtual EXPORT LPTSTR Get(void);
		virtual EXPORT void Set(LPCTSTR szFilename);
		virtual EXPORT BOOL SelectFile(LPCTSTR szCaption, LPCTSTR szMask);
		virtual EXPORT HRESULT hrValidate();
		virtual EXPORT BOOL FBrowse(LPTSTR	lpstrFileName, LPCTSTR szCaption, LPCTSTR	lpstrFilter, OPENFILENAME*	pofn = NULL);

	private:
		TCHAR	m_szFilename[_MAX_PATH];
};


//---------------------------------------------
// SaveAs Filename control support
//---------------------------------------------
class	CDlgSaveFilename : virtual public CDlgCtrlT
{
	public:
		EXPORT WINAPI CDlgSaveFilename(){};
		virtual ~CDlgSaveFilename(){};
		virtual EXPORT LPTSTR CDlgSaveFilename::Get(void);
		virtual EXPORT void CDlgSaveFilename::Set(LPCTSTR szFilename);
		virtual EXPORT BOOL CDlgSaveFilename::SelectFile(LPCTSTR szCaption, LPCTSTR szMask);
		virtual EXPORT HRESULT CDlgSaveFilename::hrValidate();
		virtual EXPORT BOOL CDlgSaveFilename::FBrowse(LPTSTR	lpstrFileName, LPCTSTR szCaption, LPCTSTR	lpstrFilter, OPENFILENAME*	pofn = NULL);

	private:
		TCHAR	m_szFilename[_MAX_PATH];

};

/*********************************************************\
*
*	Spin control which allows floating (double) point values
*
*	This control is made up of two other controls, a subclassed
*   edit control and standard spin control. The spin control is
*   buddied with the edit control.
*   To use this you initialize the CDlgCtrlDoubleSpin control
*   and set it's display format using SetDisplayFormat. You need
*   to make sure you call SetPosition when you receive a
*   EN_CHANGE message from the edit control
*
\*********************************************************/
//
// This is the edit control, you don't need to make an instance of this!
//
class CDlgCtrlDouble : public CSubClassCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlDouble();
		virtual ~CDlgCtrlDouble() {};
		virtual	EXPORT LONG CALLBACK FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
		virtual EXPORT double DGetValue(void);

	private:
		BOOL m_InValidation;
};


//
// This is the combined edit/spin control
//
class	CDlgCtrlDoubleSpin : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlDoubleSpin::CDlgCtrlDoubleSpin();
		virtual CDlgCtrlDoubleSpin::~CDlgCtrlDoubleSpin(){};

		virtual EXPORT void Initialize(LONG lIDEdit, LONG lIDSpin, HWND hWndParent);
		virtual EXPORT void SetDisplayFormat(int iLeadingDigits, int iPrecision);
		virtual EXPORT BOOL FSetRange(double dMin, double tMax);
		virtual EXPORT void GetRange(double &dMin, double &tMax);
		virtual EXPORT BOOL FSetDelta(double dDelta);
		virtual EXPORT void SetPosition(double tPosition);
		virtual EXPORT double DGetPosition(void);
		virtual EXPORT double DGetValue(void);
		virtual EXPORT LONG LSetBuddy(void);
		virtual EXPORT HWND HGetBuddy(void);
		virtual EXPORT LONG LSetAccel(WORD cAccels, LPUDACCEL paAccels);
		virtual EXPORT LONG LGetAccel(WORD cAccels, LPUDACCEL paAccels);
		virtual EXPORT BOOL FIncrement(double Amount);
		virtual EXPORT BOOL FIncrement(void);
		virtual EXPORT BOOL FDecrement(double Amount);
		virtual EXPORT BOOL FDecrement(void);
		virtual EXPORT void Select(int	iStart, int	iEnd);
		virtual EXPORT void SetFocusItem(void);
		virtual EXPORT void Enable(BOOL	fEnable);


	public:
		LONG	m_idEdit;	// ID of edit control
		LONG	m_idSpin;	// ID of spin control
		HWND	m_hdlg;		// The dialog this control belongs to.

	protected:
		CDlgCtrlDouble	m_EditCtrl;
		CDlgCtrlSpin	m_Spin;
		double	m_dCurrentValue;
		double	m_dMinRange;
		double	m_dMaxRange;
		double	m_dDeltaPos;
		int     m_iFormatLeadingDigits;
		int     m_iFormatPrecision;
		BOOL	m_fRangeSet;


};



/*********************************************************\
*
*	Edit control which allows validated entry of Signed Longs
*
\*********************************************************/
class CDlgCtrlLong : virtual public CSubClassCtrl
{
public:
	EXPORT WINAPI CDlgCtrlLong();
	virtual EXPORT WINAPI ~CDlgCtrlLong();
	virtual EXPORT LONG CALLBACK FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
	EXPORT STDMETHOD_(void, Select)(int	iStart, int	iEnd);
	EXPORT STDMETHOD_(LONG, LValGet)(BOOL	*pfParsed);
	EXPORT STDMETHOD_(BOOL,	FSetLVal)(long	lVal);

private:
	BOOL m_InValidation;
};



/*********************************************************\
*
*	Edit control which allows validated entry of Unsigned Longs
*
\*********************************************************/
class CDlgCtrlULong : virtual public CSubClassCtrl
{
public:
	EXPORT WINAPI CDlgCtrlULong();
	virtual EXPORT WINAPI ~CDlgCtrlULong();
	virtual EXPORT LONG CALLBACK FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
	EXPORT STDMETHOD_(void, Select)(int	iStart, int	iEnd);
	EXPORT STDMETHOD_(ULONG, ULValGet)(BOOL	*pfParsed);
	EXPORT STDMETHOD_(BOOL,	FSetULVal)(ULONG lVal);

private:
	BOOL m_InValidation;
};





//////////////////////////////////////////////////////////////////
// This allows us to have seperate wndproc functions
// in each class (LWndProc)

class CBaseWindow
{
	public:
		EXPORT WINAPI CBaseWindow();
		virtual EXPORT ~CBaseWindow();
		EXPORT STDMETHOD_(LONG, LWndProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;
		EXPORT STDMETHOD_(HWND, HGetWnd)(void);
		EXPORT STDMETHOD_(void, SetWnd)(HWND hWnd) {m_hWnd = hWnd;};
		EXPORT STDMETHOD_(LRESULT,	LResultSendMessage)(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
		EXPORT STDMETHOD_(LRESULT,	LResultPostMessage)(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
		EXPORT STDMETHOD_(HWND, HCreateWindow)(HWND hParentWindow) PURE;
		EXPORT STDMETHOD_(BOOL, FShowWindow)(int nCmdShow);
		EXPORT STDMETHOD_(HWND, HGetParent)(HWND){return m_hWndParent;};
		EXPORT STDMETHOD_(void, SetParent)(HWND hParent){m_hWndParent = hParent;};
		EXPORT STDMETHOD_(void, GetWindowRect)(RECT* pRect);
		EXPORT STDMETHOD_(BOOL, FIsWindow)(){return ::IsWindow(m_hWnd);};
		EXPORT STDMETHOD_(BOOL, FDestroyWindow)(void);
		EXPORT STDMETHOD_(BOOL, FMoveWindow)(int X,int Y,int nWidth,int nHeight,BOOL bRepaint) ;
		EXPORT STDMETHOD_(BOOL, FInvalidateRect)(CONST RECT *lpRect,BOOL bErase);
		EXPORT STDMETHOD_(HWND, HSetFocus)(void);
		EXPORT STDMETHOD_(BOOL, FGetClientRect)(RECT* pRect);
		EXPORT STDMETHOD_(void, UnRegisterClass)(LPTSTR szClassName, HINSTANCE hInstance);

	private:
		HWND m_hWnd;
		HWND m_hWndParent;
};


#ifdef NOT_YET	// See me if you think you need this (a-rogerw)
class CBaseMdiWindow : virtual public CBaseWindow
{
	public:
		WINAPI CBaseMdiWindow(){};
		virtual WINAPI ~CBaseMdiWindow(){};

		EXPORT STDMETHOD_(LONG, LWndProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;
		EXPORT STDMETHOD_(HWND, HCreateWindow)(HWND hParentWindow) PURE;
		EXPORT static	LONG	CALLBACK  LBaseWndProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
};
#endif // NOT_YET

class CBaseSdiWindow : virtual public CBaseWindow
{
	public:
		WINAPI CBaseSdiWindow(){};
		virtual WINAPI ~CBaseSdiWindow(){};

		EXPORT STDMETHOD_(LONG, LWndProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;
		EXPORT STDMETHOD_(HWND, HCreateWindow)(HWND hParentWindow) PURE;
		EXPORT static	LONG	CALLBACK  LBaseWndProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

class CBaseDialog
{
	public:
		EXPORT WINAPI CBaseDialog();
		virtual EXPORT ~CBaseDialog(){};
		EXPORT static	LONG	CALLBACK  LBaseDlgProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
		EXPORT STDMETHOD_(LONG, LDlgProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
		EXPORT STDMETHOD_(HWND, HGetParent)(HWND){return m_hWndParent;};
		EXPORT STDMETHOD_(void, SetParent)(HWND hParent){m_hWndParent = hParent;};
		EXPORT STDMETHOD_(HWND, GetWnd)(void){return m_hDlg;};

	protected:
		HWND m_hDlg;
		HWND m_hWndParent;
};


#ifdef NOT_YET // (a-rogerw)
class CDialog : virtual public CBaseDialog
{
public:
	EXPORT WINAPI CDialog();
	EXPORT WINAPI CDialog(HINSTANCE hInst, UINT uiTemplateID, HWND hWndParent = NULL);
	EXPORT WINAPI CDialog(HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hWndParent = NULL);
	virtual EXPORT ~CDialog();


	// Modeless
public:
	EXPORT STDMETHOD_(BOOL, Create)(void);
	EXPORT STDMETHOD_(BOOL, Create)(HINSTANCE hInst, UINT uiTemplateID, HWND hWndParent = NULL);
	EXPORT STDMETHOD_(BOOL, Create)(HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hWndParent = NULL);


	// Modal
public:

	EXPORT STDMETHOD_(int, DoModal)(void);
	EXPORT STDMETHOD_(int, DoModal)(HINSTANCE hInst, UINT uiTemplateID, HWND hWndParent);
	EXPORT STDMETHOD_(int, DoModal)(HINSTANCE hInst, LPCSTR lpszTemplateName, HWND hWndParent);

protected:
	// Operations
	EXPORT STDMETHOD_(BOOL, OnInitDialog)(){ return TRUE; };
	EXPORT STDMETHOD_(void, OnOK)(){ EndDialog(1);};
	EXPORT STDMETHOD_(void, OnCancel)(){ EndDialog(0);};

	// support for passing on tab control - use 'PostMessage' if needed
	inline void NextDlgCtrl() const
	{ if(::IsWindow(m_hDlg)) { ::SendMessage(m_hDlg, WM_NEXTDLGCTL, 0, 0);}; };
	inline void PrevDlgCtrl() const
	{ if(::IsWindow(m_hDlg)) { ::SendMessage(m_hDlg, WM_NEXTDLGCTL, 1, 0); }; };
	inline void GotoDlgCtrl(HWND hWndCtrl)
	{ if(::IsWindow(m_hDlg)) { ::SendMessage(m_hDlg, WM_NEXTDLGCTL, (WPARAM)hWndCtrl, 1L); }; };

	// default button access
	inline void SetDefID(UINT nID)
	{ if(::IsWindow(m_hDlg)) { ::SendMessage(m_hDlg, DM_SETDEFID, nID, 0); }; };
	inline DWORD GetDefID() const
	{ if(::IsWindow(m_hDlg)) { return ::SendMessage(m_hDlg, DM_GETDEFID, 0, 0); } else return 0; };

	// termination
	EXPORT STDMETHOD_(void, EndDialog)(int nResult);


	// Attributes
	LPCSTR m_lpszTemplateName;
	HINSTANCE m_hInst;
};
#endif // NOT_YET (a-rogerw)


//@class List View dialog control.
class	CDlgCtrlListView : virtual public CDlgCtrl
{
	public:
	//@cmember,mfunc Constructor, initializes string to empty.
		EXPORT WINAPI CDlgCtrlListView();

	//@cmember,mfunc Destructor
	virtual EXPORT WINAPI ~CDlgCtrlListView();

	//@cmember,mfunc Set background color
	EXPORT STDMETHOD_(COLORREF, CRGetBkColor)(void);

	//@cmember,mfunc Set background color
	EXPORT STDMETHOD_(BOOL, FSetBkColor)(COLORREF clrBk);

	//@cmember,mfunc Get image list
	EXPORT STDMETHOD_(HIMAGELIST, HGetImageList)(int iImageList);

	//@cmember,mfunc Set image list
	EXPORT STDMETHOD_(HIMAGELIST, HSetImageList)(HIMAGELIST himl, int iImageList);

	//@cmember,mfunc Get item count
	EXPORT STDMETHOD_(int,  NGetItemCount)(void);

	//@cmember,mfunc Get item
	EXPORT STDMETHOD_(BOOL, FGetItem)(LV_ITEM FAR* pitem);

	//@cmember,mfunc Set item
	EXPORT STDMETHOD_(BOOL, FSetItem)(LV_ITEM FAR* pitem);

	//@cmember,mfunc Insert item
	EXPORT STDMETHOD_(int,  NInsertItem)(LV_ITEM FAR* pitem);

	//@cmember,mfunc Delete item
	EXPORT STDMETHOD_(BOOL, DeleteItem)(int i);

	//@cmember,mfunc Delete all items
	EXPORT STDMETHOD_(BOOL, FDeleteAllItems)(void);

	//@cmember,mfunc Get callback mask
	EXPORT STDMETHOD_(BOOL, FGetCallbackMask)(void);

	//@cmember,mfunc Set callback mask
	EXPORT STDMETHOD_(BOOL, FSetCallbackMask)(UINT uimask);

	//@cmember,mfunc Get next item
	EXPORT STDMETHOD_(int,  NGetNextItem)(int i, UINT flags);

	//@cmember,mfunc FindItem
	EXPORT STDMETHOD_(int,  NFindItem)(int iStart,  const LV_FINDINFO FAR* plvfi);

	//@cmember,mfunc Get item rect
	EXPORT STDMETHOD_(BOOL, FGetItemRect)(int i, RECT FAR* prc, int code);

	//@cmember,mfunc Set item position
	EXPORT STDMETHOD_(BOOL, FSetItemPosition)(int i, int x, int y);

	//@cmember,mfunc Get item position
	EXPORT STDMETHOD_(BOOL, FGetItemPosition)(int i, POINT FAR* ppt);

	//@cmember,mfunc Get  string width
	EXPORT STDMETHOD_(int,  NGetStringWidth)(LPCSTR psz);

	//@cmember,mfunc Hit Test
	EXPORT STDMETHOD_(int,  NHitTest)(LV_HITTESTINFO FAR *pinfo);

	//@cmember,mfunc Ensure visible
	EXPORT STDMETHOD_(BOOL, FEnsureVisible)(int i, BOOL fPartialOK);

	//@cmember,mfunc Scroll
	EXPORT STDMETHOD_(BOOL, FScroll)(int dx, int dy);

	//@cmember,mfunc Redraw items
	EXPORT STDMETHOD_(BOOL, FRedrawItems)(int iFirst, int iLast);

	//@cmember,mfunc Arrange
	EXPORT STDMETHOD_(BOOL, FArrange)(UINT code);

	//@cmember,mfunc Edit label
	EXPORT STDMETHOD_(HWND, HEditLabel)(int i);

	//@cmember,mfunc Get edit control
	EXPORT STDMETHOD_(HWND, HGetEditControl)(void);

	//@cmember,mfunc Get column
	EXPORT STDMETHOD_(BOOL, FGetColumn)(int iCol, LV_COLUMN FAR* pcol);

	//@cmember,mfunc Set column
	EXPORT STDMETHOD_(BOOL, FSetColumn)(int iCol, LV_COLUMN FAR* pcol);

	//@cmember,mfunc Insert column
	EXPORT STDMETHOD_(int,  NInsertColumn)(int iCol, const LV_COLUMN FAR* pcol);

	//@cmember,mfunc Delete column
	EXPORT STDMETHOD_(BOOL, FDeleteColumn)(int iCol);

	//@cmember,mfunc Get column width
	EXPORT STDMETHOD_(int,  NGetColumnWidth)(int iCol);

	//@cmember,mfunc Set column width
	EXPORT STDMETHOD_(BOOL, FSetColumnWidth)(int iCol, int cx);

	//@cmember,mfunc Create drag image
	EXPORT STDMETHOD_(HIMAGELIST, HCreateDragImage)(int i,  LPPOINT lpptUpLeft);

	//@cmember,mfunc Get view rect
	EXPORT STDMETHOD_(BOOL, FGetViewRect)(RECT FAR* prc);

	//@cmember,mfunc Get text color
	EXPORT STDMETHOD_(COLORREF, CRGetTextColor)(void);

	//@cmember,mfunc Set text color
	EXPORT STDMETHOD_(BOOL, FSetTextColor)(COLORREF clrText);

	//@cmember,mfunc Get text background color
	EXPORT STDMETHOD_(COLORREF, CRGetTextBkColor)(void);

	//@cmember,mfunc Set text background color
	EXPORT STDMETHOD_(BOOL, FSetTextBkColor)(COLORREF clrTextBk);

	//@cmember,mfunc Get top index
	EXPORT STDMETHOD_(int,  NGetTopIndex)(void);

	//@cmember,mfunc Get count per page
	EXPORT STDMETHOD_(int,  NGetCountPerPage)(void);

	//@cmember,mfunc Get origin
	EXPORT STDMETHOD_(BOOL, FGetOrigin)(LPPOINT ppt);

	//@cmember,mfunc Update
	EXPORT STDMETHOD_(BOOL, FUpdate)(int i);

	//@cmember,mfunc Set item state
	EXPORT STDMETHOD_(void, SetItemState)(int i, UINT data, UINT mask);

	//@cmember,mfunc Get item state
	EXPORT STDMETHOD_(UINT, ULGetItemState)(int i, UINT mask);

	//@cmember,mfunc Get item text
	EXPORT STDMETHOD_(void, GetItemText)(int i, int iSubItem, LPSTR pszText, int cchTextMax);

	//@cmember,mfunc Set item text
	EXPORT STDMETHOD_(void, SetItemText)(int i, int iSubItem_, LPSTR pszText);

	//@cmember,mfunc Set item count
	EXPORT STDMETHOD_(void, SetItemCount)(int cItems);

	//@cmember,mfunc Sort items
	EXPORT STDMETHOD_(BOOL, FSortItems)(PFNLVCOMPARE pfnCompare, LPARAM lPrm);

	//@cmember,mfunc Set item position
	EXPORT STDMETHOD_(void, SetItemPosition32)(int i, int x, int y);

	//@cmember,mfunc Get selected count
	EXPORT STDMETHOD_(UINT, UGetSelectedCount)(void);

	//@cmember,mfunc Get item spacing
	EXPORT STDMETHOD_(DWORD, DWGetItemSpacing)(BOOL fSmall);

	//@cmember,mfunc Get search string
	EXPORT STDMETHOD_(BOOL, FGetISearchString)(LPSTR lpsz);

};

//@class Tree View dialog control.
class	CDlgCtrlTreeView : virtual public CDlgCtrl
{
	public:
	//@cmember,mfunc Constructor, initializes string to empty.
		EXPORT WINAPI CDlgCtrlTreeView();

	//@cmember,mfunc Destructor
	virtual EXPORT WINAPI ~CDlgCtrlTreeView();

	//@cmember,mfunc Set background color
	//EXPORT STDMETHOD_(COLORREF, CRGetBkColor)(void);

	//@cmember,mfunc Set background color
	//EXPORT STDMETHOD_(BOOL, FSetBkColor)(COLORREF clrBk);

	//@cmember,mfunc Get image list
	EXPORT STDMETHOD_(HIMAGELIST, HGetImageList)(int iImageList);

	//@cmember,mfunc Set image list
	EXPORT STDMETHOD_(HIMAGELIST, HSetImageList)(HIMAGELIST himl, int iImageList);

	//@cmember,mfunc Get item count
	EXPORT STDMETHOD_(int,  NGetItemCount)(void);

	//@cmember,mfunc Get item
	EXPORT STDMETHOD_(BOOL, FGetItem)(TV_ITEM FAR* pitem);

	//@cmember,mfunc Set item
	EXPORT STDMETHOD_(BOOL, FSetItem)(TV_ITEM FAR* pitem);

	//@cmember,mfunc Insert item
	EXPORT STDMETHOD_(HTREEITEM,  NInsertItem)(TV_INSERTSTRUCT* pitem);

	//@cmember,mfunc Expand item
	EXPORT STDMETHOD_(BOOL, NExpandItem)( HTREEITEM htriItem);

	//@cmember,mfunc Insert item
	EXPORT STDMETHOD_(HTREEITEM,  NInsertTextItemAfter)(LPSTR pszName, HTREEITEM htiParent);

	//@cmember,mfunc add leaf
	EXPORT STDMETHOD_(HTREEITEM, htiAddLeaf)(HTREEITEM htiParent, void *pObject, int iBranch, int iLeaf);

	EXPORT STDMETHOD_(VOID, AddBranch)(HTREEITEM htiParent, void *pObject, int iBranch, int iMaxBranch);

	//@cmember,mfunc Delete item
	EXPORT STDMETHOD_(BOOL, DeleteItem)(HTREEITEM i);

	//@cmember,mfunc Delete all items
	EXPORT STDMETHOD_(BOOL, FDeleteAllItems)(void);

	//@cmember,mfunc Get callback mask
	//EXPORT STDMETHOD_(BOOL, FGetCallbackMask)(void);

	//@cmember,mfunc Set callback mask
	//EXPORT STDMETHOD_(BOOL, FSetCallbackMask)(UINT uimask);

	//@cmember,mfunc Get next item
	EXPORT STDMETHOD_(HTREEITEM,  NGetNextItem)(HTREEITEM i, UINT flags);

	//@cmember,mfunc Get selected item
	EXPORT STDMETHOD_(HTREEITEM,  NGetSelection)(void);

	//@cmember,mfunc select item in the view
	EXPORT STDMETHOD_(HTREEITEM,  NSelectItem)(HTREEITEM hi);

	//@cmember,mfunc select item in the view, pass flags
	EXPORT STDMETHOD_(HTREEITEM,  NSelectItem)(HTREEITEM hi, LONG lFlags);

	//@cmember,mfunc Get parent item in the view
	EXPORT STDMETHOD_(HTREEITEM,  NGetParent)(HTREEITEM hi);

	//@cmember,mfunc Get selected child item
	EXPORT STDMETHOD_(HTREEITEM,  NGetChild)(HTREEITEM hi);

	//@cmember,mfunc FindItem	Not supported by TreeView
	//EXPORT STDMETHOD_(int,  NFindItem)(int iStart,  const LV_FINDINFO FAR* plvfi);

	//@cmember,mfunc Get item rect
	EXPORT STDMETHOD_(BOOL, FGetItemRect)(HTREEITEM i, RECT FAR* prc, int code);

	//@cmember,mfunc Set item position
	//EXPORT STDMETHOD_(BOOL, FSetItemPosition)(int i, int x, int y);

	//@cmember,mfunc Get item position
	//EXPORT STDMETHOD_(BOOL, FGetItemPosition)(int i, POINT FAR* ppt);

	//@cmember,mfunc Get  string width
	//EXPORT STDMETHOD_(int,  NGetStringWidth)(LPCSTR psz);

	//@cmember,mfunc Hit Test
	EXPORT STDMETHOD_(HTREEITEM,  NHitTest)(TV_HITTESTINFO FAR *pinfo);

	//@cmember,mfunc Ensure visible
	EXPORT STDMETHOD_(BOOL, FEnsureVisible)(HTREEITEM i);

	//@cmember,mfunc Scroll
	//EXPORT STDMETHOD_(BOOL, FScroll)(int dx, int dy);

	//@cmember,mfunc Redraw items
	//EXPORT STDMETHOD_(BOOL, FRedrawItems)(int iFirst, int iLast);

	//@cmember,mfunc Arrange
	//EXPORT STDMETHOD_(BOOL, FArrange)(UINT code);

	//@cmember,mfunc Edit label
	EXPORT STDMETHOD_(HWND, HEditLabel)(int i);

	//@cmember,mfunc Get edit control
	EXPORT STDMETHOD_(HWND, HGetEditControl)(void);

	//@cmember,mfunc Get column 	Not supported by TreeView
	//EXPORT STDMETHOD_(BOOL, FGetColumn)(int iCol, LV_COLUMN FAR* pcol);

	//@cmember,mfunc Set column		Not supported by TreeView
	//EXPORT STDMETHOD_(BOOL, FSetColumn)(int iCol, LV_COLUMN FAR* pcol);

	//@cmember,mfunc Insert column	Not supported by TreeView
	//EXPORT STDMETHOD_(int,  NInsertColumn)(int iCol, const LV_COLUMN FAR* pcol);

	//@cmember,mfunc Delete column	Not supported by TreeView
	//EXPORT STDMETHOD_(BOOL, FDeleteColumn)(int iCol);

	//@cmember,mfunc Get column width	Not supported by TreeView
	//EXPORT STDMETHOD_(int,  NGetColumnWidth)(int iCol);

	//@cmember,mfunc Set column width	Not supported by TreeView
	//EXPORT STDMETHOD_(BOOL, FSetColumnWidth)(int iCol, int cx);

	//@cmember,mfunc Create drag image
	EXPORT STDMETHOD_(HIMAGELIST, HCreateDragImage)(HTREEITEM i);

	//@cmember,mfunc Get view rect
	//EXPORT STDMETHOD_(BOOL, FGetViewRect)(RECT FAR* prc);

	//@cmember,mfunc Get text color
	//EXPORT STDMETHOD_(COLORREF, CRGetTextColor)(void);

	//@cmember,mfunc Set text color
	//EXPORT STDMETHOD_(BOOL, FSetTextColor)(COLORREF clrText);

	//@cmember,mfunc Get text background color
	//EXPORT STDMETHOD_(COLORREF, CRGetTextBkColor)(void);

	//@cmember,mfunc Set text background color
	//EXPORT STDMETHOD_(BOOL, FSetTextBkColor)(COLORREF clrTextBk);

	//@cmember,mfunc Get top index
	//EXPORT STDMETHOD_(int,  NGetTopIndex)(void);

	//@cmember,mfunc Get count per page
	//EXPORT STDMETHOD_(int,  NGetCountPerPage)(void);

	//@cmember,mfunc Get origin
	//EXPORT STDMETHOD_(BOOL, FGetOrigin)(LPPOINT ppt);

	//@cmember,mfunc Update
	//EXPORT STDMETHOD_(BOOL, FUpdate)(int i);

	//@cmember,mfunc Set item state
	//EXPORT STDMETHOD_(void, SetItemState)(int i, UINT data, UINT mask);

	//@cmember,mfunc Get item state
	//EXPORT STDMETHOD_(UINT, ULGetItemState)(int i, UINT mask);

	//@cmember,mfunc Get item text
	//EXPORT STDMETHOD_(void, GetItemText)(int i, int iSubItem, LPSTR pszText, int cchTextMax);

	//@cmember,mfunc Set item text
	//EXPORT STDMETHOD_(void, SetItemText)(int i, int iSubItem_, LPSTR pszText);

	//@cmember,mfunc Set item count
	//EXPORT STDMETHOD_(void, SetItemCount)(int cItems);

	//@cmember,mfunc Sort items
	EXPORT STDMETHOD_(BOOL, FSortItems)(LPTV_SORTCB ptvsor);

	//@cmember,mfunc Set item position
	//EXPORT STDMETHOD_(void, SetItemPosition32)(int i, int x, int y);

	//@cmember,mfunc Get selected count
	//EXPORT STDMETHOD_(UINT, UGetSelectedCount)(void);

	//@cmember,mfunc Get item spacing
	//EXPORT STDMETHOD_(DWORD, DWGetItemSpacing)(BOOL fSmall);

	//@cmember,mfunc Get search string
	//EXPORT STDMETHOD_(BOOL, FGetISearchString)(LPSTR lpsz);

};


//
// This is the combined time/spin control
//
#define FRAMES_PER_SECOND	75

// These are used as parameters for the set type call
#define DISPLAY_MSM    0
#define DISPLAY_TMSF   1
#define DISPLAY_SM     2
#define DISPLAY_HMSM   3

#define TSM_BASE		(WM_APP+0)
#define TSM_GETPOS		TSM_BASE+1
#define TSM_GETRANGE	TSM_BASE+2
#define TSM_SETPOS		TSM_BASE+3
#define TSM_SETRANGE	TSM_BASE+4
#define TSM_GETDWPOS	TSM_BASE+5
#define TSM_GETDWRANGE	TSM_BASE+6
#define TSM_SETDWPOS	TSM_BASE+7
#define TSM_SETDWRANGE	TSM_BASE+8
#define TSM_SETTYPE		TSM_BASE+9
#define TSM_GETTYPE		TSM_BASE+10
#define TSM_ENFORCERG   TSM_BASE+11
#define TSM_CHECKRG     TSM_BASE+12
#define TSM_ENABLE      TSM_BASE+13


#define MAX_FRAMES			60
#define MAX_MILLISEC		999
#define MAX_SECONDS			59
#define MAX_MINUTES			59
#define MAX_HOURS			_I32_MAX
#define MAX_TRACKS			999

typedef struct tagTIMESTRUCT
{
	DWORD dwFrame:3;		// Frame: 0=0; 1=15;2=30;3=45;4=60;
	DWORD dwMilliSec:10;	// Millisecs 0 - 999
	DWORD dwSeconds:6;		// 0 - 60  seconds
	DWORD dwMinutes:7;		// 0 - 99  minutes
	DWORD dwReserved1:6;	// Reserved
	DWORD dwTrack:10;		// 0 - 999
    DWORD dwReserved2:18;	// Reserved
    DWORD iType : 4;        // DISPLAY_TMSF, DISPLAY_MSM, etc.
	DWORD dwHours;	        // 0 - dword hours
} TIMESTRUCT, *LPTIMESTRUCT;


    // For conversions involving milliseconds
DWORD EXPORT WINAPI tsTimeToMSec(TIMESTRUCT ts);
void EXPORT WINAPI tsMSecToTime(int TypeControl, DWORD msecs, TIMESTRUCT &ts);


    // For conversions involving MCI CD-Audio, vcr TMSF DWORDs
EXPORT TIMESTRUCT tsTMSFToTime( DWORD tmsf );
EXPORT DWORD tsTimeToTMSF( TIMESTRUCT ts );

    // Returns 0 if equal, <0 if lhs<rhs, >0 if lhs>rhs
    // lhs's iType determines the type for comparison
EXPORT int CompareTimeStructs( const TIMESTRUCT & lhs,
                               const TIMESTRUCT & rhs );

    // Does the frame/millisec conversion, iType assignment,
    // and nTrack assignment if converting to TMSF.
    // It is safe if tsBefore and tsAfter are the same object.
inline void ConvertTimeStruct( const TIMESTRUCT & tsBefore,
                               TIMESTRUCT &       tsAfter,
                               int                typeAfter,
                               DWORD              nTrack=0u )
{
    tsAfter = tsBefore;
    switch( tsBefore.iType )
    {
        case DISPLAY_MSM:
            if( DISPLAY_TMSF == typeAfter )
            {
                tsAfter.dwTrack = nTrack;
                tsAfter.dwFrame = ((5 * tsBefore.dwMilliSec)+500) / 1000;
                tsAfter.dwMilliSec = 0;
            }
            break;
        case DISPLAY_TMSF:
            if( DISPLAY_MSM == typeAfter )
            {
                tsAfter.dwMilliSec = 1000 * tsBefore.dwFrame / 5;
                tsAfter.dwFrame = 0;
            }
            break;
        default:
            break;
    }
    tsAfter.iType = typeAfter;
}


class	CDlgCtrlTimeSpin : public CDlgCtrl
{
	public:
    EXPORT WINAPI CDlgCtrlTimeSpin();

	virtual EXPORT WINAPI ~CDlgCtrlTimeSpin();

	EXPORT STDMETHOD_(int, GetType)	(void);
	EXPORT STDMETHOD_(void, SetType)	(int type);
	EXPORT STDMETHOD_(BOOL, FSetRange)	(DWORD dwMin, DWORD dwMax);
	EXPORT STDMETHOD_(BOOL, FSetRange)	(TIMESTRUCT tsMin, TIMESTRUCT tsMax);
	EXPORT STDMETHOD_(BOOL, FSetPos)	(TIMESTRUCT ts);
	EXPORT STDMETHOD_(BOOL, FSetPos)	(DWORD dw);
	EXPORT STDMETHOD_(BOOL, FGetPos)	(TIMESTRUCT* ts);
	EXPORT STDMETHOD_(BOOL, FGetPos)	(DWORD* dw);

            // note: FSetRange and FSetPos do not enforce the range
            // on the position.  This, I guess, to allow you to SetPos
            // out of range then SetRange to encompass the pos.
            // Review(rogerw)
            // To ensure the position clips to the range, call EnforceRange().
            // As a quick check to see if pos is in range, FRangeCheck().
	EXPORT STDMETHOD_(BOOL, FRangeCheck)(void) const;
	EXPORT STDMETHOD_(BOOL, EnforceRange)(void);

	// Needed to disable control
	EXPORT STDMETHOD_(BOOL, Enable)(DWORD dw);


};




//
// This is the combined template edit/spin control
//
template<class TYPE, class EDIT_TYPE>
class CBaseCtrlEditSpin
{
	public:
		// EXPORT WINAPI
		CBaseCtrlEditSpin(){};
		virtual ~CBaseCtrlEditSpin(){};

		void Initialize(LONG lIDEdit, LONG lIDSpin, HWND hWndParent);
		BOOL FSetRange(TYPE tMin, TYPE tMax);

		void GetRange(TYPE &lMin, TYPE &lMax);
		BOOL FSetDelta(TYPE lDelta);
		virtual void SetPosition(TYPE lPosition) PURE;
		TYPE DGetPosition(void);
		TYPE GetPosition(void);
		virtual TYPE GetValue(void) PURE;
		virtual void SetValue(TYPE tValue) PURE;
		LONG LSetBuddy(void);
		HWND HGetBuddy(void);
		LONG LSetAccel(WORD cAccels, LPUDACCEL paAccels);
		LONG LGetAccel(WORD cAccels, LPUDACCEL paAccels);
		BOOL FIncrement(TYPE tAmount);
		EXPORT BOOL FIncrement(void);
		BOOL FDecrement(TYPE tAmount);
		BOOL FDecrement(void);
		void Select(int	iStart, int	iEnd);
		void SetFocusItem(void);
		void Enable(BOOL	fEnable);

	public:
		LONG	m_idEdit;	// ID of edit control
		LONG	m_idSpin;	// ID of spin control
		HWND	m_hdlg;		// The dialog this control belongs to.

	protected:
		EDIT_TYPE	m_EditCtrl;
		CDlgCtrlSpin	m_Spin;
		TYPE	m_tCurrentValue;
		TYPE	m_tMinRange;
		TYPE	m_tMaxRange;
		TYPE    m_tDeltaPos;
		BOOL	m_fRangeSet;

};


template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::Initialize(LONG lIDEdit, LONG lIDSpin, HWND hWndParent)
{
	m_hdlg = hWndParent;
	m_EditCtrl.SetId(lIDEdit);
	m_EditCtrl.SetHdlg(m_hdlg);
	m_EditCtrl.Subclass();
	m_Spin.SetId(lIDSpin);
	m_Spin.SetHdlg(m_hdlg);
	m_Spin.FSetRange(-10, 10);
	LSetBuddy();
}

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FSetRange(TYPE tMin, TYPE tMax)
{
	m_tMinRange = tMin;
	m_tMaxRange = tMax;
	m_fRangeSet = TRUE;
	return TRUE;
}

template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::GetRange(TYPE &tMin, TYPE &tMax)
{
    tMin = m_tMinRange;
    tMax = m_tMaxRange;
}


template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FSetDelta(TYPE tDelta)
{
	m_tDeltaPos = tDelta;
	return TRUE;
}

template< class TYPE, class EDIT_TYPE > TYPE CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::DGetPosition(void)
{
    return m_tCurrentValue;
};

template< class TYPE, class EDIT_TYPE > LONG CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::LSetBuddy(void)
{
    return m_Spin.LSetBuddy(m_EditCtrl.HGetCtrl());
};

template< class TYPE, class EDIT_TYPE > HWND CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::HGetBuddy(void)
{
    return (HWND)m_Spin.HGetBuddy(m_Spin.HGetCtrl());
};

template< class TYPE, class EDIT_TYPE > LONG CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::LSetAccel(WORD cAccels, LPUDACCEL paAccels)
{
    return m_Spin.LSetAccel(cAccels, paAccels);
};

template< class TYPE, class EDIT_TYPE > LONG CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::LGetAccel(WORD cAccels, LPUDACCEL paAccels)
{
    return m_Spin.LGetAccel(cAccels, paAccels);
};

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FIncrement(TYPE Amount)
{
	if( (m_tCurrentValue + Amount) > m_tMaxRange)
		return FALSE;
	m_tCurrentValue += Amount;

    SetValue(m_tCurrentValue);
	return TRUE;
};

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FIncrement(void)
{
	return FIncrement(m_tDeltaPos);
};

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FDecrement(TYPE Amount)
{
	if( (m_tCurrentValue - Amount) < m_tMinRange)
		return FALSE;
	m_tCurrentValue -= Amount;
	SetValue(m_tCurrentValue);
	return TRUE;
};

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FDecrement(void)
{
	return FDecrement(m_tDeltaPos);
};

template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::Select(int	iStart, int	iEnd)
{
	m_EditCtrl.LResultSendMessage(EM_SETSEL, (WPARAM)iStart, (LPARAM)iEnd);
}

template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::SetFocusItem(void)
{
	m_EditCtrl.SetFocusItem();
}

template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::Enable(BOOL	fEnable){
	m_EditCtrl.Enable(fEnable);
	m_Spin.Enable(fEnable);
}


class CDlgCtrlLongSpin : public CBaseCtrlEditSpin<LONG, CDlgCtrlLong>
{
	public:
		EXPORT WINAPI CDlgCtrlLongSpin();
		virtual ~CDlgCtrlLongSpin(){};

		virtual EXPORT void SetPosition(LONG tPosition);
		virtual EXPORT LONG GetValue(void);
		virtual EXPORT void SetValue(LONG tValue);
};


class CDlgCtrlDblSpin : public CBaseCtrlEditSpin<double, CDlgCtrlDouble>
{
	public:
		EXPORT WINAPI CDlgCtrlDblSpin();
		virtual ~CDlgCtrlDblSpin(){};

		virtual EXPORT void SetPosition(double dValue);
		virtual EXPORT double GetValue(void);
		virtual EXPORT void SetValue(double dValue);
		virtual EXPORT void SetDisplayFormat(int iLeadingDigits, int iPrecision);
		virtual EXPORT void DeltaPos(int iDelta);

	protected:
		int     m_iFormatLeadingDigits;
		int     m_iFormatPrecision;

};




class CDlgCtrlIntSpin : public CBaseCtrlEditSpin<int, CDlgCtrlLong>
{
	public:
		EXPORT WINAPI CDlgCtrlIntSpin();
		virtual ~CDlgCtrlIntSpin(){};

		virtual EXPORT void SetPosition(int nPosition);
		virtual EXPORT int  GetValue(void);
		virtual EXPORT void SetValue(int nValue);
};





#ifdef NOT_YET


#include <tchar.h>
#include <commctrl.h>
#include <io.h>  // included for _access
#include <strconv.h>




////////////// CCheckList checkbox report-view listview //////////

/////////////////////////////
// To use this, link to ADT
// Give your dialog a "SysListView32" control with LVS_SINGLESEL style
// Give your dialog class a member CCheckList  m_checkList;
// In your dialog's WM_INITDIALOG,
//     m_checkList.Initialize( IDC_LISTVIEWID, hWndDialog );
//     CCheckList::item  anItem;
//     anItem.pszText   = "Item's display name";
//     anItem.stateType = CCheckList::included;
//     m_checkList.AddItem( anItem );
// In your dialog's WM_COMMAND, IDOK
//     anItem = m_checkList.GetItem( i )
//     if( anItem.stateType == CCheckList::included ) ...
/////////////////////////////
class CCheckList : public CSubClassCtrl
{
public:
    enum state {
        excluded=1,
        included,
        mandatory,
        prohibited
    };

    enum { cszTextLen = 128 };

    struct item {
        TCHAR   szText[ cszTextLen ];
        LPVOID  pVoid;
        state   stateType;
        int     imageType;      // see SetNormalImages

        item() : pVoid(NULL),
                 stateType(excluded), imageType(0)
        { lstrcpy(szText, "blank");  }
    };

    CCheckList( ) : CSubClassCtrl( )
    { NULL; }

    virtual ~CCheckList( )
    { NULL; }

        // Sets default state image list, column size, etc.
        // (will automatically call Subclass())
    virtual EXPORT BOOL Initialize( long lID, HWND hDlg );

        // puts an item into the checklist
        // returns its index (if no sorting style specified)
        // and -1 on error.
    int  AddItem( CCheckList::item & anItem );

        // counts items in checklist
    int  CountItems( void ) const;

        // retrieves an item from the checklist
    CCheckList::item  GetItem( int idx ) const;


        // ------ "advanced" APIs ---------

        // cx can be LVSCW_AUTOSIZE, LVSCW_AUTOSIZE_USEHEADER,
        // or a value in pixels.
        // If using LVS_LIST window-style, iCol must be -1.
    void SetColumnPixelWidth( int iCol, int cx );

        // replaces the default state images with a new imagelist
        // please put your excluded, included, mandatory, and prohibited
        // images in the first four bitmaps.
        // Both HIMAGELISTS are mandatory; we use ILC_MASK.
    //BOOL SetStateImages( HIMAGELIST himlimg, HIMAGELIST himlmask );

        // Set normal-size icons - optional second icon
        // to better categorize your items
    //BOOL SetNormalImages( HIMAGELIST himlimg, HIMAGELIST himlmask );

        // sets small icon equivalents of SetNormalImages
        // only call this if you've called SetNormalImages
    //BOOL SetSmallImages( HIMAGELIST himlimg, HIMAGELIST himlmask );

    protected:
    virtual EXPORT LONG CALLBACK   FCtrlProc( HWND hWnd,
                                              UINT uMessage,
                                              WPARAM wParam,
                                              LPARAM lParam );

    virtual EXPORT void OnLButtonDown( BOOL fDoubleClick,
                                       int x, int y,
                                       UINT keyFlags );

    virtual EXPORT void OnKey( UINT vk, BOOL fDown,
                               int cRepeat, UINT flags );

        // housekeeping...
    void ToggleItemInclusion( int idx = -1 ) const;

    int  GetSelectedItem( void ) const;
};


inline int  CCheckList::AddItem( CCheckList::item & anItem )
{
    int idx;
    idx = CountItems( );

    LV_ITEM  lvItem;
	ZeroMemory( &lvItem, sizeof(lvItem) );
    lvItem.iItem = idx;
    lvItem.mask = LVIF_TEXT | LVIF_STATE;
    lvItem.pszText = anItem.szText;
    lvItem.state   = INDEXTOSTATEIMAGEMASK( anItem.stateType );

    if( anItem.pVoid )
    {
        lvItem.mask |= LVIF_PARAM;
        lvItem.lParam = (LPARAM)anItem.pVoid;
    }
    if( anItem.imageType )
    {
        lvItem.mask |= LVIF_IMAGE;
        lvItem.iImage = anItem.imageType;
    }

    return ListView_InsertItem( HGetCtrl(), &lvItem );
}

        // counts items in checklist
inline int  CCheckList::CountItems( void ) const
{
    return ListView_GetItemCount( HGetCtrl() );
}

        // retrieves an item from the checklist
inline CCheckList::item  CCheckList::GetItem( int idx ) const
{
    LV_ITEM  lvItem;
    item     theItem;

    ZeroMemory( &lvItem, sizeof(lvItem) );
    lvItem.iItem = idx;
    lvItem.mask  = LVIF_TEXT | LVIF_PARAM |
                   LVIF_STATE | LVIF_IMAGE;
    lvItem.stateMask = LVIS_STATEIMAGEMASK |
                       LVIS_SELECTED;
    lvItem.pszText    = &theItem.szText[0];
    lvItem.cchTextMax = sizeof(theItem.szText);
    if( !ListView_GetItem( HGetCtrl(), &lvItem ) )
        return theItem;

    theItem.pVoid = (LPVOID) lvItem.lParam;
    if( lvItem.stateMask & LVIS_STATEIMAGEMASK )
    {
        DWORD  dwstate;
        dwstate = lvItem.state;

        DWORD dwstatemask;
        dwstatemask = LVIS_STATEIMAGEMASK;
        while( !(dwstatemask & 0x00000001) )
        {
            dwstatemask = dwstatemask >> 1;
            dwstate = dwstate >> 1;
        }
        theItem.stateType = (CCheckList::state) dwstate;
    }
    if( lvItem.stateMask & LVIF_IMAGE )
    {
        theItem.imageType = lvItem.iImage;
    }
    return theItem;
}


inline int  CCheckList::GetSelectedItem( void ) const
{
    UINT  uState;
    int   iSelIdx = -1;
    for( int i=0; i<ListView_GetItemCount(HGetCtrl()); i++ )
    {
        uState = ListView_GetItemState( HGetCtrl(), i, LVIS_SELECTED );
        if( uState == LVIS_SELECTED )
        {
            iSelIdx = i;
            break;
        }
    }
    return iSelIdx;

}



inline void CCheckList::SetColumnPixelWidth( int iCol, int cx )
{
    ListView_SetColumnWidth( HGetCtrl(), iCol, cx );
}



inline void CCheckList::ToggleItemInclusion( int idx ) const
{
    if( -1 == idx )
        idx = GetSelectedItem( );

    if( -1 == idx )
        return;

    UINT ustate;
    ustate = ListView_GetItemState( HGetCtrl(), idx,
                                    LVIS_STATEIMAGEMASK );
    if( INDEXTOSTATEIMAGEMASK(excluded) == ustate )
        ustate = INDEXTOSTATEIMAGEMASK(included);
    else if( INDEXTOSTATEIMAGEMASK(included) == ustate )
        ustate = INDEXTOSTATEIMAGEMASK(excluded);
    ListView_SetItemState( HGetCtrl(), idx, ustate,
                           LVIS_STATEIMAGEMASK );
}




#endif // NOT_YET






#endif // _DLGSUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\evbrs.h ===
/*---------------------------------------------

  EvBrs.h--
  Event Browser

  Yury Polykovsky April 97 Excaliber

  ----------------------------------------------*/

#ifndef _EV_BROWSE
#define _EV_BROWSE

class COWPFactoryEvBrowse : public CObjWPropFactory 
{
public:
	COWPFactoryEvBrowse() : CObjWPropFactory() {};
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
};

class CEvBrowse : public CObjectWProp
{
protected:
	EVBROWSEPARAM m_obpData;
	POSITION m_posObjSw;
	POSITION m_posMethodSw;
	CSwObjectControl* m_pControl;

	virtual BOOL fValidData(void *pData);
	virtual void SetData(void *pData);
	virtual void *pGetData(void);
public:
	CEvBrowse(LPUNKNOWN, PFNDESTROYED);
	EXPORT STDMETHOD_( BOOL, ResetObjectNames() );
	EXPORT STDMETHOD_( BOOL, FGetNextObjectName(TCHAR *ptszObjName, int ilenth) );
	EXPORT STDMETHOD_( BOOL, FObjectNameInAction(TCHAR *ptszObjName, int ilenth) );
	EXPORT STDMETHOD_( BOOL, ResetMethodNames() );
	EXPORT STDMETHOD_( BOOL, FGetNextMethodName(TCHAR *ptszMethodName, int ilenth) );
	EXPORT STDMETHOD_( BOOL, FMethodNameInAction(TCHAR *ptszMethodName, int ilenth) );
	virtual BOOL FIIDGetCLSIDPropPage(int i, IID *piid);
	// Object browser globals for registration, etc.
#ifdef	CSTRING_PROBLEM_SOLVED	
	static HRESULT WINAPI hrGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
#endif	//	CSTRING_PROBLEM_SOLVED	
	static BOOL fRegisterObj ();
	static BOOL fUnregisterObj ();
};


class CPropertyNotifySinkEB : public CPropertyNotifySink
{
protected:
    CSeqListItem*  m_pSeqItem;      //Backpointer to the app

public:
    CPropertyNotifySinkEB(CSeqListItem*);

    STDMETHODIMP OnChanged(DISPID);
    STDMETHODIMP OnRequestEdit(DISPID);
};

typedef CPropertyNotifySink *PCPropertyNotifySink;

#endif //_EV_BROWSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\effect.h ===
#ifndef __EFFECT_H__
#define __EFFECT_H__

// Forward declares...
struct IDirectDrawSurface;

//{1F9DDD20-4146-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(CATID_BitmapEffect, 
0x1f9ddd20, 0x4146, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define CATSZ_BitmapEffectDescription __T("Bitmap Effect")

// {ACEA25C0-415B-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(IID_IBitmapEffect, 
0xacea25c0, 0x415b, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define BITMAP_EFFECT_INPLACE 				0x00000001
#define BITMAP_EFFECT_REALTIME				0x00000002
#define BITMAP_EFFECT_DIRECTDRAW			0x00000004
#define BITMAP_EFFECT_SUPPORTS_INVALIDATE	0x00000008

DECLARE_INTERFACE_(IBitmapEffect, IUnknown)
{
	STDMETHOD(SetSite)(LPUNKNOWN pUnk) PURE;
	STDMETHOD(GetMiscStatusBits)(DWORD* pdwFlags) PURE;
    STDMETHOD(GetSupportedFormatsCount)(unsigned *pcFormats) PURE;
    STDMETHOD(GetSupportedFormats)(unsigned cFormats, DWORD *pdwColorDepths)  PURE;
    STDMETHOD(Begin)(DWORD dwColorDepth, SIZE* psizeEffect) PURE;
    STDMETHOD(End)(void) PURE;
	STDMETHOD(DoEffect)(IDirectDrawSurface* pbsIn, IDirectDrawSurface* pbsOut, RECT *prcFull, RECT* prcInvalid) PURE;
};

#endif //__EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\evbrspg.h ===
/*---------------------------------------------

  EvBrsPg.h--
  Event Browser Property Page

  Yury Polykovsky April 97 Excalliber 1.0

  ----------------------------------------------*/

#ifndef _PROPPAGES_EV_BROWSE
#define _PROPPAGES_EV_BROWSE
#include <dlgsup.h>

class CDlgCtrlEvBrsView : public CDlgCtrlTreeView
{
	friend class CPropPageEvBrowse;
protected:
	HTREEITEM m_htriSelectedObj;
	CPropPageEvBrowse *m_pOwner;

	EXPORT STDMETHOD_(HTREEITEM, htiAddLeaf)(HTREEITEM htiParent, void *pObject, int iBranch, int iLeaf);
public:
	BOOL m_fSelectionChecked;
	CDlgCtrlEvBrsView();
};

class CPropPageEvBrowse : public CPropPageOWP
{
	friend class CDlgCtrlEvBrsView;
protected:
	EVBROWSEPARAM m_obpData;
	CDlgCtrlEvBrsView m_dcTreeView;

	BOOL EXPORT WINAPI FOnInitDialog( HWND	hdlg, WPARAM wparam);
	BOOL EXPORT WINAPI FOnCommand(HWND	hdlg, WORD	wCode, WORD	wID, HWND	hwndCtrl);
	BOOL EXPORT WINAPI FOnNotify(HWND hDlg, int wParam, LPNMHDR lParam);
	virtual void EXPORT WINAPI GetData(void *pData);
	virtual BOOL EXPORT WINAPI FComp(VOID *pData1, VOID *pData2);
	EXPORT STDMETHOD_(void,	WriteToDlg)(void *pData);
 	STDMETHOD_(BOOL,DialogProc) (HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam, HRESULT* phr);

public:
	CPropPageEvBrowse(HRESULT* phr);//(HINSTANCE hInst, UINT uIDTemplate) 
};

#endif //_PROPPAGES_EV_BROWSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\iacttran.h ===
#ifndef __IACTTRAN_H__
#define __IACTTRAN_H__

// {F34B20E1-0BCE-11d0-97DF-00A0C90FEE54}
DEFINE_GUID(IID_IActionTransfer, 
0xf34b20e1, 0xbce, 0x11d0, 0x97, 0xdf, 0x0, 0xa0, 0xc9, 0xf, 0xee, 0x54);

interface IActionSet;
interface IEnumDispatch;

DECLARE_INTERFACE_(IActionTransfer, IUnknown)
{
	STDMETHOD(GetActions)				( THIS_ IActionSet ** ppCActionSet ) PURE;
	STDMETHOD(NotifyClose)				( THIS ) PURE;
	STDMETHOD(GetDispatchEnumerator)	( THIS_ IEnumDispatch ** ppIDispatchesOnForm ) PURE;
};

#endif

// End of IActTran.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\drg.h ===
/*+********************************************************
MODULE: DRG.H
AUTHOR: Outlaw
DATE: summer '93

DESCRIPTION: Dynamic Array ADT class.
*********************************************************-*/


#ifndef __DRG_H__
#define __DRG_H__

//===============================================================================================
                                  
#define DRG_APPEND  -1                  // CAN BE USED AS POSITION PARAMETER OF ::INSERT()                                  
#define DEFAULT_RESIZE_INCREMENT    0
                                  
class FAR CDrg
{
    protected:
        LONG m_lmax;            // MAX ELEMENTS THAT CAN BE CONTAINED IN ARRAY AT PRESENT
        LONG m_lmac;            // NUMBER OF ELEMENTS THAT ARE CURRENTLY IN ARRAY
        UINT m_cElementSize;    // BYTES IN EACH ARRAY ELEMENT
        UINT m_cResizeIncrement;// NUMBER OF ELEMENTS TO GROW ARRAY BY (AND SHRINK BY) WHEN NECESSARY....
        BYTE * m_qBuf;			// ARRAY BUFFER        
        LONG m_lIdxCurrent;     // USED BY GETFIRST()/GETNEXT()
            
    public: 
        WINAPI CDrg(void)
        { 
           SetNonDefaultSizes( sizeof(LONG), DEFAULT_RESIZE_INCREMENT );           
           m_lmax=0; m_lmac=0; m_qBuf=NULL; m_lIdxCurrent=0;
        }
        WINAPI ~CDrg(void) {MakeNull();}

        virtual void EXPORT WINAPI SetNonDefaultSizes(UINT cSizeElement, UINT cResizeIncrement=DEFAULT_RESIZE_INCREMENT);

        virtual BOOL EXPORT WINAPI Insert(void FAR *q, LONG cpos);
        virtual BOOL EXPORT WINAPI Remove(void FAR *q, LONG cpos);
        
        virtual LPVOID WINAPI GetFirst(void) {if (m_lmac) {m_lIdxCurrent=1; return(m_qBuf);} return(NULL);}
        virtual LPVOID WINAPI GetNext(void) {if (m_lmac > m_lIdxCurrent) return(m_qBuf + (m_lIdxCurrent++) * m_cElementSize); return(NULL);}

            // Norm Bryar  cpos is zero based, no access to <0 or >=m_lmac            
        virtual LPVOID WINAPI GetAt(LONG cpos) 
        {  
            Proclaim(m_qBuf); 
            if( (cpos >= m_lmac) || (0 > cpos) )
                return(NULL); 
            return(m_qBuf+(m_cElementSize*cpos));
        }
        
        virtual DWORD WINAPI GetDword(LONG cpos)
        {
            Proclaim(m_qBuf); 
            if( (cpos >= m_lmac) || (0 > m_lmac) )
                return(0); 
            return(((DWORD FAR *)m_qBuf)[cpos]);
        }

        VOID WINAPI SetAt(void FAR *q, LONG cpos)
        {
            Proclaim(m_qBuf);
            Proclaim((cpos<m_lmac) || (0 > cpos));             
			memcpy(m_qBuf+(m_cElementSize * cpos), (BYTE *)q, m_cElementSize);
        }
        
        virtual LONG WINAPI Count(void) {return(m_lmac);}  
        virtual VOID WINAPI MakeNull(void)
        {
            if (m_qBuf)
            {
                HANDLE h=MemGetHandle(m_qBuf);

                Proclaim(h);

                if (h)
                {
                    MemUnlock(h);
					MemFree(h);
                }
                m_qBuf=NULL;
                m_lmax=0;
                m_lmac=0;
                m_lIdxCurrent=0;
            }
        }
        
        virtual BOOL WINAPI CopyFrom(CDrg FAR *qdrg) {LONG i; MakeNull(); Proclaim(m_cElementSize==qdrg->m_cElementSize); for (i=0; i<qdrg->m_lmac; i++) {if (!Insert(qdrg->GetAt(i), DRG_APPEND)) return(FALSE);} return(TRUE);}

        virtual LPVOID WINAPI GetBufPtr(void) {return(m_qBuf);}
        
        virtual VOID WINAPI SetArray(BYTE * qBuf, LONG lElements, UINT uElementSize) {MakeNull(); m_qBuf=qBuf; m_lmax=lElements; m_lmac=lElements; m_cElementSize=uElementSize;}
        
		virtual LPBYTE WINAPI ExtractArray(void) {BYTE * q=m_qBuf; m_qBuf=NULL; m_lmax=0; m_lmac=0; m_lIdxCurrent=0; return(q);}
        
        virtual UINT WINAPI GetElSize(void) {return(m_cElementSize);}
};         


typedef CDrg FAR * LPDRG;


// DRG USED AS A DWORD QUEUE
class FAR CLongQueue
{                    
    protected:
        CDrg m_drg;

    public:        
        BOOL WINAPI Enqueue(LONG lVal) {return(m_drg.Insert(&lVal, DRG_APPEND));}
        BOOL WINAPI Dequeue(LONG FAR *qlVal) {return(m_drg.Remove(qlVal, 0));}
};
        
        
        
// FIXED ARRAY OF DRGS        
class FAR CRgDrg 
{
    protected:                                           
        LONG m_lmax;
        CDrg FAR * FAR *m_qrgdrg;

        void WINAPI Deallocate(void) {if (m_qrgdrg) {LONG i; CDrg FAR *q; for (i=0; i<m_lmax; i++) {q=m_qrgdrg[i]; if (q) Delete q;} HANDLE h=MemGetHandle(m_qrgdrg); MemUnlock(h); MemFree(h); m_qrgdrg=NULL; m_lmax=0;}}
    
    public:
        WINAPI CRgDrg(void) {m_qrgdrg=NULL; m_lmax=0;}
        WINAPI ~CRgDrg(void) {Deallocate();}
        LPDRG WINAPI GetDrgPtr(LONG lidx) {return(m_qrgdrg[lidx]);}
        
        BOOL WINAPI Init(LONG cDrg, UINT cElementSize) 
        {   
            LONG i;
            HANDLE h=MemAllocZeroInit(cDrg * sizeof(CDrg FAR *)); 
            if (!h) 
                return(FALSE); 
            m_qrgdrg=(CDrg FAR * FAR *)MemLock(h);                
            m_lmax=cDrg;
            for (i=0; i<cDrg; i++) 
            {
                m_qrgdrg[i]=New CDrg;
                if (!m_qrgdrg[i])
                {
                    Deallocate();
                    return(FALSE);
                }       
                m_qrgdrg[i]->SetNonDefaultSizes(cElementSize);
            }    
            return(TRUE);
        }                
};



// This class is essentially similar to the CDrg class ... but 
// when you insert an element into a particular array entry, it will stay at 
// that entry until it is removed; that is, the array won't shrink automatically.
// 

class FAR CNonCollapsingDrg : public CDrg
{
    public:
        WINAPI CNonCollapsingDrg(void) {}
        WINAPI ~CNonCollapsingDrg(void) {MakeNull();}

        //virtual void EXPORT WINAPI SetNonDefaultSizes(UINT cSizeElement, UINT cResizeIncrement=DEFAULT_RESIZE_INCREMENT);

        virtual BOOL WINAPI Insert(void FAR *q, LONG cpos) {return(FALSE);}  /* not supported */
        virtual BOOL EXPORT WINAPI Remove(void FAR *q, LONG cpos);
        
        virtual LPVOID EXPORT WINAPI GetFirst(void);
        virtual LPVOID EXPORT WINAPI GetNext(void);

        virtual LPVOID EXPORT WINAPI GetAt(LONG cpos);
        virtual DWORD WINAPI GetDword(LONG cpos) {return(0);}    /* not supported */
        virtual BOOL EXPORT WINAPI SetAt(void FAR *q, LONG cpos);
        
        virtual BOOL EXPORT WINAPI CopyFrom(CDrg FAR *qdrg);

        virtual LPVOID WINAPI GetBufPtr(void) {return(NULL);}

        virtual VOID EXPORT WINAPI SetArray(BYTE * qBuf, LONG lElements, UINT uElementSize);

        virtual UINT WINAPI GetMaxElements(void) {return(m_lmax);}
};


// -------- templatized extensions of CDrg --------------------

        // Assumes <class T> is a class or type
        // that you wish to store pointers to, e.g.
        // CPtrDrg<CFleagal> stores CFleagal *.
    template <class T>
    class CPtrDrg : protected CDrg
    {
    public:
        CPtrDrg( ) : CDrg( )
        { SetNonDefaultSizes( sizeof(T *) );  }

        CPtrDrg( const CPtrDrg<T> & toCopy );

            // note: SHALLOW COPY!!!            
        CPtrDrg<T> & operator=( const CPtrDrg<T> & toCopy );

        virtual EXPORT WINAPI  ~CPtrDrg()
        { NULL; }


        virtual BOOL EXPORT WINAPI Insert(T * qT , LONG cpos)
		{  return CDrg::Insert( &qT, cpos );  }

        virtual BOOL EXPORT WINAPI Insert( T * qT )
        {  return CDrg::Insert( &qT, DRG_APPEND );  }        

        virtual BOOL EXPORT WINAPI Remove( int idx )
        {  return CDrg::Remove( NULL, (ULONG) idx );  }

        virtual EXPORT T * WINAPI operator[]( int idx ) const;

        virtual int  EXPORT WINAPI Count( void ) const
        {  return (int) m_lmac; }

        virtual void WINAPI MakeNull( void )
        {  CDrg::MakeNull();  }

        virtual void WINAPI MakeNullAndDelete( void );
    };

    template <class T>
    CPtrDrg<T>::CPtrDrg( const CPtrDrg<T> & toCopy )
    {  CPtrDrg::operator=<T>(toCopy);  }

    template <class T>
    CPtrDrg<T> & CPtrDrg<T>::operator=( const CPtrDrg<T> & toCopy )
    {
            // We don't know whether we're supposed to 
            // delete our pointers or not when we nullify our drg.
            // Don't assign to a populated CPtrDrg!
        Proclaim( 0 == Count() );

        if( this == &toCopy )
            return *this;

        MakeNull( );
        for( int idx=0; idx<toCopy.Count(); idx++ )        
            Insert( toCopy[idx] );  // SHALLOW COPY!

        return *this;
    }

    template <class T>
    void WINAPI CPtrDrg<T>::MakeNullAndDelete( void )
    {
        T *  pT;
        for( int i=0; i<Count(); i++ )
        {
            pT = (*this)[ i ];
            Delete pT;
        }
        CDrg::MakeNull();
    }
    
    template <class T>
    T *  CPtrDrg<T>::operator[]( int idx ) const
    {   
        CPtrDrg<T> *  pThis;            
        pThis = const_cast<CPtrDrg<T> * const>(this);
        T * *  ppItem;
        ppItem = (T * *) pThis->GetAt( (LONG) idx );
        return *ppItem;
    }



        
        // Assumes <class T> is a class or type
        // that you wish to store pointers to, e.g.
        // CSortedPtrDrg<int> stores int *.
        // T must have an operator< and operator==.
    template <class T>
    class CSortedPtrDrg : public CPtrDrg<T>
    {
    public:
        CSortedPtrDrg( ) : CPtrDrg<T>( )
        { NULL; }

        virtual ~CSortedPtrDrg()
        { NULL; }

        virtual BOOL Insert( T * qT );        
        virtual BOOL Remove( T * qT );
        virtual BOOL Remove( int idx )
        {  return CPtrDrg<T>::Remove( idx );  }
        virtual BOOL ReSort( T * const qT = NULL );
        virtual BOOL ReSort( int idx )
        {  T * qT;  return CDrg::Remove( &qT, idx ) && Insert( qT );  }
        virtual BOOL Search( const T * pToFind,
                     int * pIdx ) const;
        virtual BOOL SearchForCeiling( const T * pToFind,
                               int *pIdx );

    protected:
        virtual int SearchForHigher( const T * pToFind ) const;
    };

    template <class T>
    BOOL CSortedPtrDrg<T>::Insert( T * qT )
    {
        int idx;
        idx = SearchForHigher( qT );
        return CDrg::Insert( &qT, idx );
    }

    template <class T>
    BOOL CSortedPtrDrg<T>::Remove( T * qT )
    {
        int idx;
        if( !Search( qT, &idx ) )
            return FALSE;

        return CDrg::Remove( NULL, (LONG) idx );
    }

    template <class T>
    BOOL CSortedPtrDrg<T>::ReSort( T * const qT )
    {
            // Just re-sort this one item
        if( NULL != qT )
        {
            int i;
            for( i=0; i<m_lmac; i++ )
            {
                    // Try finding the actual pointer.
                    // The object changed; can't find by sort-key.
                if( operator[](i) == qT )
                    return ReSort( i );
            }
        }

            // Review(all):  O(n^2) bubble sort
            // we may want to re-code this.  
        long    j, 
                flip, 
                size;
        T  * *  ptArray;
        T  *    ptemp;

            // Do pointer arithmatic on T* not BYTE
        ptArray = (T * *) m_qBuf;
            
        flip = 0;
        size = m_lmac-1;
        do
        {                
            for( j=0, flip = 0; j < size; j++ )
            {
                    // Compare T to T; T* < T* irrelevant.
                    // note: !(x<y) requires only operator<
                if( *ptArray[j+1] < *ptArray[j] )
                {
                    ptemp = ptArray[j+1];
                    ptArray[j+1] = ptArray[j];
                    ptArray[j]   = ptemp;
                    flip++;
                }

            } // end size

        } while( flip );

        return TRUE;
    }
  
    template <class T>
    BOOL CSortedPtrDrg<T>::Search( const T * pToFind,
                                       int * pIdx ) const
    {
        if( NULL == pToFind )
        {
            if( pIdx )
                *pIdx = -1;
            return FALSE;
        }

        int iLeft,
            iRight,
            idx;
        T * pT;
        iLeft = 0;
        iRight = Count()-1;
        while( iRight >= iLeft )
        {
            idx = (iLeft + iRight)/2;
            pT = (*this)[idx];
            if( *pToFind == *pT )
            {
                if( NULL != pIdx )
                    *pIdx = idx;
                return TRUE;
            }
            if( *pT < *pToFind )
                  iLeft = idx+1;
            else  iRight = idx-1;
        }
        if( NULL != pIdx )
            *pIdx = -1;
        return FALSE;
    }

    template <class T>
    BOOL CSortedPtrDrg<T>::SearchForCeiling( const T * pToFind,
                                             int *pIdx )
    {
        *pIdx = -1;
        if( !Count() )
            return FALSE;

        int iLeft,
            iRight,
            idx;
	    
        idx = 0;
        iLeft = 0;
        iRight = Count() - 1;
        while( iRight >= iLeft )
        {
            idx = (iLeft + iRight)/2;
            if( *pToFind == *(*this)[idx] )
            {
                *pIdx = idx;
                return TRUE;
            }
            if( *pToFind < *(*this)[idx] )
                  iRight = idx-1;
            else  iLeft = idx+1;
        }        
        return FALSE;
    }

    template <class T>
    int CSortedPtrDrg<T>::SearchForHigher( const T * pToFind ) const
    {
        if( !Count() )
            return 0;

        int iLeft,
            iRight,
            idx;
	    
        idx = 0;
        iLeft = 0;
        iRight = Count() - 1;
        while( iRight > iLeft )
        {
            idx = (iLeft + iRight)/2;        
            if( *pToFind < *(*this)[idx] )
                  iRight = idx-1;
            else  iLeft = idx+1;
        }
        return( *pToFind < *(*this)[iLeft] ? iLeft : iLeft+1 );
    }



//===============================================================================================

#endif // __DRG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\hash.h ===
/*
********************************************************************
* 
* 
* Module: HASH.H 
* 
* Author: ThomasOl
* 
* Description: General purpose
* 
* 
********************************************************************
*/

#ifndef __HASH_H__
#define __HASH_H__

#ifndef New
#define New new
#endif

#ifndef Delete
#define Delete delete
#endif

/*
********************************************************************
* 
* CListElement class definition
* 
********************************************************************
*/

template <class T>
class CListElement
{
protected:
    T*            m_pT;
    CListElement* m_pPrev;
    CListElement* m_pNext;

protected:
    void DestroyData(void) 
		{if (m_pT) Delete m_pT;m_pT=NULL;}
	void Init(void) 
		{m_pT=NULL;m_pPrev=NULL;m_pNext=NULL;};

public:
    CListElement() 
		{Init();}
    CListElement(T* pT) 
		{Init();SetData(pT);}
    virtual ~CListElement() 
		{DestroyData();}
    T* GetData(void) 
		{return m_pT;}

    BOOL SetData(T* pT) 
    {
        if ((m_pT=(T*)New T))
        {
            *m_pT = *pT;
            return TRUE;
        }
        return FALSE;
    }
    
    int operator==(const CListElement& le) const
    {
		if (le.m_pT && m_pT)
			return (*le.m_pT == *m_pT);
		return 0;
    }
    void SetPrev( CListElement* prev) {m_pPrev=prev;}
    void SetNext( CListElement* next) {m_pNext=next;}
    CListElement* GetPrev(void) {return m_pPrev;}
    CListElement* GetNext(void) {return m_pNext;}
};


/*
********************************************************************
* 
* CList class definition
* 
********************************************************************
*/

template <class T>
class CList
{
public:
    CListElement<T>*    m_pHead;

public:
    CList() 
		{m_pHead=NULL;}
    virtual ~CList() 
		{DestroyList();}

    void DestroyList(void)
    {
        CListElement<T>* ple=m_pHead;
        while (ple)
        {
            CListElement<T>* pne = ple->GetNext();
            Delete ple;
            ple = pne;
        }
		m_pHead = NULL;
    }
    
	CListElement<T>* Find(T* pT)
	{
        CListElement<T>* ple=m_pHead;
		CListElement<T> le(pT);
        while (ple)
        {
            if (*ple == le)
                return ple;
            ple = ple->GetNext();
        }
		return NULL;
	}

    BOOL Insert(T* pT)
    {
        if (Find(pT))			//can't insert if it's already in hash table
			return FALSE;

		CListElement<T>* ple = New CListElement<T>;
        if (ple && ple->SetData(pT))
        {
            if (m_pHead)
			{
                m_pHead->SetPrev(ple);
				ple->SetNext(m_pHead);
			}
            m_pHead = ple;
            return TRUE;
        }
        return FALSE;
    }
    
    BOOL Remove(T* pT)
    {
        CListElement<T>* ple = Find(pT);

		if (ple)
		{
            CListElement<T>* prev=ple->GetPrev();
            CListElement<T>* next=ple->GetNext();
    
            if (prev)
                prev->SetNext(next);
            if (next)
                next->SetPrev(prev);
            if (ple==m_pHead)
                m_pHead=next;
        	return TRUE;
		}
        return FALSE;
    }
};


/*
********************************************************************
* 
* CHashTable class definition
* 
********************************************************************
*/

#define NUM_HASH_BUCKETS 4097

template <class T>
class CHashTable
{
protected:
    CList<T> m_table[NUM_HASH_BUCKETS];
    DWORD m_dwIndex;
    CListElement<T>* m_pcListElement;
	ULONG m_lCount;

protected:
    virtual DWORD Hash(T* pT)=0;

public:
    CHashTable() {m_dwIndex=0;m_pcListElement=NULL;}
    virtual ~CHashTable() {}
    

    BOOL Insert(T* pT)
    {
        DWORD dwIndex=Hash(pT);
		BOOL fRet = m_table[dwIndex].Insert(pT);
		if (fRet)
		{
			++m_lCount;
		}
        return fRet;
    }
    
    BOOL Remove(T* pT)
    {
        DWORD dwIndex=Hash(pT);
		BOOL fRet = m_table[dwIndex].Remove(pT);
		if (fRet)
		{
			--m_lCount;
		}
        return fRet;
    }

	T*  Find(T* pT)
	{
		DWORD dwIndex=Hash(pT);
		CListElement<T>* ple = m_table[dwIndex].Find(pT);
		return (ple) ? ple->GetData() : NULL;
	}

    T*  FindFirst(void)
    {
        for (m_dwIndex=0; m_dwIndex < NUM_HASH_BUCKETS; m_dwIndex++)
        {
            if (m_pcListElement=m_table[m_dwIndex].m_pHead)
                return m_pcListElement->GetData();
        }
        return NULL;
    }


    T*  FindNext(void)
    {
        if (!m_pcListElement)
            return NULL;

        if (m_pcListElement = m_pcListElement->GetNext())
            return m_pcListElement->GetData();

        for (++m_dwIndex; m_dwIndex < NUM_HASH_BUCKETS; m_dwIndex++)
        {
            if (m_pcListElement=m_table[m_dwIndex].m_pHead)
                return m_pcListElement->GetData();
        }
        return NULL;
    }

	ULONG Count(void)
	{
		return m_lCount;
	}
};

#endif //__HASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\idguids.h ===
//	GUIDs used for IDispatch collection interfaces
//	8/27/96 VK : Changed IEnumIDispatch to IEnumDispatch


// {66E5EC80-E669-11cf-B8DF-00AA00BBAF4D}
DEFINE_GUID(IID_IEnumDispatch, 
0x66e5ec80, 0xe669, 0x11cf, 0xb8, 0xdf, 0x0, 0xaa, 0x0, 0xbb, 0xaf, 0x4d);

// {66E5EC81-E669-11cf-B8DF-00AA00BBAF4D}
DEFINE_GUID(IID_IDispatchCollectionAugment,
0x66e5ec81, 0xe669, 0x11cf, 0xb8, 0xdf, 0x0, 0xaa, 0x0, 0xbb, 0xaf, 0x4d);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\ienumid.h ===
//	IDispatch enumerator interface
//	8/27/96 VK : Changed IEnumIDispatch to IEnumDispatch

#ifndef __IENUMID_H__
#define __IENUMID_H__

DECLARE_INTERFACE_( IEnumDispatch, IUnknown )
{
	STDMETHOD ( QueryInterface )( REFIID, void** )		PURE;
	STDMETHOD_( ULONG, AddRef )( void )					PURE;
	STDMETHOD_( ULONG, Release )( void )				PURE;

	STDMETHOD ( Next )( ULONG, IDispatch**, LPDWORD )	PURE;
	STDMETHOD ( Skip )( ULONG )							PURE;
	STDMETHOD ( Reset )( void )							PURE;
	STDMETHOD ( Clone )( IEnumDispatch ** )				PURE;
};
typedef IEnumDispatch *PENUMDISPATCH;

#endif //__IENUMID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\itimer.h ===
#ifndef __ITIMER_H__
#define __ITIMER_H__

// Timer service modelled on the Trident proposal.

#define TIME_INFINITE 0xffffffff

DECLARE_INTERFACE_(ITimerServiceInit, IUnknown)
{
	STDMETHOD(Init)		(THIS) PURE;
	STDMETHOD(IsReady)	(THIS) PURE;
};

#endif

// End of ITimer.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\mathwrap.h ===
#ifndef __CMATH_H__
#define __CMATH_H__

class CMathWrapper
{

 private :

	static OTrig s_otrig;

 public :

	CMathWrapper (void);
	~CMathWrapper (void);

	static EXPORT float Pow( double x, double y );
	static EXPORT float __fastcall Sqrt( float x );

	static EXPORT	float __fastcall	SinDeg (float	fltAngle);
	static EXPORT	float __fastcall	CosDeg (float	fltAngle);
	static EXPORT	float __fastcall	SinDeg (long	lAngleOneTenths);
	static EXPORT	float __fastcall	CosDeg (long    lAngleOneTenths);

    static EXPORT	float __fastcall	SinDegWrap (float	fltAngle);
	static EXPORT	float __fastcall	CosDegWrap (float	fltAngle);
	static EXPORT	float __fastcall	SinDegWrap (long	lAngleOneTenths);
	static EXPORT	float __fastcall	CosDegWrap (long    lAngleOneTenths);

	static EXPORT double __fastcall SinRad (double dblRads);
	static EXPORT double __fastcall CosRad (double dblRads);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\idcol.h ===
//	IDispatch collection, with augment and enumerate interfaces
//	8/27/96 VK : Changed IEnumIDispatch to IEnumDispatch

#ifndef _IDISPATCHCOLLECTION_H_
#define _IDISPATCHCOLLECTION_H_

#include "IEnumID.h"
#include "IIdCol.h"

#define CPTRS	50	// Hard-coded array size and max.  Must change.  BUGBUG

class CIDispatchCollection : public IUnknown
{
	class CDispatchCollectionAugment : public IIDispatchCollectionAugment
	{
		public:
		STDMETHODIMP			QueryInterface ( REFIID, void** );
		STDMETHODIMP_(ULONG)	AddRef ( void );
		STDMETHODIMP_(ULONG)	Release ( void );

		STDMETHODIMP			AddToCollection ( IDispatch* );

		CDispatchCollectionAugment::CDispatchCollectionAugment ( CIDispatchCollection* pObj );
		CDispatchCollectionAugment::~CDispatchCollectionAugment ();
		
		private:
		ULONG					m_cRef;			// Reference count (for debugging purposes)
		CIDispatchCollection	*m_poBackPtr;	// Pointer to containing object
	};

	class CDispatchCollectionEnum : public IEnumDispatch
	{
		public:
		STDMETHODIMP			QueryInterface ( REFIID, void** );
		STDMETHODIMP_(ULONG)	AddRef ( void );
		STDMETHODIMP_(ULONG)	Release ( void );

		STDMETHODIMP			Next ( ULONG, IDispatch**, ULONG * );
		STDMETHODIMP			Skip ( ULONG );
		STDMETHODIMP			Reset ( void );
		STDMETHODIMP			Clone ( PENUMDISPATCH * );
		
		CDispatchCollectionEnum::CDispatchCollectionEnum ( CIDispatchCollection* pObj );
		CDispatchCollectionEnum::~CDispatchCollectionEnum ();

		private:
		ULONG					m_cRef;			// Reference count (for debugging purposes)
		ULONG					m_iCur;         // Current enum position
		CIDispatchCollection	*m_poBackPtr;	// Pointer to containing object
	};
	
	friend CDispatchCollectionAugment;
	friend CDispatchCollectionEnum;

	private:
	ULONG		m_cRef;			// Reference count
	ULONG		m_cPtrs;		// Current count of IDispatches contained
	IDispatch*	m_rpid[CPTRS];	// IDispatch pointers we enumerate

	CDispatchCollectionAugment	m_oAugment;
	CDispatchCollectionEnum		m_oEnum;

    public:
	STDMETHODIMP				QueryInterface ( REFIID, void** );
	STDMETHODIMP_(ULONG)		AddRef ( void );
	STDMETHODIMP_(ULONG)		Release ( void );

	CIDispatchCollection ( void );
	~CIDispatchCollection ( void );
};


typedef CIDispatchCollection *PCIDispatchCollection;


//Function that creates one of these objects
BOOL EXPORT WINAPI CreateIDispatchCollection ( IUnknown **ppUnk );

#endif //_IDISPATCHCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\iidcol.h ===
//	IIDCollection interface: add items to the IEnumID collection
//	Add items by passing IDispatch interface pointers to AddToCollection.
//	They will be AddRefed, so the caller must Release the pointers after calling
//	AddToCollection.
//	Cloning AddRefs each member, so the IDispatch interface isn't released until the
//	last enumerator is released.
//
//	AddToCollection returns an error is the pointer is invalid.

#ifndef __IIDCOL_H__
#define __IIDCOL_H__

#include <OLEAUTO.H>

typedef struct IIDispatchCollectionAugment IIDispatchCollectionAugment;
typedef IIDispatchCollectionAugment *PDISPATCHCOLLECTIONAUGMENT;


DECLARE_INTERFACE_( IIDispatchCollectionAugment, IUnknown )
{
    // IUnknown members
	STDMETHOD ( QueryInterface )( REFIID, void** )		PURE;
	STDMETHOD_( ULONG, AddRef )( void )					PURE;
	STDMETHOD_( ULONG, Release )( void )				PURE;

    // IIDispatchCollectionAugment members
	STDMETHOD ( AddToCollection )( IDispatch* )			PURE;
};

#endif //__IIDCOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\ihammer.h ===
/************************************************************
Derived from OUTLAW.H:

Shared, general header file for OMT's Peacemaker

Outlaw, summer '93

REV:     April, '96  Hammer 1.0   Norm Bryar
      Added the precompiler conditional CONSTANTS_ONLY so
      clients can get CCH_ID, et. al., without pulling in every
      header the English-speaking world has ever written.
      I did this rather than creating a seperate header for
      constants because I don't want to touch every makefile
      to inform it of a new header dependency.

*************************************************************/

#ifndef __OUTLAW_H__
#define __OUTLAW_H__
#include <builddef.h>

//#include <version.h>
#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
// PAULD #include <port.h>

//#define  EDIT_TITLE_EXT     ((LPCSTR)"EMT")
//#define  RUN_TITLE_EXT      ((LPCSTR)"RMT")

// Generated purely out of the top of my head
// Pretty random.
//#define	dwMagicSymmetry		0x70adf981

// IMPORTANT, STANDARD DEFINED STRING CONSTANTS
#define CCH_MAXSTRING                   (2*_MAX_PATH)
#define CCH_ID                          256
#define CCH_HANDLER_NAME                13
#define CCH_HANDLER_DESCRIPTION_NAME	13	// The part before the : in the description.
#define CCH_HANDLER_DESCRIPTION         81
#define CCH_FILENAME              		_MAX_FNAME
#define CCH_SHORT_FILENAME              13
#define CCH_SCRIPT_FUNCTION             27
#define CCH_TITLE_BYTES                 81
#define CCH_SCRIPT_CAPTION              41
#define CCH_OFN_FILTERS                 64
#define cchStringMaxOutlaw				512


// --- Zoom constraints ---
#define MINZOOM    25u
#define MAXZOOM    800u

#define MAX_CAPTION		256
#define MAX_NAME		CCH_ID
#define MAX_COMMENT		256
#define TEMP_SIZE_MAX	256 // temporary string buffer maximum size in bytes
#define	EVT_NAMELEN		CCH_ID


//These character constants are used to replace the first character of the handler
//name dynamically so it will refer to the right dll. Can't wait to use windows
//reg file stuff. No need for hacks like this	-PhaniV
//#define	chEditMode						'X'
//#define	chRunMode						'Z'

// The reg file always has 'E' so irrespective of the
// mode/platform we need to restore it to 'E'
//#ifdef EDIT_MODE
//#define FixHandlerName(rgch, fRestore) {*rgch= (fRestore ? 'E' : chEditMode);}
//#else
//#define FixHandlerName(rgch, fRestore) {*rgch= (fRestore ? 'E' : chRunMode);}
//#endif  // EDIT_MODE

// RUNTIME CONSTANTS
#define MAX_CME_PALETTE_ENTRIES         236
#define NUM_DEFAULT_CME_PALETTE_ENTRIES 15
#define MAX_BOUNDING_RECT_SIDE          1500

//============================================================================

// PAULD #include <outlawrc.h> // Return codes from most Hammer functions
#include <memlayer.h>
#include <debug.h>
//#include <utility.h>
//#include <archive.h>
//#include <list.h>
//#include <hash.h>

//#ifdef EDIT_MODE
//#include <chelp.h>
//#endif

//#include <stg.h>
//#include <stockid.h>
//#include <object.h>
//#include <drg.h>
//#include <iprogres.h>
//#include <iasset.h>
// PAULD #include <coml.h>

//#include <icondarg.h>
//#include <icmdtarg.h>
//#include <icmepub.h>
//#include <imop.h>
//#include <ifmonikr.h>

//// #include <mop.h>

//============================================================================

#endif  // __OUTLAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\mmx.h ===
#ifndef _INC_MMX_H
#define _INC_MMX_H

		// IsMMXCpu() returns TRUE if the CPU
		// has Intel's MMX technology.
		// Link to the IHammer utils library
		// 
	__declspec(dllexport) BOOL IsMMXCpu( void );
	

#endif // _INC_MMX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\memlayer.h ===
/*=========================================================================*\

    File    : MEMMAN.H
    Purpose : CMemManager Class Definition
    Author  : Michael Byrd
    Date    : 07/10/96

\*=========================================================================*/

#ifndef __MEMMAN_H__
#define __MEMMAN_H__

#include <stdio.h> // Needed for FILE declaration...
#include <utils.h>

/*=========================================================================*\
     Forward class declarations:
\*=========================================================================*/

class CMemUser;
class CMemManager;

/*=========================================================================*\
     Constant definitions:
\*=========================================================================*/

// We always add extra bytes (because we can't alloc 0 bytes!)
#define ALLOC_EXTRA 4 + (sizeof(int))

// Array "Grow" size constants:
#define MEMHEAPGROW     4
#define MEMUSERGROW    10
#define MEMBLOCKGROW   64

#define HEAPINITIALITEMCOUNT 64 // Initial Heap size multiplier

// Debugging info constants:
#define MAX_SOURCEFILENAME  32  // Maximum number of characters in filename

// Memory Block Flags:
#define MEM_PURGEABLE      0x0001 // Memory block is purgeable
#define MEM_MOVEABLE       0x0002 // Memory block is moveable
#define MEM_EXTERNAL_FLAGS (MEM_PURGEABLE|MEM_MOVEABLE)

// Internal block flags:
#define MEM_SUBALLOC       0x8000 // Memory block is from sub-allocation

#define MEM_INTERNAL_FLAGS (MEM_SUBALLOC)

/*=========================================================================*\
     Type declarations:
\*=========================================================================*/

typedef struct HEAPHEADER_tag
{
    BOOL       fInUse;           // Flag to indicate usage
    HANDLE     handleHeap;       // Handle returned by HeapCreate
    DWORD      dwBlockAllocSize; // Size of object allocations
    int        iNumBlocks;       // Number of blocks currently allocated
} HEAPHEADER, FAR *LPHEAPHEADER;

typedef struct MEMBLOCK_tag
{
    BOOL      fInUse;           // Flag to indicate usage
    LPVOID    lpData;           // Pointer to actual bits of this memory block
    DWORD     dwSize;           // Size of this memory block
    WORD      wFlags;           // Flags associated with this memory block
    WORD      wLockCount;       // Lock Count on this memory block
    int       iHeapIndex;       // Index of heap where this was allocated
    int       iMemUserIndex;    // Index of CMemUser that allocated this
#ifdef _DEBUG
    int       iLineNum;         // Line number where created
    char      rgchFileName[MAX_SOURCEFILENAME]; // Filename where created
#endif // _DEBUG
} MEMBLOCK, FAR *LPMEMBLOCK;

typedef struct MEMUSERINFO_tag
{
    BOOL       fInUse;          // Flag to indicate usage
    DWORD      dwThreadID;      // Thread ID of the CMemUser object
    CMemUser  *lpMemUser;       // Pointer to the MEMUSER object
    int        iNumBlocks;      // Number of blocks currently allocated
} MEMUSERINFO, FAR *LPMEMUSERINFO;

// Notification types...
typedef enum
{
    eMemNone      = 0,  // No information available
    eMemAllocated = 1,  // Memory was allocated
    eMemResized   = 2,  // Memory was re-sized (re-allocated)
    eMemLowMemory = 3,  // Encountered a low-memory situation
    eMemDeleted   = 4,  // Memory was deleted
    eMemPurged    = 5   // Memory was purged
} MEMNOTIFYCODE;

// Notification structure...
typedef struct MEMNOTIFY_tag
{
    MEMNOTIFYCODE eNotifyCode;  // eMemXXXX notification code
    LPMEMBLOCK    lpMemBlock;   // MEMBLOCK for notification
} MEMNOTIFY, FAR *LPMEMNOTIFY;

/*=========================================================================*\
     CMemUser Class: (Provides notification mechanism)
\*=========================================================================*/

class FAR CMemUser
{
public:
    EXPORT CMemUser(void);
    EXPORT virtual ~CMemUser(void);

    // Basic memory allocation routines
    LPMEMBLOCK EXPORT AllocBuffer(DWORD dwBytesToAlloc, WORD wFlags);
    void EXPORT FreeBuffer(LPMEMBLOCK lpMemBlock);

    // Lock/Unlock methods (for purgeable memory)
    LPVOID EXPORT LockBuffer(LPMEMBLOCK lpMemBlock);
    void EXPORT UnLockBuffer(LPMEMBLOCK lpMemBlock);

    // Callback to notify the CMemUser of some action being taken...
    virtual BOOL EXPORT NotifyMemUser(LPMEMNOTIFY lpMemNotify);
};

/*=========================================================================*\
     CMemManager Class:
\*=========================================================================*/

class FAR CMemManager
{
public:
    // Construction
    EXPORT CMemManager(void);
    EXPORT virtual ~CMemManager(void);

#ifdef _DEBUG
    LPVOID EXPORT AllocBuffer(DWORD dwBytesToAlloc, WORD wFlags, int iLine, LPSTR lpstrFile);
    LPVOID EXPORT ReAllocBuffer(LPVOID lpBuffer, DWORD dwBytesToAlloc, WORD wFlags, int iLine, LPSTR lpstrFile);
#else // !_DEBUG
    LPVOID EXPORT AllocBuffer(DWORD dwBytesToAlloc, WORD wFlags);
    LPVOID EXPORT ReAllocBuffer(LPVOID lpBuffer, DWORD dwBytesToAlloc, WORD wFlags);
#endif // !_DEBUG

    VOID   EXPORT FreeBufferMemBlock(LPMEMBLOCK lpMemBlock);
    VOID   EXPORT FreeBuffer(LPVOID lpBuffer);
    DWORD  EXPORT SizeBuffer(LPVOID lpBuffer);

    BOOL   EXPORT RegisterMemUser(CMemUser *lpMemUser);
    BOOL   EXPORT UnRegisterMemUser(CMemUser *lpMemUser);

    VOID   EXPORT DumpAllocations(LPSTR lpstrFilename=NULL);

    // Global access to single g_CMemManager:
#ifdef _DEBUG
    static LPVOID EXPORT AllocBufferGlb(DWORD dwBytesToAlloc, WORD wFlags, int iLine, LPSTR lpstrFile);
    static LPVOID EXPORT ReAllocBufferGlb(LPVOID lpBuffer, DWORD dwBytesToAlloc, WORD wFlags, int iLine, LPSTR lpstrFile);
#else // !_DEBUG
    static LPVOID EXPORT AllocBufferGlb(DWORD dwBytesToAlloc, WORD wFlags);
    static LPVOID EXPORT ReAllocBufferGlb(LPVOID lpBuffer, DWORD dwBytesToAlloc, WORD wFlags);
#endif // !_DEBUG

    static VOID   EXPORT FreeBufferGlb(LPVOID lpBuffer);
    static DWORD  EXPORT SizeBufferGlb(LPVOID lpBuffer);

    static BOOL   EXPORT RegisterMemUserGlb(CMemUser *lpMemUser);
    static BOOL   EXPORT UnRegisterMemUserGlb(CMemUser *lpMemUser);

    static VOID   EXPORT DumpAllocationsGlb(LPSTR lpstrFilename=NULL);

private:
    // Internal management routines...
    void Cleanup(void);
    BOOL CreateHeap(DWORD dwAllocationSize);
    BOOL DestroyHeap(HANDLE handleHeap);
    int  FindHeap(DWORD dwAllocationSize, LPHEAPHEADER lpHeapHeader);

    LPVOID AllocFromHeap(int iHeapIndex, DWORD dwAllocationSize);
    BOOL   FreeFromHeap(int iHeapIndex, LPVOID lpBuffer);

    LPMEMBLOCK AllocMemBlock(int *piIndex);
    BOOL       FreeMemBlock(LPMEMBLOCK lpMemBlock, int iMemBlockIndex=-1);
    LPMEMBLOCK FindMemBlock(LPVOID lpBuffer, int *piIndex=NULL);

    VOID EXPORT DumpHeapHeader(LPHEAPHEADER lpHeapHeader, FILE *fileOutput);
    VOID EXPORT DumpMemUserInfo(LPMEMUSERINFO lpMemUserInfo, FILE *fileOutput);
    VOID EXPORT DumpMemBlock(LPMEMBLOCK lpMemBlock, FILE *fileOutput);

private:
    CRITICAL_SECTION m_CriticalHeap;
    CRITICAL_SECTION m_CriticalMemUser;
    CRITICAL_SECTION m_CriticalMemBlock;

    HANDLE           m_handleProcessHeap; // Default Process Heap handle

    int              m_iNumHeaps;      // Number of Allocated heaps
    LPHEAPHEADER     m_lpHeapHeader;   // Array of HEAPHEADER

    int              m_iNumMemUsers;   // Number of Allocated CMemUser
    LPMEMUSERINFO    m_lpMemUserInfo;  // Array of MEMUSERINFO

    int              m_iNumMemBlocks;  // Number of Allocated MEMBLOCK
    LPMEMBLOCK      *m_lplpMemBlocks;  // Pointer to Array of LPMEMBLOCK pointers

    int              m_iMemBlockFree;  // Index of first free MEMBLOCK

private:
    static CMemManager g_CMemManager;  // Global instance of memory manager
};

/*=========================================================================*/

// Global operator new/delete:

#ifdef _DEBUG

  #define DEBUG_OPERATOR_NEW
  #define New    new FAR (__LINE__, __FILE__)
  #define Delete delete

  #define MemAlloc(numBytes)             CMemManager::AllocBufferGlb(numBytes, 0, __LINE__, __FILE__)
  #define MemReAlloc(lpBuffer, numBytes) CMemManager::ReAllocBufferGlb(lpBuffer, numBytes, 0, __LINE__, __FILE__)
  #define MemFree(lpBuffer)              CMemManager::FreeBufferGlb(lpBuffer)
  #define MemSize(lpBuffer)              CMemManager::SizeBufferGlb(lpBuffer)

  __inline LPVOID __cdecl operator new(size_t cb, LONG cLine, LPSTR lpstrFile) 
  { return   CMemManager::AllocBufferGlb(cb, 0, cLine, lpstrFile); }

  __inline VOID __cdecl operator delete(LPVOID pv) 
  { CMemManager::FreeBufferGlb(pv); }

#else // !_DEBUG

  #undef DEBUG_OPERATOR_NEW
  #define New    new FAR
  #define Delete delete

  #define MemAlloc(numBytes)             CMemManager::AllocBufferGlb(numBytes, 0)
  #define MemReAlloc(lpBuffer, numBytes) CMemManager::ReAllocBufferGlb(lpBuffer, numBytes, 0)
  #define MemFree(lpBuffer)              CMemManager::FreeBufferGlb(lpBuffer)
  #define MemSize(lpBuffer)              CMemManager::SizeBufferGlb(lpBuffer)

  __inline LPVOID __cdecl operator new(size_t cb)
  { return CMemManager::AllocBufferGlb(cb, 0); }
  __inline VOID __cdecl operator delete(LPVOID pv)
  { CMemManager::FreeBufferGlb(pv); }

#endif // !_DEBUG

#define MemReallocZeroInit(p, cb) MemReAlloc(p, cb)
#define MemAllocZeroInit(cb)      MemAlloc(cb)
#define MemGetHandle(p)           (p)
#define MemLock(h)                (h)
#define MemUnlock(h)              (NULL)

/*=========================================================================*/

#endif // __MEMMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\proputil.h ===
#ifndef __PROPUTIL_H__
#define __PROPUTIL_H__

HRESULT EXPORT ReadBstrFromPropBag(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, LPSTR pszName, OLECHAR ** pbstr);
HRESULT EXPORT WriteBstrToPropBag(LPPROPERTYBAG pPropBag, LPSTR pszName, LPOLESTR bstrVal);

HRESULT EXPORT ReadLongFromPropBag(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, LPSTR pszName, LONG * plValue);
HRESULT EXPORT WriteLongToPropBag(LPPROPERTYBAG pPropBag, LPSTR pszName, LONG lValue);

#endif

// End of PropUtil.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\otrig.h ===
/*+********************************************************
MODULE: OTRIG.H
AUTHOR: PhaniV
DATE: Jan '97

DESCRIPTION: OTrig class for a table look up sin and cos functions.
*********************************************************-*/


#ifndef __OTRIG_H__
#define __OTRIG_H__

//===============================================================================================
#define		cSinCosEntries	3601
class	OTrig
{
private:
	static	float	s_rgfltSin[cSinCosEntries];
	static	float	s_rgfltCos[cSinCosEntries];
	static	BOOL	s_fCalculated;

	void PreCalcRgSinCos(void);

public:
	EXPORT	OTrig(void);

        // These versions of the functions do no range checking!
        // Caller is responsible for ensuring 0.0 - 360.0 range.
        // _DEBUG ihamutil will assert, that's it.
        // It's faster this way.
	EXPORT	float __fastcall	Sin(float	fltAngle);
	EXPORT	float __fastcall	Cos(float	fltAngle);
	EXPORT	float __fastcall	Sin(long	lAngleOneTenths);
	EXPORT	float __fastcall	Cos(long    lAngleOneTenths);

        // These versions of the functions will wrap the input
        // into the 0.0-360.0 range for you.
    EXPORT	float __fastcall	SinWrap(float	fltAngle);
	EXPORT	float __fastcall	CosWrap(float	fltAngle);
	EXPORT	float __fastcall	SinWrap(long	lAngleOneTenths);
	EXPORT	float __fastcall	CosWrap(long    lAngleOneTenths);

};
#endif // __OTRIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\params.h ===
/*-----------------------------------------------------------------------------
@doc
@module params.h | Method param class definitions.
@author 12-13-96 | pauld | Broke out from action classes and Autodoc'd
-----------------------------------------------------------------------------*/

#ifndef _PARAMS_H_
#define _PARAMS_H_

//	Represents a single parameter for an automation mehtod.
//
class CMethodParam
{

public:

	CMethodParam ();
	virtual ~CMethodParam ();

	BOOL Init ( BSTR bstrName, BOOL fOptional, VARTYPE vt );

	unsigned short	GetName ( char* szName, unsigned short wBufSize );
	BOOL			IsOptional ()	{ return m_fOptional; }
	VARTYPE			GetType ()		{ return m_varType; }
	HRESULT			GetVal ( VARIANT *pVar );
	HRESULT			SetVal ( VARIANT *pVar );

	// Persistence functions
	void			SaveOnString ( TCHAR* ptcText, DWORD dwLength );
	LPTSTR LoadVariantFromString	(LPTSTR szParamString);

	BOOL	EXPORT	SetName ( BSTR bstrName );
	void	EXPORT	SetOptional ( BOOL fOptional );
	void	EXPORT	SetVarType ( VARTYPE vt );

	// Trim leading commas and whitespace.
	static LPTSTR TrimToNextParam (LPTSTR szNextParam);

private:

	void	CleanOutEscapes			(LPTSTR szParamString, int iStringLength);
	LPTSTR ProcessStringParam (LPTSTR szParamString);
	BOOL	NeedEscape				(LPCTSTR szSourceText) const;
	int		CountEscapesOnString	(LPTSTR szParamString, int iLength) const;
	void	InsertEscapes			(LPTSTR szNewText, LPTSTR szSourceText, int cChars);
	void	SaveStringParamToString	(LPTSTR ptcActionText, DWORD dwLength);
	VARTYPE	NarrowVarType			(VARTYPE p_vt);

	char	*m_szName;
	BOOL	m_fOptional;
	VARTYPE	m_varType;
	VARIANT	m_var;
};


#endif _PARAMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\quickie.h ===
#ifndef INC_QUICKIE_H_
#define INC_QUICKIE_H_
/*-----------------------------------------------
    IHammer\inc\quickie.h--
    This header contains various lightnin'-fast
    inline utilties that otherwise don't have a home.
    
    NormB               Jan., '97    Created
  ---------------------------------------------*/

#ifndef _INC_FLOAT
  #include <float.h>
#endif _INC_FLOAT

#ifndef _INC_MATH
  #include <math.h>
#endif _INC_MATH

	// If you want fastest possible code, envelope it in
	// #pragma LIGHTNING  your-code-here #pragma ENDLIGHTNING
	// 
#ifdef _DEBUG
  #define LIGHTNING       optimize( "agt", on )
#else
  #define LIGHTNING       optimize( "agtyib1", on )
#endif // _DEBUG
#define ENDLIGHTNING    optimize( "", on )

#ifndef NO_INTRIN_MEM
#pragma warning( disable : 4164 )
#pragma intrinsic( memcmp, memset, memcpy )
#pragma warning( default : 4164 )
#endif // NO_INTRIN_MEM

#ifndef NO_INTRIN_MATH
#pragma intrinsic( fabs, labs, abs, \
                   sin, cos, tan, log, exp, sqrt )
#endif // NO_INTRIN_MATH

// note: see also recsqrt.h for the fastest "/ sqrt(x)"

// ----------------------------------

    // This is a faster (under /G5 /Ogit /Ob1) square-root routine
    // It operates on integer values 0 - 32768^2
    // and does so up to 60% faster than sqrt().
    // Caveat: (float) psi_sqrt((long) fval) takes *longer* than sqrt!
    // although (float) psi_sqrt( lval ) is still faster.
    // For floating-point sqrt, use sqrt()!!!!
    // Note: no checks for v<0.
inline int _fastcall  psi_sqrt(long v)
/* // Calculates the square root of a 32-bit number.*/
{    
  register long t = 1L << 30, r = 0, s;
  #define PSISTEP(k) \
    s = t + r; \
    r >>= 1; \
    if (s <= v) { \
        v -= s; \
        r |= t; \
    }

    PSISTEP(15); t >>= 2;
    PSISTEP(14); t >>= 2;
    PSISTEP(13); t >>= 2;
    PSISTEP(12); t >>= 2;
    PSISTEP(11); t >>= 2;
    PSISTEP(10); t >>= 2;
    PSISTEP(9); t >>= 2;
    PSISTEP(8); t >>= 2;
    PSISTEP(7); t >>= 2;
    PSISTEP(6); t >>= 2;
    PSISTEP(5); t >>= 2;
    PSISTEP(4); t >>= 2;
    PSISTEP(3); t >>= 2;
    PSISTEP(2); t >>= 2;
    PSISTEP(1); t >>= 2;
    PSISTEP(0);

    return r;

  #undef PSISTEP
}

// ----------------------------------

    // note: dotprodcut() doesn't use recsqrt
    // 'cause it turned out to be slower!  
    // Possibly as x,y,z typically ints cast to floats?
inline float dotproduct(float x1, float y1, float z1, float x2, float y2, float z2)
{
	//normalize the vector
	float dist;

    dist  = (x1*x1 + y1*y1 + z1*z1) * 
            (x2*x2 + y2*y2 + z2*z2);

    return (x1*x2 + y1*y2 + z1*z2)/(float)( sqrt(dist) + 1.0e-16);
}


// ----------------------------------

    // Use this instead of casting to convert float to int.
    // C/C++ generates _ftol calls that truncate the float
    // contrary to the round-to-even native to Intel chips.
    // Float2Int is thus more accurate and 25% faster than casts!
inline int _fastcall Float2Int( float fl )
{   
#if _M_IX86 >= 300 
    register int iRes;
    _asm{
        fld    fl
        fistp  iRes
    }
    return iRes;
#else
    return static_cast<int>(fl+0.5f);
#endif // Intel-chip
}

// ---------------------------------

#ifndef OFFSETPTR
#define OFFSETPTR
template< class T>
inline T OffsetPtr( T pT, int cb )
{
    return reinterpret_cast<T>( cb + 
        static_cast<char*>(const_cast<void*>(static_cast<const void*>(pT))) );
}
#endif // OFFSETPTR

// ----------------------------------

    // Untested on negative valued args    
template< class T >
inline T Div255( T arg )
{    
    return ((arg+128) + ((arg+128)>>8))>>8;
}

    // ...shifts don't work on floats
template<>
inline float Div255( float arg )
{  return arg / 255.0f;  }

template<>
inline double Div255( double arg )
{ return arg / 255.0; }

// ----------------------------------

#endif // INC_QUICKIE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\recsqrt.h ===
#ifndef _INC_RECSQRT_H
#define _INC_RECSQRT_H
/*------------------------------------------------------

  recsqrt.h -- 
  A faster-than-blazes implementation of reciprocal
  square-root (1 / sqrt(f)), float recsqrt(float).
  Using recsqrt() on binary-irrational numbers can save ~40%!
  NOTE: 1/sqrt() is faster, however, on ints cast to floats!
  Profile your code both ways to be sure.

  If you wish to use this, one of your source-files must
  #define RECSQRT_INIT prior to including this header.
  
  Note: the algorithm assumes input lies in (0.5 to 2.56M]
  (CRecSqrtTable_s_fLowBound, CRecSqrtTable_s_fHighBound],
  numbers chosen as a typical range occupied by vector
  magnitudes on high-resolution video.  
  For inputs outside this range, the algorithm falls-back
  to 1.0f / sqrt(f), only with added overhead.

  Note: REVIEW marks design decisions I haven't profiled.
  Need to run Intel's VTune2.1 dynamic-assembler analysis.

  Author:  Norm Bryar       Feb., '97

  ----------------------------------------------------*/

  #ifndef _INC_MATH
    #include <math.h>    // pow, sqrt
  #endif // _INC_MATH


    // The recsqrt() algorithm does a small number of 
    // Newton-Raphson iterations on an initial guess
    // generated by a piece-wise linear polynomial over
    // a restricted input range (a <= x <= b].
    // The range (a,b] is partitioned into sub-intervals
    // according to the paper
    //    "Optimal Partitioning of Newton's Method
    //     for Calculating Roots,"  
    //     Gunter Meinardus and G.D. Taylor,
    //     Mathematics of Computation, v35 no 152 October 1980,
    //     pp 1221-1230.
    // This partioning is critical to outperforming the Pentium's
    // intrinsic form of 1.0/sqrt(f).
    // Essentially, the subintervals are given by
    // ( a*(b/a)^j/v, a*(b/a)^(j+1)/v], each of which has a
    // linear equation optimally-adjusted (via gamma)
    // to provide the minimum-error first-guess for
    // Newton-Raphson iteration.
    // The Newton-Raphson algorithm, xN+1 = xN - f/f',
    // uses f = (1/x^2 - R) as the reciprocal root of R.
    // This form for f yields iterations w/ no divisions!

    class CRecSqrtTable
    {                
    public:
        enum { s_ctIntervals = 7 };   // chosen so m_fsubinterval
                                      // fits on one cache line

        CRecSqrtTable( );

		// If __inline is honored, __fastcall is ignored
		// Debug builds don't honor inlining.
        __inline float __fastcall GetStartingPoint( float x );        

    private:
        void CalcApproxCoeficients( );
        void CalcSubIntervals( );                

    private:
        struct lineareq 
        {
            float   a;
            float   b;
        };
		// We search m_fsubinterval first.
		// To maximize elements found in cache
		// we make it a seperate array.
		// REVIEW: profile it where interval is in lineareq
		// which might minimize cache misses getting a,b.
        static float       m_fsubinterval[ s_ctIntervals + 1 ];
        static lineareq    m_lineareq[ s_ctIntervals ];
    };
    
    #define CRecSqrtTable_s_fLowBound    0.5f
    #define CRecSqrtTable_s_fHighBound   2560000.0f

#ifdef RECSQRT_INIT

    inline CRecSqrtTable::CRecSqrtTable()
    {
        CalcSubIntervals( );
        CalcApproxCoeficients( );
    }

    inline void CRecSqrtTable::CalcSubIntervals( )
    {
        double  dGenerator;
        int     iInterval;
        
        m_fsubinterval[0] = CRecSqrtTable_s_fLowBound;

        dGenerator = CRecSqrtTable_s_fHighBound / 
                     CRecSqrtTable_s_fLowBound;
        iInterval = 1;
        while( iInterval <= s_ctIntervals )
        {
            m_fsubinterval[iInterval] = (float) 
                ((double) CRecSqrtTable_s_fLowBound * 
                 pow( dGenerator, 
                      ((double) iInterval) / s_ctIntervals ));
            ++iInterval;
        }
    }

        // REVIEW: We can always calculate this once, offline,
        // and just make a const array of initialized data.
        // This would probably go in .rdata and shorten
        // load-times and shrink workingset.
    inline void CRecSqrtTable::CalcApproxCoeficients( )
    {
        const  double three_3_2 =  5.196152422707;  // 3^3/2
        double alpha;
        double beta;
        double gamma;
        double lamda;
        double lamda_ba_geommean;
        double lamda_ba_normmean;
        float  a;
        float  b;
        int    iInterval = 0;

        while( iInterval < s_ctIntervals )
        {
            a = m_fsubinterval[ iInterval ];
            b = m_fsubinterval[ iInterval + 1 ];

            lamda_ba_geommean = three_3_2 * sqrt(a * b ) * 
                                (sqrt(b) + sqrt(a));
            lamda_ba_normmean = (b + sqrt(a * b) + a);
            lamda_ba_normmean *= 2 * sqrt(lamda_ba_normmean);
            lamda = (lamda_ba_normmean - lamda_ba_geommean) /
                    (lamda_ba_normmean + lamda_ba_geommean);

            alpha = (lamda - 1.0) / 
                    (sqrt(a*b) * (sqrt(b) + sqrt(a)));
            beta  = -(b + sqrt(a*b) + a) * alpha;
            gamma = 1.0; // sqrt( 3.0 / (3.0 - lamda*lamda) );

            m_lineareq[iInterval].a = (float) (gamma * alpha);
            m_lineareq[iInterval].b = (float) (gamma * beta);
            ++iInterval;
        }
    }    

    float                   CRecSqrtTable::m_fsubinterval[ CRecSqrtTable::s_ctIntervals + 1 ];
    CRecSqrtTable::lineareq CRecSqrtTable::m_lineareq[ CRecSqrtTable::s_ctIntervals ];
    CRecSqrtTable           g_recsqrttable;

#else  // user must have defined RECSQRT_INIT in another cpp file

    extern CRecSqrtTable g_recsqrttable;

#endif // RECSQRT_INIT

       // __fastcall for use in _DEBUG builds (ie /Ob0 - no inlining)
    inline float __fastcall CRecSqrtTable::GetStartingPoint( float x )
    {
            // intentional bit-wise AND, 
            // produces less asm instructions and 
            // no short-circuit branch to foul branch-prediction.
            // Pentium assumes this if will pass and will have
            // prefetched the instructions inside the if.
        if( (x >  CRecSqrtTable_s_fLowBound) & 
            (x <= CRecSqrtTable_s_fHighBound) )
        {
            register int  i = s_ctIntervals;

                // As the sub-intervals are much larger at the top
                // we begin at the top and walk down.
                // For even-distribution of x, yields fewest loops
                // Range test above ensures i < s_ctIntervals
                // If you *know* you're args cluster around 1,
                // you may want while(x > m[++i]) NULL; --i;
                // REVIEW: Cache assumes sequential, increasing access;
                // Consider ordering 2M at [0] and 0.5 at [N] instead
	            // thus maximizing cache hits as we increment i.
            while( x <= m_fsubinterval[--i] )
                NULL;
            
            return (m_lineareq[i].a * x) +m_lineareq[i].b;
        }
        return (float) (1.0f / sqrt((double) x));
    }


    inline float __fastcall recsqrt( float flt )
    {
        register float  x;
    
        x = g_recsqrttable.GetStartingPoint( flt );
        flt *= 0.5f;    
        x = (1.5f - flt * x * x) * x;
        x = (1.5f - flt * x * x) * x;
        return x;
    }

#endif // _INC_RECSQRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\page.h ===
//@class   The following class impliments a large portion of the IPropertyPage Interface \
		// It also handles the creation of the dialog for your property or parameter page \
		// and passes message on to the correct DlgProc 
class CPropertyPage : virtual public CBaseDialog, public IPropertyPage
{

//@access Public Members
public:
	//@cmember,mfunc Constructor
	EXPORT WINAPI CPropertyPage(void);
	//@cmember,mfunc Destructor
	EXPORT virtual ~CPropertyPage(void);

	//IUnknown interface
	EXPORT STDMETHOD(QueryInterface)(REFIID, LPVOID *);
	EXPORT STDMETHOD_(ULONG, AddRef)(void) ;
	EXPORT STDMETHOD_(ULONG, Release)(void) ;
	
	// IPropertyPage methods
	EXPORT STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE pPageSite);
	EXPORT STDMETHOD(Activate)(HWND hwndParent, LPCRECT lprc, BOOL bModal);
	EXPORT STDMETHOD(Deactivate)(void);
	EXPORT STDMETHOD(GetPageInfo)(LPPROPPAGEINFO pPageInfo);
	EXPORT STDMETHOD(SetObjects)(ULONG cObjects, LPUNKNOWN FAR* ppunk);
	EXPORT STDMETHOD(Show)(UINT nCmdShow);
	EXPORT STDMETHOD(Move)(LPCRECT prect);
	EXPORT STDMETHOD(IsPageDirty)(void);
	EXPORT STDMETHOD(Help)(LPCOLESTR lpszHelpDir);
	EXPORT STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);
	STDMETHOD(Apply)(void) PURE;


	// CBaseDialog you need to override this for your dialog proc
	STDMETHOD_(LONG, LDlgProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;

protected:
	EXPORT STDMETHOD_ (void, FreeAllObjects)(void);

protected:
    ULONG			m_cRef;         // Reference count
    HINSTANCE       m_hInst;        // Module instance
    UINT            m_uIDTemplate;  // Dialog ID
    ULONG           m_cx;           // Dialog size
    ULONG           m_cy;
    UINT            m_cObjects;     // Number of objects
    BOOL            m_fDirty;       // Page dirty?
    IUnknown**		m_ppIUnknown;   // Objects to notify
    LCID            m_lcid;         // Current locale
	WORD            m_uiKillInputMsg; // Used to kill input window
	BOOL			m_fDisableUpdate; // Used to prevent re-entrency in the dialog update method
	UINT            m_uTabTextId;   // Tab string ID
	IPropertyPageSite *m_pIPropertyPageSite;    //Frame's parameter page site

}; // class CPropertyPage : virtual public CBaseDialog, public IPropertyPage





// Included to prevent compile error in dllmain.cpp
// this is declared in actclass.h
interface IObjectProxy;

//@class   The following class impliments a remaining portion of the IPropertyPage Interface \
		// for parameter pages
class CParameterPage : virtual public CPropertyPage
{

public:
	EXPORT WINAPI CParameterPage(void);
	EXPORT virtual ~CParameterPage(void);

	//IUnknown interface
	EXPORT STDMETHOD(QueryInterface)(REFIID, LPVOID *);
	
	// IPropertyPage methods (PURE in CPropertyPage)
	EXPORT STDMETHOD(Apply)(void);


	// CBaseDialog you need to override this for your dialog proc
	STDMETHOD_(LONG, LDlgProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;

protected:
	EXPORT STDMETHOD (GetInitialData)(void);
	EXPORT STDMETHOD_(unsigned short, ParamTypeToString)( VARTYPE vt, char* szTypeName, unsigned short wBufSize );
	EXPORT STDMETHOD (Validate)(void);

protected:
	IObjectProxy*   m_piObjectProxy;//Pointer to ObjectProxy interface
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\urlarchv.h ===
#ifndef _INC_URLARCHV_H
#define _INC_URLARCHV_H

#ifndef __urlmon_h__
  #include <urlmon.h>
#endif // __urlmon_h__

#ifndef EXPORT
  #define EXPORT __declspec( dllexport )
#endif // EXPORT

// -----------------------------
    
class CURLArchive
{
public:
    enum origin { start   = STREAM_SEEK_SET,
                  current = STREAM_SEEK_CUR,
                  end     = STREAM_SEEK_END };

public:
    EXPORT CURLArchive( IUnknown * pUnk = NULL );
    EXPORT virtual ~CURLArchive();

        // Opens or creates the file szURL
    EXPORT virtual HRESULT Create( LPCSTR szURL );

    EXPORT virtual HRESULT Create( LPCWSTR szwURL );    

        // Closes the file
    EXPORT virtual HRESULT Close( );

    EXPORT virtual HRESULT GetFileSize( long & lSize );

        // For folks that just can't resist...
    EXPORT virtual IStream * GetStreamInterface( void ) const;

        // Reads bytes from the file.
        // 
    EXPORT virtual DWORD     Read( LPBYTE lpb,
                                   DWORD    ctBytes );

    EXPORT virtual DWORD     ReadLine( LPSTR lpstr,
                                       DWORD ctBytes );

    EXPORT virtual DWORD     ReadLine( LPWSTR lpstrw,
                                       DWORD  ctChars );

    EXPORT virtual long    Seek( long ctBytes, origin orig );

        // Writes bytes to the file.
        //
    EXPORT virtual DWORD     Write( LPBYTE lpb,
                           DWORD ctBytes );    

        // Make a local copy of the file
    EXPORT virtual HRESULT CopyLocal( LPSTR szLocalFile, int ctChars );
    EXPORT virtual HRESULT CopyLocal( LPWSTR szwLocalFile, int ctChars );    

private:
    CURLArchive( const CURLArchive & );
    CURLArchive & operator=( const CURLArchive & );

private:    
    IStream *   m_pStream;
    IUnknown *  m_pUnk;
};

#endif // _INC_URLARCHV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\transit.h ===
#ifndef __TRANSIT_H__
#define __TRANSIT_H__


// forward declares...
struct IDirectDrawSurface;


//{1F9DDD21-4146-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(CATID_BitmapTransition, 
0x1f9ddd21, 0x4146, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define CATSZ_BitmapTransitionDescription __T("Bitmap Transition")

// {ACEA25C1-415B-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(IID_IBitmapTransition, 
0xacea25c1, 0x415b, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

DECLARE_INTERFACE_(IBitmapTransition, IUnknown)
{
	STDMETHOD(SetSite)(LPUNKNOWN pUnk) PURE;
	STDMETHOD(GetMiscStatusBits)(DWORD* pdwFlags) PURE;
	STDMETHOD(GetSupportedFormatsCount)(unsigned *pcFormats) PURE;
	STDMETHOD(GetSupportedFormats)(unsigned cFormats, DWORD *pdwColorDepths) PURE;
	STDMETHOD (Begin)(DWORD  dwColorDepth, SIZE* psizeTransition,
			IDirectDrawSurface* piddsSrc, IDirectDrawSurface* piddsSrcMask,
			/* in, optional */ HDC hDC ) PURE;
	STDMETHOD(DoTransition)(HDC hdc, IDirectDrawSurface* piddsDC, RECT *prcDC, 
					   IDirectDrawSurface* piddsDst, IDirectDrawSurface* piddsDstMask,
					   RECT* prcDst, LONG lPercent) PURE;
	STDMETHOD(End)(void) PURE;

	STDMETHOD_(void,UpdatePalette)(HPALETTE hPal) PURE;
};

#endif //__TRANSIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\unknown.h ===
#ifndef __UNKNOWN_H__
#define __UNKNOWN_H__

/*
****************************************************************************
*
*
*
*
*
*
*
*
*
*
*
*
****************************************************************************
*/

#ifndef INONDELEGATINGUNKNOWN_DEFINED
#undef  INTERFACE
#define INTERFACE INonDelegatingUnknown
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NonDelegatingRelease)(THIS) PURE;
};
#define INONDELEGATINGUNKNOWN_DEFINED
#endif

typedef interface INonDelegatingUnknown *LPNONDELEGATINGUNKNOWN;

class CUnknown : public INonDelegatingUnknown, public IUnknown
{
protected:
	ULONG	m_cRef;
	LPUNKNOWN m_pUnkOuter;

public:
	CUnknown(LPUNKNOWN pUnkOuter)
	{ 
		m_cRef = 1;
		m_pUnkOuter = 
			pUnkOuter ? pUnkOuter : (LPUNKNOWN)((LPNONDELEGATINGUNKNOWN)this);
		InterlockedIncrement((LPLONG)&g_cLock);
	}
	virtual ~CUnknown() 
	{
		InterlockedDecrement((LPLONG)&g_cLock);
	}

    /* INonDelegatingUnknown Methods */
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) 
	{
    	if (IsEqualGUID(riid, IID_IUnknown))
	    {
	        *ppvObj = (LPUNKNOWN) (LPNONDELEGATINGUNKNOWN)this;
			(*(LPUNKNOWN*)ppvObj)->AddRef();
	        return(NOERROR);
	    }
	    *ppvObj = NULL;
	    return(E_NOINTERFACE);
	}

	STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)
	{
		LONG cRef = InterlockedIncrement((LPLONG)&m_cRef);
		return(cRef);
	}
	
	STDMETHOD_(ULONG,NonDelegatingRelease) (THIS)
	{
		LONG cRef = InterlockedDecrement((LPLONG)&m_cRef);
		if (0 == cRef)
		{
		 	delete this;
		}
		return cRef;
	}

    /* IUnknown Methods */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) 
		{return m_pUnkOuter->QueryInterface(riid, ppvObj);}
    STDMETHOD_(ULONG,AddRef)  (THIS)
		{return m_pUnkOuter->AddRef();}
    STDMETHOD_(ULONG,Release) (THIS)
		{return m_pUnkOuter->Release();}
};

#endif //__UNKNOWN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\typelib.h ===
// define_uuid macro - for ALL file types
#if defined(__MKTYPLIB__)
	#define define_uuid(uuidname, data1, data2, data3, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8 ) // Nothing
#elif defined(__midl)
	#define define_uuid(uuidname, data1, data2, data3, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8 ) \
		cpp_quote(stringify(EXTERN_C const IID uuidname;))
#elif defined(INITGUID)
	#define define_uuid(uuidname, data1, data2, data3, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8 ) \
		EXTERN_C const GUID uuidname = \
		{ 0x##data1, 0x##data2, 0x##data3, { 0x##d4_1, 0x##d4_2, 0x##d4_3, 0x##d4_4, 0x##d4_5, 0x##d4_6, 0x##d4_7, 0x##d4_8 } };
#else // C or C++ file (Ok if done more than once)
	#define define_uuid(uuidname, data1, data2, data3, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8 ) \
		EXTERN_C const GUID uuidname;
#endif


// **************
// **************
// **************
// macros - for ODL files
#ifndef stringify
	#define stringify(s) #s
#endif
#define GuidToString(guid)	stringify({guid})
#define CD_GUID(a)	GuidToString(a)



// ************************************************************
// ** Custom Data IDs
// ************************************************************

// CDID_ICParameterPage {708B33C1-657E-11d0-840C-00AA00BB8085}
define_uuid(CDID_ICParameterPage, 708B33C1,657E,11d0,84,0C,00,AA,00,BB,80,85)
#if defined(__midl) || defined(__MKTYPLIB__)
	#define CDID_ICParameterPage	708B33C1-657E-11d0-840C-00AA00BB8085
#endif


define_uuid(CLSID_NoParamsPage, AE56BEE5L,5403,11D0,84,0C,00,AA,00,BB,80,85)
#if defined(__midl) || defined(__MKTYPLIB__)
#define CLSID_NoParamsPage  AE56BEE5L-5403-11D0-84-0C-00-AA-00-BB-80-85
#endif

 

// **************
// **************
// **************
//	[
//	    uuid(0DA5AD44-3C2A-11d0-A069-00C04FD5C929),
//		IC_ADDIN_CODE( s:\\app\\features\\arrange\\ICArrange.vbp, ICArrange ),
//		helpstring( "Arrange events")
//	]
//	dispinterface IICArrangeAddInEvents
//	{
//		properties:
//		methods:
//
//			[
//				id(1),
//				custom(CDID_ICParameterPage, CD_GUID(<CLSID>)),
//				helpstring("Bring to front of the composition.")
//			]
//			void BringToFront();
//	}
//

#ifdef PARAMPGS_IN_TYPELIB

// Only want these when compliling C++
#ifndef __MKTYPLIB__
#ifndef __midl

EXPORT HRESULT GetFuncCustDataGUID( ITypeInfo2 *pTypeInfo, INT uiFuncIndex, REFCDID rCdid, GUID *pGuidData );
EXPORT HRESULT VariantToGUID( VARIANT *pvGuid, GUID *pGuid );


#endif // __midl
#endif // __MKTYPLIB__

#endif // PARAMPGS_IN_TYPELIB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\strwrap.h ===
#ifndef __STRWRAP_H__
#define __STRWRAP_H__

class CStringWrapper
{

 public :

	 CStringWrapper (void);
	 ~CStringWrapper (void);

	 static EXPORT LPTSTR Strcpy	(LPTSTR szDest, LPCTSTR szSource);
	 static EXPORT LPTSTR Strncpy	(LPTSTR szDest, LPCTSTR szSource, size_t nCount);
	 static EXPORT LPTSTR Strcat	(LPTSTR szDest, LPCTSTR szSource);
	 static EXPORT wchar_t * WStrcat (wchar_t *szDest, const wchar_t *szSource);
     static EXPORT int WStrlen (const wchar_t *szSource);
	 static EXPORT wchar_t * WStrcpy (wchar_t *szDest, const wchar_t *szSource);
     static EXPORT wchar_t *WStrncpy (wchar_t *szDest, const wchar_t *szSource, size_t nSize);

		// WStrCmpin - case-insensitive CompareStringW() ct chars.
		// Note: returns 0xBADBAAD on OOM or other error.
	 static EXPORT int      WStrCmpin( const wchar_t * sz1,
		                               const wchar_t * sz2,
									   size_t          ct );

	 static EXPORT int      LoadStringW(HINSTANCE hInst, 
										UINT uID, 
										wchar_t * szString, 
										int nMaxLen );
	 static EXPORT int Iswspace (wint_t c);
	 static EXPORT int         Strlen	(LPCTSTR szSource);
	 static EXPORT int         Strcmp	(LPCTSTR szLeft, LPCTSTR szRight);
	 static EXPORT int         Stricmp	(LPCTSTR szLeft, LPCTSTR szRight);
	 static EXPORT int         Strncmp	(LPCTSTR szLeft, LPCTSTR szRight, size_t nSize);
	 static EXPORT int         Strnicmp	(LPCTSTR szLeft, LPCTSTR szRight, size_t nSize);
	 static EXPORT LPTSTR Strchr	(LPCTSTR szSource, TCHAR chSearch);
	 static EXPORT LPTSTR Strrchr	(LPCTSTR szSource, TCHAR chSearch);
	 static EXPORT LPTSTR Strstr	(LPCTSTR szOne, LPCTSTR szTwo);
	 static EXPORT LPTSTR Strtok	(LPTSTR szTarget, LPCTSTR szTokens);
	 static EXPORT LPTSTR Strinc	(LPCTSTR szTarget);

// 	 static EXPORT int         Sscanf	(LPCTSTR szSource, LPCTSTR szFormat, ... );
	 static EXPORT int         Sscanf1	(LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1);
	 static EXPORT int         Sscanf2	(LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1, LPVOID pvParam2);
	 static EXPORT int         Sscanf3	(LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1, LPVOID pvParam2, LPVOID pvParam3);
	 static EXPORT int         Sprintf (LPTSTR szDest, LPCTSTR szFormat, ...);

	 static EXPORT long       Atol		(LPCTSTR szSource);
	 static EXPORT int         Atoi		(LPCTSTR szSource);

	 static EXPORT LPTSTR Ltoa			(long lSource, LPTSTR szDest, int iRadix);
	 static EXPORT LPTSTR Itoa			(int iSource, LPTSTR szDest, int iRadix);
	 
	 static EXPORT LPTSTR Gcvt			( double dblValue, int iDigits, LPTSTR szBuffer );

	 static EXPORT size_t Wcstombs		( char *mbstr, const wchar_t *wcstr, size_t count );
	 static EXPORT size_t Mbstowcs		( wchar_t *wcstr, const char *mbstr, size_t count );

	 static EXPORT int         Memcmp	(const void * pvLeft, const void * pvRight, size_t nSize);
	 static EXPORT void *	Memset		(void * pvLeft, int iValue, size_t nSize);
	 static EXPORT void *   Memcpy		( void * pvDest, const void * pvSrc, size_t count );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\strconv.h ===
#ifndef __STRCONV_H
#define __STRCONV_H


/* flag values */
#define FL_UNSIGNED   1       /* strtoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

#ifndef EXPORT
    #define EXPORT __declspec(dllexport)  
#endif

class CStrConv
{
    private:
        unsigned long EXPORT WINAPI StrToLX( const char *nptr,
                            const char **endptr,
                            int ibase,
                            int flags);



public:
    long __cdecl StrToL (
        const char *nptr,
        char **endptr,
        int ibase
        )
        {
            return (long) StrToLX(nptr, (const char **)endptr, ibase, 0);
        };

unsigned long __cdecl StrToUL (
        const char *nptr,
        char **endptr,
        int ibase
        )
        {
            return StrToLX(nptr, (const char **)endptr, ibase, FL_UNSIGNED);
        };

};

#endif //__STRCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\utils.h ===
#ifndef __UTILS_H__
#define __UTILS_H__

// Repository for commonly used macros & classes.

#pragma intrinsic(memcpy,memcmp,strcpy,strcmp)

#ifndef EXPORT
#define EXPORT __declspec(dllexport)
#endif

#ifndef QI_Base
	// Use this macro to assign to ppv in
	// your QueryInterface implementation.
	// It's preferred over just casting 'this'
	// because casting does no type-checking,
	// allowing your QI to return interfaces
	// from which your 'this' isn't derived.
	// With QI_Base, you'll get a compiler error.
  #define QI_Base( T, pObj, ppv ) \
  { T * pT = pObj;  *ppv = (void *)pT; }
#endif // QI_Base


#ifndef RELEASE_OBJECT

#define RELEASE_OBJECT(ptr)\
{ \
	Proclaim(ptr); \
	if (ptr)\
	{\
		IUnknown *pUnk = (ptr);\
		(ptr) = NULL;\
		 ULONG cRef = pUnk->Release();\
	}\
}

#endif // RELEASE_OBJECT

#ifndef ADDREF_OBJECT
#define ADDREF_OBJECT(ptr)\
{\
	Proclaim(ptr);\
    if (ptr)\
	{\
		(ptr)->AddRef();\
	}\
}

#endif // ADDREF_OBJECT




#endif	// __UTILS_H__


// End of Utils.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\surface.h ===
#ifndef __SURFACE_H__
#define __SURFACE_H__
/************************************************
 *
 *  surface.h --
 *  The IHammer-defined IDirectDrawSurface class
 *  used by transitions and effects for making
 *  masks and image-copies treated consistently
 *  with the image surfaces given us by Trident.
 *
 *  A very limited sub-set of the v1 
 *  IDirectDrawSurface is supported here! 
 *
 *  Author: Norm Bryar
 *  History:
 *     pre-history - Created for IBitmapSurface.
 *     4/97    - changed to IDirectDrawSurface.
 *     4/23/97 - moved to global inc directory
 *
 ***********************************************/

#ifndef __DDRAW_INCLUDED__
  #include <ddraw.h>
#endif // __DDRAW_INCLUDED__

	// I think we should use bpp
	// instead of DDBD_... constants
	// in DDPIXELFORMAT.dwRGBBitCount
#define DD_1BIT   1
#define DD_4BIT   4
#define DD_8BIT   8
#define DD_16BIT  16
#define DD_24BIT  24
#define DD_32BIT  32

#ifndef EXPORT
  #define EXPORT __declspec( dllexport )
#endif // EXPORT


typedef struct
{
	BITMAPINFOHEADER bmiHeader;
	RGBQUAD bmiColors[256];
} BITMAPINFO256;

    // No a class named CDirectDrawSurface,
    // there'd never be any collisions on that!
namespace IHammer {


class CDirectDrawSurface : public IDirectDrawSurface
{
public:
    EXPORT CDirectDrawSurface( HPALETTE hpal, 
							   DWORD dwColorDepth, 
							   const SIZE* psize, 
							   HRESULT * hr );
    virtual ~CDirectDrawSurface();

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
	
    //IDirectDrawSurface methods (that we care about)
    STDMETHOD (GetSurfaceDesc)( DDSURFACEDESC * pddsDesc );
    STDMETHOD (GetPixelFormat)( DDPIXELFORMAT * pddpixFormat );    

    STDMETHOD (Lock)(RECT *prcBounds, DDSURFACEDESC *pddsDesc, DWORD dwFlags, HANDLE hEvent);
    STDMETHOD (Unlock)(void *pBits);

	STDMETHOD(GetDC)(THIS_ HDC FAR *);
	STDMETHOD(ReleaseDC)(THIS_ HDC);


    // IDirectDrawSurface E_NOTIMPLs
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE);
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT);
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD );
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD);
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE);
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK);
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK);
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD);
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
    STDMETHOD(GetBltStatus)(THIS_ DWORD);
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS);
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*);
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY);    
    STDMETHOD(GetFlipStatus)(THIS_ DWORD);
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG );
    STDMETHOD(GetPalette)( THIS_ LPDIRECTDRAWPALETTE * );
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC);
    STDMETHOD(IsLost)(THIS);
    STDMETHOD(Restore)(THIS);
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER);
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY);
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG );
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE);    
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX);
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD);
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE);

		// CDDS:: Additions
	virtual HBITMAP  GetBitmap( void );
	virtual void     SetOrigin( int left, int top );
	virtual void     GetOrigin( int & left, int & top ) const;

 protected:
	ULONG			m_cRef;
	SIZE			m_size;
	BITMAPINFO256	m_bmi;
	LPVOID			m_pvBits;
	LONG			m_lBitCount;
    HBITMAP			m_hbmp;
	POINT			m_ptOrigin;
	HDC				m_hdcMem;
	HBITMAP			m_hbmpDCOld;
	int             m_ctDCRefs;

#ifdef _DEBUG
	int     m_ctLocks;
	LPVOID	m_pvLocked;
#endif // _DEBUG
};

} // end namespace IHammer


EXPORT long  BitCountFromDDPIXELFORMAT( const DDPIXELFORMAT & ddpf );


#endif //__SURFACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\servprov.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Mon Dec 16 08:37:08 1996
 */
/* Compiler settings for servprov.idl:
    Oic (OptLev=i1), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __servprov_h__
#define __servprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IServiceProvider_FWD_DEFINED__
#define __IServiceProvider_FWD_DEFINED__
typedef interface IServiceProvider IServiceProvider;
#endif 	/* __IServiceProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Mon Dec 16 08:37:08 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// ServProv.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IServiceProvider Interfaces.


#ifndef _LPSERVICEPROVIDER_DEFINED
#define _LPSERVICEPROVIDER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServiceProvider
 * at Mon Dec 16 08:37:08 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IServiceProvider __RPC_FAR *LPSERVICEPROVIDER;


EXTERN_C const IID IID_IServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IServiceProvider : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServiceProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServiceProvider __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryService )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } IServiceProviderVtbl;

    interface IServiceProvider
    {
        CONST_VTBL struct IServiceProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServiceProvider_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServiceProvider_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0055
 * at Mon Dec 16 08:37:08 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL__intf_0055_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0055_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Stub( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\webdc.h ===
//+-------------------------------------------------------------------------
//
//  webdc.h
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//
//--------------------------------------------------------------------------

#ifndef __webdc_h__
#define __webdc_h__


// CATID_WebDesigntimeControl
//
//   Controls that implement this CATID are used at design-time and support authoring textual
//   web content (e.g. HTML, JScript, VBScript). They implement the IActiveDesigner interface
//   and persist their runtime representation as text via
//   IActiveDesigner::SaveRuntimeState(IID_IPersistTextStream, IID_IStream, pStream)
//
// { 73cef3dd-ae85-11cf-a406-00aa00c00940 }
DEFINE_GUID(CATID_WebDesigntimeControl, 0x73cef3dd, 0xae85, 0x11cf, 0xa4, 0x06, 0x00, 0xaa, 0x00, 0xc0, 0x09, 0x40);

// IID_IPersistTextStream
//
// { 56223fe3-d397-11cf-a42e-00aa00c00940 }
DEFINE_GUID(IID_IPersistTextStream, 0x56223fe3, 0xd397, 0x11cf, 0xa4, 0x2e, 0x00, 0xaa, 0x00, 0xc0, 0x09, 0x40);

// IID_IProvideRuntimeText
// {56223FE1-D397-11cf-A42E-00AA00C00940}
DEFINE_GUID(IID_IProvideRuntimeText, 0x56223fe1, 0xd397, 0x11cf, 0xa4, 0x2e, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);


#ifndef __MSWDCTL_LIBRARY_DEFINED__
#define __MSWDCTL_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSWDCTL
 * at Mon Oct 07 16:35:01 1996
 * using MIDL 3.00.45
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


///////////////////////////////////////////////////////////////////////////////
// IPersistTextStream Interface
// 
///////////////////////////////////////////////////////////////////////////////
// IProvideRuntimeText Interface
// 

EXTERN_C const IID LIBID_MSWDCTL;

#ifndef __IPersistTextStream_INTERFACE_DEFINED__
#define __IPersistTextStream_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPersistTextStream
 * at Mon Oct 07 16:35:01 1996
 * using MIDL 3.00.45
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IPersistTextStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPersistTextStream : public IPersistStreamInit
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPersistTextStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPersistTextStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPersistTextStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPersistTextStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )( 
            IPersistTextStream __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )( 
            IPersistTextStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IPersistTextStream __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IPersistTextStream __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )( 
            IPersistTextStream __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            IPersistTextStream __RPC_FAR * This);
        
        END_INTERFACE
    } IPersistTextStreamVtbl;

    interface IPersistTextStream
    {
        CONST_VTBL struct IPersistTextStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistTextStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistTextStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistTextStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistTextStream_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistTextStream_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IPersistTextStream_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IPersistTextStream_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IPersistTextStream_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IPersistTextStream_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistTextStream_INTERFACE_DEFINED__ */


#ifndef __IProvideRuntimeText_INTERFACE_DEFINED__
#define __IProvideRuntimeText_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideRuntimeText
 * at Mon Oct 07 16:35:01 1996
 * using MIDL 3.00.45
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IProvideRuntimeText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideRuntimeText : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeText( 
            /* [retval][out] */ BSTR __RPC_FAR *pstrRuntimeText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideRuntimeTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideRuntimeText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideRuntimeText __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideRuntimeText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRuntimeText )( 
            IProvideRuntimeText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstrRuntimeText);
        
        END_INTERFACE
    } IProvideRuntimeTextVtbl;

    interface IProvideRuntimeText
    {
        CONST_VTBL struct IProvideRuntimeTextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideRuntimeText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideRuntimeText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideRuntimeText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideRuntimeText_GetRuntimeText(This,pstrRuntimeText)	\
    (This)->lpVtbl -> GetRuntimeText(This,pstrRuntimeText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideRuntimeText_GetRuntimeText_Proxy( 
    IProvideRuntimeText __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstrRuntimeText);


void __RPC_STUB IProvideRuntimeText_GetRuntimeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideRuntimeText_INTERFACE_DEFINED__ */

#endif /* __MSWDCTL_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
//}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\inc\wndclass.h ===
/*-----------------------------------------------------------------------------
@doc    EXTERNAL
@module WndClass.h | This is a set location for all window class names
@comm   This file will simplify localization as these string will not show up in 
		cpp files when we do a string search. Saves time and makes one less file 
		to look through.
-----------------------------------------------------------------------------*/
// Do not localize this file
#ifndef _WND_CLASS
#define _WND_CLASS

// Do not localize these strings
#define szParameterFrameWindowClass "iHParameterFrameWindowClass" 
#define szTabWindowClass "iHTabWindowClass" 
#define szPagesWindowClass "iHPagesWindowClass"
const TCHAR szHamParamPgListItemInput[] = "CIHamParamPgListItemInput";
const TCHAR szHamParamPgListItemEsc[] = "CIHamParamPgListItemEsc";
const TCHAR szHamParamPgListItemEnter[] = "CIHamParamPgListItemEnter";
#define szTimeSpinCtrl "TimeSpinCtrl"
#define szUpdateTimingPgDataMsg "UpdateTimingPgDataMsg"
#define szUpdateTimePaneDataMsg "UpdateTimePaneDataMsg"

#endif _WND_CLASS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\bfid_rgb.h ===
#ifndef UTIL_BFID_RGB_H_
#define UTIL_BFID_RGB_H_
/************************************
 *
 * bfid_rgb.h --
 * Defines the GUIDs for IBitmapSurface
 * bitmap-format-IDs, as extern declared
 * by trident's ocmm.h.
 *
 * This was stolen from mmctl\inc\ocmm.h,
 * their own private version.  
 * Imposter headers-- Great Fun!
 *
 ************************************/

DEFINE_GUID(BFID_MONOCHROME,    0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_4,         0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_8,         0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_555,       0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_565,       0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_24,        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_32,        0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#endif // UTIL_BFID_RGB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\ctstr.cpp ===
/*++

Module:
	ctstr.cpp

Description:
	Implementation of TSTR wrapper class

Author:
	Simon Bernstein (simonb)

--*/

#include <ihammer.h>
#include <ctstr.h>
#include <debug.h>

EXPORT CTStr::CTStr(LPWSTR pszStringW)
{
	m_pszString = NULL;
	SetString(pszStringW);
}


EXPORT CTStr::CTStr(LPSTR pszStringA)
{
	m_pszString = NULL;
	SetString(pszStringA);
}


EXPORT CTStr::CTStr(int iAllocateLength)
{
	m_iLen = 0;
	
	if (iAllocateLength > 0)
	{
		m_pszString = New TCHAR[iAllocateLength];
		m_pszString[0] = 0;
	}
	else
	{
		m_pszString = NULL;
	}
}

// Copy constructor
EXPORT CTStr::CTStr(CTStr &rhs)
{
	m_iLen = rhs.m_iLen;
	
	if (m_iLen > 0)
	{
		m_pszString = New TCHAR [m_iLen + 1];
		
		if (NULL != m_pszString)
			lstrcpy(m_pszString, rhs.m_pszString);
	}
	else
	{
		m_pszString = NULL;
	}
}
	

EXPORT CTStr::~CTStr()
{
	if (m_pszString)
		Delete [] m_pszString;
}
	

EXPORT BOOL CTStr::SetString(LPWSTR pszStringW)
{
	if (m_pszString)
		Delete [] m_pszString;

	if (NULL == pszStringW)
	{
		m_iLen = 0;
		m_pszString = NULL;
	}
	else
	{
		m_iLen = lstrlenW(pszStringW);
		m_pszString = New TCHAR[m_iLen + 1];
	}

	if (NULL != m_pszString)
	{
#ifdef _UNICODE
		lstrcpy (m_pszString, pszStringW);
#else
		UNICODEToANSI(m_pszString, pszStringW, m_iLen + 1);
#endif
	}
	else if (NULL != pszStringW)
	{
		return FALSE;
	}

	return TRUE;
}


EXPORT BOOL CTStr::SetString(LPSTR pszStringA)
{
	if (m_pszString)
		Delete [] m_pszString;

	if (NULL == pszStringA)
	{
		m_iLen = 0;
		m_pszString = NULL;
	}
	else
	{
		m_iLen = lstrlenA(pszStringA);
		m_pszString = New TCHAR[m_iLen + 1];
	}
	
	if (NULL != m_pszString)
	{
#ifdef _UNICODE
		ANSIToUNICODE(m_pszLine,pszStringA, m_iLen + 1);
#else
		lstrcpy (m_pszString, pszStringA);
#endif
	}
	else if (NULL != pszStringA)
	{
		return FALSE;
	}

	return TRUE;
}


EXPORT BOOL CTStr::SetStringPointer(LPTSTR pszString, BOOL fDealloc)
{
	if ( fDealloc && (NULL != m_pszString) )
		Delete [] m_pszString;

	m_pszString = pszString;
	
	if (NULL != m_pszString)
		m_iLen = lstrlen(m_pszString);

	return TRUE;
}


EXPORT BOOL CTStr::AllocBuffer(int iAllocateLength, BOOL fDealloc)
{
	if (NULL != m_pszString)
	{
        if (fDealloc)
        {
            Delete [] m_pszString;
        }
        else
        {
            return FALSE;
        }

	}

    m_iLen = 0;
	m_pszString = New TCHAR[iAllocateLength];

	return (m_pszString != NULL);
}


EXPORT void CTStr::FreeBuffer()
{
	if (m_pszString)
	{
		Delete [] m_pszString;
		m_pszString = NULL;
	}
	m_iLen = 0;

}


EXPORT BSTR CTStr::SysAllocString()
{

#ifdef _UNICODE
	return ::SysAllocString(m_pszString);
#else

	// Handle the conversion to ANSI
	LPWSTR pwszTemp = pszW();

	if (NULL != pwszTemp)
	{
		BSTR bstrRet = NULL;
		
		bstrRet = ::SysAllocString(pwszTemp);
		Delete [] pwszTemp;

		return bstrRet;
	}
	else
	{
		return NULL;
	}
#endif
}

EXPORT LPSTR CTStr::pszA()
{
	if (NULL == m_pszString)
		return NULL;

	LPSTR pszNew = New char[m_iLen + 1];

	if (NULL != pszNew)
	{
#ifdef _UNICODE
		// Convert from UNICODE to ANSI
		UNICODEToANSI(pszNew, m_pszString, m_iLen + 1);
#else
		lstrcpy(pszNew, m_pszString);
#endif
	}
	return pszNew;
}


EXPORT LPWSTR CTStr::pszW()
{
	if (NULL == m_pszString)
		return NULL;

	m_iLen = lstrlen(m_pszString);

	LPWSTR pszNew = New WCHAR[m_iLen + 1];

	if (NULL != pszNew)
	{
#ifdef _UNICODE
		lstrcpy(pszNew, m_pszString);
#else
		// Convert from ANSI to UNICODE
		ANSIToUNICODE(pszNew, m_pszString, m_iLen + 1);
#endif
	}
	return pszNew;
}


EXPORT void CTStr::ResetLength()
{
	if (NULL != m_pszString)
		m_iLen = lstrlen(m_pszString);
}


int CTStr::UNICODEToANSI(LPSTR pchDst, LPCWSTR pwchSrc, int cchDstMax)
{
	Proclaim( pchDst );

    // Initialize destination string in case WideCharToMultiByte fails
    if(cchDstMax >= 1)
        pchDst[0] = '\0';
    
    return WideCharToMultiByte(CP_ACP, 0, pwchSrc ? pwchSrc : OLESTR( "" ), 
									-1, pchDst, cchDstMax, NULL, NULL); 
}

int CTStr::ANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc, int cwchDstMax)
{
	Proclaim( pwchDst );
	Proclaim( pchSrc );

    return MultiByteToWideChar(CP_ACP, 0, pchSrc, -1, pwchDst, cwchDstMax);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\debug.cpp ===
/*********************************************************
MODULE: DEBUG.CPP
AUTHOR: Outlaw

summer '93

DESCRIPTION: Contains a debugging functions.
**********************************************************/

#include "utilpre.h"

BOOL vfEcho=FALSE;
UINT uWndProcMinParam = 0;
UINT uWndProcMaxParam = 0;


VOID EXPORT FAR CDECL RetailEcho(LPSTR lpstrFormat, ...)
{
    if (!vfEcho)
        return;

    char rgch[128], rgchOutput[256];
	va_list ap;

	va_start( ap, lpstrFormat);
    wsprintf((LPSTR)rgch, "%s\n", lpstrFormat);
    wvsprintf(rgchOutput, (LPSTR)rgch, ap);
    OutputDebugString(rgchOutput);
}

#ifdef _DEBUG

char rgch[128];
char rgchOutput[256];

VOID EXPORT FAR CDECL OldEcho(LPSTR lpstrFormat, ...)
{
    if (!vfEcho)
        return;

 	va_list ap;

	va_start( ap, lpstrFormat);
	wsprintf((LPSTR)rgch, "%s\n", lpstrFormat);
	wvsprintf(rgchOutput, (LPSTR)rgch, ap);
    OutputDebugString(rgchOutput);
}

// FUNCTION WE EXPAND "ProclaimMessage()" TO; PUTS UP ASSERTION DIALOG AND ALSO GENERATES DEBUGGER BREAK
void EXPORT WINAPI AssertDebugBreakMessage(BOOL f, LPSTR lpstrAssert, LPSTR lpstrFile, UINT uLine, LPSTR lpMessage)
{
    if (!f)
    {
    	int	id;

        if(lpMessage)
		{
			wsprintf(rgchOutput, "\"%s\"\n\n%s, line %u\n%s", (LPSTR)lpstrAssert, (LPSTR)lpstrFile, (UINT)uLine, (LPSTR)lpMessage);
		}
		else
		{
			wsprintf(rgchOutput, "\"%s\"\n\n%s, line %u", (LPSTR)lpstrAssert, (LPSTR)lpstrFile, (UINT)uLine);
		}

        id = MessageBox(NULL, rgchOutput, "Assertion failed! break into the debugger?", MB_YESNOCANCEL | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

		switch(id)
		{
    		case IDYES:
	    		DebugBreak();
			break;

    		case IDNO:
			break;

	    	case IDCANCEL:
            {
        	    char *pchGPF = NULL;
    			*pchGPF = 0;
            }
			break;
		}
    }
}

// FUNCTION WE EXPAND "Proclaim()" TO; PUTS UP ASSERTION DIALOG AND ALSO GENERATES DEBUGGER BREAK
void EXPORT WINAPI AssertDebugBreak(BOOL f, LPSTR lpstrAssert, LPSTR lpstrFile, UINT uLine)
{
	AssertDebugBreakMessage(f, lpstrAssert, lpstrFile, uLine, NULL);
}

long cTestFail = 0;
long cTestFailT = 0;
BOOL fMemSim = FALSE;
void EXPORT WINAPI InitMemFailSim(BOOL	fFail)
{
	fMemSim = fFail;
	cTestFail = cTestFailT = 0;
}
BOOL	 EXPORT WINAPI FMemFailOn()
{
	return(fMemSim);
}
void SetCountMemFailSim(long cFail)
{
	if(cFail < 0)
		cFail = 0;
	cTestFail = cTestFailT = cFail;
	fMemSim = TRUE;
}
long CFailGetMemFailSim()
{
	return(fMemSim ? cTestFail : 0);
}
void  EXPORT WINAPI ResetAndIncMemFailSim()
{
	cTestFail++;
	cTestFailT = cTestFail;
}
// Return value: True means memory allocation failed.
BOOL FFailMemFailSim()
{
	if(!fMemSim)
		return(FALSE);
	if(!cTestFailT)
		return(TRUE);
	--cTestFailT;
	return(FALSE);
}


void SetWndProcParamsRange ( UINT uMin, UINT uMax )
{
	uWndProcMinParam = uMin;
	uWndProcMaxParam = uMax;
}


void ShowWndProcParams ( HINSTANCE hInst, LPCSTR name, HWND hwnd, UINT message, UINT wParam, LONG lParam )
{
	BOOL	fOldEcho;
    char	rchOutput[256];
	char	rchMsg[64];
	static BOOL fFirstCall = TRUE;

	if ( ( 0 == uWndProcMinParam ) && ( 0 == uWndProcMaxParam ) )
	{
		return;
	}

	if ( ( message < uWndProcMinParam ) || ( message > uWndProcMaxParam ) )
	{
		return;
	}

	fOldEcho = vfEcho;
	vfEcho = TRUE;
	if ( fFirstCall )
	{
		fFirstCall = FALSE;
		RetailEcho ( "Function Name\tMessage\tMessage ID\thWnd\twParam\tlParam" );
	}

	LoadString ( hInst, message, rchMsg, 63 );
	if ( 0 == strlen ( rchMsg ) )
	{
		_ltoa ( message, rchMsg, 10 );
	}

	wsprintf((LPSTR)rchOutput, "%s\t%s", name, "%s\t%li\t0x%lX\t0x%lX\t0x%lX" );

	RetailEcho ( rchOutput, rchMsg, message, hwnd, wParam, lParam );

	vfEcho = fOldEcho;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\srcodl\guids.cpp ===
// File to ensure various GUIDs are included in the library.  Before NT Build was used, we
// used initguid to define these.  With precompiled headers, this is difficult.

// SimonB, 10-29-1997

#include <objbase.h>
#include <initguid.h>

#include <transit.h>
#include <effect.h>
#include <htmlfilter.h>
#include <ddrawex.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\cstring.cpp ===
// Fossil file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\dll.cpp ===
/*=========================================================================*\

    File    : dll.cpp
    Purpose : DLL entry point
    Author  : Simon Bernstein (simonb)
    Date    : 04/29/97

\*=========================================================================*/
#include <windows.h>
#include <locale.h>

BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)
{
    switch( dwReason ) 
	{
		case DLL_PROCESS_ATTACH:
		{
			// Set the locale to the default, which is the 
			// system-default ANSI code page.  
			setlocale( LC_ALL, "" );
		}
		break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\dds_bs.cpp ===
/***********************************************
 *   DDS_BS.cpp -
 *	Implementation of an adapter-class to take
 *  an IBitmapSurface interface pointer and
 *  make it function in clients expecting
 *  IDirectDrawSurface.  
 *  Note: Only the barest-subset of DirectDraw
 *  methods are adapted here:
 *        GetSurfaceDesc(), 
 *        GetPixelFormat(),
 *        Lock(),
 *        Unlock()
 *  sufficient to get IHammer M2 to function
 *  in both IE4 Beta1 and Beta2.
 *
 *  Author:  Norm Bryar
 *  History:
 *		4/22/97 - Created.
 *
 **********************************************/
#include <ihammer.h>
#include <htmlfilter.h>	  // IBitmapSurface, BFID_RGB_..., etc.
#include <surface.h>
#include <dds_bs.h>

	// If it's possible IBitmapSurface can accept
	// many locks on different (or overlapping)
	// regions of the image, define MANY_LOCKS
#define MANY_LOCKS

#ifdef MANY_LOCKS
  #include <memlayer>   // STL-ized IHammer mem-mgr, HAMMOC
  #include <functional> // less<>
  #include <set>		// multiset<>
#endif // MANY_LOCKS


#pragma warning( disable: 4786 )  // STL decls > 255 char, so?

const DWORD  ALPHAMASK32 = 0xFF000000;
const DWORD  REDMASK24   = 0x00FF0000;
const DWORD  GRNMASK24   = 0x0000FF00;
const DWORD  BLUMASK24   = 0x000000FF;
const DWORD  REDMASK16   = 0x0000F800;
const DWORD  GRNMASK16   = 0x000007E0;
const DWORD  BLUMASK16   = 0x0000001F;
const DWORD  REDMASK15   = 0x00007C00;
const DWORD  GRNMASK15   = 0x000003E0;
const DWORD  BLUMASK15   = 0x0000001F;


struct lockpair
{
	void * pv;
	RECT   rc;

	lockpair( ) 
	{ pv=NULL; SetRectEmpty(&rc); }

	lockpair( void* p, const RECT * pr = NULL )
	{ 
		pv=p; 
		SetRectEmpty( &rc );
		if( NULL != pr )
		{
			  rc = *pr;
		}		
	}
};


#ifdef MANY_LOCKS
	struct std::less< lockpair > 
		: public std::binary_function<lockpair, lockpair, bool> 
	{
		bool operator()(const lockpair& _X, const lockpair& _Y) const
		{return (_X.pv < _Y.pv); }
	};
	typedef std::less<lockpair> lockcmp;

	typedef HAMMOC<lockpair>    lockalloc;

	class lockcollection : public std::multiset< lockpair, 
												 lockcmp,
												 lockalloc >
	{
	};
#else
	class lockcollection : public lockpair
	{
	};
#endif // MANY_LOCKS

// ----------------------------------
									  


EXPORT CDDSBitmapSurface::CDDSBitmapSurface( IBitmapSurface * pibs ) 
	   : m_pibs(pibs),
		 m_plockcollection(NULL),
		 m_ctRef(0u)
{ 
	if( pibs )
	{
		m_ctRef = 1u;
	}
	memset( &m_ddpixformat, 0, sizeof(m_ddpixformat) );
}


CDDSBitmapSurface::~CDDSBitmapSurface( )
{ 
	Proclaim( !m_ctRef );  // Should have released a held pibs
}


STDMETHODIMP CDDSBitmapSurface::QueryInterface( REFIID riid, void * * ppv )
{
	if( m_pibs )
	{
		return m_pibs->QueryInterface( riid, ppv );
	}
	return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG)   CDDSBitmapSurface::AddRef( void )
{	
	if( m_pibs )
	{
		m_pibs->AddRef(  );
	}
	return ++m_ctRef;
}


STDMETHODIMP_(ULONG)   CDDSBitmapSurface::Release( void )
{
	ULONG  ul = --m_ctRef;
	if( m_pibs )
	{
		if( 0u == m_pibs->Release(  ) )
		{
				// How did this die out from under us?
			Proclaim( 0u == ul );
			m_pibs = NULL;
		}
	}
	if( 0u == ul )
		Delete this;
	return ul;
}


	// --- Forwarded IDirectDrawSurface methods ---
STDMETHODIMP  CDDSBitmapSurface::GetPixelFormat( DDPIXELFORMAT * pddpf )
{
	if( NULL == pddpf )
		return E_POINTER;

	if( 0u == m_ddpixformat.dwSize )
	{
		HRESULT hr = UpdatePixFormat( );
		if( FAILED(hr) )
			return hr;
	}

	*pddpf = m_ddpixformat;
	return m_ddpixformat.dwSize ? S_OK : S_FALSE;
}

STDMETHODIMP  CDDSBitmapSurface::GetSurfaceDesc( DDSURFACEDESC * pddsDesc )
{
	HRESULT hr = E_FAIL;
	if( NULL == pddsDesc )
		return E_POINTER;

	if( m_pibs )
	{
		pddsDesc->dwSize  = sizeof( *pddsDesc );
		pddsDesc->dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
		hr = m_pibs->GetSize( (long *) &pddsDesc->dwWidth,
							  (long *) &pddsDesc->dwHeight );
		if( FAILED(hr) )
			return hr;

		hr = GetPixelFormat( &(pddsDesc->ddpfPixelFormat) );
		if( S_OK == hr )
		{
			pddsDesc->dwFlags |= DDSD_PIXELFORMAT | 
								 DDSD_ALPHABITDEPTH;
			pddsDesc->dwAlphaBitDepth = 
				m_ddpixformat.dwRGBAlphaBitMask ? 8 : 0;
		}		
	}
	return hr;
}


STDMETHODIMP  CDDSBitmapSurface::Lock( RECT * pRect, DDSURFACEDESC * pddsDesc,
									   DWORD, HANDLE )
{
	HRESULT hr;

	if( NULL == pddsDesc )
		return E_POINTER;	

	hr = GetSurfaceDesc( pddsDesc );
	if( FAILED(hr) )
		return hr;

	hr = m_pibs->LockBits( pRect, 
						   0,
						   (void * *) &(pddsDesc->lpSurface),
						   &(pddsDesc->lPitch) );
	if( SUCCEEDED(hr) )
	{
		pddsDesc->dwFlags  |= DDSD_PITCH;
		hr = AddLockPair( lockpair(pddsDesc->lpSurface, pRect) );
	}
	return hr;
}


STDMETHODIMP  CDDSBitmapSurface::Unlock( void * pVoid )
{
	if( NULL == pVoid )
		return E_POINTER;

	if( (NULL == m_plockcollection) || (NULL == m_pibs) )
		return E_FAIL;

	HRESULT   hr = E_FAIL;
	lockpair  lp( pVoid );	
	lockcollection::iterator  i = m_plockcollection->find( lp );

	if( i != m_plockcollection->end() )
	{
		hr = m_pibs->UnlockBits( const_cast<RECT *>(&(*i).rc), 
							     (*i).pv );
		(void) RemoveLockPair( pVoid );
	}
	else
	{
		Proclaim( FALSE && "unlock pointer not locked" );
	}
	return hr;
}


	// --- Private utilities --- 
HRESULT  CDDSBitmapSurface::AddLockPair( lockpair & lp )
{
#ifdef MANY_LOCKS
	if( NULL == m_plockcollection )
	{
		m_plockcollection = New lockcollection;
		if( NULL == m_plockcollection )
			return E_OUTOFMEMORY;
	}

	m_plockcollection->insert( lp );
#else
	static lockpair  s_theLockPair;
	if( NULL == m_plockcollection )
	{
		m_plockcollection = &s_theLockPair;
	}

		// Just one lock at a time, please!!
	Proclaim( NULL == s_theLockPair.pv ); 

	*m_plockcollection = lp;
#endif // MANY_LOCKS
	return S_OK;
}


HRESULT  CDDSBitmapSurface::RemoveLockPair( void * pv )
{
	if( NULL == m_plockcollection )
		return E_FAIL;

#ifdef MANY_LOCKS
	lockpair  lp;
	lp.pv = pv;	

	lockcollection::iterator  i = m_plockcollection->find( lp );
	if( i != m_plockcollection->end() )
	{
		m_plockcollection->erase( i );
	}
	else
	{
		Proclaim( FALSE && "pointer not-locked" );
	}
#else
	*m_plockcollection = lockpair( NULL, NULL );
#endif // MANY_LOCKS

	return S_OK;
}


HRESULT  CDDSBitmapSurface::UpdatePixFormat( void )
{
	if( NULL == m_pibs )
		return S_FALSE;

	BFID     bfid;
	HRESULT hr = m_pibs->GetFormat( &bfid );
	if( FAILED(hr) )
		return hr;

	memset( &m_ddpixformat, 0, sizeof(m_ddpixformat) );	
	m_ddpixformat.dwFlags = DDPF_RGB;

	if( IsEqualGUID( bfid, BFID_RGB_8 ) )
	{
		m_ddpixformat.dwFlags |= DDPF_PALETTEINDEXED8;
		m_ddpixformat.dwRGBBitCount = DD_8BIT;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_555 ) )
	{
		m_ddpixformat.dwRGBBitCount = DD_16BIT;
		m_ddpixformat.dwRBitMask = REDMASK15;
		m_ddpixformat.dwGBitMask = GRNMASK15;
		m_ddpixformat.dwBBitMask = BLUMASK15;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_565 ) )
	{
		m_ddpixformat.dwRGBBitCount = DD_16BIT;
		m_ddpixformat.dwRBitMask = REDMASK16;
		m_ddpixformat.dwGBitMask = GRNMASK16;
		m_ddpixformat.dwBBitMask = BLUMASK16;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_24 ) )
	{
		m_ddpixformat.dwRGBBitCount = DD_24BIT;
		m_ddpixformat.dwRBitMask = REDMASK24;
		m_ddpixformat.dwGBitMask = GRNMASK24;
		m_ddpixformat.dwBBitMask = BLUMASK24;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_32 ) )
	{
		// m_ddpixformat.dwAlphaBitDepth = DDBD_8; -DO NOT DO THIS!
		m_ddpixformat.dwFlags |= DDPF_ALPHAPIXELS;
		m_ddpixformat.dwRGBBitCount = DD_32BIT;
		m_ddpixformat.dwRBitMask = REDMASK24;
		m_ddpixformat.dwGBitMask = GRNMASK24;
		m_ddpixformat.dwBBitMask = BLUMASK24;
		m_ddpixformat.dwRGBAlphaBitMask = ALPHAMASK32;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_4 ) )
	{
		m_ddpixformat.dwFlags |= DDPF_PALETTEINDEXED4;
		m_ddpixformat.dwRGBBitCount = DD_4BIT;
	}
	else if( IsEqualGUID( bfid, BFID_MONOCHROME ) )
	{
		m_ddpixformat.dwFlags |= DDPF_PALETTEINDEXED1;
		m_ddpixformat.dwRGBBitCount = DD_1BIT;
	}
	else
	{
		return E_FAIL;
	}

	m_ddpixformat.dwSize  = sizeof(m_ddpixformat);
	return S_OK;
}




	// --- Stubbed IDirectDrawSurface methods ---
STDMETHODIMP  CDDSBitmapSurface::AddAttachedSurface( LPDIRECTDRAWSURFACE )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::AddOverlayDirtyRect( LPRECT )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::Blt( LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::BltBatch( LPDDBLTBATCH, DWORD, DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::BltFast( DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::DeleteAttachedSurface( DWORD,LPDIRECTDRAWSURFACE )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::EnumAttachedSurfaces( LPVOID,LPDDENUMSURFACESCALLBACK )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::EnumOverlayZOrders( DWORD,LPVOID,LPDDENUMSURFACESCALLBACK )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::Flip( LPDIRECTDRAWSURFACE, DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetAttachedSurface( LPDDSCAPS, LPDIRECTDRAWSURFACE FAR * )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetBltStatus( DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetCaps( LPDDSCAPS )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetClipper( LPDIRECTDRAWCLIPPER FAR* )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetColorKey( DWORD, LPDDCOLORKEY )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetDC( HDC FAR * )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetFlipStatus( DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetOverlayPosition( LPLONG, LPLONG  )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetPalette( LPDIRECTDRAWPALETTE FAR* )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::Initialize( LPDIRECTDRAW, LPDDSURFACEDESC )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::IsLost( )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::ReleaseDC( HDC )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::Restore( )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::SetClipper( LPDIRECTDRAWCLIPPER )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::SetColorKey( DWORD, LPDDCOLORKEY )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::SetOverlayPosition( LONG, LONG  )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::SetPalette( LPDIRECTDRAWPALETTE )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::UpdateOverlay( LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::UpdateOverlayDisplay( DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::UpdateOverlayZOrder( DWORD, LPDIRECTDRAWSURFACE )
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\idcol.cpp ===
//	IDispatch collection, with augment and enumerate interfaces.
//	Van Kichline, 7/26/96
//
//	Changed 8/27/96:
//		Next now addrefs pointers.
//		IEnumIDispatch changed to IEnumDispatch
//
//	A simple implementation of an IDispatch collection.
//	Currently, a fixed array is used to store the IDispatch pointers.
//	This implementation will be improved upon later if required.
//
//	CreateIDispatchCollection returns an IUnknown interface pointer to a
//	new, empty collection.  These classes are not CoCreatable (yet.)
//
//	CDispatchCollectionEnum, exposed through IEnumDispatch, is a standard OLE
//	enumerator, returning IDispatch pointers.  Pointers objtained from Next ARE
//	AddRefed, they need not be released by the obtainer.  Pointers are AddRefed when
//	added to the collection or when the collection is Cloned, and Released when the
//	collection is disposed of.
//
//	CDispatchCollectionAugment, exposed through IIDispatchCollectionAugment, is a
//	class of convenience, allowing IDispatch pointers to be added to the collection.
//	No other functions are provided at this stage; this is enough for these tests.

#include "utilpre.h"
#include <ole2.h>
#include "IdCol.h"
#include "IdGuids.h"

//	Static routine for creating the IDispatch collection
//
BOOL EXPORT WINAPI CreateIDispatchCollection ( IUnknown **ppUnk )
{
	PCIDispatchCollection	pIdC;
	HRESULT					hr;

	Proclaim ( NULL != ppUnk );	// Must be a pointer to a memory location
	if ( NULL == ppUnk )
	{
		return FALSE;
	}
	*ppUnk = NULL;	// Initialize once it's known to be safe

	// Create the object
	pIdC = new CIDispatchCollection ();

	Proclaim ( NULL != pIdC );	// Make certain an object was allocated.
	if ( NULL == pIdC )
	{
		return FALSE;
	}

	// Get the interface, which calls AddRef
	hr = pIdC->QueryInterface ( IID_IUnknown, (void **)ppUnk );
	return SUCCEEDED ( hr );
}


//	Base object constructor, contining the other two objects
//
#pragma warning(disable:4355)	// Using 'this' in constructor
CIDispatchCollection::CIDispatchCollection ( void ) :
	m_oAugment ( this ), m_oEnum ( this )
{
	// Clear the array
	for ( int i = 0; i < CPTRS; i++ )
	{
		m_rpid[i] = NULL;
	}

	m_cRef	= 0;	// Ref counts always start at zero
	m_cPtrs	= 0;	// Array is currently empty
}
#pragma warning(default:4355)	// Using 'this' in constructor


//	Base object destructor, responsible for all AddRefed IDispatch pointers in the collection
//
CIDispatchCollection::~CIDispatchCollection ( void )
{
	ULONG	ulCount	= 0;	// Used for debugging AddRef/Release

    for ( ULONG i = 0; i < m_cPtrs; i++ )
	{
		Proclaim ( NULL != m_rpid[i] );	// Every counted interface is expected to have a value
		ulCount = m_rpid[i]->Release();	// ulCount just for single-stepping verification
		m_rpid[i] = NULL;
	}
}


//	Base object QI.  Contained objects delgate to this QI.
//
STDMETHODIMP CIDispatchCollection::QueryInterface ( REFIID riid, void** ppv )
{
	Proclaim ( NULL != ppv );	// Must be a pointer to a memory location
	*ppv = NULL;

	if ( IID_IUnknown == riid )
	{
		*ppv = this;
	}
	else if ( IID_IEnumDispatch == riid )
	{
		*ppv = &m_oEnum;
	}
	else if ( IID_IDispatchCollectionAugment == riid )
	{
		*ppv = &m_oAugment;
	}
	else
	{
		Proclaim ( FALSE );		// Who's calling this with a bad interface ID?
		return E_NOINTERFACE;
	}

	((LPUNKNOWN)*ppv)->AddRef();

	return NOERROR;
}


//	Base object AddRef.  Contained objects may contain independant reference counts
//	for debugging purposes.
//	but they are not used for deletion.
//
STDMETHODIMP_(ULONG) CIDispatchCollection::AddRef ( void )
{
	return ++m_cRef;
}


//	Base object Release.  Contained objects may contain independant reference counts,
//	but they are not used for deletion.
//
STDMETHODIMP_(ULONG) CIDispatchCollection::Release ( void )
{
	if (0 != --m_cRef)
	{
		return m_cRef;
	}

	delete this;
	return 0;
}



/******************************************************************************

CDispatchCollectionAugment: allows IDispatch pointers to be added to the collection

******************************************************************************/


CIDispatchCollection::CDispatchCollectionAugment::CDispatchCollectionAugment
(
	CIDispatchCollection* pObj
)
{
	m_cRef		= 0;	// Private reference count, used for debugging purposes.
	m_poBackPtr	= pObj;	// Back pointer to containing object
}


CIDispatchCollection::CDispatchCollectionAugment::~CDispatchCollectionAugment ()
{
	Proclaim ( 0 == m_cRef );	// Refcount must be zero when deleted.  Imbalance?
}


STDMETHODIMP CIDispatchCollection::CDispatchCollectionAugment::QueryInterface
(
	REFIID	riid,
	void**	ppv
)
{
	return m_poBackPtr->QueryInterface ( riid, ppv );
}


STDMETHODIMP_(ULONG) CIDispatchCollection::CDispatchCollectionAugment::AddRef ()
{
	m_cRef++;
	return m_poBackPtr->AddRef();
}


STDMETHODIMP_(ULONG) CIDispatchCollection::CDispatchCollectionAugment::Release ()
{
	m_cRef--;
	return m_poBackPtr->Release();
}


//	Add an IDispatch pointer to the end of the array if there's room.
//
STDMETHODIMP CIDispatchCollection::CDispatchCollectionAugment::AddToCollection
(
	IDispatch*	pid
)
{
	HRESULT	hr		= S_OK;
	ULONG	ulCount	= 0;	// Used for debugging AddRef/Release

	Proclaim ( NULL != pid );	// Must be a pointer to a memory location

	if ( m_poBackPtr->m_cPtrs >= ( CPTRS - 1 ) )
	{
		return E_OUTOFMEMORY;	// A better error needed, but implementation will change...
	}

	if ( NULL == pid )
	{
		return E_FAIL;
	}
	
	// AddRef the pointer.
	ulCount = pid->AddRef();	// ulCount just for single-stepping verification
	m_poBackPtr->m_rpid[m_poBackPtr->m_cPtrs++] = pid;

	return hr;
}


/******************************************************************************

CDispatchCollectionEnum: standard OLE enumerator

******************************************************************************/


CIDispatchCollection::CDispatchCollectionEnum::CDispatchCollectionEnum
(
	CIDispatchCollection*	pObj
)
{
	m_cRef		= 0;	// Private reference count, used for debugging purposes.
	m_iCur		= 0;	// Current pointer is the first element.
	m_poBackPtr = pObj;	// Back pointer to containing object
}

CIDispatchCollection::CDispatchCollectionEnum::~CDispatchCollectionEnum ()
{
	Proclaim ( 0 == m_cRef );	// Refcount must be zero when deleted.  Imbalance?
}


STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::QueryInterface
(
	REFIID	riid,
	void**	ppv
)
{
	return m_poBackPtr->QueryInterface ( riid, ppv );
}


STDMETHODIMP_(ULONG) CIDispatchCollection::CDispatchCollectionEnum::AddRef ()
{
	m_cRef++;
	return m_poBackPtr->AddRef();
}


STDMETHODIMP_(ULONG) CIDispatchCollection::CDispatchCollectionEnum::Release ()
{
	m_cRef--;
	return m_poBackPtr->Release();
}


//	IDispatch pointers returned to the caller ARE ADDREFED. (Changed 8/26/96)
//	They are valid only as long as the collection is retained, unless the caller AddRefs.
//
STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::Next
(
	ULONG		cPtrs,
	IDispatch	**pid,
	ULONG		*pcPtrs
)
{
	ULONG	cPtrsReturn = 0L;

	Proclaim ( 0 != cPtrs );	// Misuse?  Why get zero items?
	Proclaim ( NULL != pid );	// Must point to a memory location.
	// Must have a pointer to count returned, if count requested is other than 1
	Proclaim ( !( ( NULL == pcPtrs ) && ( 1 != cPtrs ) ) );

	if ( NULL == pcPtrs )	// Null is only allowed when one IDispatch is being requested
	{
		if ( 1L != cPtrs )
		{
			return E_FAIL;
		}
	}
	else
	{
		*pcPtrs = 0L;
	}

	if ( NULL == pid || ( m_iCur >= m_poBackPtr->m_cPtrs ) )
	{
		return S_FALSE;
	}

	while ( m_iCur < m_poBackPtr->m_cPtrs && cPtrs > 0 )
	{
		IDispatch*	pidElement = m_poBackPtr->m_rpid[m_iCur++];;
		Proclaim ( pidElement );
		pidElement->AddRef ();
		*pid++ = pidElement;
		cPtrsReturn++;
		cPtrs--;
	}

	if ( NULL != pcPtrs )
	{
		*pcPtrs = cPtrsReturn;
	}

	return NOERROR;
}


//	If the number to skip falls beyond the last element, the cursor is not moved.
//
STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::Skip
(
	ULONG	cSkip
)
{
	Proclaim ( 0 != cSkip );	// Misuse?  Why skip zero pointers?

	if ( ( m_iCur + cSkip ) >= m_poBackPtr->m_cPtrs )
	{
		return S_FALSE;
	}

	m_iCur += cSkip;
	return NOERROR;
}


STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::Reset ()
{
	m_iCur = 0;
	return NOERROR;
}


//	After duplicating the list of IDispatch pointers, AddRef each pointer.
//	The destructor will Release each pointer.
//	The enumerator's m_iCur is left initalized to 0, not copied from the source.
//
STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::Clone
(
	PENUMDISPATCH	*ppEnum
)
{
	IDispatch	*pid	= NULL;
	ULONG		ulCount	= 0;		// Used for debugging AddRef/Release
	HRESULT		hr		= S_OK;

	Proclaim ( NULL != ppEnum );	// Must be a pointer to a memory location
	if ( NULL == ppEnum )
	{
		return E_FAIL;
	}

	*ppEnum = NULL;	// Initialize the result nce it's known to be safe
	
	CIDispatchCollection *pIdc = new CIDispatchCollection ();	// Create a new collection
	Proclaim ( NULL != pIdc );		// Allocation failure
	if ( NULL == pIdc )
	{
		return E_FAIL;
	}

	// Copy the existing array of IDispatch pointers over, addrefing each one.
	for ( ULONG i = 0; i < m_poBackPtr->m_cPtrs; i++ )
	{
		pid = m_poBackPtr->m_rpid[i];
		Proclaim ( NULL != pid );	// The elements included by m_cPtrs should have no NULLs
		ulCount = pid->AddRef();	// ulCount just for single-stepping verification
		pIdc->m_rpid[i] = pid;
	}
	pIdc->m_cPtrs = m_poBackPtr->m_cPtrs;	// Copy the number of elements in the array

	hr = pIdc->QueryInterface ( IID_IEnumDispatch, (void **)ppEnum );	// Get interface pointer
	Proclaim ( NULL != *ppEnum );	// No good reason the QI should fail
	Proclaim ( SUCCEEDED ( hr ) );	// Failure at this point should be impossible
	if ( FAILED ( hr ) )
	{
		delete pIdc;				// Kill it, it won't work
	}
	return hr;
}

//	End of IdCol.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\drg.cpp ===
/*+********************************************************
MODULE: DRG.CPP
AUTHOR: Outlaw
DATE: summer '93

DESCRIPTION: Implements CDrg dynamic array class.
*********************************************************-*/

#include <stdlib.h>
#include <minmax.h>
#include "utilpre.h"
#include "utils.h"
#include "memlayer.h"
#include "memory.h"
#include "drg.h"

const UINT  DEF_REALLOC_BYTES      = 512u;  // Byte-count or
const UINT  DEF_REALLOC_MULTIPLES  = 1u;    // object ct to grow.
                                            // Bigger size used.


/*+*******************************************************
AUTHOR: Outlaw
DATE:   summer '93

PUBLIC METHOD

Initializes element size and increment size.  If this routine
is not called before other operations on array, drg will use
defaults for these.
*********************************************************-*/
void EXPORT WINAPI CDrg::SetNonDefaultSizes(UINT cElSize, UINT cResizeIncrement)
{
    m_cElementSize=cElSize;
    if( 0u == cResizeIncrement )
        cResizeIncrement = max( DEF_REALLOC_MULTIPLES,
                                DEF_REALLOC_BYTES / cElSize );
    m_cResizeIncrement=cResizeIncrement;
}







/*+*******************************************************
AUTHOR: Outlaw
DATE:   summer '93

PUBLIC METHOD

Called to insert an element on the dynamic array.  If array
must expand to accomodate it, it does so.  No gaps can be
left in array, so value passed must be <= m_lmac.

Note that upon an insertion, elements are scooted up.

Routine will fail on OOM.

Allocates array buffer upon first invocation.
*********************************************************-*/
BOOL EXPORT WINAPI CDrg::Insert(void FAR *qEl, LONG cpos)
{
    HANDLE hTemp, h;
    LONG i;

    if (cpos==DRG_APPEND)
        cpos=m_lmac;

    // WILL IT BE NECESSARY TO RESIZE ARRAY?  IF SO, GET AFTER IT....
    if (m_lmac >= m_lmax)
    {
        // INITIAL ALLOCATION?
        if (!m_qBuf)
        {
            Proclaim(!m_lmac && !m_lmax);
            h=MemAllocZeroInit(m_cResizeIncrement * m_cElementSize);
            if (!h)
                return(FALSE);
            m_qBuf=(BYTE *)MemLock(h);
            m_lmax=m_cResizeIncrement;
        }
        else    // WE'RE RESIZING
        {
            h=MemGetHandle(m_qBuf);
            MemUnlock(h);
            hTemp=MemReallocZeroInit(h, (m_lmax+m_cResizeIncrement)*m_cElementSize);
            if (!hTemp)
            {
                Echo("Memory failure reallocating buffer in CDrg::Insert()!  Failing!");
                m_qBuf=(BYTE FAR *)MemLock(h);
                return(FALSE);
            }
            m_qBuf=(BYTE FAR *)MemLock(hTemp);
            m_lmax+=m_cResizeIncrement;
        }
    }

    // SCOOT UP ELEMENTS THAT NEED TO BE SCOOTED UP (STARTING AT END) IF WE'RE NOT APPENDING
    if (cpos < m_lmac)
    {
        for (i=m_lmac; i>cpos; i--)
            memcpy(m_qBuf+(i*m_cElementSize), m_qBuf+((i-1)*m_cElementSize), m_cElementSize);
    }

    // INSERT NEW ELEMENT....
    memcpy(m_qBuf+(cpos*m_cElementSize), (BYTE *)qEl, m_cElementSize);

    // INCREMENT NUMBER OF ELEMENTS IN ARRAY....
    ++m_lmac;

    return(TRUE);
}






/*+*******************************************************
AUTHOR: Outlaw
DATE:   summer '93

PUBLIC METHOD

Called to delete an element from the dynamic array.

If array hasn't been initialized, this routine will return
false as it will upon a weird resizing error.

Value at specified position will be copied to passed pointer
location -- if the pointer is non-null.  If it's null, nothing
is copied.

This routine will also return FALSE if the specified index
value is out of range.

Note that deleting an entry will not immediately cause the
array buffer to shrink.  Rather, only when the disparity
between m_lmac and m_lmax reaches m_cResizeIncrement will
the array resize downward....

Note that when the array DOES resize, it does so by scooting
everything down....
*********************************************************-*/
BOOL EXPORT WINAPI CDrg::Remove(void FAR *q, LONG cpos)
{
    if (cpos >= m_lmac)
    {
//      Echo("CDrg::Delete(%ld) out of range deletion!  Returning!", (LONG)cpos);
        return(FALSE);
    }

    // COPY DELETED ELEMENT TO RETURN BUFFER
    if (q)
        memcpy((BYTE *)q, m_qBuf+(cpos*m_cElementSize), m_cElementSize);

    // SCOOT EVERYTHING DOWN
    if (cpos < m_lmac-1)
        memcpy(m_qBuf+(cpos * m_cElementSize), m_qBuf+((cpos+1) * m_cElementSize), (m_lmac-(cpos+1)) * m_cElementSize);

    // DECREMENT NUMBER OF ELEMENTS IN ARRAY....
    --m_lmac;

    // IF IT'S NECESSARY TO SHRINK, SHRINK
    if (m_lmac < m_lmax-(LONG)m_cResizeIncrement)
    {
        HANDLE h=MemGetHandle(m_qBuf);
        MemUnlock(h);
        if (!m_lmac)
        {
// REVIEW PAULD            Free(h);
            MemFree(h);
            m_lmax=0;
            m_qBuf=NULL;
        }
        else
        {
            HANDLE hTemp=MemReallocZeroInit(h, m_lmac*m_cElementSize);
            if (!hTemp)
            {
                Echo("Weird!  Resize shrink error in CDrg::Remove()!  Failing!");
                m_qBuf=(BYTE *)MemLock(h);
                return(FALSE);
            }
            m_qBuf=(BYTE *)MemLock(hTemp);
            m_lmax=m_lmac;
        }
    }

    return(TRUE);
}




/* Note: It is up to the application to ascertain which array elements
are actually in use. */


//void EXPORT WINAPI CNonCollapsingDrg::SetNonDefaultSizes(UINT cSizeElement, UINT cResizeIncrement)
//{
//    m_cElementSize=cSizeElement;
//    m_cResizeIncrement=cResizeIncrement;
//}


LPVOID EXPORT WINAPI CNonCollapsingDrg::GetFirst(void)
{
    LPBYTE pbyte=NULL;

    if (m_qBuf)
    {
        pbyte = m_qBuf;
        m_lIdxCurrent=0;
    }
    return (LPVOID)pbyte;
}


LPVOID EXPORT WINAPI CNonCollapsingDrg::GetNext(void)
{
    LPBYTE pbyte=NULL;

    if (m_qBuf && m_lIdxCurrent + 1 < m_lmax )
    {
        ++m_lIdxCurrent;
        pbyte = m_qBuf + (m_lIdxCurrent * m_cElementSize);
    }
    return (LPVOID)pbyte;
}


BOOL EXPORT WINAPI CNonCollapsingDrg::Remove(void FAR *q, LONG cpos)
{
    BOOL fRet=FALSE;
    if (m_qBuf && cpos < m_lmax)
    {
        memcpy( q, (LPBYTE)m_qBuf+(cpos*m_cElementSize), m_cElementSize);
        memset( (LPBYTE)m_qBuf+(cpos*m_cElementSize), 0, m_cElementSize);
        --m_lmac;
        fRet=TRUE;
    }
    return fRet;
}




BOOL EXPORT WINAPI CNonCollapsingDrg::SetAt(void FAR *q, LONG cpos)
{
    LPBYTE pbyte;

    if (!m_qBuf)
    {
        Proclaim(!m_lmac && !m_lmax);
        HANDLE h=MemAllocZeroInit(m_cResizeIncrement * m_cElementSize);
        if (!h)
            return(FALSE);
        m_qBuf=(BYTE *)MemLock(h);
        m_lmax=m_cResizeIncrement;
    }

    if (cpos >= m_lmax)
    {
        LONG lmaxNew = ((cpos + m_cResizeIncrement)/m_cResizeIncrement)*m_cResizeIncrement;
        HANDLE h=MemGetHandle(m_qBuf);
        MemUnlock(h);
        h=MemReallocZeroInit(h, lmaxNew * m_cElementSize);
        if (!h)
        {
            Echo("Memory failure reallocating buffer in CDrg::Insert()!  Failing!");
            m_qBuf=(BYTE FAR *)MemLock(h);
            return(FALSE);
        }
        m_qBuf=(BYTE FAR *)MemLock(h);
        m_lmax=lmaxNew;
    }
    pbyte = m_qBuf+(cpos*m_cElementSize);
    memcpy(pbyte, q, m_cElementSize);
    ++m_lmac;
    return(TRUE);
}

LPVOID EXPORT WINAPI CNonCollapsingDrg::GetAt(LONG cpos)
{
    LPBYTE pbyte = NULL;
    if (m_qBuf && cpos >= 0 && cpos < m_lmax)
    {
        pbyte = m_qBuf + (m_cElementSize*cpos);
    }
    return (LPVOID)pbyte;
}


BOOL EXPORT WINAPI CNonCollapsingDrg::CopyFrom(CDrg FAR *qdrg)
{
    LONG i;
    MakeNull();
    LPVOID pvoid;

    Proclaim(m_cElementSize==((CNonCollapsingDrg*)qdrg)->m_cElementSize);

    for (i=0; i < ((CNonCollapsingDrg*)qdrg)->m_lmax; i++)
    {
        if (pvoid=((CNonCollapsingDrg*)qdrg)->GetAt(i)) SetAt( pvoid, i );
    }
    return(TRUE);
}

VOID EXPORT WINAPI CNonCollapsingDrg::SetArray(BYTE *qBuf, LONG lElements, UINT uElementSize)
{
    LONG i;
    MakeNull();
    m_cElementSize = 1 + uElementSize;
    for (i = 0; i < lElements; i++)
        SetAt( (qBuf+(i*m_cElementSize)), i);
}


    // NOTE: Keep this in sync with drgx.h's SavePtrDrg()!!!
EXPORT DWORD OverheadOfSavePtrDrg( void )
{
    return sizeof(int);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\dither.cpp ===
/*
********************************************************************
*
*
*
*
*
*
*
********************************************************************
*/

#include "utilpre.h"
#include <htmlfilter.h>
#include <minmax.h>

#define DITHER_IMPL
#include <dither.h>
#include <ddraw.h>
#include <quickie.h>

#ifdef _DEBUG
  #pragma optimize( "", on )
#else
  #pragma optimize( "agty", on )
#endif // _DEBUG

#define RED_LEVELS   5
#define GREEN_LEVELS 5
#define BLUE_LEVELS  5
#define RED_SHADES   (1 << CHalftonePalette::significant_bits)
#define GREEN_SHADES (1 << CHalftonePalette::significant_bits)
#define BLUE_SHADES  (1 << CHalftonePalette::significant_bits)

#define BGRA_ALPHA       3
#define BGRA_RED         2
#define BGRA_GREEN       1
#define BGRA_BLUE        0

inline int INT_MULT( BYTE a, int b )
{  
        int temp = (a*b) + 128;
        return ((temp>>8) + temp)>>8;
}

static g_i4x4[PATTERN_COLS][PATTERN_ROWS]=
   {{-7, 1,-5, 3},
        { 5,-3, 7,-1},
        {-4, 4,-6, 2},
        { 8, 0, 6,-2}};


// -------------------------------------------------

DLINKAGE CHalftonePalette::CHalftonePalette( )
{
        m_logpal.palVersion = 0x0300;
        m_logpal.palNumEntries = 0;
}


DLINKAGE CHalftonePalette::CHalftonePalette(HPALETTE hpal)
     : m_pbQuantizationTable(NULL)
{
        m_logpal.palVersion = 0x0300;
        Regenerate( hpal );
}


CHalftonePalette::~CHalftonePalette()
{
        if (m_pbQuantizationTable)
        {
                Delete [] m_pbQuantizationTable;
                m_pbQuantizationTable = NULL;
        }
}


STDMETHODIMP CHalftonePalette::Regenerate( HPALETTE hPal )
{
        GetObject(hPal, sizeof(WORD), &m_logpal.palNumEntries);
        ::GetPaletteEntries(hPal, 0, m_logpal.palNumEntries, &m_logpal.palPalEntry[0]);
        return Initialize( );
}

STDMETHODIMP CHalftonePalette::Initialize(void)
{
        LPPALETTEENTRY pPalEntry;
        int cPaletteEntries;
        static int dRedStep   = 255 / (RED_SHADES -1);
        static int dGreenStep = 255 / (GREEN_SHADES -1);
        static int dBlueStep  = 255 / (BLUE_SHADES -1);

        if( NULL == m_pbQuantizationTable )
        {
                m_pbQuantizationTable = New BYTE[ RED_SHADES * GREEN_SHADES * BLUE_SHADES ];    
        }

        if( m_pbQuantizationTable )
        {
                LPBYTE pbCurrent = m_pbQuantizationTable;

                for (int iRed = 0; iRed <= 255; iRed += dRedStep)
                {
                        for (int iGreen = 0; iGreen <= 255; iGreen += dGreenStep)
                        {
                                for (int iBlue = 0; iBlue <= 255; iBlue += dBlueStep)
                                {
                                long lMinDistance = 0x7FFFFFFFL;

                                        pPalEntry = &m_logpal.palPalEntry[0];
                                        cPaletteEntries = m_logpal.palNumEntries;

                                for (int i = 0; i < cPaletteEntries; i++, pPalEntry++)
                                {
                                        long lRedError   = iRed   - pPalEntry->peRed;
                                        long lGreenError = iGreen - pPalEntry->peGreen;
                                        long lBlueError  = iBlue  - pPalEntry->peBlue;
                                        long lDistance   = (lRedError * lRedError)  + 
                                                                                   (lGreenError * lGreenError) + 
                                                                                   (lBlueError * lBlueError);

                                        if (lDistance < lMinDistance)
                                        {
                                                lMinDistance = lDistance;
                                                *pbCurrent = (BYTE) i;

                                        if (lMinDistance == 0)  // Early out for exact color!
                                                break;
                                        }
                                }
                                        ++pbCurrent;
                                }
                        }
                }
                return S_OK;
        }
        return E_OUTOFMEMORY;
}

/*
********************************************************************
*
*
*
*
*
*
*
********************************************************************
*/

CHalftone::CHalftone(HPALETTE hpal) : m_cpal(hpal)
{
        Initialize();
}

CHalftone::~CHalftone()
{
}

STDMETHODIMP CHalftone::Initialize(void)
{
        LPBYTE pbCurrent = m_rgPattern;

        for (int iY = 0; iY < PATTERN_ROWS; iY++)
        {
                for (int iX = 0; iX < PATTERN_COLS; iX++)
                {
                        for (int iZ = 0; iZ < 256; iZ++)
                        {
                                int iColor = iZ + g_i4x4[iX][iY];
                                iColor = min(max(0, iColor), 255);
                                *(pbCurrent++) = (BYTE)iColor;
                        }
                }
        }
        return S_OK;
}


STDMETHODIMP CHalftone::Dither32to1( IDirectDrawSurface* pSrc, LPRECT prectSrc, 
                                                                         IDirectDrawSurface* pDst, LPRECT prectDst )
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
        return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;       
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
        HRESULT         hr;
        RGBQUAD *       prgbSrc;
        LPBYTE          pbDst;
        LONG            lStrideSrc;
        LONG            lStrideDst;
        int                     iRow;   

        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(BYTE));

        prgbSrc = static_cast<RGBQUAD *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {                       
                int         iCol = ctColsToDither;
                int         pre  = prectDst->left % 8;
                BYTE        fTemp;

                        // Take care of left non-aligned
                if( pre )
                {
                        fTemp = 0;
                        do
                        {
                                if( prgbSrc->rgbReserved )
                                        fTemp |= (1 << pre);
                                ++prgbSrc;
                                ++pre;
                                --iCol;
                        } while( pre % 8 );
                        *pbDst++ = fTemp;
                }

                while( iCol >= 8 )
                {
                        fTemp = (!prgbSrc[0].rgbReserved)      | 
                                        (!prgbSrc[1].rgbReserved << 1) | 
                                        (!prgbSrc[2].rgbReserved << 2) | 
                                        (!prgbSrc[3].rgbReserved << 3) | 
                                        (!prgbSrc[4].rgbReserved << 4) | 
                                        (!prgbSrc[5].rgbReserved << 5) | 
                                        (!prgbSrc[6].rgbReserved << 6) | 
                                        (!prgbSrc[7].rgbReserved << 7);
                        prgbSrc += 8;
                        iCol  -= 8;
                        *pbDst++ = ~fTemp;
                }

                        // Take care of non-aligned endpoint
                if( iCol )
                {       
                        const int iInv = iCol;
                        fTemp = 0;
                        while( iCol )
                        {
                                if( prgbSrc->rgbReserved )
                                        fTemp |= (1 << (iInv-iCol));
                                ++prgbSrc;
                                --iCol;
                        }
                        *pbDst = fTemp;
                }
                prgbSrc = OffsetPtr( prgbSrc, lStrideSrc);
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}


STDMETHODIMP CHalftone::Dither32to8(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
        return E_INVALIDARG;


    DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        BYTE    bBlueDst;
        BYTE    bGreenDst;
        BYTE    bRedDst;
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;
        LPBYTE  pbPattern;
        long    lPatternOffset;
        BYTE    bBlueSrc;
        BYTE    bGreenSrc;
        BYTE    bRedSrc;

        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(BYTE));

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                pbPattern = &m_rgPattern[((iRow%PATTERN_ROWS)<<10) + ((prectSrc->left%PATTERN_COLS)<<8)];
                lPatternOffset = 0;
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                          //skip if transparent
                        {
                                //get noisy color components from 4x4 pattern table
                                bBlueSrc  = m_rgPattern[lPatternOffset + pbSrc[BGRA_BLUE]];
                                bGreenSrc = m_rgPattern[lPatternOffset + pbSrc[BGRA_GREEN]];
                                bRedSrc   = m_rgPattern[lPatternOffset + pbSrc[BGRA_RED]];

                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        //expand 8-bit index to 24-bit color values
                                        m_cpal.GetPaletteEntry(*pbDst, &bRedDst, &bGreenDst, &bBlueDst);

                                        //setup multipliers
                        iMulSrc   = pbSrc[BGRA_ALPHA];
                        iMulDst   = iMulSrc ^ 0xFF;

                                        //now combine color components here
                        bRedSrc   = (BYTE)(INT_MULT(bRedSrc,  iMulSrc) + INT_MULT(bRedDst,  iMulDst));
                        bGreenSrc = (BYTE)(INT_MULT(bGreenSrc,iMulSrc) + INT_MULT(bGreenDst,iMulDst));
                        bBlueSrc  = (BYTE)(INT_MULT(bBlueSrc, iMulSrc) + INT_MULT(bBlueDst, iMulDst));
                                }
                                //convert to 8-bit index
                                *pbDst = m_cpal.GetNearestPaletteIndex(bRedSrc, bGreenSrc, bBlueSrc);
                        }
                        pbDst++;
                        pbSrc += sizeof(RGBQUAD);
                        lPatternOffset = ((lPatternOffset + 256) & 0x000003FF);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}

STDMETHODIMP CHalftone::Blt32to555(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
                return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        BYTE    bBlueDst;
        BYTE    bGreenDst;
        BYTE    bRedDst;
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;
        BYTE    bBlueSrc;
        BYTE    bGreenSrc;
        BYTE    bRedSrc;
        
        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(WORD));

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                                  //skip if transparent
                        {
                                bBlueSrc  = pbSrc[BGRA_BLUE];
                                bGreenSrc = pbSrc[BGRA_GREEN];
                                bRedSrc   = pbSrc[BGRA_RED];

                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        WORD wDst = *(LPWORD)pbDst;
                                        bRedDst   = (wDst & 0x7C00) >> 7;
                                        bGreenDst = (wDst & 0x03E0) >> 2;
                                        bBlueDst  = (wDst & 0x001F) << 3;

                                        //setup multipliers
                        iMulSrc   = pbSrc[BGRA_ALPHA];
                        iMulDst   = iMulSrc ^ 0xFF;

                                        //now combine color components here
                        bRedSrc   = (BYTE)(INT_MULT(bRedSrc,  iMulSrc) + INT_MULT(bRedDst,  iMulDst));
                        bGreenSrc = (BYTE)(INT_MULT(bGreenSrc,iMulSrc) + INT_MULT(bGreenDst,iMulDst));
                        bBlueSrc  = (BYTE)(INT_MULT(bBlueSrc, iMulSrc) + INT_MULT(bBlueDst, iMulDst));
                                }
                                //convert to 555 color
                                *(LPWORD)pbDst = (WORD)(((bRedSrc>>3)<<10)+((bGreenSrc>>3)<<5)+(bBlueSrc>>3));
                        }
                        pbSrc += sizeof(RGBQUAD);
                        pbDst += sizeof(WORD);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;

}

STDMETHODIMP CHalftone::Blt32to565(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
                return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        BYTE    bBlueDst;
        BYTE    bGreenDst;
        BYTE    bRedDst;
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;
        BYTE    bBlueSrc;
        BYTE    bGreenSrc;
        BYTE    bRedSrc;
        
        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(WORD));

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                                          //skip if transparent
                        {
                                bBlueSrc  = pbSrc[BGRA_BLUE];
                                bGreenSrc = pbSrc[BGRA_GREEN];
                                bRedSrc   = pbSrc[BGRA_RED];

                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        WORD wDst = *(LPWORD)pbDst;
                                        bRedDst   = (wDst & 0xF800) >> 8;
                                        bGreenDst = (wDst & 0x07E0) >> 3;
                                        bBlueDst  = (wDst & 0x001F) << 3;

                                        //setup multipliers
                        iMulSrc   = pbSrc[BGRA_ALPHA];
                        iMulDst   = iMulSrc ^ 0xFF;

                                        //now combine color components here
                        bRedSrc   = (BYTE)(INT_MULT(bRedSrc,  iMulSrc) + INT_MULT(bRedDst,  iMulDst));
                        bGreenSrc = (BYTE)(INT_MULT(bGreenSrc,iMulSrc) + INT_MULT(bGreenDst,iMulDst));
                        bBlueSrc  = (BYTE)(INT_MULT(bBlueSrc, iMulSrc) + INT_MULT(bBlueDst, iMulDst));
                                }
                                //convert to 565 color
                                *(LPWORD)pbDst = (WORD)(((bRedSrc>>3)<<11)+((bGreenSrc>>2)<<5)+(bBlueSrc>>3));
                        }
                        pbSrc += sizeof(RGBQUAD);
                        pbDst += sizeof(WORD);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}

STDMETHODIMP CHalftone::Blt32to24(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
                return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;
                
        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

    lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(RGBTRIPLE));       

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                                          //only if visible
                        {
                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        //setup multipliers
                        iMulSrc   = pbSrc[BGRA_ALPHA];
                        iMulDst   = iMulSrc ^ 0xFF;

                                        //now combine color components here
                                        pbDst[BGRA_BLUE] = (BYTE)(INT_MULT(pbSrc[BGRA_BLUE], iMulSrc) + 
                                                                                  INT_MULT(pbDst[BGRA_BLUE], iMulDst));
                                        pbDst[BGRA_GREEN]= (BYTE)(INT_MULT(pbSrc[BGRA_GREEN],iMulSrc) + 
                                                                                  INT_MULT(pbDst[BGRA_GREEN],iMulDst));
                                        pbDst[BGRA_RED]  = (BYTE)(INT_MULT(pbSrc[BGRA_RED],  iMulSrc) + 
                                                                          INT_MULT(pbDst[BGRA_RED],  iMulDst));
                                }
                                else
                                {
                                        pbDst[BGRA_BLUE]  = pbSrc[BGRA_BLUE];
                                        pbDst[BGRA_GREEN] = pbSrc[BGRA_GREEN];
                                        pbDst[BGRA_RED]   = pbSrc[BGRA_RED];
                                }
                        }
                        pbSrc += sizeof(RGBQUAD);
                        pbDst += sizeof(RGBTRIPLE);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}


STDMETHODIMP CHalftone::Blt32to32(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
                return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;

        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;
        
    lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(RGBQUAD));

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                          //skip if transparent
                        {
                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        //setup multipliers
                        iMulSrc = pbSrc[BGRA_ALPHA];
                        iMulDst = iMulSrc ^ 0xFF;

                                        //now combine color components here
                                        pbDst[BGRA_BLUE] = (BYTE)(INT_MULT(pbSrc[BGRA_BLUE], iMulSrc) + 
                                                                                  INT_MULT(pbDst[BGRA_BLUE], iMulDst));
                                        pbDst[BGRA_GREEN]= (BYTE)(INT_MULT(pbSrc[BGRA_GREEN],iMulSrc) + 
                                                                                  INT_MULT(pbDst[BGRA_GREEN],iMulDst));
                                        pbDst[BGRA_RED]  = (BYTE)(INT_MULT(pbSrc[BGRA_RED],  iMulSrc) + 
                                                                          INT_MULT(pbDst[BGRA_RED],  iMulDst));
                                }
                                else
                                {
                                        pbDst[BGRA_BLUE]  = pbSrc[BGRA_BLUE];
                                        pbDst[BGRA_GREEN] = pbSrc[BGRA_GREEN];
                                        pbDst[BGRA_RED]   = pbSrc[BGRA_RED];
                                }
                                pbDst[BGRA_ALPHA] = pbSrc[BGRA_ALPHA];
                        }
                        pbSrc += sizeof(RGBQUAD);
                        pbDst += sizeof(RGBQUAD);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}


// ----------------------------- HANDY UTILITIES -------------------------------
DLINKAGE DWORD  GetSigBitsFrom16BPP( HDC hdc )
{
        struct {
                BITMAPINFOHEADER bih;
                DWORD bf[3];
        }       bmi;
        HBITMAP hbmp;
        DWORD   dwDepth = 15u;

    hbmp = CreateCompatibleBitmap(hdc, 1, 1);
    ZeroMemory(&bmi, sizeof(bmi));
    bmi.bih.biSize = sizeof(BITMAPINFOHEADER);
    // first call will fill in the optimal biBitCount
    GetDIBits(hdc, hbmp, 0, 1, NULL, (BITMAPINFO*)&bmi, DIB_RGB_COLORS);

    if(bmi.bih.biBitCount != 16)
                return bmi.bih.biBitCount;

    // second call will get the optimal bitfields
    GetDIBits(hdc, hbmp, 0, 1, NULL, (BITMAPINFO*)&bmi, DIB_RGB_COLORS);
    DeleteObject(hbmp);
    // Win95 only supports 555 and 565
    // For NT we'll assume this covers the majority cases too
    if( (bmi.bf[0] == 0xF800) && 
                (bmi.bf[1] == 0x07E0) && 
                (bmi.bf[2] == 0x001F) ) // RGB mask
    {
                dwDepth = 16u;
    }
    return dwDepth;
}


#pragma optimize( "", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\mathwrap.cpp ===
#include "math.h"
#include "utilpre.h"
#include "utils.h"
#include "otrig.h"
#include "mathwrap.h"

#pragma optimize( "agt", on )
#pragma intrinsic( sqrt, sin, cos )
#pragma intrinsic( pow )    // not a true intrinsic form, 
                            // but loads FP registes directly


OTrig CMathWrapper::s_otrig;

CMathWrapper::CMathWrapper (void)
{
}

CMathWrapper::~CMathWrapper (void)
{
}

float
CMathWrapper::Pow (double x, double y)
{
	return (float)pow(x, y);
}

float  __fastcall
CMathWrapper::Sqrt (float x)
{
	return (float)sqrt(x);
}

float	__fastcall
CMathWrapper::SinDeg(float	fltAngle)
{
	return s_otrig.Sin(fltAngle);
}

float	__fastcall
CMathWrapper::CosDeg(float	fltAngle)
{
	return s_otrig.Cos(fltAngle);
}

float	__fastcall
CMathWrapper::SinDeg(long	lAngleOneTenths)
{
	return s_otrig.Sin(lAngleOneTenths);
}

float	__fastcall
CMathWrapper::CosDeg(long lAngleOneTenths)
{
	return s_otrig.Cos(lAngleOneTenths);
}


float	__fastcall
CMathWrapper::SinDegWrap(float	fltAngle)
{
	return s_otrig.SinWrap(fltAngle);
}

float	__fastcall
CMathWrapper::CosDegWrap(float	fltAngle)
{
	return s_otrig.CosWrap(fltAngle);
}

float	__fastcall
CMathWrapper::SinDegWrap(long	lAngleOneTenths)
{
	return s_otrig.SinWrap(lAngleOneTenths);
}

float	__fastcall
CMathWrapper::CosDegWrap(long lAngleOneTenths)
{
	return s_otrig.CosWrap(lAngleOneTenths);
}


double __fastcall
CMathWrapper::SinRad (double dblRads)
{
	return ::sin(dblRads);
}

double __fastcall
CMathWrapper::CosRad (double dblRads)
{
	return ::cos(dblRads);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\idguids.cpp ===
#include "UtilPre.h"

#include <objbase.h>
#include <initguid.h>

#include <IdGuids.h>
#include <ddraw.h>      // IID_IDirectDrawSurface
#include "bfid_rgb.h"	// BFID_RGB_...
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\memlayer.cpp ===
/*=========================================================================*\

    File    : MEMMAN.CPP
    Purpose : CMemManager Class Implementation
    Author  : Michael Byrd
    Date    : 07/10/96

\*=========================================================================*/

#include "UtilPre.h"
#include <minmax.h>

/*=========================================================================*\
     Global Variables:
\*=========================================================================*/

// Global instance of memory manager (MUST BE GLOBAL!)
CMemManager CMemManager::g_CMemManager;

/*=========================================================================*\
     Single entry point for external debugging:
\*=========================================================================*/

VOID EXPORT WINAPI ExternalDumpAllocations(LPSTR lpstrFilename)
{
    CMemManager::DumpAllocationsGlb(lpstrFilename);
}

/*=========================================================================*\
     CMemUser Class:
\*=========================================================================*/

EXPORT CMemUser::CMemUser(void)
{
    CMemManager::RegisterMemUserGlb(this);
}

/*=========================================================================*/

EXPORT CMemUser::~CMemUser(void)
{
    CMemManager::UnRegisterMemUserGlb(this);
}

/*=========================================================================*/

LPMEMBLOCK EXPORT CMemUser::AllocBuffer(DWORD dwBytesToAlloc, WORD wFlags)
{
    LPMEMBLOCK lpResult = (LPMEMBLOCK)NULL;

    return lpResult;
}

/*=========================================================================*/

void EXPORT CMemUser::FreeBuffer(LPMEMBLOCK lpMemBlock)
{
}

/*=========================================================================*/

LPVOID EXPORT CMemUser::LockBuffer(LPMEMBLOCK lpMemBlock)
{
    LPVOID lpResult = (LPVOID)NULL;

    return lpResult;
}

/*=========================================================================*/

void EXPORT CMemUser::UnLockBuffer(LPMEMBLOCK lpMemBlock)
{
}

/*=========================================================================*/

BOOL EXPORT CMemUser::NotifyMemUser(LPMEMNOTIFY lpMemNotify)
{
    BOOL fResult = FALSE;

    return fResult;
}

/*=========================================================================*\
     CMemManager Class:
\*=========================================================================*/

EXPORT CMemManager::CMemManager(void)
{
    // Zero out our member variables...
    m_iNumHeaps     = 0;
    m_lpHeapHeader  = (LPHEAPHEADER)NULL;

    m_iNumMemUsers  = 0;
    m_lpMemUserInfo = (LPMEMUSERINFO)NULL;

    m_iNumMemBlocks = 0;
    m_lplpMemBlocks = (LPMEMBLOCK *)NULL;

    m_iMemBlockFree = 0;

    // Initialize the critical sections...
    InitializeCriticalSection(&m_CriticalHeap);
    InitializeCriticalSection(&m_CriticalMemUser);
    InitializeCriticalSection(&m_CriticalMemBlock);

    // The m_lpMemHeader, m_lpMemUserInfo, and m_lplpMemBlocks arrays
    // are allocated on the default process heap:
    m_handleProcessHeap = GetProcessHeap();

    // Create the "Standard" size heaps...
    CreateHeap(  16);
    CreateHeap(  32);
    CreateHeap(  64);
    CreateHeap( 128);
    CreateHeap( 256);
    CreateHeap( 512);
    CreateHeap(1024);
    CreateHeap(2048);
    CreateHeap(4096);
    CreateHeap(8192);
}

/*=========================================================================*/

EXPORT CMemManager::~CMemManager(void)
{
    // Free up the buffers that we allocated...
    Cleanup();

    // Get rid of the critical sections...
    DeleteCriticalSection(&m_CriticalHeap);
    DeleteCriticalSection(&m_CriticalMemUser);
    DeleteCriticalSection(&m_CriticalMemBlock);
}

/*=========================================================================*/

void CMemManager::Cleanup(void)
{
    int iItemIndex=0;

#ifdef _DEBUG
    // Dump a list of the allocations...
    DumpAllocations(NULL);
#endif // _DEBUG

    // Free all of the currently allocated CMemUser's first...
    EnterCriticalSection(&m_CriticalMemUser);
    LeaveCriticalSection(&m_CriticalMemUser);

    // Free all of the currently allocated LPMEMBLOCK's next...
    EnterCriticalSection(&m_CriticalMemBlock);

    // Release the memory from the proper heap...
    for(iItemIndex=0;iItemIndex<m_iNumMemBlocks;iItemIndex++)
    {
        LPMEMBLOCK lpCurrentMemBlock = m_lplpMemBlocks[iItemIndex];

        if (lpCurrentMemBlock)
        {
            FreeBufferMemBlock(lpCurrentMemBlock);

            // Prevent the code below from accessing bogus pointers!
            if (lpCurrentMemBlock->wFlags & MEM_SUBALLOC)
                m_lplpMemBlocks[iItemIndex] = NULL;
        }
    }

    // Now free the memory blocks that are not sub-allocations...
    for(iItemIndex=0;iItemIndex<m_iNumMemBlocks;iItemIndex++)
    {
        LPMEMBLOCK lpCurrentMemBlock = m_lplpMemBlocks[iItemIndex];

        if (lpCurrentMemBlock && ((lpCurrentMemBlock->wFlags & MEM_SUBALLOC) == 0))
        {
            // Kill the MEMBLOCK structure that we allocated...
            HeapFree(
                m_handleProcessHeap,
                (DWORD)0,
                lpCurrentMemBlock);
        }

        m_lplpMemBlocks[iItemIndex] = NULL;
    }

    // Now kill the array of memblock pointers...
    m_iNumMemBlocks = 0;
    HeapFree(
        m_handleProcessHeap,
        (DWORD)0,
        m_lplpMemBlocks);
    m_lplpMemBlocks = NULL;

    LeaveCriticalSection(&m_CriticalMemBlock);

    // Free all of the currently allocated HEAPBLOCK's last...
    EnterCriticalSection(&m_CriticalHeap);
    for(iItemIndex=0;iItemIndex<m_iNumHeaps;iItemIndex++)
    {
        LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iItemIndex];

        if (lpHeapHeader->fInUse && lpHeapHeader->handleHeap)
        {
            if (HeapDestroy(lpHeapHeader->handleHeap))
            {
                lpHeapHeader->fInUse     = FALSE;
                lpHeapHeader->handleHeap = (HANDLE)NULL;
            }
        }
    }

    // Now kill the array of HEAPHEADERs
    m_iNumHeaps = 0;
    HeapFree(
        m_handleProcessHeap,
        (DWORD)0,
        m_lpHeapHeader);
    m_lpHeapHeader = NULL;

    LeaveCriticalSection(&m_CriticalHeap);
}

/*=========================================================================*/

BOOL CMemManager::CreateHeap(DWORD dwHeapBlockSize)
{
    BOOL fResult = FALSE;
    BOOL fDone   = FALSE;

    EnterCriticalSection(&m_CriticalHeap);

    while(!fDone)
    {
        // Look through the list if we are not done...
        if (m_iNumHeaps && m_lpHeapHeader)
        {
            int iHeapIndex = 0;

            for(iHeapIndex=0;iHeapIndex<m_iNumHeaps;iHeapIndex++)
            {
                LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iHeapIndex];

                if (!lpHeapHeader->fInUse)
                {
                    fDone = TRUE;

                    // Create the new heap...
                    lpHeapHeader->handleHeap = HeapCreate(
                        (DWORD)0,
                        (dwHeapBlockSize * HEAPINITIALITEMCOUNT),
                        (DWORD)0);

                    if (lpHeapHeader->handleHeap)
                    {
                        lpHeapHeader->fInUse           = TRUE;
                        lpHeapHeader->dwBlockAllocSize = dwHeapBlockSize;
                        lpHeapHeader->iNumBlocks       = 0; // Informational only

                        fResult = TRUE;
                    }
                    else
                    {
                        // We could not create the heap!
                        fDone = TRUE;
                    }

                    // Break out of the for loop...
                    break;
                }
            }
        }

        // We haven't finished yet...
        if (!fDone)
        {
            if (!m_iNumHeaps || !m_lpHeapHeader)
            {
                // We haven't allocated the array yet!
                m_lpHeapHeader = (LPHEAPHEADER)HeapAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(HEAPHEADER) * MEMHEAPGROW);

                if (m_lpHeapHeader)
                {
                    m_iNumHeaps = MEMHEAPGROW;
                }
                else
                {
                    // Break out of the while loop...
                    fDone = TRUE;
                }
            }
            else
            {
                LPHEAPHEADER lpHeapHeader = (LPHEAPHEADER)NULL;

                // We have a HEAPHEADER array,  but no empty entries,
                // So increase the size of the m_lpHeapHeader array!

                lpHeapHeader = (LPHEAPHEADER)HeapReAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    m_lpHeapHeader,
                    sizeof(HEAPHEADER) * (m_iNumHeaps + MEMHEAPGROW));

                if (lpHeapHeader)
                {
                    m_lpHeapHeader = lpHeapHeader;
                    m_iNumHeaps += MEMHEAPGROW;
                }
                else
                {
                    // Break out of the while loop...
                    fDone = TRUE;
                }
            }
        }
    }

    LeaveCriticalSection(&m_CriticalHeap);

    return fResult;
}

/*=========================================================================*/

BOOL CMemManager::DestroyHeap(HANDLE handleHeap)
{
    BOOL fResult = FALSE;

    EnterCriticalSection(&m_CriticalHeap);

    if (handleHeap && m_iNumHeaps && m_lpHeapHeader)
    {
        int iHeapIndex = 0;

        for(iHeapIndex=0;iHeapIndex<m_iNumHeaps;iHeapIndex++)
        {
            LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iHeapIndex];

            if (lpHeapHeader->fInUse && (lpHeapHeader->handleHeap == handleHeap))
            {
                Proclaim(lpHeapHeader->iNumBlocks == 0);

                // We can only destroy the heap if it is empty!
                if (lpHeapHeader->iNumBlocks == 0)
                {
                    if (HeapDestroy(handleHeap))
                    {
                        lpHeapHeader->fInUse     = FALSE;
                        lpHeapHeader->handleHeap = (HANDLE)NULL;

                        fResult = TRUE;
                    }
                }

                break;
            }
        }
    }

    LeaveCriticalSection(&m_CriticalHeap);

    return fResult;
}

/*=========================================================================*/

int CMemManager::FindHeap(DWORD dwAllocationSize, LPHEAPHEADER lpHeapHeader)
{
    int iResult = -1;
    DWORD dwMinWasted = (DWORD)0x80000000; // Must be bigger than object!

    // Prevent other heap management functions from intercepting us...
    EnterCriticalSection(&m_CriticalHeap);

    // This will find the heap that wastes the least amount of space...
    if (dwAllocationSize && m_iNumHeaps && m_lpHeapHeader && lpHeapHeader)
    {
        int iHeapIndex = 0;

        for(iHeapIndex = 0;iHeapIndex<m_iNumHeaps;iHeapIndex++)
        {
            LPHEAPHEADER lpCurrentHeapHeader = &m_lpHeapHeader[iHeapIndex];

            if (lpCurrentHeapHeader->fInUse && lpCurrentHeapHeader->handleHeap)
            {
                if (lpCurrentHeapHeader->dwBlockAllocSize >= dwAllocationSize)
                {
                    DWORD dwWasted = lpCurrentHeapHeader->dwBlockAllocSize - dwAllocationSize;

                    if (dwWasted < dwMinWasted)
                    {
                        iResult = iHeapIndex;
                        dwMinWasted = dwWasted;

                        // Early-out for exact match!
                        if (dwWasted == 0)
                            break;
                    }
                }
            }
        }

        if (iResult >= 0)
            *lpHeapHeader = m_lpHeapHeader[iResult];
    }

    // Allow heap management to continue...
    LeaveCriticalSection(&m_CriticalHeap);

    return iResult;
}

/*=========================================================================*/

LPVOID CMemManager::AllocFromHeap(int iHeapIndex, DWORD dwAllocationSize)
{
    LPVOID lpResult = (LPVOID)NULL;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return lpResult;
#endif // _DEBUG

    // Prevent other heap management functions from intercepting us...
    EnterCriticalSection(&m_CriticalHeap);

    if (m_iNumHeaps && m_lpHeapHeader && iHeapIndex >=0 && iHeapIndex < m_iNumHeaps)
    {
        LPHEAPHEADER lpCurrentHeapHeader = &m_lpHeapHeader[iHeapIndex];

        if (lpCurrentHeapHeader->fInUse && lpCurrentHeapHeader->handleHeap)
        {
            if (lpCurrentHeapHeader->dwBlockAllocSize >= dwAllocationSize)
            {
                // Allocate the memory from the selected heap...
                lpResult = HeapAlloc(
                    lpCurrentHeapHeader->handleHeap,
                    HEAP_ZERO_MEMORY,
                    lpCurrentHeapHeader->dwBlockAllocSize+ALLOC_EXTRA);

                if (lpResult)
                {
                    // Make sure this heap's object count is incremented...
                    lpCurrentHeapHeader->iNumBlocks++;
                }
            }
        }
    }

    // Allow heap management to continue...
    LeaveCriticalSection(&m_CriticalHeap);

    return lpResult;
}

/*=========================================================================*/

BOOL CMemManager::FreeFromHeap(int iHeapIndex, LPVOID lpBuffer)
{
    BOOL fResult = FALSE;

    // Prevent other heap management functions from intercepting us...
    EnterCriticalSection(&m_CriticalHeap);

    if (lpBuffer && m_iNumHeaps && m_lpHeapHeader && (iHeapIndex >= 0) && (iHeapIndex < m_iNumHeaps))
    {
        LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iHeapIndex];

        if (lpHeapHeader->fInUse && lpHeapHeader->handleHeap)
        {
            // Allocate the memory from the selected heap...
            fResult = HeapFree(
                lpHeapHeader->handleHeap,
                (DWORD)0,
                lpBuffer);

            if (fResult)
            {
                // Make sure this heap's object count is decremented...
                lpHeapHeader->iNumBlocks--;
            }
        }
    }

    // Allow heap management to continue...
    LeaveCriticalSection(&m_CriticalHeap);

    return fResult;
}

/*=========================================================================*/

BOOL EXPORT CMemManager::RegisterMemUser(CMemUser *lpMemUser)
{
    BOOL fResult = FALSE;
    BOOL fDone   = FALSE;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return fResult;
#endif // _DEBUG

    EnterCriticalSection(&m_CriticalMemUser);

    while(!fDone)
    {
        // Look through the list if we are not done...
        if (m_iNumMemUsers && m_lpMemUserInfo)
        {
            int iMemUserIndex = 0;

            for(iMemUserIndex=0;iMemUserIndex<m_iNumHeaps;iMemUserIndex++)
            {
                LPMEMUSERINFO lpMemUserInfo = &m_lpMemUserInfo[iMemUserIndex];

                if (!lpMemUserInfo->fInUse)
                {
                    fDone = TRUE;
                    fResult = TRUE;

                    // Fill in the info about this mem user...
                    lpMemUserInfo->fInUse     = TRUE;
                    lpMemUserInfo->dwThreadID = GetCurrentThreadId();
                    lpMemUserInfo->lpMemUser  = lpMemUser;

                    // Break out of the for loop...
                    break;
                }
            }
        }

        // We haven't finished yet...
        if (!fDone)
        {
            if (!m_iNumMemUsers || !m_lpMemUserInfo)
            {
                // We haven't allocated the array yet!
                m_lpMemUserInfo = (LPMEMUSERINFO)HeapAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(MEMUSERINFO) * MEMUSERGROW);

                if (m_lpMemUserInfo)
                {
                    m_iNumMemUsers = MEMUSERGROW;
                }
                else
                {
                    // Break out of the while loop...
                    fDone = TRUE;
                }
            }
            else
            {
                LPMEMUSERINFO lpMemUserInfo = (LPMEMUSERINFO)NULL;

                // We have a MEMUSERINFO array,  but no empty entries,
                // So increase the size of the m_lpMemUserInfo array!

                lpMemUserInfo = (LPMEMUSERINFO)HeapReAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    m_lpMemUserInfo,
                    sizeof(MEMUSERINFO) * (m_iNumMemUsers + MEMUSERGROW));

                if (lpMemUserInfo)
                {
                    m_lpMemUserInfo = lpMemUserInfo;
                    m_iNumMemUsers += MEMUSERGROW;
                }
                else
                {
                    // Break out of the while loop...
                    fDone = TRUE;
                }
            }
        }
    }

    LeaveCriticalSection(&m_CriticalMemUser);

    return fResult;
}

/*=========================================================================*/

BOOL EXPORT CMemManager::UnRegisterMemUser(CMemUser *lpMemUser)
{
    BOOL fResult = FALSE;

    EnterCriticalSection(&m_CriticalMemUser);

    if (lpMemUser && m_iNumMemUsers && m_lpMemUserInfo)
    {
        int iMemUserIndex = 0;

        for(iMemUserIndex = 0;iMemUserIndex < m_iNumMemUsers;iMemUserIndex++)
        {
            LPMEMUSERINFO lpMemUserInfo = &m_lpMemUserInfo[iMemUserIndex];

            // We found the CMemUser!
            if (lpMemUserInfo->fInUse && (lpMemUserInfo->lpMemUser == lpMemUser))
            {
                Proclaim(lpMemUserInfo->iNumBlocks == 0);

                if (lpMemUserInfo->iNumBlocks == 0)
                {
                    lpMemUserInfo->fInUse     = FALSE;
                    lpMemUserInfo->lpMemUser  = (CMemUser *)NULL;
                    lpMemUserInfo->dwThreadID = (DWORD)0;

                    fResult = TRUE;
                }
                else
                {
                    // We MUST set this to NULL to prevent notification
                    // callback from getting called.
                    lpMemUserInfo->lpMemUser = (CMemUser *)NULL;
                }

                break;
            }
        }
    }

    LeaveCriticalSection(&m_CriticalMemUser);

    return fResult;
}

/*=========================================================================*/

LPMEMBLOCK CMemManager::AllocMemBlock(int far *piIndex)
{
    LPMEMBLOCK lpResult = (LPMEMBLOCK)NULL;
    BOOL fDone = FALSE;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return lpResult;
#endif // _DEBUG

    if (!piIndex)
        return lpResult;

    EnterCriticalSection(&m_CriticalMemBlock);

    while(!fDone)
    {
        // Look through the list if we are not done...
        if (m_iNumMemBlocks && m_lplpMemBlocks)
        {
            int iMemBlockIndex = 0;

            // Look for a free mem block...
            for(iMemBlockIndex=m_iMemBlockFree;iMemBlockIndex<m_iNumMemBlocks;iMemBlockIndex++)
            {
                LPMEMBLOCK lpMemBlock = m_lplpMemBlocks[iMemBlockIndex];

                if (!lpMemBlock->fInUse)
                {
                    if (!fDone)
                    {
                        fDone    = TRUE;
                        lpResult = lpMemBlock;

                        // Fill in the info about this mem block...
                        lpMemBlock->fInUse          = TRUE;
                        lpMemBlock->lpData          = NULL;
                        lpMemBlock->dwSize          = (DWORD)0;
                        lpMemBlock->wFlags          = (lpMemBlock->wFlags & MEM_INTERNAL_FLAGS);
                        lpMemBlock->wLockCount      = 0;
                        lpMemBlock->iHeapIndex      = 0;
                        lpMemBlock->iMemUserIndex   = -1;
#ifdef _DEBUG
                        lpMemBlock->iLineNum        = 0;
                        lpMemBlock->rgchFileName[0] = 0;
#endif // _DEBUG
                        *piIndex = iMemBlockIndex;
                    }
                    else
                    {
                        // Set the min mark...
                        m_iMemBlockFree = iMemBlockIndex;
                        break;
                    }
                }
            }
        }

        // We haven't finished yet...
        if (!fDone)
        {
            LPMEMBLOCK lpNewMemBlocks = (LPMEMBLOCK)NULL;

            // We ALWAYS need to allocate the MEMBLOCK's here...
            lpNewMemBlocks = (LPMEMBLOCK)HeapAlloc(
                m_handleProcessHeap,
                HEAP_ZERO_MEMORY,
                sizeof(MEMBLOCK) * MEMBLOCKGROW);

            if (lpNewMemBlocks)
            {
                if (!m_iNumMemBlocks || !m_lplpMemBlocks)
                {
                    // We haven't allocated the array yet!
                    m_lplpMemBlocks = (LPMEMBLOCK *)HeapAlloc(
                        m_handleProcessHeap,
                        HEAP_ZERO_MEMORY,
                        sizeof(LPMEMBLOCK) * MEMBLOCKGROW);

                    if (!m_lplpMemBlocks)
                    {
                        // Break out of the while loop...
                        fDone = TRUE;
                    }
                }
                else
                {
                    LPMEMBLOCK *lplpMemBlock = (LPMEMBLOCK *)NULL;

                    // We have a MEMBLOCK array,  but no empty entries,
                    // So increase the size of the m_lplpMemBlocks array!

                    lplpMemBlock = (LPMEMBLOCK *)HeapReAlloc(
                        m_handleProcessHeap,
                        HEAP_ZERO_MEMORY,
                        m_lplpMemBlocks,
                        sizeof(LPMEMBLOCK) * (m_iNumMemBlocks + MEMBLOCKGROW));

                    if (lplpMemBlock)
                    {
                        m_lplpMemBlocks = lplpMemBlock;
                    }
                    else
                    {
                        // Break out of the while loop...
                        fDone = TRUE;
                    }
                }

                // We should only do this if the allocations succeeded!
                if (!fDone)
                {
                    int iMemBlockIndex = 0;

                    // Fill in the pointer array...
                    for(iMemBlockIndex=0;iMemBlockIndex<MEMBLOCKGROW;iMemBlockIndex++)
                    {
                        LPMEMBLOCK lpMemBlock = &lpNewMemBlocks[iMemBlockIndex];

                        m_lplpMemBlocks[iMemBlockIndex+m_iNumMemBlocks] =
                            lpMemBlock;

                        // Initialize the flags...
                        if (iMemBlockIndex == 0)
                            lpMemBlock->wFlags = 0;
                        else
                            lpMemBlock->wFlags = MEM_SUBALLOC;
                    }

                    // Set the index of the first free block...
                    m_iMemBlockFree = m_iNumMemBlocks;

                    m_iNumMemBlocks += MEMBLOCKGROW;
                }
                else
                {
                    // Free the MEMBLOCK array that we allocated!
                    HeapFree(
                        m_handleProcessHeap,
                        (DWORD)0,
                        lpNewMemBlocks);
                }
            }
            else
            {
                // Couldn't allocate the MEMBLOCK structures!
                fDone = TRUE;
            }
        }
    }

    LeaveCriticalSection(&m_CriticalMemBlock);

    return lpResult;
}

/*=========================================================================*/

BOOL CMemManager::FreeMemBlock(LPMEMBLOCK lpMemBlock, int iMemBlockIndex)
{
    BOOL fResult = FALSE;

    EnterCriticalSection(&m_CriticalMemBlock);

    if (lpMemBlock && m_iNumMemBlocks && m_lplpMemBlocks)
    {
        // The MEMBLOCK always comes from our list...
        if (lpMemBlock->fInUse)
        {
            Proclaim(lpMemBlock->wLockCount == 0);

            if (iMemBlockIndex == -1)
            {
                int iBlockIndex=0;

                for(iBlockIndex = 0;iBlockIndex < m_iNumMemBlocks;iBlockIndex++)
                {
                    if (lpMemBlock == m_lplpMemBlocks[iBlockIndex])
                    {
                        iMemBlockIndex = iBlockIndex;
                        break;
                    }
                }
            }

			Proclaim(iMemBlockIndex >= 0);

            if (iMemBlockIndex < m_iMemBlockFree &&
                iMemBlockIndex >= 0)
            {
                // reset the low-water mark...
                m_iMemBlockFree = iMemBlockIndex;
            }

            if (lpMemBlock->wLockCount == 0)
            {
                lpMemBlock->fInUse          = FALSE;
                lpMemBlock->lpData          = NULL;
                lpMemBlock->dwSize          = (DWORD)0;
                lpMemBlock->wFlags          = (lpMemBlock->wFlags & MEM_INTERNAL_FLAGS);
                lpMemBlock->wLockCount      = 0;
                lpMemBlock->iHeapIndex      = 0;
                lpMemBlock->iMemUserIndex   = -1;
#ifdef _DEBUG
                lpMemBlock->iLineNum        = 0;
                lpMemBlock->rgchFileName[0] = 0;
#endif // _DEBUG

                fResult = TRUE;
            }
        }
    }

    LeaveCriticalSection(&m_CriticalMemBlock);

    return fResult;
}

/*=========================================================================*/

LPMEMBLOCK CMemManager::FindMemBlock(LPVOID lpBuffer, int *piIndex)
{
    LPMEMBLOCK lpResult = (LPMEMBLOCK)NULL;

    EnterCriticalSection(&m_CriticalMemBlock);

    if (lpBuffer && m_iNumMemBlocks && m_lplpMemBlocks)
    {
        LPBYTE lpByte = (LPBYTE)lpBuffer;
        int iRetIndex = -1;

        lpByte -= ALLOC_EXTRA;

        iRetIndex = *(int *)lpByte;

        if (iRetIndex <= m_iNumMemBlocks && iRetIndex >= 0)
        {
            LPMEMBLOCK lpMemBlock = m_lplpMemBlocks[iRetIndex];
            LPBYTE     lpData = (LPBYTE)lpMemBlock->lpData;

            lpData += ALLOC_EXTRA;

            if (lpData == lpBuffer)
            {
                lpResult = lpMemBlock;
            }
        }

        Proclaim(lpResult != NULL);

        if (piIndex)
            *piIndex = iRetIndex;
    }

    LeaveCriticalSection(&m_CriticalMemBlock);

    return lpResult;
}

/*=========================================================================*/

LPVOID EXPORT CMemManager::AllocBuffer(
    DWORD dwBytesToAlloc,
#ifdef _DEBUG
    WORD  wFlags,
    int   iLine,
    LPSTR lpstrFile)
#else // !_DEBUG
    WORD  wFlags)
#endif // !_DEBUG
{
    LPVOID lpResult = (LPVOID)NULL;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return lpResult;
#endif // _DEBUG

    // Restrict flags to externally available
    wFlags &= MEM_EXTERNAL_FLAGS;

    if (dwBytesToAlloc)
    {
        int iHeapIndex = 0;
        HEAPHEADER heapHeader;
        LPBYTE lpByte = (LPBYTE)NULL;

        // Find the proper heap to allocate from...
        iHeapIndex = FindHeap(dwBytesToAlloc, &heapHeader);

        if (iHeapIndex >= 0)
        {
            // Allocate the memory for the object from the selected heap...
            lpByte = (LPBYTE)AllocFromHeap(iHeapIndex, dwBytesToAlloc);
        }
        else
        {
            // Allocate the memory for the object from the process heap...
            lpByte = (LPBYTE)HeapAlloc(
                m_handleProcessHeap,
                HEAP_ZERO_MEMORY,
                dwBytesToAlloc+ALLOC_EXTRA);
        }

        if (lpByte)
        {
            int iIndexBlock = -1;
            LPMEMBLOCK lpMemBlock = AllocMemBlock(&iIndexBlock);

            if (lpMemBlock && iIndexBlock >= 0)
            {
                lpMemBlock->lpData        = lpByte;
                lpMemBlock->dwSize        = dwBytesToAlloc;
                lpMemBlock->wFlags        = (lpMemBlock->wFlags & MEM_INTERNAL_FLAGS) | wFlags;
                lpMemBlock->wLockCount    = 0;
                lpMemBlock->iHeapIndex    = iHeapIndex;
                lpMemBlock->iMemUserIndex = -1;
#ifdef _DEBUG
                lpMemBlock->iLineNum      = iLine;
                lstrcpyn(lpMemBlock->rgchFileName, lpstrFile, MAX_SOURCEFILENAME);
#endif // _DEBUG

                *(int *)lpByte = iIndexBlock;
                lpByte += ALLOC_EXTRA;

                lpResult = (LPVOID)lpByte;
            }
            else
            {
                if (iHeapIndex >= 0)
                {
                    FreeFromHeap(iHeapIndex, lpByte);
                }
                else
                {
                    HeapFree(
                        m_handleProcessHeap,
                        (DWORD)0,
                        lpByte);
                }
            }
        }
    }

    return lpResult;
}

/*=========================================================================*/

LPVOID EXPORT CMemManager::ReAllocBuffer(
    LPVOID lpBuffer,
    DWORD dwBytesToAlloc,
#ifdef _DEBUG
    WORD  wFlags,
    int   iLine,
    LPSTR lpstrFile)
#else // !_DEBUG
    WORD  wFlags)
#endif // !_DEBUG
{
    LPVOID lpResult = NULL;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return lpResult;
#endif // _DEBUG

    // Restrict flags to externally available
    wFlags &= MEM_EXTERNAL_FLAGS;

    if (lpBuffer && dwBytesToAlloc)
    {
        int iIndexBlock = -1;
        LPMEMBLOCK lpMemBlock = FindMemBlock(lpBuffer, &iIndexBlock);

        if (lpMemBlock && iIndexBlock >= 0)
        {
            int iHeapIndex = 0;
            HEAPHEADER heapHeader;
            LPBYTE lpByte = NULL;

            if (lpMemBlock->iHeapIndex >= 0)
            {
                // Get the heap info about this memory block...
                iHeapIndex = FindHeap(lpMemBlock->dwSize, &heapHeader);

                // No need to actually re-alloc (we have enough room already!)
                if ((iHeapIndex == lpMemBlock->iHeapIndex) &&
                    heapHeader.dwBlockAllocSize >= dwBytesToAlloc)
                {
                    lpByte = (LPBYTE)lpMemBlock->lpData;

                    lpByte += ALLOC_EXTRA;

                    lpResult = (LPVOID)lpByte;

                    // Re-zero the extra memory...
                    if (lpMemBlock->dwSize > dwBytesToAlloc)
                    {
                        lpByte += dwBytesToAlloc;

                        memset(lpByte, 0, (lpMemBlock->dwSize-dwBytesToAlloc));
                    }

                    lpMemBlock->dwSize = dwBytesToAlloc;

                    return lpResult;
                }
            }
            else
            {
                // Re-allocate from the current process heap!
                lpByte = (LPBYTE)HeapReAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    lpMemBlock->lpData,
                    dwBytesToAlloc+ALLOC_EXTRA);

                // Don't affect the memblock if the re-alloc fails!
                if (lpByte)
                {
                    lpMemBlock->lpData = (LPVOID)lpByte;
                    lpMemBlock->dwSize = dwBytesToAlloc;

                    lpByte += ALLOC_EXTRA;

                    lpResult = (LPVOID)lpByte;
                }

                return lpResult;
            }

            // Find the proper heap to allocate from...
            iHeapIndex = FindHeap(dwBytesToAlloc, &heapHeader);

            if (iHeapIndex >= 0)
            {
                // Allocate the memory for the object from the selected heap...
                lpByte = (LPBYTE)AllocFromHeap(iHeapIndex, dwBytesToAlloc);
            }
            else
            {
                // Allocate the memory for the object from the process heap...
                lpByte = (LPBYTE)HeapAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    dwBytesToAlloc+ALLOC_EXTRA);
            }

            if (lpByte)
            {
                LPBYTE lpBase = (LPBYTE)lpByte;
                LPBYTE lpData = (LPBYTE)lpMemBlock->lpData;

                *(int *)lpByte = iIndexBlock;

                lpByte += ALLOC_EXTRA;
                lpData += ALLOC_EXTRA;

                // Copy the data...
                memcpy(lpByte, lpData, min(lpMemBlock->dwSize, dwBytesToAlloc));

                // Free the memory from the proper heap...
                if (lpMemBlock->iHeapIndex >= 0)
                {
                    FreeFromHeap(lpMemBlock->iHeapIndex, lpMemBlock->lpData);
                }
                else
                {
                    HeapFree(
                        m_handleProcessHeap,
                        (DWORD)0,
                        lpMemBlock->lpData);
                }

                // Remember the new allocation's info...
                lpMemBlock->iHeapIndex = iHeapIndex;
                lpMemBlock->lpData     = lpBase;
                lpMemBlock->dwSize     = dwBytesToAlloc;

                lpResult = lpByte;
            }
        }
    }

    return lpResult;
}

/*=========================================================================*/

void EXPORT CMemManager::FreeBufferMemBlock(LPMEMBLOCK lpMemBlock)
{
    if (lpMemBlock && lpMemBlock->fInUse)
    {
        // Free the memory from the proper heap...
        if (lpMemBlock->iHeapIndex >= 0)
        {
            FreeFromHeap(lpMemBlock->iHeapIndex, lpMemBlock->lpData);
        }
        else
        {
            HeapFree(
                m_handleProcessHeap,
                (DWORD)0,
                lpMemBlock->lpData);
        }

		// REVIEW PAULD - defer resetting fInUse until FreeMemBlock is called.
		// Since we're called in sequence (except from Cleanup), this
		// should not be a problem.
        lpMemBlock->lpData = NULL;
        lpMemBlock->dwSize = (DWORD)0;
    }
}

/*=========================================================================*/

void EXPORT CMemManager::FreeBuffer(LPVOID lpBuffer)
{
    if (lpBuffer)
    {
        int iIndexBlock = -1;
        LPMEMBLOCK lpMemBlock = FindMemBlock(lpBuffer, &iIndexBlock);

        FreeBufferMemBlock(lpMemBlock);

        // This clears out the block...
        FreeMemBlock(lpMemBlock, iIndexBlock);
    }
}

/*=========================================================================*/

DWORD EXPORT CMemManager::SizeBuffer(LPVOID lpBuffer)
{
    DWORD dwResult = 0;

    if (lpBuffer)
    {
        LPMEMBLOCK lpMemBlock = FindMemBlock(lpBuffer);

        if (lpMemBlock)
        {
            dwResult = lpMemBlock->dwSize;
        }
    }

    return dwResult;
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpHeapHeader(LPHEAPHEADER lpHeapHeader, FILE *fileOutput)
{
    char rgOutput[256];

    wsprintf(rgOutput, "HEAP(0x%08X);SIZE(0x%08X);COUNT(0x%08X) ===================================================\n",
        lpHeapHeader,
        lpHeapHeader->dwBlockAllocSize,
        lpHeapHeader->iNumBlocks);

    if (fileOutput)
        fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
    else
        OutputDebugString(rgOutput);
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpMemUserInfo(LPMEMUSERINFO lpMemUserInfo, FILE *fileOutput)
{
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpMemBlock(LPMEMBLOCK lpMemBlock, FILE *fileOutput)
{
    if (lpMemBlock)
    {
        char rgOutput[256];

#ifdef _DEBUG
        wsprintf(rgOutput, "MEM(0x%08X);DATA(0x%08X);SIZE(0x%08X);LINE;(%05d);FILE(%s)\n",
            lpMemBlock,
            lpMemBlock->lpData,
            lpMemBlock->dwSize,
            lpMemBlock->iLineNum,
            lpMemBlock->rgchFileName);
#else // !_DEBUG
        wsprintf(rgOutput, "MEM(0x%08X);DATA(0x%08X);SIZE(0x%08X)\n",
            lpMemBlock,
            lpMemBlock->lpData,
            lpMemBlock->dwSize);
#endif // !_DEBUG

        if (fileOutput)
            fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
        else
            OutputDebugString(rgOutput);
    }
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpAllocations(LPSTR lpstrFilename)
{
    FILE *fileOutput = (FILE *)NULL;
    int iItemIndex = 0;
    int iHeapIndex = 0;
    BOOL fProcessBlocks = FALSE;
    char rgOutput[256];

    if (lpstrFilename)
    {
        fileOutput = fopen(lpstrFilename, "w");

        // Just get out now...
        if (!fileOutput)
            return;
    }

    if (fileOutput)
        fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
    else
        OutputDebugString(rgOutput);

    EnterCriticalSection(&m_CriticalHeap);
    EnterCriticalSection(&m_CriticalMemBlock);

    for(iHeapIndex=0;iHeapIndex < m_iNumHeaps;iHeapIndex++)
    {
        LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iHeapIndex];

        if (lpHeapHeader && lpHeapHeader->fInUse && lpHeapHeader->iNumBlocks)
        {
            DumpHeapHeader(lpHeapHeader, fileOutput);

            // Dump a readable list of the memory blocks...
            for(iItemIndex=0;iItemIndex < m_iNumMemBlocks;iItemIndex++)
            {
                LPMEMBLOCK lpMemBlock = m_lplpMemBlocks[iItemIndex];

                if (lpMemBlock->fInUse)
                {
                    if (lpMemBlock->iHeapIndex == iHeapIndex)
                        DumpMemBlock(lpMemBlock, fileOutput);

                    if (lpMemBlock->iHeapIndex == -1)
                        fProcessBlocks = TRUE;
                }
            }
        }
    }

    if (fProcessBlocks)
    {
        wsprintf(rgOutput, "HEAP(PROCESS) ===================================================\n");

        if (fileOutput)
            fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
        else
            OutputDebugString(rgOutput);

        // Dump a readable list of the memory blocks...
        for(iItemIndex=0;iItemIndex < m_iNumMemBlocks;iItemIndex++)
        {
            LPMEMBLOCK lpMemBlock = m_lplpMemBlocks[iItemIndex];

            if (lpMemBlock->fInUse && (lpMemBlock->iHeapIndex == -1))
                DumpMemBlock(lpMemBlock, fileOutput);
        }
    }

    LeaveCriticalSection(&m_CriticalMemBlock);
    LeaveCriticalSection(&m_CriticalHeap);

    if (fileOutput)
        fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
    else
        OutputDebugString(rgOutput);

    if (fileOutput)
        fclose(fileOutput);
}

/*=========================================================================*/

LPVOID EXPORT CMemManager::AllocBufferGlb(
    DWORD dwBytesToAlloc,
#ifdef _DEBUG
    WORD wFlags,
    int iLine,
    LPSTR lpstrFile)
#else // !_DEBUG
    WORD wFlags)
#endif // !_DEBUG
{
    return g_CMemManager.AllocBuffer(
        dwBytesToAlloc,
#ifdef _DEBUG
        wFlags,
        iLine,
        lpstrFile);
#else // !_DEBUG
        wFlags);
#endif // !_DEBUG
}

/*=========================================================================*/

LPVOID EXPORT CMemManager::ReAllocBufferGlb(
    LPVOID lpBuffer,
    DWORD  dwBytesToAlloc,
#ifdef _DEBUG
    WORD   wFlags,
    int    iLine,
    LPSTR  lpstrFile)
#else // !_DEBUG
    WORD   wFlags)
#endif // !_DEBUG
{
    return g_CMemManager.ReAllocBuffer(
        lpBuffer,
        dwBytesToAlloc,
#ifdef _DEBUG
        wFlags,
        iLine,
        lpstrFile);
#else // !_DEBUG
        wFlags);
#endif // !_DEBUG
}

/*=========================================================================*/

VOID EXPORT CMemManager::FreeBufferGlb(LPVOID lpBuffer)
{
    g_CMemManager.FreeBuffer(lpBuffer);
}

/*=========================================================================*/

DWORD EXPORT CMemManager::SizeBufferGlb(LPVOID lpBuffer)
{
    return g_CMemManager.SizeBuffer(lpBuffer);
}

/*=========================================================================*/

BOOL EXPORT CMemManager::RegisterMemUserGlb(CMemUser *lpMemUser)
{
    return g_CMemManager.RegisterMemUser(lpMemUser);
}

/*=========================================================================*/

BOOL EXPORT CMemManager::UnRegisterMemUserGlb(CMemUser *lpMemUser)
{
    return g_CMemManager.UnRegisterMemUser(lpMemUser);
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpAllocationsGlb(LPSTR lpstrFilename)
{
    g_CMemManager.DumpAllocations(lpstrFilename);
}

/*=========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\mmx.cpp ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmx.h>

	// Define or undef the following to allow
	// HKCU\Software\Microsoft\Internet Explorer  "TestMMX"=DWORD
	// We logical AND this reg value with fIsMMX.
#define TEST_MMX

const  int  s_mmxvaruninit = 0xabcd;
static BOOL s_fIsMMX       = s_mmxvaruninit;

// ----------------------------------------------------------------------------------------

__declspec(dllexport)  BOOL    IsMMXCpu( void )
{

    if( s_mmxvaruninit == s_fIsMMX )
    {
		BOOL   fIsMMX = FALSE;

#if _M_IX86 >= 300  // INTEL TARGET
        __try               // THIS REQUIRES THE CRT
        {        
                // The 0x0fA2 opcode was a late addtion to the 486
                // Some 486 and all 386 chips will not have it.
                // Doubt it's emulated.  Execution on these chips will 
                // raise (and handle) EXCEPTION_ILLEGAL_INSTRUCTION.
		    #define _cpuid _emit 0x0f _asm _emit 0xa2
		    _asm {
			    mov eax,1
			    _cpuid
			    and edx, 00800000h
			    mov fIsMMX, edx
		    } // end asm
        }

        __except( EXCEPTION_EXECUTE_HANDLER )
        {            
            fIsMMX = FALSE;  // No 0x0fA2 opcode?  No MMX either!
        }
#endif // END _M_IX86 INTEL TARGET


#ifdef TEST_MMX
		HKEY  hkeyIE;
		if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER,
				   TEXT("Software\\Microsoft\\Internet Explorer"),
				   0u, KEY_READ, &hkeyIE ) )
		{
			DWORD  dwVal = TRUE;
			DWORD  dwType = REG_DWORD;
			DWORD  dwSize = sizeof(dwVal);

			if ( ERROR_SUCCESS == 
				 RegQueryValueEx( hkeyIE, 
								  TEXT("TestMMX"), 
								  NULL, 
								  &dwType, 
								  reinterpret_cast<BYTE*>(&dwVal),
								  &dwSize ) )
			{
				fIsMMX = fIsMMX && dwVal;
			}
		}
#endif // TEST_MMX

        s_fIsMMX = fIsMMX;
    }

    return s_fIsMMX;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\proputil.cpp ===
#include "utilpre.h"
#include "olectl.h"
#include "malloc.h"
#include "proputil.h"

// Note: cgeorges, 11/98
// To remove 64-bit warnings, I'm changing defn of WIDESTR() to always do an ANSI->UNICODE conversion.
// As of now, this code is never called, and since this is purely legacy code, it should be safe


//#define WIDESTR(x)        ((HIWORD((ULONG)(x)) != 0) ? strcpyWfromA((LPWSTR) _alloca((strlen(x)+1) * 2), (x)) : (LPWSTR)(x))
#define WIDESTR(x)        (strcpyWfromA((LPWSTR) _alloca((strlen(x)+1) * 2), (x)))

LPSTR strcpyAfromW(LPSTR dest, LPCOLESTR src);
LPWSTR strcpyWfromA(LPOLESTR dest, LPCSTR src);

// ansi <-> unicode conversion
LPSTR strcpyAfromW(LPSTR dest, LPCOLESTR src)
{
        UINT cch;

        if (NULL == src)
                src = OLESTR("");

        cch = WideCharToMultiByte(CP_ACP, 0, src, -1, dest, (wcslen(src)*2)+1, NULL, NULL);
        return dest;
}

LPWSTR strcpyWfromA(LPOLESTR dest, LPCSTR src)
{
        MultiByteToWideChar(CP_ACP, 0, src, -1, dest, (strlen(src)+1));
        return dest;
}

/////////////////////////////////////////////////////////////////////////////
// ReadBstrFromPropBag - Read a BSTR saved with WriteBstrToPropBag.

HRESULT ReadBstrFromPropBag(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, LPSTR pszName, OLECHAR ** pbstr)
{
        HRESULT hr;
        VARIANT var;
        LPWSTR pOleStr;

        Proclaim (pszName);

        // Convert Ansi to Ole string
        pOleStr = WIDESTR(pszName);

        if (!pOleStr)
        {
                DWORD dw = GetLastError();
                hr = dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
                goto Error;
        }

    memset(&var, 0, sizeof var);
        var.vt = VT_BSTR;
        hr = pPropBag->Read(pOleStr, &var, pErrorLog);
        if (FAILED(hr))
                goto Error;
        
        // Coerce the type if needed.
        if (var.vt != VT_BSTR)
        {
                hr = VariantChangeType(&var, &var, 0, VT_BSTR);
                if (FAILED(hr)) 
                        goto Error;
        }

        *pbstr = var.bstrVal;

        return NOERROR;

Error:
        if (pErrorLog)
        {
                EXCEPINFO excepinfo;

                memset(&excepinfo, 0, sizeof(EXCEPINFO));
                excepinfo.scode = hr;
                LPWSTR pErrStr = pOleStr;
                if (pErrStr)
                        pErrorLog->AddError(pErrStr, (EXCEPINFO *)&excepinfo);
        }

        return hr;
}


/////////////////////////////////////////////////////////////////////////////
// WriteBstrToPropBag - Write a BSTR to Property Bag.

HRESULT WriteBstrToPropBag(LPPROPERTYBAG pPropBag, LPSTR pszName, LPOLESTR bstrVal)
{
        HRESULT hr = NOERROR;
        VARIANT var;
        LPWSTR pOleStr;

        assert(NULL != pszName);

        if (NULL != bstrVal)
        {
                // Convert Ansi to Ole string
                pOleStr = WIDESTR(pszName);

                if (!pOleStr)
                {
                        DWORD dw = GetLastError();
                        hr = dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
                        return hr;
                }

            memset(&var, 0, sizeof var);
                var.vt = VT_BSTR;
                var.bstrVal = bstrVal;
                hr = pPropBag->Write(pOleStr, &var);
                assert(SUCCEEDED(hr));
        }

        return hr;
}

HRESULT WriteLongToPropBag(IPropertyBag* pPropBag, LPSTR pszName, LONG lValue)
{
        assert( pszName && pPropBag );
        if (!pszName || !pPropBag)
                return E_INVALIDARG;

        VARIANT var;
        memset(&var, 0, sizeof var);
        var.vt = VT_I4;
        var.lVal = lValue;
        return pPropBag->Write(WIDESTR(pszName), &var);
}

HRESULT ReadLongFromPropBag(IPropertyBag* pPropBag, LPERRORLOG pErrorLog, LPSTR pszName, LONG* plValue)
{
        HRESULT hr;
        assert( pszName && pPropBag && plValue);
        if (!pszName || !pPropBag || !plValue)
                return E_INVALIDARG;

        VARIANT var;
        memset(&var, 0, sizeof var);
        var.vt = VT_I4;
        LPOLESTR pOleStr = WIDESTR(pszName);
        hr = pPropBag->Read(pOleStr, &var, pErrorLog);
        if (FAILED(hr))
                goto Error;

        // Coerce the type if needed.
        if (var.vt != VT_I4)
        {
                hr = VariantChangeType(&var, &var, 0, VT_I4);
                if (FAILED(hr)) 
                        goto Error;
        }

        *plValue = var.lVal;
        return NOERROR;

Error:
        if (pErrorLog)
        {
                EXCEPINFO excepinfo;

                memset(&excepinfo, 0, sizeof(EXCEPINFO));
                excepinfo.scode = hr;
                LPWSTR pErrStr = pOleStr;
                if (pErrStr)
                        pErrorLog->AddError(pErrStr, (EXCEPINFO *)&excepinfo);
        }

        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\strconv.cpp ===
/***
*strtol.c - Contains Modified C runtimes strtol and strtoul
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       strtol - convert ascii string to long signed integer
*       strtoul - convert ascii string to long unsigned integer
*
*       These are modified to skip any "," occuring in the number
*
*******************************************************************************/

// #include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <strconv.h>

#ifdef LATER_ALIGATOR
#include <oleauto.h>
#endif


/***
*strtol, strtoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*               (a) First char = '0', second char = 'x' or 'X',
*                   use base 16.
*               (b) First char = '0', use base 8
*               (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then strtol/strtoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               strtol -- LONG_MAX or LONG_MIN
*               strtoul -- ULONG_MAX
*               strtol/strtoul -- errno == ERANGE
*
*       No digits or bad base return:
*               0
*               endptr = nptr*
*
*Exceptions:
*       None.
*******************************************************************************/



unsigned long EXPORT WINAPI CStrConv::StrToLX(
        const char *nptr,
        const char **endptr,
        int ibase,
        int flags
        ) 
{
        const char *p;
        char c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while ( isspace((int)(unsigned char)c) )
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != '0')
                        ibase = 10;
                else if (*p == 'x' || *p == 'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == '0' && (*p == 'x' || *p == 'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if(',' == c) {
                        if(flags & FL_READDIGIT) {
                            c = *p++; /* read next digit */
                            continue; /* skip ',' character if occurs after a digit */
                        } else {
                            break;
                        }
                }
                else if ( isdigit((int)(unsigned char)c) )
                        digval = c - '0';
                else if ( isalpha((int)(unsigned char)c) )
                        digval = toupper(c) - 'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                errno = ERANGE;
                if ( flags & FL_UNSIGNED )
                        number = ULONG_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned long)(-LONG_MIN);
                else
                        number = LONG_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        return number;                  /* done. */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\strwrap.cpp ===
#include "utilpre.h"
#include "string.h"
#include "utils.h"
#include "strwrap.h"
#include <minmax.h>

//#pragma optimize( "agt", on )
#pragma intrinsic( memcmp, memset, memcpy )


CStringWrapper::CStringWrapper (void)
{
}

CStringWrapper::~CStringWrapper (void)
{
}

LPTSTR 
CStringWrapper::Strcpy (LPTSTR szDest, LPCTSTR szSource)
{
	return _tcscpy(szDest, szSource);
}

LPTSTR 
CStringWrapper::Strncpy (LPTSTR szDest, LPCTSTR szSource, size_t nCount)
{
	return _tcsncpy(szDest, szSource, nCount);
}

LPTSTR 
CStringWrapper::Strcat (LPTSTR szDest, LPCTSTR szSource)
{
	return _tcscat(szDest, szSource);
}

wchar_t *
CStringWrapper::WStrcat (wchar_t *szDest, const wchar_t *szSource)
{
	return wcscat(szDest, szSource);
}

int 
CStringWrapper::WStrlen (const wchar_t *szSource)
{
	return wcslen(szSource);
}

wchar_t *
CStringWrapper::WStrcpy (wchar_t *szDest, const wchar_t *szSource)
{
	return wcscpy(szDest, szSource);
}

wchar_t *
CStringWrapper::WStrncpy (wchar_t *szDest, const wchar_t *szSource, size_t nSize)
{
	return wcsncpy(szDest, szSource, nSize);
}


	// A case-insensitive string comparison up to ct characters
	// required because CompareStringW() is stubbed on Win95.
EXPORT int  CStringWrapper::WStrCmpin( const wchar_t * sz1,
		                               const wchar_t * sz2,
									   size_t          ct )
{
	if( !sz1 || !sz2 )
	{
		return 0x0BADBAAD;
	}

	int       iRes = 0x0BADBAAD;
	wchar_t * p1 = NULL;
	wchar_t * p2 = NULL;
	size_t  size1 = lstrlenW(sz1);
	size_t  size2 = lstrlenW(sz2);
	size_t  size_least = min( min( size1, size2 ), ct );

	p1 = New wchar_t[ size_least + 1 ];
	p2 = New wchar_t[ size_least + 1 ];
	if( p1 && p2 )
	{
		wcsncpy( p1, sz1, size_least );
		wcsncpy( p2, sz2, size_least );
		p1[ size_least ] = L'\0';
		p2[ size_least ] = L'\0';
		iRes = _wcsicmp( p1, p2 );
	}
	Delete [] p1;
	Delete [] p2;

	return iRes;
}


	// A LoadStringW() substitute because
	// the real API is stubbed on Win95.
EXPORT int  CStringWrapper::LoadStringW(HINSTANCE hInst, 
										UINT uID, 
										wchar_t * szString, 
										int nMaxLen )
{
	int     iRes = 0;
	char *  pch = NULL;

	if( 0 >= nMaxLen )
	{
		SetLastError( ERROR_INVALID_DATA );
		return 0;
	}

	if( szString )
	{
		pch = New char[ nMaxLen ];
		if( !pch )
		{
			SetLastError( ERROR_OUTOFMEMORY );
			return 0;
		}
	}

	iRes = LoadStringA( hInst, uID, pch, nMaxLen );
	if( iRes && pch )
	{
		iRes = CStringWrapper::Mbstowcs( szString, pch, nMaxLen );
		if( iRes == nMaxLen )
		{
			szString[ nMaxLen - 1 ] = L'\0';
		}
	}

	Delete [] pch;
	return iRes;
}


int 
CStringWrapper::Iswspace (wint_t c)
{
	return iswspace(c);
}

int         
CStringWrapper::Strlen (LPCTSTR szSource)
{
	return _tcslen(szSource);
}

int         
CStringWrapper::Strcmp (LPCTSTR szLeft, LPCTSTR szRight)
{
	return _tcscmp(szLeft, szRight);
}

int         
CStringWrapper::Stricmp (LPCTSTR szLeft, LPCTSTR szRight)
{
	return _tcsicmp(szLeft, szRight);
}

int         
CStringWrapper::Strncmp (LPCTSTR szLeft, LPCTSTR szRight, size_t nSize)
{
	return _tcsncmp(szLeft, szRight, nSize);
}

int         
CStringWrapper::Strnicmp (LPCTSTR szLeft, LPCTSTR szRight, size_t nSize)
{
	return _tcsnicmp(szLeft, szRight, nSize);
}

LPTSTR 
CStringWrapper::Strchr (LPCTSTR szSource, TCHAR chSearch)
{
	return _tcschr(szSource, chSearch);
}

LPTSTR 
CStringWrapper::Strrchr (LPCTSTR szSource, TCHAR chSearch)
{
	return _tcsrchr(szSource, chSearch);
}

LPTSTR 
CStringWrapper::Strstr (LPCTSTR szOne, LPCTSTR szTwo)
{
	return _tcsstr(szOne, szTwo);
}

LPTSTR 
CStringWrapper::Strtok (LPTSTR szTarget, LPCTSTR szTokens)
{
	return _tcstok(szTarget, szTokens);
}

LPTSTR 
CStringWrapper::Strinc (LPCTSTR szTarget)
{
	return _tcsinc(szTarget);
}

int
CStringWrapper::Sscanf1 (LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1)
{
	return _stscanf(szSource, szFormat, pvParam1);
}

int
CStringWrapper::Sscanf2 (LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1, LPVOID pvParam2)
{
	return _stscanf(szSource, szFormat, pvParam1, pvParam2);
}

int
CStringWrapper::Sscanf3 (LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1, LPVOID pvParam2, LPVOID pvParam3)
{
	return _stscanf(szSource, szFormat, pvParam1, pvParam2, pvParam3);
}

/*
int         
CStringWrapper::Sscanf (LPCTSTR szSource, LPCTSTR szFormat, ... )
{
	va_list argList;
	va_start(argList, szFormat);
	int iRet = _stscanf(szSource, szFormat, argList);
	va_end(argList);
	return iRet;
}
*/

int         
CStringWrapper::Sprintf (LPTSTR szDest, LPCTSTR szFormat, ... )
{
	va_list argList;
	va_start(argList, szFormat);
	int iRet = _vstprintf(szDest, szFormat, argList);
	va_end(argList);
	return iRet;
}

long       
CStringWrapper::Atol (LPCTSTR szSource)
{
	return _ttol(szSource);
}

int         
CStringWrapper::Atoi (LPCTSTR szSource)
{
	return _ttoi(szSource);
}

LPTSTR 
CStringWrapper::Ltoa (long lSource, LPTSTR szDest, int iRadix)
{
	return _ltot(lSource, szDest, iRadix);
}

LPTSTR 
CStringWrapper::Itoa (int iSource, LPTSTR szDest, int iRadix)
{
	return _itot(iSource, szDest, iRadix);
}

LPTSTR 
CStringWrapper::Gcvt ( double dblValue, int iDigits, LPTSTR szBuffer )
{
	return _gcvt(dblValue, iDigits, szBuffer);
}

size_t 
CStringWrapper::Wcstombs ( char *mbstr, const wchar_t *wcstr, size_t count )
{
	return wcstombs ( mbstr, wcstr, count );
}

size_t 
CStringWrapper::Mbstowcs ( wchar_t *wcstr, const char *mbstr, size_t count )
{
	return mbstowcs (wcstr, mbstr, count);
}

int         
CStringWrapper::Memcmp (const void * pvLeft, const void * pvRight, size_t nSize)
{
	return memcmp(pvLeft, pvRight, nSize);
}

void *
CStringWrapper::Memset (void * pvLeft, int iValue, size_t nSize)
{
	return memset(pvLeft, iValue, nSize);
}

void *
CStringWrapper::Memcpy( void * pvDest, const void * pvSrc, size_t count )
{
	return memcpy(pvDest, pvSrc, count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\surface.cpp ===
/*
********************************************************************
*
*
*
*
*
*
*
********************************************************************
*/
#include <iHammer.h>
#include <strwrap.h>
#include <surface.h>


const DWORD  ALPHAMASK32 = 0xFF000000;
const DWORD  REDMASK24   = 0x00FF0000;
const DWORD  GRNMASK24   = 0x0000FF00;
const DWORD  BLUMASK24   = 0x000000FF;
const DWORD  REDMASK16   = 0x0000F800;
const DWORD  GRNMASK16   = 0x000007E0;
const DWORD  BLUMASK16   = 0x0000001F;
const DWORD  REDMASK15   = 0x00007C00;
const DWORD  GRNMASK15   = 0x000003E0;
const DWORD  BLUMASK15   = 0x0000001F;


static inline long CalcPitch( long width, long bitsperpixel )
{
        return ((((width * bitsperpixel)+31L)&(~31L)) >> 3);
}

static inline long CalcImageSize( int width, int height, int bitsperpixel )
{
        return height * CalcPitch( width, bitsperpixel );
}


// ---------------------------------------


EXPORT IHammer::CDirectDrawSurface::CDirectDrawSurface(
        HPALETTE hpal, 
        DWORD dwColorDepth, 
    const SIZE* psize, 
        HRESULT * phr )
{
        HDC hdc;
        HWND hwnd;
        PALETTEENTRY pe[256];
        int iCount;

                // For the GetDC(), ReleaseDC() stuff
        m_ctDCRefs      = 0;
        m_hdcMem        = NULL;
        m_hbmpDCOld = NULL;

        m_pvBits = NULL;
        m_cRef = 1;
        m_size = *psize;
        m_ptOrigin.x = (m_ptOrigin.y = 0);

        ZeroMemory(&m_bmi, sizeof(m_bmi));
        m_bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        m_bmi.bmiHeader.biWidth       = m_size.cx;
        m_bmi.bmiHeader.biHeight      = -m_size.cy;
        m_bmi.bmiHeader.biPlanes      = 1;
        m_bmi.bmiHeader.biCompression = BI_RGB;
        m_bmi.bmiColors[0].rgbRed =     m_bmi.bmiColors[0].rgbGreen = m_bmi.bmiColors[0].rgbBlue = 0;
        m_bmi.bmiColors[1].rgbRed =     m_bmi.bmiColors[1].rgbGreen = m_bmi.bmiColors[1].rgbBlue = 255;

    switch( dwColorDepth ) 
    {
        case 1:
            m_bmi.bmiHeader.biBitCount = 1;
            break;

        case 4:
            m_bmi.bmiHeader.biBitCount = 4;
                    m_bmi.bmiHeader.biClrUsed  = 2;
            break;

        case 8:
            {
                    m_bmi.bmiHeader.biBitCount = 8;
                    iCount = GetPaletteEntries(hpal, 0, 256, (PALETTEENTRY*)&pe);
                    for (int i = 0; i < iCount; i++)
                    {
                                // Review(normb): Do we want to copy rgbReserved?                               
                            m_bmi.bmiColors[i].rgbRed   = pe[i].peRed;
                            m_bmi.bmiColors[i].rgbGreen = pe[i].peGreen;
                            m_bmi.bmiColors[i].rgbBlue  = pe[i].peBlue;
                    }
            }
        break;

        case 15:                // 555 encoded 16-bit            
            m_bmi.bmiHeader.biBitCount = 16;
            break;
            
        case 16:                // 565 encoded 16-bit
            m_bmi.bmiHeader.biBitCount = 16;
            m_bmi.bmiHeader.biCompression = BI_BITFIELDS;                   
            {
                        LPDWORD pdw = (LPDWORD)&m_bmi.bmiColors[0];
                        pdw[0] = 0x0000F800;
                        pdw[1] = 0x000007E0;
                        pdw[2] = 0x0000001F;
            }
            break;

        case 24:
                m_bmi.bmiHeader.biBitCount = 24;
            break;

        case 32: 
            m_bmi.bmiHeader.biBitCount = 32;
            break;
        
        default:
            Proclaim( FALSE && "Bad color-depth" );
            break;
    }
    m_lBitCount = m_bmi.bmiHeader.biBitCount;

                // Review(normb): require the ctor to take a HDC
                // and make a compatible DIB from it.  
                // Who says desktop and Trident must be similar bitdepths?
    hwnd   = ::GetDesktopWindow();
    hdc    = ::GetDC(hwnd);
        m_hbmp = CreateDIBSection(hdc, (LPBITMAPINFO)&m_bmi, DIB_RGB_COLORS, &m_pvBits, NULL, NULL);
    ::ReleaseDC(hwnd, hdc);

        if (phr)
        {
                *phr = (m_hbmp) ? S_OK : E_FAIL;
        }

#ifdef _DEBUG
        m_ctLocks = 0;
#endif // _DEBUG

    // Don't try to clear a bitmap if it was never allocated!
    if (m_pvBits)
    {
            memset( m_pvBits, 0, 
                        CalcImageSize(m_size.cx, m_size.cy ,m_lBitCount) );
    }
}

IHammer::CDirectDrawSurface::~CDirectDrawSurface()
{
        if (m_hbmp)
        {
                DeleteObject(m_hbmp);
                m_hbmp = NULL;
        }
        
        Proclaim( 0 == m_ctLocks );

                // No one should have a dangling dc from our GetDC()
        Proclaim( 0 == m_ctDCRefs );
        while( m_hdcMem && 
                   SUCCEEDED(this->ReleaseDC(m_hdcMem)) )
        {
                NULL;
        }
}

HBITMAP IHammer::CDirectDrawSurface::GetBitmap( void )
{
    return m_hbmp;
}

void IHammer::CDirectDrawSurface::GetOrigin( int & left, int & top  ) const
{
        left = m_ptOrigin.x;
        top  = m_ptOrigin.y;
}


void IHammer::CDirectDrawSurface::SetOrigin( int left, int top  )
{
        m_ptOrigin.x = left;
        m_ptOrigin.y = top;
}


STDMETHODIMP IHammer::CDirectDrawSurface::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
        if (!ppvObj)
                return E_INVALIDARG;
        if (IsEqualGUID(riid, IID_IUnknown))
    {
        IDirectDrawSurface *   pThis = this;
                *ppvObj = (LPVOID) pThis;
    }
        else
        if (IsEqualGUID(riid, IID_IDirectDrawSurface))
    {
                IDirectDrawSurface * pThis = this;
        *ppvObj = (LPVOID) pThis;
    }
        else
                return E_NOINTERFACE;
        AddRef();
        return S_OK;
}

STDMETHODIMP_(ULONG) IHammer::CDirectDrawSurface::AddRef(THIS) 
{
        ULONG cRef = InterlockedIncrement((LPLONG)&m_cRef);
        return cRef;
}

STDMETHODIMP_(ULONG) IHammer::CDirectDrawSurface::Release(THIS)
{
        ULONG cRef = InterlockedDecrement((LPLONG)&m_cRef);

        if (0 == cRef)
                Delete this;
        return cRef;
}


STDMETHODIMP IHammer::CDirectDrawSurface::GetSurfaceDesc( DDSURFACEDESC * pddsDesc )
{
    if( !pddsDesc )
        return E_POINTER;

    pddsDesc->dwFlags = DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | 
                        DDSD_PIXELFORMAT;

    pddsDesc->dwHeight = (DWORD) m_size.cy;
    pddsDesc->dwWidth  = (DWORD) m_size.cx;
        pddsDesc->lPitch   = CalcPitch( m_size.cx, m_lBitCount );
    pddsDesc->ddpfPixelFormat.dwSize = sizeof(pddsDesc->ddpfPixelFormat);
    return GetPixelFormat( &pddsDesc->ddpfPixelFormat );
}


STDMETHODIMP IHammer::CDirectDrawSurface::GetPixelFormat( DDPIXELFORMAT * pddpixFormat )
{
    if( !pddpixFormat )
        return E_POINTER;
    //if( sizeof(DDPIXELFORMAT) != pddpixFormat->dwSize )
    //    return E_INVALIDARG;

    CStringWrapper::Memset( pddpixFormat, 0, sizeof(DDPIXELFORMAT) );
    pddpixFormat->dwSize = sizeof(DDPIXELFORMAT);

    pddpixFormat->dwFlags = DDPF_RGB;
    switch( m_lBitCount )
    {
                case 1:                 
                        pddpixFormat->dwFlags |= DDPF_PALETTEINDEXED1;
            pddpixFormat->dwRGBBitCount = DDBD_1;
                        break;

                case 4:
                        pddpixFormat->dwFlags |= DDPF_PALETTEINDEXED4;
            pddpixFormat->dwRGBBitCount = DDBD_4;
                        break;

        case 8:
            pddpixFormat->dwFlags |= DDPF_PALETTEINDEXED8;
            pddpixFormat->dwRGBBitCount = DDBD_8;
            break;

        case 16:
            pddpixFormat->dwRGBBitCount     = DDBD_16;
            pddpixFormat->dwRBitMask        = REDMASK16;
            pddpixFormat->dwGBitMask        = GRNMASK16;
            pddpixFormat->dwBBitMask        = BLUMASK16;
            break;

        case 24:            
            pddpixFormat->dwRGBBitCount     = DDBD_24;
            pddpixFormat->dwRBitMask        = REDMASK24;
            pddpixFormat->dwGBitMask        = GRNMASK24;
            pddpixFormat->dwBBitMask        = BLUMASK24;
            break;

        case 32:
            // DO NOT SET pddpixFormat->dwAlphaBitDepth   = DDBD_8
            pddpixFormat->dwFlags |= DDPF_ALPHAPIXELS;
            pddpixFormat->dwRGBBitCount     = DDBD_32;
            pddpixFormat->dwRGBAlphaBitMask = ALPHAMASK32;
            pddpixFormat->dwRBitMask        = REDMASK24;
            pddpixFormat->dwGBitMask        = GRNMASK24;
            pddpixFormat->dwBBitMask        = BLUMASK24;
            break;

                default:
                        Proclaim( FALSE && "bad color depth" );
                        break;
    }
    return S_OK;
}


STDMETHODIMP IHammer::CDirectDrawSurface::Lock(RECT *prcBounds, 
                                      DDSURFACEDESC *pddsDesc, 
                                      DWORD dwFlags, 
                                      HANDLE hEvent )
{
        HRESULT hr = E_FAIL;
        
        Proclaim( prcBounds && pddsDesc );
        if (!prcBounds || !pddsDesc )
                return E_POINTER;

    hr = GetSurfaceDesc( pddsDesc );
    if( FAILED(hr) )
        return hr;

        if (m_hbmp && m_pvBits )
        {
                RECT rectBounds = *prcBounds;
                int  dLeft;
                int  dTop;
                int  doffset;
                GetOrigin( dLeft, dTop );
                ::OffsetRect( &rectBounds, -dLeft, -dTop );

                doffset = (rectBounds.top * pddsDesc->lPitch) + 
                                  ((rectBounds.left * m_lBitCount)/8);

                        // Sanity checks...
                        // Don't lock anything outside our block.
                Proclaim( 0 <= doffset );
                //Proclaim( rectBounds.right  <= m_size.cx );
                //Proclaim( rectBounds.bottom <= m_size.cy );
                if( (0 > doffset) ||
                        (rectBounds.right  > m_size.cx) ||
                        (rectBounds.bottom > m_size.cy) )
                {
                        return E_FAIL;
                }

            pddsDesc->lpSurface  =
                    (void *)( ((LPBYTE) m_pvBits) + doffset );
                hr = S_OK;

#ifdef _DEBUG
                        // Yes, we do allow multiple locks on our surfaces.
                        // Probably contrary to IDirectDrawSurface spec.
                        // but (cowardly) done to replace IBitmapSurface
                        // rules exploited by IHammer Transition code!!!
                        // At least we require (for _DEBUG) identical regions.
                ++m_ctLocks;
                m_pvLocked = pddsDesc->lpSurface;
#endif // _DEBUG

        }
        return hr;
}


STDMETHODIMP  IHammer::CDirectDrawSurface::Unlock( void *pBits )
{
#ifdef _DEBUG
        Proclaim( pBits == m_pvLocked );
        if( 0 == --m_ctLocks )
        {
                m_pvLocked = NULL;
        }
#endif // _DEBUG

        return S_OK;
}


STDMETHODIMP  IHammer::CDirectDrawSurface::GetDC( HDC * phdc )
{  
        HRESULT  hr = S_OK;

        Proclaim( phdc );
        if( !phdc )
                return E_POINTER;

        if( !m_hdcMem )
        {
                HBITMAP  hBmp        = GetBitmap( );

                Proclaim( hBmp && "insane CDirectDrawSurface object" );
                hr = E_FAIL;   // Guilty 'til proven innocent...
                if( hBmp )
                {
                        HWND     hWndDesktop = ::GetDesktopWindow( );
                        HDC      hDCDesktop  = ::GetDC( hWndDesktop );
                        m_hdcMem = ::CreateCompatibleDC( hDCDesktop );

                        if( m_hdcMem )
                        {
                                m_hbmpDCOld = (HBITMAP)::SelectObject( m_hdcMem, hBmp );
                                if( m_hbmpDCOld )
                                {
                                        hr = S_OK;
                                }
                                else
                                {
                                        ::DeleteDC( m_hdcMem );
   
                                        m_hdcMem = NULL;
                                        hr = E_FAIL;
                                }
                        }
                        else
                        {
                                hr = E_OUTOFMEMORY;
                        }

                        if (hDCDesktop)
                            ::ReleaseDC(hWndDesktop, hDCDesktop);
                }
        }

        *phdc = m_hdcMem;

        if( SUCCEEDED(hr) )
        {
                ++m_ctDCRefs;
        }
        return hr;
}


STDMETHODIMP  IHammer::CDirectDrawSurface::ReleaseDC( HDC hDC )
{  
        HRESULT  hr = E_INVALIDARG;

        if( m_hdcMem && (hDC == m_hdcMem) )  // NULL==NULL still bad
        {
                hr = S_OK;
                if( !--m_ctDCRefs )
                {
                        if( GetBitmap() == 
                                ::SelectObject( hDC, m_hbmpDCOld ) )
                        {
                                ::DeleteDC( hDC );  // m_hdcMem created using CreateCompatibleDC, so can use DeleteDC
                                m_hdcMem = NULL;                                
                        }
                        else
                        {
                                Proclaim( FALSE && "Unexpected bitmap in DC" );
                                hr = E_FAIL;
                        }
                }               
        }
        
        return hr;
}



// Yeah yeah yeah...

STDMETHODIMP  IHammer::CDirectDrawSurface::AddAttachedSurface( LPDIRECTDRAWSURFACE)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::AddOverlayDirtyRect( LPRECT)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::Blt( LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::BltBatch( LPDDBLTBATCH, DWORD, DWORD )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::BltFast( DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::DeleteAttachedSurface( DWORD,LPDIRECTDRAWSURFACE)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::EnumAttachedSurfaces( LPVOID,LPDDENUMSURFACESCALLBACK)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::EnumOverlayZOrders( DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::Flip( LPDIRECTDRAWSURFACE, DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetAttachedSurface( LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetBltStatus( DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetCaps( LPDDSCAPS)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetClipper( LPDIRECTDRAWCLIPPER FAR*)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetColorKey( DWORD, LPDDCOLORKEY)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetFlipStatus( DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetOverlayPosition( LPLONG, LPLONG )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetPalette( LPDIRECTDRAWPALETTE * )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::Initialize( LPDIRECTDRAW, LPDDSURFACEDESC)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::IsLost( )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::Restore( )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::SetClipper( LPDIRECTDRAWCLIPPER)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::SetColorKey( DWORD, LPDDCOLORKEY)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::SetOverlayPosition( LONG, LONG )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::SetPalette( LPDIRECTDRAWPALETTE)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::UpdateOverlay( LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::UpdateOverlayDisplay( DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::UpdateOverlayZOrder( DWORD, LPDIRECTDRAWSURFACE)
{  return E_NOTIMPL; }


// ----------------------- Other utilities --------------


EXPORT long  BitCountFromDDPIXELFORMAT( const DDPIXELFORMAT & ddpf )
{       
        long lBitCount = -1L;

    switch( ddpf.dwRGBBitCount )
    {
        case DD_1BIT:
                case DDBD_1:
            lBitCount = 1;
            break;

        case DD_4BIT:
                case DDBD_4:
            lBitCount = 4;
            break;

        case DD_8BIT:
                case DDBD_8:
            lBitCount = 8;
            break;

        case DD_16BIT:
                case DDBD_16:
            if( GRNMASK15 == ddpf.dwGBitMask )
            {
                lBitCount = 15;
            }
            else
            {
                lBitCount = 16;
            }
            break;

        case DD_24BIT:
                case DDBD_24:
            lBitCount = 24;
            break;

        case DD_32BIT:
                case DDBD_32:
            lBitCount = 32;
            break;
                    
        default:
            Proclaim(FALSE && "unexpected color-depth");            
            break; 
    
    } // end switch

        return lBitCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\otrig.cpp ===
/*+********************************************************
MODULE: OTRIG.CPP
AUTHOR: PhaniV
DATE: Jan 97

DESCRIPTION: Implements OTrig class which implements table look for
for sin and cos functions which are calculated at increments of 0.1 degree.
*********************************************************-*/
#include <math.h>
#include "utilpre.h"
#include "otrig.h"
#include "quickie.h"

#define PI          3.1415927f
#define PIINDEG     180.0f
#define PI2INDEG    360.0f
#define PI2         (PI * 2.0f)
#define PI2INDEGINV (1.0f / PI2INDEG)
#define ANGLEENTRIES (10.0f)

float OTrig::s_rgfltSin[cSinCosEntries];
float OTrig::s_rgfltCos[cSinCosEntries];

BOOL OTrig::s_fCalculated = FALSE;

#pragma intrinsic (sin, cos)
#pragma optimize( "agt", on )

// Precalculate the sin and cos table for look up.
void OTrig::PreCalcRgSinCos(void)
{
    float fltAngle = 0.0f;
    float fltAngleInc = PI2/((float)(cSinCosEntries - 1));
    int   iSinCos = 0;

    if(s_fCalculated)
        return;

    while(fltAngle <= PI2)
    {
        s_rgfltSin[iSinCos] = (float)::sin((double)fltAngle);
        s_rgfltCos[iSinCos] = (float)::cos((double)fltAngle);
        fltAngle += fltAngleInc;
        iSinCos++;
    }

    // Now close the circle.
    s_rgfltSin[cSinCosEntries - 1] = s_rgfltSin[0];
    s_rgfltCos[cSinCosEntries - 1] = s_rgfltCos[0];
    s_fCalculated = TRUE;
}

EXPORT OTrig::OTrig(void)
{
    if(!s_fCalculated)
        PreCalcRgSinCos();
}

EXPORT float __fastcall OTrig::Sin(float fltAngle)
{    
    Proclaim( (fltAngle >= 0.0f) && (fltAngle <= 360.0f) );
    return s_rgfltSin[Float2Int(fltAngle * ANGLEENTRIES)];
}

EXPORT float __fastcall OTrig::Cos(float fltAngle)
{
    Proclaim( (fltAngle >= 0.0f) && (fltAngle <= 360.0f) );
    return s_rgfltCos[Float2Int(fltAngle * ANGLEENTRIES)];
}

EXPORT float  __fastcall OTrig::Sin(long lAngleOneTenths)
{
    Proclaim( (lAngleOneTenths >= 0) && (lAngleOneTenths <cSinCosEntries) );
    return s_rgfltSin[lAngleOneTenths];
}

EXPORT float  __fastcall OTrig::Cos(long lAngleOneTenths)
{
    Proclaim( (lAngleOneTenths >= 0) && (lAngleOneTenths <cSinCosEntries) );
    return  s_rgfltCos[lAngleOneTenths];
}

// ==================================================

EXPORT float __fastcall OTrig::SinWrap(float fltAngle)
{
    while(fltAngle < 0.0f)
        fltAngle += 360.0f;

    while(fltAngle > 360.0f)
        fltAngle -= 360.0f;

    return s_rgfltSin[Float2Int(fltAngle * ANGLEENTRIES)];
}

EXPORT float __fastcall OTrig::CosWrap(float fltAngle)
{
    while(fltAngle < 0.0f)
        fltAngle += 360.0f;

    while(fltAngle > 360.0f)
        fltAngle -= 360.0f;

    return s_rgfltCos[Float2Int(fltAngle * ANGLEENTRIES)];
}

EXPORT float  __fastcall OTrig::SinWrap(long lAngleOneTenths)
{
    lAngleOneTenths = lAngleOneTenths % (cSinCosEntries - 1);
    return s_rgfltSin[lAngleOneTenths];
}

EXPORT float  __fastcall OTrig::CosWrap(long lAngleOneTenths)
{
    lAngleOneTenths = lAngleOneTenths % (cSinCosEntries - 1);
    return  s_rgfltCos[lAngleOneTenths];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\urlarchv.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <minmax.h>

#include <urlarchv.h>

#define MAX_URL  2060

#ifndef ARRAYDIM
  #define ARRAYDIM(a)   (sizeof(a) / sizeof(a[0]))
#endif // ARRAYDIM

#ifndef LOOPFOREVER
  #define LOOPFOREVER  for(;;)
#endif // LOOPFOREVER


// --------------------------------


EXPORT CURLArchive::CURLArchive( IUnknown * pUnk ) :
    m_pStream(NULL), m_pUnk(pUnk)
{
    if (m_pUnk)
    	m_pUnk->AddRef();
}


    // These are private methods; 
    // no one, even CURLArchive, should be calling them
CURLArchive::CURLArchive( const CURLArchive & )
{ NULL; }


CURLArchive & CURLArchive::operator=( const CURLArchive & )
{ return *this; }


EXPORT CURLArchive::~CURLArchive()
{
    Close( );
    if( m_pUnk )
        m_pUnk->Release();
}


EXPORT HRESULT CURLArchive::Close( )
{    
    if( m_pStream )
    {
        m_pStream->Release( );
        m_pStream = NULL;
    }
    return S_OK;
}


        
EXPORT HRESULT CURLArchive::CopyLocal( LPSTR szLocalFile, int ctChars )
{
    return E_NOTIMPL;
}



EXPORT HRESULT CURLArchive::CopyLocal( LPWSTR szwLocalFile, int ctChars )
{
    return E_NOTIMPL;
}



EXPORT HRESULT CURLArchive::Create( LPCSTR szURL )
{
    HRESULT  hr = E_FAIL;

    if( m_pStream )
        return E_ACCESSDENIED;

    if( !szURL )
        return E_INVALIDARG;

    hr = URLOpenBlockingStreamA( m_pUnk,
        szURL,
        &m_pStream,
        0u,
        NULL );

    return hr;
}


EXPORT HRESULT CURLArchive::Create( LPCWSTR szwURL )
{
    HRESULT  hr = E_FAIL;

    if( m_pStream )
        return E_ACCESSDENIED;

    if( !szwURL )
        return E_INVALIDARG;

    hr = URLOpenBlockingStreamW( m_pUnk,
        szwURL,
        &m_pStream,
        0u,
        NULL );

    return hr;
}



EXPORT HRESULT    CURLArchive::GetFileSize( long & lSize )
{
    lSize = -1;
    if( m_pStream )
    {
        HRESULT  hr;
        STATSTG  statStg;

        hr = m_pStream->Stat( &statStg, STATFLAG_NONAME );
        if( SUCCEEDED(hr) )
        {
            if( 0u == statStg.cbSize.HighPart )
            {
                lSize = statStg.cbSize.LowPart;
            }
            else
            {
                lSize = -1;
            }            
        }
        return hr;
    }
    return E_ACCESSDENIED;    
}


EXPORT IStream * CURLArchive::GetStreamInterface( void ) const
{
    return m_pStream;
}


EXPORT DWORD     CURLArchive::Read( LPBYTE lpb,
                             DWORD ctBytes )
{
    DWORD  ctBytesRead = 0u;

    if( m_pStream )
    {
        HRESULT hr;

        hr = m_pStream->Read( lpb, ctBytes, &ctBytesRead );
        if( FAILED(hr) )
            ctBytesRead = 0u;    
    }
    return ctBytesRead;
}


EXPORT DWORD     CURLArchive::ReadLine( LPSTR lpstr,
                                        DWORD ctBytes )
{
    if( !m_pStream || (ctBytes < 1) || !lpstr )
        return 0u;

    DWORD   ctBytesRead      = 0u;
    LPSTR   lpstrXfer        = lpstr;
    DWORD   ctBytesRemaining = ctBytes - 1u;
    char    chTemp[ 512 + 1 ];
    
    lpstr[0] = '\0';
    ZeroMemory( chTemp, sizeof(chTemp) );
    LOOPFOREVER
    {
        HRESULT hr;
        DWORD   ctBytesToRead;
        DWORD   ctBytesJustRead;

        ctBytesToRead = (DWORD)min( (DWORD) ctBytesRemaining, 
                             sizeof(chTemp) - 1u );
        hr = m_pStream->Read( chTemp, 
                              ctBytesToRead,
                              &ctBytesJustRead );

        for( DWORD i=0u; i<ctBytesJustRead; ++i )
        {
                // Is there a CRLF in here?
            if( ('\r' == chTemp[i]) || ('\n' == chTemp[i]) )
            {
                LARGE_INTEGER  li;

                    // Skip past any other line-breaks
                while( (++i < ctBytesJustRead) && 
                       (('\r' == chTemp[i]) || ('\n' == chTemp[i])) )
                {
                    NULL;  // increment i in while eval
                }
                       
                    // Rewind stream to the next non-empty line
                if( i < ctBytesJustRead )
                {
                    li.HighPart = -1L;
                    li.LowPart  = (DWORD)((long) i - 
                                          (long) ctBytesJustRead);
                    m_pStream->Seek( li, current, NULL );
                }

                *lpstrXfer = '\0';
                return ctBytesRead;
            }

            *lpstrXfer++ = chTemp[i];
            --ctBytesRemaining;
            ++ctBytesRead;
        }

           // IStream docs say EOF may or may not return S_ hr
           // Review(normb): What does failed hr mean given this?           
        if( FAILED(hr) || 
            (ctBytesJustRead != ctBytesToRead) || 
            (ctBytesRemaining < 1) )
        {
            break;
        }
    }

    return ctBytesRead;
}


EXPORT DWORD     CURLArchive::ReadLine( LPWSTR lpstrw,
                                        DWORD  ctChars )
{
    return 0u;
}




EXPORT long CURLArchive::Seek( long ctBytes, origin orig )
{
    long  lNewPos = -1L;

    if( m_pStream )
    {
        ULARGE_INTEGER  uli;
        LARGE_INTEGER   li;
        HRESULT         hr = E_FAIL;

        li.LowPart = ctBytes;
        if( ctBytes < 0 )
            li.HighPart = -1L;

        hr = m_pStream->Seek( li, orig, &uli );
        if( FAILED(hr) || uli.HighPart )
            return -1L;

        lNewPos = (long) uli.LowPart;
    }
    return lNewPos;
}


EXPORT DWORD     CURLArchive::Write( LPBYTE lpb,
                              DWORD ctBytes )
{   
    DWORD  ctBytesWritten = 0u;

    if( m_pStream )
    {
        HRESULT hr;

        hr = m_pStream->Read( lpb, ctBytes, &ctBytesWritten );
        if( FAILED(hr) )
            ctBytesWritten = 0u;
    }
    return ctBytesWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\utilpre.h ===
// utilpre.h : Header files commonly included by util source code files.

#include <windows.h>
#include <windowsx.h>
#include <winuser.h>
#include <tchar.h>
#include <commctrl.h>
#include <limits.h>
#include <ihammer.h>
#include "objbase.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\daxctl\util\util.cpp ===
// Fossil file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\capphandler\apphandler.cpp ===
// AppHandler.cpp : Implementation of CAppHandler
#include "stdafx.h"
#include "cacheapp.h"
#include "AppHandler.h"

/////////////////////////////////////////////////////////////////////////////
// CAppHandler

CAppHandler::~CAppHandler()
{
    if(m_hUrlCacheStream)
    {
        BOOL f= UnlockUrlCacheEntryStream(m_hUrlCacheStream, 0);
        _ASSERTE(f);
    }
}


// IInternetProtocolRoot
HRESULT STDMETHODCALLTYPE CAppHandler::Start( 
    /* [in] */ LPCWSTR szUrl,
    /* [in] */ IInternetProtocolSink *pOIProtSink,
    /* [in] */ IInternetBindInfo *pOIBindInfo,
    /* [in] */ DWORD grfPI,
    /* [in] */ DWORD dwReserved)
{
    HRESULT hr = S_OK;

    DWORD dwcbIcei = sizeof(INTERNET_CACHE_ENTRY_INFO);
    
    for(;;)
    {
        INTERNET_CACHE_ENTRY_INFO *picei = (INTERNET_CACHE_ENTRY_INFO *)_alloca(dwcbIcei);

        _ASSERTE(m_hUrlCacheStream == 0);
        USES_CONVERSION;
        m_hUrlCacheStream = RetrieveUrlCacheEntryStream(
            W2T(szUrl),
            picei,
            &dwcbIcei,
            FALSE,              // not random but sequential access
            0);                 // reserved
        if(m_hUrlCacheStream)
        {
            m_byteOffset = 0;

            // do the "fake" download synchronously

            // DA and dshow do something different than mshtml that
            // causes urlmon to want the name of the cache file.
            hr = pOIProtSink->ReportProgress(
                BINDSTATUS_CACHEFILENAMEAVAILABLE,
                T2CW(picei->lpszLocalFileName));
            
            if(SUCCEEDED(hr))
            {
                // everything should be in the cache.
                hr = pOIProtSink->ReportData(
                    BSCF_FIRSTDATANOTIFICATION | BSCF_INTERMEDIATEDATANOTIFICATION | BSCF_LASTDATANOTIFICATION,
                    picei->dwSizeLow,
                    picei->dwSizeLow);

                if(SUCCEEDED(hr))
                {
                    hr = pOIProtSink->ReportResult(S_OK, 0, L"");
                }
            }
        }
        else
        {
            DWORD dw = GetLastError();
            if(dw == ERROR_INSUFFICIENT_BUFFER)
            {
                // dwcbIcei has the right size now.
                continue;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(dw);
            }
        }

        break;
    }
            
            
    return hr;
}

// Allows the pluggable protocol handler to continue processing data
// on the apartment thread. This method is called in response to a
// call to IInternetProtocolSink::Switch.
// 
HRESULT STDMETHODCALLTYPE CAppHandler::Continue( 
    /* [in] */ PROTOCOLDATA *pProtocolData)
{
    // I never call IInternetProtocolSink::Switch, so it will never call this?
    _ASSERTE(!"CAppHandler::Continue");    
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Abort( 
    /* [in] */ HRESULT hrReason,
    /* [in] */ DWORD dwOptions)
{
    // we're not actually doing anything asynchronously
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Terminate( 
    /* [in] */ DWORD dwOptions)
{
    // nothing to do
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Suspend( void)
{
    // docs say "not implemented"
    return E_NOTIMPL;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Resume( void)
{
    // docs say "not implemented"
    return E_NOTIMPL;
}

// IInternetProtocol
HRESULT STDMETHODCALLTYPE CAppHandler::Read( 
    /* [length_is][size_is][out][in] */ void *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG *pcbRead)
{
    _ASSERTE(m_hUrlCacheStream);
    HRESULT hr = S_OK;
    
    *pcbRead = cb;
    BOOL f = ReadUrlCacheEntryStream(
        m_hUrlCacheStream,
        m_byteOffset,
        pv,
        pcbRead,
        0);                     // reserved
    if(f)
    {
        m_byteOffset += *pcbRead;
        hr = (cb == *pcbRead ? S_OK : S_FALSE);
    }
    else
    {
        DWORD dw = GetLastError();
        hr = (dw == ERROR_HANDLE_EOF ? S_FALSE :  HRESULT_FROM_WIN32(dw));
    }
        
    return hr;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Seek( 
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER *plibNewPosition)
{
    // the protocol does not support seekable data retrieval. 
    return E_FAIL;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::LockRequest( 
    /* [in] */ DWORD dwOptions)
{
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::UnlockRequest( void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\capphandler\cacheapp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Feb 02 09:39:11 1998
 */
/* Compiler settings for cacheapp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cacheapp_h__
#define __cacheapp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAppHandler_FWD_DEFINED__
#define __IAppHandler_FWD_DEFINED__
typedef interface IAppHandler IAppHandler;
#endif 	/* __IAppHandler_FWD_DEFINED__ */


#ifndef __AppHandler_FWD_DEFINED__
#define __AppHandler_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppHandler AppHandler;
#else
typedef struct AppHandler AppHandler;
#endif /* __cplusplus */

#endif 	/* __AppHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IAppHandler_INTERFACE_DEFINED__
#define __IAppHandler_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAppHandler
 * at Mon Feb 02 09:39:11 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][helpstring][uuid] */ 



EXTERN_C const IID IID_IAppHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("A4181900-9A8E-11D1-ADF0-0000F8754B99")
    IAppHandler : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAppHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAppHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAppHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAppHandler __RPC_FAR * This);
        
        END_INTERFACE
    } IAppHandlerVtbl;

    interface IAppHandler
    {
        CONST_VTBL struct IAppHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAppHandler_INTERFACE_DEFINED__ */



#ifndef __CACHEAPPLib_LIBRARY_DEFINED__
#define __CACHEAPPLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: CACHEAPPLib
 * at Mon Feb 02 09:39:11 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_CACHEAPPLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_AppHandler;

class DECLSPEC_UUID("A4181901-9A8E-11D1-ADF0-0000F8754B99")
AppHandler;
#endif
#endif /* __CACHEAPPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\capphandler\cacheapp.cpp ===
// cacheapp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f cacheappps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "cacheapp.h"

#include "cacheapp_i.c"
#include "AppHandler.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_AppHandler, CAppHandler)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\capphandler\cacheapp_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Feb 02 09:39:11 1998
 */
/* Compiler settings for cacheapp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IAppHandler = {0xA4181900,0x9A8E,0x11D1,{0xAD,0xF0,0x00,0x00,0xF8,0x75,0x4B,0x99}};


const IID LIBID_CACHEAPPLib = {0xA41818F3,0x9A8E,0x11D1,{0xAD,0xF0,0x00,0x00,0xF8,0x75,0x4B,0x99}};


const CLSID CLSID_AppHandler = {0xA4181901,0x9A8E,0x11D1,{0xAD,0xF0,0x00,0x00,0xF8,0x75,0x4B,0x99}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\capphandler\apphandler.h ===
// AppHandler.h : Declaration of the CAppHandler

#ifndef __APPHANDLER_H_
#define __APPHANDLER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAppHandler
class ATL_NO_VTABLE CAppHandler : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAppHandler, &CLSID_AppHandler>,
	public IInternetProtocol
{

    // IInternetProtocolRoot
    HRESULT STDMETHODCALLTYPE Start( 
        /* [in] */ LPCWSTR szUrl,
        /* [in] */ IInternetProtocolSink *pOIProtSink,
        /* [in] */ IInternetBindInfo *pOIBindInfo,
        /* [in] */ DWORD grfPI,
        /* [in] */ DWORD dwReserved);
        
    HRESULT STDMETHODCALLTYPE Continue( 
        /* [in] */ PROTOCOLDATA *pProtocolData);
        
    HRESULT STDMETHODCALLTYPE Abort( 
        /* [in] */ HRESULT hrReason,
        /* [in] */ DWORD dwOptions);
        
    HRESULT STDMETHODCALLTYPE Terminate( 
        /* [in] */ DWORD dwOptions);
        
    HRESULT STDMETHODCALLTYPE Suspend( void);
        
    HRESULT STDMETHODCALLTYPE Resume( void);

    // IInternetProtocol
    HRESULT STDMETHODCALLTYPE Read( 
        /* [length_is][size_is][out][in] */ void *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG *pcbRead);
        
    HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
    HRESULT STDMETHODCALLTYPE LockRequest( 
        /* [in] */ DWORD dwOptions);
        
    HRESULT STDMETHODCALLTYPE UnlockRequest( void);

    //

    HANDLE m_hUrlCacheStream;
    ULONG m_byteOffset;
    
public:

    CAppHandler()
    {
        m_hUrlCacheStream = 0;
    }

    ~CAppHandler();

DECLARE_REGISTRY_RESOURCEID(IDR_APPHANDLER)

BEGIN_COM_MAP(CAppHandler)
	COM_INTERFACE_ENTRY(IInternetProtocol)
	COM_INTERFACE_ENTRY(IInternetProtocolRoot)
END_COM_MAP()

};

#endif //__APPHANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\capphandler\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cacheapp.rc
//
#define IDS_PROJNAME                    100
#define IDR_APPHANDLER                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\capphandler\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\capphandler\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( cacheapp )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( cacheapp ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\capphandler\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A41818F7_9A8E_11D1_ADF0_0000F8754B99__INCLUDED_)
#define AFX_STDAFX_H__A41818F7_9A8E_11D1_ADF0_0000F8754B99__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <urlmon.h>
#include <wininet.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A41818F7_9A8E_11D1_ADF0_0000F8754B99__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmauth\header.h ===
#include "source.h"
#include <stdio.h>

static const CLSID CLSID_ImageSrc = { /* 3437851e-9119-11d1-adea-0000f8754b99 */
    0x3437851e,
    0x9119,
    0x11d1,
    {0xad, 0xea, 0x00, 0x00, 0xf8, 0x75, 0x4b, 0x99}
  };

class CDiSrcStream : public CSourceStream
{
    HRESULT OnThreadCreate(void);
    HRESULT OnThreadDestroy(void);
    HRESULT FillBuffer(IMediaSample *pms);

    HRESULT DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * ppropInputRequest) ;
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);
    HRESULT GetMediaType(CMediaType *pMediaType);
    
    FILE *m_pFile;

public:

    CDiSrcStream(class CDiSrc *pParent, HRESULT *phr);
};

class CDiSrc : public CSource, IFileSourceFilter
{
    CDiSrc(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *mt);
    STDMETHODIMP GetCurFile(LPOLESTR * ppszFileName, AM_MEDIA_TYPE *mt);
    WCHAR m_wszFileName[MAX_PATH];

    CDiSrcStream m_outpin;

public:
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr) { return new CDiSrc(punk, phr); }

    friend class CDiSrcStream;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmauth\copyfile.cpp ===
#include <streams.h>

#undef _ATL_STATIC_REGISTRY
#include <atlbase.h>
#include <atlimpl.cpp>

#ifdef COPYFILE_EXE

#include <stdio.h>
#define CHECK_ERROR(x) if (FAILED(hr = (x))) { printf(#x": %08x\n", hr); goto Exit; }
bool g_fVerbose = false;

#else

#define CHECK_ERROR(x) if (FAILED(hr = (x))) { DbgLog((LOG_ERROR, 0, #x": %08x")); goto Exit; }

#endif

HRESULT SetNoClock(IFilterGraph *graph)
{
    // Keep a useless clock from being instantiated....
    IMediaFilter *graphF;
    HRESULT hr = graph->QueryInterface(IID_IMediaFilter, (void **) &graphF);

    if (SUCCEEDED(hr)) {
	hr = graphF->SetSyncSource(NULL);
	graphF->Release();
    }

    return hr;
}

HRESULT RenderOneOutputPin(ICaptureGraphBuilder *pBuilder, IBaseFilter *pMux, IPin *pPin);

HRESULT RenderAllOutputPins(ICaptureGraphBuilder *pBuilder, IBaseFilter *pMux, IBaseFilter *pFilter)
{
    IEnumPins *pep;
    HRESULT hr = pFilter->EnumPins(&pep);
    if(SUCCEEDED(hr))
    {
        IPin *rgppin[1];
        ULONG cFetched;
        while(pep->Next(1, rgppin, &cFetched) == S_OK)
        {
            PIN_DIRECTION dir;
            if(rgppin[0]->QueryDirection(&dir) == S_OK && dir == PINDIR_OUTPUT) {
                hr = RenderOneOutputPin(pBuilder, pMux, rgppin[0]);
            }
            rgppin[0]->Release();

            if(FAILED(hr)) {
                break;
            }
        }

        pep->Release();
    }

    return hr;
}

HRESULT RenderInputPin(ICaptureGraphBuilder *pBuilder, IBaseFilter *pMux, IPin *pPin)
{
    HRESULT hr = S_OK;

    CComPtr<IPin> rgpin[100];
    ULONG cSlots = NUMELMS(rgpin);
    hr = pPin->QueryInternalConnections((IPin **)rgpin, &cSlots);
    if(SUCCEEDED(hr))
    {
        for(ULONG iPin = 0; iPin < cSlots; iPin++) {
            hr = RenderOneOutputPin(pBuilder, pMux, rgpin[iPin]);
        }
    }
    else
    {
        PIN_INFO pi;
        hr = pPin->QueryPinInfo(&pi);
        if(SUCCEEDED(hr))
        {
            ASSERT(pi.dir == PINDIR_INPUT);
            hr = RenderAllOutputPins(pBuilder, pMux, pi.pFilter);
            pi.pFilter->Release();
        }
    }

    return hr;
}

HRESULT RenderOneOutputPin(ICaptureGraphBuilder *pBuilder, IBaseFilter *pMux, IPin *pPin)
{
    HRESULT hr = S_OK;
    
    IPin *pPinCon;
    hr = pPin->ConnectedTo(&pPinCon);
    if(SUCCEEDED(hr))
    {
        PIN_INFO pi;
        hr = pPinCon->QueryPinInfo(&pi);
        if(SUCCEEDED(hr))
        {
            ASSERT(pi.dir == PINDIR_INPUT);
            hr = RenderAllOutputPins(pBuilder, pMux, pi.pFilter);
            pi.pFilter->Release();
        }

        pPinCon->Release();
    }
    else                // not connected
    {
        hr = pBuilder->RenderStream(0, pPin, 0, pMux);
        // if(hr == VFW_S_PARTIAL_RENDER)
        if(SUCCEEDED(hr))
        {
            hr = pPin->ConnectedTo(&pPinCon);
            if(SUCCEEDED(hr))
            {
                hr = RenderInputPin(pBuilder, pMux, pPinCon);
                pPinCon->Release();
            }
        }
    }

    return hr;
}

#define DllExport   __declspec( dllexport )
DllExport STDAPI LmrtCopyfile(
    LPCWSTR szOutputFile,
    const CLSID *pmtFile,
    ULONG cbps,                 // zero to pick a default
    UINT cInputs,
    LPCWSTR *rgSzInputs,
    ULONG *pmsPreroll);

STDAPI LmrtCopyfile(
    LPCWSTR szOutputFile,
    const CLSID *pmtFile,
    ULONG cbps,                 // zero to pick a default
    UINT cInputs,
    LPCWSTR *rgSzInputs,
    ULONG *pmsPreroll)
{
    HRESULT hr = S_OK;
    USES_CONVERSION;

    CComPtr <ICaptureGraphBuilder> pBuilder;
    CComPtr <IFileSinkFilter> pFileSinkWriter;
    CComPtr <IBaseFilter> pMuxFilter;
    CComPtr <IGraphBuilder> pGraph;
    CComQIPtr <IMediaControl, &IID_IMediaControl> pGraphC;
    CComQIPtr <IMediaEvent, &IID_IMediaEvent> pEvent;
    CComQIPtr<IConfigInterleaving, &IID_IConfigInterleaving> pInterleaving;
    CComQIPtr<IConfigAviMux, &IID_IConfigAviMux> pCfgMux;
    CComQIPtr<IFileSinkFilter2, &IID_IFileSinkFilter2> pCfgFw;


    CHECK_ERROR(CoCreateInstance(CLSID_CaptureGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                                 IID_ICaptureGraphBuilder, (void **)&pBuilder));

    CHECK_ERROR(pBuilder->SetOutputFileName(
        pmtFile,
        szOutputFile,
        &pMuxFilter, &pFileSinkWriter));

    CHECK_ERROR(pBuilder->GetFiltergraph(&pGraph));

    if(cbps != 0)
    {
        CComQIPtr<IConfigAsfMux, &IID_IConfigAsfMux> pcfgasf(pMuxFilter);
        if(pcfgasf)
        {
            CHECK_ERROR(pcfgasf->SetPeakBitRate(cbps));
        }
        else
        {
#ifdef COPYFILE_EXE
            fprintf(stderr, "bitrate not supported\n");
#endif
        }
    }

    pInterleaving = pMuxFilter;// auto QI
    if(pInterleaving)
    {
        // set interleaving mode to FULL (should this be a command
        // line option?)
        CHECK_ERROR(pInterleaving->put_Mode(INTERLEAVE_FULL));
    }
        
    pCfgMux = pMuxFilter;   // auto qi
    if(pCfgMux) {
        // waste less space. The Compatiblity Index is for VFW
        // playback support. We only care about DShow
        CHECK_ERROR(pCfgMux->SetOutputCompatibilityIndex(FALSE));
    }

        
    // create new files each time
    pCfgFw = pFileSinkWriter; // auto qi
    if(pCfgFw) {
        CHECK_ERROR(pCfgFw->SetMode(AM_FILE_OVERWRITE));
    }
    
    
    CHECK_ERROR(SetNoClock(pGraph));

    {
        for(UINT i = 0; i < cInputs; i++)
        {
            CComPtr<IBaseFilter> pSrcFilter;
            
            CHECK_ERROR(pGraph->AddSourceFilter(rgSzInputs[i], rgSzInputs[i], &pSrcFilter));

            // Just calling RenderStream will connect just one stream
            // if source file has multiple streams, so we traverse the
            // graph looking for unconnected output pins. Note some
            // source filters may have more than one output pin.
            hr = RenderAllOutputPins(pBuilder, pMuxFilter, pSrcFilter);

#ifdef COPYFILE_EXE
            printf("Rendering  %S : %08x\n", rgSzInputs[i], hr);
#endif
        }
    }

    pGraphC = pGraph;           // auto qi

        // auto QI for IMediaEvent. Do this before we run or else we
        // may lose some events (graph discards events if nobody can
        // collect them.
    pEvent = pGraph;
    
    CHECK_ERROR(pGraphC->Run());

#ifdef COPYFILE_EXE
    printf("Waiting for completion....\n");
#endif
    LONG lEvCode, lParam1, lParam2;
    for(;;)
    {
        CHECK_ERROR(pEvent->GetEvent(&lEvCode, &lParam1, &lParam2, INFINITE));
        CHECK_ERROR(pEvent->FreeEventParams(lEvCode, lParam1, lParam2));

        if(lEvCode == EC_COMPLETE ||
           lEvCode == EC_USERABORT ||
           lEvCode == EC_ERRORABORT ||
           lEvCode == EC_STREAM_ERROR_STOPPED)
        {
            if(lEvCode != EC_COMPLETE) {
#ifdef COPYFILE_EXE
                printf("failed  hr = %x\n", lParam1);
#endif
            }
            break;
        }
    }
        

#ifdef COPYFILE_EXE
    if (g_fVerbose) {
        printf("Done, event = %x  hr = %x\n", lEvCode, lParam1);
    }
#endif
    
    if(FAILED(lParam1)) {
        hr = lParam1;
    }

    // auto release everything

Exit:
    return hr;

}

#ifdef COPYFILE_EXE

int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    BOOL fVerbose = FALSE, fAsf = FALSE;;
    USES_CONVERSION;
    HRESULT hr = S_OK;

    ULONG cbps = 0;
    char *szOut = 0;

    int i = 1;
    while (i < argc && (argv[i][0] == '-' || argv[i][0] == '/'))
    {
	// options

        if (lstrcmpi(argv[i] + 1, "v") == 0) {
            fVerbose = TRUE;
        }
        else if (lstrcmpi(argv[i] + 1, "asf") == 0) {
            fAsf = TRUE;
        }
        else if(i + 1 < argc && lstrcmpi(argv[i] + 1, "bps") == 0) {
            cbps = atoi(argv[++i]);
        }
        else if(i + 1 < argc && lstrcmpi(argv[i] + 1, "o") == 0) {
            szOut = argv[++i];
        }
        else {
            fprintf(stderr, "Unrecognised switch %s\n", argv[i]);
        }

	i++;
    }
    
    UINT cFiles = argc - i;
    if (cFiles < 1 || !szOut) {
        printf("usage: copyfile [/v] [/asf] [/bps n] /o target file1 [ file2 ...] \n");
        return -1;
    }

    CoInitialize(NULL);

    const WCHAR **rgszIn = (const WCHAR **)_alloca(sizeof(WCHAR *) * cFiles);
    
    for(UINT iFile = 0; iFile < cFiles; iFile++) {
        rgszIn[iFile] = A2CW(argv[i + iFile]);
    }

    ULONG msPreroll;
    hr = LmrtCopyfile(
        A2CW(szOut),
        fAsf ? &MEDIASUBTYPE_Asf : &MEDIASUBTYPE_Avi,
        cbps,
        cFiles,
        rgszIn,
        &msPreroll);

    printf("all done %08x. preroll = %d ms.\n", hr, msPreroll);
    if(SUCCEEDED(hr))
    {
        CoUninitialize();
        return 0;
    }

Exit:

    CoUninitialize();
    return -1;
}

#endif // COPYFILE_EXE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmauth\parse.x.cpp ===
#include <streams.h>
#include "simpread.h"
#include "header.h"

// {689C8D50-70CA-11d1-ADE4-0000F8754B99}
static const GUID CLSID_DotXParser = 
{ 0x689c8d50, 0x70ca, 0x11d1, { 0xad, 0xe4, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99 } };

// this is a FourCC Guid - FOURCCMap(FCC('DOTX')). but it doesn't need
// to be a 4cc guid
// {58544f44-0000-0010-8000-00AA00389B71}
static const GUID CLSID_DotXStream = 
{ 0x58544f44, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71} };

struct SizeWidthHeight
{
    DWORD dwcbMax;
    DWORD dwWidth;
    DWORD dwHeight;
};


// space for the max sample size up front.
#define INITIAL_OFFSET sizeof(SizeWidthHeight) + sizeof(GUID)


AMOVIESETUP_MEDIATYPE sudDOTXInPinTypes =   {
  &MEDIATYPE_Stream,            // clsMajorType
  &CLSID_DotXStream };          // clsMinorType

AMOVIESETUP_MEDIATYPE sudDOTXOutPinTypes =   {
  &MEDIATYPE_LMRT,              // clsMajorType
  &GUID_NULL };                 // clsMinorType



AMOVIESETUP_PIN psudDOTXPins[] =
{
  { L"Input"                    // strName
    , FALSE                     // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , L""                       // strConnectsToPin
    , 1                         // nTypes
    , &sudDOTXInPinTypes        // lpTypes
  }
  ,
  { L"Output"                   // strName
    , FALSE                     // bRendered
    , TRUE                      // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , L""                       // strConnectsToPin
    , 1                         // nTypes
    , &sudDOTXOutPinTypes       // lpTypes
  }
};


const AMOVIESETUP_FILTER sudDOTX =
{
  &CLSID_DotXParser             // clsID
  , L".X parser"                // strName
  , MERIT_NORMAL                // dwMerit
  , NUMELMS(psudDOTXPins)       // nPins
  , psudDOTXPins                // lpPin
};

STDAPI DllRegisterServer()
{
    // register what files should go with my media types
    HKEY hk;
    LONG lRsult = RegCreateKeyEx(
        HKEY_CLASSES_ROOT,
        TEXT("Media Type\\{e436eb83-524f-11ce-9f53-0020af0ba770}\\{58544f44-0000-0010-8000-00AA00389B71}"),
        0,                      // reserved
        0,                      // class string
        0,                      // options
        KEY_WRITE,
        0,                      // security,
        &hk,
        0);                     // disposition
    if(lRsult == ERROR_SUCCESS)
    {
        if(lRsult == ERROR_SUCCESS) {
            static const char szval[] = "0,16,,444f545800001000800000aa00389b71";
            lRsult = RegSetValueExA(hk, "0", 0, REG_SZ, (BYTE *)szval, sizeof(szval));
        }
        if(lRsult == ERROR_SUCCESS) {
            static const char szval[] = "{E436EBB5-524F-11CE-9F53-0020AF0BA770}";
            lRsult = RegSetValueExA(hk, "Source Filter", 0, REG_SZ, (BYTE *)szval, NUMELMS(szval));
        }

        EXECUTE_ASSERT(RegCloseKey(hk) == ERROR_SUCCESS);
    }
    if(lRsult == ERROR_SUCCESS)
    {
        lRsult = RegCreateKeyEx(
            HKEY_CLASSES_ROOT,
            TEXT("Media Type\\Extensions\\.urls"),
            0,                      // reserved
            0,                      // class string
            0,                      // options
            KEY_WRITE,
            0,                      // security,
            &hk,
            0);                     // disposition
        if(lRsult == ERROR_SUCCESS)
        {
            if(lRsult == ERROR_SUCCESS) {
                static const char szval[] = "{3437851e-9119-11d1-adea-0000f8754b99}";
                lRsult = RegSetValueExA(hk, "Source Filter", 0, REG_SZ, (BYTE *)szval, sizeof(szval));
            }

            EXECUTE_ASSERT(RegCloseKey(hk) == ERROR_SUCCESS);
        }
    }
    if(lRsult == ERROR_SUCCESS)
    {
        return AMovieDllRegisterServer2(TRUE);
    } else
    {
        return HRESULT_FROM_WIN32(lRsult);
    }
}

STDAPI DllUnregisterServer()
{
    LONG lResult = RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\{e436eb83-524f-11ce-9f53-0020af0ba770}\\{58544f44-0000-0010-8000-00AA00389B71}"));
    ASSERT(lResult == ERROR_SUCCESS || lResult == ERROR_FILE_NOT_FOUND);
    lResult = RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\Extensions\\.urls"));
    ASSERT(lResult == ERROR_SUCCESS || lResult == ERROR_FILE_NOT_FOUND);
    return AMovieDllRegisterServer2(FALSE);
}



class CParseDotX : public CSimpleReader
{
    CCritSec m_cs;

    DWORD m_dwMaxSampleSize;
    LONG m_lLastTimeStamp;
    DWORDLONG m_qwLastFileOffsetRead;
    DWORDLONG m_qwInitOffset;
    LONGLONG m_llFileLength;

    HRESULT ReadOneBlock(BYTE *pb, ULONG *pcb, LONG &lStart);


public:
    CParseDotX(LPUNKNOWN punk, HRESULT *phr);
    ~CParseDotX() {; }

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    // pure CSimpleReader overrides
    HRESULT ParseNewFile();
    HRESULT CheckMediaType(const CMediaType* mtIn);
    LONG StartFrom(LONG sStart) ;
    HRESULT FillBuffer(IMediaSample *pSample, LONG &lStart, DWORD *pcSamples);
    LONG RefTimeToSample(CRefTime t) { return t.Millisecs(); }
    CRefTime SampleToRefTime(LONG s) { return CRefTime(s); } // ms to 100ns
    ULONG GetMaxSampleSize() { return m_dwMaxSampleSize; }
};

static const AMOVIESETUP_FILTER sudDiSrc =
{
    &CLSID_ImageSrc,              // clsID
    L"Data Image Source",         // strName
    MERIT_DO_NOT_USE,             // dwMerit
    0,                            // nPins
    0                             // lpPin
};

CFactoryTemplate g_Templates[]= {
  {L"DOTX Parser",        &CLSID_DotXParser, CParseDotX::CreateInstance, NULL,  &sudDOTX},
  {L"Data Image Source" , &CLSID_ImageSrc ,  CDiSrc::CreateInstance ,    NULL , &sudDiSrc}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);;

CUnknown *CParseDotX::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CParseDotX *ppdx = 0;
    if(SUCCEEDED(*phr))
    {
        ppdx = new CParseDotX(lpunk, phr);
        if(ppdx == 0) {
            *phr = E_OUTOFMEMORY;
        }

        // ignore error
    }

    return ppdx;
}

CParseDotX::CParseDotX(LPUNKNOWN punk, HRESULT *phr) :
        CSimpleReader(NAME(".X parser"), punk, CLSID_DotXParser, &m_cs, phr),
        m_qwInitOffset(INITIAL_OFFSET)
{
};

HRESULT CParseDotX::CheckMediaType(const CMediaType *pmtIn)
{
    if(pmtIn->majortype == MEDIATYPE_Stream && pmtIn->subtype == CLSID_DotXStream)
        return S_OK;
    else
        return S_FALSE;
}


HRESULT CParseDotX::ReadOneBlock(BYTE *pb, ULONG *pcb, LONG &lStart)
{
#include <pshpack4.h>
    struct Dw2
    {
        double dt;         // milliseconds
        DWORD dwcb;         // byte count
    } dw2;
#include <poppack.h>

    HRESULT hr = S_OK;
    for(;;)
    {
        hr = m_pAsyncReader->SyncRead(m_qwLastFileOffsetRead, sizeof(Dw2), (BYTE *)&dw2);
        if(hr == S_OK)
        {
            m_lLastTimeStamp = dw2.dt * 1000;

            if(dw2.dwcb <= m_dwMaxSampleSize)
            {
                if(m_lLastTimeStamp >= lStart)
                {
                    hr = m_pAsyncReader->SyncRead(m_qwLastFileOffsetRead + sizeof(Dw2), dw2.dwcb, pb);
                    if(SUCCEEDED(hr))
                    {
                        m_qwLastFileOffsetRead += sizeof(Dw2) + dw2.dwcb;
                        lStart = dw2.dt * 1000;

                        if((LONGLONG)m_qwLastFileOffsetRead < m_llFileLength)
                        {
                        }
                        else
                        {
                            m_Output.SetStopAt(0, MAX_TIME);
                        }

                        *pcb = dw2.dwcb;
                    } 
                    break;
                }
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("sample in file larger than promised.")));
                hr = VFW_E_INVALID_FILE_FORMAT;
            }

            m_qwLastFileOffsetRead += sizeof(Dw2) + dw2.dwcb;
        }
        else 
        {
            // S_FALSE or an error

            // base class ignores S_FALSE so make it an error
            if(SUCCEEDED(hr)) {
                hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
            }
            break;
        }


        if(FAILED(hr)) {
            break;
        }
    }

    return hr;
}

HRESULT CParseDotX::ParseNewFile()
{
    m_lLastTimeStamp = 0;
    m_sLength = 3600 * 1000 * 10; // 10 hours

    LONGLONG llAvailable;
    
    HRESULT hr = m_pAsyncReader->Length(&m_llFileLength, &llAvailable);
    if(SUCCEEDED(hr))
    {
        SizeWidthHeight swh;
        
        hr = m_pAsyncReader->SyncRead(sizeof(GUID), sizeof(swh), (BYTE *)&swh);
        if(hr == S_OK)
        {
            m_dwMaxSampleSize = swh.dwcbMax;
            
            m_qwLastFileOffsetRead = INITIAL_OFFSET;

            CMediaType mt;
            mt.SetType(&MEDIATYPE_LMRT);
            mt.SetFormatType(&CLSID_DotXStream);
            mt.SetFormat((BYTE *)&swh, sizeof(swh));

            BYTE *pb = new BYTE[m_dwMaxSampleSize];
            if(pb)
            {
                DWORDLONG dwlOldPos = m_qwLastFileOffsetRead;
                LONG lStart = -1000;
                ULONG cb;
                HRESULT hr = ReadOneBlock(pb, &cb, lStart);
                if(SUCCEEDED(hr) && lStart == -1000)
                {
                    ASSERT(cb <= m_dwMaxSampleSize);
                    mt.ReallocFormatBuffer(sizeof(swh) + cb);
                    CopyMemory(mt.pbFormat + sizeof(swh), pb, cb);
                    m_qwInitOffset = m_qwLastFileOffsetRead;
                }
                else
                {
                    m_qwLastFileOffsetRead = dwlOldPos;
                }
                mt.SetVariableSize();
                mt.SetTemporalCompression(FALSE);
                hr =  SetOutputMediaType(&mt);
                
                delete[] pb;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            
        }
        else
        {
            hr = VFW_E_INVALID_FILE_FORMAT;
        }
    } 

    return hr;
}

HRESULT CParseDotX::FillBuffer(IMediaSample *pSample, LONG &lStart, DWORD *pcSamples)
{
    BYTE *pb;
    ULONG cb;
    pSample->GetPointer(&pb);
    HRESULT hr = ReadOneBlock(pb, &cb, lStart);
    pSample->SetActualDataLength(cb);
    *pcSamples = 100;
    return hr;
}

LONG CParseDotX::StartFrom(LONG sStart)
{
    // start from the beginning.
    { m_qwLastFileOffsetRead = m_qwInitOffset; return sStart; };
}


extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);
BOOL WINAPI DllMain(  HINSTANCE hinstDLL,  // handle to DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmauth\simpread.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved


// Simple parser filter
//
// Positional information is supported by the pins, which expose IMediaPosition.
// upstream pins will use this to tell us the start/stop position and rate to
// use
//

#include <streams.h>
#include "simpread.h"

// ok to use this as it is not dereferenced
#pragma warning(disable:4355)


/* Implements the CSimpleReader public member functions */


// constructors etc
CSimpleReader::CSimpleReader(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    REFCLSID refclsid,
    CCritSec *pLock,
    HRESULT *phr)
    : m_pLock(pLock),
      CBaseFilter(pName, pUnk, pLock, refclsid),
      m_Input(this, pLock, phr, L"Reader"),
      m_Output(NAME("Output pin"), phr, this, pLock, L"Out"),
      m_pAsyncReader(NULL)
{
}

CSimpleReader::~CSimpleReader()
{
}


// pin enumerator calls this
int CSimpleReader::GetPinCount() {
    // only expose output pin if we have a reader.
    return m_pAsyncReader ? 2 : 1;
};

// return a non-addrefed pointer to the CBasePin.
CBasePin *
CSimpleReader::GetPin(int n)
{
    if (n == 0)
	return &m_Input;

    if (n == 1)
	return &m_Output;
    
    return NULL;
}

HRESULT CSimpleReader::NotifyInputConnected(IAsyncReader *pAsyncReader)
{
    // these are reset when disconnected
    ASSERT(m_pAsyncReader == 0);

    // m_iStreamSeekingIfExposed = -1;

    // fail if any output pins are connected.
    if (m_Output.GetConnected()) {
	// !!! can't find a good error.
	return VFW_E_FILTER_ACTIVE;
    }

    // done here because CreateOutputPins uses m_pAsyncReader
    m_pAsyncReader = pAsyncReader;
    pAsyncReader->AddRef();

    HRESULT hr = ParseNewFile();

    if (FAILED(hr)) {
	m_pAsyncReader->Release();
	m_pAsyncReader = 0;
	return hr;
    }

    // set duration and length of stream
    m_Output.SetDuration(m_sLength, SampleToRefTime(m_sLength));
    
     // !!! anything else to set up here?
    
    return hr;
}

HRESULT CSimpleReader::NotifyInputDisconnected()
{
    if (m_pAsyncReader) {
	m_pAsyncReader->Release();
	m_pAsyncReader = 0;
    }

    // !!! disconnect output???

    return S_OK;
}


HRESULT CSimpleReader::SetOutputMediaType(const CMediaType* mtOut)
{
    m_Output.SetMediaType(mtOut);

    return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CReaderInPin::CReaderInPin(CSimpleReader *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   LPCWSTR pPinName) :
   CBasePin(NAME("in pin"), pFilter, pLock, phr, pPinName, PINDIR_INPUT)
{
    m_pFilter = pFilter;
}

CReaderInPin::~CReaderInPin()
{
}

HRESULT CReaderInPin::CheckMediaType(const CMediaType *mtOut)
{
    return m_pFilter->CheckMediaType(mtOut);
}

HRESULT CReaderInPin::CheckConnect(IPin * pPin)
{
    HRESULT hr;

    hr = CBasePin::CheckConnect(pPin);
    if (FAILED(hr))
	return hr;

    IAsyncReader *pAsyncReader = 0;
    hr = pPin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
    if(SUCCEEDED(hr))
	pAsyncReader->Release();

    // E_NOINTERFACE is a reasonable error
    return hr;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CReaderInPin::CompleteConnect(
  IPin *pReceivePin)
{
    HRESULT hr = CBasePin::CompleteConnect(pReceivePin);
    if(FAILED(hr))
	return hr;

    IAsyncReader *pAsyncReader = 0;
    hr = pReceivePin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
    if(FAILED(hr))
	return hr;

    hr = m_pFilter->NotifyInputConnected(pAsyncReader);
    pAsyncReader->Release();

    return hr;
}

HRESULT CReaderInPin::BreakConnect()
{
    HRESULT hr = CBasePin::BreakConnect();
    if(FAILED(hr))
	return hr;

    return m_pFilter->NotifyInputDisconnected();
}

/* Implements the CReaderStream class */


CReaderStream::CReaderStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CSimpleReader * pFilter,
    CCritSec *pLock,
    LPCWSTR wszPinName)
    : CBaseOutputPin(pObjectName, pFilter, pLock, phr, wszPinName)
    , CSourceSeeking(NAME("source position"), (IPin*) this, phr, &m_WorkerLock)
    , m_pFilter(pFilter)
{
}

CReaderStream::~CReaderStream()
{
}

STDMETHODIMP
CReaderStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IMediaSeeking) {
	return GetInterface((IMediaSeeking *) this, ppv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


// IPin interfaces


// return default media type & format
HRESULT
CReaderStream::GetMediaType(int iPosition, CMediaType* pt)
{
    // check it is the single type they want
    if (iPosition<0) {
	return E_INVALIDARG;
    }
    if (iPosition>0) {
	return VFW_S_NO_MORE_ITEMS;
    }

    CopyMediaType(pt, &m_mt);

    return S_OK;
}

// check if the pin can support this specific proposed type&format
HRESULT
CReaderStream::CheckMediaType(const CMediaType* pt)
{
    // we support exactly the type specified in the file header, and
    // no other.

    if (m_mt == *pt) {
	return NOERROR;
    } else {
	return E_INVALIDARG;
    }
}

HRESULT
CReaderStream::DecideBufferSize(IMemAllocator * pAllocator,
			     ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(pAllocator);
    ASSERT(pProperties);

    // !!! how do we decide how many to get ?
    pProperties->cBuffers = 4;

    pProperties->cbBuffer = m_pFilter->GetMaxSampleSize();

    // ask the allocator for these buffers
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
	return hr;
    }

    return NOERROR;
}

// this pin has gone active. Start the thread pushing
HRESULT
CReaderStream::Active()
{
    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
	return hr;
    }


    // start the thread
    if (!ThreadExists()) {
	if (!Create()) {
	    return E_FAIL;
	}
    }

    return RunThread();
}

// pin has gone inactive. Stop and exit the worker thread
HRESULT
CReaderStream::Inactive()
{
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr;
    if (ThreadExists()) {
	hr = StopThread();

	if (FAILED(hr)) {
	    return hr;
	}

	hr = ExitThread();
	if (FAILED(hr)) {
	    return hr;
	}
    }
    return CBaseOutputPin::Inactive();
}

#if 0  // MIDL and structs don't match well
STDMETHODIMP
CReaderStream::Notify(IBaseFilter * pSender, Quality q)
{
   // ??? Try to adjust the quality to avoid flooding/starving the
   // components downstream.
   //
   // ideas anyone?

   return E_NOTIMPL;  // We are (currently) NOT handling this
}
#endif

// worker thread stuff


BOOL
CReaderStream::Create()
{
    CAutoLock lock(&m_AccessLock);

    return CAMThread::Create();
}


HRESULT
CReaderStream::RunThread()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CReaderStream::StopThread()
{
    return CallWorker(CMD_STOP);
}


HRESULT
CReaderStream::ExitThread()
{
    CAutoLock lock(&m_AccessLock);

    HRESULT hr = CallWorker(CMD_EXIT);
    if (FAILED(hr)) {
	return hr;
    }

    // wait for thread completion and then close
    // handle (and clear so we can start another later)
    Close();

    return NOERROR;
}


// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CReaderStream::ThreadProc()
{

    BOOL bExit = FALSE;
    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }
    return NOERROR;
}

void
CReaderStream::DoRunLoop(void)
{
    // snapshot start and stop times from the other thread
    CRefTime tStart, tStopAt;
    double dRate;
    LONG sStart;
    LONG sStopAt;

    while (TRUE) {

	// each time before re-entering the push loop, check for changes
	// in start, stop or rate. If start has not changed, pick up from the
	// same current position.
	{
	    CAutoLock lock(&m_WorkerLock);

	    tStart = Start();
	    tStopAt = Stop();
	    dRate = Rate();

	    sStart = m_pFilter->RefTimeToSample(tStart);
	    sStopAt = m_pFilter->RefTimeToSample(tStopAt);

	    // if the stream is temporally compressed, we need to start from
	    // the previous key frame and play from there. All samples until the
	    // actual start will be marked with negative times.
	    // we send tStart as time 0, and start from tCurrent which may be
	    // negative

	}

	LONG sCurrent = m_pFilter->StartFrom(sStart);

	// check we are not going over the end
	sStopAt = min(sStopAt, (LONG) m_pFilter->m_sLength-1);

	// set the variables checked by PushLoop - these can also be set
	// on the fly
	SetRateInternal(dRate);
	SetStopAt(sStopAt, tStopAt);
	ASSERT(sCurrent >= 0);

	// returns S_OK if reached end
	HRESULT hr = PushLoop(sCurrent, sStart, tStart, dRate);
	if (VFW_S_NO_MORE_ITEMS == hr) {

	    DbgLog((LOG_ERROR,1,TEXT("Sending EndOfStream")));
	    // all done
	    // reached end of stream - notify downstream
	    DeliverEndOfStream();
	
	    break;
	} else if (FAILED(hr)) {

	    // signal an error to the filter graph and stop

	    // This could be the error reported from GetBuffer when we
	    // are stopping. In that case, nothing is wrong, really
	    if (hr != VFW_E_NOT_COMMITTED) {
		DbgLog((LOG_ERROR,1,TEXT("PushLoop failed! hr=%lx"), hr));
		m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);

		DeliverEndOfStream();
	    } else {
		DbgLog((LOG_TRACE,1,TEXT("PushLoop failed! But I don't care")));
	    }

	    break;
	} else if(hr == S_OK) {
	    // not my error to report. or someone wants to stop. queitly
	    // exit.
	    break;
	} // else S_FALSE - go round again

	Command com;
	if (CheckRequest(&com)) {
	    // if it's a run command, then we're already running, so
	    // eat it now.
	    if (com == CMD_RUN) {
		GetRequest();
		Reply(NOERROR);
	    } else {
		break;
	    }
	}
    }

    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop")));
}


// return S_OK if reach sStop, S_FALSE if pos changed, or else error
HRESULT
CReaderStream::PushLoop(
    LONG sCurrent,
    LONG sStart,
    CRefTime tStart,
    double dRate
    )
{
    DbgLog((LOG_TRACE,1,TEXT("Entering streaming loop: start = %d, stop=%d"),
	    sCurrent, GetStopAt()));

    LONG sFirst = sCurrent; // remember the first thing we're sending

    // since we are starting on a new segment, notify the downstream pin
    DeliverNewSegment(tStart, GetStopTime(), GetRate());


    // we send one sample at m_sStopAt, but we set the time stamp such that
    // it won't get rendered except for media types that understand static
    // rendering (eg video). This means that play from 10 to 10 does the right
    // thing (completing, with frame 10 visible and no audio).

    while (sCurrent <= GetStopAt()) {

	DWORD sCount;

	// get a buffer
	DbgLog((LOG_TRACE,5,TEXT("Getting buffer...")));

	IMediaSample *pSample;
	HRESULT hr = GetDeliveryBuffer(&pSample, NULL, NULL, 0);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("Error %lx getting delivery buffer"), hr));
	    return hr;
	}

	DbgLog((LOG_TRACE,5,TEXT("Got buffer, size=%d"), pSample->GetSize()));

	// mark sample as preroll or not....
	pSample->SetPreroll(sCurrent < sStart);
	
	// If this is the first thing we're sending, it is discontinuous
	// from the last thing they received.
	if (sCurrent == sFirst)
	    pSample->SetDiscontinuity(TRUE);
	else
	    pSample->SetDiscontinuity(FALSE);

	// !!! actually get data here!!!!!!
	hr = m_pFilter->FillBuffer(pSample, sCurrent, &sCount);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("FillBuffer failed!  hr = %x"), hr));

	    return hr;
	}
	
	// set the start/stop time for this sample.
	CRefTime tThisStart = m_pFilter->SampleToRefTime(sCurrent) - tStart;
	CRefTime tThisEnd = m_pFilter->SampleToRefTime(sCurrent + sCount) - tStart;

	// we may have pushed a sample past the stop time, but we need to
	// make sure that the stop time is correct
	tThisEnd = min(tThisEnd, GetStopTime());

	// adjust both times by Rate... unless Rate is 0

	if (dRate && (dRate!=1.0)) {
	    tThisStart = LONGLONG( tThisStart.GetUnits() / dRate);
	    tThisEnd = LONGLONG( tThisEnd.GetUnits() / dRate);
	}

	pSample->SetTime((REFERENCE_TIME *)&tThisStart,
			 (REFERENCE_TIME *)&tThisEnd);


	DbgLog((LOG_TRACE,5,TEXT("Sending buffer, size = %d"), pSample->GetActualDataLength()));
	hr = Deliver(pSample);

	// done with buffer. connected pin may have its own addref
	DbgLog((LOG_TRACE,4,TEXT("Sample is delivered - releasing")));
	pSample->Release();
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("... but sample FAILED to deliver! hr=%lx"), hr));
	    // pretend everything's OK.  If we return an error, we'll panic
	    // and send EC_ERRORABORT and EC_COMPLETE, which is the wrong thing
	    // to do if we've tried to deliver something downstream.  Only
	    // if the downstream guy never got a chance to see the data do I
	    // feel like panicing.  For instance, the downstream guy could
	    // be failing because he's already seen EndOfStream (this thread
	    // hasn't noticed it yet) and he's already sent EC_COMPLETE and I
	    // would send another one!
	    return S_OK;
	}
	sCurrent += sCount;
	
	// what about hr==S_FALSE... I thought this would mean that
	// no more data should be sent down the pipe.
	if (hr == S_FALSE) {
	    DbgLog((LOG_ERROR,1,TEXT("Received S_FALSE from Deliver, stopping delivery")));
	    return S_OK;
	}
	
	// any other requests ?
	Command com;
	if (CheckRequest(&com)) {
	    return S_FALSE;
	}

    }

    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop: current = %d, stop=%d"),
	    sCurrent, GetStopAt()));
    return VFW_S_NO_MORE_ITEMS;
}

// ------ IMediaPosition implementation -----------------------

HRESULT
CReaderStream::ChangeStart()
{
    // this lock should not be the same as the lock that protects access
    // to the start/stop/rate values. The worker thread will need to lock
    // that on some code paths before responding to a Stop and thus will
    // cause deadlock.

    // what we are locking here is access to the worker thread, and thus we
    // should hold the lock that prevents more than one client thread from
    // accessing the worker thread.

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {

	// next time round the loop the worker thread will
	// pick up the position change.
	// We need to flush all the existing data - we must do that here
	// as our thread will probably be blocked in GetBuffer otherwise

	DeliverBeginFlush();

	// make sure we have stopped pushing
	StopThread();

	// complete the flush
	DeliverEndFlush();

	// restart
	RunThread();
    }
    return S_OK;
}

HRESULT
CReaderStream::ChangeRate()
{
    // changing the rate can be done on the fly

    SetRateInternal(Rate());
    return S_OK;
}

HRESULT
CReaderStream::ChangeStop()
{
    // we don't need to restart the worker thread to handle stop changes
    // and in any case that would be wrong since it would then start
    // pushing from the wrong place. Set the variables used by
    // the PushLoop
    REFERENCE_TIME tStopAt;
    {
        CAutoLock lock(&m_WorkerLock);
        tStopAt = Stop();
    }
    LONG sStopAt = m_pFilter->RefTimeToSample(tStopAt);
    SetStopAt(sStopAt, tStopAt);

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmauth\simpread.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

//
//
// implements quartz stream handler interfaces by mapping to avifile apis.
//

// forward declarations

#ifndef __SIMPLEREADER__
#define __SIMPLEREADER__

class CReaderStream;     // owns a particular stream
class CSimpleReader;     // overall container class

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CReaderInPin : public CBasePin
{
protected:
    class CSimpleReader* m_pFilter;

public:
    CReaderInPin(
		 class CSimpleReader *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 LPCWSTR pPinName);

    virtual ~CReaderInPin();

    // CBasePin overrides
    virtual HRESULT CheckMediaType(const CMediaType* mtOut);
    virtual HRESULT CheckConnect(IPin * pPin);
    virtual HRESULT CompleteConnect(IPin *pReceivePin);
    virtual HRESULT BreakConnect();

    STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
    STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};

// CReaderStream
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CSimpleReader object and
// returned via the EnumPins interface.
//

class CReaderStream : public CBaseOutputPin, public CAMThread, public CSourceSeeking
{

public:

    CReaderStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CSimpleReader * pFilter,
	CCritSec *pLock,
	LPCWSTR wszPinName);

    ~CReaderStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // Override to start & stop thread
    HRESULT Active();
    HRESULT Inactive();


    // ----- called by worker thread ---

    // access the stop and rate variables used by PushLoop
    // called by worker thread and
    double GetRate(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        return m_dRate;
    }
    void SetRateInternal(double dRate) {
        // not atomic so hold critsec
        CAutoLock lock(&m_WorkerLock);
        m_dRate = dRate;
    }
    LONG GetStopAt(void) {
        // atomic so no critsec
        return m_sStopAt;
    }
    REFERENCE_TIME GetStopTime(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        return m_rtStop;
    }
    void SetStopAt(DWORD sStop, REFERENCE_TIME tStop) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        m_rtStop = tStop;
	m_sStopAt = sStop;
    }

    void SetDuration(DWORD sDuration, REFERENCE_TIME tDuration) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);

	m_sStopAt = sDuration;

        // set them in the base class
	m_rtDuration = tDuration;
	m_rtStop = tDuration;
    }

private:

    CSimpleReader * m_pFilter;

    // CSourcePosition stuff
    // the worker thread PushLoop is checking against these for every sample
    // Use Get/SetRate Get/SetStop to access from worker thread
    LONG m_sStopAt;


    HRESULT ChangeStart();
    HRESULT ChangeStop();
    HRESULT ChangeRate();

#if 0    // MIDL and structs don't match well
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
#endif
    
    double Rate() {
	return m_dRateSeeking;
    };
    CRefTime Start() {
        // not atomic, so use critsec
        ASSERT(CritCheckIn(&m_WorkerLock));
	return m_rtStart;
    };
    CRefTime Stop() {
        // not atomic, so use critsec
        ASSERT(CritCheckIn(&m_WorkerLock));
	return m_rtStop;
    };

    // worker thread stuff
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    void DoRunLoop(void);

    // return S_OK if reach sStop, S_FALSE if pos changed, or else error
    HRESULT PushLoop(
		LONG sCurrent,
		LONG sStart,
		CRefTime tStart,
		double dRate
		);

    CCritSec m_WorkerLock;
    CCritSec m_AccessLock;
    
public:
    BOOL Create();

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT RunThread();
    HRESULT StopThread();

    HRESULT ExitThread();

};

//
// CSimpleReader represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
//

class CSimpleReader : public CBaseFilter
{
public:

    // constructors etc
    CSimpleReader(TCHAR *, LPUNKNOWN, REFCLSID, CCritSec *, HRESULT *);
    ~CSimpleReader();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // pin enumerator calls this
    int GetPinCount();

    CBasePin * GetPin(int n);

    // input pin notifies filter of connection and gives the
    // IAsyncReader interface this way. parse the file here and create
    // output pins (leave pins in a state ready to connect downstream).
    virtual HRESULT NotifyInputConnected(IAsyncReader *pAsyncReader);

    virtual HRESULT NotifyInputDisconnected();

    // these must be overridden....
    virtual HRESULT ParseNewFile() = 0;
    virtual HRESULT CheckMediaType(const CMediaType* mtOut) = 0;
    virtual LONG StartFrom(LONG sStart) = 0;
    virtual HRESULT FillBuffer(IMediaSample *pSample, LONG &dwStart, DWORD *cSamples) = 0;
    
    HRESULT SetOutputMediaType(const CMediaType* mtOut);
    
    
private:

    friend class CReaderStream;
    friend class CReaderInPin;

protected:
    CReaderStream m_Output;
private:
    CReaderInPin m_Input;

    CCritSec *m_pLock;
    
public:
    IAsyncReader *m_pAsyncReader;
    DWORD	m_sLength;

protected:
    // returns the sample number starting at or after time t
    virtual LONG RefTimeToSample(CRefTime t) = 0;

    // returns the RefTime for s (media time)
    virtual CRefTime SampleToRefTime(LONG s) = 0;

    virtual ULONG GetMaxSampleSize() = 0;
};


#endif // __SIMPLEREADER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmauth\source.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Classes to simplify creation of ActiveX source filters that support
// continuous generation of data. It provides no support for IMediaControl
// or IMediaPosition
//
// Derive your source filter from CSource.
// During construction either:
//    Create some CSourceStream objects to manage your pins
//    Provide the user with a means of doing so eg, an IPersistFile interface.
//
// CSource provides:
//    IBaseFilter interface management
//    IMediaFilter interface management, via CBaseFilter
//    Pin counting for CBaseFilter
//
// Derive a class from CSourceStream to manage your output pin types
//  Implement GetMediaType/1 to return the type you support. If you support multiple
//   types then overide GetMediaType/3, CheckMediaType and GetMediaTypeCount.
//  Implement Fillbuffer() to put data into one buffer.
//
// CSourceStream provides:
//    IPin management via CBaseOutputPin
//    Worker thread management

#ifndef __CSOURCE__
#define __CSOURCE__

class CSourceStream;  // The class that will handle each pin


//
// CSource
//
// Override construction to provide a means of creating
// CSourceStream derived objects - ie a way of creating pins.
class CSource : public CBaseFilter {
public:

    CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid, HRESULT *phr);
    CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid);
    ~CSource();

    int       GetPinCount(void);
    CBasePin *GetPin(int n);

    // -- Utilities --

    CCritSec*	pStateLock(void) { return &m_cStateLock; }	// provide our critical section

    HRESULT     AddPin(CSourceStream *);
    HRESULT     RemovePin(CSourceStream *);

    STDMETHODIMP FindPin(
        LPCWSTR Id,
        IPin ** ppPin
    );

    int FindPinNumber(IPin *iPin);
    
protected:

    int             m_iPins;       // The number of pins on this filter. Updated by CSourceStream
    	   			   // constructors & destructors.
    CSourceStream **m_paStreams;   // the pins on this filter.

    CCritSec m_cStateLock;	// Lock this to serialize function accesses to the filter state

};


//
// CSourceStream
//
// Use this class to manage a stream of data that comes from a
// pin.
// Uses a worker thread to put data on the pin.
class CSourceStream : public CAMThread, public CBaseOutputPin {
public:

    CSourceStream(TCHAR *pObjectName,
                  HRESULT *phr,
                  CSource *pms,
                  LPCWSTR pName);

    virtual ~CSourceStream(void);  // virtual destructor ensures derived class destructors are called too.

protected:

    CSource *m_pFilter;	// The parent of this stream

    // *
    // * Data Source
    // *
    // * The following three functions: FillBuffer, OnThreadCreate/Destroy, are
    // * called from within the ThreadProc. They are used in the creation of
    // * the media samples this pin will provide
    // *

    // Override this to provide the worker thread a means
    // of processing a buffer
    virtual HRESULT FillBuffer(IMediaSample *pSamp) PURE;

    // Called as the thread is created/destroyed - use to perform
    // jobs such as start/stop streaming mode
    // If OnThreadCreate returns an error the thread will exit.
    virtual HRESULT OnThreadCreate(void) {return NOERROR;};
    virtual HRESULT OnThreadDestroy(void) {return NOERROR;};
    virtual HRESULT OnThreadStartPlay(void) {return NOERROR;};

    // *
    // * Worker Thread
    // *

    HRESULT Active(void);    // Starts up the worker thread
    HRESULT Inactive(void);  // Exits the worker thread.

public:
    // thread commands
    enum Command {CMD_INIT, CMD_PAUSE, CMD_RUN, CMD_STOP, CMD_EXIT};
    HRESULT Init(void) { return CallWorker(CMD_INIT); }
    HRESULT Exit(void) { return CallWorker(CMD_EXIT); }
    HRESULT Run(void) { return CallWorker(CMD_RUN); }
    HRESULT Pause(void) { return CallWorker(CMD_PAUSE); }
    HRESULT Stop(void) { return CallWorker(CMD_STOP); }

protected:
    Command GetRequest(void) { return (Command) CAMThread::GetRequest(); }
    BOOL    CheckRequest(Command *pCom) { return CAMThread::CheckRequest( (DWORD *) pCom); }

    // override these if you want to add thread commands
    virtual DWORD ThreadProc(void);  		// the thread function

    virtual HRESULT DoBufferProcessingLoop(void);    // the loop executed whilst running


    // *
    // * AM_MEDIA_TYPE support
    // *

    // If you support more than one media type then override these 2 functions
    virtual HRESULT CheckMediaType(const CMediaType *pMediaType);
    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);  // List pos. 0-n

    // If you support only one type then override this fn.
    // This will only be called by the default implementations
    // of CheckMediaType and GetMediaType(int, CMediaType*)
    // You must override this fn. or the above 2!
    virtual HRESULT GetMediaType(CMediaType *pMediaType) {return E_UNEXPECTED;}

    STDMETHODIMP QueryId(
        LPWSTR * Id
    );
};

#endif // __CSOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmauth\urlssrc.cpp ===
#include <streams.h>
#include "source.h"
#include "header.h"

// !!!!!
#undef _ATL_STATIC_REGISTRY

#include <atlbase.h>


#define CB_MAX (1024 * 1024)




CDiSrcStream::CDiSrcStream(CDiSrc *pParent, HRESULT *phr)
        : CSourceStream(NAME("pin"), phr, pParent, L"out")
{
    ;
}

HRESULT CDiSrcStream::OnThreadCreate(void)
{
    USES_CONVERSION;
    if(((CDiSrc *)m_pFilter)->m_wszFileName[0] != (WCHAR)-1) {
        m_pFile = fopen(W2A(((CDiSrc *)m_pFilter)->m_wszFileName), "r");
        if(m_pFile) {
            return CSourceStream::OnThreadCreate();
        }
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    };
    
    return E_UNEXPECTED;
}

HRESULT CDiSrcStream::OnThreadDestroy()
{
    if(m_pFile) {
        fclose(m_pFile);
    }
    return CSourceStream::OnThreadDestroy();
}

HRESULT CDiSrcStream::FillBuffer(IMediaSample *pms)
{
    BYTE *pb; EXECUTE_ASSERT(SUCCEEDED(pms->GetPointer(&pb)));
            
    char szImage[4000];
    ULONG tms;                  // time in millisec
    int x = fscanf(m_pFile, "%s %s %d", szImage, pb, &tms);
    if(x == 3)
    {
        FILE *pFile = fopen(szImage, "rb");
        if(pFile)
        {
            int cchUrl = strlen((char *)pb) + 1;
            
            long cbRead = fread(pb + cchUrl, 1, CB_MAX - cchUrl, pFile);
            EXECUTE_ASSERT(SUCCEEDED(pms->SetActualDataLength(cchUrl + cbRead)));

            REFERENCE_TIME rts = tms * (UNITS / MILLISECONDS), rte = rts + UNITS / 10;
            EXECUTE_ASSERT(SUCCEEDED(pms->SetTime(&rts, &rte)));
            
            fclose(pFile);
            return S_OK;
        }
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    else if(x == EOF)
    {
        return S_FALSE;
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }
}

HRESULT CDiSrcStream::DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * ppropInputRequest)
{
    ALLOCATOR_PROPERTIES Actual, Request = *ppropInputRequest;
    Request.cbBuffer = CB_MAX;
    Request.cBuffers = 1;
    
    HRESULT hr = pAlloc->SetProperties(&Request,&Actual);
    return hr;
}

HRESULT CDiSrcStream::GetMediaType(CMediaType *pmt)
{
    pmt->majortype = MEDIATYPE_URL_STREAM;
    return S_OK;
}

HRESULT CDiSrcStream::GetMediaType(int iPosition, CMediaType *pmt)
{
    if(iPosition == 0) {
        return GetMediaType(pmt);
    }

    return VFW_S_NO_MORE_ITEMS;
}



CDiSrc::CDiSrc(LPUNKNOWN punk, HRESULT *phr) :
        CSource(NAME("image data src"), punk, CLSID_ImageSrc),
        m_outpin(this, phr)
{
    m_wszFileName[0] = (WCHAR)-1;
}

HRESULT CDiSrc::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    return riid == IID_IFileSourceFilter ?
        GetInterface((IFileSourceFilter *)this, ppv) :
        CSource::NonDelegatingQueryInterface(riid, ppv);
}

HRESULT CDiSrc:: Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *mt)
{
    if(m_wszFileName[0] == (WCHAR)-1) {
        lstrcpyW(m_wszFileName, pszFileName);
        return S_OK;
    }
    return E_UNEXPECTED;
}

HRESULT CDiSrc::GetCurFile(LPOLESTR * ppszFileName, AM_MEDIA_TYPE *mt)
{
    if(m_wszFileName[0] != (WCHAR)-1) {
        *ppszFileName = (WCHAR *)CoTaskMemAlloc(lstrlenW(m_wszFileName) * sizeof(WCHAR) + sizeof(WCHAR));
        lstrcpyW(*ppszFileName, m_wszFileName);
        return S_OK;
    }
    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmauth\source.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Implements CSource. A Quartz source filter 'template', March 1995

// Locking Strategy.
//
// Hold the filter critical section (m_pFilter->pStateLock()) to serialise
// access to functions. Note that, in general, this lock may be held
// by a function when the worker thread may want to hold it. Therefore
// if you wish to access shared state from the worker thread you will
// need to add another critical section object. The execption is during
// the threads processing loop, when it is safe to get the filter critical
// section from within FillBuffer().

#include <streams.h>
#include "source.h"


//
// CSource::Constructor
//
// Initialise the pin count for the filter. The user will create the pins in
// the derived class.
CSource::CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid)
    : CBaseFilter(pName, lpunk, &m_cStateLock, clsid),
      m_iPins(0),
      m_paStreams(NULL)
{
}

CSource::CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid, HRESULT *phr)
    : CBaseFilter(pName, lpunk, &m_cStateLock, clsid),
      m_iPins(0),
      m_paStreams(NULL)
{
    UNREFERENCED_PARAMETER(phr);
}

//
// CSource::Destructor
//
CSource::~CSource()
{
    /*  Free our pins and pin array */
    while (m_iPins != 0) {
	// deleting the pins causes them to be removed from the array...
	delete m_paStreams[m_iPins - 1];
    }

    ASSERT(m_paStreams == NULL);
}


//
//  Add a new pin
//
HRESULT CSource::AddPin(CSourceStream *pStream)
{
    CAutoLock lock(&m_cStateLock);

    /*  Allocate space for this pin and the old ones */
    CSourceStream **paStreams = new CSourceStream *[m_iPins + 1];
    if (paStreams == NULL) {
        return E_OUTOFMEMORY;
    }
    if (m_paStreams != NULL) {
        CopyMemory((PVOID)paStreams, (PVOID)m_paStreams,
                   m_iPins * sizeof(m_paStreams[0]));
        paStreams[m_iPins] = pStream;
        delete [] m_paStreams;
    }
    m_paStreams = paStreams;
    m_paStreams[m_iPins] = pStream;
    m_iPins++;
    return S_OK;
}

//
//  Remove a pin - pStream is NOT deleted
//
HRESULT CSource::RemovePin(CSourceStream *pStream)
{
    int i;
    for (i = 0; i < m_iPins; i++) {
        if (m_paStreams[i] == pStream) {
            if (m_iPins == 1) {
                delete [] m_paStreams;
                m_paStreams = NULL;
            } else {
                /*  no need to reallocate */
		while (++i < m_iPins)
		    m_paStreams[i - 1] = m_paStreams[i];
            }
            m_iPins--;
            return S_OK;
        }
    }
    return S_FALSE;
}

//
// FindPin
//
// Set *ppPin to the IPin* that has the id Id.
// or to NULL if the Id cannot be matched.
STDMETHODIMP CSource::FindPin(LPCWSTR Id, IPin **ppPin)
{
    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));
    // The -1 undoes the +1 in QueryId and ensures that totally bogus
    // strings (for which WstrToInt delivers 0) give a deliver a NULL pin.
    int i = WstrToInt(Id) -1;
    *ppPin = GetPin(i);
    if (*ppPin!=NULL){
        (*ppPin)->AddRef();
        return NOERROR;
    } else {
        return VFW_E_NOT_FOUND;
    }
}

//
// FindPinNumber
//
// return the number of the pin with this IPin* or -1 if none
int CSource::FindPinNumber(IPin *iPin) {
    int i;
    for (i=0; i<m_iPins; ++i) {
        if ((IPin *)(m_paStreams[i])==iPin) {
            return i;
        }
    }
    return -1;
}

//
// GetPinCount
//
// Returns the number of pins this filter has
int CSource::GetPinCount(void) {

    CAutoLock lock(&m_cStateLock);
    return m_iPins;
}


//
// GetPin
//
// Return a non-addref'd pointer to pin n
// needed by CBaseFilter
CBasePin *CSource::GetPin(int n) {

    CAutoLock lock(&m_cStateLock);

    // n must be in the range 0..m_iPins-1
    // if m_iPins>n  && n>=0 it follows that m_iPins>0
    // which is what used to be checked (i.e. checking that we have a pin)
    if ((n >= 0) && (n < m_iPins)) {

        ASSERT(m_paStreams[n]);
	return m_paStreams[n];
    }
    return NULL;
}


//


// *
// * --- CSourceStream ----
// *

//
// Set Id to point to a CoTaskMemAlloc'd
STDMETHODIMP CSourceStream::QueryId(LPWSTR *Id) {
    CheckPointer(Id,E_POINTER);
    ValidateReadWritePtr(Id,sizeof(LPWSTR));

    // We give the pins id's which are 1,2,...
    // FindPinNumber returns -1 for a bogus pin
    int i = 1+ m_pFilter->FindPinNumber(this);
    if (i<1) return VFW_E_NOT_FOUND;
    *Id = (LPWSTR)CoTaskMemAlloc(8);
    if (*Id==NULL) {
       return E_OUTOFMEMORY;
    }
    IntToWstr(i, *Id);
    return NOERROR;
}



//
// CSourceStream::Constructor
//
// increments the number of pins present on the filter
CSourceStream::CSourceStream(
    TCHAR *pObjectName,
    HRESULT *phr,
    CSource *ps,
    LPCWSTR pPinName)
    : CBaseOutputPin(pObjectName, ps, ps->pStateLock(), phr, pPinName),
      m_pFilter(ps) {

     *phr = m_pFilter->AddPin(this);
}


//
// CSourceStream::Destructor
//
// Decrements the number of pins on this filter
CSourceStream::~CSourceStream(void) {

     m_pFilter->RemovePin(this);
}


//
// CheckMediaType
//
// Do we support this type? Provides the default support for 1 type.
HRESULT CSourceStream::CheckMediaType(const CMediaType *pMediaType) {

    CAutoLock lock(m_pFilter->pStateLock());

    CMediaType mt;
    GetMediaType(&mt);

    if (mt == *pMediaType) {
        return NOERROR;
    }

    return E_FAIL;
}


//
// GetMediaType/3
//
// By default we support only one type
// iPosition indexes are 0-n
HRESULT CSourceStream::GetMediaType(int iPosition, CMediaType *pMediaType) {

    CAutoLock lock(m_pFilter->pStateLock());

    if (iPosition<0) {
        return E_INVALIDARG;
    }
    if (iPosition>0) {
        return VFW_S_NO_MORE_ITEMS;
    }
    return GetMediaType(pMediaType);
}


//
// Active
//
// The pin is active - start up the worker thread
HRESULT CSourceStream::Active(void) {

    CAutoLock lock(m_pFilter->pStateLock());

    HRESULT hr;

    if (m_pFilter->IsActive()) {
	return S_FALSE;	// succeeded, but did not allocate resources (they already exist...)
    }

    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (!IsConnected()) {
        return NOERROR;
    }

    hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
        return hr;
    }

    ASSERT(!ThreadExists());

    // start the thread
    if (!Create()) {
        return E_FAIL;
    }

    // Tell thread to initialize. If OnThreadCreate Fails, so does this.
    hr = Init();
    if (FAILED(hr))
	return hr;

    return Pause();
}


//
// Inactive
//
// Pin is inactive - shut down the worker thread
// Waits for the worker to exit before returning.
HRESULT CSourceStream::Inactive(void) {

    CAutoLock lock(m_pFilter->pStateLock());

    HRESULT hr;

    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (!IsConnected()) {
        return NOERROR;
    }

    // !!! need to do this before trying to stop the thread, because
    // we may be stuck waiting for our own allocator!!!

    hr = CBaseOutputPin::Inactive();  // call this first to Decommit the allocator
    if (FAILED(hr)) {
	return hr;
    }

    if (ThreadExists()) {
	hr = Stop();

	if (FAILED(hr)) {
	    return hr;
	}

	hr = Exit();
	if (FAILED(hr)) {
	    return hr;
	}

	Close();	// Wait for the thread to exit, then tidy up.
    }

    // hr = CBaseOutputPin::Inactive();  // call this first to Decommit the allocator
    //if (FAILED(hr)) {
    //	return hr;
    //}

    return NOERROR;
}


//
// ThreadProc
//
// When this returns the thread exits
// Return codes > 0 indicate an error occured
DWORD CSourceStream::ThreadProc(void) {

    HRESULT hr;  // the return code from calls
    Command com;

    do {
	com = GetRequest();
	if (com != CMD_INIT) {
	    DbgLog((LOG_ERROR, 1, TEXT("Thread expected init command")));
	    Reply((DWORD) E_UNEXPECTED);
	}
    } while (com != CMD_INIT);

    DbgLog((LOG_TRACE, 1, TEXT("CSourceStream worker thread initializing")));

    hr = OnThreadCreate(); // perform set up tasks
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("CSourceStream::OnThreadCreate failed. Aborting thread.")));
        OnThreadDestroy();
	Reply(hr);	// send failed return code from OnThreadCreate
        return 1;
    }

    // Initialisation suceeded
    Reply(NOERROR);

    Command cmd;
    do {
	cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    DbgLog((LOG_ERROR, 1, TEXT("CMD_RUN received before a CMD_PAUSE???")));
	    // !!! fall through???
	
	case CMD_PAUSE:
	    Reply(NOERROR);
	    DoBufferProcessingLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    DbgLog((LOG_ERROR, 1, TEXT("Unknown command %d received!"), cmd));
	    Reply((DWORD) E_NOTIMPL);
	    break;
	}
    } while (cmd != CMD_EXIT);

    hr = OnThreadDestroy();	// tidy up.
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("CSourceStream::OnThreadDestroy failed. Exiting thread.")));
        return 1;
    }

    DbgLog((LOG_TRACE, 1, TEXT("CSourceStream worker thread exiting")));
    return 0;
}


//
// DoBufferProcessingLoop
//
// Grabs a buffer and calls the users processing function.
// Overridable, so that different delivery styles can be catered for.
HRESULT CSourceStream::DoBufferProcessingLoop(void) {

    Command com;

    OnThreadStartPlay();

    do {
	while (!CheckRequest(&com)) {

	    IMediaSample *pSample;

	    HRESULT hr = GetDeliveryBuffer(&pSample,NULL,NULL,0);
	    if (FAILED(hr)) {
                Sleep(1);
		continue;	// go round again. Perhaps the error will go away
			    // or the allocator is decommited & we will be asked to
			    // exit soon.
	    }

	    // Virtual function user will override.
	    hr = FillBuffer(pSample);

	    if (hr == S_OK) {
		hr = Deliver(pSample);
                pSample->Release();

                // downstream filter returns S_FALSE if it wants us to
                // stop or an error if it's reporting an error.
                if(hr != S_OK)
                {
                  DbgLog((LOG_TRACE, 2, TEXT("Deliver() returned %08x; stopping"), hr));
                  return S_OK;
                }

	    } else if (hr == S_FALSE) {
                // derived class wants us to stop pushing data
		pSample->Release();
		DeliverEndOfStream();
		return S_OK;
	    } else {
                // derived class encountered an error
                pSample->Release();
		DbgLog((LOG_ERROR, 1, TEXT("Error %08lX from FillBuffer!!!"), hr));
                DeliverEndOfStream();
                m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
                return hr;
	    }

            // all paths release the sample
	}

        // For all commands sent to us there must be a Reply call!

	if (com == CMD_RUN || com == CMD_PAUSE) {
	    Reply(NOERROR);
	} else if (com != CMD_STOP) {
	    Reply((DWORD) E_UNEXPECTED);
	    DbgLog((LOG_ERROR, 1, TEXT("Unexpected command!!!")));
	}
    } while (com != CMD_STOP);

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmrtrend\lmrtrend.h ===
#include "lmrttype.h"
#include "danim.h"
#include "lmrt.h"

// {3C89D120-6F65-11d1-A520-000000000000}
DEFINE_GUID(IID_ILMRTRenderer,
0x3c89d120, 0x6f65, 0x11d1, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

static const GUID CLSID_UrlStreamRenderer = { /* bf0b4b00-8c6c-11d1-ade9-0000f8754b99 */
    0xbf0b4b00,
    0x8c6c,
    0x11d1,
    {0xad, 0xe9, 0x00, 0x00, 0xf8, 0x75, 0x4b, 0x99}
  };



interface ILMRTRenderer : IUnknown
{
//  virtual HRESULT SetLMReader(ILMReader *pLMReader) = 0;
	virtual HRESULT SetLMEngine(ILMEngine *pLMEngine) = 0;
};

// {3C89D121-6F65-11d1-A520-000000000000}
DEFINE_GUID(CLSID_LMRTRenderer,
0x3c89d121, 0x6f65, 0x11d1, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

#ifdef _STREAMS_

extern const AMOVIESETUP_FILTER sudLMRTRend;

class CLMRTRenderer : public CBaseRenderer , public ILMRTRenderer
{
public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    CLMRTRenderer(LPUNKNOWN pUnk,HRESULT *phr);
    ~CLMRTRenderer();

    DECLARE_IUNKNOWN
	    
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    STDMETHODIMP Pause();
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    void OnReceiveFirstSample(IMediaSample *pMediaSample);
    HRESULT DoRenderSample(IMediaSample *pMediaSample);
	HRESULT OnStopStreaming(void);
    HRESULT OnStartStreaming();
	STDMETHOD(JoinFilterGraph)( IFilterGraph *pGraph, LPCWSTR szName );
    // HRESULT EndOfStream();

	//ILMRTRenderer
//    HRESULT SetLMReader(ILMReader *pLMReader);
	HRESULT SetLMEngine(ILMEngine *pLMEngine);

protected:
//	IBindStatusCallback	*m_pIbsc;
	ILMEngine2 *m_pEngine;
	ILMReader2 *m_pReader;
	IUnknown *m_punkControl;
//	BYTE	*m_pMem;
//	IStream	*m_pstm;
//	ULONG	m_dwSize;
//	BSCF	m_bscf;

	DWORD	m_dwWidth;
	DWORD	m_dwHeight;

    BYTE *m_pbFirstPacketFromHeader;
    ULONG m_cbFirstPacketFromHeader;
    bool m_fFirstPause;

}; // CLMRTRenderer

class CUrlInPin : public CBaseInputPin
{
public:
    CUrlInPin(
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr
        );

    ~CUrlInPin();

    STDMETHODIMP Receive(IMediaSample *pSample);
    HRESULT CheckMediaType(const CMediaType *) ;

private:

    friend class CUrlStreamRenderer;
    TCHAR m_szTempDir[MAX_PATH];
};

class CUrlStreamRenderer :
    public CBaseFilter,
    public IPropertyBag
{
    CCritSec m_cs;
    CUrlInPin m_inPin;

    int GetPinCount() { return 1; }
    CBasePin *GetPin(int n) { ASSERT(n == 0); return &m_inPin; }

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    
    // IPropertyBag

    STDMETHODIMP Read(
        LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);

    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
    
    CUrlStreamRenderer(LPUNKNOWN punk, HRESULT *phr);
    ~CUrlStreamRenderer() {; }


public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
};
#endif // _STREAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmrtrend\ourcrt.cpp ===
#include <streams.h>

#ifndef _M_ALPHA

extern "C" const int _fltused = 0;

void * _cdecl operator new(size_t size)
{
    void * pv;
    pv = (void *)LocalAlloc(LMEM_FIXED, size);
    DbgLog((LOG_MEMORY, 4, TEXT("Allocating: %lx = %d"), pv, size));

    return pv;
}
void _cdecl operator delete(void *ptr)
{
    DbgLog((LOG_MEMORY, 4, TEXT("Freeing: %lx"), ptr));
    if (ptr)
	LocalFree(ptr);
}

/*
 * This function serves to avoid linking CRT code
 */

int __cdecl  _purecall(void)
{
#ifdef DEBUG
    DebugBreak();
#endif

    return(FALSE);
}

#if 0
#ifdef _X86_

// ---------------------------------------------------
//	asm_ftol()
// ---------------------------------------------------
extern "C" long __cdecl _ftol(float flX)
{
	long lResult;
	WORD wCW;
	WORD wNewCW;

	_asm
	{
		fld       flX			// Push the float onto the stack
		wait
		fnstcw    wCW			// Store the control word
		wait
		mov       ax,wCW		// Setup our rounding
		or        ah,0x0c
		mov       wNewCW,ax
		fldcw     wNewCW		// Set Control word to our new value
		fistp     lResult		// Round off top of stack into result
		fldcw     wCW			// Restore control word
		fnclex					// clear the status word of exceptions
	}

	return(lResult);
}

#endif
#endif
#endif / _M_ALPHA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmrtrend\lmrttype.h ===
// LMRT media type

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
//EXTERN_GUID(MEDIATYPE_LMRT,
//0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

// we might also need some kind of structure for header or per-sample information,
// if it isn't as simple as just "find an LMRT engine and give it the data".
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmrtrend\urlcache.cpp ===
#include <streams.h>
// !!!!!
#undef _ATL_STATIC_REGISTRY
#include <atlbase.h>
#include <atlimpl.cpp>
#include "lmrtrend.h"




// AMOVIESETUP_MEDIATYPE sudURLSPinTypes[] =   {
//   &MEDIATYPE_URL_STREAM,        // clsMajorType
//   &MEDIATYPE_URL_STREAM };      // clsMinorType

// AMOVIESETUP_PIN sudURLSPins[] =
// {
//   { L"Input"                    // strName
//     , TRUE                      // bRendered
//     , FALSE                     // bOutput
//     , FALSE                     // bZero
//     , FALSE                     // bMany
//     , &CLSID_NULL               // clsConnectsToFilter
//     , 0                         // strConnectsToPin
//     , NUMELMS(sudURLSPinTypes)  // nTypes
//     , sudURLSPinTypes           // lpTypes
//   }
// };


// const AMOVIESETUP_FILTER sudURLS =
// {
//   &CLSID_UrlStreamRenderer      // clsID
//   , L"URL StreamRenderer"       // strName
//   , MERIT_NORMAL                // dwMerit
//   , NUMELMS(sudURLSPins)        // nPins
//   , sudURLSPins                 // lpPin
// };

// STDAPI DllRegisterServer()
// {
//   return AMovieDllRegisterServer2(TRUE);
// }

// STDAPI DllUnregisterServer()
// {
//   return AMovieDllRegisterServer2(FALSE);
// }




CUrlInPin::CUrlInPin(CBaseFilter *pFilter, CCritSec *pLock, HRESULT *phr) :
        CBaseInputPin(NAME("url in pin"), pFilter, pLock, phr, L"In")
{
    m_szTempDir[0] = 0;
    if(SUCCEEDED(*phr))
    {
        TCHAR szTmpDir[MAX_PATH];
        DWORD dw = GetTempPath(NUMELMS(szTmpDir), szTmpDir);
        if(dw)
        {
            while(SUCCEEDED(*phr))
            {
                TCHAR szTempFile[MAX_PATH];
                UINT ui = GetTempFileName(
                    szTmpDir,
                    TEXT("lmrtasf"),
                    timeGetTime(),
                    szTempFile);
                if(ui)
                {

                    BOOL f = CreateDirectory(szTempFile, 0);
                    if(f)
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("CUrlInPin using %s"), m_szTempDir));
                        lstrcpy(m_szTempDir, szTempFile);
                        break;
                    }

                    DWORD dw = GetLastError();
                    if(dw == ERROR_ALREADY_EXISTS)
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("CUrlInPin %s exists"), szTempFile));
                        Sleep(1);
                        continue;
                    }
                    else
                    {
                        DbgLog((LOG_ERROR, 0, TEXT("CUrlInPin %s failed"), szTempFile));
                        *phr = HRESULT_FROM_WIN32(dw);
                    }
                }
                else
                {
                    DWORD dw = GetLastError();
                    *phr = HRESULT_FROM_WIN32(dw);
                    DbgLog((LOG_ERROR, 0, TEXT("CUrlInPin GetTempFileName ")));
                }
            }
        }
        else
        {
            DWORD dw = GetLastError();
            *phr = HRESULT_FROM_WIN32(dw);
            DbgLog((LOG_ERROR, 0, TEXT("CUrlInPin GetTempPath ")));
        }
    }
}

void DeleteFiles(TCHAR  *szTmp)
{
    if(szTmp[0] != 0)
    {
        WIN32_FIND_DATA wfd;
        TCHAR szwildcard[MAX_PATH + 10];
        lstrcpy(szwildcard, szTmp);
        lstrcat(szwildcard, TEXT("/*"));
        HANDLE h = FindFirstFile(szwildcard, &wfd);
        if(h != INVALID_HANDLE_VALUE)
        {
            do
            {
                if(wfd.cFileName[0] == TEXT('.') &&
                   (wfd.cFileName[1] == 0 ||
                    wfd.cFileName[1] == TEXT('.') && wfd.cFileName[2] == 0))
                {
                    continue;
                }
                
                TCHAR sz[MAX_PATH * 3];
                lstrcpy(sz, szTmp);
                lstrcat(sz, TEXT("/"));
                lstrcat(sz, wfd.cFileName);
                EXECUTE_ASSERT(DeleteFile(sz));
                
            } while (FindNextFile(h, &wfd));
        
            EXECUTE_ASSERT(FindClose(h));
        }
        EXECUTE_ASSERT(RemoveDirectory(szTmp));
    }

}

CUrlInPin::~CUrlInPin()
{
    DeleteFiles(m_szTempDir);
}



HRESULT CUrlInPin::CheckMediaType(const CMediaType *pmt)
{
    if(pmt->majortype == MEDIATYPE_URL_STREAM)
    {
        return S_OK;
    }
    return S_FALSE;
}

HRESULT CUrlInPin::Receive(IMediaSample *ps)
{
    HRESULT hrSignal = S_OK;
    
    HRESULT hr = CBaseInputPin::Receive(ps);
    if(hr == S_OK)
    {
        bool fInvalid = false;
        BYTE *pbLastPeriod = 0;
        // determine length of url without expecting a null at the end
        for(LONG ib = 0; ib < m_SampleProps.lActual; ib++)
        {
            BYTE &rsz = m_SampleProps.pbBuffer[ib];
            if(rsz == 0)
                break;

            // avoid creating some malicious file names (eg
            // c:/config.sys, ..\dsound.dll)
            if(rsz == ':'  && ib != 4 ||
               rsz == '/' ||
               rsz == '\\')
            {
                DbgBreak("bad filename");
                fInvalid = true;
                break;
            }

            if(rsz == '.') {
                pbLastPeriod = &rsz;
            }
        }

        if(!fInvalid && (ib >= m_SampleProps.lActual || ib >= MAX_PATH)) {
            fInvalid = true;
        }

        // these can be malicious, but it's not an exhaustive
        // list. (if you stream in a .wav and a rogue dsound.dll and
        // the user finds and double clicks on the .wav, he'll pick up
        // the rogue dsound.dll from the current directory). perhaps
        // we can compile a list of stuff it is ok to import!!!
        if(!fInvalid && pbLastPeriod) {
            if(lstrcmpiA((char *)pbLastPeriod, ".dll") == 0 ||
               lstrcmpiA((char *)pbLastPeriod, ".cmd") == 0 ||
               lstrcmpiA((char *)pbLastPeriod, ".bat") == 0 ||
               lstrcmpiA((char *)pbLastPeriod, ".url") == 0 ||
               lstrcmpiA((char *)pbLastPeriod, ".exe") == 0)
            {
                fInvalid = true;
            }
        }
        if(!fInvalid)
        {
            ULONG cbSz = ib + 1; // incl null
            BYTE *pbImage = m_SampleProps.pbBuffer + ib + 1;
            ULONG ibImage = ib + 1; // image starts here
            ULONG cbImage = m_SampleProps.lActual - cbSz;
            

            char *szUrl = (char *)m_SampleProps.pbBuffer;
            if(*szUrl++ == 'l' &&
               *szUrl++ == 'm' &&
               *szUrl++ == 'r' &&
               *szUrl++ == 't' &&
               *szUrl++ == ':')
            {
                ASSERT(ib - 5 == lstrlen(szUrl));

                TCHAR szThisFile[MAX_PATH * 2+ 10];
                lstrcpy(szThisFile, m_szTempDir);
                lstrcat(szThisFile, TEXT("\\"));
                lstrcat(szThisFile, szUrl);

                HANDLE hFile = CreateFile(
                    szThisFile,
                    GENERIC_WRITE,
                    0,  // share
                    0,  // lpSecurityAttribytes
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    0);
                if(hFile != INVALID_HANDLE_VALUE)
                {
                    DWORD cbWritten;
                            
                    BOOL b = WriteFile(
                        hFile,
                        pbImage,
                        cbImage,
                        &cbWritten,
                        0); // overlapped

                    if(b)
                    {
                        ASSERT(cbWritten == cbImage);
                    }
                    else
                    {
                        DWORD dw = GetLastError();
                        hrSignal = HRESULT_FROM_WIN32(dw);
                    }

                    EXECUTE_ASSERT(CloseHandle(hFile));
                }
                else
                {
                    DWORD dw = GetLastError();
                    hrSignal = HRESULT_FROM_WIN32(dw);
                }
            }
            else
            {
                // no "lmrt:"
                hrSignal = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }
        }
        else
        {
            // no null terminator on string
            hrSignal = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
        
    } // base class receive

    if(SUCCEEDED(hrSignal))
    {
        return hr;
    }
    else
    {
        m_pFilter->NotifyEvent(EC_STREAM_ERROR_STOPPED, hrSignal, 0);
        return S_FALSE;
    }
}


// CFactoryTemplate g_Templates[]= {
//   {L"URL StreamRenderer", &CLSID_UrlStreamRenderer, CUrlStreamRenderer::CreateInstance, NULL, &sudURLS},
// };
// int g_cTemplates = NUMELMS(g_Templates);

CUnknown *CUrlStreamRenderer::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    if(SUCCEEDED(*phr))
        return new CUrlStreamRenderer(lpunk, phr);
    else
        return 0;
}

#pragma warning(disable:4355)

CUrlStreamRenderer::CUrlStreamRenderer(LPUNKNOWN punk, HRESULT *phr) :
        CBaseFilter(NAME("URL Stream Filter"), punk, &m_cs, CLSID_UrlStreamRenderer),
        m_inPin(this, &m_cs, phr)
{
}

HRESULT CUrlStreamRenderer::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if(riid == IID_IPropertyBag) {
        return GetInterface((IPropertyBag *)this, ppv);
    } else {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

HRESULT CUrlStreamRenderer::Read(
    LPCOLESTR pszPropName, LPVARIANT pVar,
    LPERRORLOG pErrorLog)
{
    if(lstrcmpW(pszPropName, L"lmrtcache") == 0 &&
       (pVar->vt == VT_BSTR || pVar->vt == VT_EMPTY))
    {
        EXECUTE_ASSERT(VariantClear(pVar) == S_OK);
        USES_CONVERSION;
        pVar->vt = VT_BSTR;
        pVar->bstrVal = SysAllocString(T2W(m_inPin.m_szTempDir));
        return pVar->bstrVal ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT CUrlStreamRenderer::Write(
    LPCOLESTR pszPropName, LPVARIANT pVar)
{
    return E_FAIL;
}

// extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);


// BOOL WINAPI DllMain(  HINSTANCE hinstDLL,  // handle to DLL module
//   DWORD fdwReason,     // reason for calling function
//   LPVOID lpvReserved   // reserved
// )
// {
//     return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\amfilter.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierarchy for streams architecture, December 1994

#ifndef __FILTER__
#define __FILTER__

/* The following classes are declared in this header: */

class CBaseMediaFilter;     // IMediaFilter support
class CBaseFilter;          // IBaseFilter,IMediaFilter support
class CBasePin;             // Abstract base class for IPin interface
class CEnumPins;            // Enumerate input and output pins
class CEnumMediaTypes;      // Enumerate the pin's preferred formats
class CBaseOutputPin;       // Adds data provider member functions
class CBaseInputPin;        // Implements IMemInputPin interface
class CMediaSample;         // Basic transport unit for IMemInputPin
class CBaseAllocator;       // General list guff for most allocators
class CMemAllocator;        // Implements memory buffer allocation


//=====================================================================
//=====================================================================
//
// QueryFilterInfo and QueryPinInfo AddRef the interface pointers
// they return.  You can use the macro below to release the interface.
//
//=====================================================================
//=====================================================================

#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph->Release();

#define QueryPinInfoReleaseFilter(pi) if ((pi).pFilter) (pi).pFilter->Release();

//=====================================================================
//=====================================================================
// Defines CBaseMediaFilter
//
// Abstract base class implementing IMediaFilter.
//
// Typically you will derive your filter from CBaseFilter rather than
// this,  unless you are implementing an object such as a plug-in
// distributor that needs to support IMediaFilter but not IBaseFilter.
//
// Note that IMediaFilter is derived from IPersist to allow query of
// class id.
//=====================================================================
//=====================================================================

class AM_NOVTABLE CBaseMediaFilter : public CUnknown,
                                     public IMediaFilter
{

protected:

    FILTER_STATE    m_State;            // current state: running, paused
    IReferenceClock *m_pClock;          // this filter's reference clock
    // note: all filters in a filter graph use the same clock

    // offset from stream time to reference time
    CRefTime        m_tStart;

    CLSID	    m_clsid;            // This filters clsid
                                        // used for serialization
    CCritSec        *m_pLock;           // Object we use for locking

public:

    CBaseMediaFilter(
        const TCHAR     *pName,
        LPUNKNOWN pUnk,
        CCritSec  *pLock,
	REFCLSID   clsid);

    virtual ~CBaseMediaFilter();

    DECLARE_IUNKNOWN

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    //
    // --- IPersist method ---
    //

    STDMETHODIMP GetClassID(CLSID *pClsID);

    // --- IMediaFilter methods ---

    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);

    STDMETHODIMP GetSyncSource(IReferenceClock **pClock);

    // default implementation of Stop and Pause just record the
    // state. Override to activate or de-activate your filter.
    // Note that Run when called from Stopped state will call Pause
    // to ensure activation, so if you are a source or transform
    // you will probably not need to override Run.
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();


    // the start parameter is the difference to be added to the
    // sample's stream time to get the reference time for
    // its presentation
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // --- helper methods ---

    // return the current stream time - ie find out what
    // stream time should be appearing now
    virtual HRESULT StreamTime(CRefTime& rtStream);

    // Is the filter currently active? (running or paused)
    BOOL IsActive() {
        CAutoLock cObjectLock(m_pLock);
        return ((m_State == State_Paused) || (m_State == State_Running));
    };
};

//=====================================================================
//=====================================================================
// Defines CBaseFilter
//
// An abstract class providing basic IBaseFilter support for pin
// enumeration and filter information reading.
//
// We cannot derive from CBaseMediaFilter since methods in IMediaFilter
// are also in IBaseFilter and would be ambiguous. Since much of the code
// assumes that they derive from a class that has m_State and other state
// directly available, we duplicate code from CBaseMediaFilter rather than
// having a member variable.
//
// Derive your filter from this, or from a derived object such as
// CTransformFilter.
//=====================================================================
//=====================================================================


class AM_NOVTABLE CBaseFilter : public CUnknown,        // Handles an IUnknown
                    public IBaseFilter,     // The Filter Interface
                    public IAMovieSetup     // For un/registration
{

friend class CBasePin;

protected:
    FILTER_STATE    m_State;            // current state: running, paused
    IReferenceClock *m_pClock;          // this graph's ref clock
    CRefTime        m_tStart;           // offset from stream time to reference time
    CLSID	    m_clsid;            // This filters clsid
                                        // used for serialization
    CCritSec        *m_pLock;           // Object we use for locking

    WCHAR           *m_pName;           // Full filter name
    IFilterGraph    *m_pGraph;          // Graph we belong to
    IMediaEventSink *m_pSink;           // Called with notify events
    LONG            m_PinVersion;       // Current pin version

public:

    CBaseFilter(
        const TCHAR *pName,     // Object description
        LPUNKNOWN pUnk,         // IUnknown of delegating object
        CCritSec  *pLock,       // Object who maintains lock
	REFCLSID   clsid);      // The clsid to be used to serialize this filter

    CBaseFilter(
        TCHAR     *pName,       // Object description
        LPUNKNOWN pUnk,         // IUnknown of delegating object
        CCritSec  *pLock,       // Object who maintains lock
	REFCLSID   clsid,       // The clsid to be used to serialize this filter
        HRESULT   *phr);        // General OLE return code

    ~CBaseFilter();

    DECLARE_IUNKNOWN

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
#ifdef DEBUG
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
#endif

    //
    // --- IPersist method ---
    //

    STDMETHODIMP GetClassID(CLSID *pClsID);

    // --- IMediaFilter methods ---

    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);

    STDMETHODIMP GetSyncSource(IReferenceClock **pClock);


    // override Stop and Pause so we can activate the pins.
    // Note that Run will call Pause first if activation needed.
    // Override these if you want to activate your filter rather than
    // your pins.
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

    // the start parameter is the difference to be added to the
    // sample's stream time to get the reference time for
    // its presentation
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // --- helper methods ---

    // return the current stream time - ie find out what
    // stream time should be appearing now
    virtual HRESULT StreamTime(CRefTime& rtStream);

    // Is the filter currently active?
    BOOL IsActive() {
        CAutoLock cObjectLock(m_pLock);
        return ((m_State == State_Paused) || (m_State == State_Running));
    };

    // Is this filter stopped (without locking)
    BOOL IsStopped() {
        return (m_State == State_Stopped);
    };

    //
    // --- IBaseFilter methods ---
    //

    // pin enumerator
    STDMETHODIMP EnumPins(
                    IEnumPins ** ppEnum);


    // default behaviour of FindPin assumes pin ids are their names
    STDMETHODIMP FindPin(
        LPCWSTR Id,
        IPin ** ppPin
    );

    STDMETHODIMP QueryFilterInfo(
                    FILTER_INFO * pInfo);

    STDMETHODIMP JoinFilterGraph(
                    IFilterGraph * pGraph,
                    LPCWSTR pName);

    // return a Vendor information string. Optional - may return E_NOTIMPL.
    // memory returned should be freed using CoTaskMemFree
    // default implementation returns E_NOTIMPL
    STDMETHODIMP QueryVendorInfo(
                    LPWSTR* pVendorInfo
            );

    // --- helper methods ---

    // send an event notification to the filter graph if we know about it.
    // returns S_OK if delivered, S_FALSE if the filter graph does not sink
    // events, or an error otherwise.
    HRESULT NotifyEvent(
        long EventCode,
        LONG_PTR EventParam1,
        LONG_PTR EventParam2);

    // return the filter graph we belong to
    IFilterGraph *GetFilterGraph() {
        return m_pGraph;
    }

    // Request reconnect
    // pPin is the pin to reconnect
    // pmt is the type to reconnect with - can be NULL
    // Calls ReconnectEx on the filter graph
    HRESULT ReconnectPin(IPin *pPin, AM_MEDIA_TYPE const *pmt);

    // find out the current pin version (used by enumerators)
    virtual LONG GetPinVersion();
    void IncrementPinVersion();

    // you need to supply these to access the pins from the enumerator
    // and for default Stop and Pause/Run activation.
    virtual int GetPinCount() PURE;
    virtual CBasePin *GetPin(int n) PURE;

    // --- IAMovieSetup methods ---

    STDMETHODIMP Register();    // ask filter to register itself
    STDMETHODIMP Unregister();  // and unregister itself

    // --- setup helper methods ---
    // (override to return filters setup data)

    virtual LPAMOVIESETUP_FILTER GetSetupData(){ return NULL; }

};


//=====================================================================
//=====================================================================
// Defines CBasePin
//
// Abstract class that supports the basics of IPin
//=====================================================================
//=====================================================================

class  AM_NOVTABLE CBasePin : public CUnknown, public IPin, public IQualityControl
{

protected:

    WCHAR *         m_pName;		        // This pin's name
    IPin            *m_Connected;               // Pin we have connected to
    CMediaType      m_mt;                       // Media type of connection
    PIN_DIRECTION   m_dir;                      // Direction of this pin
    CCritSec        *m_pLock;                   // Object we use for locking
    BOOL            m_bRunTimeError;            // Run time error generated
    CBaseFilter    *m_pFilter;                  // Filter we were created by
    IQualityControl *m_pQSink;                  // Target for Quality messages
    LONG            m_TypeVersion;              // Holds current type version

    CRefTime        m_tStart;                   // time from NewSegment call
    CRefTime        m_tStop;                    // time from NewSegment
    double          m_dRate;                    // rate from NewSegment

#ifdef DEBUG
    LONG            m_cRef;                     // Ref count tracing
#endif

    // displays pin connection information

#ifdef DEBUG
    void DisplayPinInfo(IPin *pReceivePin);
    void DisplayTypeInfo(IPin *pPin, const CMediaType *pmt);
#else
    void DisplayPinInfo(IPin *pReceivePin) {};
    void DisplayTypeInfo(IPin *pPin, const CMediaType *pmt) {};
#endif

    // used to agree a media type for a pin connection

    // given a specific media type, attempt a connection (includes
    // checking that the type is acceptable to this pin)
    HRESULT
    AttemptConnection(
        IPin* pReceivePin,      // connect to this pin
        const CMediaType* pmt   // using this type
    );

    // try all the media types in this enumerator - for each that
    // we accept, try to connect using ReceiveConnection.
    HRESULT TryMediaTypes(
                        IPin *pReceivePin,      // connect to this pin
                        const CMediaType *pmt,        // proposed type from Connect
                        IEnumMediaTypes *pEnum);    // try this enumerator

    // establish a connection with a suitable mediatype. Needs to
    // propose a media type if the pmt pointer is null or partially
    // specified - use TryMediaTypes on both our and then the other pin's
    // enumerator until we find one that works.
    HRESULT AgreeMediaType(
                        IPin *pReceivePin,      // connect to this pin
                        const CMediaType *pmt);       // proposed type from Connect

public:

    CBasePin(
        TCHAR *pObjectName,         // Object description
        CBaseFilter *pFilter,       // Owning filter who knows about pins
        CCritSec *pLock,            // Object who implements the lock
        HRESULT *phr,               // General OLE return code
        LPCWSTR pName,              // Pin name for us
        PIN_DIRECTION dir);         // Either PINDIR_INPUT or PINDIR_OUTPUT

    virtual ~CBasePin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();

    // --- IPin methods ---

    // take lead role in establishing a connection. Media type pointer
    // may be null, or may point to partially-specified mediatype
    // (subtype or format type may be GUID_NULL).
    STDMETHODIMP Connect(
        IPin * pReceivePin,
        const AM_MEDIA_TYPE *pmt   // optional media type
    );

    // (passive) accept a connection from another pin
    STDMETHODIMP ReceiveConnection(
        IPin * pConnector,      // this is the initiating connecting pin
        const AM_MEDIA_TYPE *pmt   // this is the media type we will exchange
    );

    STDMETHODIMP Disconnect();

    STDMETHODIMP ConnectedTo(IPin **pPin);

    STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE *pmt);

    STDMETHODIMP QueryPinInfo(
        PIN_INFO * pInfo
    );

    STDMETHODIMP QueryDirection(
    	PIN_DIRECTION * pPinDir
    );

    STDMETHODIMP QueryId(
        LPWSTR * Id
    );

    // does the pin support this media type
    STDMETHODIMP QueryAccept(
        const AM_MEDIA_TYPE *pmt
    );

    // return an enumerator for this pins preferred media types
    STDMETHODIMP EnumMediaTypes(
        IEnumMediaTypes **ppEnum
    );

    // return an array of IPin* - the pins that this pin internally connects to
    // All pins put in the array must be AddReffed (but no others)
    // Errors: "Can't say" - FAIL, not enough slots - return S_FALSE
    // Default: return E_NOTIMPL
    // The filter graph will interpret NOT_IMPL as any input pin connects to
    // all visible output pins and vice versa.
    // apPin can be NULL if nPin==0 (not otherwise).
    STDMETHODIMP QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin       // on input, the number of slots
                          // on output  the number of pins
    ) { return E_NOTIMPL; }

    // Called when no more data will be sent
    STDMETHODIMP EndOfStream(void);

    // Begin/EndFlush still PURE

    // NewSegment notifies of the start/stop/rate applying to the data
    // about to be received. Default implementation records data and
    // returns S_OK.
    // Override this to pass downstream.
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    //================================================================================
    // IQualityControl methods
    //================================================================================

    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    STDMETHODIMP SetSink(IQualityControl * piqc);

    // --- helper methods ---

    // Returns true if the pin is connected. false otherwise.
    BOOL IsConnected(void) {return (m_Connected != NULL); };
    // Return the pin this is connected to (if any)
    IPin * GetConnected() { return m_Connected; };

    // Check if our filter is currently stopped
    BOOL IsStopped() {
        return (m_pFilter->m_State == State_Stopped);
    };

    // find out the current type version (used by enumerators)
    virtual LONG GetMediaTypeVersion();
    void IncrementTypeVersion();

    // switch the pin to active (paused or running) mode
    // not an error to call this if already active
    virtual HRESULT Active(void);

    // switch the pin to inactive state - may already be inactive
    virtual HRESULT Inactive(void);

    // Notify of Run() from filter
    virtual HRESULT Run(REFERENCE_TIME tStart);

    // check if the pin can support this specific proposed type and format
    virtual HRESULT CheckMediaType(const CMediaType *) PURE;

    // set the connection to use this format (previously agreed)
    virtual HRESULT SetMediaType(const CMediaType *);

    // check that the connection is ok before verifying it
    // can be overridden eg to check what interfaces will be supported.
    virtual HRESULT CheckConnect(IPin *);

    // Set and release resources required for a connection
    virtual HRESULT BreakConnect();
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // returns the preferred formats for a pin
    virtual HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // access to NewSegment values
    REFERENCE_TIME CurrentStopTime() {
        return m_tStop;
    }
    REFERENCE_TIME CurrentStartTime() {
        return m_tStart;
    }
    double CurrentRate() {
        return m_dRate;
    }

    //  Access name
    LPWSTR Name() { return m_pName; };

};


//=====================================================================
//=====================================================================
// Defines CEnumPins
//
// Pin enumerator class that works by calling CBaseFilter. This interface
// is provided by CBaseFilter::EnumPins and calls GetPinCount() and
// GetPin() to enumerate existing pins. Needs to be a separate object so
// that it can be cloned (creating an existing object at the same
// position in the enumeration)
//
// NOTE It overrides the non delegating IUnknown so that it can not
// only keep it's own reference counting lifetime but it will also still
// delegate to the outer owner. This ensures the owner is around all the
// time we are
//=====================================================================
//=====================================================================

class CEnumPins : public IEnumPins      // The interface we support
{
    int m_Position;                 // Current ordinal position
    int m_PinCount;                 // Number of pins available
    CBaseFilter *m_pFilter;         // The filter who owns us
    LONG m_Version;                 // Pin version information
    LONG m_cRef;

    typedef CGenericList<CBasePin> CPinList;

    CPinList m_PinCache;	    // These pointers have not been AddRef'ed and
				    // so they should not be dereferenced.  They are
				    // merely kept to ID which pins have been enumerated.

#ifdef DEBUG
    DWORD m_dwCookie;
#endif

    /* If while we are retrieving a pin for example from the filter an error
       occurs we assume that our internal state is stale with respect to the
       filter (someone may have deleted all the pins). We can check before
       starting whether or not the operation is likely to fail by asking the
       filter what it's current version number is. If the filter has not
       overriden the GetPinVersion method then this will always match */

    BOOL AreWeOutOfSync() {
        return (m_pFilter->GetPinVersion() == m_Version ? FALSE : TRUE);
    };

    /* This method performs the same operations as Reset, except is does not clear
       the cache of pins already enumerated. */

    STDMETHODIMP Refresh();

public:

    CEnumPins(
        CBaseFilter *pFilter,
        CEnumPins *pEnumPins);

    virtual ~CEnumPins();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumPins
    STDMETHODIMP Next(
        ULONG cPins,         // place this many pins...
        IPin ** ppPins,      // ...in this array of IPin*
        ULONG * pcFetched    // actual count passed returned here
    );

    STDMETHODIMP Skip(ULONG cPins);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumPins **ppEnum);


};


//=====================================================================
//=====================================================================
// Defines CEnumMediaTypes
//
// Enumerates the preferred formats for input and output pins
//=====================================================================
//=====================================================================

class CEnumMediaTypes : public IEnumMediaTypes    // The interface we support
{
    int m_Position;           // Current ordinal position
    CBasePin *m_pPin;         // The pin who owns us
    LONG m_Version;           // Media type version value
    LONG m_cRef;
#ifdef DEBUG
    DWORD m_dwCookie;
#endif

    /* The media types a filter supports can be quite dynamic so we add to
       the general IEnumXXXX interface the ability to be signaled when they
       change via an event handle the connected filter supplies. Until the
       Reset method is called after the state changes all further calls to
       the enumerator (except Reset) will return E_UNEXPECTED error code */

    BOOL AreWeOutOfSync() {
        return (m_pPin->GetMediaTypeVersion() == m_Version ? FALSE : TRUE);
    };

public:

    CEnumMediaTypes(
        CBasePin *pPin,
        CEnumMediaTypes *pEnumMediaTypes);

    virtual ~CEnumMediaTypes();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumMediaTypes
    STDMETHODIMP Next(
        ULONG cMediaTypes,          // place this many pins...
        AM_MEDIA_TYPE ** ppMediaTypes,  // ...in this array
        ULONG * pcFetched           // actual count passed
    );

    STDMETHODIMP Skip(ULONG cMediaTypes);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumMediaTypes **ppEnum);
};




//=====================================================================
//=====================================================================
// Defines CBaseOutputPin
//
// class derived from CBasePin that can pass buffers to a connected pin
// that supports IMemInputPin. Supports IPin.
//
// Derive your output pin from this.
//
//=====================================================================
//=====================================================================

class  AM_NOVTABLE CBaseOutputPin : public CBasePin
{

protected:

    IMemAllocator *m_pAllocator;
    IMemInputPin *m_pInputPin;        // interface on the downstreaminput pin
                                      // set up in CheckConnect when we connect.

public:

    CBaseOutputPin(
        TCHAR *pObjectName,
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr,
        LPCWSTR pName);

    // override CompleteConnect() so we can negotiate an allocator
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // negotiate the allocator and its buffer size/count and other properties
    // Calls DecideBufferSize to set properties
    virtual HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);

    // override this to set the buffer size and count. Return an error
    // if the size/count is not to your liking.
    // The allocator properties passed in are those requested by the
    // input pin - use eg the alignment and prefix members if you have
    // no preference on these.
    virtual HRESULT DecideBufferSize(
        IMemAllocator * pAlloc,
        ALLOCATOR_PROPERTIES * ppropInputRequest
    ) PURE;

    // returns an empty sample buffer from the allocator
    virtual HRESULT GetDeliveryBuffer(IMediaSample ** ppSample,
                                      REFERENCE_TIME * pStartTime,
                                      REFERENCE_TIME * pEndTime,
                                      DWORD dwFlags);

    // deliver a filled-in sample to the connected input pin
    // note - you need to release it after calling this. The receiving
    // pin will addref the sample if it needs to hold it beyond the
    // call.
    virtual HRESULT Deliver(IMediaSample *);

    // override this to control the connection
    virtual HRESULT InitAllocator(IMemAllocator **ppAlloc);
    HRESULT CheckConnect(IPin *pPin);
    HRESULT BreakConnect();

    // override to call Commit and Decommit
    HRESULT Active(void);
    HRESULT Inactive(void);

    // we have a default handling of EndOfStream which is to return
    // an error, since this should be called on input pins only
    STDMETHODIMP EndOfStream(void);

    // called from elsewhere in our filter to pass EOS downstream to
    // our connected input pin
    virtual HRESULT DeliverEndOfStream(void);

    // same for Begin/EndFlush - we handle Begin/EndFlush since it
    // is an error on an output pin, and we have Deliver methods to
    // call the methods on the connected pin
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);
    virtual HRESULT DeliverBeginFlush(void);
    virtual HRESULT DeliverEndFlush(void);

    // deliver NewSegment to connected pin - you will need to
    // override this if you queue any data in your output pin.
    virtual HRESULT DeliverNewSegment(
                        REFERENCE_TIME tStart,
                        REFERENCE_TIME tStop,
                        double dRate);

    //================================================================================
    // IQualityControl methods
    //================================================================================

    // All inherited from CBasePin and not overridden here.
    // STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    // STDMETHODIMP SetSink(IQualityControl * piqc);
};


//=====================================================================
//=====================================================================
// Defines CBaseInputPin
//
// derive your standard input pin from this.
// you need to supply GetMediaType and CheckConnect etc (see CBasePin),
// and you need to supply Receive to do something more useful.
//
//=====================================================================
//=====================================================================

class AM_NOVTABLE CBaseInputPin : public CBasePin,
                                  public IMemInputPin
{

protected:

    IMemAllocator *m_pAllocator;    // Default memory allocator

    // allocator is read-only, so received samples
    // cannot be modified (probably only relevant to in-place
    // transforms
    BYTE m_bReadOnly;

//private:  this should really be private... only the MPEG code
// currently looks at it directly and it should use IsFlushing().
    // in flushing state (between BeginFlush and EndFlush)
    // if TRUE, all Receives are returned with S_FALSE
    BYTE m_bFlushing;

    // Sample properties - initalized in Receive
    AM_SAMPLE2_PROPERTIES m_SampleProps;

public:

    CBaseInputPin(
        TCHAR *pObjectName,
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr,
        LPCWSTR pName);

    virtual ~CBaseInputPin();

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(
                    IMemAllocator * pAllocator,
                    BOOL bReadOnly);

    // override to release our stored allocator
    STDMETHODIMP Disconnect();

    // do something with this media sample
    STDMETHODIMP Receive(IMediaSample *pSample);

    // do something with these media samples
    STDMETHODIMP ReceiveMultiple (
        IMediaSample **pSamples,
        long nSamples,
        long *nSamplesProcessed);

    // See if Receive() blocks
    STDMETHODIMP ReceiveCanBlock();

    // Default handling for BeginFlush - call at the beginning
    // of your implementation (makes sure that all Receive calls
    // fail). After calling this, you need to free any queued data
    // and then call downstream.
    STDMETHODIMP BeginFlush(void);

    // default handling for EndFlush - call at end of your implementation
    // - before calling this, ensure that there is no queued data and no thread
    // pushing any more without a further receive, then call downstream,
    // then call this method to clear the m_bFlushing flag and re-enable
    // receives
    STDMETHODIMP EndFlush(void);

    // this method is optional (can return E_NOTIMPL).
    // default implementation returns E_NOTIMPL. Override if you have
    // specific alignment or prefix needs, but could use an upstream
    // allocator
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);

    // helper method to check the read-only flag
    BOOL IsReadOnly() {
        return m_bReadOnly;
    };

    // helper method to see if we are flushing
    BOOL IsFlushing() {
        return m_bFlushing;
    };

    //  Override this for checking whether it's OK to process samples
    //  Also call this from EndOfStream.
    virtual HRESULT CheckStreaming();

    // Pass a Quality notification on to the appropriate sink
    HRESULT PassNotify(Quality& q);


    //================================================================================
    // IQualityControl methods (from CBasePin)
    //================================================================================

    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // no need to override:
    // STDMETHODIMP SetSink(IQualityControl * piqc);


    // switch the pin to inactive state - may already be inactive
    virtual HRESULT Inactive(void);

    // Return sample properties pointer
    AM_SAMPLE2_PROPERTIES * SampleProps() {
        ASSERT(m_SampleProps.cbData != 0);
        return &m_SampleProps;
    }
};



//=====================================================================
//=====================================================================
// Memory allocators
//
// the shared memory transport between pins requires the input pin
// to provide a memory allocator that can provide sample objects. A
// sample object supports the IMediaSample interface.
//
// CBaseAllocator handles the management of free and busy samples. It
// allocates CMediaSample objects. CBaseAllocator is an abstract class:
// in particular it has no method of initializing the list of free
// samples. CMemAllocator is derived from CBaseAllocator and initializes
// the list of samples using memory from the standard IMalloc interface.
//
// If you want your buffers to live in some special area of memory,
// derive your allocator object from CBaseAllocator. If you derive your
// IMemInputPin interface object from CBaseMemInputPin, you will get
// CMemAllocator-based allocation etc for free and will just need to
// supply the Receive handling, and media type / format negotiation.
//=====================================================================
//=====================================================================


//=====================================================================
//=====================================================================
// Defines CMediaSample
//
// an object of this class supports IMediaSample and represents a buffer
// for media data with some associated properties. Releasing it returns
// it to a freelist managed by a CBaseAllocator derived object.
//=====================================================================
//=====================================================================

class CMediaSample : public IMediaSample2    // The interface we support
{

protected:

    friend class CBaseAllocator;

    /*  Values for dwFlags - these are used for backward compatiblity
        only now - use AM_SAMPLE_xxx
    */
    enum { Sample_SyncPoint       = 0x01,   /* Is this a sync point */
           Sample_Preroll         = 0x02,   /* Is this a preroll sample */
           Sample_Discontinuity   = 0x04,   /* Set if start of new segment */
           Sample_TypeChanged     = 0x08,   /* Has the type changed */
           Sample_TimeValid       = 0x10,   /* Set if time is valid */
           Sample_MediaTimeValid  = 0x20,   /* Is the media time valid */
           Sample_TimeDiscontinuity = 0x40, /* Time discontinuity */
           Sample_StopValid       = 0x100,  /* Stop time valid */
           Sample_ValidFlags      = 0x1FF
         };

    /* Properties, the media sample class can be a container for a format
       change in which case we take a copy of a type through the SetMediaType
       interface function and then return it when GetMediaType is called. As
       we do no internal processing on it we leave it as a pointer */

    DWORD            m_dwFlags;         /* Flags for this sample */
                                        /* Type specific flags are packed
                                           into the top word
                                        */
    DWORD            m_dwTypeSpecificFlags; /* Media type specific flags */
    LPBYTE           m_pBuffer;         /* Pointer to the complete buffer */
    LONG             m_lActual;         /* Length of data in this sample */
    LONG             m_cbBuffer;        /* Size of the buffer */
    CBaseAllocator  *m_pAllocator;      /* The allocator who owns us */
    CMediaSample     *m_pNext;          /* Chaining in free list */
    REFERENCE_TIME   m_Start;           /* Start sample time */
    REFERENCE_TIME   m_End;             /* End sample time */
    LONGLONG         m_MediaStart;      /* Real media start position */
    LONG             m_MediaEnd;        /* A difference to get the end */
    AM_MEDIA_TYPE    *m_pMediaType;     /* Media type change data */
    DWORD            m_dwStreamId;      /* Stream id */
public:
    LONG             m_cRef;            /* Reference count */


public:

    CMediaSample(
        TCHAR *pName,
        CBaseAllocator *pAllocator,
        HRESULT *phr,
        LPBYTE pBuffer = NULL,
        LONG length = 0);

    virtual ~CMediaSample();

    /* Note the media sample does not delegate to its owner */

    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // set the buffer pointer and length. Used by allocators that
    // want variable sized pointers or pointers into already-read data.
    // This is only available through a CMediaSample* not an IMediaSample*
    // and so cannot be changed by clients.
    HRESULT SetPointer(BYTE * ptr, LONG cBytes);

    // Get me a read/write pointer to this buffer's memory.
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);

    STDMETHODIMP_(LONG) GetSize(void);

    // get the stream time at which this sample should start and finish.
    STDMETHODIMP GetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );

    // Set the stream time at which this sample should start and finish.
    STDMETHODIMP SetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);

    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);

    // these allow for limited format changes in band

    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);

    // returns S_OK if there is a discontinuity in the data (this same is
    // not a continuation of the previous stream of data
    // - there has been a seek).
    STDMETHODIMP IsDiscontinuity(void);
    // set the discontinuity property - TRUE if this sample is not a
    // continuation, but a new sample after a seek.
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);

    // get the media times for this sample
    STDMETHODIMP GetMediaTime(
    	LONGLONG * pTimeStart,
	LONGLONG * pTimeEnd
    );

    // Set the media times for this sample
    STDMETHODIMP SetMediaTime(
    	LONGLONG * pTimeStart,
	LONGLONG * pTimeEnd
    );

    // Set and get properties (IMediaSample2)
    STDMETHODIMP GetProperties(
        DWORD cbProperties,
        BYTE * pbProperties
    );

    STDMETHODIMP SetProperties(
        DWORD cbProperties,
        const BYTE * pbProperties
    );
};


//=====================================================================
//=====================================================================
// Defines CBaseAllocator
//
// Abstract base class that manages a list of media samples
//
// This class provides support for getting buffers from the free list,
// including handling of commit and (asynchronous) decommit.
//
// Derive from this class and override the Alloc and Free functions to
// allocate your CMediaSample (or derived) objects and add them to the
// free list, preparing them as necessary.
//=====================================================================
//=====================================================================

class AM_NOVTABLE CBaseAllocator : public CUnknown,         // A non delegating IUnknown
                       public IMemAllocator,    // The interface we support
                       public CCritSec          // Provides object locking
{
    class CSampleList;
    friend class CSampleList;

    /*  Hack to get at protected member in CMediaSample */
    static CMediaSample * &NextSample(CMediaSample *pSample)
    {
        return pSample->m_pNext;
    };

    /*  Mini list class for the free list */
    class CSampleList
    {
    public:
        CSampleList() : m_List(NULL), m_nOnList(0) {};
#ifdef DEBUG
        ~CSampleList()
        {
            ASSERT(m_nOnList == 0);
        };
#endif
        CMediaSample *Head() const { return m_List; };
        CMediaSample *Next(CMediaSample *pSample) const { return CBaseAllocator::NextSample(pSample); };
        int GetCount() const { return m_nOnList; };
        void Add(CMediaSample *pSample)
        {
            ASSERT(pSample != NULL);
            CBaseAllocator::NextSample(pSample) = m_List;
            m_List = pSample;
            m_nOnList++;
        };
        CMediaSample *RemoveHead()
        {
            CMediaSample *pSample = m_List;
            if (pSample != NULL) {
                m_List = CBaseAllocator::NextSample(m_List);
                m_nOnList--;
            }
            return pSample;
        };
        void Remove(CMediaSample *pSample);

    public:
        CMediaSample *m_List;
        int           m_nOnList;
    };
protected:

    CSampleList m_lFree;        // Free list

    /*  Note to overriders of CBaseAllocator.

        We use a lazy signalling mechanism for waiting for samples.
        This means we don't call the OS if no waits occur.

        In order to implement this:

        1. When a new sample is added to m_lFree call NotifySample() which
           calls ReleaseSemaphore on m_hSem with a count of m_lWaiting and
           sets m_lWaiting to 0.
           This must all be done holding the allocator's critical section.

        2. When waiting for a sample call SetWaiting() which increments
           m_lWaiting BEFORE leaving the allocator's critical section.

        3. Actually wait by calling WaitForSingleObject(m_hSem, INFINITE)
           having left the allocator's critical section.  The effect of
           this is to remove 1 from the semaphore's count.  You MUST call
           this once having incremented m_lWaiting.

        The following are then true when the critical section is not held :
            (let nWaiting = number about to wait or waiting)

            (1) if (m_lFree.GetCount() != 0) then (m_lWaiting == 0)
            (2) m_lWaiting + Semaphore count == nWaiting

        We would deadlock if
           nWaiting != 0 &&
           m_lFree.GetCount() != 0 &&
           Semaphore count == 0

           But from (1) if m_lFree.GetCount() != 0 then m_lWaiting == 0 so
           from (2) Semaphore count == nWaiting (which is non-0) so the
           deadlock can't happen.
    */

    HANDLE m_hSem;              // For signalling
    long m_lWaiting;            // Waiting for a free element
    long m_lCount;              // how many buffers we have agreed to provide
    long m_lAllocated;          // how many buffers are currently allocated
    long m_lSize;               // agreed size of each buffer
    long m_lAlignment;          // agreed alignment
    long m_lPrefix;             // agreed prefix (preceeds GetPointer() value)
    BOOL m_bChanged;            // Have the buffer requirements changed

    // if true, we are decommitted and can't allocate memory
    BOOL m_bCommitted;
    // if true, the decommit has happened, but we haven't called Free yet
    // as there are still outstanding buffers
    BOOL m_bDecommitInProgress;

    // called to decommit the memory when the last buffer is freed
    // pure virtual - need to override this
    virtual void Free(void) PURE;

    // override to allocate the memory when commit called
    virtual HRESULT Alloc(void);

public:

    CBaseAllocator(TCHAR *, LPUNKNOWN, HRESULT *, BOOL bEvent = TRUE);
    virtual ~CBaseAllocator();

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual);

    // return the properties actually being used on this allocator
    STDMETHODIMP GetProperties(
		    ALLOCATOR_PROPERTIES* pProps);

    // override Commit to allocate memory. We handle the GetBuffer
    //state changes
    STDMETHODIMP Commit();

    // override this to handle the memory freeing. We handle any outstanding
    // GetBuffer calls
    STDMETHODIMP Decommit();

    // get container for a sample. Blocking, synchronous call to get the
    // next free buffer (as represented by an IMediaSample interface).
    // on return, the time etc properties will be invalid, but the buffer
    // pointer and size will be correct. The two time parameters are
    // optional and either may be NULL, they may alternatively be set to
    // the start and end times the sample will have attached to it
    // bPrevFramesSkipped is not used (used only by the video renderer's
    // allocator where it affects quality management in direct draw).

    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                           REFERENCE_TIME * pStartTime,
                           REFERENCE_TIME * pEndTime,
                           DWORD dwFlags);

    // final release of a CMediaSample will call this
    STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);
    // obsolete:: virtual void PutOnFreeList(CMediaSample * pSample);

    // Notify that a sample is available
    void NotifySample();

    // Notify that we're waiting for a sample
    void SetWaiting() { m_lWaiting++; };
};


//=====================================================================
//=====================================================================
// Defines CMemAllocator
//
// this is an allocator based on CBaseAllocator that allocates sample
// buffers in main memory (from 'new'). You must call SetProperties
// before calling Commit.
//
// we don't free the memory when going into Decommit state. The simplest
// way to implement this without complicating CBaseAllocator is to
// have a Free() function, called to go into decommit state, that does
// nothing and a ReallyFree function called from our destructor that
// actually frees the memory.
//=====================================================================
//=====================================================================

//  Make me one from quartz.dll
STDAPI CreateMemoryAllocator(IMemAllocator **ppAllocator);

class CMemAllocator : public CBaseAllocator
{

protected:

    LPBYTE m_pBuffer;   // combined memory for all buffers

    // override to free the memory when decommit completes
    // - we actually do nothing, and save the memory until deletion.
    void Free(void);

    // called from the destructor (and from Alloc if changing size/count) to
    // actually free up the memory
    void ReallyFree(void);

    // overriden to allocate the memory when commit called
    HRESULT Alloc(void);

public:
    /* This goes in the factory template table to create new instances */
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual);

    CMemAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMemAllocator();
};

// helper used by IAMovieSetup implementation
STDAPI
AMovieSetupRegisterFilter( const AMOVIESETUP_FILTER * const psetupdata
                         , IFilterMapper *                  pIFM
                         , BOOL                             bRegister  );


#endif /* __FILTER__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\amvideo.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Video related definitions and interfaces for ActiveMovie

#ifndef __AMVIDEO__
#define __AMVIDEO__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <ddraw.h>


// This is an interface on the video renderer that provides information about
// DirectDraw with respect to its use by the renderer. For example it allows
// an application to get details of the surface and any hardware capabilities
// that are available. It also allows someone to adjust the surfaces that the
// renderer should use and furthermore even set the DirectDraw instance. We
// allow someone to set the DirectDraw instance because DirectDraw can only
// be opened once per process so it helps resolve conflicts. There is some
// duplication in this interface as the hardware/emulated/FOURCCs available
// can all be found through the IDirectDraw interface, this interface allows
// simple access to that information without calling the DirectDraw provider
// itself. The AMDDS prefix is ActiveMovie DirectDraw Switches abbreviated.

#define AMDDS_NONE 0x00             // No use for DCI/DirectDraw
#define AMDDS_DCIPS 0x01            // Use DCI primary surface
#define AMDDS_PS 0x02               // Use DirectDraw primary
#define AMDDS_RGBOVR 0x04           // RGB overlay surfaces
#define AMDDS_YUVOVR 0x08           // YUV overlay surfaces
#define AMDDS_RGBOFF 0x10           // RGB offscreen surfaces
#define AMDDS_YUVOFF 0x20           // YUV offscreen surfaces
#define AMDDS_RGBFLP 0x40           // RGB flipping surfaces
#define AMDDS_YUVFLP 0x80           // YUV flipping surfaces
#define AMDDS_ALL 0xFF              // ALL the previous flags
#define AMDDS_DEFAULT AMDDS_ALL     // Use all available surfaces

#define AMDDS_YUV (AMDDS_YUVOFF | AMDDS_YUVOVR | AMDDS_YUVFLP)
#define AMDDS_RGB (AMDDS_RGBOFF | AMDDS_RGBOVR | AMDDS_RGBFLP)
#define AMDDS_PRIMARY (AMDDS_DCIPS | AMDDS_PS)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IDirectDrawVideo

DECLARE_INTERFACE_(IDirectDrawVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDirectDrawVideo methods

    STDMETHOD(GetSwitches)(THIS_ DWORD *pSwitches) PURE;
    STDMETHOD(SetSwitches)(THIS_ DWORD Switches) PURE;
    STDMETHOD(GetCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetEmulatedCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ DDSURFACEDESC *pSurfaceDesc) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_ DWORD *pCount,DWORD *pCodes) PURE;
    STDMETHOD(SetDirectDraw)(THIS_ LPDIRECTDRAW pDirectDraw) PURE;
    STDMETHOD(GetDirectDraw)(THIS_ LPDIRECTDRAW *ppDirectDraw) PURE;
    STDMETHOD(GetSurfaceType)(THIS_ DWORD *pSurfaceType) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
    STDMETHOD(UseScanLine)(THIS_ long UseScanLine) PURE;
    STDMETHOD(CanUseScanLine)(THIS_ long *UseScanLine) PURE;
    STDMETHOD(UseOverlayStretch)(THIS_ long UseOverlayStretch) PURE;
    STDMETHOD(CanUseOverlayStretch)(THIS_ long *UseOverlayStretch) PURE;
    STDMETHOD(UseWhenFullScreen)(THIS_ long UseWhenFullScreen) PURE;
    STDMETHOD(WillUseFullScreen)(THIS_ long *UseWhenFullScreen) PURE;
};


// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IQualProp

DECLARE_INTERFACE_(IQualProp, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Compare these with the functions in class CGargle in gargle.h

    STDMETHOD(get_FramesDroppedInRenderer)(THIS_ int *pcFrames) PURE;  // Out
    STDMETHOD(get_FramesDrawn)(THIS_ int *pcFramesDrawn) PURE;         // Out
    STDMETHOD(get_AvgFrameRate)(THIS_ int *piAvgFrameRate) PURE;       // Out
    STDMETHOD(get_Jitter)(THIS_ int *iJitter) PURE;                    // Out
    STDMETHOD(get_AvgSyncOffset)(THIS_ int *piAvg) PURE;               // Out
    STDMETHOD(get_DevSyncOffset)(THIS_ int *piDev) PURE;               // Out
};


// This interface allows an application or plug in distributor to control a
// full screen renderer. The Modex renderer supports this interface. When
// connected a renderer should load the display modes it has available
// The number of modes available can be obtained through CountModes. Then
// information on each individual mode is available by calling GetModeInfo
// and IsModeAvailable. An application may enable and disable any modes
// by calling the SetEnabled flag with OATRUE or OAFALSE (not C/C++ TRUE
// and FALSE values) - the current value may be queried by IsModeEnabled

// A more generic way of setting the modes enabled that is easier to use
// when writing applications is the clip loss factor. This defines the
// amount of video that can be lost when deciding which display mode to
// use. Assuming the decoder cannot compress the video then playing an
// MPEG file (say 352x288) into a 320x200 display will lose about 25% of
// the image. The clip loss factor specifies the upper range permissible.
// To allow typical MPEG video to be played in 320x200 it defaults to 25%

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideo

DECLARE_INTERFACE_(IFullScreenVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
};


// This adds the accelerator table capabilities in fullscreen. This is being
// added between the original runtime release and the full SDK release. We
// cannot just add the method to IFullScreenVideo as we don't want to force
// applications to have to ship the ActiveMovie support DLLs - this is very
// important to applications that plan on being downloaded over the Internet

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideoEx

DECLARE_INTERFACE_(IFullScreenVideoEx, IFullScreenVideo)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;

    // IFullScreenVideoEx

    STDMETHOD(SetAcceleratorTable)(THIS_ HWND hwnd,HACCEL hAccel) PURE;
    STDMETHOD(GetAcceleratorTable)(THIS_ HWND *phwnd,HACCEL *phAccel) PURE;
    STDMETHOD(KeepPixelAspectRatio)(THIS_ long KeepAspect) PURE;
    STDMETHOD(IsKeepPixelAspectRatio)(THIS_ long *pKeepAspect) PURE;
};


// The SDK base classes contain a base video mixer class. Video mixing in a
// software environment is tricky because we typically have multiple streams
// each sending data at unpredictable times. To work with this we defined a
// pin that is the lead pin, when data arrives on this pin we do a mix. As
// an alternative we may not want to have a lead pin but output samples at
// predefined spaces, like one every 1/15 of a second, this interfaces also
// supports that mode of operations (there is a working video mixer sample)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IBaseVideoMixer

DECLARE_INTERFACE_(IBaseVideoMixer, IUnknown)
{
    STDMETHOD(SetLeadPin)(THIS_ int iPin) PURE;
    STDMETHOD(GetLeadPin)(THIS_ int *piPin) PURE;
    STDMETHOD(GetInputPinCount)(THIS_ int *piPinCount) PURE;
    STDMETHOD(IsUsingClock)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetUsingClock)(THIS_ int bValue) PURE;
    STDMETHOD(GetClockPeriod)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetClockPeriod)(THIS_ int bValue) PURE;
};

#define iPALETTE_COLORS 256     // Maximum colours in palette
#define iEGA_COLORS 16          // Number colours in EGA palette
#define iMASK_COLORS 3          // Maximum three components
#define iTRUECOLOR 16           // Minimum true colour device
#define iRED 0                  // Index position for RED mask
#define iGREEN 1                // Index position for GREEN mask
#define iBLUE 2                 // Index position for BLUE mask
#define iPALETTE 8              // Maximum colour depth using a palette
#define iMAXBITS 8              // Maximum bits per colour component


// Used for true colour images that also have a palette

typedef struct tag_TRUECOLORINFO {
    DWORD   dwBitMasks[iMASK_COLORS];
    RGBQUAD bmiColors[iPALETTE_COLORS];
} TRUECOLORINFO;


// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target

typedef struct tagVIDEOINFOHEADER {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

} VIDEOINFOHEADER;

// make sure the pbmi is initialized before using these macros
#define TRUECOLOR(pbmi)  ((TRUECOLORINFO *)(((LPBYTE)&((pbmi)->bmiHeader)) \
					+ (pbmi)->bmiHeader.biSize))
#define COLORS(pbmi)	((RGBQUAD *)(((LPBYTE)&((pbmi)->bmiHeader)) 	\
					+ (pbmi)->bmiHeader.biSize))
#define BITMASKS(pbmi)	((DWORD *)(((LPBYTE)&((pbmi)->bmiHeader)) 	\
					+ (pbmi)->bmiHeader.biSize))

// All the image based filters use this to communicate their media types. It's
// centred principally around the BITMAPINFO. This structure always contains a
// BITMAPINFOHEADER followed by a number of other fields depending on what the
// BITMAPINFOHEADER contains. If it contains details of a palettised format it
// will be followed by one or more RGBQUADs defining the palette. If it holds
// details of a true colour format then it may be followed by a set of three
// DWORD bit masks that specify where the RGB data can be found in the image
// (For more information regarding BITMAPINFOs see the Win32 documentation)

// The rcSource and rcTarget fields are not for use by filters supplying the
// data. The destination (target) rectangle should be set to all zeroes. The
// source may also be zero filled or set with the dimensions of the video. So
// if the video is 352x288 pixels then set it to (0,0,352,288). These fields
// are mainly used by downstream filters that want to ask the source filter
// to place the image in a different position in an output buffer. So when
// using for example the primary surface the video renderer may ask a filter
// to place the video images in a destination position of (100,100,452,388)
// on the display since that's where the window is positioned on the display

// !!! WARNING !!!
// DO NOT use this structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagVIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

    union {
        RGBQUAD         bmiColors[iPALETTE_COLORS];     // Colour palette
        DWORD           dwBitMasks[iMASK_COLORS];       // True colour masks
        TRUECOLORINFO   TrueColorInfo;                  // Both of the above
    };

} VIDEOINFO;

// These macros define some standard bitmap format sizes

#define SIZE_EGA_PALETTE (iEGA_COLORS * sizeof(RGBQUAD))
#define SIZE_PALETTE (iPALETTE_COLORS * sizeof(RGBQUAD))
#define SIZE_MASKS (iMASK_COLORS * sizeof(DWORD))
#define SIZE_PREHEADER (FIELD_OFFSET(VIDEOINFOHEADER,bmiHeader))
#define SIZE_VIDEOHEADER (sizeof(BITMAPINFOHEADER) + SIZE_PREHEADER)
// !!! for abnormal biSizes
// #define SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + SIZE_PREHEADER)

// DIBSIZE calculates the number of bytes required by an image

#define WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define _DIBSIZE(bi) (DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(_DIBSIZE(bi)) : _DIBSIZE(bi))

// This compares the bit masks between two VIDEOINFOHEADERs

#define BIT_MASKS_MATCH(pbmi1,pbmi2)                                \
    (((pbmi1)->dwBitMasks[iRED] == (pbmi2)->dwBitMasks[iRED]) &&        \
     ((pbmi1)->dwBitMasks[iGREEN] == (pbmi2)->dwBitMasks[iGREEN]) &&    \
     ((pbmi1)->dwBitMasks[iBLUE] == (pbmi2)->dwBitMasks[iBLUE]))

// These zero fill different parts of the VIDEOINFOHEADER structure

// Only use these macros for pbmi's with a normal BITMAPINFOHEADER biSize
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(pbmi)->dwBitFields,SIZE_MASKS))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi),SIZE_VIDEOHEADER))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(pbmi)->bmiColors,SIZE_PALETTE));

#if 0
// !!! This is the right way to do it, but may break existing code
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
			(pbmi)->bmiHeader.biSize,SIZE_MASKS)))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi), SIZE_PREHEADER +	    \
			sizeof(BITMAPINFOHEADER)))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
			(pbmi)->bmiHeader.biSize,SIZE_PALETTE))
#endif

// Other (hopefully) useful bits and bobs

#define PALETTISED(pbmi) ((pbmi)->bmiHeader.biBitCount <= iPALETTE)
#define PALETTE_ENTRIES(pbmi) ((DWORD) 1 << (pbmi)->bmiHeader.biBitCount)

// Returns the address of the BITMAPINFOHEADER from the VIDEOINFOHEADER
#define HEADER(pVideoInfo) (&(((VIDEOINFOHEADER *) (pVideoInfo))->bmiHeader))


// MPEG variant - includes a DWORD length followed by the
// video sequence header after the video header.
//
// The sequence header includes the sequence header start code and the
// quantization matrices associated with the first sequence header in the
// stream so is a maximum of 140 bytes long.

typedef struct tagMPEG1VIDEOINFO {

    VIDEOINFOHEADER hdr;                    // Compatible with VIDEOINFO
    DWORD           dwStartTimeCode;        // 25-bit Group of pictures time code
                                            // at start of data
    DWORD           cbSequenceHeader;       // Length in bytes of bSequenceHeader
    BYTE            bSequenceHeader[1];     // Sequence header including
                                            // quantization matrices if any
} MPEG1VIDEOINFO;

#define MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)


// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagAnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} ANALOGVIDEOINFO;


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMVIDEO__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\amvideo.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Helper functions for bitmap formats, March 1995

#include <streams.h>
#include <limits.h>

// These are bit field masks for true colour devices

const DWORD bits555[] = {0x007C00,0x0003E0,0x00001F};
const DWORD bits565[] = {0x00F800,0x0007E0,0x00001F};
const DWORD bits888[] = {0xFF0000,0x00FF00,0x0000FF};

// This maps bitmap subtypes into a bits per pixel value and also a name

const struct {
    const GUID *pSubtype;
    WORD BitCount;
    TCHAR *pName;
} BitCountMap[] = { &MEDIASUBTYPE_RGB1,        1,   TEXT("RGB Monochrome"),
                    &MEDIASUBTYPE_RGB4,        4,   TEXT("RGB VGA"),
                    &MEDIASUBTYPE_RGB8,        8,   TEXT("RGB 8"),
                    &MEDIASUBTYPE_RGB565,      16,  TEXT("RGB 565 (16 bit)"),
                    &MEDIASUBTYPE_RGB555,      16,  TEXT("RGB 555 (16 bit)"),
                    &MEDIASUBTYPE_RGB24,       24,  TEXT("RGB 24"),
                    &MEDIASUBTYPE_RGB32,       32,  TEXT("RGB 32"),
                    &MEDIASUBTYPE_Overlay,     0,   TEXT("Overlay"),
                    &GUID_NULL,                0,   TEXT("UNKNOWN") };


// Return the size of the bitmap as defined by this header

STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader)
{
    return DIBSIZE(*pHeader);
}


// This is called if the header has a 16 bit colour depth and needs to work
// out the detailed type from the bit fields (either RGB 565 or RGB 555)

STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader)
{
    BITMAPINFO *pbmInfo = (BITMAPINFO *) pbmiHeader;
    ASSERT(pbmiHeader->biBitCount == 16);

    // If its BI_RGB then it's RGB 555 by default

    if (pbmiHeader->biCompression == BI_RGB) {
        return MEDIASUBTYPE_RGB555;
    }

    // Compare the bit fields with RGB 555

    DWORD *pMask = (DWORD *) pbmInfo->bmiColors;
    if (pMask[0] == bits555[0]) {
        if (pMask[1] == bits555[1]) {
            if (pMask[2] == bits555[2]) {
                return MEDIASUBTYPE_RGB555;
            }
        }
    }

    // Compare the bit fields with RGB 565

    pMask = (DWORD *) pbmInfo->bmiColors;
    if (pMask[0] == bits565[0]) {
        if (pMask[1] == bits565[1]) {
            if (pMask[2] == bits565[2]) {
                return MEDIASUBTYPE_RGB565;
            }
        }
    }
    return GUID_NULL;
}


// Given a BITMAPINFOHEADER structure this returns the GUID sub type that is
// used to describe it in format negotiations. For example a video codec fills
// in the format block with a VIDEOINFO structure, it also fills in the major
// type with MEDIATYPE_VIDEO and the subtype with a GUID that matches the bit
// count, for example if it is an eight bit image then MEDIASUBTYPE_RGB8

STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader)
{
    ASSERT(pbmiHeader);

    // If it's not RGB then create a GUID from the compression type

    if (pbmiHeader->biCompression != BI_RGB) {
        if (pbmiHeader->biCompression != BI_BITFIELDS) {
            FOURCCMap FourCCMap(pbmiHeader->biCompression);
            return (const GUID) FourCCMap;
        }
    }

    // Map the RGB DIB bit depth to a image GUID

    switch(pbmiHeader->biBitCount) {
        case 1    :   return MEDIASUBTYPE_RGB1;
        case 4    :   return MEDIASUBTYPE_RGB4;
        case 8    :   return MEDIASUBTYPE_RGB8;
        case 16   :   return GetTrueColorType(pbmiHeader);
        case 24   :   return MEDIASUBTYPE_RGB24;
        case 32   :   return MEDIASUBTYPE_RGB32;
    }
    return GUID_NULL;
}


// Given a video bitmap subtype we return the number of bits per pixel it uses
// We return a WORD bit count as thats what the BITMAPINFOHEADER uses. If the
// GUID subtype is not found in the table we return an invalid USHRT_MAX

STDAPI_(WORD) GetBitCount(const GUID *pSubtype)
{
    ASSERT(pSubtype);
    const GUID *pMediaSubtype;
    INT iPosition = 0;

    // Scan the mapping list seeing if the source GUID matches any known
    // bitmap subtypes, the list is terminated by a GUID_NULL entry

    while (TRUE) {
        pMediaSubtype = BitCountMap[iPosition].pSubtype;
        if (IsEqualGUID(*pMediaSubtype,GUID_NULL)) {
            return USHRT_MAX;
        }
        if (IsEqualGUID(*pMediaSubtype,*pSubtype)) {
            return BitCountMap[iPosition].BitCount;
        }
        iPosition++;
    }
}


// Given a bitmap subtype we return a description name that can be used for
// debug purposes. In a retail build this function still returns the names
// If the subtype isn't found in the lookup table we return string UNKNOWN

STDAPI_(TCHAR *) GetSubtypeName(const GUID *pSubtype)
{
    ASSERT(pSubtype);
    const GUID *pMediaSubtype;
    INT iPosition = 0;

    // Scan the mapping list seeing if the source GUID matches any known
    // bitmap subtypes, the list is terminated by a GUID_NULL entry

    while (TRUE) {
        pMediaSubtype = BitCountMap[iPosition].pSubtype;
        if (IsEqualGUID(*pMediaSubtype,*pSubtype)) {
            return BitCountMap[iPosition].pName;
        }
        if (IsEqualGUID(*pMediaSubtype,GUID_NULL)) {
            return TEXT("UNKNOWN");
        }
        iPosition++;
    }
}


// The mechanism for describing a bitmap format is with the BITMAPINFOHEADER
// This is really messy to deal with because it invariably has fields that
// follow it holding bit fields, palettes and the rest. This function gives
// the number of bytes required to hold a VIDEOINFO that represents it. This
// count includes the prefix information (like the rcSource rectangle) the
// BITMAPINFOHEADER field, and any other colour information on the end.
//
// WARNING If you want to copy a BITMAPINFOHEADER into a VIDEOINFO always make
// sure that you use the HEADER macro because the BITMAPINFOHEADER field isn't
// right at the start of the VIDEOINFO (there are a number of other fields),
//
//     CopyMemory(HEADER(pVideoInfo),pbmi,sizeof(BITMAPINFOHEADER));
//

STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader)
{
    // Everyone has this to start with this  
    LONG Size = SIZE_PREHEADER + pHeader->biSize;

    ASSERT(pHeader->biSize >= sizeof(BITMAPINFOHEADER));
    
    // Does this format use a palette, if the number of colours actually used
    // is zero then it is set to the maximum that are allowed for that colour
    // depth (an example is 256 for eight bits). Truecolour formats may also
    // pass a palette with them in which case the used count is non zero

    // This would scare me.
    ASSERT(pHeader->biBitCount <= iPALETTE || pHeader->biClrUsed == 0);

    if (pHeader->biBitCount <= iPALETTE || pHeader->biClrUsed) {
        LONG Entries = (DWORD) 1 << pHeader->biBitCount;
        if (pHeader->biClrUsed) {
            Entries = pHeader->biClrUsed;
        }
        Size += Entries * sizeof(RGBQUAD);
    }

    // Truecolour formats may have a BI_BITFIELDS specifier for compression
    // type which means that room for three DWORDs should be allocated that
    // specify where in each pixel the RGB colour components may be found

    if (pHeader->biCompression == BI_BITFIELDS) {
        Size += SIZE_MASKS;
    }

    // A BITMAPINFO for a palettised image may also contain a palette map that
    // provides the information to map from a source palette to a destination
    // palette during a BitBlt for example, because this information is only
    // ever processed during drawing you don't normally store the palette map
    // nor have any way of knowing if it is present in the data structure

    return Size;
}


// Returns TRUE if the VIDEOINFO contains a palette

STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo)
{
    if (PALETTISED(pVideoInfo) == FALSE) {
        if (pVideoInfo->bmiHeader.biClrUsed == 0) {
            return FALSE;
        }
    }
    return TRUE;
}


// Return a pointer to the first entry in a palette

STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo)
{
    if (pVideoInfo->bmiHeader.biCompression == BI_BITFIELDS) {
        return TRUECOLOR(pVideoInfo)->bmiColors;
    }
    return COLORS(pVideoInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\lmrtrend\lmrtrend.cpp ===
#include <streams.h>
#include <urlmon.h>
#include <atlbase.h>
#include <ddrawex.h>
#include <htmlfilter.h>


// ! copied from h\evcodei.h in the netshow tree.
#define EC_VIDEOFRAMEREADY		    0x49
// (void, void) : application
// sent to notify the application that the first video frame is about to be drawn


// Things that are still really broken:
//
// RefCount issues, could be really an OCX problem instead
// Position reporting, why isn't this working?
// seeking, respecting run/pause
//


#ifdef FILTER_DLL
#include <initguid.h>
#endif

#pragma warning(disable:4355)

#include "lmrtrend.h"

// Setup data

const IID IID_ILMReader = {0x183C2599,0x0480,0x11d1,{0x87,0xEA,0x00,0xC0,0x4F,0xC2,0x9D,0x46}};

const AMOVIESETUP_MEDIATYPE sudLMRTPinTypes[] =
{
    { &MEDIATYPE_LMRT, &MEDIASUBTYPE_NULL }
};

const AMOVIESETUP_PIN sudLMRTPin =
{
    L"Input",                     // The Pins name
    TRUE,                         // Is rendered
    FALSE,                        // Is an output pin
    FALSE,                        // Allowed none
    FALSE,                        // Allowed many
    &CLSID_NULL,                  // Connects to filter
    NULL,                         // Connects to pin
    NUMELMS(sudLMRTPinTypes),     // Number of types
    sudLMRTPinTypes               // Pin details
};

const AMOVIESETUP_FILTER sudLMRTRend =
{
    &CLSID_LMRTRenderer,            // Filter CLSID
    L"Internal LMRT Renderer",      // String name
    MERIT_PREFERRED + 1,            // Filter merit high, since we're the only one who likes this type
    1,                              // Number of pins
    &sudLMRTPin                     // Pin details
};

AMOVIESETUP_MEDIATYPE sudURLSPinTypes[] =   {
  &MEDIATYPE_URL_STREAM,        // clsMajorType
  &MEDIATYPE_URL_STREAM };      // clsMinorType

AMOVIESETUP_PIN sudURLSPins[] =
{
  { L"Input"                    // strName
    , TRUE                      // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , 0                         // strConnectsToPin
    , NUMELMS(sudURLSPinTypes)  // nTypes
    , sudURLSPinTypes           // lpTypes
  }
};


const AMOVIESETUP_FILTER sudURLS =
{
  &CLSID_UrlStreamRenderer      // clsID
  , L"URL StreamRenderer"       // strName
  , MERIT_NORMAL                // dwMerit
  , NUMELMS(sudURLSPins)        // nPins
  , sudURLSPins                 // lpPin
};



CFactoryTemplate g_Templates[] = {
    { L"Internal LMRT Renderer" , &CLSID_LMRTRenderer , CLMRTRenderer::CreateInstance , NULL , &sudLMRTRend },
    {L"URL StreamRenderer", &CLSID_UrlStreamRenderer, CUrlStreamRenderer::CreateInstance, NULL, &sudURLS},
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}



//
CLMRTRenderer::CLMRTRenderer(LPUNKNOWN pUnk,HRESULT *phr) :
    CBaseRenderer(CLSID_LMRTRenderer, NAME("LMRT Filter"), pUnk, phr),
    m_fFirstPause(true),
    m_pbFirstPacketFromHeader(0)
{
//	m_pIbsc = NULL;
	m_pEngine = NULL;
	m_pReader = 0;
	m_punkControl = 0;
//	HGLOBAL hMem = GlobalAlloc(GMEM_FIXED, 10000); 
//	m_pMem = (BYTE*)hMem;
//	m_dwSize = 0;
//	CreateStreamOnHGlobal(hMem, true, &m_pstm);
	m_dwWidth = 0;
	m_dwHeight = 0;
//         DbgLog((LOG_TRACE, 0, TEXT("**** m_cRef: %08x = %d"), &m_cRef, m_cRef));
//         if(GetFileAttributes(TEXT("C:/kassert")) != 0xFFFFFFFF) {
//             _asm int 3
//         }
} // (Constructor)


//
// Destructor
//
CLMRTRenderer::~CLMRTRenderer()
{
    // we artificially lowered our reference count after calling
    // put_ViewerControl.
    AddRef();
    AddRef();

//  if (m_pIbsc)
//	m_pIbsc->Release();
    if (m_pEngine)
        m_pEngine->Release();
    if (m_pReader) {
        LONG l = m_pReader->Release();
        ASSERT(l == 0);
    }
    if (m_punkControl)
        m_punkControl->Release();
    //  if (m_pstm)
    //	m_pstm->Release();

    delete[] m_pbFirstPacketFromHeader;
}


//
// CreateInstance
//
// This goes in the factory template table to create new instances
//
CUnknown * WINAPI CLMRTRenderer::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CLMRTRenderer *pLMRTFilter = new CLMRTRenderer(pUnk,phr);
    if (pLMRTFilter == NULL) {
        return NULL;
    }
    return (CBaseMediaFilter *) pLMRTFilter;

} // CreateInstance



// !!! stolen from atlctl.cpp

#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

void ConvertPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    int nPixelsPerInchX = 0;    // Pixels per logical inch along width
    int nPixelsPerInchY = 0;    // Pixels per logical inch along height

    HDC hDCScreen = GetDC(NULL);
    nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
    nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
    ReleaseDC(NULL, hDCScreen);

    if (!nPixelsPerInchX || !nPixelsPerInchY)
	return;

    lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, nPixelsPerInchX);
    lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, nPixelsPerInchY);
}


//
// NonDelegatingQueryInterface
//
// Overriden to say what interfaces we support and where
//
STDMETHODIMP
CLMRTRenderer::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
//         // explicity disable seeking.
//         return E_NOINTERFACE;
    } else if (riid == IID_ILMRTRenderer) {
	return GetInterface((ILMRTRenderer *)this, ppv);
    } else if (riid == IID_IOleObject ||
    	   riid == IID_IOleInPlaceObjectWindowless ||
	       riid == IID_IOleInPlaceObject ||
	       riid == IID_IViewObject ||
	       riid == IID_IViewObject2 ||
	       riid == IID_IOleWindow ||
	       riid == IID_IOleControl ||
	       riid == IID_IOleObject ||
	       riid == IID_IQuickActivate ||
	       riid == IID_ISpecifyPropertyPages ||
	       riid == IID_IDAViewerControl ||
	       riid == IID_IDASite ||
	       riid == IID_IDAViewSite ||
	       riid == IID_IDispatch ||
	       riid == IID_IOleInPlaceActiveObject ||
	       riid == IID_IViewObjectEx) { // !!! is this a complete list of interfaces?
	// in the standalone case, we aggregate the DAViewer control
	if (!m_punkControl) {
	    HRESULT hr = S_OK; 
	    // create the DA control aggregated 
        bool bTridentServicesAvailable = false;
        
        // TODO: Enable this if/when the embedded case will work windowless.
        /*       
        CComPtr<IObjectWithSite> pObjWithSite;
        if(SUCCEEDED(m_pGraph->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite))) {
            CComPtr<IServiceProvider> pServiceProvider;
            if(SUCCEEDED(pObjWithSite->GetSite(IID_IServiceProvider, (void**)&pServiceProvider))) {                        
                bTridentServicesAvailable = true;
                
                // Additional checks for the two trident services required by DA
                CComPtr<ITimerService> pTimerService;
                CComPtr<IDirectDraw3> pDirectDraw3;
                
                if(FAILED( pServiceProvider->QueryService(SID_STimerService,
                                               IID_ITimerService, (void**)&pTimerService))) {
                    bTridentServicesAvailable = false;    
                }
                // Can't link this in...
                
                if(FAILED( pServiceProvider->QueryService(SID_SDirectDraw3,
                                               IID_IDirectDraw3, (void**)&pDirectDraw3))) {
                    bTridentServicesAvailable = false; 
                }       
            }
        }
        pObjWithSite.Release();  // done with this
        */

        IDAViewerControl *pControl;
        if(bTridentServicesAvailable) {	        
       	    if(FAILED(CoCreateInstance(__uuidof(DAViewerControl), (IBaseFilter *) this,
				  CLSCTX_INPROC_SERVER, IID_IUnknown, (void **) &m_punkControl))) {
		        ASSERT(0);
		        return E_NOINTERFACE;
	        }

	        if(FAILED(m_punkControl->QueryInterface(IID_IDAViewerControl,
			    	  (void **) &pControl))) { 
		        ASSERT(0);                         
		        return E_NOINTERFACE;
            }
        }
        else {        
            if(FAILED(CoCreateInstance(__uuidof(DAViewerControlWindowed), (IBaseFilter *) this,
                  CLSCTX_INPROC_SERVER, IID_IUnknown, (void **) &m_punkControl))) { 
                ASSERT(0);                         
                return E_NOINTERFACE;
            }    

            if(FAILED(m_punkControl->QueryInterface(IID_IDAViewerControlWindowed,
                      (void **) &pControl))) { 
                ASSERT(0);
                return E_NOINTERFACE;
            }

            if (FAILED(pControl->put_TimerSource(DAWMTimer))) {
                ASSERT(0);
                return hr;
            }                                      
        }          

	    if (m_dwWidth) {
		    SIZEL sizeControl;

		    sizeControl.cx = m_dwWidth;
		    sizeControl.cy = m_dwHeight;

		    ConvertPixelToHiMetric(&sizeControl, &sizeControl);

		    IOleObject *pOleObj;
		    hr = m_punkControl->QueryInterface(IID_IOleObject, (void **) &pOleObj);

		    if (SUCCEEDED(hr)) {
		        hr = pOleObj->SetExtent(DVASPECT_CONTENT, &sizeControl);

		        pOleObj->Release();
		    }
	    }	    

	    // create the LM reader
	    hr = CoCreateInstance(__uuidof(LMReader), NULL,
				  CLSCTX_INPROC_SERVER,
				  __uuidof(ILMReader),
				  (void **) &m_pReader);

	    if (FAILED(hr)) {
		ASSERT(0);
		return E_NOINTERFACE;
	    }
	    
		ILMEngine *pEngine = NULL;
	    hr = m_pReader->createAsyncEngine(&pEngine);
	    if (FAILED(hr)) {
		ASSERT(0);
		return E_NOINTERFACE;		
	    }

		hr = pEngine->QueryInterface( __uuidof(ILMEngine2), (void **)&m_pEngine);
		if (FAILED(hr)) {
		ASSERT(0);
		return E_NOINTERFACE;		
	    }
		pEngine->Release();

	    hr = m_pReader->put_ViewerControl(pControl);
	    if (FAILED(hr)) {
            ASSERT(0);
            return E_NOINTERFACE;
	    }

        // just created a circular reference since we aggregated
        // pControl. get rid of it artificially. we'll bump the
        // refcount up twice in the destructor when it releases
        // m_pReader to avoid hitting 0 again.
        Release();

	    IDAStatics *pMeterLibrary;
	    hr = pControl->get_MeterLibrary(&pMeterLibrary);

	    if (SUCCEEDED(hr)) {
		// check whether this is DA version 1 by seeing if the IDA2Statics
		// interface is not present.
		IUnknown *pStatics2 = NULL;
		hr = pMeterLibrary->QueryInterface(__uuidof(IDA2Statics), (void **) &pStatics2);

		if (SUCCEEDED(hr)) {
		    pStatics2->Release();
		}

		// if no IDA2Statics, it's the IE4 version of DA.
		m_pReader->put_NoExports(pStatics2 ? OAFALSE : OATRUE);
		
		pMeterLibrary->Release();
	    }
        	    
	    pControl->Release();
	}
	
	return m_punkControl->QueryInterface(riid, ppv);
    }


    return CBaseRenderer::NonDelegatingQueryInterface(riid,ppv);
    
} // NonDelegatingQueryInterface


//
// CheckMediaType
//
// Check that we can support a given proposed type
//
HRESULT CLMRTRenderer::CheckMediaType(const CMediaType *pmt)
{
    // Accept only LMRT data

    if (pmt->majortype != MEDIATYPE_LMRT) {
	return E_INVALIDARG;
    }

    // !!! check other things about the format?
    
    return NOERROR;

} // CheckMediaType

//
// SetMediaType
//
// Called when the media type is really chosen
//
HRESULT CLMRTRenderer::SetMediaType(const CMediaType *pmt)
{
    // possibly actually look at the type?
#define CB_SWH_HEADER ((3 * sizeof(DWORD)))

    HRESULT hr = CheckMediaType(pmt);

    if (pmt->cbFormat >= CB_SWH_HEADER) {
	DWORD *pdw = (DWORD *) pmt->pbFormat;

	m_dwWidth = pdw[1];
	m_dwHeight = pdw[2];
    }

    // strictly greater than
    if (pmt->cbFormat > CB_SWH_HEADER)
    {
        // any extra data in the format block is the first lm
        // packet. save it off and send it in stop->pause.
        ULONG cb = pmt->cbFormat - CB_SWH_HEADER;
        delete[] m_pbFirstPacketFromHeader;
        m_pbFirstPacketFromHeader = new BYTE[cb];
        if(m_pbFirstPacketFromHeader)
        {
            CopyMemory(m_pbFirstPacketFromHeader, pmt->pbFormat + CB_SWH_HEADER, cb);
            m_cbFirstPacketFromHeader = cb;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
                
    }
    
    return hr;

} // CheckMediaType


//
// OnReceiveFirstSample
//
// Display an image if not streaming
//
void CLMRTRenderer::OnReceiveFirstSample(IMediaSample *pMediaSample)
{
}

//
// DoRenderSample
//
// This is called when a sample is ready for rendering
//
HRESULT CLMRTRenderer::DoRenderSample(IMediaSample *pMediaSample)
{
    ASSERT(pMediaSample);
    BYTE *pData;        // Pointer to image data

    pMediaSample->GetPointer(&pData);
    ASSERT(pData != NULL);

    REFERENCE_TIME rtStart, rtEnd;
    ASSERT(pMediaSample->GetTime(&rtStart, &rtEnd) == S_OK);
    DbgLog((LOG_TRACE, 15, TEXT("** CLMRTRenderer: %d"), (LONG)(rtStart / (UNITS / MILLISECONDS))));

    DWORD cbData = pMediaSample->GetActualDataLength();
/*
    // !!! send data to LMRT 
	if (m_pIbsc)
	{
		FORMATETC	format;
		STGMEDIUM	stgMedium;
		CopyMemory(m_pMem, pData, cbData);
		m_pMem += cbData;
		m_dwSize += cbData;
		stgMedium.pstm = m_pstm;
		stgMedium.tymed = TYMED_ISTREAM;
		m_pIbsc->OnDataAvailable(m_bscf, m_dwSize, &format, &stgMedium);
		if (m_bscf == BSCF_FIRSTDATANOTIFICATION)
			m_bscf = BSCF_INTERMEDIATEDATANOTIFICATION;
	}
*/
    if(m_pEngine) {
        m_pEngine->OnMemDataAvailable(FALSE, cbData, pData);
    }
    return NOERROR;

} // DoRenderSample


// OnStartStreaming
HRESULT CLMRTRenderer::OnStartStreaming()
{
//    m_bscf = BSCF_FIRSTDATANOTIFICATION;


    // !!! start control here?
    if(m_pEngine)
    {
        REFERENCE_TIME rtNow = 0;

        if(m_pClock)
        {
            HRESULT hrTmp = m_pClock->GetTime(&rtNow);
            ASSERT(hrTmp == S_OK || hrTmp == S_FALSE);
            rtNow -= m_tStart;

            // rtNow could be negative if we've just been told to run
            // 100ms from now.
            ASSERT(rtNow >= -UNITS);
        }
        
        m_pEngine->Start(rtNow);

    }

    return S_OK;
} // OnStartStreaming

HRESULT CLMRTRenderer::Pause()
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    FILTER_STATE fsOld = m_State;
    HRESULT hrPause = CBaseRenderer::Pause();
    if(SUCCEEDED(hrPause) && fsOld == State_Stopped)
    {
        // look for the magic cache directory from the urlcache
        // filter. really we should find related filters (common
        // upstream source) first. !!!! this should go in Pause()
        IEnumFilters *pEnum;
        HRESULT hr = m_pGraph->EnumFilters(&pEnum);
        if(SUCCEEDED(hr))
        {
            IBaseFilter *pFilter;
            // find the first filter in the graph that supports riid interface
            while(pEnum->Next(1, &pFilter, NULL) == S_OK)
            {
                CLSID clsid;
                if(pFilter->GetClassID( &clsid) == S_OK)
                {
                    if(clsid == CLSID_UrlStreamRenderer)
                    {
                        IPropertyBag *ppb;
                        hr =pFilter->QueryInterface(IID_IPropertyBag, (void **)&ppb);
                        ASSERT(hr == S_OK); // our filter
                        if(SUCCEEDED(hr))
                        {
                            VARIANT var;
                            var.vt = VT_EMPTY;
                            hr = ppb->Read(L"lmrtcache", &var, 0);
                            if(SUCCEEDED(hr))
                            {
                                m_pEngine->SetMediaCacheDir(var.bstrVal);
                                VariantClear(&var);

                            }
                            ppb->Release();
                        }
                    }
                }
                pFilter->Release();
            }

            pEnum->Release();
        }

        if(m_fFirstPause && m_pEngine && m_pbFirstPacketFromHeader)
        {
            m_pEngine->OnMemDataAvailable(
                FALSE,          // boolLastBlock
                m_cbFirstPacketFromHeader,
                m_pbFirstPacketFromHeader);

            // netshow doesn't know we can paint something, so we need
            // to stop the netshow logo from appearing on top of the
            // animation.
            NotifyEvent( EC_VIDEOFRAMEREADY, NULL, NULL );
        }
        m_fFirstPause = false;
    }

    return hrPause;
}

// OnStopStreaming
HRESULT CLMRTRenderer::OnStopStreaming(void)
{
/*
	FORMATETC	format;
	STGMEDIUM	stgMedium;
	stgMedium.pstm = m_pstm;
	m_pIbsc->OnDataAvailable(BSCF_LASTDATANOTIFICATION, m_dwSize, &format, &stgMedium);
*/
    if(m_pEngine) {
            m_pEngine->OnMemDataAvailable(TRUE, 0, 0);
    }

	// !!! stop model here?
    if(m_pEngine) {
        m_pEngine->Stop();
    }
	
	return S_OK;
}

// HRESULT CLMRTRenderer::EndOfStream()
// {
//     // avoid signaling EC_COMPLETE because msdxm.ocx will paint a
//     // static image.
//     return S_OK;
// }

/*
HRESULT CLMRTRenderer::SetLMReader(ILMReader *pReader)
{
	HRESULT		hr;
	ILMEngine	*pEngine;

	if (!SUCCEEDED(hr = pReader->createAsyncEngine(&pEngine)))
		return hr;

	hr = pEngine->QueryInterface(IID_IBindStatusCallback, (void **)&m_pIbsc);
	pEngine->Release();
	return hr;
}
*/

HRESULT CLMRTRenderer::SetLMEngine(ILMEngine *pEngine)
{
	if( m_pEngine != NULL )
		m_pEngine->Release();

	if( FAILED( pEngine->QueryInterface( __uuidof(ILMEngine2), (void **)&m_pEngine ) ) )
		return E_NOINTERFACE;

	return S_OK;
}

STDMETHODIMP CLMRTRenderer::JoinFilterGraph( IFilterGraph *pGraph, LPCWSTR szName )
{
	HRESULT hr = CBaseRenderer::JoinFilterGraph( pGraph, szName);

	if( pGraph == NULL && m_pEngine != NULL )
	{
		m_pEngine->releaseAllFilterGraph();
	}

	return hr;
}

#if defined(DEVELOPER_DEBUG) || defined(_M_ALPHA)

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);


BOOL WINAPI DllMain(  HINSTANCE hinstDLL,  // handle to DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\amfilter.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for streams architecture, December 1994

//=====================================================================
//=====================================================================
// The following classes are declared in this header:
//
//
// CBaseMediaFilter            Basic IMediaFilter support (abstract class)
// CBaseFilter                 Support for IBaseFilter (incl. IMediaFilter)
// CEnumPins                   Enumerate input and output pins
// CEnumMediaTypes             Enumerate the preferred pin formats
// CBasePin                    Abstract base class for IPin interface
//    CBaseOutputPin           Adds data provider member functions
//    CBaseInputPin            Implements IMemInputPin interface
// CMediaSample                Basic transport unit for IMemInputPin
// CBaseAllocator              General list guff for most allocators
//    CMemAllocator            Implements memory buffer allocation
//
//=====================================================================
//=====================================================================

#include <streams.h>

//=====================================================================
// Helpers
//=====================================================================
STDAPI CreateMemoryAllocator(IMemAllocator **ppAllocator)
{
    return CoCreateInstance(CLSID_MemoryAllocator,
                            0,
                            CLSCTX_INPROC_SERVER,
                            IID_IMemAllocator,
                            (void **)ppAllocator);
}

//  Put this one here rather than in ctlutil.cpp to avoid linking
//  anything brought in by ctlutil.cpp
STDAPI CreatePosPassThru(
    LPUNKNOWN pAgg,
    BOOL bRenderer,
    IPin *pPin,
    IUnknown **ppPassThru
)
{
    *ppPassThru = NULL;
    IUnknown *pUnkSeek;
    HRESULT hr = CoCreateInstance(CLSID_SeekingPassThru,
                                  pAgg,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IUnknown,
                                  (void **)&pUnkSeek
                                 );
    if (FAILED(hr)) {
        return hr;
    }

    ISeekingPassThru *pPassThru;
    hr = pUnkSeek->QueryInterface(IID_ISeekingPassThru, (void**)&pPassThru);
    if (FAILED(hr)) {
        pUnkSeek->Release();
        return hr;
    }
    hr = pPassThru->Init(bRenderer, pPin);
    pPassThru->Release();
    if (FAILED(hr)) {
        pUnkSeek->Release();
        return hr;
    }
    *ppPassThru = pUnkSeek;
    return S_OK;
}

#define CONNECT_TRACE_LEVEL 3

//=====================================================================
//=====================================================================
// Implements CBaseMediaFilter
//=====================================================================
//=====================================================================


/* Constructor */

CBaseMediaFilter::CBaseMediaFilter(const TCHAR	*pName,
				   LPUNKNOWN	pUnk,
				   CCritSec	*pLock,
				   REFCLSID	clsid) :
    CUnknown(pName, pUnk),
    m_pLock(pLock),
    m_clsid(clsid),
    m_State(State_Stopped),
    m_pClock(NULL)
{
}


/* Destructor */

CBaseMediaFilter::~CBaseMediaFilter()
{
    // must be stopped, but can't call Stop here since
    // our critsec has been destroyed.

    /* Release any clock we were using */

    if (m_pClock) {
	m_pClock->Release();
	m_pClock = NULL;
    }
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP
CBaseMediaFilter::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    if (riid == IID_IMediaFilter) {
	    return GetInterface((IMediaFilter *) this, ppv);
    } else if (riid == IID_IPersist) {
	    return GetInterface((IPersist *) this, ppv);
    } else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

/* Return the filter's clsid */
STDMETHODIMP
CBaseMediaFilter::GetClassID(CLSID *pClsID)
{
    CheckPointer(pClsID,E_POINTER);
    ValidateReadWritePtr(pClsID,sizeof(CLSID));
    *pClsID = m_clsid;
    return NOERROR;
}

/* Override this if your state changes are not done synchronously */

STDMETHODIMP
CBaseMediaFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    return S_OK;
}


/* Set the clock we will use for synchronisation */

STDMETHODIMP
CBaseMediaFilter::SetSyncSource(IReferenceClock *pClock)
{
    CAutoLock cObjectLock(m_pLock);

    // Ensure the new one does not go away - even if the same as the old
    if (pClock) {
	pClock->AddRef();
    }

    // if we have a clock, release it
    if (m_pClock) {
	m_pClock->Release();
    }

    // Set the new reference clock (might be NULL)
    // Should we query it to ensure it is a clock?  Consider for a debug build.
    m_pClock = pClock;

    return NOERROR;
}

/* Return the clock we are using for synchronisation */
STDMETHODIMP
CBaseMediaFilter::GetSyncSource(IReferenceClock **pClock)
{
    CheckPointer(pClock,E_POINTER);
    ValidateReadWritePtr(pClock,sizeof(IReferenceClock *));
    CAutoLock cObjectLock(m_pLock);

    if (m_pClock) {
	// returning an interface... addref it...
	m_pClock->AddRef();
    }
    *pClock = (IReferenceClock*)m_pClock;
    return NOERROR;
}


/* Put the filter into a stopped state */

STDMETHODIMP
CBaseMediaFilter::Stop()
{
    CAutoLock cObjectLock(m_pLock);

    m_State = State_Stopped;
    return S_OK;
}


/* Put the filter into a paused state */

STDMETHODIMP
CBaseMediaFilter::Pause()
{
    CAutoLock cObjectLock(m_pLock);

    m_State = State_Paused;
    return S_OK;
}


// Put the filter into a running state.

// The time parameter is the offset to be added to the samples'
// stream time to get the reference time at which they should be presented.
//
// you can either add these two and compare it against the reference clock,
// or you can call CBaseMediaFilter::StreamTime and compare that against
// the sample timestamp.

STDMETHODIMP
CBaseMediaFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);

    // remember the stream time offset
    m_tStart = tStart;

    if (m_State == State_Stopped){
	HRESULT hr = Pause();

	if (FAILED(hr)) {
	    return hr;
	}
    }
    m_State = State_Running;
    return S_OK;
}


//
// return the current stream time - samples with start timestamps of this
// time or before should be rendered by now
HRESULT
CBaseMediaFilter::StreamTime(CRefTime& rtStream)
{
    // Caller must lock for synchronization
    // We can't grab the filter lock because we want to be able to call
    // this from worker threads without deadlocking

    if (m_pClock == NULL) {
	return VFW_E_NO_CLOCK;
    }

    // get the current reference time
    HRESULT hr = m_pClock->GetTime((REFERENCE_TIME*)&rtStream);
    if (FAILED(hr)) {
	return hr;
    }

    // subtract the stream offset to get stream time
    rtStream -= m_tStart;

    return S_OK;
}


//=====================================================================
//=====================================================================
// Implements CBaseFilter
//=====================================================================
//=====================================================================


/* Override this to say what interfaces we support and where */

STDMETHODIMP CBaseFilter::NonDelegatingQueryInterface(REFIID riid,
                                                      void **ppv)
{
    /* Do we have this interface */

    if (riid == IID_IBaseFilter) {
	return GetInterface((IBaseFilter *) this, ppv);
    } else if (riid == IID_IMediaFilter) {
	return GetInterface((IMediaFilter *) this, ppv);
    } else if (riid == IID_IPersist) {
	return GetInterface((IPersist *) this, ppv);
    } else if (riid == IID_IAMovieSetup) {
	return GetInterface((IAMovieSetup *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

#ifdef DEBUG
STDMETHODIMP_(ULONG) CBaseFilter::NonDelegatingRelease()
{
    if (m_cRef == 1) {
        KASSERT(m_pGraph == NULL);
    }
    return CUnknown::NonDelegatingRelease();
}
#endif


/* Constructor */

CBaseFilter::CBaseFilter(const TCHAR	*pName,
			 LPUNKNOWN	pUnk,
			 CCritSec	*pLock,
			 REFCLSID	clsid) :
    CUnknown( pName, pUnk ),
    m_pLock(pLock),
    m_clsid(clsid),
    m_State(State_Stopped),
    m_pClock(NULL),
    m_pGraph(NULL),
    m_pSink(NULL),
    m_pName(NULL),
    m_PinVersion(1)
{
    ASSERT(pLock != NULL);
}

/* Passes in a redundant HRESULT argument */

CBaseFilter::CBaseFilter(TCHAR     *pName,
                         LPUNKNOWN  pUnk,
                         CCritSec  *pLock,
                         REFCLSID   clsid,
                         HRESULT   *phr) :
    CUnknown( pName, pUnk ),
    m_pLock(pLock),
    m_clsid(clsid),
    m_State(State_Stopped),
    m_pClock(NULL),
    m_pGraph(NULL),
    m_pSink(NULL),
    m_pName(NULL),
    m_PinVersion(1)
{
    ASSERT(pLock != NULL);
    UNREFERENCED_PARAMETER(phr);
}


/* Destructor */

CBaseFilter::~CBaseFilter()
{
// NOTE we do NOT hold references on the filtergraph for m_pGraph or m_pSink
// When we did we had the circular reference problem.  Nothing would go away.

    if (m_pName)
	delete[] m_pName;

    // must be stopped, but can't call Stop here since
    // our critsec has been destroyed.

    /* Release any clock we were using */
    if (m_pClock) {
	m_pClock->Release();
	m_pClock = NULL;
    }
}

/* Return the filter's clsid */
STDMETHODIMP
CBaseFilter::GetClassID(CLSID *pClsID)
{
    CheckPointer(pClsID,E_POINTER);
    ValidateReadWritePtr(pClsID,sizeof(CLSID));
    *pClsID = m_clsid;
    return NOERROR;
}

/* Override this if your state changes are not done synchronously */
STDMETHODIMP
CBaseFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    return S_OK;
}


/* Set the clock we will use for synchronisation */

STDMETHODIMP
CBaseFilter::SetSyncSource(IReferenceClock *pClock)
{
    CAutoLock cObjectLock(m_pLock);

    // Ensure the new one does not go away - even if the same as the old
    if (pClock) {
	pClock->AddRef();
    }

    // if we have a clock, release it
    if (m_pClock) {
	m_pClock->Release();
    }

    // Set the new reference clock (might be NULL)
    // Should we query it to ensure it is a clock?  Consider for a debug build.
    m_pClock = pClock;

    return NOERROR;
}

/* Return the clock we are using for synchronisation */
STDMETHODIMP
CBaseFilter::GetSyncSource(IReferenceClock **pClock)
{
    CheckPointer(pClock,E_POINTER);
    ValidateReadWritePtr(pClock,sizeof(IReferenceClock *));
    CAutoLock cObjectLock(m_pLock);

    if (m_pClock) {
	// returning an interface... addref it...
	m_pClock->AddRef();
    }
    *pClock = (IReferenceClock*)m_pClock;
    return NOERROR;
}



// override CBaseMediaFilter Stop method, to deactivate any pins this
// filter has.
STDMETHODIMP
CBaseFilter::Stop()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = NOERROR;

    // notify all pins of the state change
    if (m_State != State_Stopped) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins worrying
            // about this state themselves. We ignore the return code to make
            // sure everyone is inactivated regardless. The base input pin
            // class can return an error if it has no allocator but Stop can
            // be used to resync the graph state after something has gone bad

            if (pPin->IsConnected()) {
                HRESULT hrTmp = pPin->Inactive();
                if (FAILED(hrTmp) && SUCCEEDED(hr)) {
                    hr = hrTmp;
                }
            }
	}
    }
    m_State = State_Stopped;
    return hr;
}


// override CBaseMediaFilter Pause method to activate any pins
// this filter has (also called from Run)

STDMETHODIMP
CBaseFilter::Pause()
{
    CAutoLock cObjectLock(m_pLock);

    // notify all pins of the change to active state
    if (m_State == State_Stopped) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins
            // worrying about this state themselves

            if (pPin->IsConnected()) {
	        HRESULT hr = pPin->Active();
	        if (FAILED(hr)) {
		    return hr;
	        }
            }
	}
    }
    m_State = State_Paused;
    return S_OK;
}

// Put the filter into a running state.

// The time parameter is the offset to be added to the samples'
// stream time to get the reference time at which they should be presented.
//
// you can either add these two and compare it against the reference clock,
// or you can call CBaseFilter::StreamTime and compare that against
// the sample timestamp.

STDMETHODIMP
CBaseFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);

    // remember the stream time offset
    m_tStart = tStart;

    if (m_State == State_Stopped){
	HRESULT hr = Pause();

	if (FAILED(hr)) {
	    return hr;
	}
    }
    // notify all pins of the change to active state
    if (m_State != State_Running) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins
            // worrying about this state themselves

            if (pPin->IsConnected()) {
	        HRESULT hr = pPin->Run(tStart);
	        if (FAILED(hr)) {
		    return hr;
	        }
            }
	}
    }
    m_State = State_Running;
    return S_OK;
}

//
// return the current stream time - samples with start timestamps of this
// time or before should be rendered by now
HRESULT
CBaseFilter::StreamTime(CRefTime& rtStream)
{
    // Caller must lock for synchronization
    // We can't grab the filter lock because we want to be able to call
    // this from worker threads without deadlocking

    if (m_pClock == NULL) {
	return VFW_E_NO_CLOCK;
    }

    // get the current reference time
    HRESULT hr = m_pClock->GetTime((REFERENCE_TIME*)&rtStream);
    if (FAILED(hr)) {
	return hr;
    }

    // subtract the stream offset to get stream time
    rtStream -= m_tStart;

    return S_OK;
}


/* Create an enumerator for the pins attached to this filter */

STDMETHODIMP
CBaseFilter::EnumPins(IEnumPins **ppEnum)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumPins *));

    /* Create a new ref counted enumerator */

    *ppEnum = new CEnumPins(this,
	                    NULL);

    return *ppEnum == NULL ? E_OUTOFMEMORY : NOERROR;
}


// default behaviour of FindPin is to assume pins are named
// by their pin names
STDMETHODIMP
CBaseFilter::FindPin(
    LPCWSTR Id,
    IPin ** ppPin
)
{
    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));

    //  We're going to search the pin list so maintain integrity
    CAutoLock lck(m_pLock);
    int iCount = GetPinCount();
    for (int i = 0; i < iCount; i++) {
        CBasePin *pPin = GetPin(i);
        ASSERT(pPin != NULL);

        if (0 == lstrcmpW(pPin->Name(), Id)) {
            //  Found one that matches
            //
            //  AddRef() and return it
            *ppPin = pPin;
            pPin->AddRef();
            return S_OK;
        }
    }
    *ppPin = NULL;
    return VFW_E_NOT_FOUND;
}

/* Return information about this filter */

STDMETHODIMP
CBaseFilter::QueryFilterInfo(FILTER_INFO * pInfo)
{
    CheckPointer(pInfo,E_POINTER);
    ValidateReadWritePtr(pInfo,sizeof(FILTER_INFO));

    if (m_pName) {
    	lstrcpynW(pInfo->achName, m_pName, sizeof(pInfo->achName)/sizeof(WCHAR));
    } else {
	pInfo->achName[0] = L'\0';
    }
    pInfo->pGraph = m_pGraph;
    if (m_pGraph)
	m_pGraph->AddRef();
    return NOERROR;
}


/* Provide the filter with a filter graph */

STDMETHODIMP
CBaseFilter::JoinFilterGraph(
    IFilterGraph * pGraph,
    LPCWSTR pName)
{
    CAutoLock cObjectLock(m_pLock);

    // NOTE: we no longer hold references on the graph (m_pGraph, m_pSink)

    m_pGraph = pGraph;
    if (m_pGraph) {
	HRESULT hr = m_pGraph->QueryInterface(IID_IMediaEventSink,
					(void**) &m_pSink);
	if (FAILED(hr)) {
	    ASSERT(m_pSink == NULL);
	}
        else m_pSink->Release();        // we do NOT keep a reference on it.
    } else {
        // if graph pointer is null, then we should
        // also release the IMediaEventSink on the same object - we don't
        // refcount it, so just set it to null
        m_pSink = NULL;
    }


    if (m_pName) {
        delete[] m_pName;
	m_pName = NULL;
    }

    if (pName) {
	DWORD nameLen = lstrlenW(pName)+1;
	m_pName = new WCHAR[nameLen];
	if (m_pName) {
	    CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR));
	} else {
	    // !!! error here?
	}
    }
    return NOERROR;
}


// return a Vendor information string. Optional - may return E_NOTIMPL.
// memory returned should be freed using CoTaskMemFree
// default implementation returns E_NOTIMPL
STDMETHODIMP
CBaseFilter::QueryVendorInfo(
    LPWSTR* pVendorInfo)
{
    UNREFERENCED_PARAMETER(pVendorInfo);
    return E_NOTIMPL;
}


// send an event notification to the filter graph if we know about it.
// returns S_OK if delivered, S_FALSE if the filter graph does not sink
// events, or an error otherwise.
HRESULT
CBaseFilter::NotifyEvent(
    long EventCode,
    LONG_PTR EventParam1,
    LONG_PTR EventParam2)
{
    // Snapshot so we don't have to lock up
    IMediaEventSink *pSink = m_pSink;
    if (pSink) {
	return pSink->Notify(EventCode, EventParam1, EventParam2);
    } else {
	return E_NOTIMPL;
    }
}

// Request reconnect
// pPin is the pin to reconnect
// pmt is the type to reconnect with - can be NULL
// Calls ReconnectEx on the filter graph
HRESULT
CBaseFilter::ReconnectPin(
    IPin *pPin,
    AM_MEDIA_TYPE const *pmt
)
{
    IFilterGraph2 *pGraph2;
    if (m_pGraph != NULL) {
        HRESULT hr = m_pGraph->QueryInterface(IID_IFilterGraph2, (void **)&pGraph2);
        if (SUCCEEDED(hr)) {
            hr = pGraph2->ReconnectEx(pPin, pmt);
            pGraph2->Release();
            return hr;
        } else {
            return m_pGraph->Reconnect(pPin);
        }
    } else {
        return E_NOINTERFACE;
    }
}



/* This is the same idea as the media type version does for type enumeration
   on pins but for the list of pins available. So if the list of pins you
   provide changes dynamically then either override this virtual function
   to provide the version number, or more simply call IncrementPinVersion */

LONG CBaseFilter::GetPinVersion()
{
    return m_PinVersion;
}


/* Increment the current pin version cookie */

void CBaseFilter::IncrementPinVersion()
{
    InterlockedIncrement(&m_PinVersion);
}

/* register filter */

STDMETHODIMP CBaseFilter::Register()
{
    // get setup data, if it exists
    //
    LPAMOVIESETUP_FILTER psetupdata = GetSetupData();

    // check we've got data
    //
    if( NULL == psetupdata ) return S_FALSE;

    // init is ref counted so call just in case
    // we're being called cold.
    //
    HRESULT hr = CoInitialize( (LPVOID)NULL );
    ASSERT( SUCCEEDED(hr) );

    // get hold of IFilterMapper
    //
    IFilterMapper *pIFM;
    hr = CoCreateInstance( CLSID_FilterMapper
                             , NULL
                             , CLSCTX_INPROC_SERVER
                             , IID_IFilterMapper
                             , (void **)&pIFM       );
    if( SUCCEEDED(hr) )
    {
        hr = AMovieSetupRegisterFilter( psetupdata, pIFM, TRUE );
        pIFM->Release();
    }

    // and clear up
    //
    CoFreeUnusedLibraries();
    CoUninitialize();

    return NOERROR;
}


/* unregister filter */

STDMETHODIMP CBaseFilter::Unregister()
{
    // get setup data, if it exists
    //
    LPAMOVIESETUP_FILTER psetupdata = GetSetupData();

    // check we've got data
    //
    if( NULL == psetupdata ) return S_FALSE;

    // OLE init is ref counted so call
    // just in case we're being called cold.
    //
    HRESULT hr = CoInitialize( (LPVOID)NULL );
    ASSERT( SUCCEEDED(hr) );

    // get hold of IFilterMapper
    //
    IFilterMapper *pIFM;
    hr = CoCreateInstance( CLSID_FilterMapper
                             , NULL
                             , CLSCTX_INPROC_SERVER
                             , IID_IFilterMapper
                             , (void **)&pIFM       );
    if( SUCCEEDED(hr) )
    {
        hr = AMovieSetupRegisterFilter( psetupdata, pIFM, FALSE );

        // release interface
        //
        pIFM->Release();
    }

    // clear up
    //
    CoFreeUnusedLibraries();
    CoUninitialize();

    // handle one acceptable "error" - that
    // of filter not being registered!
    // (couldn't find a suitable #define'd
    // name for the error!)
    //
    if( 0x80070002 == hr)
      return NOERROR;
    else
      return hr;
}


//=====================================================================
//=====================================================================
// Implements CEnumPins
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor
   with a NULL unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants it's lifetime controlled by the external object */

CEnumPins::CEnumPins(CBaseFilter *pFilter,
		     CEnumPins *pEnumPins) :
    m_Position(0),
    m_PinCount(0),
    m_pFilter(pFilter),
    m_cRef(1),               // Already ref counted
    m_PinCache(NAME("Pin Cache"))
{

#ifdef DEBUG
    m_dwCookie = DbgRegisterObjectCreation(TEXT("CEnumPins"));
#endif

    /* We must be owned by a filter derived from CBaseFilter */

    ASSERT(pFilter != NULL);

    /* Hold a reference count on our filter */
    m_pFilter->AddRef();

    /* Are we creating a new enumerator */

    if (pEnumPins == NULL) {
	m_Version = m_pFilter->GetPinVersion();
	m_PinCount = m_pFilter->GetPinCount();
    } else {
        ASSERT(m_Position <= m_PinCount);
        m_Position = pEnumPins->m_Position;
        m_PinCount = pEnumPins->m_PinCount;
        m_Version = pEnumPins->m_Version;
	m_PinCache.AddTail(&(pEnumPins->m_PinCache));
    }
}


/* Destructor releases the reference count on our filter NOTE since we hold
   a reference count on the filter who created us we know it is safe to
   release it, no access can be made to it afterwards though as we have just
   caused the last reference count to go and the object to be deleted */

CEnumPins::~CEnumPins()
{
    m_pFilter->Release();

#ifdef DEBUG
    DbgRegisterObjectDestruction(m_dwCookie);
#endif
}


/* Override this to say what interfaces we support where */

STDMETHODIMP
CEnumPins::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv, E_POINTER);

    /* Do we have this interface */

    if (riid == IID_IEnumPins || riid == IID_IUnknown) {
	return GetInterface((IEnumPins *) this, ppv);
    } else {
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CEnumPins::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CEnumPins::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0) {
        delete this;
    }
    return cRef;
}

/* One of an enumerator's basic member functions allows us to create a cloned
   interface that initially has the same state. Since we are taking a snapshot
   of an object (current position and all) we must lock access at the start */

STDMETHODIMP
CEnumPins::Clone(IEnumPins **ppEnum)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumPins *));
    HRESULT hr = NOERROR;

    /* Check we are still in sync with the filter */
    if (AreWeOutOfSync() == TRUE) {
        *ppEnum = NULL;
        hr =  VFW_E_ENUM_OUT_OF_SYNC;
    } else {

        *ppEnum = new CEnumPins(m_pFilter,
    	                        this);
        if (*ppEnum == NULL) {
    	    hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}


/* Return the next pin after the current position */

STDMETHODIMP
CEnumPins::Next(ULONG cPins,        // place this many pins...
		IPin **ppPins,      // ...in this array
		ULONG *pcFetched)   // actual count passed returned here
{
    CheckPointer(ppPins,E_POINTER);
    ValidateReadWritePtr(ppPins,cPins * sizeof(IPin *));

    ASSERT(ppPins);

    if (pcFetched!=NULL) {
        ValidateWritePtr(pcFetched, sizeof(ULONG));
        *pcFetched = 0;           // default unless we succeed
    }
    // now check that the parameter is valid
    else if (cPins>1) {	  // pcFetched == NULL
        return E_INVALIDARG;
    }
    ULONG cFetched = 0;           // increment as we get each one.

    /* Check we are still in sync with the filter */
    if (AreWeOutOfSync() == TRUE) {
	// If we are out of sync, we should refresh the enumerator.
	// This will reset the position and update the other members, but
	// will not clear cache of pins we have already returned.
	Refresh();
    }

    /* Calculate the number of available pins */

    int cRealPins = min(m_PinCount - m_Position, (int) cPins);
    if (cRealPins == 0) {
	return S_FALSE;
    }

    /* Return each pin interface NOTE GetPin returns CBasePin * not addrefed
       so we must QI for the IPin (which increments its reference count)
       If while we are retrieving a pin from the filter an error occurs we
       assume that our internal state is stale with respect to the filter
       (for example someone has deleted a pin) so we
       return VFW_E_ENUM_OUT_OF_SYNC                            */

    while (cRealPins && (m_PinCount - m_Position)) {

	/* Get the next pin object from the filter */

	CBasePin *pPin = m_pFilter->GetPin(m_Position++);
	if (pPin == NULL) {
            // If this happend, and it's not the first time through, then we've got a problem,
            // since we should really go back and release the iPins, which we have previously
            // AddRef'ed.
            ASSERT( cFetched==0 );
            return VFW_E_ENUM_OUT_OF_SYNC;
	}

	/* We only want to return this pin, if it is not in our cache */
	if (0 == m_PinCache.Find(pPin))
	{
	    /* From the object get an IPin interface */

	    *ppPins = pPin;
	    pPin->AddRef();

	    cFetched++;
	    ppPins++;

	    m_PinCache.AddTail(pPin);

	    cRealPins--;

	}
    }

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    return (cPins==cFetched ? NOERROR : S_FALSE);
}


/* Skip over one or more entries in the enumerator */

STDMETHODIMP
CEnumPins::Skip(ULONG cPins)
{
    /* Check we are still in sync with the filter */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    /* Work out how many pins are left to skip over */
    /* We could position at the end if we are asked to skip too many... */
    /* ..which would match the base implementation for CEnumMediaTypes::Skip */

    ULONG PinsLeft = m_PinCount - m_Position;
    if (cPins > PinsLeft) {
	return S_FALSE;
    }
    m_Position += cPins;
    return NOERROR;
}


/* Set the current position back to the start */
/* Reset has 4 simple steps:
 *
 * Set position to head of list
 * Sync enumerator with object being enumerated
 * Clear the cache of pins already returned
 * return S_OK
 */

STDMETHODIMP
CEnumPins::Reset()
{
    m_Version = m_pFilter->GetPinVersion();
    m_PinCount = m_pFilter->GetPinCount();

    m_Position = 0;

    // Clear the cache
    m_PinCache.RemoveAll();

    return S_OK;
}


/* Set the current position back to the start */
/* Refresh has 3 simple steps:
 *
 * Set position to head of list
 * Sync enumerator with object being enumerated
 * return S_OK
 */

STDMETHODIMP
CEnumPins::Refresh()
{
    m_Version = m_pFilter->GetPinVersion();
    m_PinCount = m_pFilter->GetPinCount();

    m_Position = 0;
    return S_OK;
}


//=====================================================================
//=====================================================================
// Implements CEnumMediaTypes
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor
   with a NULL unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants it's lifetime controlled by the external object */

CEnumMediaTypes::CEnumMediaTypes(CBasePin *pPin,
				 CEnumMediaTypes *pEnumMediaTypes) :
    m_Position(0),
    m_pPin(pPin),
    m_cRef(1)
{

#ifdef DEBUG
    m_dwCookie = DbgRegisterObjectCreation(TEXT("CEnumMediaTypes"));
#endif

    /* We must be owned by a pin derived from CBasePin */

    ASSERT(pPin != NULL);

    /* Hold a reference count on our pin */
    m_pPin->AddRef();

    /* Are we creating a new enumerator */

    if (pEnumMediaTypes == NULL) {
	m_Version = m_pPin->GetMediaTypeVersion();
	return;
    }

    m_Position = pEnumMediaTypes->m_Position;
    m_Version = pEnumMediaTypes->m_Version;
}


/* Destructor releases the reference count on our base pin. NOTE since we hold
   a reference count on the pin who created us we know it is safe to release
   it, no access can be made to it afterwards though as we might have just
   caused the last reference count to go and the object to be deleted */

CEnumMediaTypes::~CEnumMediaTypes()
{
#ifdef DEBUG
    DbgRegisterObjectDestruction(m_dwCookie);
#endif
    m_pPin->Release();
}


/* Override this to say what interfaces we support where */

STDMETHODIMP
CEnumMediaTypes::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv, E_POINTER);

    /* Do we have this interface */

    if (riid == IID_IEnumMediaTypes || riid == IID_IUnknown) {
	return GetInterface((IEnumMediaTypes *) this, ppv);
    } else {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CEnumMediaTypes::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CEnumMediaTypes::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0) {
        delete this;
    }
    return cRef;
}

/* One of an enumerator's basic member functions allows us to create a cloned
   interface that initially has the same state. Since we are taking a snapshot
   of an object (current position and all) we must lock access at the start */

STDMETHODIMP
CEnumMediaTypes::Clone(IEnumMediaTypes **ppEnum)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumMediaTypes *));
    HRESULT hr = NOERROR;

    /* Check we are still in sync with the pin */
    if (AreWeOutOfSync() == TRUE) {
        *ppEnum = NULL;
        hr = VFW_E_ENUM_OUT_OF_SYNC;
    } else {

        *ppEnum = new CEnumMediaTypes(m_pPin,
    	                              this);

        if (*ppEnum == NULL) {
    	    hr =  E_OUTOFMEMORY;
        }
    }
    return hr;
}


/* Enumerate the next pin(s) after the current position. The client using this
   interface passes in a pointer to an array of pointers each of which will
   be filled in with a pointer to a fully initialised media type format
   Return NOERROR if it all works,
          S_FALSE if fewer than cMediaTypes were enumerated.
          VFW_E_ENUM_OUT_OF_SYNC if the enumerator has been broken by
                                 state changes in the filter
   The actual count always correctly reflects the number of types in the array.
*/

STDMETHODIMP
CEnumMediaTypes::Next(ULONG cMediaTypes,          // place this many types...
		      AM_MEDIA_TYPE **ppMediaTypes,   // ...in this array
		      ULONG *pcFetched)           // actual count passed
{
    CheckPointer(ppMediaTypes,E_POINTER);
    ValidateReadWritePtr(ppMediaTypes,cMediaTypes * sizeof(AM_MEDIA_TYPE *));
    /* Check we are still in sync with the pin */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    if (pcFetched!=NULL) {
        ValidateWritePtr(pcFetched, sizeof(ULONG));
        *pcFetched = 0;           // default unless we succeed
    }
    // now check that the parameter is valid
    else if (cMediaTypes>1) {	  // pcFetched == NULL
        return E_INVALIDARG;
    }
    ULONG cFetched = 0;           // increment as we get each one.

    /* Return each media type by asking the filter for them in turn - If we
       have an error code retured to us while we are retrieving a media type
       we assume that our internal state is stale with respect to the filter
       (for example the window size changing) so we return
       VFW_E_ENUM_OUT_OF_SYNC */

    while (cMediaTypes) {

    	CMediaType cmt;

	HRESULT hr = m_pPin->GetMediaType(m_Position++, &cmt);
        if (S_OK != hr) {
            break;
        }

    	/* We now have a CMediaType object that contains the next media type
    	   but when we assign it to the array position we CANNOT just assign
    	   the AM_MEDIA_TYPE structure because as soon as the object goes out of
    	   scope it will delete the memory we have just copied. The function
    	   we use is CreateMediaType which allocates a task memory block */

        /*  Transfer across the format block manually to save an allocate
            and free on the format block and generally go faster */

    	*ppMediaTypes = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    	if (*ppMediaTypes == NULL) {
            break;
    	}

        /*  Do a regular copy */
        **ppMediaTypes = (AM_MEDIA_TYPE)cmt;

        /*  Make sure the destructor doesn't free these */
        cmt.pbFormat = NULL;
        cmt.cbFormat = NULL;
        cmt.pUnk     = NULL;


    	ppMediaTypes++;
    	cFetched++;
    	cMediaTypes--;
    }

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    return ( cMediaTypes==0 ? NOERROR : S_FALSE );
}


/* Skip over one or more entries in the enumerator */

STDMETHODIMP
CEnumMediaTypes::Skip(ULONG cMediaTypes)
{
    /* Check we are still in sync with the pin */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    m_Position += cMediaTypes;

    /*  See if we're over the end */
    CMediaType cmt;
    return S_OK == m_pPin->GetMediaType(m_Position - 1, &cmt) ? S_OK : S_FALSE;
}


/* Set the current position back to the start */
/* Reset has 3 simple steps:
 *
 * set position to head of list
 * sync enumerator with object being enumerated
 * return S_OK
 */

STDMETHODIMP
CEnumMediaTypes::Reset()
{
    m_Position = 0;

    // Bring the enumerator back into step with the current state.  This
    // may be a noop but ensures that the enumerator will be valid on the
    // next call.
    m_Version = m_pPin->GetMediaTypeVersion();
    return NOERROR;
}


//=====================================================================
//=====================================================================
// Implements CBasePin
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor with
   a NULL outer unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants its lifetime controlled by the external object */

/* Constructor */

CBasePin::CBasePin(TCHAR *pObjectName,
		   CBaseFilter *pFilter,
		   CCritSec *pLock,
		   HRESULT *phr,
		   LPCWSTR pName,
		   PIN_DIRECTION dir) :
    CUnknown( pObjectName, NULL ),
    m_pFilter(pFilter),
    m_pLock(pLock),
    m_pName(NULL),
    m_Connected(NULL),
    m_dir(dir),
    m_bRunTimeError(FALSE),
    m_pQSink(NULL),
    m_TypeVersion(1),
    m_tStart(),
    m_tStop(MAX_TIME),
    m_dRate(1.0)
{
    /*  WARNING - pFilter is often not a properly constituted object at
        this state (in particular QueryInterface may not work) - this
        is because its owner is often its containing object and we
        have been called from the containing object's constructor so
        the filter's owner has not yet had its CUnknown constructor
        called
    */
    ASSERT(pFilter != NULL);
    ASSERT(pLock != NULL);

    if (pName) {
	DWORD nameLen = lstrlenW(pName)+1;
	m_pName = new WCHAR[nameLen];
	if (m_pName) {
	    CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR));
	}
    }

#ifdef DEBUG
    m_cRef = 0;
#endif
}


/* Destructor since a connected pin holds a reference count on us there is
   no way that we can be deleted unless we are not currently connected */

CBasePin::~CBasePin()
{
    //  We don't call disconnect because if the filter is going away
    //  all the pins must have a reference count of zero so they must
    //  have been disconnected anyway - (but check the assumption)
    ASSERT(m_Connected == FALSE);

    if (m_pName)
	delete[] m_pName;

    // check the internal reference count is consistent
    ASSERT(m_cRef == 0);
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP
CBasePin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    /* Do we have this interface */

    if (riid == IID_IPin) {
	return GetInterface((IPin *) this, ppv);
    } else if (riid == IID_IQualityControl) {
        return GetInterface((IQualityControl *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


/* Override to increment the owning filter's reference count */

STDMETHODIMP_(ULONG)
CBasePin::NonDelegatingAddRef()
{
    ASSERT(InterlockedIncrement(&m_cRef) > 0);
    return m_pFilter->AddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CBasePin::NonDelegatingRelease()
{
    ASSERT(InterlockedDecrement(&m_cRef) >= 0);
    return m_pFilter->Release();
}


/* Displays pin connection information */

#ifdef DEBUG
void
CBasePin::DisplayPinInfo(IPin *pReceivePin)
{

    if (DbgCheckModuleLevel(LOG_TRACE, CONNECT_TRACE_LEVEL)) {
	PIN_INFO ConnectPinInfo;
	PIN_INFO ReceivePinInfo;

	if (FAILED(QueryPinInfo(&ConnectPinInfo))) {
	    lstrcpyW(ConnectPinInfo.achName, L"Bad Pin");
	} else {
	    QueryPinInfoReleaseFilter(ConnectPinInfo);
	}

	if (FAILED(pReceivePin->QueryPinInfo(&ReceivePinInfo))) {
	    lstrcpyW(ReceivePinInfo.achName, L"Bad Pin");
	} else {
	    QueryPinInfoReleaseFilter(ReceivePinInfo);
	}

	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Trying to connect Pins :")));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    <%ls>"), ConnectPinInfo.achName));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    <%ls>"), ReceivePinInfo.achName));
    }
}
#endif


/* Displays general information on the pin media type */

#ifdef DEBUG
void CBasePin::DisplayTypeInfo(IPin *pPin, const CMediaType *pmt)
{
    UNREFERENCED_PARAMETER(pPin);
    if (DbgCheckModuleLevel(LOG_TRACE, CONNECT_TRACE_LEVEL)) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Trying media type:")));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    major type:  %s"),
	       GuidNames[*pmt->Type()]));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    sub type  :  %s"),
	       GuidNames[*pmt->Subtype()]));
    }
}
#endif

/* Asked to connect to a pin. A pin is always attached to an owning filter
   object so we always delegate our locking to that object. We first of all
   retrieve a media type enumerator for the input pin and see if we accept
   any of the formats that it would ideally like, failing that we retrieve
   our enumerator and see if it will accept any of our preferred types */

STDMETHODIMP
CBasePin::Connect(
    IPin * pReceivePin,
    const AM_MEDIA_TYPE *pmt   // optional media type
)
{
    CheckPointer(pReceivePin,E_POINTER);
    ValidateReadPtr(pReceivePin,sizeof(IPin));
    CAutoLock cObjectLock(m_pLock);
    DisplayPinInfo(pReceivePin);

    /* See if we are already connected */

    if (m_Connected) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Already connected")));
	return VFW_E_ALREADY_CONNECTED;
    }

    /* See if the filter is active */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }


    // Find a mutually agreeable media type -
    // Pass in the template media type. If this is partially specified,
    // each of the enumerated media types will need to be checked against
    // it. If it is non-null and fully specified, we will just try to connect
    // with this.

    const CMediaType * ptype = (CMediaType*)pmt;
    HRESULT hr = AgreeMediaType(pReceivePin, ptype);
    if (FAILED(hr)) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Failed to agree type")));
	BreakConnect();
	return hr;
    }

    DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Connection succeeded")));
    return NOERROR;
}

// given a specific media type, attempt a connection (includes
// checking that the type is acceptable to this pin)
HRESULT
CBasePin::AttemptConnection(
    IPin* pReceivePin,      // connect to this pin
    const CMediaType* pmt   // using this type
)
{
    // Check that the connection is valid  -- need to do this for every
    // connect attempt since BreakConnect will undo it.
    HRESULT hr = CheckConnect(pReceivePin);
    if (FAILED(hr)) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("CheckConnect failed")));
	BreakConnect();
	return hr;
    }

    DisplayTypeInfo(pReceivePin, pmt);

    /* Check we will accept this media type */

    hr = CheckMediaType(pmt);
    if (hr == NOERROR) {

        /*  Make ourselves look connected otherwise ReceiveConnection
            may not be able to complete the connection
        */
        m_Connected = pReceivePin;
        m_Connected->AddRef();
        SetMediaType(pmt);

        /* See if the other pin will accept this type */

        hr = pReceivePin->ReceiveConnection((IPin *)this, pmt);
        if (SUCCEEDED(hr)) {
            /* Complete the connection */

            hr = CompleteConnect(pReceivePin);
            if (SUCCEEDED(hr)) {
                return hr;
            } else {
                DbgLog((LOG_TRACE,
                        CONNECT_TRACE_LEVEL,
                        TEXT("Failed to complete connection")));
                pReceivePin->Disconnect();
            }
        }
    } else {
	// we cannot use this media type

	// return a specific media type error if there is one
	// or map a general failure code to something more helpful
	// (in particular S_FALSE gets changed to an error code)
	if (SUCCEEDED(hr) ||
	    (hr == E_FAIL) ||
	    (hr == E_INVALIDARG)) {
		hr = VFW_E_TYPE_NOT_ACCEPTED;
	}
    }

    // BreakConnect and release any connection here in case CheckMediaType
    // failed, or if we set anything up during a call back during
    // ReceiveConnection.
    BreakConnect();

    /*  If failed then undo our state */
    if (m_Connected) {
        m_Connected->Release();
        m_Connected = NULL;
    }

    return hr;
}

/* Given an enumerator we cycle through all the media types it proposes and
   firstly suggest them to our derived pin class and if that succeeds try
   them with the pin in a ReceiveConnection call. This means that if our pin
   proposes a media type we still check in here that we can support it. This
   is deliberate so that in simple cases the enumerator can hold all of the
   media types even if some of them are not really currently available */

HRESULT CBasePin::TryMediaTypes(
    IPin *pReceivePin,
    const CMediaType *pmt,
    IEnumMediaTypes *pEnum)
{
    /* Reset the current enumerator position */

    HRESULT hr = pEnum->Reset();
    if (FAILED(hr)) {
	return hr;
    }

    CMediaType *pMediaType = NULL;
    ULONG ulMediaCount = 0;

    // attempt to remember a specific error code if there is one
    HRESULT hrFailure = S_OK;

    for (;;) {

	/* Retrieve the next media type NOTE each time round the loop the
	   enumerator interface will allocate another AM_MEDIA_TYPE structure
	   If we are successful then we copy it into our output object, if
	   not then we must delete the memory allocated before returning */

	hr = pEnum->Next(1, (AM_MEDIA_TYPE**)&pMediaType,&ulMediaCount);
	if (hr != S_OK) {
	    if (S_OK == hrFailure) {
		hrFailure = VFW_E_NO_ACCEPTABLE_TYPES;
	    }
	    return hrFailure;
	}


	ASSERT(ulMediaCount == 1);
	ASSERT(pMediaType);

        // check that this matches the partial type (if any)

        if ((pmt == NULL) ||
            pMediaType->MatchesPartial(pmt)) {

            hr = AttemptConnection(pReceivePin, pMediaType);

	    // attempt to remember a specific error code
	    if (FAILED(hr) &&
		SUCCEEDED(hrFailure) &&
		(hr != E_FAIL) &&
		(hr != E_INVALIDARG) &&
		(hr != VFW_E_TYPE_NOT_ACCEPTED)) {
		    hrFailure = hr;
	    }
        } else {
            hr = VFW_E_NO_ACCEPTABLE_TYPES;
        }

        DeleteMediaType(pMediaType);

        if (S_OK == hr) {
            return hr;
        }
    }
}


/* This is called to make the connection, including the taask of finding
   a media type for the pin connection. pmt is the proposed media type
   from the Connect call: if this is fully specified, we will try that.
   Otherwise we enumerate and try all the input pin's types first and
   if that fails we then enumerate and try all our preferred media types.
   For each media type we check it against pmt (if non-null and partially
   specified) as well as checking that both pins will accept it.
 */

HRESULT CBasePin::AgreeMediaType(
    IPin *pReceivePin,
    const CMediaType *pmt)
{
    ASSERT(pReceivePin);
    IEnumMediaTypes *pEnumMediaTypes = NULL;

    // if the media type is fully specified then use that
    if ( (pmt != NULL) && (!pmt->IsPartiallySpecified())) {

        // if this media type fails, then we must fail the connection
        // since if pmt is nonnull we are only allowed to connect
        // using a type that matches it.

        return AttemptConnection(pReceivePin, pmt);
    }


    /* Try the other pin's enumerator */

    HRESULT hrFailure = VFW_E_NO_ACCEPTABLE_TYPES;

    HRESULT hr = pReceivePin->EnumMediaTypes(&pEnumMediaTypes);
    if (SUCCEEDED(hr)) {
	ASSERT(pEnumMediaTypes);
	hr = TryMediaTypes(pReceivePin,pmt,pEnumMediaTypes);
	pEnumMediaTypes->Release();
	if (SUCCEEDED(hr)) {
	    return NOERROR;
	} else {
	    // try to remember specific error codes if there are any
	    if ((hr != E_FAIL) &&
		(hr != E_INVALIDARG) &&
		(hr != VFW_E_TYPE_NOT_ACCEPTED)) {
		    hrFailure = hr;
	    }
	}
    }

    /* Having failed with that try our enumerator */

    hr = EnumMediaTypes(&pEnumMediaTypes);
    if (SUCCEEDED(hr)) {
	ASSERT(pEnumMediaTypes);
	hr = TryMediaTypes(pReceivePin,pmt,pEnumMediaTypes);
	pEnumMediaTypes->Release();
	if (SUCCEEDED(hr)) {
	    return NOERROR;
	} else {
	    // try to remember specific error codes if there are any
	    if ((hr != E_FAIL) &&
		(hr != E_INVALIDARG) &&
		(hr != VFW_E_TYPE_NOT_ACCEPTED)) {
		    hrFailure = hr;
	    }
	}
    }
    return hrFailure;
}


/* Called when we want to complete a connection to another filter. Failing
   this will also fail the connection and disconnect the other pin as well */

HRESULT
CBasePin::CompleteConnect(IPin *pReceivePin)
{
    UNREFERENCED_PARAMETER(pReceivePin);
    return NOERROR;
}


/* This is called to set the format for a pin connection - CheckMediaType
   will have been called to check the connection format and if it didn't
   return an error code then this (virtual) function will be invoked */

HRESULT
CBasePin::SetMediaType(const CMediaType *pmt)
{
    m_mt = *pmt;
    return NOERROR;
}


/* This is called during Connect() to provide a virtual method that can do
   any specific check needed for connection such as QueryInterface. This
   base class method just checks that the pin directions don't match */

HRESULT
CBasePin::CheckConnect(IPin * pPin)
{
    /* Check that pin directions DONT match */

    PIN_DIRECTION pd;
    pPin->QueryDirection(&pd);

    ASSERT((pd == PINDIR_OUTPUT) || (pd == PINDIR_INPUT));
    ASSERT((m_dir == PINDIR_OUTPUT) || (m_dir == PINDIR_INPUT));

    // we should allow for non-input and non-output connections?
    if (pd == m_dir) {
	return VFW_E_INVALID_DIRECTION;
    }
    return NOERROR;
}


/* This is called when we realise we can't make a connection to the pin and
   must undo anything we did in CheckConnect - override to release QIs done */

HRESULT
CBasePin::BreakConnect()
{
    return NOERROR;
}


/* Called normally by an output pin on an input pin to try and establish a
   connection.
*/

STDMETHODIMP
CBasePin::ReceiveConnection(
    IPin * pConnector,      // this is the pin who we will connect to
    const AM_MEDIA_TYPE *pmt    // this is the media type we will exchange
)
{
    CheckPointer(pConnector,E_POINTER);
    CheckPointer(pmt,E_POINTER);
    ValidateReadPtr(pConnector,sizeof(IPin));
    ValidateReadPtr(pmt,sizeof(AM_MEDIA_TYPE));
    CAutoLock cObjectLock(m_pLock);

    /* Are we already connected */
    if (m_Connected) {
	return VFW_E_ALREADY_CONNECTED;
    }

    /* See if the filter is active */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }

    HRESULT hr = CheckConnect(pConnector);
    if (FAILED(hr)) {
	BreakConnect();
	return hr;
    }

    /* Ask derived class if this media type is ok */

    CMediaType * pcmt = (CMediaType*) pmt;
    hr = CheckMediaType(pcmt);
    if (hr != NOERROR) {
	// no -we don't support this media type
	BreakConnect();

	// return a specific media type error if there is one
	// or map a general failure code to something more helpful
	// (in particular S_FALSE gets changed to an error code)
	if (SUCCEEDED(hr) ||
	    (hr == E_FAIL) ||
	    (hr == E_INVALIDARG)) {
		hr = VFW_E_TYPE_NOT_ACCEPTED;
	}
	return hr;
    }

    /* Complete the connection */

    m_Connected = pConnector;
    m_Connected->AddRef();
    SetMediaType(pcmt);

    hr = CompleteConnect(pConnector);
    if (FAILED(hr)) {
        DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Failed to complete connection")));
        m_Connected->Release();
        m_Connected = NULL;
        BreakConnect();
        return hr;
    }
    return NOERROR;
}


/* Called when we want to terminate a pin connection */

STDMETHODIMP
CBasePin::Disconnect()
{
    CAutoLock cObjectLock(m_pLock);

    /* See if the filter is active */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }		

    if (m_Connected) {
	BreakConnect();
	m_Connected->Release();
	m_Connected = NULL;
	return S_OK;
    } else {
	// no connection - not an error
	return S_FALSE;
    }
}


/* Return an AddRef()'d pointer to the connected pin if there is one */
STDMETHODIMP
CBasePin::ConnectedTo(
    IPin **ppPin
)
{
    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));
    //
    //  It's pointless to lock here.
    //  The caller should ensure integrity.
    //

    IPin *pPin = m_Connected;
    *ppPin = pPin;
    if (pPin != NULL) {
        pPin->AddRef();
        return S_OK;
    } else {
        ASSERT(*ppPin == NULL);
        return VFW_E_NOT_CONNECTED;
    }
}

/* Return the media type of the connection */
STDMETHODIMP
CBasePin::ConnectionMediaType(
    AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(pmt,E_POINTER);
    ValidateReadWritePtr(pmt,sizeof(AM_MEDIA_TYPE));
    CAutoLock cObjectLock(m_pLock);

    /*  Copy constructor of m_mt allocates the memory */
    if (IsConnected()) {
        CopyMediaType( pmt, &m_mt );
        return S_OK;
    } else {
        ((CMediaType *)pmt)->InitMediaType();
        return VFW_E_NOT_CONNECTED;
    }
}

/* Return information about the filter we are connect to */

STDMETHODIMP
CBasePin::QueryPinInfo(
    PIN_INFO * pInfo
)
{
    CheckPointer(pInfo,E_POINTER);
    ValidateReadWritePtr(pInfo,sizeof(PIN_INFO));

    pInfo->pFilter = m_pFilter;
    if (m_pFilter) {
	m_pFilter->AddRef();
    }

    if (m_pName) {
	lstrcpyW(pInfo->achName, m_pName);
    } else {
	pInfo->achName[0] = L'\0';
    }

    pInfo->dir = m_dir;

    return NOERROR;
}

STDMETHODIMP
CBasePin::QueryDirection(
    PIN_DIRECTION * pPinDir
)
{
    CheckPointer(pPinDir,E_POINTER);
    ValidateReadWritePtr(pPinDir,sizeof(PIN_DIRECTION));

    *pPinDir = m_dir;
    return NOERROR;
}

// Default QueryId to return the pin's name
STDMETHODIMP
CBasePin::QueryId(
    LPWSTR * Id
)
{
    //  We're not going away because someone's got a pointer to us
    //  so there's no need to lock

    return AMGetWideString(Name(), Id);
}

/* Does this pin support this media type WARNING this interface function does
   not lock the main object as it is meant to be asynchronous by nature - if
   the media types you support depend on some internal state that is updated
   dynamically then you will need to implement locking in a derived class */

STDMETHODIMP
CBasePin::QueryAccept(
    const AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(pmt,E_POINTER);
    ValidateReadPtr(pmt,sizeof(AM_MEDIA_TYPE));

    /* The CheckMediaType method is valid to return error codes if the media
       type is horrible, an example might be E_INVALIDARG. What we do here
       is map all the error codes into either S_OK or S_FALSE regardless */

    HRESULT hr = CheckMediaType((CMediaType*)pmt);
    if (FAILED(hr)) {
        return S_FALSE;
    }
    // note that the only defined success codes should be S_OK and S_FALSE...
    return hr;
}


/* This can be called to return an enumerator for the pin's list of preferred
   media types. An input pin is not obliged to have any preferred formats
   although it can do. For example, the window renderer has a preferred type
   which describes a video image that matches the current window size. All
   output pins should expose at least one preferred format otherwise it is
   possible that neither pin has any types and so no connection is possible */

STDMETHODIMP
CBasePin::EnumMediaTypes(
    IEnumMediaTypes **ppEnum
)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumMediaTypes *));

    /* Create a new ref counted enumerator */

    *ppEnum = new CEnumMediaTypes(this,
	                          NULL);

    if (*ppEnum == NULL) {
	return E_OUTOFMEMORY;
    }

    return NOERROR;
}



/* This is a virtual function that returns a media type corresponding with
   place iPosition in the list. This base class simply returns an error as
   we support no media types by default but derived classes should override */

HRESULT CBasePin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    UNREFERENCED_PARAMETER(iPosition);
    UNREFERENCED_PARAMETER(pMediaType);
    return E_UNEXPECTED;
}


/* This is a virtual function that returns the current media type version.
   The base class initialises the media type enumerators with the value 1
   By default we always returns that same value. A Derived class may change
   the list of media types available and after doing so it should increment
   the version either in a method derived from this, or more simply by just
   incrementing the m_TypeVersion base pin variable. The type enumerators
   call this when they want to see if their enumerations are out of date */

LONG CBasePin::GetMediaTypeVersion()
{
    return m_TypeVersion;
}


/* Increment the cookie representing the current media type version */

void CBasePin::IncrementTypeVersion()
{
    InterlockedIncrement(&m_TypeVersion);
}


/* Called by IMediaFilter implementation when the state changes from Stopped
   to either paused or running and in derived classes could do things like
   commit memory and grab hardware resource (the default is to do nothing) */

HRESULT
CBasePin::Active(void)
{
    return NOERROR;
}

/* Called by IMediaFilter implementation when the state changes from
   to either paused to running and in derived classes could do things like
   commit memory and grab hardware resource (the default is to do nothing) */

HRESULT
CBasePin::Run(REFERENCE_TIME tStart)
{
    UNREFERENCED_PARAMETER(tStart);
    return NOERROR;
}


/* Also called by the IMediaFilter implementation when the state changes to
   Stopped at which point you should decommit allocators and free hardware
   resources you grabbed in the Active call (default is also to do nothing) */

HRESULT
CBasePin::Inactive(void)
{
    m_bRunTimeError = FALSE;
    return NOERROR;
}


// Called when no more data will arrive
STDMETHODIMP
CBasePin::EndOfStream(void)
{
    return S_FALSE;
}


STDMETHODIMP
CBasePin::SetSink(IQualityControl * piqc)
{
    CAutoLock cObjectLock(m_pLock);
    if (piqc) ValidateReadPtr(piqc,sizeof(IQualityControl));
    m_pQSink = piqc;
    return NOERROR;
} // SetSink


STDMETHODIMP
CBasePin::Notify(IBaseFilter * pSender, Quality q)
{
    UNREFERENCED_PARAMETER(q);
    UNREFERENCED_PARAMETER(pSender);
    DbgBreak("IQualityControl::Notify not over-ridden from CBasePin.  (IGNORE is OK)");
    return E_NOTIMPL;
} //Notify


// NewSegment notifies of the start/stop/rate applying to the data
// about to be received. Default implementation records data and
// returns S_OK.
// Override this to pass downstream.
STDMETHODIMP
CBasePin::NewSegment(
                REFERENCE_TIME tStart,
                REFERENCE_TIME tStop,
                double dRate)
{
    m_tStart = tStart;
    m_tStop = tStop;
    m_dRate = dRate;

    return S_OK;
}


//=====================================================================
//=====================================================================
// Implements CBaseOutputPin
//=====================================================================
//=====================================================================


CBaseOutputPin::CBaseOutputPin(TCHAR *pObjectName,
			       CBaseFilter *pFilter,
			       CCritSec *pLock,
			       HRESULT *phr,
			       LPCWSTR pName) :
    CBasePin(pObjectName, pFilter, pLock, phr, pName, PINDIR_OUTPUT),
    m_pAllocator(NULL),
    m_pInputPin(NULL)
{
    ASSERT(pFilter);
}


/* Since an input pin connected to us holds a reference count on us we will
   never be deleted unless all connections have already been terminated */

#if 0
CBaseOutputPin::~CBaseOutputPin()
{
}
#endif

/*   This is called after a media type has been proposed

     Try to complete the connection by agreeing the allocator
*/
HRESULT
CBaseOutputPin::CompleteConnect(IPin *pReceivePin)
{
    UNREFERENCED_PARAMETER(pReceivePin);
    return DecideAllocator(m_pInputPin, &m_pAllocator);
}


/* This method is called when the output pin is about to try and connect to
   an input pin. It is at this point that you should try and grab any extra
   interfaces that you need, in this case IMemInputPin. Because this is
   only called if we are not currently connected we do NOT need to call
   BreakConnect. This also makes it easier to derive classes from us as
   BreakConnect is only called when we actually have to break a connection
   (or a partly made connection) and not when we are checking a connection */

/* Overriden from CBasePin */

HRESULT
CBaseOutputPin::CheckConnect(IPin * pPin)
{
    HRESULT hr = CBasePin::CheckConnect(pPin);
    if (FAILED(hr)) {
	return hr;
    }

    // get an input pin and an allocator interface
    hr = pPin->QueryInterface(IID_IMemInputPin, (void **) &m_pInputPin);
    if (FAILED(hr)) {
	return hr;
    }
    return NOERROR;
}


/* Overriden from CBasePin */

HRESULT
CBaseOutputPin::BreakConnect()
{
    /* Release any allocator we hold */

    if (m_pAllocator) {
	m_pAllocator->Release();
	m_pAllocator = NULL;
    }

    /* Release any input pin interface we hold */

    if (m_pInputPin) {
	m_pInputPin->Release();
	m_pInputPin = NULL;
    }
    return NOERROR;
}


/* This is called when the input pin didn't give us a valid allocator */

HRESULT
CBaseOutputPin::InitAllocator(IMemAllocator **ppAlloc)
{
#if 0
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;
    CMemAllocator *pMemObject = NULL;

    /* Create a default memory allocator */

    pMemObject = new CMemAllocator(NAME("Base memory allocator"),NULL, &hr);
    if (pMemObject == NULL) {
	return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
	delete pMemObject;
	return hr;
    }

    /* Get a reference counted IID_IMemAllocator interface */

    EXECUTE_ASSERT(SUCCEEDED(pMemObject->QueryInterface(IID_IMemAllocator,(void **)ppAlloc)));

    ASSERT(*ppAlloc != NULL);
    return NOERROR;
#else
    return CreateMemoryAllocator(ppAlloc);
#endif
}


/* Decide on an allocator, override this if you want to use your own allocator
   Override DecideBufferSize to call SetProperties. If the input pin fails
   the GetAllocator call then this will construct a CMemAllocator and call
   DecideBufferSize on that, and if that fails then we are completely hosed.
   If the you succeed the DecideBufferSize call, we will notify the input
   pin of the selected allocator. NOTE this is called during Connect() which
   therefore looks after grabbing and locking the object's critical section */

// We query the input pin for its requested properties and pass this to
// DecideBufferSize to allow it to fulfill requests that it is happy
// with (eg most people don't care about alignment and are thus happy to
// use the downstream pin's alignment request).

HRESULT
CBaseOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;
}


/* This returns an empty sample buffer from the allocator WARNING the same
   dangers and restrictions apply here as described below for Deliver() */

HRESULT
CBaseOutputPin::GetDeliveryBuffer(IMediaSample ** ppSample,
                                  REFERENCE_TIME * pStartTime,
                                  REFERENCE_TIME * pEndTime,
                                  DWORD dwFlags)
{
    if (m_pAllocator != NULL) {
        return m_pAllocator->GetBuffer(ppSample,pStartTime,pEndTime,dwFlags);
    } else {
        return E_NOINTERFACE;
    }
}


/* Deliver a filled-in sample to the connected input pin. NOTE the object must
   have locked itself before calling us otherwise we may get halfway through
   executing this method only to find the filter graph has got in and
   disconnected us from the input pin. If the filter has no worker threads
   then the lock is best applied on Receive(), otherwise it should be done
   when the worker thread is ready to deliver. There is a wee snag to worker
   threads that this shows up. The worker thread must lock the object when
   it is ready to deliver a sample, but it may have to wait until a state
   change has completed, but that may never complete because the state change
   is waiting for the worker thread to complete. The way to handle this is for
   the state change code to grab the critical section, then set an abort event
   for the worker thread, then release the critical section and wait for the
   worker thread to see the event we set and then signal that it has finished
   (with another event). At which point the state change code can complete */

// note (if you've still got any breath left after reading that) that you
// need to release the sample yourself after this call. if the connected
// input pin needs to hold onto the sample beyond the call, it will addref
// the sample itself.

// of course you must release this one and call GetDeliveryBuffer for the
// next. You cannot reuse it directly.

HRESULT
CBaseOutputPin::Deliver(IMediaSample * pSample)
{
    if (m_pInputPin == NULL) {
	return VFW_E_NOT_CONNECTED;
    }
    return m_pInputPin->Receive(pSample);
}


// called from elsewhere in our filter to pass EOS downstream to
// our connected input pin
HRESULT
CBaseOutputPin::DeliverEndOfStream(void)
{
    // remember this is on IPin not IMemInputPin
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->EndOfStream();
}


/* Commit the allocator's memory, this is called through IMediaFilter
   which is responsible for locking the object before calling us */

HRESULT
CBaseOutputPin::Active(void)
{
    if (m_pAllocator == NULL) {
	return VFW_E_NO_ALLOCATOR;
    }
    return m_pAllocator->Commit();
}


/* Free up or unprepare allocator's memory, this is called through
   IMediaFilter which is responsible for locking the object first */

HRESULT
CBaseOutputPin::Inactive(void)
{
    m_bRunTimeError = FALSE;
    if (m_pAllocator == NULL) {
	return VFW_E_NO_ALLOCATOR;
    }
    return m_pAllocator->Decommit();
}

// we have a default handling of EndOfStream which is to return
// an error, since this should be called on input pins only
STDMETHODIMP
CBaseOutputPin::EndOfStream(void)
{
    return E_UNEXPECTED;
}


// BeginFlush should be called on input pins only
STDMETHODIMP
CBaseOutputPin::BeginFlush(void)
{
    return E_UNEXPECTED;
}

// EndFlush should be called on input pins only
STDMETHODIMP
CBaseOutputPin::EndFlush(void)
{
    return E_UNEXPECTED;
}

// call BeginFlush on the connected input pin
HRESULT
CBaseOutputPin::DeliverBeginFlush(void)
{
    // remember this is on IPin not IMemInputPin
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->BeginFlush();
}

// call EndFlush on the connected input pin
HRESULT
CBaseOutputPin::DeliverEndFlush(void)
{
    // remember this is on IPin not IMemInputPin
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->EndFlush();
}
// deliver NewSegment to connected pin
HRESULT
CBaseOutputPin::DeliverNewSegment(
    REFERENCE_TIME tStart,
    REFERENCE_TIME tStop,
    double dRate)
{
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->NewSegment(tStart, tStop, dRate);
}


//=====================================================================
//=====================================================================
// Implements CBaseInputPin
//=====================================================================
//=====================================================================


/* Constructor creates a default allocator object */

CBaseInputPin::CBaseInputPin(TCHAR *pObjectName,
			     CBaseFilter *pFilter,
			     CCritSec *pLock,
			     HRESULT *phr,
			     LPCWSTR pPinName) :
    CBasePin(pObjectName, pFilter, pLock, phr, pPinName, PINDIR_INPUT),
    m_pAllocator(NULL),
    m_bReadOnly(FALSE),
    m_bFlushing(FALSE)
{
    ZeroMemory(&m_SampleProps, sizeof(m_SampleProps));
}

/* Destructor releases it's reference count on the default allocator */

CBaseInputPin::~CBaseInputPin()
{
    if (m_pAllocator != NULL) {
	m_pAllocator->Release();
	m_pAllocator = NULL;
    }
}


// override this to publicise our interfaces
STDMETHODIMP
CBaseInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we know about this interface */

    if (riid == IID_IMemInputPin) {
	return GetInterface((IMemInputPin *) this, ppv);
    } else {
	return CBasePin::NonDelegatingQueryInterface(riid, ppv);
    }
}


/* Return the allocator interface that this input pin would like the output
   pin to use. NOTE subsequent calls to GetAllocator should all return an
   interface onto the SAME object so we create one object at the start

   Note:
       The allocator is Release()'d on disconnect and replaced on
       NotifyAllocator().

   Override this to provide your own allocator.
*/

STDMETHODIMP
CBaseInputPin::GetAllocator(
    IMemAllocator **ppAllocator)
{
    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);

    if (m_pAllocator == NULL) {
#if 0
	HRESULT hr = S_OK;

	/* Create the new allocator object */

	CMemAllocator *pMemObject = new CMemAllocator(NAME("Default memory allocator"),
						      NULL, &hr);
	if (pMemObject == NULL) {
	    return E_OUTOFMEMORY;
	}

	if (FAILED(hr)) {
	    ASSERT(pMemObject);
	    delete pMemObject;
	    return hr;
	}

        m_pAllocator = pMemObject;

        /*  We AddRef() our own allocator */
        m_pAllocator->AddRef();
#else
        HRESULT hr = CreateMemoryAllocator(&m_pAllocator);
        if (FAILED(hr)) {
            return hr;
        }
#endif
    }
    ASSERT(m_pAllocator != NULL);
    *ppAllocator = m_pAllocator;
    m_pAllocator->AddRef();
    return NOERROR;
}


/* Tell the input pin which allocator the output pin is actually going to use
   Override this if you care - NOTE the locking we do both here and also in
   GetAllocator is unnecessary but derived classes that do something useful
   will undoubtedly have to lock the object so this might help remind people */

STDMETHODIMP
CBaseInputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    CheckPointer(pAllocator,E_POINTER);
    ValidateReadPtr(pAllocator,sizeof(IMemAllocator));
    CAutoLock cObjectLock(m_pLock);

    IMemAllocator *pOldAllocator = m_pAllocator;
    pAllocator->AddRef();
    m_pAllocator = pAllocator;

    if (pOldAllocator != NULL) {
	pOldAllocator->Release();
    }

    // the readonly flag indicates whether samples from this allocator should
    // be regarded as readonly - if true, then inplace transforms will not be
    // allowed.
    m_bReadOnly = (BYTE)bReadOnly;
    return NOERROR;
}


/*  Disconnect */

STDMETHODIMP CBaseInputPin::Disconnect()
{
    CAutoLock cObjectLock(m_pLock);

    /*  Call base class first because it calls Inactive() for us */
    HRESULT hr = CBasePin::Disconnect();

    if (S_OK == hr) {
        /* We don't need our allocator any more */
        if (m_pAllocator) {
            m_pAllocator->Release();
            m_pAllocator = NULL;
        }
    }
    return hr;
}


/* Do something with this media sample - this base class checks to see if the
   format has changed with this media sample and if so checks that the filter
   will accept it, generating a run time error if not. Once we have raised a
   run time error we set a flag so that no more samples will be accepted

   It is important that any filter should override this method and implement
   synchronization so that samples are not processed when the pin is
   disconnected etc
*/

STDMETHODIMP
CBaseInputPin::Receive(IMediaSample *pSample)
{
    CheckPointer(pSample,E_POINTER);
    ValidateReadPtr(pSample,sizeof(IMediaSample));
    AM_MEDIA_TYPE *pmt = NULL;
    ASSERT(pSample);

    HRESULT hr = CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }

    /* Check for IMediaSample2 */
    IMediaSample2 *pSample2;
    if (SUCCEEDED(pSample->QueryInterface(IID_IMediaSample2, (void **)&pSample2))) {
        hr = pSample2->GetProperties(sizeof(m_SampleProps), (PBYTE)&m_SampleProps);
        pSample2->Release();
        if (FAILED(hr)) {
            return hr;
        }
    } else {
        /*  Get the properties the hard way */
        m_SampleProps.cbData = sizeof(m_SampleProps);
        m_SampleProps.dwTypeSpecificFlags = 0;
        m_SampleProps.dwStreamId = AM_STREAM_MEDIA;
        m_SampleProps.dwSampleFlags = 0;
        if (S_OK == pSample->IsDiscontinuity()) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_DATADISCONTINUITY;
        }
        if (S_OK == pSample->IsPreroll()) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_PREROLL;
        }
        if (S_OK == pSample->IsSyncPoint()) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_SPLICEPOINT;
        }
        if (SUCCEEDED(pSample->GetTime(&m_SampleProps.tStart,
                                       &m_SampleProps.tStop))) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_TIMEVALID |
                                           AM_SAMPLE_STOPVALID;
        }
        if (S_OK == pSample->GetMediaType(&m_SampleProps.pMediaType)) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_TYPECHANGED;
        }
        pSample->GetPointer(&m_SampleProps.pbBuffer);
        m_SampleProps.lActual = pSample->GetActualDataLength();
        m_SampleProps.cbBuffer = pSample->GetSize();
    }

    /* Has the format changed in this sample */

    if (!(m_SampleProps.dwSampleFlags & AM_SAMPLE_TYPECHANGED)) {
	return NOERROR;
    }

    /* Check the derived class accepts this format */
    /* This shouldn't fail as the source must call QueryAccept first */

    hr = CheckMediaType((CMediaType *)m_SampleProps.pMediaType);

    if (hr == NOERROR) {
        return NOERROR;
    }

    /* Raise a runtime error if we fail the media type */

    m_bRunTimeError = TRUE;
    EndOfStream();
    m_pFilter->NotifyEvent(EC_ERRORABORT,VFW_E_TYPE_NOT_ACCEPTED,0);
    return VFW_E_INVALIDMEDIATYPE;
}


/*  Receive multiple samples */
STDMETHODIMP
CBaseInputPin::ReceiveMultiple (
    IMediaSample **pSamples,
    long nSamples,
    long *nSamplesProcessed)
{
    CheckPointer(pSamples,E_POINTER);
    ValidateReadPtr(pSamples,nSamples * sizeof(IMediaSample *));

    HRESULT hr = S_OK;
    *nSamplesProcessed = 0;
    while (nSamples-- > 0) {
         hr = Receive(pSamples[*nSamplesProcessed]);

         /*  S_FALSE means don't send any more */
         if (hr != S_OK) {
             break;
         }
         (*nSamplesProcessed)++;
    }
    return hr;
}

/*  See if Receive() might block */
STDMETHODIMP
CBaseInputPin::ReceiveCanBlock()
{
    /*  Ask all the output pins if they block
        If there are no output pin assume we do block
    */
    int cPins = m_pFilter->GetPinCount();
    int cOutputPins = 0;
    for (int c = 0; c < cPins; c++) {
        CBasePin *pPin = m_pFilter->GetPin(c);
        PIN_DIRECTION pd;
        HRESULT hr = pPin->QueryDirection(&pd);
        if (FAILED(hr)) {
            return hr;
        }

        if (pd == PINDIR_OUTPUT) {
            IPin *pConnected;
            hr = pPin->ConnectedTo(&pConnected);
            if (SUCCEEDED(hr)) {
                ASSERT(pConnected != NULL);
                cOutputPins++;
                IMemInputPin *pInputPin;
                hr = pConnected->QueryInterface(
                                              IID_IMemInputPin,
                                              (void **)&pInputPin);
                pConnected->Release();
                if (SUCCEEDED(hr)) {
                    hr = pInputPin->ReceiveCanBlock();
                    pInputPin->Release();
                    if (hr != S_FALSE) {
                        return S_OK;
                    }
                } else {
                    /*  There's a transport we don't understand here */
                    return S_OK;
                }
            }
        }
    }
    return cOutputPins == 0 ? S_OK : S_FALSE;
}

// Default handling for BeginFlush - call at the beginning
// of your implementation (makes sure that all Receive calls
// fail). After calling this, you need to free any queued data
// and then call downstream.
STDMETHODIMP
CBaseInputPin::BeginFlush(void)
{
    //  BeginFlush is NOT synchronized with streaming but is part of
    //  a control action - hence we synchronize with the filter
    CAutoLock lck(m_pLock);

    // if we are already in mid-flush, this is probably a mistake
    // though not harmful - try to pick it up for now so I can think about it
    ASSERT(!m_bFlushing);

    // first thing to do is ensure that no further Receive calls succeed
    m_bFlushing = TRUE;

    // now discard any data and call downstream - must do that
    // in derived classes
    return S_OK;
}

// default handling for EndFlush - call at end of your implementation
// - before calling this, ensure that there is no queued data and no thread
// pushing any more without a further receive, then call downstream,
// then call this method to clear the m_bFlushing flag and re-enable
// receives
STDMETHODIMP
CBaseInputPin::EndFlush(void)
{
    //  Endlush is NOT synchronized with streaming but is part of
    //  a control action - hence we synchronize with the filter
    CAutoLock lck(m_pLock);

    // almost certainly a mistake if we are not in mid-flush
    ASSERT(m_bFlushing);

    // before calling, sync with pushing thread and ensure
    // no more data is going downstream, then call EndFlush on
    // downstream pins.

    // now re-enable Receives
    m_bFlushing = FALSE;

    return S_OK;
}


STDMETHODIMP
CBaseInputPin::Notify(IBaseFilter * pSender, Quality q)
{
    UNREFERENCED_PARAMETER(q);
    CheckPointer(pSender,E_POINTER);
    ValidateReadPtr(pSender,sizeof(IBaseFilter));
    DbgBreak("IQuality::Notify called on an input pin");
    return NOERROR;
} // Notify

/* Free up or unprepare allocator's memory, this is called through
   IMediaFilter which is responsible for locking the object first */

HRESULT
CBaseInputPin::Inactive(void)
{
    m_bRunTimeError = FALSE;
    if (m_pAllocator == NULL) {
	return VFW_E_NO_ALLOCATOR;
    }

    m_bFlushing = FALSE;

    return m_pAllocator->Decommit();
}

// what requirements do we have of the allocator - override if you want
// to support other people's allocators but need a specific alignment
// or prefix.
STDMETHODIMP
CBaseInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    UNREFERENCED_PARAMETER(pProps);
    return E_NOTIMPL;
}

//  Check if it's OK to process data
//
HRESULT
CBaseInputPin::CheckStreaming()
{
    //  Shouldn't be able to get any data if we're not connected!
    ASSERT(IsConnected());

    //  Don't process stuff in Stopped state
    if (IsStopped()) {
        return VFW_E_WRONG_STATE;
    }
    if (m_bFlushing) {
        return S_FALSE;
    }
    if (m_bRunTimeError) {
	return VFW_E_RUNTIME_ERROR;
    }
    return S_OK;
}

// Pass on the Quality notification q to
// a. Our QualityControl sink (if we have one) or else
// b. to our upstream filter
// and if that doesn't work, throw it away with a bad return code
HRESULT
CBaseInputPin::PassNotify(Quality& q)
{
    // We pass the message on, which means that we find the quality sink
    // for our input pin and send it there

    DbgLog((LOG_TRACE,3,TEXT("Passing Quality notification through transform")));
    if (m_pQSink!=NULL) {
        return m_pQSink->Notify(m_pFilter, q);
    } else {
        // no sink set, so pass it upstream
        HRESULT hr;
        IQualityControl * pIQC;

        hr = VFW_E_NOT_FOUND;                   // default
        if (m_Connected) {
            m_Connected->QueryInterface(IID_IQualityControl, (void**)&pIQC);

            if (pIQC!=NULL) {
                hr = pIQC->Notify(m_pFilter, q);
                pIQC->Release();
            }
        }
        return hr;
    }

} // PassNotify

//=====================================================================
//=====================================================================
// Memory allocation class, implements CMediaSample
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor with
   a NULL outer unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants it's lifetime controlled by the external object */

/* The last two parameters have default values of NULL and zero */

CMediaSample::CMediaSample(TCHAR *pName,
			   CBaseAllocator *pAllocator,
			   HRESULT *phr,
			   LPBYTE pBuffer,
			   LONG length) :
    m_pBuffer(pBuffer),             // Initialise the buffer
    m_cbBuffer(length),             // And it's length
    m_lActual(length),              // By default, actual = length
    m_pMediaType(NULL),             // No media type change
    m_dwFlags(0),                   // Nothing set
    m_cRef(0),                      // 0 ref count
    m_dwTypeSpecificFlags(0),       // Type specific flags
    m_dwStreamId(AM_STREAM_MEDIA),  // Stream id
    m_pAllocator(pAllocator)        // Allocator
{
    /* We must have an owner and it must also be derived from class
       CBaseAllocator BUT we do not hold a reference count on it */

    ASSERT(pAllocator);
}


/* Destructor deletes the media type memory */

CMediaSample::~CMediaSample()
{
    if (m_pMediaType) {
	DeleteMediaType(m_pMediaType);
    }
}

/* Override this to publicise our interfaces */

STDMETHODIMP
CMediaSample::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IMediaSample ||
        riid == IID_IMediaSample2 ||
        riid == IID_IUnknown) {
	return GetInterface((IMediaSample *) this, ppv);
    } else {
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CMediaSample::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// --  CMediaSample lifetimes --
//
// On final release of this sample buffer it is not deleted but
// returned to the freelist of the owning memory allocator
//
// The allocator may be waiting for the last buffer to be placed on the free
// list in order to decommit all the memory, so the ReleaseBuffer() call may
// result in this sample being deleted. We also need to hold a refcount on
// the allocator to stop that going away until we have finished with this.
// However, we cannot release the allocator before the ReleaseBuffer, as the
// release may cause us to be deleted. Similarly we can't do it afterwards.
//
// Thus we must leave it to the allocator to hold an addref on our behalf.
// When he issues us in GetBuffer, he addref's himself. When ReleaseBuffer
// is called, he releases himself, possibly causing us and him to be deleted.


STDMETHODIMP_(ULONG)
CMediaSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
	    this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {
        /* Free all resources */
        if (m_dwFlags & Sample_TypeChanged) {
            SetMediaType(NULL);
        }
        ASSERT(m_pMediaType == NULL);
        m_dwFlags = 0;
        m_dwTypeSpecificFlags = 0;
        m_dwStreamId = AM_STREAM_MEDIA;

        /* This may cause us to be deleted */
        // Our refcount is reliably 0 thus no-one will mess with us
        m_pAllocator->ReleaseBuffer(this);
    }
    return (ULONG)lRef;
}


// set the buffer pointer and length. Used by allocators that
// want variable sized pointers or pointers into already-read data.
// This is only available through a CMediaSample* not an IMediaSample*
// and so cannot be changed by clients.
HRESULT
CMediaSample::SetPointer(BYTE * ptr, LONG cBytes)
{
    m_pBuffer = ptr;            // new buffer area (could be null)
    m_cbBuffer = cBytes;        // length of buffer
    m_lActual = cBytes;         // length of data in buffer (assume full)

    return S_OK;
}


// get me a read/write pointer to this buffer's memory. I will actually
// want to use sizeUsed bytes.
STDMETHODIMP
CMediaSample::GetPointer(BYTE ** ppBuffer)
{
    ValidateReadWritePtr(ppBuffer,sizeof(BYTE *));

    // creator must have set pointer either during
    // constructor or by SetPointer
    ASSERT(m_pBuffer);

    *ppBuffer = m_pBuffer;
    return NOERROR;
}


// return the size in bytes of this buffer
STDMETHODIMP_(LONG)
CMediaSample::GetSize(void)
{
    return m_cbBuffer;
}


// get the stream time at which this sample should start and finish.
STDMETHODIMP
CMediaSample::GetTime(
    REFERENCE_TIME * pTimeStart,     // put time here
    REFERENCE_TIME * pTimeEnd
)
{
    ValidateReadWritePtr(pTimeStart,sizeof(REFERENCE_TIME));
    ValidateReadWritePtr(pTimeEnd,sizeof(REFERENCE_TIME));

    if (!(m_dwFlags & Sample_StopValid)) {
        if (!(m_dwFlags & Sample_TimeValid)) {
            return VFW_E_SAMPLE_TIME_NOT_SET;
        } else {
            *pTimeStart = m_Start;

            //  Make sure old stuff works
            *pTimeEnd = m_Start + 1;
            return VFW_S_NO_STOP_TIME;
        }
    }

    *pTimeStart = m_Start;
    *pTimeEnd = m_End;
    return NOERROR;
}


// Set the stream time at which this sample should start and finish.
// NULL pointers means the time is reset
STDMETHODIMP
CMediaSample::SetTime(
    REFERENCE_TIME * pTimeStart,
    REFERENCE_TIME * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        ASSERT(pTimeEnd == NULL);
        m_dwFlags &= ~(Sample_TimeValid | Sample_StopValid);
    } else {
        if (pTimeEnd == NULL) {
            m_Start = *pTimeStart;
            m_dwFlags |= Sample_TimeValid;
            m_dwFlags &= ~Sample_StopValid;
        } else {
            ValidateReadPtr(pTimeStart,sizeof(REFERENCE_TIME));
            ValidateReadPtr(pTimeEnd,sizeof(REFERENCE_TIME));
            ASSERT(*pTimeEnd >= *pTimeStart);

            m_Start = *pTimeStart;
            m_End = *pTimeEnd;
            m_dwFlags |= Sample_TimeValid | Sample_StopValid;
        }
    }
    return NOERROR;
}


// get the media times (eg bytes) for this sample
STDMETHODIMP
CMediaSample::GetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    ValidateReadWritePtr(pTimeStart,sizeof(LONGLONG));
    ValidateReadWritePtr(pTimeEnd,sizeof(LONGLONG));

    if (!(m_dwFlags & Sample_MediaTimeValid)) {
        return VFW_E_MEDIA_TIME_NOT_SET;
    }

    *pTimeStart = m_MediaStart;
    *pTimeEnd = (m_MediaStart + m_MediaEnd);
    return NOERROR;
}


// Set the media times for this sample
STDMETHODIMP
CMediaSample::SetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        ASSERT(pTimeEnd == NULL);
        m_dwFlags &= ~Sample_MediaTimeValid;
    } else {
        ValidateReadPtr(pTimeStart,sizeof(LONGLONG));
        ValidateReadPtr(pTimeEnd,sizeof(LONGLONG));
	ASSERT(*pTimeEnd >= *pTimeStart);

        m_MediaStart = *pTimeStart;
        m_MediaEnd = (LONG)(*pTimeEnd - *pTimeStart);
        m_dwFlags |= Sample_MediaTimeValid;
    }
    return NOERROR;
}


STDMETHODIMP
CMediaSample::IsSyncPoint(void)
{
    if (m_dwFlags & Sample_SyncPoint) {
	return S_OK;
    } else {
	return S_FALSE;
    }
}


STDMETHODIMP
CMediaSample::SetSyncPoint(BOOL bIsSyncPoint)
{
    if (bIsSyncPoint) {
        m_dwFlags |= Sample_SyncPoint;
    } else {
        m_dwFlags &= ~Sample_SyncPoint;
    }
    return NOERROR;
}

// returns S_OK if there is a discontinuity in the data (this same is
// not a continuation of the previous stream of data
// - there has been a seek).
STDMETHODIMP
CMediaSample::IsDiscontinuity(void)
{
    if (m_dwFlags & Sample_Discontinuity) {
	return S_OK;
    } else {
	return S_FALSE;
    }
}

// set the discontinuity property - TRUE if this sample is not a
// continuation, but a new sample after a seek.
STDMETHODIMP
CMediaSample::SetDiscontinuity(BOOL bDiscont)
{
    // should be TRUE or FALSE
    if (bDiscont) {
        m_dwFlags |= Sample_Discontinuity;
    } else {
        m_dwFlags &= ~Sample_Discontinuity;
    }
    return S_OK;
}

STDMETHODIMP
CMediaSample::IsPreroll(void)
{
    if (m_dwFlags & Sample_Preroll) {
	return S_OK;
    } else {
	return S_FALSE;
    }
}


STDMETHODIMP
CMediaSample::SetPreroll(BOOL bIsPreroll)
{
    if (bIsPreroll) {
        m_dwFlags |= Sample_Preroll;
    } else {
        m_dwFlags &= ~Sample_Preroll;
    }
    return NOERROR;
}

STDMETHODIMP_(LONG)
CMediaSample::GetActualDataLength(void)
{
    return m_lActual;
}


STDMETHODIMP
CMediaSample::SetActualDataLength(LONG lActual)
{
    if (lActual > m_cbBuffer) {
        ASSERT(lActual <= GetSize());
	return VFW_E_BUFFER_OVERFLOW;
    }
    m_lActual = lActual;
    return NOERROR;
}


/* These allow for limited format changes in band */

STDMETHODIMP
CMediaSample::GetMediaType(AM_MEDIA_TYPE **ppMediaType)
{
    ValidateReadWritePtr(ppMediaType,sizeof(AM_MEDIA_TYPE *));
    ASSERT(ppMediaType);

    /* Do we have a new media type for them */

    if (!(m_dwFlags & Sample_TypeChanged)) {
	ASSERT(m_pMediaType == NULL);
	*ppMediaType = NULL;
	return S_FALSE;
    }

    ASSERT(m_pMediaType);

    /* Create a copy of our media type */

    *ppMediaType = CreateMediaType(m_pMediaType);
    if (*ppMediaType == NULL) {
	return E_OUTOFMEMORY;
    }
    return NOERROR;
}


/* Mark this sample as having a different format type */

STDMETHODIMP
CMediaSample::SetMediaType(AM_MEDIA_TYPE *pMediaType)
{
    /* Delete the current media type */

    if (m_pMediaType) {
	DeleteMediaType(m_pMediaType);
	m_pMediaType = NULL;
    }

    /* Mechanism for resetting the format type */

    if (pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
	return NOERROR;
    }

    ASSERT(pMediaType);
    ValidateReadPtr(pMediaType,sizeof(AM_MEDIA_TYPE));

    /* Take a copy of the media type */

    m_pMediaType = CreateMediaType(pMediaType);
    if (m_pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
	return E_OUTOFMEMORY;
    }

    m_dwFlags |= Sample_TypeChanged;
    return NOERROR;
}

// Set and get properties (IMediaSample2)
STDMETHODIMP CMediaSample::GetProperties(
    DWORD cbProperties,
    BYTE * pbProperties
)
{
    if (0 != cbProperties) {
        CheckPointer(pbProperties, E_POINTER);
        //  Return generic stuff up to the length
        AM_SAMPLE2_PROPERTIES Props;
        Props.cbData     = min(cbProperties, sizeof(Props));
        Props.dwSampleFlags = m_dwFlags & ~Sample_MediaTimeValid;
        Props.dwTypeSpecificFlags = m_dwTypeSpecificFlags;
        Props.pbBuffer   = m_pBuffer;
        Props.cbBuffer   = m_cbBuffer;
        Props.lActual    = m_lActual;
        Props.tStart     = m_Start;
        Props.tStop      = m_End;
        Props.dwStreamId = m_dwStreamId;
        if (m_dwFlags & AM_SAMPLE_TYPECHANGED) {
            Props.pMediaType = m_pMediaType;
        } else {
            Props.pMediaType = NULL;
        }
        CopyMemory(pbProperties, &Props, Props.cbData);
    }
    return S_OK;
}

#define CONTAINS_FIELD(type, field, offset) \
    ((FIELD_OFFSET(type, field) + sizeof(((type *)0)->field)) <= offset)

HRESULT CMediaSample::SetProperties(
    DWORD cbProperties,
    const BYTE * pbProperties
)
{

    /*  Generic properties */
    AM_MEDIA_TYPE *pMediaType = NULL;

    if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbData, cbProperties)) {
        CheckPointer(pbProperties, E_POINTER);
        AM_SAMPLE2_PROPERTIES *pProps =
            (AM_SAMPLE2_PROPERTIES *)pbProperties;

        /*  Don't use more data than is actually there */
        if (pProps->cbData < cbProperties) {
            cbProperties = pProps->cbData;
        }
        /*  We only handle IMediaSample2 */
        if (cbProperties > sizeof(*pProps) ||
            pProps->cbData > sizeof(*pProps)) {
            return E_INVALIDARG;
        }
        /*  Do checks first, the assignments (for backout) */
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Check the flags */
            if (pProps->dwSampleFlags &
                    (~Sample_ValidFlags | Sample_MediaTimeValid)) {
                return E_INVALIDARG;
            }
            /*  Check a flag isn't being set for a property
                not being provided
            */
            if ((pProps->dwSampleFlags & AM_SAMPLE_TIMEVALID) &&
                 !(m_dwFlags & AM_SAMPLE_TIMEVALID) &&
                 !CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {
                 return E_INVALIDARG;
            }
        }
        /*  NB - can't SET the pointer or size */
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pbBuffer, cbProperties)) {

            /*  Check pbBuffer */
            if (pProps->pbBuffer != 0 && pProps->pbBuffer != m_pBuffer) {
                return E_INVALIDARG;
            }
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties)) {

            /*  Check cbBuffer */
            if (pProps->cbBuffer != 0 && pProps->cbBuffer != m_cbBuffer) {
                return E_INVALIDARG;
            }
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties) &&
            CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {

            /*  Check lActual */
            if (pProps->cbBuffer < pProps->lActual) {
                return E_INVALIDARG;
            }
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {

            /*  Check pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                CheckPointer(pProps->pMediaType, E_POINTER);
                pMediaType = CreateMediaType(pProps->pMediaType);
                if (pMediaType == NULL) {
                    return E_OUTOFMEMORY;
                }
            }
        }

        /*  Now do the assignments */
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwStreamId, cbProperties)) {
            m_dwStreamId = pProps->dwStreamId;
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Set the flags */
            m_dwFlags = pProps->dwSampleFlags |
                                (m_dwFlags & Sample_MediaTimeValid);
            m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
        } else {
            if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwTypeSpecificFlags, cbProperties)) {
                m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
            }
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {
            /*  Set lActual */
            m_lActual = pProps->lActual;
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {

            /*  Set the times */
            m_End   = pProps->tStop;
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStart, cbProperties)) {

            /*  Set the times */
            m_Start = pProps->tStart;
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {
            /*  Set pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                if (m_pMediaType != NULL) {
                    DeleteMediaType(m_pMediaType);
                }
                m_pMediaType = pMediaType;
            }
        }
    }

    return S_OK;
}

//=====================================================================
//=====================================================================
// Implements CBaseAllocator
//=====================================================================
//=====================================================================


/* Constructor overrides the default settings for the free list to request
   that it be alertable (ie the list can be cast to a handle which can be
   passed to WaitForSingleObject). Both of the allocator lists also ask for
   object locking, the all list matches the object default settings but I
   have included them here just so it is obvious what kind of list it is */

CBaseAllocator::CBaseAllocator(TCHAR *pName,
			       LPUNKNOWN pUnk,
			       HRESULT *phr,
                               BOOL bEvent) :
    CUnknown(pName, pUnk),
    m_lAllocated(0),
    m_bChanged(FALSE),
    m_bCommitted(FALSE),
    m_bDecommitInProgress(FALSE),
    m_lSize(0),
    m_lCount(0),
    m_lAlignment(0),
    m_lPrefix(0),
    m_hSem(NULL),
    m_lWaiting(0)
{
    if (bEvent) {
        m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL);
        if (m_hSem == NULL) {
            *phr = E_OUTOFMEMORY;
            return;
        }
    }
}


/* Destructor */

CBaseAllocator::~CBaseAllocator()
{
    // we can't call Decommit here since that would mean a call to a
    // pure virtual in destructor.
    // We must assume that the derived class has gone into decommit state in
    // its destructor.
    ASSERT(!m_bCommitted);
    if (m_hSem != NULL) {
        EXECUTE_ASSERT(CloseHandle(m_hSem));
    }
}


/* Override this to publicise our interfaces */

STDMETHODIMP
CBaseAllocator::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we know about this interface */

    if (riid == IID_IMemAllocator) {
        return GetInterface((IMemAllocator *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


/* This sets the size and count of the required samples. The memory isn't
   actually allocated until Commit() is called, if memory has already been
   allocated then assuming no samples are outstanding the user may call us
   to change the buffering, the memory will be released in Commit() */

STDMETHODIMP
CBaseAllocator::SetProperties(
                ALLOCATOR_PROPERTIES* pRequest,
                ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pRequest, E_POINTER);
    CheckPointer(pActual, E_POINTER);
    ValidateReadWritePtr(pActual, sizeof(ALLOCATOR_PROPERTIES));
    CAutoLock cObjectLock(this);

    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

    ASSERT(pRequest->cbBuffer > 0);

    /*  Check the alignment requested */
    if (pRequest->cbAlign != 1) {
	DbgLog((LOG_ERROR, 2, TEXT("Alignment requested was 0x%x, not 1"),
	       pRequest->cbAlign));
	return VFW_E_BADALIGN;
    }

    /* Can't do this if already comm