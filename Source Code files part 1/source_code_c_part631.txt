 172 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 174 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 176 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 178 */	NdrFcShort( 0x24 ),	/* 36 */
/* 180 */	NdrFcShort( 0x5c ),	/* 92 */
/* 182 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 184 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 186 */	NdrFcShort( 0x1 ),	/* 1 */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 192 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 194 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 196 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 198 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 200 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 202 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 206 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumInfo */

/* 210 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 212 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 214 */	NdrFcShort( 0x50 ),	/* Type Offset=80 */

	/* Parameter ElementsRead */

/* 216 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 218 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 222 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 224 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 230 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElement */

/* 234 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0x4 ),	/* 4 */
#ifndef _ALPHA_
/* 242 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 244 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 246 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 248 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 254 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 256 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x2 ),	/* 2 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 264 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 266 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 268 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 270 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 272 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 276 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 278 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 280 */	NdrFcShort( 0xf6 ),	/* Type Offset=246 */

	/* Return value */

/* 282 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 284 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElements */

/* 288 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 290 */	NdrFcLong( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x5 ),	/* 5 */
#ifndef _ALPHA_
/* 296 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
#else
			NdrFcShort( 0x48 ),	/* Alpha Stack size/offset = 72 */
#endif
/* 298 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 300 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 302 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 304 */	NdrFcShort( 0x32 ),	/* 50 */
/* 306 */	NdrFcShort( 0x5c ),	/* 92 */
/* 308 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 310 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 312 */	NdrFcShort( 0x3 ),	/* 3 */
/* 314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 316 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 318 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 320 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 322 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 324 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 326 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 330 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 332 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 334 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 336 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 338 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 344 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 346 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 348 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 350 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 352 */	NdrFcShort( 0x104 ),	/* Type Offset=260 */

	/* Parameter ElementsRead */

/* 354 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 356 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 360 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 362 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 366 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 368 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElement */

/* 372 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 374 */	NdrFcLong( 0x0 ),	/* 0 */
/* 378 */	NdrFcShort( 0x6 ),	/* 6 */
#ifndef _ALPHA_
/* 380 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 382 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 384 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 386 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 388 */	NdrFcShort( 0xe ),	/* 14 */
/* 390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 392 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 394 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 396 */	NdrFcShort( 0x0 ),	/* 0 */
/* 398 */	NdrFcShort( 0x2 ),	/* 2 */
/* 400 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 402 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 404 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 406 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 410 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 414 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 416 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 418 */	NdrFcShort( 0xf6 ),	/* Type Offset=246 */

	/* Parameter ForceFlag */

/* 420 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 424 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 428 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSubnet */

/* 432 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 440 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 442 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 444 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 446 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 448 */	NdrFcShort( 0xe ),	/* 14 */
/* 450 */	NdrFcShort( 0x8 ),	/* 8 */
/* 452 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 454 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 462 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 464 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 466 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 468 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 470 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 472 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ForceFlag */

/* 474 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 476 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 478 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 480 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 482 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateOption */

/* 486 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 488 */	NdrFcLong( 0x0 ),	/* 0 */
/* 492 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 494 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 496 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 498 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 500 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 502 */	NdrFcShort( 0x8 ),	/* 8 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 508 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x4 ),	/* 4 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 516 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 518 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 520 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 522 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 524 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 528 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 530 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 532 */	NdrFcShort( 0x136 ),	/* Type Offset=310 */

	/* Return value */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 536 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionInfo */

/* 540 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 548 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 550 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 552 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 554 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 556 */	NdrFcShort( 0x8 ),	/* 8 */
/* 558 */	NdrFcShort( 0x8 ),	/* 8 */
/* 560 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 562 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x4 ),	/* 4 */
/* 568 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 570 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 572 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 574 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 576 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 578 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 580 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 582 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 584 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 586 */	NdrFcShort( 0x136 ),	/* Type Offset=310 */

	/* Return value */

/* 588 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 590 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 592 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionInfo */

/* 594 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 596 */	NdrFcLong( 0x0 ),	/* 0 */
/* 600 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 602 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 604 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 606 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 608 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
/* 612 */	NdrFcShort( 0x8 ),	/* 8 */
/* 614 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 616 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 618 */	NdrFcShort( 0x4 ),	/* 4 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 624 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 626 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 628 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 630 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 632 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 636 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 638 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 640 */	NdrFcShort( 0x1cc ),	/* Type Offset=460 */

	/* Return value */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 644 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOption */

/* 648 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 656 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 658 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 660 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 662 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 664 */	NdrFcShort( 0x8 ),	/* 8 */
/* 666 */	NdrFcShort( 0x8 ),	/* 8 */
/* 668 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 670 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 678 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 680 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 682 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 686 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 690 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 692 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValue */

/* 696 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 698 */	NdrFcLong( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 704 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 706 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 708 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 710 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 712 */	NdrFcShort( 0x8 ),	/* 8 */
/* 714 */	NdrFcShort( 0x8 ),	/* 8 */
/* 716 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 718 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x5 ),	/* 5 */
/* 724 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 726 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 728 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 730 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 732 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 734 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 736 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 738 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 740 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 742 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValue */

/* 744 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 746 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 748 */	NdrFcShort( 0x19e ),	/* Type Offset=414 */

	/* Return value */

/* 750 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 752 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 754 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionValue */

/* 756 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 758 */	NdrFcLong( 0x0 ),	/* 0 */
/* 762 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 764 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 766 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 768 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 770 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 772 */	NdrFcShort( 0x8 ),	/* 8 */
/* 774 */	NdrFcShort( 0x8 ),	/* 8 */
/* 776 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 778 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 780 */	NdrFcShort( 0x4 ),	/* 4 */
/* 782 */	NdrFcShort( 0x1 ),	/* 1 */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 786 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 788 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 790 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 792 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 794 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 798 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 800 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 802 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValue */

/* 804 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 806 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 808 */	NdrFcShort( 0x218 ),	/* Type Offset=536 */

	/* Return value */

/* 810 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 812 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptionValues */

/* 816 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 818 */	NdrFcLong( 0x0 ),	/* 0 */
/* 822 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 824 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 826 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 828 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 830 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 832 */	NdrFcShort( 0x24 ),	/* 36 */
/* 834 */	NdrFcShort( 0x5c ),	/* 92 */
/* 836 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 838 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 840 */	NdrFcShort( 0x5 ),	/* 5 */
/* 842 */	NdrFcShort( 0x1 ),	/* 1 */
/* 844 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 846 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 848 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 850 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 852 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 854 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 856 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter ResumeHandle */

/* 858 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 860 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 864 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 866 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionValues */

/* 870 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 872 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 874 */	NdrFcShort( 0x24c ),	/* Type Offset=588 */

	/* Parameter OptionsRead */

/* 876 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 878 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 880 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 882 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 884 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 888 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 890 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOptionValue */

/* 894 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 896 */	NdrFcLong( 0x0 ),	/* 0 */
/* 900 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 902 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 904 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 906 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 908 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 910 */	NdrFcShort( 0x8 ),	/* 8 */
/* 912 */	NdrFcShort( 0x8 ),	/* 8 */
/* 914 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 916 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 920 */	NdrFcShort( 0x1 ),	/* 1 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 924 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 926 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 928 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 932 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 936 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 938 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 940 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Return value */

/* 942 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 944 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfo */

/* 948 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 950 */	NdrFcLong( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 956 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 958 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 960 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 962 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 966 */	NdrFcShort( 0x8 ),	/* 8 */
/* 968 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 970 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 972 */	NdrFcShort( 0x0 ),	/* 0 */
/* 974 */	NdrFcShort( 0x1 ),	/* 1 */
/* 976 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 978 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 980 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 982 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 984 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 986 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 988 */	NdrFcShort( 0x28a ),	/* Type Offset=650 */

	/* Return value */

/* 990 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 992 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 994 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfo */

/* 996 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 998 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1002 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 1004 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1006 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1008 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1010 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1014 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1016 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1018 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1020 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1022 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1024 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1026 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1028 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1030 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1032 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 1034 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1036 */	NdrFcShort( 0x28a ),	/* Type Offset=650 */

	/* Return value */

/* 1038 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1040 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1042 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfo */

/* 1044 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1046 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1050 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 1052 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1054 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1056 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1058 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1064 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1066 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1068 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1070 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1074 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1076 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1078 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 1080 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1082 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1084 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Parameter ClientInfo */

/* 1086 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1088 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1090 */	NdrFcShort( 0x316 ),	/* Type Offset=790 */

	/* Return value */

/* 1092 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1094 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1096 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteClientInfo */

/* 1098 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1100 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0x13 ),	/* 19 */
#ifndef _ALPHA_
/* 1106 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1108 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1110 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1112 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1118 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1120 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1126 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1128 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1130 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1132 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1134 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1136 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1138 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Return value */

/* 1140 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1142 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClients */

/* 1146 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1148 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1152 */	NdrFcShort( 0x14 ),	/* 20 */
#ifndef _ALPHA_
/* 1154 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 1156 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1158 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1160 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1162 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1164 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1166 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1168 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1170 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1174 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1178 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1180 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1182 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1184 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1188 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1190 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1194 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1196 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 1200 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1202 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1204 */	NdrFcShort( 0x31e ),	/* Type Offset=798 */

	/* Parameter ClientsRead */

/* 1206 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1208 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 1212 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1214 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1220 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientOptions */

/* 1224 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x15 ),	/* 21 */
#ifndef _ALPHA_
/* 1232 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1234 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1236 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1238 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1240 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1242 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1244 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1246 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1248 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1252 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1254 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1256 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1258 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientIpAddress */

/* 1260 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientSubnetMask */

/* 1266 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientOptions */

/* 1272 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1274 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1276 */	NdrFcShort( 0x35a ),	/* Type Offset=858 */

	/* Return value */

/* 1278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1280 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetMibInfo */

/* 1284 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1290 */	NdrFcShort( 0x16 ),	/* 22 */
#ifndef _ALPHA_
/* 1292 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1294 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1296 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1298 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1304 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1306 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1308 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1314 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1316 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1318 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MibInfo */

/* 1320 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1322 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1324 */	NdrFcShort( 0x376 ),	/* Type Offset=886 */

	/* Return value */

/* 1326 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1328 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptions */

/* 1332 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1334 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1338 */	NdrFcShort( 0x17 ),	/* 23 */
#ifndef _ALPHA_
/* 1340 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1342 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1344 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1346 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1348 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1350 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1352 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1354 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1356 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1360 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1362 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1364 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1366 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 1368 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1370 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1374 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1376 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Options */

/* 1380 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1382 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1384 */	NdrFcShort( 0x3b8 ),	/* Type Offset=952 */

	/* Parameter OptionsRead */

/* 1386 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1388 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1390 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 1392 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1394 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1398 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1400 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1402 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValues */

/* 1404 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1406 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1410 */	NdrFcShort( 0x18 ),	/* 24 */
#ifndef _ALPHA_
/* 1412 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1414 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1416 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1418 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1422 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1424 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1426 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1430 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1432 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1434 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1436 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1438 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 1440 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1442 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1444 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValues */

/* 1446 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 1448 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1450 */	NdrFcShort( 0x3ea ),	/* Type Offset=1002 */

	/* Return value */

/* 1452 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1454 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1456 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfig */

/* 1458 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1460 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1464 */	NdrFcShort( 0x19 ),	/* 25 */
#ifndef _ALPHA_
/* 1466 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1468 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1470 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1472 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1474 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1476 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1478 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1480 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1484 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1486 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1488 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1490 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1492 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 1494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1496 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 1500 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 1502 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1504 */	NdrFcShort( 0x3ee ),	/* Type Offset=1006 */

	/* Return value */

/* 1506 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1508 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfig */

/* 1512 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1514 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1518 */	NdrFcShort( 0x1a ),	/* 26 */
#ifndef _ALPHA_
/* 1520 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1522 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1524 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1526 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1532 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1534 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1540 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1542 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1544 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1546 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 1548 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1552 */	NdrFcShort( 0x422 ),	/* Type Offset=1058 */

	/* Return value */

/* 1554 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpScanDatabase */

/* 1560 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1562 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1566 */	NdrFcShort( 0x1b ),	/* 27 */
#ifndef _ALPHA_
/* 1568 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1570 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1572 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1574 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1576 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1578 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1580 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1582 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1584 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1588 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1590 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1592 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1594 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1596 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1598 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter FixFlag */

/* 1602 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1604 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScanList */

/* 1608 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1610 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1612 */	NdrFcShort( 0x42a ),	/* Type Offset=1066 */

	/* Return value */

/* 1614 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1616 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1618 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetVersion */

/* 1620 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1622 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1626 */	NdrFcShort( 0x1c ),	/* 28 */
#ifndef _ALPHA_
/* 1628 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1630 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1632 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1634 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1636 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1638 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1640 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1642 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1650 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1652 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1654 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MajorVersion */

/* 1656 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1658 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter MinorVersion */

/* 1662 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1664 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1670 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElementV4 */

/* 1674 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1676 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1680 */	NdrFcShort( 0x1d ),	/* 29 */
#ifndef _ALPHA_
/* 1682 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1684 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1686 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1688 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1692 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1694 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1696 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1700 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1702 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1704 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1706 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1708 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1710 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1712 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 1716 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1718 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1720 */	NdrFcShort( 0x4b0 ),	/* Type Offset=1200 */

	/* Return value */

/* 1722 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1724 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1726 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElementsV4 */

/* 1728 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1730 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1734 */	NdrFcShort( 0x1e ),	/* 30 */
#ifndef _ALPHA_
/* 1736 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
#else
			NdrFcShort( 0x48 ),	/* Alpha Stack size/offset = 72 */
#endif
/* 1738 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1740 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1742 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1744 */	NdrFcShort( 0x32 ),	/* 50 */
/* 1746 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1748 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 1750 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1752 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1754 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1758 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1760 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1762 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1764 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1766 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1768 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 1770 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1772 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1774 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1776 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1778 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1782 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1784 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 1788 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1790 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1792 */	NdrFcShort( 0x4be ),	/* Type Offset=1214 */

	/* Parameter ElementsRead */

/* 1794 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1796 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1798 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 1800 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1802 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1804 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1806 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1808 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 1810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElementV4 */

/* 1812 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1814 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0x1f ),	/* 31 */
#ifndef _ALPHA_
/* 1820 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1822 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1824 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1826 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1828 */	NdrFcShort( 0xe ),	/* 14 */
/* 1830 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1832 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1834 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1838 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1840 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1842 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1844 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1846 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1848 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1850 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1852 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 1854 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1856 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1858 */	NdrFcShort( 0x4b0 ),	/* Type Offset=1200 */

	/* Parameter ForceFlag */

/* 1860 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1862 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1864 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1866 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1868 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfoV4 */

/* 1872 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1874 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1878 */	NdrFcShort( 0x20 ),	/* 32 */
#ifndef _ALPHA_
/* 1880 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1882 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1884 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1886 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1890 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1892 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1894 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1896 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1898 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1900 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1902 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1904 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1906 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1908 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1910 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1912 */	NdrFcShort( 0x4f4 ),	/* Type Offset=1268 */

	/* Return value */

/* 1914 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1916 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1918 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfoV4 */

/* 1920 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1922 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1926 */	NdrFcShort( 0x21 ),	/* 33 */
#ifndef _ALPHA_
/* 1928 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1930 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1932 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1934 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1938 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1940 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1942 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1944 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1946 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1948 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1950 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1952 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1954 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1956 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1958 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1960 */	NdrFcShort( 0x4f4 ),	/* Type Offset=1268 */

	/* Return value */

/* 1962 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1964 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1966 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfoV4 */

/* 1968 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1970 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1974 */	NdrFcShort( 0x22 ),	/* 34 */
#ifndef _ALPHA_
/* 1976 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1978 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1980 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1982 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1986 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1988 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1990 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1992 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1994 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1996 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1998 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2000 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2002 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 2004 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2006 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2008 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Parameter ClientInfo */

/* 2010 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2012 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2014 */	NdrFcShort( 0x518 ),	/* Type Offset=1304 */

	/* Return value */

/* 2016 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2018 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClientsV4 */

/* 2022 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2028 */	NdrFcShort( 0x23 ),	/* 35 */
#ifndef _ALPHA_
/* 2030 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 2032 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2034 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2036 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2038 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2040 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2042 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 2044 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2046 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2048 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2050 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2052 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2054 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2056 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2058 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2060 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2062 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 2064 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 2066 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2068 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 2070 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2072 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2074 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 2076 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2078 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2080 */	NdrFcShort( 0x520 ),	/* Type Offset=1312 */

	/* Parameter ClientsRead */

/* 2082 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 2084 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 2088 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 2090 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2092 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2094 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2096 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 2098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSuperScopeV4 */

/* 2100 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2102 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2106 */	NdrFcShort( 0x24 ),	/* 36 */
#ifndef _ALPHA_
/* 2108 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2110 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2112 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2114 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2116 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2120 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2122 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2128 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2130 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2132 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2134 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2136 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2138 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SuperScopeName */

/* 2142 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2144 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2146 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ChangeExisting */

/* 2148 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2150 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2152 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2156 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSuperScopeInfoV4 */

/* 2160 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2166 */	NdrFcShort( 0x25 ),	/* 37 */
#ifndef _ALPHA_
/* 2168 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2170 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2172 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2174 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2180 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2182 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2188 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2190 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2192 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2194 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeTable */

/* 2196 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2198 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2200 */	NdrFcShort( 0x55c ),	/* Type Offset=1372 */

	/* Return value */

/* 2202 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2204 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSuperScopeV4 */

/* 2208 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2210 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2214 */	NdrFcShort( 0x26 ),	/* 38 */
#ifndef _ALPHA_
/* 2216 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2218 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2220 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2222 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2226 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2228 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2230 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2236 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2238 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2240 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2242 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeName */

/* 2244 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2246 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2248 */	NdrFcShort( 0x5b2 ),	/* Type Offset=1458 */

	/* Return value */

/* 2250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2252 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfigV4 */

/* 2256 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x27 ),	/* 39 */
#ifndef _ALPHA_
/* 2264 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2266 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2268 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2270 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2276 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2278 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2282 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2284 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2286 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2288 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2290 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 2292 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2294 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 2298 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2300 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2302 */	NdrFcShort( 0x5c4 ),	/* Type Offset=1476 */

	/* Return value */

/* 2304 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2306 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfigV4 */

/* 2310 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2312 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2316 */	NdrFcShort( 0x28 ),	/* 40 */
#ifndef _ALPHA_
/* 2318 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2320 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2322 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2324 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2330 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2332 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2334 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2338 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2340 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2342 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2344 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 2346 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2348 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2350 */	NdrFcShort( 0x602 ),	/* Type Offset=1538 */

	/* Return value */

/* 2352 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2354 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2356 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/*  8 */	NdrFcShort( 0x22 ),	/* Offset= 34 (42) */
/* 10 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 12 */	NdrFcShort( 0xc ),	/* 12 */
/* 14 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 16 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 18 */	NdrFcShort( 0x4 ),	/* 4 */
/* 20 */	NdrFcShort( 0x4 ),	/* 4 */
/* 22 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 24 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 26 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 28 */	NdrFcShort( 0x8 ),	/* 8 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 34 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 36 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 38 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0xc ),	/* Offset= 12 (60) */
/* 50 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 52 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 54 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 56 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (10) */
/* 58 */	0xd,		/* FC_ENUM16 */
			0x5b,		/* FC_END */
/* 60 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 62 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 64 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 66 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 68 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
/* 72 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 74 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (42) */
/* 76 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 78 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 80 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 82 */	NdrFcShort( 0x2 ),	/* Offset= 2 (84) */
/* 84 */	
			0x12, 0x0,	/* FC_UP */
/* 86 */	NdrFcShort( 0xe ),	/* Offset= 14 (100) */
/* 88 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 90 */	NdrFcShort( 0x4 ),	/* 4 */
/* 92 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 98 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 100 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 104 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 106 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 108 */	NdrFcShort( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x4 ),	/* 4 */
/* 112 */	0x12, 0x0,	/* FC_UP */
/* 114 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (88) */
/* 116 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 118 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 120 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 122 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 124 */	
			0x11, 0x0,	/* FC_RP */
/* 126 */	NdrFcShort( 0x78 ),	/* Offset= 120 (246) */
/* 128 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 130 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 136 */	NdrFcShort( 0x2 ),	/* Offset= 2 (138) */
/* 138 */	NdrFcShort( 0x4 ),	/* 4 */
/* 140 */	NdrFcShort( 0x5 ),	/* 5 */
/* 142 */	NdrFcLong( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0x1c ),	/* Offset= 28 (174) */
/* 148 */	NdrFcLong( 0x1 ),	/* 1 */
/* 152 */	NdrFcShort( 0x22 ),	/* Offset= 34 (186) */
/* 154 */	NdrFcLong( 0x2 ),	/* 2 */
/* 158 */	NdrFcShort( 0x20 ),	/* Offset= 32 (190) */
/* 160 */	NdrFcLong( 0x3 ),	/* 3 */
/* 164 */	NdrFcShort( 0xa ),	/* Offset= 10 (174) */
/* 166 */	NdrFcLong( 0x4 ),	/* 4 */
/* 170 */	NdrFcShort( 0x4 ),	/* Offset= 4 (174) */
/* 172 */	NdrFcShort( 0x0 ),	/* Offset= 0 (172) */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0x2 ),	/* Offset= 2 (178) */
/* 178 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 182 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 184 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffffff4e ),	/* Offset= -178 (10) */
/* 190 */	
			0x12, 0x0,	/* FC_UP */
/* 192 */	NdrFcShort( 0x22 ),	/* Offset= 34 (226) */
/* 194 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 196 */	NdrFcShort( 0x1 ),	/* 1 */
/* 198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 204 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 206 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 212 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 214 */	NdrFcShort( 0x4 ),	/* 4 */
/* 216 */	NdrFcShort( 0x4 ),	/* 4 */
/* 218 */	0x12, 0x0,	/* FC_UP */
/* 220 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (194) */
/* 222 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 224 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 226 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 230 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 232 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 234 */	NdrFcShort( 0x4 ),	/* 4 */
/* 236 */	NdrFcShort( 0x4 ),	/* 4 */
/* 238 */	0x12, 0x0,	/* FC_UP */
/* 240 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (206) */
/* 242 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 244 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 246 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 248 */	NdrFcShort( 0x8 ),	/* 8 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 252 */	NdrFcShort( 0x0 ),	/* Offset= 0 (252) */
/* 254 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 256 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff7f ),	/* Offset= -129 (128) */
			0x5b,		/* FC_END */
/* 260 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 262 */	NdrFcShort( 0x2 ),	/* Offset= 2 (264) */
/* 264 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 266 */	NdrFcShort( 0x18 ),	/* Offset= 24 (290) */
/* 268 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 278 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 282 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 284 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 286 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (246) */
/* 288 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 290 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 294 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 296 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 298 */	NdrFcShort( 0x4 ),	/* 4 */
/* 300 */	NdrFcShort( 0x4 ),	/* 4 */
/* 302 */	0x12, 0x0,	/* FC_UP */
/* 304 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (268) */
/* 306 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 308 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 310 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 312 */	NdrFcShort( 0x7a ),	/* Offset= 122 (434) */
/* 314 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 316 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 318 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 320 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 322 */	NdrFcShort( 0x2 ),	/* Offset= 2 (324) */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 328 */	NdrFcLong( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 334 */	NdrFcLong( 0x1 ),	/* 1 */
/* 338 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 340 */	NdrFcLong( 0x2 ),	/* 2 */
/* 344 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 346 */	NdrFcLong( 0x3 ),	/* 3 */
/* 350 */	NdrFcShort( 0xffffff54 ),	/* Offset= -172 (178) */
/* 352 */	NdrFcLong( 0x4 ),	/* 4 */
/* 356 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 358 */	NdrFcLong( 0x5 ),	/* 5 */
/* 362 */	NdrFcShort( 0xfffffe98 ),	/* Offset= -360 (2) */
/* 364 */	NdrFcLong( 0x6 ),	/* 6 */
/* 368 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (206) */
/* 370 */	NdrFcLong( 0x7 ),	/* 7 */
/* 374 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (206) */
/* 376 */	NdrFcShort( 0x0 ),	/* Offset= 0 (376) */
/* 378 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 380 */	NdrFcShort( 0xc ),	/* 12 */
/* 382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0x0 ),	/* Offset= 0 (384) */
/* 386 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 388 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb5 ),	/* Offset= -75 (314) */
			0x5b,		/* FC_END */
/* 392 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 402 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 406 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 408 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 410 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (378) */
/* 412 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 414 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 416 */	NdrFcShort( 0x8 ),	/* 8 */
/* 418 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 420 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 422 */	NdrFcShort( 0x4 ),	/* 4 */
/* 424 */	NdrFcShort( 0x4 ),	/* 4 */
/* 426 */	0x12, 0x0,	/* FC_UP */
/* 428 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (392) */
/* 430 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 432 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 434 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 436 */	NdrFcShort( 0x18 ),	/* 24 */
/* 438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0xc ),	/* Offset= 12 (452) */
/* 442 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 444 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 446 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdf ),	/* Offset= -33 (414) */
			0xd,		/* FC_ENUM16 */
/* 450 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 452 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 454 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 456 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 458 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 460 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 462 */	NdrFcShort( 0x2 ),	/* Offset= 2 (464) */
/* 464 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 466 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (434) */
/* 468 */	
			0x11, 0x0,	/* FC_RP */
/* 470 */	NdrFcShort( 0x30 ),	/* Offset= 48 (518) */
/* 472 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 474 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 476 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 478 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 480 */	NdrFcShort( 0x2 ),	/* Offset= 2 (482) */
/* 482 */	NdrFcShort( 0x8 ),	/* 8 */
/* 484 */	NdrFcShort( 0x5 ),	/* 5 */
/* 486 */	NdrFcLong( 0x0 ),	/* 0 */
/* 490 */	NdrFcShort( 0x0 ),	/* Offset= 0 (490) */
/* 492 */	NdrFcLong( 0x1 ),	/* 1 */
/* 496 */	NdrFcShort( 0x0 ),	/* Offset= 0 (496) */
/* 498 */	NdrFcLong( 0x2 ),	/* 2 */
/* 502 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 504 */	NdrFcLong( 0x3 ),	/* 3 */
/* 508 */	NdrFcShort( 0xfffffeb6 ),	/* Offset= -330 (178) */
/* 510 */	NdrFcLong( 0x4 ),	/* 4 */
/* 514 */	NdrFcShort( 0xfffffe00 ),	/* Offset= -512 (2) */
/* 516 */	NdrFcShort( 0x0 ),	/* Offset= 0 (516) */
/* 518 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 520 */	NdrFcShort( 0xc ),	/* 12 */
/* 522 */	NdrFcShort( 0x0 ),	/* 0 */
/* 524 */	NdrFcShort( 0x0 ),	/* Offset= 0 (524) */
/* 526 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 528 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc7 ),	/* Offset= -57 (472) */
			0x5b,		/* FC_END */
/* 532 */	
			0x11, 0x0,	/* FC_RP */
/* 534 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (414) */
/* 536 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 538 */	NdrFcShort( 0x2 ),	/* Offset= 2 (540) */
/* 540 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 542 */	NdrFcShort( 0x18 ),	/* Offset= 24 (566) */
/* 544 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 548 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 550 */	NdrFcShort( 0x4 ),	/* 4 */
/* 552 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 554 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 558 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 560 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 562 */	NdrFcShort( 0xffffff48 ),	/* Offset= -184 (378) */
/* 564 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 566 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 568 */	NdrFcShort( 0xc ),	/* 12 */
/* 570 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 572 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 578 */	0x12, 0x0,	/* FC_UP */
/* 580 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (544) */
/* 582 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 584 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 586 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 588 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 590 */	NdrFcShort( 0x2 ),	/* Offset= 2 (592) */
/* 592 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 594 */	NdrFcShort( 0x24 ),	/* Offset= 36 (630) */
/* 596 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 598 */	NdrFcShort( 0xc ),	/* 12 */
/* 600 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
/* 604 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 606 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 608 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 610 */	NdrFcShort( 0xc ),	/* 12 */
/* 612 */	NdrFcShort( 0x0 ),	/* 0 */
/* 614 */	NdrFcShort( 0x1 ),	/* 1 */
/* 616 */	NdrFcShort( 0x8 ),	/* 8 */
/* 618 */	NdrFcShort( 0x8 ),	/* 8 */
/* 620 */	0x12, 0x0,	/* FC_UP */
/* 622 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (544) */
/* 624 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 626 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc3 ),	/* Offset= -61 (566) */
			0x5b,		/* FC_END */
/* 630 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 634 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 636 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 638 */	NdrFcShort( 0x4 ),	/* 4 */
/* 640 */	NdrFcShort( 0x4 ),	/* 4 */
/* 642 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 644 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (596) */
/* 646 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 648 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 650 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 652 */	NdrFcShort( 0xe ),	/* Offset= 14 (666) */
/* 654 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 656 */	NdrFcShort( 0x1 ),	/* 1 */
/* 658 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 662 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 664 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 666 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 668 */	NdrFcShort( 0x2c ),	/* 44 */
/* 670 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 672 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 674 */	NdrFcShort( 0xc ),	/* 12 */
/* 676 */	NdrFcShort( 0xc ),	/* 12 */
/* 678 */	0x12, 0x0,	/* FC_UP */
/* 680 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (654) */
/* 682 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 684 */	NdrFcShort( 0x10 ),	/* 16 */
/* 686 */	NdrFcShort( 0x10 ),	/* 16 */
/* 688 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 690 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 692 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 694 */	NdrFcShort( 0x14 ),	/* 20 */
/* 696 */	NdrFcShort( 0x14 ),	/* 20 */
/* 698 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 700 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 702 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 704 */	NdrFcShort( 0x24 ),	/* 36 */
/* 706 */	NdrFcShort( 0x24 ),	/* 36 */
/* 708 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 710 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 712 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 714 */	NdrFcShort( 0x28 ),	/* 40 */
/* 716 */	NdrFcShort( 0x28 ),	/* 40 */
/* 718 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 720 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 722 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 724 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 726 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 728 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 730 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffdd7 ),	/* Offset= -553 (178) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 734 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd2b ),	/* Offset= -725 (10) */
			0x5b,		/* FC_END */
/* 738 */	
			0x11, 0x0,	/* FC_RP */
/* 740 */	NdrFcShort( 0x24 ),	/* Offset= 36 (776) */
/* 742 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 744 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 746 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 748 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 750 */	NdrFcShort( 0x2 ),	/* Offset= 2 (752) */
/* 752 */	NdrFcShort( 0x8 ),	/* 8 */
/* 754 */	NdrFcShort( 0x3 ),	/* 3 */
/* 756 */	NdrFcLong( 0x0 ),	/* 0 */
/* 760 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 762 */	NdrFcLong( 0x1 ),	/* 1 */
/* 766 */	NdrFcShort( 0xfffffdd0 ),	/* Offset= -560 (206) */
/* 768 */	NdrFcLong( 0x2 ),	/* 2 */
/* 772 */	NdrFcShort( 0xfffffcfe ),	/* Offset= -770 (2) */
/* 774 */	NdrFcShort( 0x0 ),	/* Offset= 0 (774) */
/* 776 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 778 */	NdrFcShort( 0xc ),	/* 12 */
/* 780 */	NdrFcShort( 0x0 ),	/* 0 */
/* 782 */	NdrFcShort( 0x0 ),	/* Offset= 0 (782) */
/* 784 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 786 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (742) */
			0x5b,		/* FC_END */
/* 790 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 792 */	NdrFcShort( 0x2 ),	/* Offset= 2 (794) */
/* 794 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 796 */	NdrFcShort( 0xffffff7e ),	/* Offset= -130 (666) */
/* 798 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 800 */	NdrFcShort( 0x2 ),	/* Offset= 2 (802) */
/* 802 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 804 */	NdrFcShort( 0x22 ),	/* Offset= 34 (838) */
/* 806 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 808 */	NdrFcShort( 0x4 ),	/* 4 */
/* 810 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 814 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 816 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 818 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 820 */	NdrFcShort( 0x4 ),	/* 4 */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x1 ),	/* 1 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 830 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 832 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (666) */
/* 834 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 836 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 838 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 840 */	NdrFcShort( 0x8 ),	/* 8 */
/* 842 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 844 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 846 */	NdrFcShort( 0x4 ),	/* 4 */
/* 848 */	NdrFcShort( 0x4 ),	/* 4 */
/* 850 */	0x12, 0x0,	/* FC_UP */
/* 852 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (806) */
/* 854 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 856 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 858 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 860 */	NdrFcShort( 0x2 ),	/* Offset= 2 (862) */
/* 862 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 864 */	NdrFcShort( 0x2 ),	/* Offset= 2 (866) */
/* 866 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 868 */	NdrFcShort( 0x8 ),	/* 8 */
/* 870 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 872 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 874 */	NdrFcShort( 0x4 ),	/* 4 */
/* 876 */	NdrFcShort( 0x4 ),	/* 4 */
/* 878 */	0x12, 0x0,	/* FC_UP */
/* 880 */	NdrFcShort( 0xfffffee4 ),	/* Offset= -284 (596) */
/* 882 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 884 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 886 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 888 */	NdrFcShort( 0x2 ),	/* Offset= 2 (890) */
/* 890 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 892 */	NdrFcShort( 0x1c ),	/* Offset= 28 (920) */
/* 894 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 896 */	NdrFcShort( 0x10 ),	/* 16 */
/* 898 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 900 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 902 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 904 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 906 */	NdrFcShort( 0x10 ),	/* 16 */
/* 908 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 910 */	NdrFcShort( 0x24 ),	/* 36 */
/* 912 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 914 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 916 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (894) */
/* 918 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 920 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 922 */	NdrFcShort( 0x2c ),	/* 44 */
/* 924 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 926 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 928 */	NdrFcShort( 0x28 ),	/* 40 */
/* 930 */	NdrFcShort( 0x28 ),	/* 40 */
/* 932 */	0x12, 0x0,	/* FC_UP */
/* 934 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (904) */
/* 936 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 938 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 940 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 942 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 944 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 946 */	NdrFcShort( 0xfffffd00 ),	/* Offset= -768 (178) */
/* 948 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 950 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 952 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 954 */	NdrFcShort( 0x2 ),	/* Offset= 2 (956) */
/* 956 */	
			0x12, 0x0,	/* FC_UP */
/* 958 */	NdrFcShort( 0x18 ),	/* Offset= 24 (982) */
/* 960 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 962 */	NdrFcShort( 0x0 ),	/* 0 */
/* 964 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 966 */	NdrFcShort( 0x0 ),	/* 0 */
/* 968 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 970 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 974 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 976 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 978 */	NdrFcShort( 0xfffffde0 ),	/* Offset= -544 (434) */
/* 980 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 982 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 984 */	NdrFcShort( 0x8 ),	/* 8 */
/* 986 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 988 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 990 */	NdrFcShort( 0x4 ),	/* 4 */
/* 992 */	NdrFcShort( 0x4 ),	/* 4 */
/* 994 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 996 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (960) */
/* 998 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1000 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1002 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 1004 */	NdrFcShort( 0xfffffe8a ),	/* Offset= -374 (630) */
/* 1006 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 1008 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1010) */
/* 1010 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1012 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1014 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1016 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1018 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1020 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1022 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1024 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1026 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1028 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1030 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1032 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1034 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1036 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1038 */	NdrFcShort( 0xc ),	/* 12 */
/* 1040 */	NdrFcShort( 0xc ),	/* 12 */
/* 1042 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1044 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1046 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1048 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1050 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1052 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1054 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1056 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1058 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1060 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1062) */
/* 1062 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 1064 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (1010) */
/* 1066 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1068 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1070) */
/* 1070 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 1072 */	NdrFcShort( 0x24 ),	/* Offset= 36 (1108) */
/* 1074 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1076 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1078 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1080 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1080) */
/* 1082 */	0x8,		/* FC_LONG */
			0xd,		/* FC_ENUM16 */
/* 1084 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1086 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1088 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1090 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1092 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1094 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1096 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1100 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1102 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1104 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1074) */
/* 1106 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1108 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1110 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1112 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1114 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1116 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1118 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1120 */	0x12, 0x0,	/* FC_UP */
/* 1122 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1086) */
/* 1124 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1126 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1128 */	
			0x11, 0x0,	/* FC_RP */
/* 1130 */	NdrFcShort( 0x46 ),	/* Offset= 70 (1200) */
/* 1132 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 1134 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 1136 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1138 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1140 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1142) */
/* 1142 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1144 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1150 */	NdrFcShort( 0xfffffc30 ),	/* Offset= -976 (174) */
/* 1152 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1156 */	NdrFcShort( 0xfffffc36 ),	/* Offset= -970 (186) */
/* 1158 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1162 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1178) */
/* 1164 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1168 */	NdrFcShort( 0xfffffc1e ),	/* Offset= -994 (174) */
/* 1170 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1174 */	NdrFcShort( 0xfffffc18 ),	/* Offset= -1000 (174) */
/* 1176 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1176) */
/* 1178 */	
			0x12, 0x0,	/* FC_UP */
/* 1180 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1182) */
/* 1182 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1184 */	NdrFcShort( 0xc ),	/* 12 */
/* 1186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1196) */
/* 1190 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1192 */	0x2,		/* FC_CHAR */
			0x3f,		/* FC_STRUCTPAD3 */
/* 1194 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1196 */	
			0x12, 0x0,	/* FC_UP */
/* 1198 */	NdrFcShort( 0xfffffc20 ),	/* Offset= -992 (206) */
/* 1200 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 1202 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1206 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1206) */
/* 1208 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1210 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb1 ),	/* Offset= -79 (1132) */
			0x5b,		/* FC_END */
/* 1214 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1216 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1218) */
/* 1218 */	
			0x12, 0x0,	/* FC_UP */
/* 1220 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1244) */
/* 1222 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1226 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1232 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1236 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1240 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (1200) */
/* 1242 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1244 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1246 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1248 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1250 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1252 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1254 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1256 */	0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1222) */
/* 1260 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1262 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1264 */	
			0x11, 0x0,	/* FC_RP */
/* 1266 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1268) */
/* 1268 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1270 */	NdrFcShort( 0x30 ),	/* 48 */
/* 1272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1274 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1296) */
/* 1276 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1278 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1280 */	NdrFcShort( 0xfffffbce ),	/* Offset= -1074 (206) */
/* 1282 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1284 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1286 */	NdrFcShort( 0xfffffbac ),	/* Offset= -1108 (178) */
/* 1288 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1290 */	NdrFcShort( 0xfffffb00 ),	/* Offset= -1280 (10) */
/* 1292 */	0x2,		/* FC_CHAR */
			0x3f,		/* FC_STRUCTPAD3 */
/* 1294 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1296 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1298 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1300 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1302 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1304 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1306 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1308) */
/* 1308 */	
			0x12, 0x0,	/* FC_UP */
/* 1310 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1268) */
/* 1312 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1314 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1316) */
/* 1316 */	
			0x12, 0x0,	/* FC_UP */
/* 1318 */	NdrFcShort( 0x22 ),	/* Offset= 34 (1352) */
/* 1320 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1322 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1324 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1328 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1330 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1332 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1334 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1338 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1344 */	0x12, 0x0,	/* FC_UP */
/* 1346 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (1268) */
/* 1348 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1350 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1352 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1354 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1356 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1358 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1360 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1362 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1364 */	0x12, 0x0,	/* FC_UP */
/* 1366 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1320) */
/* 1368 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1370 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1372 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1374 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1376) */
/* 1376 */	
			0x12, 0x0,	/* FC_UP */
/* 1378 */	NdrFcShort( 0x3a ),	/* Offset= 58 (1436) */
/* 1380 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1382 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1384 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1386 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1388 */	NdrFcShort( 0xc ),	/* 12 */
/* 1390 */	NdrFcShort( 0xc ),	/* 12 */
/* 1392 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1394 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1396 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1398 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1400 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1402 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1404 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1406 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1410 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1412 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1414 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1416 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1420 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1422 */	NdrFcShort( 0xc ),	/* 12 */
/* 1424 */	NdrFcShort( 0xc ),	/* 12 */
/* 1426 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1428 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1430 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1432 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffcb ),	/* Offset= -53 (1380) */
			0x5b,		/* FC_END */
/* 1436 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1438 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1440 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1442 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1444 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1446 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1448 */	0x12, 0x0,	/* FC_UP */
/* 1450 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1402) */
/* 1452 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1454 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1456 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1458 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1460 */	
			0x11, 0x0,	/* FC_RP */
/* 1462 */	NdrFcShort( 0xe ),	/* Offset= 14 (1476) */
/* 1464 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1466 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1468 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1470 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1472 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1474 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1476 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1478 */	NdrFcShort( 0x34 ),	/* 52 */
/* 1480 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1482 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1484 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1486 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1488 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1490 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1492 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1494 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1496 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1498 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1500 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1502 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1504 */	NdrFcShort( 0xc ),	/* 12 */
/* 1506 */	NdrFcShort( 0xc ),	/* 12 */
/* 1508 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1510 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1512 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1514 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1516 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1518 */	0x12, 0x0,	/* FC_UP */
/* 1520 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (1464) */
/* 1522 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1524 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1526 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1528 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1530 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1532 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1534 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1536 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1538 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1540 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1542) */
/* 1542 */	
			0x12, 0x0,	/* FC_UP */
/* 1544 */	NdrFcShort( 0xffffffbc ),	/* Offset= -68 (1476) */

			0x0
        }
    };

static const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ] = 
        {
        {
            (GENERIC_BINDING_ROUTINE)DHCP_SRV_HANDLE_bind,
            (GENERIC_UNBIND_ROUTINE)DHCP_SRV_HANDLE_unbind
         }
        
        };


static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR * )(pStubMsg->StackTop - 4);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR * )(pStubMsg->StackTop - 4);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000
    ,dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001
    };


static const unsigned short dhcpsrv_FormatStringOffsetTable[] =
    {
    0,
    54,
    108,
    162,
    234,
    288,
    372,
    432,
    486,
    540,
    594,
    648,
    696,
    756,
    816,
    894,
    948,
    996,
    1044,
    1098,
    1146,
    1224,
    1284,
    1332,
    1404,
    1458,
    1512,
    1560,
    1620,
    1674,
    1728,
    1812,
    1872,
    1920,
    1968,
    2022,
    2100,
    2160,
    2208,
    2256,
    2310
    };


static const MIDL_STUB_DESC dhcpsrv_StubDesc = 
    {
    (void __RPC_FAR *)& dhcpsrv___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &dhcpsrv_bhandle,
    0,
    BindingRoutines,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000143, /* MIDL Version 6.0.323 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for dhcp_cli.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, oldnames, robust dhcp_bug_compatibility
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>
#if defined( _ALPHA_ )
#include <stdarg.h>
#endif

#include "dhcp_cli.h"

#define TYPE_FORMAT_STRING_SIZE   1331                              
#define PROC_FORMAT_STRING_SIZE   2441                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   1            


/* Standard interface: dhcpsrv, ver. 1.0,
   GUID={0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}} */

handle_t dhcpsrv_bhandle;


static const RPC_CLIENT_INTERFACE dhcpsrv___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE dhcpsrv_ClientIfHandle = (RPC_IF_HANDLE)& dhcpsrv___RpcClientInterface;

extern const MIDL_STUB_DESC dhcpsrv_StubDesc;

static RPC_BINDING_HANDLE dhcpsrv__MIDL_AutoBindHandle;


DWORD R_DhcpCreateSubnet( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_INFO SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ServerIpAddress,
                  SubnetAddress,
                  SubnetInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetSubnetInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_INFO SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[56],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[56],
                  ServerIpAddress,
                  SubnetAddress,
                  SubnetInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetSubnetInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out] */ LPDHCP_SUBNET_INFO __RPC_FAR *SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[112],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[112],
                  ServerIpAddress,
                  SubnetAddress,
                  SubnetInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnets( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_IP_ARRAY __RPC_FAR *EnumInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[168],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[168],
                  ServerIpAddress,
                  ResumeHandle,
                  PreferredMaximum,
                  EnumInfo,
                  ElementsRead,
                  ElementsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpAddSubnetElement( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA AddElementInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,AddElementInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[242],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[242],
                  ServerIpAddress,
                  SubnetAddress,
                  AddElementInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetElements( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_SUBNET_ELEMENT_INFO_ARRAY __RPC_FAR *EnumElementInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[298],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[298],
                  ServerIpAddress,
                  SubnetAddress,
                  EnumElementType,
                  ResumeHandle,
                  PreferredMaximum,
                  EnumElementInfo,
                  ElementsRead,
                  ElementsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveSubnetElement( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[384],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[384],
                  ServerIpAddress,
                  SubnetAddress,
                  RemoveElementInfo,
                  ForceFlag);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteSubnet( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[446],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[446],
                  ServerIpAddress,
                  SubnetAddress,
                  ForceFlag);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateOption( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[502],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[502],
                  ServerIpAddress,
                  OptionID,
                  OptionInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[558],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[558],
                  ServerIpAddress,
                  OptionID,
                  OptionInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetOptionInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [out] */ LPDHCP_OPTION __RPC_FAR *OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[614],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[614],
                  ServerIpAddress,
                  OptionID,
                  OptionInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveOption( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionID);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[670],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[670],
                  ServerIpAddress,
                  OptionID);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [ref][in] */ LPDHCP_OPTION_DATA OptionValue)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValue);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[720],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[720],
                  ServerIpAddress,
                  OptionID,
                  ScopeInfo,
                  OptionValue);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [out] */ LPDHCP_OPTION_VALUE __RPC_FAR *OptionValue)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValue);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[782],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[782],
                  ServerIpAddress,
                  OptionID,
                  ScopeInfo,
                  OptionValue);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumOptionValues( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_OPTION_VALUE_ARRAY __RPC_FAR *OptionValues,
    /* [out] */ DWORD __RPC_FAR *OptionsRead,
    /* [out] */ DWORD __RPC_FAR *OptionsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[844],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[844],
                  ServerIpAddress,
                  ScopeInfo,
                  ResumeHandle,
                  PreferredMaximum,
                  OptionValues,
                  OptionsRead,
                  OptionsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ScopeInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[924],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[924],
                  ServerIpAddress,
                  OptionID,
                  ScopeInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[980],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[980],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1030],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1030],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO SearchInfo,
    /* [out] */ LPDHCP_CLIENT_INFO __RPC_FAR *ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1080],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1080],
                  ServerIpAddress,
                  SearchInfo,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1136],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1136],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetClients( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_CLIENT_INFO_ARRAY __RPC_FAR *ClientInfo,
    /* [out] */ DWORD __RPC_FAR *ClientsRead,
    /* [out] */ DWORD __RPC_FAR *ClientsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1186],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1186],
                  ServerIpAddress,
                  SubnetAddress,
                  ResumeHandle,
                  PreferredMaximum,
                  ClientInfo,
                  ClientsRead,
                  ClientsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientOptions( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS ClientIpAddress,
    /* [in] */ DHCP_IP_MASK ClientSubnetMask,
    /* [out] */ LPDHCP_OPTION_LIST __RPC_FAR *ClientOptions)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientOptions);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1266],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1266],
                  ServerIpAddress,
                  ClientIpAddress,
                  ClientSubnetMask,
                  ClientOptions);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetMibInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_MIB_INFO __RPC_FAR *MibInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,MibInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1328],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1328],
                  ServerIpAddress,
                  MibInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumOptions( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_OPTION_ARRAY __RPC_FAR *Options,
    /* [out] */ DWORD __RPC_FAR *OptionsRead,
    /* [out] */ DWORD __RPC_FAR *OptionsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1378],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1378],
                  ServerIpAddress,
                  ResumeHandle,
                  PreferredMaximum,
                  Options,
                  OptionsRead,
                  OptionsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionValues( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [ref][in] */ LPDHCP_OPTION_VALUE_ARRAY OptionValues)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValues);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1452],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1452],
                  ServerIpAddress,
                  ScopeInfo,
                  OptionValues);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerSetConfig( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DWORD FieldsToSet,
    /* [ref][in] */ LPDHCP_SERVER_CONFIG_INFO ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1508],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1508],
                  ServerIpAddress,
                  FieldsToSet,
                  ConfigInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerGetConfig( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SERVER_CONFIG_INFO __RPC_FAR *ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1564],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1564],
                  ServerIpAddress,
                  ConfigInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpScanDatabase( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DWORD FixFlag,
    /* [out] */ LPDHCP_SCAN_LIST __RPC_FAR *ScanList)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ScanList);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1614],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1614],
                  ServerIpAddress,
                  SubnetAddress,
                  FixFlag,
                  ScanList);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetVersion( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDWORD MajorVersion,
    /* [out] */ LPDWORD MinorVersion)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,MinorVersion);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1676],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1676],
                  ServerIpAddress,
                  MajorVersion,
                  MinorVersion);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpAddSubnetElementV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,AddElementInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1732],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1732],
                  ServerIpAddress,
                  SubnetAddress,
                  AddElementInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetElementsV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 __RPC_FAR *EnumElementInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1788],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1788],
                  ServerIpAddress,
                  SubnetAddress,
                  EnumElementType,
                  ResumeHandle,
                  PreferredMaximum,
                  EnumElementInfo,
                  ElementsRead,
                  ElementsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveSubnetElementV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1874],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1874],
                  ServerIpAddress,
                  SubnetAddress,
                  RemoveElementInfo,
                  ForceFlag);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO_V4 ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1936],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1936],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO_V4 ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1986],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1986],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO SearchInfo,
    /* [out] */ LPDHCP_CLIENT_INFO_V4 __RPC_FAR *ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2036],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2036],
                  ServerIpAddress,
                  SearchInfo,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetClientsV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_CLIENT_INFO_ARRAY_V4 __RPC_FAR *ClientInfo,
    /* [out] */ DWORD __RPC_FAR *ClientsRead,
    /* [out] */ DWORD __RPC_FAR *ClientsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2092],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2092],
                  ServerIpAddress,
                  SubnetAddress,
                  ResumeHandle,
                  PreferredMaximum,
                  ClientInfo,
                  ClientsRead,
                  ClientsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetSuperScopeV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [string][unique][in] */ WCHAR __RPC_FAR *SuperScopeName,
    /* [in] */ BOOL ChangeExisting)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ChangeExisting);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2172],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2172],
                  ServerIpAddress,
                  SubnetAddress,
                  SuperScopeName,
                  ChangeExisting);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetSuperScopeInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SUPER_SCOPE_TABLE __RPC_FAR *SuperScopeTable)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SuperScopeTable);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2234],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2234],
                  ServerIpAddress,
                  SuperScopeTable);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteSuperScopeV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [string][ref][in] */ WCHAR __RPC_FAR *SuperScopeName)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SuperScopeName);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2284],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2284],
                  ServerIpAddress,
                  SuperScopeName);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerSetConfigV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DWORD FieldsToSet,
    /* [ref][in] */ LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2334],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2334],
                  ServerIpAddress,
                  FieldsToSet,
                  ConfigInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerGetConfigV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SERVER_CONFIG_INFO_V4 __RPC_FAR *ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2390],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2390],
                  ServerIpAddress,
                  ConfigInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}

extern const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ];
extern const EXPR_EVAL ExprEvalRoutines[];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure R_DhcpCreateSubnet */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 22 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 32 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 34 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 36 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 38 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 40 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 42 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 44 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 46 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 48 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSubnetInfo */

/* 56 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x1 ),	/* 1 */
/* 64 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 66 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 68 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 70 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 72 */	NdrFcShort( 0x8 ),	/* 8 */
/* 74 */	NdrFcShort( 0x8 ),	/* 8 */
/* 76 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 78 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 88 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 90 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 92 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 96 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 98 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 100 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 102 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 104 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSubnetInfo */

/* 112 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x2 ),	/* 2 */
/* 120 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 122 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 124 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 126 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 132 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 134 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 144 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 146 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 148 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 152 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 156 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 158 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 160 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 164 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnets */

/* 168 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x3 ),	/* 3 */
/* 176 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 178 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 180 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 182 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 184 */	NdrFcShort( 0x24 ),	/* 36 */
/* 186 */	NdrFcShort( 0x5c ),	/* 92 */
/* 188 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 190 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 192 */	NdrFcShort( 0x1 ),	/* 1 */
/* 194 */	NdrFcShort( 0x0 ),	/* 0 */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 200 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 202 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 204 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 206 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 208 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 212 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 214 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumInfo */

/* 218 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 220 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 222 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */

	/* Parameter ElementsRead */

/* 224 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 226 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 230 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 232 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 236 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 238 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElement */

/* 242 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 244 */	NdrFcLong( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x4 ),	/* 4 */
/* 250 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 252 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 254 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 256 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 258 */	NdrFcShort( 0x8 ),	/* 8 */
/* 260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 262 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 264 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 268 */	NdrFcShort( 0x2 ),	/* 2 */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 274 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 276 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 278 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 280 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 282 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 284 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 286 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 288 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 290 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Return value */

/* 292 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 294 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElements */

/* 298 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 300 */	NdrFcLong( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x5 ),	/* 5 */
/* 306 */	NdrFcShort( 0x48 ),	/* ia64, axp64 Stack size/offset = 72 */
/* 308 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 310 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 312 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 314 */	NdrFcShort( 0x32 ),	/* 50 */
/* 316 */	NdrFcShort( 0x5c ),	/* 92 */
/* 318 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 320 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 322 */	NdrFcShort( 0x3 ),	/* 3 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 330 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 332 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 334 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 336 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 338 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 344 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 346 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 348 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 350 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 354 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 356 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 360 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 362 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 364 */	NdrFcShort( 0xf2 ),	/* Type Offset=242 */

	/* Parameter ElementsRead */

/* 366 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 368 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 372 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 374 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 380 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 382 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElement */

/* 384 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 386 */	NdrFcLong( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x6 ),	/* 6 */
/* 392 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 394 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 396 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 398 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 400 */	NdrFcShort( 0xe ),	/* 14 */
/* 402 */	NdrFcShort( 0x8 ),	/* 8 */
/* 404 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 406 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 410 */	NdrFcShort( 0x2 ),	/* 2 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 416 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 418 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 420 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 424 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 428 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 430 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 432 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Parameter ForceFlag */

/* 434 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 436 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 438 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 440 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 442 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSubnet */

/* 446 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 452 */	NdrFcShort( 0x7 ),	/* 7 */
/* 454 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 456 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 458 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 460 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 462 */	NdrFcShort( 0xe ),	/* 14 */
/* 464 */	NdrFcShort( 0x8 ),	/* 8 */
/* 466 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 468 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 478 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 480 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 482 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 484 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 486 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 488 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ForceFlag */

/* 490 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 492 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 494 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 496 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 498 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 500 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateOption */

/* 502 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 504 */	NdrFcLong( 0x0 ),	/* 0 */
/* 508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 510 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 512 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 514 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 516 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 518 */	NdrFcShort( 0x8 ),	/* 8 */
/* 520 */	NdrFcShort( 0x8 ),	/* 8 */
/* 522 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 524 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 528 */	NdrFcShort( 0x4 ),	/* 4 */
/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 532 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 534 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 536 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 538 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 540 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 542 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 544 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 546 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 548 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 550 */	NdrFcShort( 0x120 ),	/* Type Offset=288 */

	/* Return value */

/* 552 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 554 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionInfo */

/* 558 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 560 */	NdrFcLong( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x9 ),	/* 9 */
/* 566 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 568 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 570 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 572 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 578 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 580 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	NdrFcShort( 0x4 ),	/* 4 */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 588 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 590 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 592 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 594 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 596 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 598 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 602 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 604 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 606 */	NdrFcShort( 0x120 ),	/* Type Offset=288 */

	/* Return value */

/* 608 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 610 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionInfo */

/* 614 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 616 */	NdrFcLong( 0x0 ),	/* 0 */
/* 620 */	NdrFcShort( 0xa ),	/* 10 */
/* 622 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 624 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 626 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 628 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 634 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 636 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 638 */	NdrFcShort( 0x4 ),	/* 4 */
/* 640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 642 */	NdrFcShort( 0x0 ),	/* 0 */
/* 644 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 646 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 648 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 650 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 654 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 658 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 660 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 662 */	NdrFcShort( 0x1b6 ),	/* Type Offset=438 */

	/* Return value */

/* 664 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 666 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 668 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOption */

/* 670 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 672 */	NdrFcLong( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0xb ),	/* 11 */
/* 678 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 680 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 682 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 684 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 688 */	NdrFcShort( 0x8 ),	/* 8 */
/* 690 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 692 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 702 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 704 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 706 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 708 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 710 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 714 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 716 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValue */

/* 720 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 722 */	NdrFcLong( 0x0 ),	/* 0 */
/* 726 */	NdrFcShort( 0xc ),	/* 12 */
/* 728 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 730 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 732 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 734 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 736 */	NdrFcShort( 0x8 ),	/* 8 */
/* 738 */	NdrFcShort( 0x8 ),	/* 8 */
/* 740 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 742 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x5 ),	/* 5 */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 752 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 754 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 756 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 758 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 760 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 762 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 764 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 766 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 768 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValue */

/* 770 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 772 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 774 */	NdrFcShort( 0x18a ),	/* Type Offset=394 */

	/* Return value */

/* 776 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 778 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionValue */

/* 782 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 784 */	NdrFcLong( 0x0 ),	/* 0 */
/* 788 */	NdrFcShort( 0xd ),	/* 13 */
/* 790 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 792 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 794 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 796 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	NdrFcShort( 0x8 ),	/* 8 */
/* 802 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 804 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 806 */	NdrFcShort( 0x4 ),	/* 4 */
/* 808 */	NdrFcShort( 0x1 ),	/* 1 */
/* 810 */	NdrFcShort( 0x0 ),	/* 0 */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 814 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 816 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 818 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 820 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 822 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 824 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 826 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 828 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 830 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValue */

/* 832 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 834 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 836 */	NdrFcShort( 0x204 ),	/* Type Offset=516 */

	/* Return value */

/* 838 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 840 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptionValues */

/* 844 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 846 */	NdrFcLong( 0x0 ),	/* 0 */
/* 850 */	NdrFcShort( 0xe ),	/* 14 */
/* 852 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 854 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 856 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 858 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 860 */	NdrFcShort( 0x24 ),	/* 36 */
/* 862 */	NdrFcShort( 0x5c ),	/* 92 */
/* 864 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 866 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 868 */	NdrFcShort( 0x5 ),	/* 5 */
/* 870 */	NdrFcShort( 0x1 ),	/* 1 */
/* 872 */	NdrFcShort( 0x0 ),	/* 0 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 876 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 878 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 880 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 882 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 884 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 886 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter ResumeHandle */

/* 888 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 890 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 894 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 896 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 898 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionValues */

/* 900 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 902 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 904 */	NdrFcShort( 0x21c ),	/* Type Offset=540 */

	/* Parameter OptionsRead */

/* 906 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 908 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 910 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 914 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 920 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOptionValue */

/* 924 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 926 */	NdrFcLong( 0x0 ),	/* 0 */
/* 930 */	NdrFcShort( 0xf ),	/* 15 */
/* 932 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 934 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 936 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 938 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 940 */	NdrFcShort( 0x8 ),	/* 8 */
/* 942 */	NdrFcShort( 0x8 ),	/* 8 */
/* 944 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 946 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 948 */	NdrFcShort( 0x0 ),	/* 0 */
/* 950 */	NdrFcShort( 0x1 ),	/* 1 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 956 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 958 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 960 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 962 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 964 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 966 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 968 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 970 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 972 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Return value */

/* 974 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 976 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 978 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfo */

/* 980 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 982 */	NdrFcLong( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0x10 ),	/* 16 */
/* 988 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 990 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 992 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 994 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 998 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1000 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1002 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1008 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1010 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1012 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1014 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1016 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1018 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1020 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1022 */	NdrFcShort( 0x24a ),	/* Type Offset=586 */

	/* Return value */

/* 1024 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1026 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1028 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfo */

/* 1030 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1032 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1036 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1038 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1040 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1042 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1044 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1046 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1048 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1050 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1052 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1054 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1056 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1058 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1062 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1064 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1066 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1068 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1070 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1072 */	NdrFcShort( 0x24a ),	/* Type Offset=586 */

	/* Return value */

/* 1074 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1076 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfo */

/* 1080 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1082 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1086 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1088 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1090 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1092 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1094 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1096 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1098 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1100 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1102 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1104 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1106 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1112 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1114 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1116 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 1118 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1120 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1122 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Parameter ClientInfo */

/* 1124 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1126 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1128 */	NdrFcShort( 0x2a6 ),	/* Type Offset=678 */

	/* Return value */

/* 1130 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1132 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteClientInfo */

/* 1136 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1138 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1142 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1144 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1146 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1148 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1150 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1156 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1158 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1168 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1170 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1172 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1174 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1176 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1178 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Return value */

/* 1180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1182 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClients */

/* 1186 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1188 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1192 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1194 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 1196 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1198 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1200 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1202 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1204 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1206 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1208 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1210 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1216 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1218 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1220 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1222 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1224 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1226 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1230 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1232 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1236 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1238 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 1242 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1244 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1246 */	NdrFcShort( 0x2ae ),	/* Type Offset=686 */

	/* Parameter ClientsRead */

/* 1248 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1250 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1252 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 1254 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1256 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1260 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1262 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientOptions */

/* 1266 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1272 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1274 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1276 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1278 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1280 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1282 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1286 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1288 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1290 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1296 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1298 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1300 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1302 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientIpAddress */

/* 1304 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1306 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientSubnetMask */

/* 1310 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1312 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1314 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientOptions */

/* 1316 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1318 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1320 */	NdrFcShort( 0x2dc ),	/* Type Offset=732 */

	/* Return value */

/* 1322 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1324 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetMibInfo */

/* 1328 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1334 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1336 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1338 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1340 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1342 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1348 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1350 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1352 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1360 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1362 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1364 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MibInfo */

/* 1366 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1368 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1370 */	NdrFcShort( 0x2f4 ),	/* Type Offset=756 */

	/* Return value */

/* 1372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1374 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptions */

/* 1378 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1380 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1384 */	NdrFcShort( 0x17 ),	/* 23 */
/* 1386 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1388 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1390 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1392 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1394 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1396 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1398 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1400 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1402 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1408 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1410 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1412 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1414 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 1416 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1418 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1420 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1424 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Options */

/* 1428 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1430 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1432 */	NdrFcShort( 0x330 ),	/* Type Offset=816 */

	/* Parameter OptionsRead */

/* 1434 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1436 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 1440 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1442 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1446 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1448 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1450 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValues */

/* 1452 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1454 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1458 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1460 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1462 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1464 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1466 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1472 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1474 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1478 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1480 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1484 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1486 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1488 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 1490 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1492 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1494 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValues */

/* 1496 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1498 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1500 */	NdrFcShort( 0x35e ),	/* Type Offset=862 */

	/* Return value */

/* 1502 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1504 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1506 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfig */

/* 1508 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1510 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1514 */	NdrFcShort( 0x19 ),	/* 25 */
/* 1516 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1518 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1520 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1522 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1526 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1528 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1530 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1532 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1540 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1542 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1544 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 1546 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1548 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1550 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 1552 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1554 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1556 */	NdrFcShort( 0x362 ),	/* Type Offset=866 */

	/* Return value */

/* 1558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1560 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfig */

/* 1564 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1566 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1570 */	NdrFcShort( 0x1a ),	/* 26 */
/* 1572 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1574 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1576 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1578 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1584 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1586 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1588 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1592 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1594 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1596 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1598 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1600 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 1602 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1604 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1606 */	NdrFcShort( 0x386 ),	/* Type Offset=902 */

	/* Return value */

/* 1608 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1610 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpScanDatabase */

/* 1614 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1616 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1620 */	NdrFcShort( 0x1b ),	/* 27 */
/* 1622 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1624 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1626 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1628 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1630 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1634 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1636 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1638 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1642 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1646 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1648 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1650 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1654 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter FixFlag */

/* 1658 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1660 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1662 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScanList */

/* 1664 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1666 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1668 */	NdrFcShort( 0x38e ),	/* Type Offset=910 */

	/* Return value */

/* 1670 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1672 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1674 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetVersion */

/* 1676 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1678 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1682 */	NdrFcShort( 0x1c ),	/* 28 */
/* 1684 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1686 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1688 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1690 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1692 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1694 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1696 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1698 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1702 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1706 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1708 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1710 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1712 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MajorVersion */

/* 1714 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1716 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter MinorVersion */

/* 1720 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1722 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1728 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElementV4 */

/* 1732 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1738 */	NdrFcShort( 0x1d ),	/* 29 */
/* 1740 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1742 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1744 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1746 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1748 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1750 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1752 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1754 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1758 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1760 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1762 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1764 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1766 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1768 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1770 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1772 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 1776 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1778 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1780 */	NdrFcShort( 0x410 ),	/* Type Offset=1040 */

	/* Return value */

/* 1782 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1784 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElementsV4 */

/* 1788 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1790 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1794 */	NdrFcShort( 0x1e ),	/* 30 */
/* 1796 */	NdrFcShort( 0x48 ),	/* ia64, axp64 Stack size/offset = 72 */
/* 1798 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1800 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1802 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1804 */	NdrFcShort( 0x32 ),	/* 50 */
/* 1806 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1808 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 1810 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1812 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1820 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1822 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1824 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1826 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1828 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1830 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 1832 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1834 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1836 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1838 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1840 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1844 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1846 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1848 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 1850 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1852 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1854 */	NdrFcShort( 0x420 ),	/* Type Offset=1056 */

	/* Parameter ElementsRead */

/* 1856 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1858 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1860 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 1862 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1864 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1866 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1868 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1870 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 1872 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElementV4 */

/* 1874 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1876 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1880 */	NdrFcShort( 0x1f ),	/* 31 */
/* 1882 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1884 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1886 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1888 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1890 */	NdrFcShort( 0xe ),	/* 14 */
/* 1892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1894 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1896 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1898 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1900 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1904 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1906 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1908 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1910 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1912 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1914 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 1918 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1920 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1922 */	NdrFcShort( 0x410 ),	/* Type Offset=1040 */

	/* Parameter ForceFlag */

/* 1924 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1926 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1928 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1930 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1932 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfoV4 */

/* 1936 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1938 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1942 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1944 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1946 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1948 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1950 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1954 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1956 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1958 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1960 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1962 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1966 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1968 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1970 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1972 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1974 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1976 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1978 */	NdrFcShort( 0x452 ),	/* Type Offset=1106 */

	/* Return value */

/* 1980 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1982 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfoV4 */

/* 1986 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1988 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1992 */	NdrFcShort( 0x21 ),	/* 33 */
/* 1994 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1996 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1998 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2000 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2004 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2006 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2008 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2012 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2016 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2018 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2020 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2022 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 2024 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2026 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2028 */	NdrFcShort( 0x452 ),	/* Type Offset=1106 */

	/* Return value */

/* 2030 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2032 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2034 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfoV4 */

/* 2036 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2038 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2042 */	NdrFcShort( 0x22 ),	/* 34 */
/* 2044 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2046 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2048 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2050 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2052 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2054 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2056 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2058 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2060 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2062 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2064 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2066 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2068 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2070 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2072 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 2074 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2076 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2078 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Parameter ClientInfo */

/* 2080 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2082 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2084 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 2086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2088 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClientsV4 */

/* 2092 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2098 */	NdrFcShort( 0x23 ),	/* 35 */
/* 2100 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 2102 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2104 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2106 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2108 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2110 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2112 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 2114 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2116 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2122 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2124 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2126 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2128 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2130 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2132 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 2136 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2138 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 2142 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2144 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2146 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 2148 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2150 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2152 */	NdrFcShort( 0x47e ),	/* Type Offset=1150 */

	/* Parameter ClientsRead */

/* 2154 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2156 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 2160 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2162 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2164 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2166 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2168 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 2170 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSuperScopeV4 */

/* 2172 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2174 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2180 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2182 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2184 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2186 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2188 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2192 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2194 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2204 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2206 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2208 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2210 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2212 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SuperScopeName */

/* 2216 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2218 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2220 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ChangeExisting */

/* 2222 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2224 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2230 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSuperScopeInfoV4 */

/* 2234 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2240 */	NdrFcShort( 0x25 ),	/* 37 */
/* 2242 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2244 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2246 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2248 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2254 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2256 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2258 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2264 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2266 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2268 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2270 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeTable */

/* 2272 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2274 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2276 */	NdrFcShort( 0x4ac ),	/* Type Offset=1196 */

	/* Return value */

/* 2278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2280 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSuperScopeV4 */

/* 2284 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2290 */	NdrFcShort( 0x26 ),	/* 38 */
/* 2292 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2294 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2296 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2298 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2304 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2306 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2314 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2316 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2318 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2320 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeName */

/* 2322 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2324 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2326 */	NdrFcShort( 0x4ee ),	/* Type Offset=1262 */

	/* Return value */

/* 2328 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2330 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfigV4 */

/* 2334 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2336 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2340 */	NdrFcShort( 0x27 ),	/* 39 */
/* 2342 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2344 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2346 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2348 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2350 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2354 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2356 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2360 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2364 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2366 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2368 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2370 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 2372 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2374 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 2378 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2380 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2382 */	NdrFcShort( 0x500 ),	/* Type Offset=1280 */

	/* Return value */

/* 2384 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2386 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2388 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfigV4 */

/* 2390 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2392 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2396 */	NdrFcShort( 0x28 ),	/* 40 */
/* 2398 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2400 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2402 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2404 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2410 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2412 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2414 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2420 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2422 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2424 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2426 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 2428 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2430 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2432 */	NdrFcShort( 0x52a ),	/* Type Offset=1322 */

	/* Return value */

/* 2434 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2436 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/*  8 */	NdrFcShort( 0x18 ),	/* Offset= 24 (32) */
/* 10 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 12 */	NdrFcShort( 0x18 ),	/* 24 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* Offset= 8 (24) */
/* 18 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 20 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 22 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 24 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 26 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 30 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 32 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x38 ),	/* 56 */
/* 36 */	NdrFcShort( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0xe ),	/* Offset= 14 (52) */
/* 40 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 42 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 44 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 46 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (10) */
/* 48 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 50 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 52 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 54 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 56 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 58 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 60 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 62 */	NdrFcShort( 0x2 ),	/* Offset= 2 (64) */
/* 64 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 66 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (32) */
/* 68 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 70 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 72 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x12, 0x0,	/* FC_UP */
/* 78 */	NdrFcShort( 0xe ),	/* Offset= 14 (92) */
/* 80 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 82 */	NdrFcShort( 0x4 ),	/* 4 */
/* 84 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
/* 88 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 90 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 92 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 94 */	NdrFcShort( 0x10 ),	/* 16 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x6 ),	/* Offset= 6 (104) */
/* 100 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 102 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 104 */	
			0x12, 0x0,	/* FC_UP */
/* 106 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (80) */
/* 108 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 110 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 112 */	
			0x11, 0x0,	/* FC_RP */
/* 114 */	NdrFcShort( 0x70 ),	/* Offset= 112 (226) */
/* 116 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 118 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 124 */	NdrFcShort( 0x2 ),	/* Offset= 2 (126) */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	NdrFcShort( 0x5 ),	/* 5 */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x1c ),	/* Offset= 28 (162) */
/* 136 */	NdrFcLong( 0x1 ),	/* 1 */
/* 140 */	NdrFcShort( 0x22 ),	/* Offset= 34 (174) */
/* 142 */	NdrFcLong( 0x2 ),	/* 2 */
/* 146 */	NdrFcShort( 0x20 ),	/* Offset= 32 (178) */
/* 148 */	NdrFcLong( 0x3 ),	/* 3 */
/* 152 */	NdrFcShort( 0xa ),	/* Offset= 10 (162) */
/* 154 */	NdrFcLong( 0x4 ),	/* 4 */
/* 158 */	NdrFcShort( 0x4 ),	/* Offset= 4 (162) */
/* 160 */	NdrFcShort( 0x0 ),	/* Offset= 0 (160) */
/* 162 */	
			0x12, 0x0,	/* FC_UP */
/* 164 */	NdrFcShort( 0x2 ),	/* Offset= 2 (166) */
/* 166 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 168 */	NdrFcShort( 0x8 ),	/* 8 */
/* 170 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 172 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (10) */
/* 178 */	
			0x12, 0x0,	/* FC_UP */
/* 180 */	NdrFcShort( 0x1e ),	/* Offset= 30 (210) */
/* 182 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 186 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 192 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 194 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 196 */	NdrFcShort( 0x10 ),	/* 16 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x6 ),	/* Offset= 6 (206) */
/* 202 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 204 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 206 */	
			0x12, 0x0,	/* FC_UP */
/* 208 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (182) */
/* 210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 212 */	NdrFcShort( 0x10 ),	/* 16 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 216 */	NdrFcShort( 0x6 ),	/* Offset= 6 (222) */
/* 218 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 220 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 222 */	
			0x12, 0x0,	/* FC_UP */
/* 224 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (194) */
/* 226 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 228 */	NdrFcShort( 0x10 ),	/* 16 */
/* 230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 232 */	NdrFcShort( 0x0 ),	/* Offset= 0 (232) */
/* 234 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 236 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 238 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (116) */
/* 240 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 242 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 244 */	NdrFcShort( 0x2 ),	/* Offset= 2 (246) */
/* 246 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 248 */	NdrFcShort( 0x18 ),	/* Offset= 24 (272) */
/* 250 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 254 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 260 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 264 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 266 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 268 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (226) */
/* 270 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 272 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 274 */	NdrFcShort( 0x10 ),	/* 16 */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x6 ),	/* Offset= 6 (284) */
/* 280 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 282 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 284 */	
			0x12, 0x0,	/* FC_UP */
/* 286 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (250) */
/* 288 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 290 */	NdrFcShort( 0x78 ),	/* Offset= 120 (410) */
/* 292 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 294 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 296 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 300 */	NdrFcShort( 0x2 ),	/* Offset= 2 (302) */
/* 302 */	NdrFcShort( 0x10 ),	/* 16 */
/* 304 */	NdrFcShort( 0x8 ),	/* 8 */
/* 306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 312 */	NdrFcLong( 0x1 ),	/* 1 */
/* 316 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 318 */	NdrFcLong( 0x2 ),	/* 2 */
/* 322 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 324 */	NdrFcLong( 0x3 ),	/* 3 */
/* 328 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (166) */
/* 330 */	NdrFcLong( 0x4 ),	/* 4 */
/* 334 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 336 */	NdrFcLong( 0x5 ),	/* 5 */
/* 340 */	NdrFcShort( 0xfffffeae ),	/* Offset= -338 (2) */
/* 342 */	NdrFcLong( 0x6 ),	/* 6 */
/* 346 */	NdrFcShort( 0xffffff68 ),	/* Offset= -152 (194) */
/* 348 */	NdrFcLong( 0x7 ),	/* 7 */
/* 352 */	NdrFcShort( 0xffffff62 ),	/* Offset= -158 (194) */
/* 354 */	NdrFcShort( 0x0 ),	/* Offset= 0 (354) */
/* 356 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 358 */	NdrFcShort( 0x18 ),	/* 24 */
/* 360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 362 */	NdrFcShort( 0x0 ),	/* Offset= 0 (362) */
/* 364 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 366 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 368 */	NdrFcShort( 0xffffffb4 ),	/* Offset= -76 (292) */
/* 370 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 372 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 382 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 386 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (356) */
/* 392 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 394 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 396 */	NdrFcShort( 0x10 ),	/* 16 */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x6 ),	/* Offset= 6 (406) */
/* 402 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 404 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 406 */	
			0x12, 0x0,	/* FC_UP */
/* 408 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (372) */
/* 410 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 412 */	NdrFcShort( 0x30 ),	/* 48 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 416 */	NdrFcShort( 0xe ),	/* Offset= 14 (430) */
/* 418 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 420 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 422 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 424 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (394) */
/* 426 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 428 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 430 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 432 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 434 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 436 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 438 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 440 */	NdrFcShort( 0x2 ),	/* Offset= 2 (442) */
/* 442 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 444 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (410) */
/* 446 */	
			0x11, 0x0,	/* FC_RP */
/* 448 */	NdrFcShort( 0x30 ),	/* Offset= 48 (496) */
/* 450 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 452 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 454 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 456 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 458 */	NdrFcShort( 0x2 ),	/* Offset= 2 (460) */
/* 460 */	NdrFcShort( 0x8 ),	/* 8 */
/* 462 */	NdrFcShort( 0x5 ),	/* 5 */
/* 464 */	NdrFcLong( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0x0 ),	/* Offset= 0 (468) */
/* 470 */	NdrFcLong( 0x1 ),	/* 1 */
/* 474 */	NdrFcShort( 0x0 ),	/* Offset= 0 (474) */
/* 476 */	NdrFcLong( 0x2 ),	/* 2 */
/* 480 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 482 */	NdrFcLong( 0x3 ),	/* 3 */
/* 486 */	NdrFcShort( 0xfffffec0 ),	/* Offset= -320 (166) */
/* 488 */	NdrFcLong( 0x4 ),	/* 4 */
/* 492 */	NdrFcShort( 0xfffffe16 ),	/* Offset= -490 (2) */
/* 494 */	NdrFcShort( 0x0 ),	/* Offset= 0 (494) */
/* 496 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 498 */	NdrFcShort( 0x10 ),	/* 16 */
/* 500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 502 */	NdrFcShort( 0x0 ),	/* Offset= 0 (502) */
/* 504 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 506 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 508 */	NdrFcShort( 0xffffffc6 ),	/* Offset= -58 (450) */
/* 510 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 512 */	
			0x11, 0x0,	/* FC_RP */
/* 514 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (394) */
/* 516 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 518 */	NdrFcShort( 0x2 ),	/* Offset= 2 (520) */
/* 520 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 522 */	NdrFcShort( 0x2 ),	/* Offset= 2 (524) */
/* 524 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 526 */	NdrFcShort( 0x18 ),	/* 24 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcShort( 0x0 ),	/* Offset= 0 (530) */
/* 532 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xffffff72 ),	/* Offset= -142 (394) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 542 */	NdrFcShort( 0x2 ),	/* Offset= 2 (544) */
/* 544 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 546 */	NdrFcShort( 0x18 ),	/* Offset= 24 (570) */
/* 548 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 550 */	NdrFcShort( 0x0 ),	/* 0 */
/* 552 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 556 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 558 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 562 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 564 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 566 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (524) */
/* 568 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 570 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 572 */	NdrFcShort( 0x10 ),	/* 16 */
/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 576 */	NdrFcShort( 0x6 ),	/* Offset= 6 (582) */
/* 578 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 580 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 582 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 584 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (548) */
/* 586 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 588 */	NdrFcShort( 0x2 ),	/* Offset= 2 (590) */
/* 590 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 592 */	NdrFcShort( 0x48 ),	/* 72 */
/* 594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 596 */	NdrFcShort( 0x14 ),	/* Offset= 20 (616) */
/* 598 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 600 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 602 */	NdrFcShort( 0xfffffe68 ),	/* Offset= -408 (194) */
/* 604 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 606 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 608 */	NdrFcShort( 0xfffffe46 ),	/* Offset= -442 (166) */
/* 610 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 612 */	NdrFcShort( 0xfffffda6 ),	/* Offset= -602 (10) */
/* 614 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 616 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 618 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 620 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 622 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 624 */	
			0x11, 0x0,	/* FC_RP */
/* 626 */	NdrFcShort( 0x24 ),	/* Offset= 36 (662) */
/* 628 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 630 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 632 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 634 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 636 */	NdrFcShort( 0x2 ),	/* Offset= 2 (638) */
/* 638 */	NdrFcShort( 0x10 ),	/* 16 */
/* 640 */	NdrFcShort( 0x3 ),	/* 3 */
/* 642 */	NdrFcLong( 0x0 ),	/* 0 */
/* 646 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 648 */	NdrFcLong( 0x1 ),	/* 1 */
/* 652 */	NdrFcShort( 0xfffffe36 ),	/* Offset= -458 (194) */
/* 654 */	NdrFcLong( 0x2 ),	/* 2 */
/* 658 */	NdrFcShort( 0xfffffd70 ),	/* Offset= -656 (2) */
/* 660 */	NdrFcShort( 0x0 ),	/* Offset= 0 (660) */
/* 662 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 664 */	NdrFcShort( 0x18 ),	/* 24 */
/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 668 */	NdrFcShort( 0x0 ),	/* Offset= 0 (668) */
/* 670 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 672 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 674 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (628) */
/* 676 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 678 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 680 */	NdrFcShort( 0x2 ),	/* Offset= 2 (682) */
/* 682 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 684 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (590) */
/* 686 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 688 */	NdrFcShort( 0x2 ),	/* Offset= 2 (690) */
/* 690 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 692 */	NdrFcShort( 0x18 ),	/* Offset= 24 (716) */
/* 694 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 704 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 708 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 710 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 712 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (590) */
/* 714 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 716 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 718 */	NdrFcShort( 0x10 ),	/* 16 */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x6 ),	/* Offset= 6 (728) */
/* 724 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 726 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 728 */	
			0x12, 0x0,	/* FC_UP */
/* 730 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (694) */
/* 732 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 734 */	NdrFcShort( 0x2 ),	/* Offset= 2 (736) */
/* 736 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 738 */	NdrFcShort( 0x2 ),	/* Offset= 2 (740) */
/* 740 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 742 */	NdrFcShort( 0x10 ),	/* 16 */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x6 ),	/* Offset= 6 (752) */
/* 748 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 750 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 752 */	
			0x12, 0x0,	/* FC_UP */
/* 754 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (548) */
/* 756 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 758 */	NdrFcShort( 0x2 ),	/* Offset= 2 (760) */
/* 760 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 762 */	NdrFcShort( 0x1c ),	/* Offset= 28 (790) */
/* 764 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 766 */	NdrFcShort( 0x10 ),	/* 16 */
/* 768 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 770 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 772 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 774 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 776 */	NdrFcShort( 0x10 ),	/* 16 */
/* 778 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 780 */	NdrFcShort( 0x24 ),	/* 36 */
/* 782 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 784 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 786 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (764) */
/* 788 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 790 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x30 ),	/* 48 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x10 ),	/* Offset= 16 (812) */
/* 798 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 800 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 802 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 804 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 806 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd7f ),	/* Offset= -641 (166) */
			0x8,		/* FC_LONG */
/* 810 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 812 */	
			0x12, 0x0,	/* FC_UP */
/* 814 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (774) */
/* 816 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 818 */	NdrFcShort( 0x2 ),	/* Offset= 2 (820) */
/* 820 */	
			0x12, 0x0,	/* FC_UP */
/* 822 */	NdrFcShort( 0x18 ),	/* Offset= 24 (846) */
/* 824 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
/* 832 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 834 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 838 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 840 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 842 */	NdrFcShort( 0xfffffe50 ),	/* Offset= -432 (410) */
/* 844 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 846 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 848 */	NdrFcShort( 0x10 ),	/* 16 */
/* 850 */	NdrFcShort( 0x0 ),	/* 0 */
/* 852 */	NdrFcShort( 0x6 ),	/* Offset= 6 (858) */
/* 854 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 856 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 858 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 860 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (824) */
/* 862 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 864 */	NdrFcShort( 0xfffffeda ),	/* Offset= -294 (570) */
/* 866 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 868 */	NdrFcShort( 0x2 ),	/* Offset= 2 (870) */
/* 870 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 872 */	NdrFcShort( 0x38 ),	/* 56 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */
/* 876 */	NdrFcShort( 0xe ),	/* Offset= 14 (890) */
/* 878 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 880 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 882 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 884 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 886 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 888 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 890 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 892 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 894 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 896 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 898 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 900 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 902 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 904 */	NdrFcShort( 0x2 ),	/* Offset= 2 (906) */
/* 906 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 908 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (870) */
/* 910 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 912 */	NdrFcShort( 0x2 ),	/* Offset= 2 (914) */
/* 914 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 916 */	NdrFcShort( 0x24 ),	/* Offset= 36 (952) */
/* 918 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */
/* 924 */	NdrFcShort( 0x0 ),	/* Offset= 0 (924) */
/* 926 */	0x8,		/* FC_LONG */
			0xd,		/* FC_ENUM16 */
/* 928 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 930 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 934 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 938 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 940 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 944 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 946 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 948 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (918) */
/* 950 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 952 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 954 */	NdrFcShort( 0x10 ),	/* 16 */
/* 956 */	NdrFcShort( 0x0 ),	/* 0 */
/* 958 */	NdrFcShort( 0x6 ),	/* Offset= 6 (964) */
/* 960 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 962 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 964 */	
			0x12, 0x0,	/* FC_UP */
/* 966 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (930) */
/* 968 */	
			0x11, 0x0,	/* FC_RP */
/* 970 */	NdrFcShort( 0x46 ),	/* Offset= 70 (1040) */
/* 972 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 974 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 976 */	NdrFcShort( 0x1 ),	/* 1 */
/* 978 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 980 */	NdrFcShort( 0x2 ),	/* Offset= 2 (982) */
/* 982 */	NdrFcShort( 0x8 ),	/* 8 */
/* 984 */	NdrFcShort( 0x5 ),	/* 5 */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0xfffffcc4 ),	/* Offset= -828 (162) */
/* 992 */	NdrFcLong( 0x1 ),	/* 1 */
/* 996 */	NdrFcShort( 0xfffffcca ),	/* Offset= -822 (174) */
/* 998 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1002 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1018) */
/* 1004 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1008 */	NdrFcShort( 0xfffffcb2 ),	/* Offset= -846 (162) */
/* 1010 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1014 */	NdrFcShort( 0xfffffcac ),	/* Offset= -852 (162) */
/* 1016 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1016) */
/* 1018 */	
			0x12, 0x0,	/* FC_UP */
/* 1020 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1022) */
/* 1022 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1024 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1028 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1036) */
/* 1030 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1032 */	0x36,		/* FC_POINTER */
			0x2,		/* FC_CHAR */
/* 1034 */	0x43,		/* FC_STRUCTPAD7 */
			0x5b,		/* FC_END */
/* 1036 */	
			0x12, 0x0,	/* FC_UP */
/* 1038 */	NdrFcShort( 0xfffffcb4 ),	/* Offset= -844 (194) */
/* 1040 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 1042 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1046 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1046) */
/* 1048 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 1050 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1052 */	NdrFcShort( 0xffffffb0 ),	/* Offset= -80 (972) */
/* 1054 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1056 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1058 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1060) */
/* 1060 */	
			0x12, 0x0,	/* FC_UP */
/* 1062 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1086) */
/* 1064 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1066 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1068 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1074 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1078 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1080 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1082 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1040) */
/* 1084 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1086 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1088 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1092 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1098) */
/* 1094 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1096 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1098 */	
			0x12, 0x0,	/* FC_UP */
/* 1100 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1064) */
/* 1102 */	
			0x11, 0x0,	/* FC_RP */
/* 1104 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1106) */
/* 1106 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1108 */	NdrFcShort( 0x50 ),	/* 80 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1112 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1134) */
/* 1114 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1116 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1118 */	NdrFcShort( 0xfffffc64 ),	/* Offset= -924 (194) */
/* 1120 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1122 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1124 */	NdrFcShort( 0xfffffc42 ),	/* Offset= -958 (166) */
/* 1126 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1128 */	NdrFcShort( 0xfffffba2 ),	/* Offset= -1118 (10) */
/* 1130 */	0x2,		/* FC_CHAR */
			0x43,		/* FC_STRUCTPAD7 */
/* 1132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1134 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1136 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1138 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1140 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1142 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1144 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1146) */
/* 1146 */	
			0x12, 0x0,	/* FC_UP */
/* 1148 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1106) */
/* 1150 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1152 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1154) */
/* 1154 */	
			0x12, 0x0,	/* FC_UP */
/* 1156 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1180) */
/* 1158 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1168 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1172 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1174 */	
			0x12, 0x0,	/* FC_UP */
/* 1176 */	NdrFcShort( 0xffffffba ),	/* Offset= -70 (1106) */
/* 1178 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1180 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1182 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1186 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1192) */
/* 1188 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1190 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1192 */	
			0x12, 0x0,	/* FC_UP */
/* 1194 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1158) */
/* 1196 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1198 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1200) */
/* 1200 */	
			0x12, 0x0,	/* FC_UP */
/* 1202 */	NdrFcShort( 0x2a ),	/* Offset= 42 (1244) */
/* 1204 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1206 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1210 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1218) */
/* 1212 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1214 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1216 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1218 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1220 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1222 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1226 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1232 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1236 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1240 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1204) */
/* 1242 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1244 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1246 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1256) */
/* 1252 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1254 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1256 */	
			0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1222) */
/* 1260 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1262 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1264 */	
			0x11, 0x0,	/* FC_RP */
/* 1266 */	NdrFcShort( 0xe ),	/* Offset= 14 (1280) */
/* 1268 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1270 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1274 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1278 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1280 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1282 */	NdrFcShort( 0x50 ),	/* 80 */
/* 1284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1286 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1306) */
/* 1288 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1290 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1292 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 1294 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1296 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1298 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1300 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 1302 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1304 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1306 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1308 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1310 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1312 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1314 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1316 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1318 */	
			0x12, 0x0,	/* FC_UP */
/* 1320 */	NdrFcShort( 0xffffffcc ),	/* Offset= -52 (1268) */
/* 1322 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1324 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1326) */
/* 1326 */	
			0x12, 0x0,	/* FC_UP */
/* 1328 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1280) */

			0x0
        }
    };

static const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ] = 
        {
        {
            (GENERIC_BINDING_ROUTINE)DHCP_SRV_HANDLE_bind,
            (GENERIC_UNBIND_ROUTINE)DHCP_SRV_HANDLE_unbind
         }
        
        };


static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000
    ,dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001
    };


static const unsigned short dhcpsrv_FormatStringOffsetTable[] =
    {
    0,
    56,
    112,
    168,
    242,
    298,
    384,
    446,
    502,
    558,
    614,
    670,
    720,
    782,
    844,
    924,
    980,
    1030,
    1080,
    1136,
    1186,
    1266,
    1328,
    1378,
    1452,
    1508,
    1564,
    1614,
    1676,
    1732,
    1788,
    1874,
    1936,
    1986,
    2036,
    2092,
    2172,
    2234,
    2284,
    2334,
    2390
    };


static const MIDL_STUB_DESC dhcpsrv_StubDesc = 
    {
    (void __RPC_FAR *)& dhcpsrv___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &dhcpsrv_bhandle,
    0,
    BindingRoutines,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000143, /* MIDL Version 6.0.323 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\client\rpcbind.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the
    DHCP server service.

Author:

    Madan Appiah (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcpcli.h"

static WCHAR LocalMachineName[MAX_COMPUTERNAME_LENGTH + 1] = L"";

//
// Bind should timeout in a max of 15 sec
//
const int DHCP_RPC_BIND_TIMEOUT_VALUE = ( 1000 * 15 );

BOOL fShortTimeOut = FALSE;

DWORD
FindProtocolToUse(
    LPWSTR ServerIpAddress
    )
/*++

Routine Description:

    This function returns the protocol binding to be used. It examines
    the ServerIpAddress string, if it is :

    1. NULL or local IPAddress or Local Name - use "ncalrpc"
    2. IpAddress - (of the  form "ppp.qqq.rrr.sss") -   use "ncacn_ip_tcp"
    3. otherwise use "ncacn_np" protocol.


Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    One of the following values :

        DHCP_SERVER_USE_RPC_OVER_TCPIP  0x1
        DHCP_SERVER_USE_RPC_OVER_NP     0x2
        DHCP_SERVER_USE_RPC_OVER_LPC    0x4

--*/
{
    DWORD DotCount = 0;
    LPWSTR String = ServerIpAddress;
    DWORD ComputerNameLength;

    if( (ServerIpAddress == NULL) ||
            (*ServerIpAddress == L'\0') ) {

        return( DHCP_SERVER_USE_RPC_OVER_LPC );
    }

    while ( (String = wcschr( String, L'.' )) != NULL ) {

        //
        // found another DOT.
        //

        DotCount++;
        String++;   // skip this dot.
    }

    //
    // if the string has 3 DOTs exactly then this string must represent
    // an IpAddress.
    //

    if( DotCount == 3) {

        //
        // if this is local IP Address, use LPC
        //

        if( _wcsicmp(L"127.0.0.1" , ServerIpAddress) == 0 ) {
            return( DHCP_SERVER_USE_RPC_OVER_LPC );
        }

        //
        // ?? determine whether this address is local IPAddress.
        //

        return(DHCP_SERVER_USE_RPC_OVER_TCPIP);
    }

    //
    // It is a computer name string. Check to see this is local
    // computer name. If so use LPC, otherwise use NP.
    //

    if( *LocalMachineName == L'\0' ) {

        ComputerNameLength = MAX_COMPUTERNAME_LENGTH;

        if( !GetComputerName(
                LocalMachineName,
                &ComputerNameLength ) ) {

            *LocalMachineName = L'\0';
        }
    }

    //
    // if know machine ..
    //

    if( (*LocalMachineName != L'\0') ) {

        BOOL LocalMachine;

        //
        // if the machine has "\\" skip it for name compare.
        //

        if( *ServerIpAddress == L'\\' ) {
            LocalMachine = !_wcsicmp( LocalMachineName, ServerIpAddress + 2);
        }
        else {
            LocalMachine = !_wcsicmp( LocalMachineName, ServerIpAddress);
        }

        if( LocalMachine ) {
            return( DHCP_SERVER_USE_RPC_OVER_LPC );
        }

    }

    return( DHCP_SERVER_USE_RPC_OVER_NP );
}


handle_t
DHCP_SRV_HANDLE_bind(
    DHCP_SRV_HANDLE ServerIpAddress
    )

/*++

Routine Description:

    This routine is called from the DHCP server service client stubs when
    it is necessary create an RPC binding to the server end.

Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR binding = NULL;
    handle_t bindingHandle;
    DWORD RpcProtocol;

    //
    // examine the ServerIpAddress string, if it is :
    //
    // 1. NULL or local IPAddress or Local Name - use "ncalrpc"
    // 2. IpAddress - (of the  form "ppp.qqq.rrr.sss") -   use "ncacn_ip_tcp"
    // 3. otherwise use "ncacn_np" protocol.
    //

    RpcProtocol = FindProtocolToUse( ServerIpAddress );

    if( RpcProtocol == DHCP_SERVER_USE_RPC_OVER_LPC ) {

        rpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        NULL,
                        DHCP_LPC_EP,
                        // L"Security=Impersonation Dynamic False",
                        L"Security=Impersonation Static True",
                        &binding);
    }
    else if( RpcProtocol == DHCP_SERVER_USE_RPC_OVER_NP ) {

        rpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        ServerIpAddress,
                        DHCP_NAMED_PIPE,
                        L"Security=Impersonation Static True",
                        &binding);
    }
    else {

        rpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_ip_tcp",
                        ServerIpAddress,
                        DHCP_SERVER_BIND_PORT,
                        NULL,
                        &binding);
    }

    if ( rpcStatus != RPC_S_OK ) {
        goto Cleanup;
    }

    rpcStatus = RpcBindingFromStringBindingW( binding, &bindingHandle );

    if ( rpcStatus != RPC_S_OK ) {
        goto Cleanup;
    }

    if( RpcProtocol == DHCP_SERVER_USE_RPC_OVER_TCPIP ) {
        //
        // Tell RPC to do the security thing.
        //

        if( DhcpGlobalTryDownlevel ) {
            rpcStatus = RpcBindingSetAuthInfo(
                bindingHandle,                  // binding handle
                DHCP_SERVER_SECURITY,           // app name to security provider
                RPC_C_AUTHN_LEVEL_CONNECT,      // auth level
                DHCP_SERVER_SECURITY_AUTH_ID,   // Auth package ID
                NULL,                           // client auth info, NULL specified logon info.
                RPC_C_AUTHZ_NAME );
        } else {
            rpcStatus = RpcBindingSetAuthInfo(
                bindingHandle, NULL,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                RPC_C_AUTHN_GSS_NEGOTIATE, NULL, RPC_C_AUTHZ_NAME );
        }
    } // if

    rpcStatus = RpcBindingSetOption( bindingHandle, RPC_C_OPT_CALL_TIMEOUT,
                                     fShortTimeOut ? DHCP_RPC_BIND_TIMEOUT_VALUE : 0);

Cleanup:

    if ( NULL != binding ) {
        RpcStringFreeW(&binding);
    }

    if ( rpcStatus != RPC_S_OK ) {
        SetLastError( rpcStatus );
        return( NULL );
    }

    return bindingHandle;
}




void
DHCP_SRV_HANDLE_unbind(
    DHCP_SRV_HANDLE ServerIpAddress,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine is called from the DHCP server service client stubs
    when it is necessary to unbind from the server end.

Arguments:

    ServerIpAddress - This is the IP address of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    fShortTimeOut = FALSE;
    (VOID)RpcBindingFree(&BindHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\client\rpcstub.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcstub.c

Abstract:

    Client stubs of the DHCP server service APIs.

Author:

    Madan Appiah (madana) 10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcpcli.h"
#include <dhcpds.h>                             // this is from dhcpds directory
#include <stdlib.h>
#include <winsock2.h>
#include <rpcasync.h>

CRITICAL_SECTION DhcpsapiDllCritSect;

static      DWORD                  Initialized = 0;
static      DWORD                  TlsIndex = 0xFFFFFFFF;

// This flag is used to set a shorter bind timeout value
extern      BOOL fShortTimeOut;

BOOLEAN
DllMain (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This is the DLL initialization routine for dhcpsapi.dll.

Arguments:

    Standard.

Return Value:

    TRUE iff initialization succeeded.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    BOOL  BoolError;
    DWORD Length;

    UNREFERENCED_PARAMETER(DllHandle);  // avoid compiler warnings
    UNREFERENCED_PARAMETER(Context);    // avoid compiler warnings

    //
    // Handle attaching netlogon.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

        if ( !DisableThreadLibraryCalls( DllHandle ) ) {
            return( FALSE );
        }

        try {

            InitializeCriticalSection(&DhcpsapiDllCritSect);

        } except ( I_RpcExceptionFilter(RpcExceptionCode())) {

            Error = GetLastError( );
            return FALSE;
        }

    } else if (Reason == DLL_PROCESS_DETACH) {
	DeleteCriticalSection( &DhcpsapiDllCritSect );        
    }

    return( TRUE );
}

    
VOID _cdecl 
DbgPrint( char *, ... );

LPWSTR      _inline
DhcpOemToUnicode(                               // convert from ansi buffer to uni buffer
    IN      LPSTR                  Ansi,
    IN OUT  LPWSTR                 Unicode
)
{
    if( NULL == Unicode || NULL == Ansi ) {     // should not happen
        return NULL;
    }

    if( -1 == mbstowcs(Unicode, Ansi, 1+strlen(Ansi))) {
        return NULL;
    }
    return Unicode;
}


//DOC DhcpDsInit must be called exactly once per process.. this initializes the
//DOC memory and other structures for this process.  This initializes some DS
//DOC object handles (memory), and hence is slow as this has to read from DS.
DWORD
DhcpDsInit(
    VOID
)
{
    DWORD                          Err = NO_ERROR;

    EnterCriticalSection(&DhcpsapiDllCritSect);

    do {

        if( 0 != Initialized ) {
            break;
        }

        TlsIndex = TlsAlloc();
        if( 0xFFFFFFFF == TlsIndex ) {
            Err = GetLastError();
            break;
        }

        Err = DhcpDsInitDS(0, NULL);
        if( ERROR_SUCCESS != Err ) {
            TlsFree(TlsIndex);
            TlsIndex = 0xFFFFFFFF;
        }

        break;
    } while ( 0 );

    if( NO_ERROR == Err ) Initialized ++;

    LeaveCriticalSection(&DhcpsapiDllCritSect);
    return Err;
}

//DOC DhcpDsCleanup undoes the effect of any DhcpDsInit.  This function should be
//DOC called exactly once for each process, and only at termination.  Note that
//DOC it is safe to call this function even if DhcpDsInit does not succeed.
VOID
DhcpDsCleanup(
    VOID
)
{
    EnterCriticalSection(&DhcpsapiDllCritSect);

    do {
        if( 0 == Initialized ) break;
        Initialized --;
        if( 0 != Initialized ) break;

        TlsFree(TlsIndex);
        DhcpDsCleanupDS();
        TlsIndex = 0xFFFFFFFF;

    } while ( 0 );

    LeaveCriticalSection(&DhcpsapiDllCritSect);
}

#define     DHCP_FLAGS_DONT_ACCESS_DS             0x01
#define     DHCP_FLAGS_DONT_DO_RPC                0x02

//DOC DhcpSetThreadOptions currently allows only one option to be set.  This is the
//DOC flag DHCP_FLAGS_DONT_ACCESS_DS.  This affects only the current executing thread.
//DOC When this function is executed, all calls made further DONT access the registry,
//DOC excepting the DhcpEnumServers, DhcpAddServer and DhcpDeleteServer calls.
DWORD
DhcpSetThreadOptions(                             // set options for current thread
    IN      DWORD                  Flags,         // options, currently 0 or DHCP_FLAGS_DONT_ACCESS_DS
    IN      LPVOID                 Reserved       // must be NULL, reserved for future
)
{
    BOOL                           Err;

    Err = TlsSetValue(TlsIndex, ULongToPtr(Flags));
    if( FALSE == Err ) {                          // could not set the value?
        return GetLastError();
    }
    return ERROR_SUCCESS;
}

//DOC DhcpGetThreadOptions retrieves the current thread options as set by DhcpSetThreadOptions.
//DOC If none were set, the return value is zero.
DWORD
DhcpGetThreadOptions(                             // get current thread options
    OUT     LPDWORD                pFlags,        // this DWORD is filled with current optiosn..
    IN OUT  LPVOID                 Reserved       // must be NULL, reserved for future
)
{
    if( NULL == pFlags ) return ERROR_INVALID_PARAMETER;
    *pFlags = (DWORD)((DWORD_PTR)TlsGetValue(TlsIndex));
    if( 0 == *pFlags ) return GetLastError();     // dont know if there were no options or error
    return ERROR_SUCCESS;
}

//DOC DontAccessDs is an inline that checks to see if requested NOT to access DS ..
BOOL        _inline                               // TRUE ==> Dont access DS.
DontAccessDs(                                     // check to see if requested NOT to access DS
    VOID
)
{
    DWORD                          Flags;

    if( CFLAG_DONT_DO_DSWORK ) return TRUE;       // if DS is turned off return TRUE immediately..

    Flags = (DWORD)((DWORD_PTR)TlsGetValue(TlsIndex)); // dont bother if it fails, as this would be 0 then.
    return (Flags & DHCP_FLAGS_DONT_ACCESS_DS)? TRUE : FALSE;
}

//DOC DontDoRPC is an inline that checks to see if requested NOT to do RPC (maybe only DS)..
BOOL        _inline                               // TRUE ==> Dont do RPC
DontDoRPC(                                        // check to see if requested not to do RPC
    VOID
)
{
    DWORD                          Flags;
    Flags = (DWORD)((DWORD_PTR)TlsGetValue(TlsIndex)); // dont bother if it fails, as this would be 0 then.
    return (Flags & DHCP_FLAGS_DONT_DO_RPC)? TRUE : FALSE;
}

//
// API proto types
//

//
// Subnet APIs
//

DWORD
DhcpCreateSubnet(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO SubnetInfo
    )
/*++

Routine Description:

    This function creates a new subnet structure in the server
    registry database. The server will start managing the new subnet
    and distribute IP address to clients from that subnet. However
    the administrator should call DhcpAddSubnetElement() to add an
    address range for distribution. The PrimaryHost field specified in
    the SubnetInfo should be same as the server pointed by
    ServerIpAddress.

Arguments:

    ServerIpAddress : IP address string of the DHCP server (Primary).

    SubnetAddress : IP Address of the new subnet.

    SubnetInfo : Pointer to the new subnet information structure.

Return Value:

    ERROR_DHCP_SUBNET_EXISTS - if the subnet is already managed.

    ERROR_INVALID_PARAMETER - if the information structure contains an
        inconsistent fields.

    other WINDOWS errors.

--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpCreateSubnet(
                    ServerIpAddress,
                    SubnetAddress,
                    SubnetInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }

    return Status;
}

DWORD
DhcpSetSubnetInfo(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO SubnetInfo
    )
/*++

Routine Description:

    This function sets the information fields of the subnet that is already
    managed by the server. The valid fields that can be modified are 1.
    SubnetName, 2. SubnetComment, 3. PrimaryHost.NetBiosName and 4.
    PrimaryHost.HostName. Other fields can't be modified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    SubnetInfo : Pointer to the subnet information structure.


Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    Other WINDOWS errors.

--*/

{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetSubnetInfo(
                    ServerIpAddress,
                    SubnetAddress,
                    SubnetInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpGetSubnetInfo(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO *SubnetInfo
    )
/*++

Routine Description:

    This function retrieves the information of the subnet managed by
    the server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    SubnetInfo : Pointer to a location where the subnet information
        structure pointer is returned. Caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    Other WINDOWS errors.

--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetSubnetInfo(
                    ServerIpAddress,
                    SubnetAddress,
                    SubnetInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}


DWORD
DhcpEnumSubnets(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_IP_ARRAY *EnumInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the available subnets.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnets(
                    ServerIpAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    EnumInfo,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}

DWORD
DhcpAddSubnetElement(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA AddElementInfo
    )
/*++

Routine Description:

    This function adds a enumerable type of subnet elements to the
    specified subnet. The new elements that are added to the subnet will
    come into effect immediately.

    NOTE: It is not clear now how do we handle the new secondary hosts.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    AddElementInfo : Pointer to an element information structure
        containing new element that is added to the subnet.
        DhcpIPClusters element type is invalid to specify.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    Other WINDOWS errors.
--*/

{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpAddSubnetElement(
                    ServerIpAddress,
                    SubnetAddress,
                    AddElementInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpEnumSubnetElements(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the eumerable fields of a subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    EnumElementType : Type of the subnet element that are enumerated.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumElementInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnetElements(
                    ServerIpAddress,
                    SubnetAddress,
                    EnumElementType,
                    ResumeHandle,
                    PreferredMaximum,
                    EnumElementInfo,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}

DWORD
DhcpRemoveSubnetElement(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveSubnetElement(
                    ServerIpAddress,
                    SubnetAddress,
                    RemoveElementInfo,
                    ForceFlag
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpDeleteSubnet(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_FORCE_FLAG ForceFlag
)
/*++

Routine Description:

    This function removes a subnet from DHCP server management. If the
    subnet is in use (for example, if the IpRange is in use)
    then it returns error according to the ForceFlag specified.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.

--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpDeleteSubnet(
                        ServerIpAddress,
                        SubnetAddress,
                        ForceFlag
                        );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

//
// Option APIs
//

DWORD
DhcpCreateOption(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION OptionInfo
    )
/*++

Routine Description:

    This function creates a new option that will be managed by the
    server. The optionID specified the ID of the new option, it should
    be within 0-255 range. If no default value is specified for this
    option, then this API automatically adds a default value from RFC
    1122 doc. (if it is defined).

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the new option.

    OptionInfo : Pointer to new option information structure.

Return Value:

    ERROR_DHCP_OPTION_EXISTS - if the option exists already.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpCreateOption(
                    ServerIpAddress,
                    OptionID,
                    OptionInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpSetOptionInfo(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION OptionInfo
    )
/*++

Routine Description:

    This functions sets the Options information fields.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option to be set.

    OptionInfo : Pointer to new option information structure.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetOptionInfo(
                    ServerIpAddress,
                    OptionID,
                    OptionInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpGetOptionInfo(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION *OptionInfo
    )
/*++

Routine Description:

    This function retrieves the current information structure of the specified
    option.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option to be retrieved.

    OptionInfo : Pointer to a location where the retrieved option
        structure pointer is returned. Caller should free up
        the buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetOptionInfo(
                    ServerIpAddress,
                    OptionID,
                    OptionInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}

DWORD
DhcpEnumOptions(
    LPWSTR ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_OPTION_ARRAY *Options,
    DWORD *OptionsRead,
    DWORD *OptionsTotal
    )
/*++

Routine Description:

    This functions retrieves the information of all known options.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    Options : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    OptionsRead : Pointer to a DWORD where the number of options
        in the above buffer is returned.

    OptionsTotal : Pointer to a DWORD where the total number of
        options remaining from the current position is returned.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumOptions(
                    ServerIpAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    Options,
                    OptionsRead,
                    OptionsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpRemoveOption(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID
    )
/*++

Routine Description:

    This function removes the specified option from the server database.
    Also it browses through the Global/Subnet/ReservedIP
    option lists and deletes them too (?? This will be too expensive.).

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option to be removed.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveOption(
                    ServerIpAddress,
                    OptionID
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpSetOptionValue(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    LPDHCP_OPTION_DATA OptionValue
    )
/*++

Routine Description:

    The function sets a new option value at the specified scope. If
    there is already a value available for the specified option at
    specified scope then this function will replace it otherwise it will
    create a new entry at that scope.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option whose value should be set.

    ScopeInfo : Pointer to the scope information structure.

    OptionValue : Pointer to the option value structure.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option is unknown.

    ERROR_INVALID_PARAMETER - if the scope information specified is invalid.

    other WINDOWS errors.

--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetOptionValue(
                    ServerIpAddress,
                    OptionID,
                    ScopeInfo,
                    OptionValue
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpSetOptionValues(
    LPWSTR ServerIpAddress,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    LPDHCP_OPTION_VALUE_ARRAY OptionValues
    )
/*++

Routine Description:

    The function sets a set of new options value at the specified scope.
    If there is already a value available for the specified option at
    specified scope then this function will replace it otherwise it will
    create a new entry at that scope.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ScopeInfo : Pointer to the scope information structure.

    OptionValue : Pointer to the option value structure.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option is unknown.

    ERROR_INVALID_PARAMETER - if the scope information specified is invalid.

    other WINDOWS errors.

--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetOptionValues(
                    ServerIpAddress,
                    ScopeInfo,
                    OptionValues
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpGetOptionValue(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    LPDHCP_OPTION_VALUE *OptionValue
    )
/*++

Routine Description:

    This function retrieves the current option value at the specified
    scope. It returns error if there is no option value is available at
    the specified scope.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option whose value is returned.

    ScopeInfo : Pointer to the scope information structure.

    OptionValue : Pointer to a location where the pointer to the option
        value structure is returned. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option is unknown.

    ERROR_DHCP_NO_OPTION_VALUE - if no the option value is available at
        the specified scope.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetOptionValue(
                    ServerIpAddress,
                    OptionID,
                    ScopeInfo,
                    OptionValue
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}


DWORD
DhcpEnumOptionValues(
    LPWSTR ServerIpAddress,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    DWORD *OptionsRead,
    DWORD *OptionsTotal
    )
/*++

Routine Description:

    This function enumerates the available options values at the
    specified scope.

Arguments:
    ServerIpAddress : IP address string of the DHCP server.

    ScopeInfo : Pointer to the scope information structure.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    OptionValues : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    OptionsRead : Pointer to a DWORD where the number of options
        in the above buffer is returned.

    OptionsTotal : Pointer to a DWORD where the total number of
        options remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SCOPE_NOT_PRESENT - if the scope is unknown.

    ERROR_MORE_DATA - if more options available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more option to enumerate.

    Other WINDOWS errors.

--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumOptionValues(
                    ServerIpAddress,
                    ScopeInfo,
                    ResumeHandle,
                    PreferredMaximum,
                    OptionValues,
                    OptionsRead,
                    OptionsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}


DWORD
DhcpRemoveOptionValue(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo
    )
/*++

Routine Description:

    This function removes the specified option from specified scope.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option to be removed.

    ScopeInfo : Pointer to the scope information structure.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveOptionValue(
                    ServerIpAddress,
                    OptionID,
                    ScopeInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

//
// Client APIs
//

DWORD
DhcpCreateClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_CLIENT_INFO ClientInfo
    )
/*++

Routine Description:

    This function creates a client record in server's database. Also
    this marks the specified client IP address as unavailable (or
    distributed). This function returns error under the following cases :

    1. If the specified client IP address is not within the server
        management.

    2. If the specified client IP address is already unavailable.

    3. If the specified client record is already in the server's
        database.

    This function may be used to distribute IP addresses manually.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpCreateClientInfo(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpSetClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_CLIENT_INFO ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetClientInfo(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}


DWORD
DhcpGetClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_CLIENT_INFO *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetClientInfo(
                    ServerIpAddress,
                    SearchInfo,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}


DWORD
DhcpDeleteClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    )
/*++

Routine Description:

    This function deletes the specified client record. Also it frees up
    the client IP address for redistribution.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to a client information which is the key for
        the client's record search.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpDeleteClientInfo(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpEnumSubnetClients(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnetClients(
                    ServerIpAddress,
                    SubnetAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    ClientInfo,
                    ClientsRead,
                    ClientsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpGetClientOptions(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_MASK ClientSubnetMask,
    LPDHCP_OPTION_LIST *ClientOptions
    )
/*++

Routine Description:

    This function retrieves the options that are given to the
    specified client on boot request.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientIpAddress : IP Address of the client whose options to be
        retrieved

    ClientSubnetMask : Subnet mask of the client.

    ClientOptions : Pointer to a location where the retrieved option
        structure pointer is returned. Caller should free up
        the buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the specified client subnet is
        not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetClientOptions(
                    ServerIpAddress,
                    ClientIpAddress,
                    ClientSubnetMask,
                    ClientOptions
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpGetMibInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_MIB_INFO *MibInfo
    )
/*++

Routine Description:

    This function retrieves all counter values of the DHCP server
    service.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MibInfo : pointer a counter/table buffer. Caller should free up this
        buffer after usage.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetMibInfo(
                    ServerIpAddress,
                    MibInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpServerSetConfig(
    LPWSTR ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO ConfigInfo
    )
/*++

Routine Description:

    This function sets the DHCP server configuration information.
    Serveral of the configuration information will become effective
    immediately.

    The following parameters require restart of the service after this
    API is called successfully.

        Set_APIProtocolSupport
        Set_DatabaseName
        Set_DatabasePath
        Set_DatabaseLoggingFlag
        Set_RestoreFlag

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    FieldsToSet : Bit mask of the fields in the ConfigInfo structure to
        be set.

    ConfigInfo: Pointer to the info structure to be set.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpServerSetConfig(
                    ServerIpAddress,
                    FieldsToSet,
                    ConfigInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpServerGetConfig(
    LPWSTR ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO *ConfigInfo
    )
/*++

Routine Description:

    This function retrieves the current configuration information of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ConfigInfo: Pointer to a location where the pointer to the dhcp
        server config info structure is returned. Caller should free up
        this structure after use.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpServerGetConfig(
                    ServerIpAddress,
                    ConfigInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpScanDatabase(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpScanDatabase(
                    ServerIpAddress,
                    SubnetAddress,
                    FixFlag,
                    ScanList );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpGetVersion(
    LPWSTR ServerIpAddress,
    LPDWORD MajorVersion,
    LPDWORD MinorVersion
    )
/*++

Routine Description:

    This function returns the major and minor version numbers of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MajorVersion : pointer to a location where the major version of the
        server is returned.

    MinorVersion : pointer to a location where the minor version of the
        server is returned.

Return Value:

    WINDOWS errors.

--*/
{

    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetVersion(
                        ServerIpAddress,
                        MajorVersion,
                        MinorVersion );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


VOID
DhcpRpcFreeMemory(
    PVOID BufferPointer
    )
/*++

Routine Description:

    This function deallocates the memory that was alloted by the RPC and
    given to the client as part of the retrun info structures.

Arguments:

    BufferPointer : pointer to a memory block that is deallocated.

Return Value:

    none.

--*/
{
    MIDL_user_free( BufferPointer );
}

//
// NT4 SP1 interface
//

DWORD
DhcpAddSubnetElementV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V4 * AddElementInfo
    )
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpAddSubnetElementV4(
                    ServerIpAddress,
                    SubnetAddress,
                    AddElementInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpEnumSubnetElementsV4(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the eumerable fields of a subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    EnumElementType : Type of the subnet element that are enumerated.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumElementInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpEnumSubnetElementsV4(
                    ServerIpAddress,
                    SubnetAddress,
                    EnumElementType,
                    ResumeHandle,
                    PreferredMaximum,
                    EnumElementInfo,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}


DWORD
DhcpRemoveSubnetElementV4(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveSubnetElementV4(
                    ServerIpAddress,
                    SubnetAddress,
                    RemoveElementInfo,
                    ForceFlag
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpCreateClientInfoV4(
    LPWSTR ServerIpAddress,
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
/*++

Routine Description:

    This function creates a client record in server's database. Also
    this marks the specified client IP address as unavailable (or
    distributed). This function returns error under the following cases :

    1. If the specified client IP address is not within the server
        management.

    2. If the specified client IP address is already unavailable.

    3. If the specified client record is already in the server's
        database.

    This function may be used to distribute IP addresses manually.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpCreateClientInfoV4(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpGetClientInfoV4(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_CLIENT_INFO_V4 *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetClientInfoV4(
                    ServerIpAddress,
                    SearchInfo,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}



DWORD
DhcpSetClientInfoV4(
    LPWSTR ServerIpAddress,
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetClientInfoV4(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpEnumSubnetClientsV4(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V4 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnetClientsV4(
                    ServerIpAddress,
                    SubnetAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    ClientInfo,
                    ClientsRead,
                    ClientsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpEnumSubnetClientsV5(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V5 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnetClientsV5(
                    ServerIpAddress,
                    SubnetAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    ClientInfo,
                    ClientsRead,
                    ClientsTotal
                    );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpServerSetConfigV4(
    LPWSTR ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo
    )
/*++

Routine Description:

    This function sets the DHCP server configuration information.
    Serveral of the configuration information will become effective
    immediately.

    The following parameters require restart of the service after this
    API is called successfully.

        Set_APIProtocolSupport
        Set_DatabaseName
        Set_DatabasePath
        Set_DatabaseLoggingFlag
        Set_RestoreFlag

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    FieldsToSet : Bit mask of the fields in the ConfigInfo structure to
        be set.

    ConfigInfo: Pointer to the info structure to be set.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpServerSetConfigV4(
                    ServerIpAddress,
                    FieldsToSet,
                    ConfigInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD
DhcpServerGetConfigV4(
    LPWSTR ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO_V4 *ConfigInfo
    )
/*++

Routine Description:

    This function retrieves the current configuration information of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ConfigInfo: Pointer to a location where the pointer to the dhcp
        server config info structure is returned. Caller should free up
        this structure after use.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpServerGetConfigV4(
                    ServerIpAddress,
                    ConfigInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}



DWORD
DhcpSetSuperScopeV4(
    DHCP_CONST DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_CONST DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST LPWSTR SuperScopeName,
    DHCP_CONST BOOL ChangeExisting
    )
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept
    {
        Status = R_DhcpSetSuperScopeV4(
                    ServerIpAddress,
                    SubnetAddress,
                    SuperScopeName,
                    ChangeExisting
                    );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )
    {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpDeleteSuperScopeV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST LPWSTR SuperScopeName
    )
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept
    {
        Status = R_DhcpDeleteSuperScopeV4(
                          ServerIpAddress,
                          SuperScopeName
                          );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )
    {
        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpGetSuperScopeInfoV4(
    DHCP_CONST DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
    )
{
    DWORD Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpGetSuperScopeInfoV4(
                    ServerIpAddress,
                    SuperScopeTable
                    );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}

//================================================================================
//  V5 NT 5.0 Beta2 work (ClassId and Vendor specific stuff)
//  In the following function, if flags is DHCP_FLAGS_OPTION_IS_VENDOR
//  implies the option being considered is vendor, otherwise the option is normal...
//  ClasName = NULL imples there is no class (otherwise the class is named)
//================================================================================

DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
DhcpCreateOptionV5(                               // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpCreateOptionV5(
            ServerIpAddress,
            Flags,
            OptionId,
            ClassName,
            VendorName,
            OptionInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}

DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpSetOptionInfoV5(                              // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpSetOptionInfoV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName,
            OptionInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
DhcpGetOptionInfoV5(                              // retrieve the information from off the mem structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept  {
        Status = R_DhcpGetOptionInfoV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName,
            OptionInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}

DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpEnumOptionsV5(                                // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept  {
        Status = R_DhcpEnumOptionsV5(
            ServerIpAddress,
            Flags,
            ClassName,
            VendorName,
            ResumeHandle,
            PreferredMaximum,
            Options,
            OptionsRead,
            OptionsTotal
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}

DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
DhcpRemoveOptionV5(                               // remove the option definition from the registry
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpRemoveOptionV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValueV5(                             // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpSetOptionValueV5(
            ServerIpAddress,
            Flags,
            OptionId,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValue
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD                                             // not atomic!!!!
DhcpSetOptionValuesV5(                            // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpSetOptionValuesV5(
            ServerIpAddress,
            Flags,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValues
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpGetOptionValueV5(                             // fetch the required option at required level
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept  {
        Status = R_DhcpGetOptionValueV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValue
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}


DWORD
DhcpEnumOptionValuesV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept  {
        Status = R_DhcpEnumOptionValuesV5(
            ServerIpAddress,
            Flags,
            ClassName,
            VendorName,
            ScopeInfo,
            ResumeHandle,
            PreferredMaximum,
            OptionValues,
            OptionsRead,
            OptionsTotal
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}


DWORD
DhcpRemoveOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpRemoveOptionValueV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName,
            ScopeInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpCreateClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpCreateClass(
            ServerIpAddress,
            ReservedMustBeZero,
            ClassInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpModifyClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpModifyClass(
            ServerIpAddress,
            ReservedMustBeZero,
            ClassInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpDeleteClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpDeleteClass(
            ServerIpAddress,
            ReservedMustBeZero,
            ClassName
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
}


DWORD
DhcpGetClassInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept  {
        Status = R_DhcpGetClassInfo(
            ServerIpAddress,
            ReservedMustBeZero,
            PartialClassInfo,
            FilledClassInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}


DWORD
DhcpEnumClasses(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Status;

    *nRead = *nTotal =0;

    RedoRpc: RpcTryExcept  {
        Status = R_DhcpEnumClasses(
            ServerIpAddress,
            ReservedMustBeZero,
            ResumeHandle,
            PreferredMaximum,
            ClassInfoArray,
            nRead,
            nTotal
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}

DWORD
DhcpGetAllOptions(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // what do we care about vendor/classid stuff?
    OUT     LPDHCP_ALL_OPTIONS     *OptionStruct   // fill the fields of this structure
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpGetAllOptions(
            ServerIpAddress,
            Flags,
            OptionStruct
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}

DWORD
DhcpGetAllOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
)
{
    DWORD                           Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpGetAllOptionValues(
            ServerIpAddress,
            Flags,
            ScopeInfo,
            Values
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

}

//DOC DhcpEnumServers enumerates the list of servers found in the DS.  If the DS
//DOC is not accessible, it returns an error. The only currently used parameter
//DOC is the out parameter Servers.  This is a SLOW call.
DWORD
DhcpEnumServers(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,    // output servers list
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
)
{
    DWORD                          Result;

    Result = DhcpEnumServersDS(Flags,IdInfo,Servers,CallbackFn,CallbackData);

    return Result;
}

//DOC DhcpAddServer tries to add a new server to the existing list of servers in
//DOC the DS. The function returns error if the Server already exists in the DS.
//DOC The function tries to upload the server configuration to the DS..
//DOC This is a SLOW call.  Currently, the DsLocation and DsLocType are not valid
//DOC fields in the NewServer and they'd be ignored. Version must be zero.
DWORD
DhcpAddServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
)
{
    DWORD                          Err, IpAddress;
    WCHAR                          wBuf[sizeof("xxx.xxx.xxx.xxx")];

    Err = DhcpAddServerDS(Flags,IdInfo,NewServer,CallbackFn,CallbackData);
    if( ERROR_SUCCESS != Err ) return Err;

    IpAddress = htonl(NewServer->ServerAddress);
    (void)DhcpServerRedoAuthorization(
        DhcpOemToUnicode( inet_ntoa(*(struct in_addr*)&IpAddress), wBuf),
        0
    );


    return ERROR_SUCCESS;
}

//DOC DhcpDeleteServer tries to delete the server from DS. It is an error if the
//DOC server does not already exist.  This also deletes any objects related to
//DOC this server in the DS (like subnet, reservations etc.).
DWORD
DhcpDeleteServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
)
{
    DWORD                          Err, IpAddress;
    WCHAR                          wBuf[sizeof("xxx.xxx.xxx.xxx")];

    Err = DhcpDeleteServerDS(Flags,IdInfo,NewServer,CallbackFn,CallbackData);
    if( ERROR_SUCCESS != Err ) return Err;

    IpAddress = htonl(NewServer->ServerAddress);
    (void)DhcpServerRedoAuthorization(
        DhcpOemToUnicode( inet_ntoa(*(struct in_addr*)&IpAddress), wBuf),
        0
    );


    return ERROR_SUCCESS;
}

//================================================================================
// Multicast stuff
//================================================================================

DWORD
DhcpSetMScopeInfo(
    DHCP_CONST DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR  MScopeName,
    LPDHCP_MSCOPE_INFO MScopeInfo,
    BOOL NewScope
    )
{
    DWORD Status;

    RedoRpc: RpcTryExcept
    {
        Status = R_DhcpSetMScopeInfo(
                    ServerIpAddress,
                    MScopeName,
                    MScopeInfo,
                    NewScope
                    );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )
    {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpGetMScopeInfo(
    DHCP_CONST DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR  MScopeName,
    LPDHCP_MSCOPE_INFO *MScopeInfo
    )
{
    DWORD Status;

    RedoRpc: RpcTryExcept
    {
        Status = R_DhcpGetMScopeInfo(
                    ServerIpAddress,
                    MScopeName,
                    MScopeInfo
                    );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )
    {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}


DWORD
DhcpEnumMScopes(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MSCOPE_TABLE *MScopeTable,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the available subnets.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumMScopes(
                    ServerIpAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    MScopeTable,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpAddMScopeElement(
    LPWSTR ServerIpAddress,
    LPWSTR  MScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo
    )
/*++

Routine Description:

    This function adds a enumerable type of subnet elements to the
    specified subnet. The new elements that are added to the subnet will
    come into effect immediately.

    NOTE: It is not clear now how do we handle the new secondary hosts.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    AddElementInfo : Pointer to an element information structure
        containing new element that is added to the subnet.
        DhcpIPClusters element type is invalid to specify.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    Other WINDOWS errors.
--*/

{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpAddMScopeElement(
                    ServerIpAddress,
                    MScopeName,
                    AddElementInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpEnumMScopeElements(
    LPWSTR ServerIpAddress,
    LPWSTR  MScopeName,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the eumerable fields of a subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    EnumElementType : Type of the subnet element that are enumerated.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumElementInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumMScopeElements(
                    ServerIpAddress,
                    MScopeName,
                    EnumElementType,
                    ResumeHandle,
                    PreferredMaximum,
                    EnumElementInfo,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpRemoveMScopeElement(
    LPWSTR ServerIpAddress,
    LPWSTR  MScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveMScopeElement(
                    ServerIpAddress,
                    MScopeName,
                    RemoveElementInfo,
                    ForceFlag
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpDeleteMScope(
    LPWSTR ServerIpAddress,
    LPWSTR  MScopeName,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet from DHCP server management. If the
    subnet is in use (for example, if the IpRange is in use)
    then it returns error according to the ForceFlag specified.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.

--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpDeleteMScope(
                        ServerIpAddress,
                        MScopeName,
                        ForceFlag
                        );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpGetMClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_MCLIENT_INFO *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetMClientInfo(
                    ServerIpAddress,
                    SearchInfo,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpDeleteMClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    )
/*++

Routine Description:

    This function deletes the specified client record. Also it frees up
    the client IP address for redistribution.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to a client information which is the key for
        the client's record search.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpDeleteMClientInfo(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpEnumMScopeClients(
    LPWSTR ServerIpAddress,
    LPWSTR MScopeName,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MCLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumMScopeClients(
                    ServerIpAddress,
                    MScopeName,
                    ResumeHandle,
                    PreferredMaximum,
                    ClientInfo,
                    ClientsRead,
                    ClientsTotal
                    );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;

}

DWORD
DhcpScanMDatabase(
    LPWSTR ServerIpAddress,
    LPWSTR MScopeName,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpScanMDatabase(
                    ServerIpAddress,
                    MScopeName,
                    FixFlag,
                    ScanList );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpGetMCastMibInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_MCAST_MIB_INFO *MibInfo
    )
/*++

Routine Description:

    This function retrieves all counter values of the DHCP server
    service.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MibInfo : pointer a counter/table buffer. Caller should free up this
        buffer after usage.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetMCastMibInfo(
                    ServerIpAddress,
                    MibInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}


DWORD
DhcpAuditLogSetParams(                            // set some auditlogging params
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpAuditLogSetParams(
            ServerIpAddress,
            Flags,
            AuditLogDir,
            DiskCheckInterval,
            MaxLogFilesSize,
            MinSpaceOnDisk
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpAuditLogGetParams(                                // get the auditlogging params
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDisk     // ditto
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpAuditLogGetParams(
            ServerIpAddress,
            Flags,
            AuditLogDir,
            DiskCheckInterval,
            MaxLogFilesSize,
            MinSpaceOnDisk
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD                                             // Status code
DhcpServerQueryAttribute(                         // get a server status
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved,    // reserved for future
    IN      DHCP_ATTRIB_ID         DhcpAttribId,  // the attrib being queried
    OUT     LPDHCP_ATTRIB         *pDhcpAttrib    // fill in this field
)
{
    ULONG                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpServerQueryAttribute(
            ServerIpAddr,
            dwReserved,
            DhcpAttribId,
            pDhcpAttrib
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD                                             // Status code
DhcpServerQueryAttributes(                        // query multiple attributes
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved,    // reserved for future
    IN      ULONG                  dwAttribCount, // # of attribs being queried
    IN      DHCP_ATTRIB_ID         pDhcpAttribs[],// array of attribs
    OUT     LPDHCP_ATTRIB_ARRAY   *pDhcpAttribArr // Ptr is filled w/ array
)
{
    ULONG                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpServerQueryAttributes(
            ServerIpAddr,
            dwReserved,
            dwAttribCount,
            pDhcpAttribs,
            pDhcpAttribArr
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD                                             // Status code
DhcpServerRedoAuthorization(                      // retry the rogue server stuff
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved     // reserved for future
)
{
    ULONG                          Status;

    // Use a short timeout value
    fShortTimeOut = TRUE;

    RpcTryExcept {
        Status = R_DhcpServerRedoAuthorization(
            ServerIpAddr,
            dwReserved
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpAddSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * AddElementInfo
    )
{
    ULONG Status;
    
    RedoRpc: RpcTryExcept {
        Status = R_DhcpAddSubnetElementV5(
            ServerIpAddress,
            SubnetAddress,
            AddElementInfo
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetElementsV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpEnumSubnetElementsV5(
            ServerIpAddress,
            SubnetAddress,
            EnumElementType,
            ResumeHandle,
            PreferredMaximum,
            EnumElementInfo,
            ElementsRead,
            ElementsTotal
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpRemoveSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpRemoveSubnetElementV5(
            ServerIpAddress,
            SubnetAddress,
            RemoveElementInfo,
            ForceFlag
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpSetServerBindingInfo(
    IN DHCP_CONST WCHAR *ServerIpAddress,
    IN ULONG Flags,
    IN LPDHCP_BIND_ELEMENT_ARRAY BindInfo
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpSetServerBindingInfo(
            ServerIpAddress,
            Flags,
            BindInfo
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpGetServerBindingInfo(
    IN DHCP_CONST WCHAR *ServerIpAddress,
    IN ULONG Flags,
    OUT LPDHCP_BIND_ELEMENT_ARRAY *BindInfo
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpGetServerBindingInfo(
            ServerIpAddress,
            Flags,
            BindInfo
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}


DWORD
DhcpServerQueryDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN ULONG UnameSize, //in BYTES
    OUT LPWSTR Uname,
    IN ULONG DomainSize, // in BYTES
    OUT LPWSTR Domain
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpQueryDnsRegCredentials(
            ServerIpAddress,
            UnameSize/sizeof(WCHAR), Uname,
            DomainSize/sizeof(WCHAR), Domain );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD 
DhcpServerSetDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Uname,
    IN LPWSTR Domain,
    IN LPWSTR Passwd
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpSetDnsRegCredentials(
            ServerIpAddress, Uname, Domain, Passwd );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpServerBackupDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpBackupDatabase(
            ServerIpAddress, Path );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpServerRestoreDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpRestoreDatabase(
            ServerIpAddress, Path );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}
    

#define BINL_SVC_NAME  L"binlsvc"

BOOL
BinlServiceInstalled(
    VOID
    )
/*++

Routine Description:

    This routine checks if BINL service has been installed.
    BINL service is "binlsvc"

Return Values;

    TRUE -- binl service is installed
    FALSE -- binl service is not installed
    
--*/
{
    SC_HANDLE hScManager, hService;
    ULONG Error, Attempt;
    SERVICE_STATUS ServiceStatus;

    hScManager = OpenSCManager(
        NULL, NULL,
        STANDARD_RIGHTS_READ | SC_MANAGER_ENUMERATE_SERVICE
        );
    if( NULL == hScManager ) {
        DbgPrint("DHCP: OpenSCManager failed 0x%lx\n", GetLastError());
        //ASSERT(FALSE);
        return FALSE;
    }

    hService = OpenService(
        hScManager, BINL_SVC_NAME,
        SERVICE_QUERY_STATUS
        );

#if DBG
    if( NULL == hService ) {
        Error = GetLastError();
        if( ERROR_SERVICE_DOES_NOT_EXIST != Error ) {
            //ASSERT(FALSE);
        }
        DbgPrint("DHCP: Can't open BINLSVC service: 0x%lx\n", Error);
    }
#endif

    CloseServiceHandle(hService);
    CloseServiceHandle(hScManager);
    
    return (NULL != hService);
}

VOID
WINAPI
DhcpDsClearHostServerEntries(
    VOID
)
/*++

Routine Description:
    This routine clears off any entries in DS for the current host assuming
    it has permissions to do so..

--*/
{
    ULONG Error;
    struct hostent *HostEnt;
    int i, j;
    WSADATA wsadata;
    LPDHCP_SERVER_INFO_ARRAY Servers = NULL;

    if( BinlServiceInstalled() ) {
        //
        // Do not do anything if BINL is installed
        //
        return ;
    }
    
    Error = WSAStartup( 0x0101, &wsadata);
    if( ERROR_SUCCESS != Error ) {
        return;
    }

    do {
        HostEnt = gethostbyname( NULL );
        if( NULL == HostEnt ) break;

        //
        // Now try to start the DS module..
        //
        Error = DhcpDsInit();
        if( ERROR_SUCCESS != Error ) break;

        do {
            Error = DhcpEnumServers(
                0,
                NULL,
                &Servers,
                0,
                0
                );

            if( ERROR_SUCCESS != Error ) break;

            i = 0;
            if( !Servers ) break;
        
            while( HostEnt->h_addr_list[i] ) {
                ULONG Addr = *(ULONG *)(HostEnt->h_addr_list[i]);
                
                i ++;
                if( Addr == 0 || Addr == ~0 || Addr == INADDR_LOOPBACK )
                    continue;
                
                for( j = 0; j < (int)Servers->NumElements; j ++ ) {
                    if( Addr == ntohl(Servers->Servers[j].ServerAddress )) {
                        DhcpDeleteServer(
                            0,
                            NULL,
                            &Servers->Servers[j],
                            NULL,
                            NULL
                            );
                    }
                }
            }

            DhcpRpcFreeMemory( Servers );
        } while ( 0 );

        DhcpDsCleanup();
    } while ( 0 );

    WSACleanup();
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\dhcpbas.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#define     DDS_RESERVED_DWORD                    0
#define     DDS_RESERVED_PTR                      ((LPVOID)0)

//DOC The following constants are Flag values that maybe passed to different
//DOC functions.
#define     DDS_FLAGS_CREATE                      0x01

//DOC Some standard names and locations in the DS

#define     DHCP_ROOT_OBJECT_LOC                  L"CN=DhcpRoot, CN=NetServices, CN=Services"
#define     DHCP_ROOT_OBJECT_PARENT_LOC           L"CN=NetServices, CN=Services"
#define     DHCP_ROOT_OBJECT_CN_NAME              L"CN=DhcpRoot"
#define     DHCP_ROOT_OBJECT_NAME                 L"DhcpRoot"

#define     DHCP_ATTRIB_WHEN_CHANGED              L"whenChanged"

//DOC The attributes that are defined for the dhcp class follows.

#define     DHCP_ATTRIB_UNIQUE_KEY                L"dhcpUniqueKey"         // reqd,single,integer8
#define     DHCP_ATTRIB_IDENTIFICATION            L"dhcpIdentification"    // reqd,single,directorystring
#define     DHCP_ATTRIB_TYPE                      L"dhcpType"              // reqd,single,integer
#define     DHCP_ATTRIB_FLAGS                     L"dhcpFlags"             // reqd,single,integer8
#define     DHCP_ATTRIB_DESCRIPTION               L"description"           // -,mv,directorystring
#define     DHCP_ATTRIB_CLASSES                   L"dhcpClasses"           // -,mv,octetstring
#define     DHCP_ATTRIB_MASK                      L"dhcpMask"              // -,mv,printablestring
#define     DHCP_ATTRIB_OBJ_DESCRIPTION           L"dhcpObjDescription"    // -,single,directorystring
#define     DHCP_ATTRIB_OBJ_NAME                  L"dhcpObjName"           // -,single,direcotrystring
#define     DHCP_ATTRIB_OPTIONS                   L"dhcpOptions"           // -,single,octetstring
#define     DHCP_ATTRIB_RANGES                    L"dhcpRanges"            // -,mv,printablestring
#define     DHCP_ATTRIB_RESERVATIONS              L"dhcpReservations"      // -,mv,printablestring
#define     DHCP_ATTRIB_SERVERS                   L"dhcpServers"           // -,mv,printablestring
#define     DHCP_ATTRIB_STATE                     L"dhcpState"             // -,mv,printablestring
#define     DHCP_ATTRIB_SUBNETS                   L"dhcpSubnets"           // -,mv,printablestring
#define     DHCP_ATTRIB_LOCATION_DN               L"locationDN"            // -,single,dn
#define     DHCP_ATTRIB_MSCOPEID                  L"mscopeid"              // -,single,printablestring
#define     DHCP_ATTRIB_ADDRESS                   L"networkAddress"        // -,mv,CaseIgnoreString
#define     DHCP_ATTRIB_OPTIONS_LOC               L"optionsLocation"       // -,mv,printablestring
#define     DHCP_ATTRIB_OPTION_DESCRIPTION        L"optionDescription"     // -,mv,directorystring
#define     DHCP_ATTRIB_SUPERSCOPES               L"superScopes"           // -,mv,printablestring

//DOC The following are the various types of objects recognized by the dhcp server
#define     DHCP_OBJ_TYPE_ROOT                    0                        // dhcp root object
#define     DHCP_OBJ_TYPE_SERVER                  1                        // dhcp server object
#define     DHCP_OBJ_TYPE_SUBNET                  2                        // subnet object
#define     DHCP_OBJ_TYPE_RANGE                   3                        // range object
#define     DHCP_OBJ_TYPE_RESERVATION             4                        // reservation object
#define     DHCP_OBJ_TYPE_OPTION                  5                        // options object
#define     DHCP_OBJ_TYPE_CLASS                   6                        // class object

#define     DHCP_OBJ_TYPE_ROOT_DESC               L"DHCP Root object"
#define     DHCP_OBJ_TYPE_SERVER_DESC             L"DHCP Server object"
#define     DHCP_OBJ_TYPE_SUBNET_DESC             L"Dhcp Subnet object"
#define     DHCP_OBJ_TYPE_RANGE_DESC              L"Dhcp Range object"
#define     DHCP_OBJ_TYPE_RESERVATION_DESC        L"Dhcp Reservation object"
#define     DHCP_OBJ_TYPE_OPTION_DESC             L"Dhcp Option object"
#define     DHCP_OBJ_TYPE_CLASS_DESC              L"Dhcp Class object"


//DOC The following defines are bitmasks and bits in various flags..

//DOC The flag2 portion of Ranges key is used for differntiating between exclusions and ranges
#define     RANGE_TYPE_RANGE                      0
#define     RANGE_TYPE_EXCL                       1
#define     RANGE_TYPE_MASK                       (0x1)



//DOC DhcpDsGetDhcpC gets the dhcp container in the DS.. This is usually the
//DOC container CN=Netservices,CN=Services,CN=Configuration etc..
//DOC This is used in many functions, so it is useful to have a central function..
//DOC
DWORD
DhcpDsGetDhcpC(                                   // get dhcp container
    IN      DWORD                  Reserved,      // future use
    IN OUT  LPSTORE_HANDLE         hStoreCC,      // config container handle
    OUT     LPSTORE_HANDLE         hDhcpC         // output dhcp container handle
) ;


//DOC DhcpDsGetRoot gets the dhcp root object given to the configuration container
//DOC This is usually CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration...
//DOC If Flags has the DDS_FLAGS_CREATE bit set, then the root object is created.
//DOC Return Values:
//DOC Store                        any returns returned by the Store module
//DOC ERROR_DDS_NO_DHCP_ROOT       no DhcpRoot object found
//DOC ERROR_DDS_UNEXPECTED_ERROR   the DhcpRoot's parent container not found..
DWORD
DhcpDsGetRoot(
    IN      DWORD                  Flags,         // 0 or DDS_FLAGS_CREATE
    IN OUT  LPSTORE_HANDLE         hStoreCC,      // configuration container handle
    OUT     LPSTORE_HANDLE         hStoreDhcpRoot // dhcp root object handle
) ;


//DOC DhcpDsGetLists function retrives a list of attributes and adds it the given array
//DOC allocating each element separateley, and traversing any pointers indicated by
//DOC the value of the attribute.
//DOC Note that even in case of error, the array may still contain some elements.
//DOC This is a best effort even in case of failure.
//DOC Each element of the array must be freed via MemFree, and the array itself
//DOC must be cleaned up via MemArrayCleanup.
//DOC Note that any of the PARRAY type parameters may be NULL, as they are optional.
//DOC but reading these separately is highly inefficient...
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   some entirely unexpected error
//DOC ERROR_DDS_TOO_MANY_ERRORS    multiple errors occured, and was caught
//DOC Store                        any errors returned by the store apis
DWORD
DhcpDsGetLists(                                   // get list of different objects
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to get the lists for
    IN      DWORD                  RecursionDepth,// how much nesting allowed? 0 ==> one level only
    IN OUT  PARRAY                 Servers,       // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Subnets,       // <Name,Description,IpAddress,Mask,State,Location>
    IN OUT  PARRAY                 IpAddress,     // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Mask,          // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Ranges,        // <Name,Description,IpAddress1,IpAddress2,State,Location>
    IN OUT  PARRAY                 Sites,         // dont know what this looks like now
    IN OUT  PARRAY                 Reservations,  // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 SuperScopes,   // <Name,Description,State,DWORD, Location>
    //IN    PARRAY                 SuperScopesDescription, // UNUSED
    IN OUT  PARRAY                 OptionDescription, // <options definition>
    IN OUT  PARRAY                 OptionsLocation, // <Location>
    IN OUT  PARRAY                 Options,       // xxx <Name, Description, String1=HexStream>
    IN OUT  PARRAY                 Classes        // xxx <Name, Description, String1=HexStream>
) ;


//DOC DhcpDsGetAttribs retreives all the miscellaneous attributes (whichever is requested) and
//DOC returns it as XXX_TYPE parameter.   These parameters are allocated within this function
//DOC using MemAlloc and must be freed via MemFree.  Any of the parameters maybe NULL indicating
//DOC lack of interest in that attribute.  (Note that the following parameters are NOT allocated:
//DOC they are just filled in: UniqueKey, Type, Flags, MScopeId, FoundParams)
//DOC Note that some of the parameters may not be found, but this can be checked against the
//DOC value returned in FoundParams (which is a REQUIRED parameter) using the FOUND_ARG(FoundParams,Arg#)
//DOC where the Args are numbered from 0 starting at UniqueKey..
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   some entirely unexpected error
//DOC ERROR_DDS_TOO_MANY_ERRORS    multiple errors occured, and was caught
//DOC Store                        any errors returned by the store apis
DWORD
DhcpDsGetAttribs(                                 // get list of attributes
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,
    IN OUT  DWORD                 *FoundParams,   // which of the following params was found?
    IN OUT  LARGE_INTEGER         *UniqueKey,     // fill in an unique key
    IN OUT  DWORD                 *Type,          // object type
    IN OUT  LARGE_INTEGER         *Flags,         // additional info about the object
    IN OUT  LPWSTR                *Name,          // Allocated, name of object
    IN OUT  LPWSTR                *Description,   // Allocated, something that describes this object
    IN OUT  LPWSTR                *Location,      // the reference location from which to do other stuff
    IN OUT  DWORD                 *MScopeId       // what is the scope id used?
) ;


//DOC DhcpCheckParams checks to see if the argument numbered (ArgNo) was found
//DOC as marked in the bitmap FoundParams.  Essentially used by the DhcpDsGetAttribs function only.
//DOC Return Values:
BOOL        _inline
DhcpCheckParams(                                  // check to see if requested param was returned
    IN      DWORD                  FoundParams,
    IN      DWORD                  ArgNo
)
{
    if( ArgNo > sizeof(FoundParams)*8 ) return FALSE;
    return ((FoundParams) & (1 << ArgNo) )?TRUE:FALSE;
}


//DOC DhcpDsSetLists function sets the various list of attributes to the values given.
//DOC it walks the arrays and encapsulates the arrays.
//DOC Note that in case of error, this function returns immediately.
//DOC In case of error, pl check the SetParams parameter with the CheckParams function
//DOC to determine which parameters were set... (no order guarantee is made for setting
//DOC the parameters).
//DOC Any PARRAY parameter may be omitted if it is not required to be modified.
//DOC SetParams is REQUIRED to be present.  See the discussion in DhcpDsGetAttribs for
//DOC the meaning of this parameter.
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   something bad happened
//DOC ERROR_DDS_TOO_MANY_ERRORS    too many simple errors
//DOC Store                        any errors returned by the store module
DWORD
DhcpDsSetLists(                                   // set the list of attributes after encapsulating them
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to get the lists for
    IN OUT  LPDWORD                SetParams,     // which of the following params got modified really?
    IN      PARRAY                 Servers,       // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Subnets,       // <Name,Description,IpAddress,Mask,State,Location>
    IN      PARRAY                 IpAddress,     // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Mask,          // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Ranges,        // <Name,Description,IpAddress1,IpAddress2,State,Location>
    IN      PARRAY                 Sites,         // dont know what this looks like now
    IN      PARRAY                 Reservations,  // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 SuperScopes,   // <Name,Description,State,DWORD, Location>
    //IN    PARRAY                 SuperScopesDescription, // UNUSED
    IN    PARRAY                   OptionDescription, // option definitions..
    IN      PARRAY                 OptionsLocation, // <Location>
    IN      PARRAY                 Options,       // xxx <Name, Description, String1=HexStream>
    IN      PARRAY                 ClassDescription, // <Name, Description, String, Location>
    IN      PARRAY                 Classes        // xxx <Name, Description, String1=HexStream>
) ;


//DOC DhcpDsSetAttribs sets the miscellaneous single-valued attributes.  Any of the attributes
//DOC may be omitted if not required to be set.  (In this case they must be set to NULL).
//DOC SetParams contains the information on which parameters were actually modified.
//DOC See DhcpDsGetAttribs on using this parameter.
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   something unexpected
//DOC Store                        any errors returned by the Store APIs
DWORD
DhcpDsSetAttribs(                                 // set these attributes
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to set the attributes
    IN OUT  DWORD                 *SetParams,     // which of the following params were actually modified?
    IN OUT  LARGE_INTEGER         *UniqueKey,     // fill in an unique key
    IN OUT  DWORD                 *Type,          // object type
    IN OUT  LPWSTR                *Name,          // Allocated, name of object
    IN OUT  LPWSTR                *Description,   // Allocated, something that describes this object
    IN OUT  LPWSTR                *Location,      // the reference location from which to do other stuff
    IN OUT  DWORD                 *MScopeId       // what is the scope id used?
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\hdrmacro.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: common headers for dhcp ds stuff.. used by both the core <store>
// and by the dhcp-ds implementation..
//================================================================================

#define INC_OLE2
#include    <mm/mm.h>
#include    <mm/array.h>
#include    <activeds.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <align.h>
#include    <lmcons.h>

#include    <netlib.h>
#include    <lmapibuf.h>
#include    <dsgetdc.h>
#include    <dnsapi.h>
#include    <adsi.h>

//================================================================================
//  defines and constants
//================================================================================
#define     DHCP_OBJECTS_LOCATION  L"CN=NetServices,CN=Services"
#define     DHCP_SEARCH_FILTER     L"(objectClass=dHCPClass)"
#define     DHCP_ADDRESS_ATTRIB    L"ipAddress"

// global attribute names
#define     ATTRIB_NAME            L"name"
#define     ATTRIB_DN_NAME         L"cn"
#define     ATTRIB_INSTANCE_TYPE   L"instanceType"

// dhcp only attribute names
#define     ATTRIB_IPADDR_OBSOLETE L"IPAddress"
#define     ATTRIB_DHCP_UNIQUE_KEY L"dhcpUniqueKey"
#define     ATTRIB_DHCP_TYPE       L"dhcpType"
#define     ATTRIB_DHCP_IDENTIFICATION L"dhcpIdentification"
#define     ATTRIB_DHCP_FLAGS      L"dhcpFlags"
#define     ATTRIB_OBJECT_CLASS    L"objectClass"
#define     ATTRIB_OBJECT_CATEGORY L"objectCategory"
#define     ATTRIB_DHCP_SERVERS    L"dhcpServers"
#define     ATTRIB_DHCP_OPTIONS    L"dhcpOptions"

// default attribute values
#define     DEFAULT_DHCP_CLASS_ATTRIB_VALUE       L"dHCPClass"
#define     DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE    4

//================================================================================
//  defines and constants
//================================================================================
#define     DEFAULT_LDAP_ROOTDSE   L"LDAP://ROOTDSE"
#define     LDAP_PREFIX            L"LDAP://"
#define     ROOTDSE_POSTFIX        L"/ROOTDSE"
#define     ENT_ROOT_PREFIX        L"CN=Configuration"
#define     CONNECTOR              L","
#define     LDAP_JOIN              L"="
#define     ENT_ROOT_PREFIX_LEN    16

// other stuff
#define     Investigate            Require
#define     ALIGN(X)               ((X) = ROUND_UP_COUNT((X), ALIGN_WORST))

#if 0
#define     DhcpDsDbgPrint         printf
#define     StoreTrace2            printf
#define     StoreTrace3            printf
#else
#define     DhcpDsDbgPrint         (void)
#define     StoreTrace2            (void)
#define     StoreTrace3            (void)
#endif

static      const
LPWSTR      constNamingContextString = L"configurationNamingContext";
static      const                                 // cn is NOT mandatory..what is?
LPWSTR      constCNAttrib = L"cn";                // the attribute that is unique,mandator for each object..

//================================================================================
//  interal helpers
//================================================================================
LPWSTR      _inline
DuplicateString(                                  // allocate and copy this LPWSTR value
    IN      LPWSTR                 StringIn,
    IN      BOOL                   EmptyString    // convert empty string to L"" ?
)
{
    LPWSTR                         StringOut;

    if( NULL == StringIn ) {
        if( FALSE  == EmptyString ) return NULL;
        StringIn = L"";
    }

    StringOut = MemAlloc(sizeof(WCHAR)*(1 + wcslen(StringIn)));
    if( NULL == StringOut) return NULL;
    wcscpy(StringOut, StringIn);
    return StringOut;
}

DWORD       _inline
SizeString(                                       // # of bytes to copy the string
    IN      LPWSTR                 StringIn,      // OPTIONAL
    IN      BOOL                   EmptyString    // Convert NULL to L"" ?
)
{
    if( NULL == StringIn ) {
        return EmptyString? sizeof(WCHAR) : 0;
    }

    return sizeof(WCHAR)*(1+wcslen(StringIn));
}

LPWSTR      _inline
MakeColumnName(
    IN      LPWSTR                 RawColumnName
)
{
    LPWSTR                         RetVal;

    RetVal = MemAlloc(SizeString(constCNAttrib,FALSE) + sizeof(LDAP_JOIN) + sizeof(WCHAR)*wcslen(RawColumnName));
    if( NULL == RetVal ) return RetVal;

    wcscpy(RetVal, constCNAttrib);
    wcscat(RetVal, LDAP_JOIN);
    wcscat(RetVal, RawColumnName);

    return RetVal;
}

LPWSTR      _inline
MakeSubnetLocation(                               // make a DN name out of servername. address
    IN      LPWSTR                 ServerName,    // name of server
    IN      DWORD                  IpAddress      // subnet address
)
{
    DWORD                          Size;
    LPWSTR                         RetVal;
    LPSTR                          AddrString;

    Size = SizeString(constCNAttrib,FALSE) + sizeof(LDAP_JOIN) + sizeof(WCHAR)*wcslen(ServerName);
    Size += sizeof(WCHAR) + sizeof(L"000.000.000.000");

    RetVal = MemAlloc(Size);
    if( NULL == RetVal ) return NULL;             // not enough memory

    wcscpy(RetVal, constCNAttrib);
    wcscat(RetVal, LDAP_JOIN);
    wcscat(RetVal, ServerName);
    wcscat(RetVal, L"!" );

    IpAddress = htonl(IpAddress);                 // convert to network order before writing...
    AddrString = inet_ntoa(*(struct in_addr *)&IpAddress);
    mbstowcs(&RetVal[wcslen(RetVal)], AddrString, 1+strlen(AddrString));

    return RetVal;
}

LPWSTR      _inline
MakeReservationLocation(                          // make a DN name out of server name. address
    IN      LPWSTR                 ServerName,    // name of server
    IN      DWORD                  IpAddress      // subnet address
)
{
    return MakeSubnetLocation(ServerName, IpAddress);
}


DWORD       _inline
ConvertHresult(                                   // try to convert HRESULT to Win32 errors
    IN      HRESULT                HResult
)
{
    if( 0 == (((ULONG)(HRESULT_FACILITY(HResult))) & ~0xF )) {
        return HRESULT_CODE(HResult);             // known result
    }

    return HResult ;                              // unknown facility
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\delete.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This module has helper routines to delete the objects recursively.
//
//================================================================================

#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpapi.h>

//================================================================================
//  helper functions
//================================================================================
VOID        static
MemFreeFunc(
    IN OUT  LPVOID                 Memory
)
{
    MemFree(Memory);
}

//================================================================================
//  exposed functions
//================================================================================

//BeginExport(function)
//DOC  SubnetDeleteReservation deletes the reservation object from off the DS.
SubnetDeleteReservation(                          // delete reservation from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for resrevation objs
    IN      LPWSTR                 ServerName,    // name of dhcp server
    IN OUT  LPSTORE_HANDLE         hServer,       // server object in DS
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object in DS
    IN      LPWSTR                 ADsPath,       // path of reservation object
    IN      DWORD                  StoreGetType   // path is relative, abs, or dif server?
)   //EndExport(function)
{
    return StoreDeleteThisObject                  // just delete the reservation object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath
    );
}

//BeginExport(function)
//DOC  ServerDeleteSubnet deletes the subnet specified from the DS by removing
//DOC  the subnet object.
ServerDeleteSubnet(                               // remove subnet object from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for subnet objs in Ds
    IN      LPWSTR                 ServerName,    // name of server this deletion is for
    IN OUT  LPSTORE_HANDLE         hServer,       // server object in DS
    IN      LPWSTR                 ADsPath,       // Location of the subnet in DS
    IN      DWORD                  StoreGetType   // path is relative,abs or diff srvr?
)   //EndExport(function)
{
    DWORD                          Err, LastErr, LocType;
    STORE_HANDLE                   hSubnet;
    ARRAY                          Reservations;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPWSTR                         Location;
    LPVOID                         Ptr;

    Err = StoreGetHandle                          // get the server object from the DS
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath,
        /* hStoreOut            */ &hSubnet
    );
    if( ERROR_SUCCESS != Err ) return Err;

    Err = MemArrayInit(&Reservations);            //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list or reservations
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ &hSubnet,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ &Reservations,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    LastErr = ERROR_SUCCESS;
    for(                                          // delete each subnet
        Err = MemArrayInitLoc(&Reservations, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err;
        Err = MemArrayNextLoc(&Reservations, &Loc)
    ) {
        Err = MemArrayGetElement(&Reservations, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // reserved address
            !IS_BINARY1_PRESENT(ThisAttrib) ) {   // HW address info
            continue;                             // invalid subnet
        }

        if( !IS_ADSPATH_PRESENT(ThisAttrib) ) {   // no location specified
            Location = MakeReservationLocation(ServerName, ThisAttrib->Address1);
            LocType = StoreGetChildType;
            Ptr = Location;
        } else {
            Location = ThisAttrib->ADsPath;
            LocType = ThisAttrib->StoreGetType;
            Ptr = NULL;
        }

        Err = SubnetDeleteReservation             // now delete the reservation
        (
            /* hDhcpC           */ hDhcpC,
            /* ServerName       */ ServerName,
            /* hServer          */ hServer,
            /* hSubnet          */ &hSubnet,
            /* ADsPath          */ Location,
            /* StoreGetType     */ LocType
        );
        if( ERROR_SUCCESS != Err ) LastErr = Err;
        if( Ptr ) MemFree(Ptr);
    }

    MemArrayFree(&Reservations, MemFreeFunc);

    Err = StoreCleanupHandle(&hSubnet, 0);        //= require ERROR_SUCCESS == Err
    Err = StoreDeleteThisObject                   // now really delete the subnet object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath
    );
    if( ERROR_SUCCESS != Err ) LastErr = Err;     // try to delete the store object itself

    return LastErr;
}

//BeginExport(function)
//DOC  DeleteServer deletes the server object from the DS and deletes any SUBNET and
//DOC  reservation objects that it may point to.
//DOC  The hDhcpC parameter is the handle of the container where the server object
//DOC  may be located. This used in conjunction with the ADsPath and StoreGetType
//DOC  defines the location of the ServerObject.
DWORD
DeleteServer(                                     // recurse delete server from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where server obj may be
    IN      LPWSTR                 ServerName,    // name of server..
    IN      LPWSTR                 ADsPath,       // path of the server object
    IN      DWORD                  StoreGetType   // is path relative, absolute or dif srvr?
)   //EndExport(function)
{
    DWORD                          Err, LastErr, LocType;
    STORE_HANDLE                   hServer;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPWSTR                         Location;
    LPVOID                         Ptr;

    Err = StoreGetHandle                          // get the server object from the DS
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath,
        /* hStoreOut            */ &hServer
    );
    if( ERROR_SUCCESS != Err ) return Err;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get subnets and other stuff
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ &hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    LastErr = ERROR_SUCCESS;
    for(                                          // delete each subnet
        Err = MemArrayInitLoc(&Subnets, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err;
        Err = MemArrayNextLoc(&Subnets, &Loc)
    ) {
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // subnet mask
            continue;                             // invalid subnet
        }

        if( !IS_ADSPATH_PRESENT(ThisAttrib) ) {   // no location specified
            Location = MakeSubnetLocation(ServerName, ThisAttrib->Address1);
            LocType = StoreGetChildType;
            Ptr = Location;
        } else {
            Location = ThisAttrib->ADsPath;
            LocType = ThisAttrib->StoreGetType;
            Ptr = NULL;
        }

        Err = ServerDeleteSubnet                  // now delete the subnet
        (
            /* hDhcpC           */ hDhcpC,
            /* ServerName       */ ServerName,
            /* hServer          */ &hServer,
            /* ADsPath          */ Location,
            /* StoreGetType     */ LocType
        );
        if( ERROR_SUCCESS != Err ) LastErr = Err;
        if( Ptr ) MemFree(Ptr);
    }

    MemArrayFree(&Subnets, MemFreeFunc);

    Err = StoreCleanupHandle( &hServer, DDS_RESERVED_DWORD );
    Err = StoreDeleteThisObject                   // now really delete the server object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath
    );
    if( ERROR_SUCCESS != Err ) LastErr = Err;     // try to delete the store object itself

    return LastErr;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\rpcapi2.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: most of the rpc apis are here and some miscellaneous functions too
//  all the functions here go to the DS directly.
//================================================================================

#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpapi.h>
#include    <delete.h>
#include    <st_srvr.h>
#include    <upndown.h>
#include    <dnsapi.h>


//================================================================================
// helper functions
//================================================================================

#include <rpcapi2.h>

//
// Allow Debug prints to ntsd or kd
//

//  #ifdef DBG
//  #define DsAuthPrint(_x_) DsAuthDebugPrintRoutine _x_

//  #else
//  #define DebugPrint(_x_)
//  #endif


extern LPWSTR
CloneString( IN LPWSTR String );

typedef enum {
    LDAP_OPERATOR_EQUAL_TO,
    LDAP_OPERATOR_APPROX_EQUAL_TO,
    LDAP_OPERATOR_LESS_OR_EQUAL_TO,
    LDAP_OPERATOR_GREATER_OR_EQUAL_TO,
    LDAP_OPERATOR_AND,
    LDAP_OPERATOR_OR,
    LDAP_OPERATOR_NOT,
    
    LDAP_OPERATOR_TOTAL
} LDAP_OPERATOR_ENUM;

LPWSTR LdapOperators[ LDAP_OPERATOR_TOTAL ] =
    { L"=", L"~=", L"<=", L">=", L"&", L"|", L"!" };


VOID DsAuthPrintRoutine(
    LPWSTR Format,
    ...
)
{
    WCHAR   buf[2 * 256];
    va_list arg;
    DWORD   len;

    va_start( arg, Format );
    len = wsprintf(buf, L"DSAUTH: ");
    wvsprintf( &buf[ len ], Format, arg );

    va_end( arg );

    OutputDebugString( buf );
} // DsAuthPrint()

//
// This function creates an LDAP query filter string
// with the option type, value and operator.
// 
// Syntax: 
//   primitive : <filter>=(<attribute><operator><value>)
//   complex   : (<operator><filter1><filter2>)
//

LPWSTR
MakeLdapFilter(
    IN   LPWSTR             Operand1,
    IN   LDAP_OPERATOR_ENUM Operator,
    IN   LPWSTR             Operand2,
    IN   BOOL               Primitive
)
{
    LPWSTR Result;
    DWORD  Size;
    DWORD  Len;
    
    Result = NULL;

    AssertRet((( NULL != Operand1 ) && 
	       ( NULL != Operand2 ) &&
	       (( Operator >= 0 ) && ( Operator < LDAP_OPERATOR_TOTAL ))),
	       NULL );
    
    // calculate the amount of memory needed
    Size = 0;
    Size += ROUND_UP_COUNT( sizeof( L"(" ), ALIGN_WORST );
    Size += ROUND_UP_COUNT( sizeof( L")" ), ALIGN_WORST );
    Size += ROUND_UP_COUNT( wcslen( Operand1 ), ALIGN_WORST );
    Size += ROUND_UP_COUNT( wcslen( Operand2 ), ALIGN_WORST );
    Size += ROUND_UP_COUNT( wcslen( LdapOperators[ Operator ] ), ALIGN_WORST );
    Size += 16; // padding

    Result = MemAlloc( Size * sizeof( WCHAR ));
    if ( NULL == Result ) {
	return NULL;
    }

    if ( Primitive ) {
	Len = wsprintf( Result, 
			L"(%ws%ws%ws)",
			Operand1, LdapOperators[ Operator ], Operand2
			);
    }
    else {
	Len = wsprintf( Result,
			L"(%ws%ws%ws)",
			LdapOperators[ Operator ], Operand1, Operand2
			);
	
    } // else

    AssertRet( Len <= Size, NULL );
    
    return Result;
} // MakeLdapFilter()

//
// Make a LDAP query filter like this:
// (&(objectCategory=dHCPClass)(<operator>(dhcpServer="i<ip>$*")(dhcpServer="*s<hostname>*")))
// 

LPWSTR
MakeFilter(
   LPWSTR LookupServerIP,   // Printable IP addr
   LPWSTR HostName,
   LDAP_OPERATOR_ENUM Operator
)
{
    LPWSTR Filter1, Filter2, Filter3, Filter4, SearchFilter;
    LPWSTR Buf;
    DWORD Len, CopiedLen;

    AssertRet((( NULL != LookupServerIP ) &&
	       ( NULL != HostName )), NULL );

    Filter1 = NULL;
    Filter2 = NULL;
    Filter3 = NULL;
    Filter4 = NULL;
    SearchFilter = NULL;

    do {

	// Make large enough buffer 
	Len = wcslen( HostName ) + wcslen( LookupServerIP ) + 10;
	Buf = MemAlloc( Len * sizeof( WCHAR ));
	if ( NULL == Buf ) {
	    break;
	}

	// make (objectCategory=dHCPClass)
	Filter1 = MakeLdapFilter( ATTRIB_OBJECT_CATEGORY,
				  LDAP_OPERATOR_EQUAL_TO,
				  DEFAULT_DHCP_CLASS_ATTRIB_VALUE,
				  TRUE );

	if ( NULL == Filter1 ) {
	    break;
	}

	// The IP needs to be sent as i<ip>* to match the query
	
	// make (dhcpServers="i<ip>$*")
	CopiedLen = _snwprintf( Buf, Len - 1, L"i%ws$*", LookupServerIP );
	Require( CopiedLen > 0 );
	Filter2 = MakeLdapFilter( DHCP_ATTRIB_SERVERS,
				  LDAP_OPERATOR_EQUAL_TO, Buf, TRUE );
	if ( NULL == Filter2 ) {
	    break;
	}

	// make (dhcpServers="*s<hostname>$*")
	CopiedLen = _snwprintf( Buf, Len - 1, L"*s%ws$*", HostName );
	Require( CopiedLen > 0 );
	Filter3 = MakeLdapFilter( DHCP_ATTRIB_SERVERS, 
				  LDAP_OPERATOR_EQUAL_TO, Buf, TRUE );
	
	if ( NULL == Filter3 ) {
	    break;
	}

	// make (<operator>(<ipfilter>)(<hostfilter))
	Filter4 = MakeLdapFilter( Filter2, Operator,
				  Filter3, FALSE );

	if ( NULL == Filter4 ) {
	    break;
	}

	// Finally make the filter to be returned
	SearchFilter = MakeLdapFilter( Filter1, LDAP_OPERATOR_AND,
				       Filter4, FALSE );

    } while ( FALSE );
    
    if ( NULL != Buf ) {
	MemFree( Buf );
    }
    if ( NULL != Filter1 ) {
	MemFree( Filter1 );
    }
    if ( NULL != Filter2 ) {
	MemFree( Filter2 );
    }
    if ( NULL != Filter3 ) {
	MemFree( Filter3 );
    }
    if ( NULL != Filter4 ) {
	MemFree( Filter4 );
    }
    
    return SearchFilter;
} // MakeFilter()

//================================================================================
//  This function computes the unique identifier for a client; this is just
//  client subnet + client hw address type + client hw address. note that client
//  hardware address type is hardcoded as HARDWARE_TYPE_10MB_EITHERNET as there
//  is no way in the ui to specify type of reservations..
//  Also, DhcpValidateClient (cltapi.c?) uses the subnet address for validation.
//  Dont remove that.
//================================================================================
DWORD
DhcpMakeClientUID(                 // compute unique identifier for the client
    IN      LPBYTE                 ClientHardwareAddress,
    IN      DWORD                  ClientHardwareAddressLength,
    IN      BYTE                   ClientHardwareAddressType,
    IN      DHCP_IP_ADDRESS        ClientSubnetAddress,
    OUT     LPBYTE                *ClientUID,          // will be allocated by function
    OUT     DWORD                 *ClientUIDLength
)
{
    LPBYTE                         Buffer;
    LPBYTE                         ClientUIDBuffer;
    BYTE                           ClientUIDBufferLength;

    if( NULL == ClientUID || NULL == ClientUIDLength || 0 == ClientHardwareAddressLength )
        return ERROR_INVALID_PARAMETER;

    // see comment about on hardcoded hardware address type
    ClientHardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;

    ClientUIDBufferLength  =  sizeof(ClientSubnetAddress);
    ClientUIDBufferLength +=  sizeof(ClientHardwareAddressType);
    ClientUIDBufferLength +=  (BYTE)ClientHardwareAddressLength;

    ClientUIDBuffer = MemAlloc( ClientUIDBufferLength );

    if( ClientUIDBuffer == NULL ) {
        *ClientUIDLength = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Buffer = ClientUIDBuffer;
    RtlCopyMemory(Buffer,&ClientSubnetAddress,sizeof(ClientSubnetAddress));

    Buffer += sizeof(ClientSubnetAddress);
    RtlCopyMemory(Buffer,&ClientHardwareAddressType,sizeof(ClientHardwareAddressType) );

    Buffer += sizeof(ClientHardwareAddressType);
    RtlCopyMemory(Buffer,ClientHardwareAddress,ClientHardwareAddressLength );

    *ClientUID = ClientUIDBuffer;
    *ClientUIDLength = ClientUIDBufferLength;

    return ERROR_SUCCESS;
}

VOID        static
MemFreeFunc(                                      // free memory
    IN OUT  LPVOID                 Memory
)
{
    MemFree(Memory);
}

//DOC CreateServerObject creates the server object in the DS. It takes the
//DOC ServerName parameter and names the object using this.
//DOC The server is created with default values for most attribs.
//DOC Several attribs are just not set.
//DOC This returns ERROR_DDS_UNEXPECTED_ERROR if any DS operation fails.
DWORD
CreateServerObject(                               // create dhcp srvr obj in ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container to creat obj in
    IN      LPWSTR                 ServerName     // [DNS?] name of server
)
{
    DWORD                          Err;
    LPWSTR                         ServerCNName;  // container name

    ServerCNName = MakeColumnName(ServerName);    // convert from "name" to "CN=name"
    if( NULL == ServerCNName ) return ERROR_NOT_ENOUGH_MEMORY;

    Err = StoreCreateObject                       // now create the object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* NewObjName           */ ServerCNName,
        /* ...                  */
        /* Identification       */
        ADSTYPE_DN_STRING,         ATTRIB_DN_NAME,          ServerName,
        ADSTYPE_DN_STRING,         ATTRIB_OBJECT_CLASS,     DEFAULT_DHCP_CLASS_ATTRIB_VALUE,

        /* systemMustContain    */
        ADSTYPE_INTEGER,           ATTRIB_DHCP_UNIQUE_KEY,  0,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_TYPE,        DHCP_OBJ_TYPE_SERVER,
        ADSTYPE_DN_STRING,         ATTRIB_DHCP_IDENTIFICATION, DHCP_OBJ_TYPE_SERVER_DESC,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_FLAGS,       0,
        ADSTYPE_INTEGER,           ATTRIB_INSTANCE_TYPE,    DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE,

        /* terminator           */
        ADSTYPE_INVALID
    );
    if( ERROR_ALREADY_EXISTS == Err ) {           // if object exists, ignore this..
        Err = ERROR_SUCCESS;
    }

    MemFree(ServerCNName);
    return Err;
}

BOOL
ServerMatched(
    IN PEATTRIB ThisAttrib,
    IN LPWSTR ServerName,
    IN ULONG IpAddress,
    OUT BOOL *fExactMatch
    )
{
    BOOL fIpMatch, fNameMatch, fWildcardIp;
    
    (*fExactMatch) = FALSE;

    fIpMatch = (ThisAttrib->Address1 == IpAddress);
    if( INADDR_BROADCAST == ThisAttrib->Address1 ||
        INADDR_BROADCAST == IpAddress ) {
        fWildcardIp = TRUE;
    } else {
        fWildcardIp = FALSE;
    }
    
    if( FALSE == fIpMatch ) {
        //
        // If IP Addresses don't match, then check to see if
        // one of the IP addresses is a broadcast address..
        //
        if( !fWildcardIp ) return FALSE;
    }

    fNameMatch = DnsNameCompare_W(ThisAttrib->String1, ServerName);
    if( FALSE == fNameMatch ) {
        //
        // If names don't match _and_ IP's don't match, no match.
        //
        if( FALSE == fIpMatch || fWildcardIp ) return FALSE;
    } else {
        if( FALSE == fIpMatch ) return TRUE;
        
        (*fExactMatch) = TRUE;
    }
    return TRUE;
}

DWORD
GetListOfAllServersMatchingFilter(
    IN OUT LPSTORE_HANDLE hDhcpC,
    IN OUT PARRAY Servers,
    IN     LPWSTR SearchFilter  OPTIONAL
)
{
    DWORD Err, LastErr;
    STORE_HANDLE hContainer;
    LPWSTR Filter;

    AssertRet( ( NULL != hDhcpC ) && ( NULL != Servers ),
	       ERROR_INVALID_PARAMETER );

    Err = StoreSetSearchOneLevel(
        hDhcpC, DDS_RESERVED_DWORD );
    AssertRet( Err == NO_ERROR, Err );

    if ( NULL == SearchFilter ) {
	Filter = DHCP_SEARCH_FILTER;
    }
    else {
	Filter = SearchFilter;
    }
    AssertRet( NULL != Filter, ERROR_INVALID_PARAMETER );

    Err = StoreBeginSearch(
        hDhcpC, DDS_RESERVED_DWORD, Filter );
    AssertRet( Err == NO_ERROR, Err );

    while( TRUE ) {
        Err = StoreSearchGetNext(
            hDhcpC, DDS_RESERVED_DWORD, &hContainer );

        if( ERROR_DS_INVALID_DN_SYNTAX == Err ) {
            //
            // This nasty problem is because of an upgrade issue
            // in DS where some bad-named objects may exist..
            //
            Err = NO_ERROR;
            continue;
        }

        if( NO_ERROR != Err ) break;
        
        Err = DhcpDsGetLists
        (
            /* Reserved             */ DDS_RESERVED_DWORD,
            /* hStore               */ &hContainer,
            /* RecursionDepth       */ 0xFFFFFFFF,
            /* Servers              */ Servers,      // array of PEATTRIB 's
            /* Subnets              */ NULL,
            /* IpAddress            */ NULL,
            /* Mask                 */ NULL,
            /* Ranges               */ NULL,
            /* Sites                */ NULL,
            /* Reservations         */ NULL,
            /* SuperScopes          */ NULL,
            /* OptionDescription    */ NULL,
            /* OptionsLocation      */ NULL,
            /* Options              */ NULL,
            /* Classes              */ NULL
        );

        StoreCleanupHandle( &hContainer, DDS_RESERVED_DWORD );

        if( NO_ERROR != Err ) break;

    }

    if( Err == ERROR_NO_MORE_ITEMS ) Err = NO_ERROR;
    
    LastErr = StoreEndSearch( hDhcpC, DDS_RESERVED_DWORD );
    //Require( LastErr == NO_ERROR );

    return Err;
} // GetListOfAllServersMatchingFilter()

DWORD
DhcpDsAddServerInternal(                          // add a server in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ServerLocation,// Container where this will go in
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ReservedPtr,   // Server location? future use
    IN      DWORD                  IpAddress,     // ip address of server
    IN      DWORD                  State          // currently un-interpreted
)
{
    DWORD                          Err, Err2, unused;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;

    if ( NULL == ServerLocation ) {
	return ERROR_INVALID_PARAMETER;
    }

    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Servers);                 // cant fail
    //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of servers for this object
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hDhcpRoot,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ &Servers,      // array of PEATTRIB 's
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

#ifdef DBG
    for(                                          // search list of servers
        Err = MemArrayInitLoc(&Servers, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Servers, &Loc)     // skip to next element
        ) {
        BOOL fExactMatch = FALSE;
        
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //=  ds inconsistent
        }

        if( ServerMatched(ThisAttrib, ServerName, IpAddress, &fExactMatch ) ) {
            //
            // Server found in the list of servers.  Exact match not allowed.
            //

	    Require( fExactMatch == FALSE );
        }            
    } // for

#endif

    NothingPresent(&DummyAttrib);                 // fill in attrib w/ srvr info
    STRING1_PRESENT(&DummyAttrib);                // name
    ADDRESS1_PRESENT(&DummyAttrib);               // ip addr
    FLAGS1_PRESENT(&DummyAttrib);                 // state
    DummyAttrib.String1 = ServerName;
    DummyAttrib.Address1 = IpAddress;
    DummyAttrib.Flags1 = State;
    if( ServerLocation ) {
        ADSPATH_PRESENT(&DummyAttrib);            // ADsPath of location of server object
        STOREGETTYPE_PRESENT(&DummyAttrib);
        DummyAttrib.ADsPath = ServerLocation;
        DummyAttrib.StoreGetType = StoreGetChildType;
    }

    Err = MemArrayAddElement(&Servers, &DummyAttrib);
    if( ERROR_SUCCESS != Err ) {                  // could not add this to attrib array
        MemArrayFree(&Servers, MemFreeFunc);      // free allocated memory
        return Err;
    }

    Err = DhcpDsSetLists                          // now set the new attrib list
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hDhcpRoot,
        /* SetParams            */ &unused,
        /* Servers              */ &Servers,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription..  */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescription     */ NULL,
        /* Classes              */ NULL
    );

    Err2 = MemArrayLastLoc(&Servers, &Loc);       // theres atleast 1 elt in array
    //= require ERROR_SUCCESS == Err2
    Err2 = MemArrayDelElement(&Servers, &Loc, &ThisAttrib);
    //= require ERROR_SUCCESS == Err2 && ThisAttrib == &DummyAttrib
    MemArrayFree(&Servers, MemFreeFunc);          // free allocated memory
    
    return Err;
} // DhcpDsAddServerInternal()

//================================================================================
//  exported functions
//================================================================================

//BeginExport(function)
//DOC DhcpDsAddServer adds a server's entry in the DS.  Note that only the name
//DOC uniquely determines the server. There can be one server with many ip addresses.
//DOC If the server is created first time, a separate object is created for the
//DOC server. : TO DO: The newly added server should also have its data
//DOC updated in the DS uploaded from the server itself if it is still up.
//DOC Note that it takes as parameter the Dhcp root container.
//DOC If the requested address already exists in the DS (maybe to some other
//DOC server), then the function returns ERROR_DDS_SERVER_ALREADY_EXISTS
DWORD
DhcpDsAddServer(                                  // add a server in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ReservedPtr,   // Server location? future use
    IN      DWORD                  IpAddress,     // ip address of server
    IN      DWORD                  State          // currently un-interpreted
)   //EndExport(function)
{
    DWORD                          Err;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    LPWSTR                         ServerLocation;
    DWORD                          ServerLocType;
    STORE_HANDLE                   hDhcpServer;
    LPWSTR                         SearchFilter;
    WCHAR                          PrintableIp[ 20 ];
    LPWSTR SName;

    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    ServerLocation = NULL;

    do {
	Err = MemArrayInit( &Servers );                 // cant fail
	//= require ERROR_SUCCESS == Err
	
	DsAuthPrint(( L"DhcpAddServer() \n" ));
	
	// Make a printable IP
	ConvertAddressToLPWSTR( IpAddress, PrintableIp );

	DsAuthPrint(( L"DhcpAddServer() : PrintableIp = %ws\n", PrintableIp ));
	
	SearchFilter = MakeFilter( PrintableIp, ServerName, LDAP_OPERATOR_AND );
	if ( NULL == SearchFilter ) {
	    Err = ERROR_INVALID_PARAMETER; // get a better error code
	    break;
	}
	
	DsAuthPrint(( L"DhcpDsAddServer() : Filter = %ws\n", SearchFilter ));

	Err = GetListOfAllServersMatchingFilter( hDhcpC, &Servers,
						 SearchFilter );
	MemFree( SearchFilter );
	if( ERROR_SUCCESS != Err ) {
	    break;
	}
	
	// There should only be one entry matching <hostname> and <ip> 
	// if the entry already exists

	Require( MemArraySize( &Servers ) <= 1);

	if ( MemArraySize( &Servers ) > 0 ) {
	    Err = ERROR_DDS_SERVER_ALREADY_EXISTS;
	    break;
	}
	
	// Use the printable IP for the CN name
	Err = CreateServerObject(
				 /*  hDhcpC          */ hDhcpC,
				 /*  ServerName      */ PrintableIp
							);
	if( ERROR_SUCCESS != Err ) {              // dont add server if obj cant be created
	    break;
	}
	ServerLocation = MakeColumnName( PrintableIp );
	ServerLocType = StoreGetChildType;
	
	Err = StoreGetHandle( hDhcpC, 0, ServerLocType, ServerLocation, &hDhcpServer );
	if( NO_ERROR == Err ) {
	    Err = DhcpDsAddServerInternal( hDhcpC, &hDhcpServer, Reserved, ServerLocation,
					   ServerName, ReservedPtr,
					   IpAddress, State );
	    StoreCleanupHandle( &hDhcpServer, 0 );
	}
	
    } while ( FALSE );

    // clean up the allocated memory
    MemArrayFree(&Servers, MemFreeFunc);
    MemArrayCleanup( &Servers );
    
    if( NULL != ServerLocation ) {
	MemFree( ServerLocation );
    }

    DsAuthPrint(( L"DhcpDsAddServer() done\n" ));
    return Err;
} // DhcpDsAddServer()

DWORD
DhcpDsDelServerInternal(                                  // Delete a server from memory
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 ServerLocation,// Container where this will go in
    IN      LPWSTR                 ServerName,    // which server to delete for
    IN      LPWSTR                 ReservedPtr,   // server location ? future use
    IN      DWORD                  IpAddress      // the IpAddress to delete..
)
{
    DWORD                          Err, Err2, unused;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    BOOL                           fServerExists;
    BOOL                           fServerDeleted;

    if ( NULL == ServerLocation ) {
	return ERROR_INVALID_PARAMETER;
    }
        
    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Servers);                 // cant fail
    //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of servers for this object
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hDhcpRoot,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ &Servers,      // array of PEATTRIB 's
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    fServerDeleted = FALSE;
    for(                                          // search list of servers
        Err = MemArrayInitLoc( &Servers, &Loc )   // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc( &Servers, &Loc )   // skip to next element
    ) {
        BOOL fExactMatch = FALSE;
            
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement( &Servers, &Loc, &ThisAttrib );
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT( ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT( ThisAttrib) ) {  // no address for this server
            continue;                              //=  ds inconsistent
        }

        if( ServerMatched( ThisAttrib, ServerName, IpAddress, &fExactMatch )) {
            //
            // Server found. If exact match, remove the element from list.
            //
            if( fExactMatch ) { 
                Err2 = MemArrayDelElement( &Servers, &Loc, &ThisAttrib );
		fServerDeleted = TRUE;
		break;
            }
        } // if
    } // for

    Require( fServerDeleted == TRUE );

    if ( MemArraySize( &Servers ) > 0 ) {
	// now set the new attrib list
	Err = DhcpDsSetLists( DDS_RESERVED_DWORD, hDhcpRoot, &unused, &Servers,
			      NULL, NULL, NULL, NULL, NULL, NULL,
			      NULL, NULL, NULL, NULL, NULL, NULL );
	MemArrayFree(&Servers, MemFreeFunc);
    } // if
    else {
	// this empty object needs to be deleted from the DS 
	
	Err = StoreDeleteThisObject( hDhcpC, DDS_RESERVED_DWORD,
				     StoreGetChildType,
				     ServerLocation );
    } // else

    return Err;
} // DhcpDsDelServerInternal()

//BeginExport(function)
//DOC DhcpDsDelServer removes the requested servername-ipaddress pair from the ds.
//DOC If this is the last ip address for the given servername, then the server
//DOC is also removed from memory.  But objects referred by the Server are left in
//DOC the DS as they may also be referred to from else where.  This needs to be
//DOC fixed via references being tagged as direct and symbolic -- one causing deletion
//DOC and other not causing any deletion.  THIS NEEDS TO BE FIXED. 
DWORD
DhcpDsDelServer(                                  // Delete a server from memory
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 ServerName,    // which server to delete for
    IN      LPWSTR                 ReservedPtr,   // server location ? future use
    IN      DWORD                  IpAddress      // the IpAddress to delete..
) //EndExport(function)
{
    DWORD            Err, Loc;
    ARRAY            Servers;
    PEATTRIB         ThisAttrib;
    WCHAR            PrintableIp[ 20 ];
    LPWSTR           SearchFilter;
    STORE_HANDLE     hObj;

    do {

	Err = MemArrayInit( &Servers );
	DsAuthPrint(( L"DhcpDelServer() \n" ));

	ConvertAddressToLPWSTR( IpAddress, PrintableIp );

	SearchFilter = MakeFilter( PrintableIp, ServerName, LDAP_OPERATOR_AND );
	if ( NULL == SearchFilter ) {
	    Err = ERROR_INVALID_PARAMETER;  // get a better error code
	    break;
	} 

	DsAuthPrint(( L"DhcpDsDelServer() : Filter = %ws\n", SearchFilter ));

	Err = GetListOfAllServersMatchingFilter( hDhcpC, &Servers,
						 SearchFilter );
	MemFree( SearchFilter );
    

	// GetListOfAllServersMatchingFilter() returns the dhcp servers
	// defined the in all the maching objects, so it also returns false
	// objects. 

	// Since we are using '&' operator for ip and host name, it will return
	// a single object. However, that object may contain more than one entries
	// in dhcpServers attribute. 

	if ( MemArraySize( &Servers ) == 0 ) {
	    Err = ERROR_DDS_SERVER_DOES_NOT_EXIST;
	    break;
	}

	// get the object CN. This is okay since it returns only one object.
	Err = MemArrayInitLoc( &Servers, &Loc );
	Err = MemArrayGetElement( &Servers, &Loc, &ThisAttrib );

	Require( NULL != ThisAttrib );
	Require( NULL != ThisAttrib->ADsPath );

	// get a handle to the object that contains the server to be deleted
	Err = StoreGetHandle( hDhcpC, DDS_RESERVED_DWORD,
			      StoreGetChildType, ThisAttrib->ADsPath,
			      &hObj );
	if ( ERROR_SUCCESS != Err ) {
	    break;
	}

	// ADsPath is cn=xxxx, get rid of 'cn='
	Err = DhcpDsDelServerInternal( hDhcpC, &hObj, Reserved, 
				       ThisAttrib->ADsPath, ServerName,
				       ReservedPtr, IpAddress );

	// Ignore the error
	(void ) StoreCleanupHandle( &hObj, 0 );

    } while ( FALSE );

    // Free allocated memory

    MemArrayFree( &Servers, MemFreeFunc );

    DsAuthPrint(( L"DhcpDsDelServer() exiting...\n" ));
    return Err;
} // DhcpDsDelServer()

//BeginExport(function)
BOOL
DhcpDsLookupServer(                               // get info about a server
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 LookupServerIP,// Server to lookup IP
    IN      LPWSTR                 HostName      // Hostname to lookup
) //EndExport(function)
{
    DWORD                          Err, Err2, Size, Size2, i, N;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPDHCPDS_SERVERS               LocalServers;
    LPBYTE                         Ptr;
    LPWSTR                         SearchFilter;
    STORE_HANDLE                   hContainer;

    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return FALSE;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return FALSE;

    if (( NULL == HostName ) ||
	( NULL == LookupServerIP )) {
	return FALSE;
    }

    SearchFilter = MakeFilter( LookupServerIP, HostName, LDAP_OPERATOR_OR );
    if ( NULL == SearchFilter ) {
	return FALSE;
    }

    DsAuthPrint(( L"hostname = %ws, IP = %ws, Filter = %ws\n",
		  HostName, LookupServerIP, SearchFilter ));

    Err = StoreSetSearchOneLevel( hDhcpC, DDS_RESERVED_DWORD );
    AssertRet( Err == NO_ERROR, Err );

    Err = StoreBeginSearch( hDhcpC, DDS_RESERVED_DWORD, SearchFilter );
    MemFree( SearchFilter );
    AssertRet( Err == NO_ERROR, Err );

    Err = StoreSearchGetNext( hDhcpC, DDS_RESERVED_DWORD, &hContainer );

    StoreEndSearch( hDhcpC, DDS_RESERVED_DWORD );
    return ( NO_ERROR == Err );
} // DhcpDsLookupServer()


//BeginExport(function)
//DOC DhcpDsEnumServers retrieves a bunch of information about each server that
//DOC has an entry in the Servers attribute of the root object. There are no guarantees
//DOC on the order..
//DOC The memory for this is allocated in ONE shot -- so the output can be freed in
//DOC one shot too.
//DOC
DWORD
DhcpDsEnumServers(                                // get info abt all existing servers
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    OUT     LPDHCPDS_SERVERS      *ServersInfo    // array of servers
) //EndExport(function)
{
    DWORD                          Err, Err2, Size, Size2, i, N;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPDHCPDS_SERVERS               LocalServers;
    LPBYTE                         Ptr;
    LPWSTR                         Filter1, Filter2, Filter3;

    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( 0 != Reserved || NULL == ServersInfo )
        return ERROR_INVALID_PARAMETER;

    *ServersInfo = NULL; i = N = Size = Size2 = 0;

    Err = MemArrayInit(&Servers);                 // cant fail
    //= require ERROR_SUCCESS == Err

    DsAuthPrint(( L"DhcpDsEnumServers \n" ));

    Err = GetListOfAllServersMatchingFilter( hDhcpC, &Servers,
					     DHCP_SEARCH_FILTER );
    if( ERROR_SUCCESS != Err ) return Err;

    Size = Size2 = 0;
    for(                                          // walk thru list of servers
        Err = MemArrayInitLoc(&Servers, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Servers, &Loc)     // skip to next element
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //=  ds inconsistent
        }

        Size2 = sizeof(WCHAR)*(1 + wcslen(ThisAttrib->String1));
        if( IS_ADSPATH_PRESENT(ThisAttrib) ) {    // if ADsPath there, account for it
            Size2 += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->ADsPath));
        }

        Size += Size2;                            // keep track of total mem reqd
        i ++;
    }

    Size += ROUND_UP_COUNT(sizeof(DHCPDS_SERVERS), ALIGN_WORST);
    Size += ROUND_UP_COUNT(sizeof(DHCPDS_SERVER)*i, ALIGN_WORST);
    Ptr = MIDL_user_allocate(Size);                         // allocate memory
    if( NULL == Ptr ) {
        MemArrayFree(&Servers, MemFreeFunc );     // free allocated memory
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LocalServers = (LPDHCPDS_SERVERS)Ptr;
    LocalServers->NumElements = i;
    LocalServers->Flags = 0;
    Size = 0;                                     // start from offset 0
    Size += ROUND_UP_COUNT(sizeof(DHCPDS_SERVERS), ALIGN_WORST);
    LocalServers->Servers = (LPDHCPDS_SERVER)(Size + Ptr);
    Size += ROUND_UP_COUNT(sizeof(DHCPDS_SERVER)*i, ALIGN_WORST);

    i = Size2 = 0;
    for(                                          // copy list of servers
        Err = MemArrayInitLoc(&Servers, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Servers, &Loc)     // skip to next element
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //=  ds inconsistent
        }

        LocalServers->Servers[i].Version =0;      // version is always zero in this build
        LocalServers->Servers[i].State=0;
        LocalServers->Servers[i].ServerName = (LPWSTR)(Size + Ptr);
        wcscpy((LPWSTR)(Size+Ptr), ThisAttrib->String1);
        Size += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->String1));
        LocalServers->Servers[i].ServerAddress = ThisAttrib->Address1;
        if( IS_FLAGS1_PRESENT(ThisAttrib) ) {     // State present
            LocalServers->Servers[i].Flags = ThisAttrib->Flags1;
        } else {
            LocalServers->Servers[i].Flags = 0;   // if no flags present, use zero
        }
        if( IS_ADSPATH_PRESENT(ThisAttrib) ) {    // if ADsPath there, copy it too
            LocalServers->Servers[i].DsLocType = ThisAttrib->StoreGetType;
            LocalServers->Servers[i].DsLocation = (LPWSTR)(Size + Ptr);
            wcscpy((LPWSTR)(Size + Ptr), ThisAttrib->ADsPath);
            Size += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->ADsPath));
        } else {                                  // no ADsPath present
            LocalServers->Servers[i].DsLocType = 0;
            LocalServers->Servers[i].DsLocation = NULL;
        }
        i ++;
    }

    *ServersInfo = LocalServers;
    MemArrayFree(&Servers, MemFreeFunc );         // free allocated memory
    return ERROR_SUCCESS;
} // DhcpDsEnumServers()

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\dhcpbas.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This is some functionality essential for the dhcp-ds
//   implementation.
//================================================================================


//================================================================================
//  headers
//================================================================================
#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>

//================================================================================
// Constants
//================================================================================
//BeginExport(defines)
#define     DDS_RESERVED_DWORD                    0
#define     DDS_RESERVED_PTR                      ((LPVOID)0)

//DOC The following constants are Flag values that maybe passed to different
//DOC functions.
#define     DDS_FLAGS_CREATE                      0x01

//DOC Some standard names and locations in the DS

#define     DHCP_ROOT_OBJECT_LOC                  L"CN=DhcpRoot, CN=NetServices, CN=Services"
#define     DHCP_ROOT_OBJECT_PARENT_LOC           L"CN=NetServices, CN=Services"
#define     DHCP_ROOT_OBJECT_CN_NAME              L"CN=DhcpRoot"
#define     DHCP_ROOT_OBJECT_NAME                 L"DhcpRoot"

#define     DHCP_ATTRIB_WHEN_CHANGED              L"whenChanged"

//DOC The attributes that are defined for the dhcp class follows.

#define     DHCP_ATTRIB_UNIQUE_KEY                L"dhcpUniqueKey"         // reqd,single,integer8
#define     DHCP_ATTRIB_IDENTIFICATION            L"dhcpIdentification"    // reqd,single,directorystring
#define     DHCP_ATTRIB_TYPE                      L"dhcpType"              // reqd,single,integer
#define     DHCP_ATTRIB_FLAGS                     L"dhcpFlags"             // reqd,single,integer8
#define     DHCP_ATTRIB_DESCRIPTION               L"description"           // -,mv,directorystring
#define     DHCP_ATTRIB_CLASSES                   L"dhcpClasses"           // -,mv,octetstring
#define     DHCP_ATTRIB_MASK                      L"dhcpMask"              // -,mv,printablestring
#define     DHCP_ATTRIB_OBJ_DESCRIPTION           L"dhcpObjDescription"    // -,single,directorystring
#define     DHCP_ATTRIB_OBJ_NAME                  L"dhcpObjName"           // -,single,direcotrystring
#define     DHCP_ATTRIB_OPTIONS                   L"dhcpOptions"           // -,single,octetstring
#define     DHCP_ATTRIB_RANGES                    L"dhcpRanges"            // -,mv,printablestring
#define     DHCP_ATTRIB_RESERVATIONS              L"dhcpReservations"      // -,mv,printablestring
#define     DHCP_ATTRIB_SERVERS                   L"dhcpServers"           // -,mv,printablestring
#define     DHCP_ATTRIB_STATE                     L"dhcpState"             // -,mv,printablestring
#define     DHCP_ATTRIB_SUBNETS                   L"dhcpSubnets"           // -,mv,printablestring
#define     DHCP_ATTRIB_LOCATION_DN               L"locationDN"            // -,single,dn
#define     DHCP_ATTRIB_MSCOPEID                  L"mscopeid"              // -,single,printablestring
#define     DHCP_ATTRIB_ADDRESS                   L"networkAddress"        // -,mv,CaseIgnoreString
#define     DHCP_ATTRIB_OPTIONS_LOC               L"optionsLocation"       // -,mv,printablestring
#define     DHCP_ATTRIB_OPTION_DESCRIPTION        L"optionDescription"     // -,mv,directorystring
#define     DHCP_ATTRIB_SUPERSCOPES               L"superScopes"           // -,mv,printablestring

//DOC The following are the various types of objects recognized by the dhcp server
#define     DHCP_OBJ_TYPE_ROOT                    0                        // dhcp root object
#define     DHCP_OBJ_TYPE_SERVER                  1                        // dhcp server object
#define     DHCP_OBJ_TYPE_SUBNET                  2                        // subnet object
#define     DHCP_OBJ_TYPE_RANGE                   3                        // range object
#define     DHCP_OBJ_TYPE_RESERVATION             4                        // reservation object
#define     DHCP_OBJ_TYPE_OPTION                  5                        // options object
#define     DHCP_OBJ_TYPE_CLASS                   6                        // class object

#define     DHCP_OBJ_TYPE_ROOT_DESC               L"DHCP Root object"
#define     DHCP_OBJ_TYPE_SERVER_DESC             L"DHCP Server object"
#define     DHCP_OBJ_TYPE_SUBNET_DESC             L"Dhcp Subnet object"
#define     DHCP_OBJ_TYPE_RANGE_DESC              L"Dhcp Range object"
#define     DHCP_OBJ_TYPE_RESERVATION_DESC        L"Dhcp Reservation object"
#define     DHCP_OBJ_TYPE_OPTION_DESC             L"Dhcp Option object"
#define     DHCP_OBJ_TYPE_CLASS_DESC              L"Dhcp Class object"


//DOC The following defines are bitmasks and bits in various flags..

//DOC The flag2 portion of Ranges key is used for differntiating between exclusions and ranges
#define     RANGE_TYPE_RANGE                      0
#define     RANGE_TYPE_EXCL                       1
#define     RANGE_TYPE_MASK                       (0x1)

//EndExport(defines)



//================================================================================
// functions
//================================================================================
//BeginExport(function)
//DOC DhcpDsGetDhcpC gets the dhcp container in the DS.. This is usually the
//DOC container CN=Netservices,CN=Services,CN=Configuration etc..
//DOC This is used in many functions, so it is useful to have a central function..
//DOC
DWORD
DhcpDsGetDhcpC(                                   // get dhcp container
    IN      DWORD                  Reserved,      // future use
    IN OUT  LPSTORE_HANDLE         hStoreCC,      // config container handle
    OUT     LPSTORE_HANDLE         hDhcpC         // output dhcp container handle
)   //EndExport(function)
{
    DWORD                          Result, Result2;
    STORE_HANDLE                   TmpHandle;

    if( NULL == hStoreCC || NULL == hDhcpC )
        return ERROR_INVALID_PARAMETER;
    if( 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Result = StoreGetHandle(
        /* hStore               */ hStoreCC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetChildType,
        /* Path                 */ DHCP_ROOT_OBJECT_PARENT_LOC,
        /* hStoreOut            */ hDhcpC
    );

    return Result;
}

//BeginExport(function)
//DOC DhcpDsGetRoot gets the dhcp root object given to the configuration container
//DOC This is usually CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration...
//DOC If Flags has the DDS_FLAGS_CREATE bit set, then the root object is created.
//DOC Return Values:
//DOC Store                        any returns returned by the Store module
//DOC ERROR_DDS_NO_DHCP_ROOT       no DhcpRoot object found
//DOC ERROR_DDS_UNEXPECTED_ERROR   the DhcpRoot's parent container not found..
//                                 in this case GetLastError returns ADS error
DWORD
DhcpDsGetRoot(
    IN      DWORD                  Flags,         // 0 or DDS_FLAGS_CREATE
    IN OUT  LPSTORE_HANDLE         hStoreCC,      // configuration container handle
    OUT     LPSTORE_HANDLE         hStoreDhcpRoot // dhcp root object handle
) //EndExport(function)
{
    DWORD                          Result, Result2;
    STORE_HANDLE                   TmpHandle;

    SetLastError(NO_ERROR);
    
    if( NULL == hStoreCC || NULL == hStoreDhcpRoot )
        return ERROR_INVALID_PARAMETER;
    if( 0 != Flags && DDS_FLAGS_CREATE != Flags )
        return ERROR_INVALID_PARAMETER;

    Result = StoreGetHandle(
        /* hStore               */ hStoreCC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetChildType,
        /* Path                 */ DHCP_ROOT_OBJECT_LOC,
        /* hStoreOut            */ hStoreDhcpRoot
    );
    if( ERROR_SUCCESS == Result ) return ERROR_SUCCESS;

    if( DDS_FLAGS_CREATE != Flags && ERROR_DS_NO_SUCH_OBJECT != Result ) {
        //- MajorFunctionFailure(StoreGetHandle, Result, DHCP_ROOT_OBJECT_LOC);
        SetLastError(Result);
        return Result;
    }

    //= DDS_FLAGS_CREATE == Flags && ERROR_DS_NO_SUCH_OBJECT == Result    
    Result = StoreGetHandle(
        /* hStore               */ hStoreCC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetChildType,
        /* Path                 */ DHCP_ROOT_OBJECT_PARENT_LOC,
        /* hStoreOut            */ &TmpHandle
    );
    if( ERROR_SUCCESS != Result ) {
        SetLastError(Result);
        return ERROR_DDS_UNEXPECTED_ERROR;
    }
    
    if( DDS_FLAGS_CREATE != Flags ) {
        //
        // Could open the config\services\netservices container, but
        // can't open the dhcproot object.  Most likely the dhcproot
        // object ain't there. 
        //
        
        Result2 = StoreCleanupHandle( &TmpHandle, DDS_RESERVED_DWORD );
        //= ERROR_SUCCESS == Result2

        SetLastError(ERROR_DS_NO_SUCH_OBJECT);
        return ERROR_DDS_NO_DHCP_ROOT;
    }

    Result = StoreCreateObject(
        /* hStore               */ &TmpHandle,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* NewObjName           */ DHCP_ROOT_OBJECT_CN_NAME,
        /* ...                  */
        /* Identification       */
        ADSTYPE_DN_STRING,         ATTRIB_DN_NAME,          DHCP_ROOT_OBJECT_NAME,
        ADSTYPE_DN_STRING,         ATTRIB_OBJECT_CLASS,     DEFAULT_DHCP_CLASS_ATTRIB_VALUE,

        /* systemMustContain    */
        ADSTYPE_INTEGER,           ATTRIB_DHCP_UNIQUE_KEY,  0,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_TYPE,        0,
        ADSTYPE_DN_STRING,         ATTRIB_DHCP_IDENTIFICATION, L"This is a server",
        ADSTYPE_INTEGER,           ATTRIB_DHCP_FLAGS,       0,
        ADSTYPE_INTEGER,           ATTRIB_INSTANCE_TYPE,    DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE,

        /* terminator           */
        ADSTYPE_INVALID
    );

    Result2 = StoreCleanupHandle( &TmpHandle, DDS_RESERVED_DWORD );
    //= ERROR_SUCCESS == Result2

    if( ERROR_SUCCESS != Result ) {
        //- MinorFunctionFailure(StoreCleanupHandle, Result)
        return Result;
    }

    return DhcpDsGetRoot( Flags & ~DDS_FLAGS_CREATE, hStoreCC, hStoreDhcpRoot);
}

//BeginExport(function)
//DOC DhcpDsGetLists function retrives a list of attributes and adds it the given array
//DOC allocating each element separateley, and traversing any pointers indicated by
//DOC the value of the attribute.
//DOC Note that even in case of error, the array may still contain some elements.
//DOC This is a best effort even in case of failure.
//DOC Each element of the array must be freed via MemFree, and the array itself
//DOC must be cleaned up via MemArrayCleanup.
//DOC Note that any of the PARRAY type parameters may be NULL, as they are optional.
//DOC but reading these separately is highly inefficient...
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   some entirely unexpected error
//DOC ERROR_DDS_TOO_MANY_ERRORS    multiple errors occured, and was caught
//DOC Store                        any errors returned by the store apis
DWORD
DhcpDsGetLists(                                   // get list of different objects
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to get the lists for
    IN      DWORD                  RecursionDepth,// how much nesting allowed? 0 ==> one level only
    IN OUT  PARRAY                 Servers,       // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Subnets,       // <Name,Description,IpAddress,Mask,State,Location>
    IN OUT  PARRAY                 IpAddress,     // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Mask,          // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Ranges,        // <Name,Description,IpAddress1,IpAddress2,State,Location>
    IN OUT  PARRAY                 Sites,         // dont know what this looks like now
    IN OUT  PARRAY                 Reservations,  // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 SuperScopes,   // <Name,Description,State,DWORD, Location>
    //IN    PARRAY                 SuperScopesDescription, // UNUSED
    IN OUT  PARRAY                 OptionDescription, // <options definition>
    IN OUT  PARRAY                 OptionsLocation, // <Location>
    IN OUT  PARRAY                 Options,       // xxx <Name, Description, String1=HexStream>
    IN OUT  PARRAY                 Classes        // xxx <Name, Description, String1=HexStream>
) //EndExport(function)
{
    DWORD                          Result;
    DWORD                          LastError;

    if( 0 != Reserved ) return ERROR_INVALID_PARAMETER;
    if( NULL == hStore || NULL == hStore->ADSIHandle ) return ERROR_INVALID_PARAMETER;

    LastError = ERROR_SUCCESS;
    if( NULL != Servers ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SERVERS,
            /* ArrayToAddTo     */ Servers,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Subnets ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SUBNETS,
            /* ArrayToAddTo     */ Subnets,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != IpAddress ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_ADDRESS,
            /* ArrayToAddTo     */ IpAddress,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Mask ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_MASK,
            /* ArrayToAddTo     */ Mask,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Ranges ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_RANGES,
            /* ArrayToAddTo     */ Ranges,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Sites ) {
        // ignored for now
    }

    if( NULL != Reservations ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_RESERVATIONS,
            /* ArrayToAddTo     */ Reservations,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != SuperScopes ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SUPERSCOPES,
            /* ArrayToAddTo     */ SuperScopes,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != OptionsLocation ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTIONS_LOC,
            /* ArrayToAddTo     */ OptionsLocation,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != OptionDescription ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTION_DESCRIPTION,
            /* ArrayToAddTo     */ OptionDescription,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Options ) {
        Result = StoreCollectBinaryAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTIONS,
            /* ArrayToAddTo     */ Options,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Classes ) {
        Result = StoreCollectBinaryAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_CLASSES,
            /* ArrayToAddTo     */ Classes,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    return LastError;
}

//DOC Clonestring just allocates memory for the string and copies it over and returns
//DOC that.
LPWSTR
CloneString(
    IN      LPWSTR                 Str
)
{
    LPWSTR                         RetVal;

    if( NULL == Str ) return NULL;
    RetVal = MemAlloc( sizeof(WCHAR)*(1+wcslen(Str)));
    if( NULL != RetVal ) wcscpy(RetVal, Str);
    return RetVal;
}

//DOC MarkFoundParam marks the given argno as found (converse of DhcpCheckParams )
VOID        _inline
MarkFoundParam(
    IN OUT  DWORD                 *FoundParams,
    IN      DWORD                  ArgNo
)
{
    (*FoundParams) |= (1 << ArgNo);
}

//BeginExport(function)
//DOC DhcpDsGetAttribs retreives all the miscellaneous attributes (whichever is requested) and
//DOC returns it as XXX_TYPE parameter.   These parameters are allocated within this function
//DOC using MemAlloc and must be freed via MemFree.  Any of the parameters maybe NULL indicating
//DOC lack of interest in that attribute.  (Note that the following parameters are NOT allocated:
//DOC they are just filled in: UniqueKey, Type, Flags, MScopeId, FoundParams)
//DOC Note that some of the parameters may not be found, but this can be checked against the
//DOC value returned in FoundParams (which is a REQUIRED parameter) using the FOUND_ARG(FoundParams,Arg#)
//DOC where the Args are numbered from 0 starting at UniqueKey..
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   some entirely unexpected error
//DOC ERROR_DDS_TOO_MANY_ERRORS    multiple errors occured, and was caught
//DOC Store                        any errors returned by the store apis
DWORD
DhcpDsGetAttribs(                                 // get list of attributes
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,
    IN OUT  DWORD                 *FoundParams,   // which of the following params was found?
    IN OUT  LARGE_INTEGER         *UniqueKey,     // fill in an unique key
    IN OUT  DWORD                 *Type,          // object type
    IN OUT  LARGE_INTEGER         *Flags,         // additional info about the object
    IN OUT  LPWSTR                *Name,          // Allocated, name of object
    IN OUT  LPWSTR                *Description,   // Allocated, something that describes this object
    IN OUT  LPWSTR                *Location,      // the reference location from which to do other stuff
    IN OUT  DWORD                 *MScopeId       // what is the scope id used?
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          i;
    DWORD                          nAttribs, nAttributes;
    LPWSTR                         Attribs[10];   // atmost 10 attribs are defined now...
    PADS_ATTR_INFO                 Attributes;

    if( Reserved != 0 ) return ERROR_INVALID_PARAMETER;
    if( NULL == FoundParams ) return ERROR_INVALID_PARAMETER;
    if( NULL == hStore || NULL == hStore->ADSIHandle ) return ERROR_INVALID_PARAMETER;

    *FoundParams = 0;                             // nothing has been found yet.
    nAttribs = 0;

    if( UniqueKey ) Attribs[nAttribs++] = DHCP_ATTRIB_UNIQUE_KEY;
    if( Type ) Attribs[nAttribs++] = DHCP_ATTRIB_TYPE;
    if( Flags ) Attribs[nAttribs++] = DHCP_ATTRIB_FLAGS;
    if( Name ) Attribs[nAttribs++] = DHCP_ATTRIB_OBJ_NAME;
    if( Description ) Attribs[nAttribs++] = DHCP_ATTRIB_OBJ_DESCRIPTION;
    if( Location ) Attribs[nAttribs++] = DHCP_ATTRIB_LOCATION_DN;
    if( MScopeId ) Attribs[nAttribs++] = DHCP_ATTRIB_MSCOPEID;

    if( 0 == nAttribs ) return ERROR_INVALID_PARAMETER;

    Attributes = NULL; nAttributes = 0;
    hResult = ADSIGetObjectAttributes(
        /* hDSObject            */ hStore->ADSIHandle,
        /* pAttributeNames      */ Attribs,
        /* dwNumberAttributes   */ nAttribs,
        /* ppAttributeEntries   */ &Attributes,
        /* pdwNumAttributesReturned */ &nAttributes
    );

    // hResult can be E_ADS_LDAP_NO_SUCH_ATTRIBUTE if only one attrib was asked for..
    if( FAILED(hResult) ) return ERROR_DDS_UNEXPECTED_ERROR;

    if( 0 == nAttributes ) {
        if( Attributes ) FreeADsMem(Attributes);
        return ERROR_DDS_UNEXPECTED_ERROR;
    }

    for( i = 0; i < nAttributes ; i ++ ) {
        if( ADSTYPE_INVALID == Attributes[i].dwADsType )
            continue;                             //?? should not really happen
        if( 0 == Attributes[i].dwNumValues )      //?? this should not happen either
            continue;

        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_UNIQUE_KEY ) ) {
            if( ADSTYPE_LARGE_INTEGER != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *UniqueKey = Attributes[i].pADsValues[0].LargeInteger;
            MarkFoundParam(FoundParams, 0);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_TYPE ) ) {
            if( ADSTYPE_INTEGER != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Type = Attributes[i].pADsValues[0].Integer;
            MarkFoundParam(FoundParams, 1);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_FLAGS ) ) {
            if( ADSTYPE_LARGE_INTEGER != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Flags = Attributes[i].pADsValues[0].LargeInteger;
            MarkFoundParam(FoundParams, 2);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_OBJ_NAME ) ) {
            if( ADSTYPE_CASE_IGNORE_STRING != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Name = CloneString(Attributes[i].pADsValues[0].CaseIgnoreString);
            MarkFoundParam(FoundParams, 3);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_OBJ_DESCRIPTION ) ) {
            if( ADSTYPE_CASE_IGNORE_STRING != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Description = CloneString(Attributes[i].pADsValues[0].CaseIgnoreString);
            MarkFoundParam(FoundParams, 4);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_LOCATION_DN ) ) {
            if( ADSTYPE_DN_STRING != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Location = CloneString(Attributes[i].pADsValues[0].CaseIgnoreString);
            MarkFoundParam(FoundParams, 5);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_MSCOPEID ) ) {
            if( ADSTYPE_PRINTABLE_STRING != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *MScopeId = _wtol(Attributes[i].pADsValues[0].PrintableString);
            MarkFoundParam(FoundParams, 6);
            continue;
        }
    }

    FreeADsMem(Attributes);
    return ERROR_SUCCESS;
}

//BeginExport(inline)
//DOC DhcpCheckParams checks to see if the argument numbered (ArgNo) was found
//DOC as marked in the bitmap FoundParams.  Essentially used by the DhcpDsGetAttribs function only.
//DOC Return Values:
BOOL        _inline
DhcpCheckParams(                                  // check to see if requested param was returned
    IN      DWORD                  FoundParams,
    IN      DWORD                  ArgNo
)
{
    if( ArgNo > sizeof(FoundParams)*8 ) return FALSE;
    return ((FoundParams) & (1 << ArgNo) )?TRUE:FALSE;
}
//EndExport(inline)


//BeginExport(function)
//DOC DhcpDsSetLists function sets the various list of attributes to the values given.
//DOC it walks the arrays and encapsulates the arrays.
//DOC Note that in case of error, this function returns immediately.
//DOC In case of error, pl check the SetParams parameter with the CheckParams function
//DOC to determine which parameters were set... (no order guarantee is made for setting
//DOC the parameters).
//DOC Any PARRAY parameter may be omitted if it is not required to be modified.
//DOC SetParams is REQUIRED to be present.  See the discussion in DhcpDsGetAttribs for
//DOC the meaning of this parameter.
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   something bad happened
//DOC ERROR_DDS_TOO_MANY_ERRORS    too many simple errors
//DOC Store                        any errors returned by the store module
DWORD
DhcpDsSetLists(                                   // set the list of attributes after encapsulating them
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to get the lists for
    IN OUT  LPDWORD                SetParams,     // which of the following params got modified really?
    IN      PARRAY                 Servers,       // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Subnets,       // <Name,Description,IpAddress,Mask,State,Location>
    IN      PARRAY                 IpAddress,     // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Mask,          // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Ranges,        // <Name,Description,IpAddress1,IpAddress2,State,Location>
    IN      PARRAY                 Sites,         // dont know what this looks like now
    IN      PARRAY                 Reservations,  // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 SuperScopes,   // <Name,Description,State,DWORD, Location>
    //IN    PARRAY                 SuperScopesDescription, // UNUSED
    IN    PARRAY                   OptionDescription, // option definitions..
    IN      PARRAY                 OptionsLocation, // <Location>
    IN      PARRAY                 Options,       // xxx <Name, Description, String1=HexStream>
    IN      PARRAY                 ClassDescription, // <Name, Description, String, Location>
    IN      PARRAY                 Classes        // xxx <Name, Description, String1=HexStream>
) //EndExport(function)
{
    DWORD                          Result;
    DWORD                          LastError;
    DWORD                          ArgNo;

    if( 0 != Reserved ) return ERROR_INVALID_PARAMETER;
    if( NULL == hStore || NULL == hStore->ADSIHandle ) return ERROR_INVALID_PARAMETER;
    if( NULL == SetParams ) return ERROR_INVALID_PARAMETER;

    LastError = ERROR_SUCCESS;

    ArgNo = 0;
    if( NULL != Servers ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SERVERS,
            /* ArrayToWrite     */ Servers
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Subnets ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SUBNETS,
            /* ArrayToWrite     */ Subnets
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != IpAddress ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_ADDRESS,
            /* ArrayToWrite     */ IpAddress
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Mask ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_MASK,
            /* ArrayToWrite     */ Mask
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Ranges ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_RANGES,
            /* ArrayToWrite     */ Ranges
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Sites ) {
        // ignored for now
        MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Reservations ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_RESERVATIONS,
            /* ArrayToWrite     */ Reservations
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != SuperScopes ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SUPERSCOPES,
            /* ArrayToWrite     */ SuperScopes
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != OptionsLocation ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTIONS_LOC,
            /* ArrayToWrite     */ OptionsLocation
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != OptionDescription ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTION_DESCRIPTION,
            /* ArrayToWrite     */ OptionDescription
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Options ) {
        Result = StoreUpdateBinaryAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTIONS,
            /* ArrayToWrite     */ Options
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Classes ) {
        Result = StoreUpdateBinaryAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_CLASSES,
            /* ArrayToWrite     */ Classes
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    return LastError;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\delete.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

//DOC  SubnetDeleteReservation deletes the reservation object from off the DS.
SubnetDeleteReservation(                          // delete reservation from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for resrevation objs
    IN      LPWSTR                 ServerName,    // name of dhcp server
    IN OUT  LPSTORE_HANDLE         hServer,       // server object in DS
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object in DS
    IN      LPWSTR                 ADsPath,       // path of reservation object
    IN      DWORD                  StoreGetType   // path is relative, abs, or dif server?
) ;


//DOC  ServerDeleteSubnet deletes the subnet specified from the DS by removing
//DOC  the subnet object.
ServerDeleteSubnet(                               // remove subnet object from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for subnet objs in Ds
    IN      LPWSTR                 ServerName,    // name of server this deletion is for
    IN OUT  LPSTORE_HANDLE         hServer,       // server object in DS
    IN      LPWSTR                 ADsPath,       // Location of the subnet in DS
    IN      DWORD                  StoreGetType   // path is relative,abs or diff srvr?
) ;


//DOC  DeleteServer deletes the server object from the DS and deletes any SUBNET and
//DOC  reservation objects that it may point to.
//DOC  The hDhcpC parameter is the handle of the container where the server object
//DOC  may be located. This used in conjunction with the ADsPath and StoreGetType
//DOC  defines the location of the ServerObject.
DWORD
DeleteServer(                                     // recurse delete server from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where server obj may be
    IN      LPWSTR                 ServerName,    // name of server..
    IN      LPWSTR                 ADsPath,       // path of the server object
    IN      DWORD                  StoreGetType   // is path relative, absolute or dif srvr?
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\rpcstubs.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description:  Actual stubs that are the equivalent the rpcapi1.c and rpcapi2.c
// in the server\server directory.. (or more accurately, the implementations are
// the same as for the functions defined in server\client\dhcpsapi.def)
// NOTE: THE FOLLOWING FUNCTIONS ARE NOT RPC, BUT THEY BEHAVE JUST THE SAME AS
// THE DHCP RPC CALLS, EXCEPT THEY ACCESS THE DS DIRECTLY.
//================================================================================

#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpapi.h>
#include    <delete.h>
#include    <st_srvr.h>
#include    <rpcapi2.h>

//================================================================================
//  global variables..
//================================================================================
BOOL
StubInitialized                    = FALSE;
STORE_HANDLE                       hDhcpC, hDhcpRoot;
CRITICAL_SECTION                   DhcpDsDllCriticalSection;

//================================================================================
//   THE FOLLOWING FUNCTIONS HAVE BEEN COPIED OVER FROM RPCAPI1.C (IN THE
//   DHCP\SERVER\SERVER DIRECTORY).
//================================================================================

#undef      DhcpPrint
#define     DhcpPrint(X)
#define     DhcpAssert(X)

//================================================================================
//  helper routines
//================================================================================

VOID
MemFreeFunc(                                      // free memory
    IN OUT  LPVOID                 Mem
)
{
    MemFree(Mem);
}

//
// ErrorNotInitialized used to be ZERO.. but why would we NOT return an error?
// so changed it to return errors..
//
#define ErrorNotInitialized        Err
#define STUB_NOT_INITIALIZED(Err)  ( !StubInitialized && ((Err) = StubInitialize()))

//DOC StubInitialize initializes all the modules involved in the dhcp ds dll.
//DOC It also sets a global variable StubInitialized to TRUE to indicate that
//DOC initialization went fine.  This should be called as part of DllInit so that
//DOC everything can be done at this point..
DWORD
StubInitialize(                                   // initialize all global vars
    VOID
)
{
    DWORD                          Err,Err2;
    STORE_HANDLE                   ConfigC;

    if( StubInitialized ) return ERROR_SUCCESS;   // already initialized

    Err = Err2 = ERROR_SUCCESS;
    EnterCriticalSection( &DhcpDsDllCriticalSection );
    do {
        if( StubInitialized ) break;
        Err = StoreInitHandle(
            /* hStore               */ &ConfigC,
            /* Reserved             */ DDS_RESERVED_DWORD,
            /* ThisDomain           */ NULL,      // current domain
            /* UserName             */ NULL,      // current user
            /* Password             */ NULL,      // current credentials
            /* AuthFlags            */ ADS_SECURE_AUTHENTICATION | ADS_USE_SIGNING | ADS_USE_SEALING
            );
        if( ERROR_SUCCESS != Err ) {
            Err = ERROR_DDS_NO_DS_AVAILABLE;      // could not get config hdl
            break;
        }
        
        Err = DhcpDsGetDhcpC(
            DDS_RESERVED_DWORD, &ConfigC, &hDhcpC
            );
        
        if( ERROR_SUCCESS == Err ) {
            Err2 = DhcpDsGetRoot(                 // now try to get root handle
                DDS_FLAGS_CREATE, &ConfigC, &hDhcpRoot
                );
        }

        StoreCleanupHandle(&ConfigC, DDS_RESERVED_DWORD);
    } while (0);

    if( ERROR_SUCCESS != Err2 ) {                 // could not get dhcp root hdl
        DhcpAssert(ERROR_SUCCESS == Err);
        StoreCleanupHandle(&hDhcpC, DDS_RESERVED_DWORD);
        Err = Err2;
    }

    StubInitialized = (ERROR_SUCCESS == Err );
    LeaveCriticalSection( &DhcpDsDllCriticalSection );
    return Err;
}

//DOC StubCleanup de-initializes all the modules involved in the dhcp ds dll.
//DOC its effect is to undo everything done by StubInitialize
VOID
StubCleanup(                                      // undo StubInitialize
    VOID
)
{
    if( ! StubInitialized ) return;               // never initialized anyways
    EnterCriticalSection(&DhcpDsDllCriticalSection);
    if( StubInitialized ) {
        StoreCleanupHandle(&hDhcpC, DDS_RESERVED_DWORD);
        StoreCleanupHandle(&hDhcpRoot, DDS_RESERVED_DWORD);
        StubInitialized = FALSE;
    }
    LeaveCriticalSection(&DhcpDsDllCriticalSection);
}

//DOC DhcpDsLock is not yet implemented
DWORD
DhcpDsLock(                                       // lock the ds
    IN OUT  LPSTORE_HANDLE         hDhcpRoot      // dhcp root object to lock via
)
{

    EnterCriticalSection(&DhcpDsDllCriticalSection);
    
    return ERROR_SUCCESS;
}

//DOC DhcpDsUnlock not yet implemented
VOID
DhcpDsUnlock(
    IN OUT  LPSTORE_HANDLE         hDhcpRoot      // dhcp root object..
)
{
    LeaveCriticalSection(&DhcpDsDllCriticalSection);
}

//DOC GetServerNameFromAddr gets the server name given ip address
DWORD
GetServerNameFromAddr(                            // get server name from ip addr
    IN      DWORD                  IpAddress,     // look for server w/ this addr
    OUT     LPWSTR                *ServerName     // fill this with matching name
)
{
    DWORD                          Err, Err2;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPWSTR                         ThisStr, AllocStr;

    MemArrayInit(&Servers);
    Err = DhcpDsGetLists                          // get list of servers
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ &hDhcpRoot,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ &Servers,      // array of PEATTRIB 's
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    ThisStr = NULL;
    for(                                          // find name for ip-address
        Err = MemArrayInitLoc(&Servers,&Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Servers, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //= ds inconsistent
        }

        ThisStr = ThisAttrib->String1;
        break;
    }

    AllocStr = NULL;
    if( NULL == ThisStr ) {                       // didnt find server name
        Err = ERROR_FILE_NOT_FOUND;
    } else {                                      // found the server name
        AllocStr = MemAlloc(sizeof(WCHAR)*(1+wcslen(ThisStr)));
        if( NULL == AllocStr ) {                  // couldnt alloc mem?
            Err = ERROR_NOT_ENOUGH_MEMORY;
        } else {                                  // now just copy the str over
            wcscpy(AllocStr, ThisStr);
            Err = ERROR_SUCCESS;
        }
    }

    MemArrayFree(&Servers, MemFreeFunc);
    *ServerName = AllocStr;
    return Err;
}

//================================================================================
//  the following functions are NOT based on RPC, but actually direct calls to
//  the DS. But, they have the same interface as the RPC stubs in dhcpsapi.dll.
//================================================================================

BOOLEAN
DllMain(
    IN HINSTANCE DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*++

Routine Description:
    This routine is the standard DLL initialization
    routine and all it does is intiialize a critical section
    for actual initialization to be done at startup elsewhere.

Arguments:
    DllHandle -- handle to current module
    Reason -- reason for DLL_PROCESS_ATTACH.. DLL_PROCESS_DETACH

Return Value:
    TRUE -- success, FALSE -- failure

--*/
{
    if( DLL_PROCESS_ATTACH == Reason ) {
        //
        // First disable further calls to DllInit
        //
        if( !DisableThreadLibraryCalls( DllHandle ) ) return FALSE;

        //
        // Now try to create critical section
        //
        try {
            InitializeCriticalSection(&DhcpDsDllCriticalSection);
        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            // shouldnt happen but you never know.
            return FALSE;
        }

    } else if( DLL_PROCESS_DETACH == Reason ) {
        //
        // Cleanup the initialization critical section
        //
        DeleteCriticalSection(&DhcpDsDllCriticalSection);
    }

    //
    // InitializeCriticalSection does not fail, just throws exception..
    // so we always return success.
    //
    return TRUE;
}

//================================================================================
//  DS only NON-rpc stubs
//================================================================================

//BeginExport(function)
//DOC DhcpEnumServersDS lists the servers found in the DS along with the
//DOC addresses and other information.  The whole server is allocated as a blob,
//DOC and should be freed in one shot.  No parameters are currently used, other
//DOC than Servers which will be an OUT parameter only.
DWORD
DhcpEnumServersDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) //EndExport(function)
{
    DWORD                          Err, Err2, Size,i;
    LPDHCPDS_SERVERS               DhcpDsServers;

    AssertRet(Servers, ERROR_INVALID_PARAMETER);
    AssertRet(!Flags, ERROR_INVALID_PARAMETER);
    *Servers = NULL;

    if( STUB_NOT_INITIALIZED(Err) ) return ERROR_DDS_NO_DS_AVAILABLE;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    DhcpDsServers = NULL;
    Err = DhcpDsEnumServers                       // get the list of servers
    (
        /* hDhcpC               */ &hDhcpC,
        /* hDhcpRoot            */ &hDhcpRoot,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServersInfo          */ &DhcpDsServers
    );

    DhcpDsUnlock(&hDhcpRoot);

    if( ERROR_SUCCESS != Err ) return Err;        // return err..

    *Servers = DhcpDsServers;
    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC DhcpAddServerDS adds a particular server to the DS.  If the server exists,
//DOC then, this returns error.  If the server does not exist, then this function
//DOC adds the server in DS, and also uploads the configuration from the server
//DOC to the ds.
DWORD
DhcpAddServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) //EndExport(function)
{
    DWORD                          Err, Err2;
    WCHAR                          TmpBuf[sizeof(L"000.000.000.000")];
    
    AssertRet(NewServer, ERROR_INVALID_PARAMETER);
    AssertRet(!Flags, ERROR_INVALID_PARAMETER);
    
    if( STUB_NOT_INITIALIZED(Err) ) return ERROR_DDS_NO_DS_AVAILABLE;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = DhcpDsAddServer                         // add the new server
    (
        /* hDhcpC               */ &hDhcpC,
        /* hDhcpRoot            */ &hDhcpRoot,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServerName           */ NewServer->ServerName,
        /* ReservedPtr          */ DDS_RESERVED_PTR,
        /* IpAddress            */ NewServer->ServerAddress,
        /* State                */ Flags
    );

    DhcpDsUnlock(&hDhcpRoot);

    return Err;
}

//BeginExport(function)
//DOC DhcpDeleteServerDS deletes the servers from off the DS and recursively
//DOC deletes the server object..(i.e everything belonging to the server is deleted).
//DOC If the server does not exist, it returns an error.
DWORD
DhcpDeleteServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) //EndExport(function)
{
    DWORD                          Err, Err2;

    AssertRet(NewServer, ERROR_INVALID_PARAMETER);
    AssertRet(!Flags, ERROR_INVALID_PARAMETER);

    if( STUB_NOT_INITIALIZED(Err) ) return ERROR_DDS_NO_DS_AVAILABLE;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = DhcpDsDelServer                         // del this server
    (
        /* hDhcpC               */ &hDhcpC,
        /* hDhcpRoot            */ &hDhcpRoot,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServerName           */ NewServer->ServerName,
        /* ReservedPtr          */ DDS_RESERVED_PTR,
        /* IpAddress            */ NewServer->ServerAddress
    );

    DhcpDsUnlock(&hDhcpRoot);

    return Err;
}

//BeginExport(function)
//DOC DhcpDsInitDS initializes everything in this module.
DWORD
DhcpDsInitDS(
    DWORD                          Flags,
    LPVOID                         IdInfo
) //EndExport(function)
{
    return StubInitialize();
}

//BeginExport(function)
//DOC DhcpDsCleanupDS uninitiailzes everything in this module.
VOID
DhcpDsCleanupDS(
    VOID
) //EndExport(function)
{
    StubCleanup();
}

//BeginExport(header)
//DOC This function is defined in validate.c
//DOC Only the stub is here.
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses OPTIONAL,
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone
);

//EndExport(header)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\rpcapi2.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _DHCPDS_RPCAPI2_H
#define _DHCPDS_RPCAPI2_H

//DOC DhcpDsAddServer adds a server's entry in the DS.  Note that only the name
//DOC uniquely determines the server. There can be one server with many ip addresses.
//DOC If the server is created first time, a separate object is created for the
//DOC server. TO DO: The newly added server should also have its data
//DOC updated in the DS uploaded from the server itself if it is still up.
//DOC Note that it takes as parameter the Dhcp root container.
//DOC If the requested address already exists in the DS (maybe to some other
//DOC server), then the function returns ERROR_DDS_SERVER_ALREADY_EXISTS
DWORD
DhcpDsAddServer(                                  // add a server in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ReservedPtr,   // Server location? future use
    IN      DWORD                  IpAddress,     // ip address of server
    IN      DWORD                  State          // currently un-interpreted
) ;


//DOC DhcpDsDelServer removes the requested servername-ipaddress pair from the ds.
//DOC If this is the last ip address for the given servername, then the server
//DOC is also removed from memory.  But objects referred by the Server are left in
//DOC the DS as they may also be referred to from else where.  This needs to be
//DOC fixed via references being tagged as direct and symbolic -- one causing deletion
//DOC and other not causing any deletion.  THIS NEEDS TO BE FIXED. 
DWORD
DhcpDsDelServer(                                  // Delete a server from memory
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 ServerName,    // which server to delete for
    IN      LPWSTR                 ReservedPtr,   // server location ? future use
    IN      DWORD                  IpAddress      // the IpAddress to delete..
) ;


BOOL
DhcpDsLookupServer(                               // get info abt all existing servers
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 LookupServerIP,// Server to lookup IP
    IN      LPWSTR                 HostName      // Hostname to lookup
);

//DOC DhcpDsEnumServers retrieves a bunch of information about each server that
//DOC has an entry in the Servers attribute of the root object. There are no guarantees
//DOC on the order..
//DOC The memory for this is allocated in ONE shot -- so the output can be freed in
//DOC one shot too.
//DOC
DWORD
DhcpDsEnumServers(                                // get info abt all existing servers
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    OUT     LPDHCPDS_SERVERS      *ServersInfo    // array of servers
) ;


//DOC DhcpDsSetSScope modifies the superscope that a subnet belongs to.
//DOC The function tries to set the superscope of the subnet referred by
//DOC address IpAddress to SScopeName.  It does not matter if the superscope
//DOC by that name does not exist, it is automatically created.
//DOC If the subnet already had a superscope, then the behaviour depends on
//DOC the flag ChangeSScope.  If this is TRUE, it sets the new superscopes.
//DOC If the flag is FALSE, it returns ERROR_DDS_SUBNET_HAS_DIFF_SSCOPE.
//DOC This flag is ignored if the subnet does not have a superscope already.
//DOC If SScopeName is NULL, the function removes the subnet from any superscope
//DOC if it belonged to one before.
//DOC If the specified subnet does not exist, it returns ERROR_DDS_SUBNET_NOT_PRESENT.
DWORD
DhcpDsSetSScope(                                  // change superscope of subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where dhcp objects are stored
    IN OUT  LPSTORE_HANDLE         hServer,       // the server object referred
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      DWORD                  IpAddress,     // subnet address to use
    IN      LPWSTR                 SScopeName,    // sscope it must now be in
    IN      BOOL                   ChangeSScope   // if it already has a SScope, change it?
) ;


//DOC DhcpDsDelSScope deletes the superscope and removes all elements
//DOC that belong to that superscope in one shot. There is no error if the
//DOC superscope does not exist.
DWORD
DhcpDsDelSScope(                                  // delete superscope off DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where dhcp objects are stored
    IN OUT  LPSTORE_HANDLE         hServer,       // the server object referred
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 SScopeName     // sscope to delete
) ;


//DOC DhcpDsGetSScopeInfo retrieves the SuperScope table for the server of interest.
//DOC The table itself is allocated in one blob, so it can be freed lateron.
//DOC The SuperScopeNumber is garbage (always zero) and the NextInSuperScope reflects
//DOC the order in the DS which may/maynot be the same in the DHCP server.
//DOC SuperScopeName is NULL in for subnets that done have a sscope.
DWORD
DhcpDsGetSScopeInfo(                              // get superscope table from ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where dhcp objects are stored
    IN OUT  LPSTORE_HANDLE         hServer,       // the server object referred
    IN      DWORD                  Reserved,      // must be zero, for future use
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SScopeTbl   // allocated by this func in one blob
) ;


//DOC DhcpDsServerAddSubnet tries to add a subnet to a given server. Each subnet
//DOC address has to be unique, but the other parameters dont have to.
//DOC The subnet address being added should not belong to any other subnet.
//DOC In this case it returns error ERROR_DDS_SUBNET_EXISTS
DWORD
DhcpDsServerAddSubnet(                            // create a new subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      LPDHCP_SUBNET_INFO     Info           // info on new subnet to create
) ;


//DOC DhcpDsServerDelSubnet removes a subnet from a given server. It removes not
//DOC just the subnet, but also all dependent objects like reservations etc.
//DOC This fn returns ERROR_DDS_SUBNET_NOT_PRESENT if the subnet is not found.
DWORD
DhcpDsServerDelSubnet(                            // Delete the subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create obj
    IN      LPSTORE_HANDLE         hServer,       // server obj
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 ServerName,    // name of dhcp server 2 del off
    IN      DWORD                  IpAddress      // ip address of subnet to del
) ;


//DOC DhcpDsServerModifySubnet changes the subnet name, comment, state, mask
//DOC fields of the subnet.  Actually, currently, the mask should probably not
//DOC be changed, as no checks are performed in this case.  The address cannot
//DOC be changed.. If the subnet is not present, the error returned is
//DOC ERROR_DDS_SUBNET_NOT_PRESENT
DWORD
DhcpDsServerModifySubnet(                         // modify subnet info
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      LPDHCP_SUBNET_INFO     Info           // info on new subnet to create
) ;


//DOC DhcpDsServerEnumSubnets is not yet implemented.
DWORD
DhcpDsServerEnumSubnets(                          // get subnet list
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    OUT     LPDHCP_IP_ARRAY       *SubnetsArray   // give array of subnets
) ;


//DOC DhcpDsServerGetSubnetInfo is not yet implemented.
DWORD
DhcpDsServerGetSubnetInfo(                        // get info on subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DHCP_IP_ADDRESS        SubnetAddress, // address of subnet to get info for
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo     // o/p: allocated info
) ;


//DOC DhcpDsSubnetAddRangeOrExcl adds a range/excl to an existing subnet.
//DOC If there is a collision with between ranges, then the error code returned
//DOC is ERROR_DDS_POSSIBLE_RANGE_CONFLICT. Note that no checks are made for
//DOC exclusions though.  Also, if a RANGE is extended via this routine, then
//DOC there is no error returned, but a limitation currently is that multiple
//DOC ranges (two only right) cannot be simultaneously extended.
//DOC BUBGUG: The basic check of whether the range belongs in the subnet is
//DOC not done..
DWORD
DhcpDsSubnetAddRangeOrExcl(                       // add a range or exclusion
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  Start,         // start addr in range
    IN      DWORD                  End,           // end addr in range
    IN      BOOL                   RangeOrExcl    // TRUE ==> Range,FALSE ==> Excl
) ;


//DOC DhcpDsSubnetDelRangeOrExcl deletes a range or exclusion from off the ds.
//DOC To specify range, set the RangeOrExcl parameter to TRUE.
DWORD
DhcpDsSubnetDelRangeOrExcl(                       // del a range or exclusion
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  Start,         // start addr in range
    IN      DWORD                  End,           // end addr in range
    IN      BOOL                   RangeOrExcl    // TRUE ==> Range,FALSE ==> Excl
) ;


//DOC DhcpDsEnumRangesOrExcl is not yet implemented.
DWORD
DhcpDsEnumRangesOrExcl(                           // enum list of ranges 'n excl
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      BOOL                   RangeOrExcl,   // TRUE ==> Range, FALSE ==> Excl
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pRanges
) ;


//DOC DhcpDsSubnetAddReservation tries to add a reservation object in the DS.
//DOC Neither the ip address not hte hw-address must exist in the DS prior to this.
//DOC If they do exist, the error returned is ERROR_DDS_RESERVATION_CONFLICT.
//DOC No checks are made on the sanity of the address in this subnet..
DWORD
DhcpDsSubnetAddReservation(                       // add a reservation
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  ReservedAddr,  // reservation ip address to add
    IN      LPBYTE                 HwAddr,        // RAW [ethernet?] hw addr of the client
    IN      DWORD                  HwAddrLen,     // length in # of bytes of hw addr
    IN      DWORD                  ClientType     // client is BOOTP, DHCP, or both?
) ;


//DOC DhcpDsSubnetDelReservation deletes a reservation from the DS.
//DOC If the reservation does not exist, it returns ERROR_DDS_RESERVATION_NOT_PRESENT.
//DOC Reservations cannot be deleted by anything but ip address for now.
DWORD
DhcpDsSubnetDelReservation(                       // delete a reservation
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  ReservedAddr   // ip address to delete reserv. by
) ;


//DOC DhcpDsEnumReservations enumerates the reservations..
DWORD
DhcpDsEnumReservations(                           // enumerate reservations frm DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pReservations
) ;


//DOC DhcpDsEnumSubnetElements enumerates the list of subnet elements in a
//DOC subnet... such as IpRanges, Exclusions, Reservations..
//DOC
DWORD
DhcpDsEnumSubnetElements(
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DHCP_SUBNET_ELEMENT_TYPE ElementType, // what kind of elt to enum?
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *ElementInfo
) ;

//
// Allow Debug prints to ntsd or kd
//

#ifdef DBG
#define DsAuthPrint(_x_) DsAuthPrintRoutine _x_

VOID DsAuthPrintRoutine(
    LPWSTR Format,
    ...
);
 
#else
#define DsAuthPrint(_x_)
#endif


#endif 
//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\rpcstubs.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef CONVERT_NAMES
#define DhcpCreateSubnet DhcpCreateSubnetDS
#define DhcpSetSubnetInfo DhcpSetSubnetInfoDS
#define DhcpGetSubnetInfo DhcpGetSubnetInfoDS
#define DhcpEnumSubnets DhcpEnumSubnetsDS
#define DhcpDeleteSubnet DhcpDeleteSubnetDS
#define DhcpCreateOption DhcpCreateOptionDS
#define DhcpSetOptionInfo DhcpSetOptionInfoDS
#define DhcpGetOptionInfo DhcpGetOptionInfoDS
#define DhcpRemoveOption DhcpRemoveOptionDS
#define DhcpSetOptionValue DhcpSetOptionValueDS
#define DhcpGetOptionValue DhcpGetOptionValueDS
#define DhcpEnumOptionValues DhcpEnumOptionValuesDS
#define DhcpRemoveOptionValue DhcpRemoveOptionValueDS
#define DhcpEnumOptions DhcpEnumOptionsDS
#define DhcpSetOptionValues DhcpSetOptionValuesDS
#define DhcpAddSubnetElement DhcpAddSubnetElementDS
#define DhcpEnumSubnetElements DhcpEnumSubnetElementsDS
#define DhcpRemoveSubnetElement DhcpRemoveSubnetElementDS
#define DhcpAddSubnetElementV4 DhcpAddSubnetElementV4DS
#define DhcpEnumSubnetElementsV4 DhcpEnumSubnetElementsV4DS
#define DhcpRemoveSubnetElementV4 DhcpRemoveSubnetElementV4DS
#define DhcpSetSuperScopeV4 DhcpSetSuperScopeV4DS
#define DhcpGetSuperScopeInfoV4 DhcpGetSuperScopeInfoV4DS
#define DhcpDeleteSuperScopeV4 DhcpDeleteSuperScopeV4DS

#define DhcpSetClientInfo DhcpSetClientInfoDS
#define DhcpGetClientInfo DhcpGetClientInfoDS
#define DhcpSetClientInfoV4 DhcpSetClientInfoV4DS
#define DhcpGetClientInfoV4 DhcpGetClientInfoV4DS

#define DhcpCreateOptionV5 DhcpCreateOptionV5DS
#define DhcpSetOptionInfoV5 DhcpSetOptionInfoV5DS
#define DhcpGetOptionInfoV5 DhcpGetOptionInfoV5DS
#define DhcpEnumOptionsV5 DhcpEnumOptionsV5DS
#define DhcpRemoveOptionV5 DhcpRemoveOptionV5DS
#define DhcpSetOptionValueV5 DhcpSetOptionValueV5DS
#define DhcpSetOptionValuesV5 DhcpSetOptionValuesV5DS
#define DhcpGetOptionValueV5 DhcpGetOptionValueV5DS
#define DhcpEnumOptionValuesV5 DhcpEnumOptionValuesV5DS
#define DhcpRemoveOptionValueV5 DhcpRemoveOptionValueV5DS
#define DhcpCreateClass DhcpCreateClassDS
#define DhcpModifyClass DhcpModifyClassDS
#define DhcpDeleteClass DhcpDeleteClassDS
#define DhcpGetClassInfo DhcpGetClassInfoDS
#define DhcpEnumClasses DhcpEnumClassesDS
#define DhcpGetAllOptions DhcpGetAllOptionsDS
#define DhcpGetAllOptionValues DhcpGetAllOptionValuesDS

#endif  CONVERT_NAMES


//DOC Create an option in DS. Checkout DhcpDsCreateOptionDef for more info...
DWORD
DhcpCreateOptionV5(                               // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


//DOC Modify existing option's fields in the DS. See DhcpDsModifyOptionDef for more
//DOC details
DWORD
DhcpSetOptionInfoV5(                              // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


//DOC not yet supported at this level... (this is supported in a
//DOC DhcpDs function, no wrapper yet)
DWORD
DhcpGetOptionInfoV5(                              // retrieve option info from off ds structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory
) ;


//DOC See DhcpDsEnumOptionDefs for more info on this function.. but essentially, all this
//DOC does is to read thru the options and create a list of options..
DWORD
DhcpEnumOptionsV5(                                // create list of all options in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


//DOC Delete an option from off the DS. See DhcpDsDeleteOptionDef for
//DOC more details.
DWORD
DhcpRemoveOptionV5(                               // remove an option from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


//DOC Set the specified option value in the DS.  For more information,
//DOC see DhcpDsSetOptionValue.
DWORD
DhcpSetOptionValueV5(                             // set the option value in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


//DOC This function just calls the SetOptionValue function N times.. this is not
//DOC atomic (), but even worse, it is highly inefficient, as it creates the
//DOC required objects over and over again!!!!!
//DOC This has to be fixed..
DWORD
DhcpSetOptionValuesV5(                            // set a series of option values
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


//DOC This function retrives the value of an option from the DS.  For more info,
//DOC pl check DhcpDsGetOptionValue.
DWORD
DhcpGetOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue
) ;


//DOC Get the list of option values defined in DS. For more information,
//DOC check DhcpDsEnumOptionValues.
DWORD
DhcpEnumOptionValuesV5(                           // get list of options defined in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


//DOC Remove the option value from off the DS.  See DhcpDsRemoveOptionValue
//DOC for further information.
DWORD
DhcpRemoveOptionValueV5(                          // remove option value from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


//DOC Create a class in the DS.  Please see DhcpDsCreateClass for more
//DOC details on this function.
DWORD
DhcpCreateClass(                                  // create a class in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


//DOC Modify an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpModifyClass(                                  // modify existing class
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


//DOC Delete an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpDeleteClass(                                  // delete a class from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) ;


//DOC DhcpGetClassInfo completes the information provided for a class in struct
//DOC PartialClassInfo.  For more details pl see DhcpDsGetClassInfo.
DWORD
DhcpGetClassInfo(                                 // fetch complete info frm DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) ;


//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpEnumClasses(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) ;


//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) ;


//DOC This is implememented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptions(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) ;


DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
DhcpCreateOption(                                 // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpSetOptionInfo(                                // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
DhcpGetOptionInfo(                                // retrieve the information from off the mem structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpEnumOptions(                                  // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
DhcpRemoveOption(                                 // remove the option definition from the registry
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValue(                               // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
DhcpSetOptionValues(                              // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
DhcpGetOptionValue(                               // fetch the required option at required level
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
DhcpEnumOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
DhcpRemoveOptionValue(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


//DOC This function sets the superscope of a subnet, thereby creating the superscope
//DOC if required.  Please see DhcpDsSetSScope for more details.
DWORD
DhcpSetSuperScopeV4(                              // set superscope in DS.
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SuperScopeName,
    IN      BOOL                   ChangeExisting
) ;


//DOC This function removes the superscope, and resets any subnet with this
//DOC superscope.. so that all those subnets end up with no superscopes..
//DOC Please see DhcpDsDelSScope for more details.
DWORD
DhcpDeleteSuperScopeV4(                           // delete subnet sscope from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      LPWSTR                 SuperScopeName
) ;


//DOC This function retrievs the supercsope info for each subnet that is
//DOC present for the given server.  Please see DhcpDsGetSScopeInfo for more
//DOC details on this..
DWORD
DhcpGetSuperScopeInfoV4(                          // get sscope tbl from DS
    IN      LPWSTR                 ServerIpAddress,
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
) ;


//DOC This function creates a subnet in the DS with the specified params.
//DOC Please see DhcpDsServerAddSubnet for more details on this function.
DWORD
DhcpCreateSubnet(                                 // add subnet 2 DS for this srvr
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


//DOC Modify existing subnet with new parameters... some restrictions apply.
//DOC Please see DhcpDsServerModifySubnet for further details.
DWORD
DhcpSetSubnetInfo(                                // modify existing subnet params
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpGetSubnetInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo
) ;


//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpEnumSubnets(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      LPDHCP_IP_ARRAY       *EnumInfo,
    IN      DWORD                 *ElementsRead,
    IN      DWORD                 *ElementsTotal
) ;


//DOC This function deletes the subnet from the DS.  For further information, pl
//DOC see DhcpDsServerDelSubnet..
DWORD
DhcpDeleteSubnet(                                 // Del subnet from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


//DOC This function sets some particular information for RESERVATIONS only
//DOC all other stuff it just ignores and returns success..
DWORD
DhcpSetClientInfo(
    IN      LPWSTR                 ServerIpAddresess,
    IN      LPDHCP_CLIENT_INFO     ClientInfo
) ;


//DOC This function retrieves some particular client's information
//DOC for RESERVATIONS only.. For all other stuff it returns CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_SEARCH_INFO     SearchInfo,
    OUT      LPDHCP_CLIENT_INFO    *ClientInfo
) ;


//DOC This function sets the client informatoin for RESERVATIONS only in DS
//DOC For all toher clients it returns ERROR_SUCCESS w/o doing anything
DWORD
DhcpSetClientInfoV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_CLIENT_INFO_V4  ClientInfo
) ;


//DOC Thsi function sets the client information for RESERVATIONS only
//DOC For all others it returns ERROR_CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfoV4(
    IN     LPWSTR                  ServerIpAddress,
    IN     LPDHCP_SEARCH_INFO      SearchInfo,
    OUT    LPDHCP_CLIENT_INFO_V4  *ClientInfo
) ;


//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElement(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA  AddElementInfo
) ;


//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElementV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4  AddElementInfo
) ;


//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElementsV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElements(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElement(                          // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElementV4(                        // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


#ifndef CONVERT_NAMES
#undef DhcpCreateSubnet
#undef DhcpSetSubnetInfo
#undef DhcpGetSubnetInfo
#undef DhcpEnumSubnets
#undef DhcpDeleteSubnet
#undef DhcpCreateOption
#undef DhcpSetOptionInfo
#undef DhcpGetOptionInfo
#undef DhcpRemoveOption
#undef DhcpSetOptionValue
#undef DhcpGetOptionValue
#undef DhcpEnumOptionValues
#undef DhcpRemoveOptionValue
#undef DhcpEnumOptions
#undef DhcpSetOptionValues
#undef DhcpAddSubnetElementV4
#undef DhcpEnumSubnetElementsV4
#undef DhcpRemoveSubnetElementV4
#undef DhcpAddSubnetElement
#undef DhcpEnumSubnetElements
#undef DhcpRemoveSubnetElement
#undef DhcpSetSuperScopeV4
#undef DhcpGetSuperScopeInfoV4
#undef DhcpDeleteSuperScopeV4

#undef DhcpSetClientInfo
#undef DhcpGetClientInfo
#undef DhcpSetClientInfoV4
#undef DhcpGetClientInfoV4

#undef DhcpCreateOptionV5
#undef DhcpSetOptionInfoV5
#undef DhcpGetOptionInfoV5
#undef DhcpEnumOptionsV5
#undef DhcpRemoveOptionV5
#undef DhcpSetOptionValueV5
#undef DhcpSetOptionValuesV5
#undef DhcpGetOptionValueV5
#undef DhcpEnumOptionValuesV5
#undef DhcpRemoveOptionValueV5
#undef DhcpCreateClass
#undef DhcpModifyClass
#undef DhcpDeleteClass
#undef DhcpGetClassInfo
#undef DhcpEnumClasses
#undef DhcpGetAllOptions
#undef DhcpGetAllOptionValues
#endif CONVERT_NAMES


#define     DHCP_SERVER_ANOTHER_ENTERPRISE        0x01
typedef     DHCPDS_SERVER          DHCP_SERVER_INFO;
typedef     PDHCPDS_SERVER         PDHCP_SERVER_INFO;
typedef     LPDHCPDS_SERVER        LPDHCP_SERVER_INFO;

typedef     DHCPDS_SERVERS         DHCP_SERVER_INFO_ARRAY;
typedef     PDHCPDS_SERVERS        PDHCP_SERVER_INFO_ARRAY;
typedef     LPDHCPDS_SERVERS       LPDHCP_SERVER_INFO_ARRAY;


//DOC DhcpEnumServersDS lists the servers found in the DS along with the
//DOC addresses and other information.  The whole server is allocated as a blob,
//DOC and should be freed in one shot.  No parameters are currently used, other
//DOC than Servers which will be an OUT parameter only.
DWORD
DhcpEnumServersDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpAddServerDS adds a particular server to the DS.  If the server exists,
//DOC then, this returns error.  If the server does not exist, then this function
//DOC adds the server in DS, and also uploads the configuration from the server
//DOC to the ds.
DWORD
DhcpAddServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpDeleteServerDS deletes the servers from off the DS and recursively
//DOC deletes the server object..(i.e everything belonging to the server is deleted).
//DOC If the server does not exist, it returns an error.
DWORD
DhcpDeleteServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpDsInitDS initializes everything in this module.
DWORD
DhcpDsInitDS(
    DWORD                          Flags,
    LPVOID                         IdInfo
) ;


//DOC DhcpDsCleanupDS uninitiailzes everything in this module.
VOID
DhcpDsCleanupDS(
    VOID
) ;


//DOC This function is defined in validate.c
//DOC Only the stub is here.
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses OPTIONAL,
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone
);

//DOC DhcpDsGetLastUpdateTime is defined in upndown.c --> see there for more details.
DWORD
DhcpDsGetLastUpdateTime(                          // last update time for server
    IN      LPWSTR                 ServerName,    // this is server of interest
    IN OUT  LPFILETIME             Time           // fill in this w./ the time
);

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\sterr.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: per thread error status
//================================================================================

#include    <hdrmacro.h>

const
DWORD       nErrorsToStore         = 4;           // the size of the array is 1+nErrorsToStore
DWORD       StErrTlsIndex[5]       = { -1, -1, -1, -1, -1 };

//BeginExport(function)
DWORD
StErrInit(
    VOID
) //EndExport(function)
{
    return ERROR_SUCCESS;
}

//BeginExport(function)
VOID
StErrCleanup(
    VOID
) //EndExport(function)
{
}

//BeginExport(function)
VOID 
SetInternalFormatError(
    IN      DWORD                  Code,
    IN      BOOL                   ReallyDoIt
)
{
#ifdef DBG
    if(ReallyDoIt) {
//          printf("InternalError: %lx\n", Code);	
    }
#endif // DBG
}
//EndExport(function)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\sterr.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
StErrInit(
    VOID
) ;


VOID
StErrCleanup(
    VOID
) ;

VOID
SetInternalFormatError(
    IN      DWORD                  Code,
    IN      BOOL                   ReallyDoIt
);

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\store.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV (critical code borrowed from shirish koti)
//  Description: This makes somethings easy for accessing the DS.
//================================================================================

#include    <hdrmacro.h>
#include    <sterr.h>                             // error reporting stuff

enum        /* anonymous */ {
    REPEATED_ADDRESS1      = 0x01,                // dont start error code with zero!
    REPEATED_ADDRESS2,
    REPEATED_ADDRESS3,
    INVALID_ADDRESS1,
    INVALID_ADDRESS2,
    INVALID_ADDRESS3,
    REPEATED_ADSPATH,
    INVALID_ADSPATH,
    REPEATED_FLAGS1,
    REPEATED_FLAGS2,
    INVALID_FLAGS1,
    INVALID_FLAGS2,
    REPEATED_DWORD1,
    REPEATED_DWORD2,
    INVALID_DWORD1,
    INVALID_DWORD2,
    REPEATED_STRING1,
    REPEATED_STRING2,
    REPEATED_STRING3,
    REPEATED_STRING4,
    INVALID_STRING1,
    INVALID_STRING2,
    INVALID_STRING3,
    INVALID_STRING4,
    REPEATED_BINARY1,
    REPEATED_BINARY2,
    INVALID_BINARY1,
    INVALID_BINARY2,
    INVALID_ATTRIB_FIELD,
    INVALID_BINARY_CODING,
    UNEXPECTED_COLLECTION_TYPE,
    UNEXPECTED_INTERNAL_ERROR,
};

//
// Constants
//

// Retrive 256 rows per query
#define DHCPDS_DS_SEARCH_PAGESIZE 256


//================================================================================
//  structures
//================================================================================
//BeginExport(typedef)
typedef struct _STORE_HANDLE {                    // this is what is used almost always
    DWORD                          MustBeZero;    // for future use
    LPWSTR                         Location;      // where does this refer to?
    LPWSTR                         UserName;      // who is the user?
    LPWSTR                         Password;      // what is the password?
    DWORD                          AuthFlags;     // what permission was this opened with?
    HANDLE                         ADSIHandle;    // handle to within ADSI
    ADS_SEARCH_HANDLE              SearchHandle;  // any searches going on?
    LPVOID                         Memory;        // memory allocated for this call..
    DWORD                          MemSize;       // how much was really allocated?
    BOOL                           SearchStarted; // Did we start the search?
} STORE_HANDLE, *LPSTORE_HANDLE, *PSTORE_HANDLE;
//EndExport(typedef)

LPWSTR      _inline
MakeRootDSEString(                                // given DSDC or domain name, produce ROOT DSE name
    IN      LPWSTR                 Server
)
{
    LPWSTR                         RootDSE;

    if( NULL == Server ) {
        RootDSE = MemAlloc( sizeof(DEFAULT_LDAP_ROOTDSE) ) ;
        if( NULL == RootDSE ) return NULL;
        wcscpy(RootDSE, DEFAULT_LDAP_ROOTDSE);
        return RootDSE;
    }

    RootDSE = MemAlloc(sizeof(LDAP_PREFIX) + SizeString(Server,FALSE) + sizeof(ROOTDSE_POSTFIX));
    if( NULL == RootDSE ) return NULL;

    wcscpy(RootDSE, LDAP_PREFIX);
    wcscat(RootDSE, Server);
    wcscat(RootDSE, ROOTDSE_POSTFIX);

    return RootDSE;
}

LPWSTR      _inline
MakeServerLocationString(
    IN      LPWSTR                 Server,
    IN      LPWSTR                 Location
)
{
    LPWSTR                         RetVal;

    Require(Location);

    RetVal = MemAlloc(sizeof(LDAP_PREFIX) + sizeof(WCHAR) + SizeString(Server,FALSE) + SizeString(Location,FALSE));
    if( NULL == RetVal ) return NULL;

    wcscpy(RetVal, LDAP_PREFIX);
    if( NULL != Server ) {
        wcscat(RetVal, Server);
        wcscat(RetVal, L"/");
    }
    wcscat(RetVal, Location);

    return RetVal;
}

HRESULT
GetEnterpriseRootFromRootHandle(                  // given /ROOTDSE object handle, get enterprise config root handle..
    IN      HANDLE                 DSERootHandle,
    IN      LPWSTR                 Server,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    IN OUT  LPWSTR                *RootLocation,
    IN OUT  HANDLE                *hRoot
)
{
    HRESULT                        hResult;
    DWORD                          Chk;
    DWORD                          i, j;
    DWORD                          nAttributes;
    PADS_ATTR_INFO                 Attributes;
    BOOL                           Found;

    *RootLocation = NULL;
    hResult = ADSIGetObjectAttributes(
        DSERootHandle,
        (LPWSTR *)&constNamingContextString,
        1,
        &Attributes,
        &nAttributes
    );

    if( FAILED(hResult) ) return hResult;
    if( 0 == nAttributes ) {
        return E_ADS_PROPERTY_NOT_FOUND;
    }

    Found = FALSE;
    for( i = 0; i < Attributes->dwNumValues ; i ++ ) {
        if( Attributes->pADsValues[i].dwType != ADSTYPE_CASE_IGNORE_STRING &&
            Attributes->pADsValues[i].dwType != ADSTYPE_DN_STRING )
            continue;

        Chk = _wcsnicmp(
            ENT_ROOT_PREFIX,
            Attributes->pADsValues[i].CaseIgnoreString,
            ENT_ROOT_PREFIX_LEN
        );
        if( 0 == Chk ) break;
    }

    if( i < Attributes->dwNumValues ) {
        *RootLocation = MakeServerLocationString(
            Server,
            Attributes->pADsValues[i].CaseIgnoreString
        );
        Found = TRUE;
    }

    FreeADsMem(Attributes);
    if( FALSE == Found ) return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    if( NULL == *RootLocation ) return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

    hResult = ADSIOpenDSObject(
        *RootLocation,
        UserName,
        Password,
        AuthFlags,
        hRoot
    );

    if( SUCCEEDED(hResult) ) return S_OK;

    MemFree(*RootLocation);
    *RootLocation = NULL;
    return hResult;
}

DWORD
GetEnterpriseRootObject(                          // get the /ROOTDSE object's naming context object..
    IN      LPWSTR                 Server,        // domain controller name or domain dns name
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    IN OUT  LPWSTR                *RootLocation,  // what is the value of the nameingContext attrib that we used?
    IN OUT  HANDLE                *hRoot          // handle to the above object..
)
{
    DWORD                          Result;
    LPWSTR                         RootDSEString;
    LPWSTR                         RootEnterpriseString;
    HANDLE                         hRootDSE;
    HRESULT                        hResult;

    *RootLocation = NULL; *hRoot = NULL;
    RootDSEString = MakeRootDSEString(Server);
    if( NULL == RootDSEString ) return ERROR_NOT_ENOUGH_MEMORY;

    hResult = ADSIOpenDSObject(
        RootDSEString,
        UserName,
        Password,
        AuthFlags,
        &hRootDSE
    );
    MemFree(RootDSEString);

    if( FAILED(hResult) ) return ConvertHresult(hResult);

    hResult = GetEnterpriseRootFromRootHandle(
        hRootDSE,
        Server,
        UserName,
        Password,
        AuthFlags,
        RootLocation,
        hRoot
    );
    ADSICloseDSObject(hRootDSE);

    if( FAILED(hResult) ) return ConvertHresult(hResult);

    Require(hRoot && RootLocation);
    return ERROR_SUCCESS;
}

//================================================================================
//  exported functions
//================================================================================
//BeginExport(function)
DWORD
StoreInitHandle(                                  // initialize a handle
    IN OUT  STORE_HANDLE          *hStore,        // will be filled in with stuff..
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN      LPWSTR                 Domain,        // OPTIONAL NULL==>default Domain
    IN      LPWSTR                 UserName,      // OPTIONAL NULL==>default credentials
    IN      LPWSTR                 Password,      // OPTIONAL used only if UserName given
    IN      DWORD                  AuthFlags      // OPTIONAL 0 ==> default??????
) //EndExport(function)
{
    DWORD                          Result;
    DWORD                          Size;
    LPWSTR                         EnterpriseRootLocation;
    HANDLE                         RootServer;
    LPBYTE                         Memory;

    Result = GetEnterpriseRootObject(
        Domain,
        UserName,
        Password,
        AuthFlags,
        &EnterpriseRootLocation,
        &RootServer
    );
    if( ERROR_SUCCESS != Result) return Result;

    Require(RootServer && EnterpriseRootLocation);

    Size =  sizeof(LONG);
    Size += SizeString(UserName, FALSE);
    Size += SizeString(Password, FALSE);

    Memory = MemAlloc(Size);
    if( NULL == Memory ) {
        MemFree(EnterpriseRootLocation);
        ADSICloseDSObject(RootServer);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hStore->MemSize = Size;
    Size = sizeof(LONG);
    hStore->MustBeZero = 0;
    hStore->Location = EnterpriseRootLocation;
    hStore->UserName = (LPWSTR)&Memory[Size]; Size += SizeString(UserName, FALSE);
    hStore->Password = (LPWSTR)&Memory[Size]; Size += SizeString(Password, FALSE);
    hStore->AuthFlags = AuthFlags;
    hStore->ADSIHandle = RootServer;
    hStore->SearchHandle = NULL;
    hStore->Memory = Memory;

    if( NULL == UserName ) hStore->UserName = NULL;
    else wcscpy(hStore->UserName, UserName);
    if( NULL == Password ) hStore->Password = NULL;
    else wcscpy(hStore->Password,Password);

    return ERROR_SUCCESS;
}


//BeginExport(function)
DWORD
StoreCleanupHandle(                               // cleanup the handle
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) //EndExport(function)
{
    DWORD                          Result;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->Location, ERROR_INVALID_PARAMETER);

    MemFree(hStore->Location);
    MemFree(hStore->Memory);
    if(hStore->SearchHandle)
        ADSICloseSearchHandle(hStore->ADSIHandle, hStore->SearchHandle);
    ADSICloseDSObject(hStore->ADSIHandle);
//      memset(hStore, 0, sizeof(*hStore));
    hStore->Location = NULL;
    hStore->UserName = NULL;
    hStore->Password = NULL;
    hStore->AuthFlags = 0;
    hStore->ADSIHandle = 0;
    hStore->Memory = NULL;
    hStore->MemSize = 0;
//      hStore->SearchStarted = FALSE;

    return ERROR_SUCCESS;
}


//BeginExport(enum)
enum {
    StoreGetChildType,
    StoreGetAbsoluteSameServerType,
    StoreGetAbsoluteOtherServerType
} _StoreGetType;
//EndExport(enum)

DWORD
ConvertPath(                                      // convert a "CN=X" type spec to "LDAP://Server/CN=X"..
    IN      LPSTORE_HANDLE         hStore,        // needed to get the initial strings bits
    IN      DWORD                  StoreGetType,
    IN      LPWSTR                 PathIn,
    OUT     LPWSTR                *PathOut
)
{
    DWORD                          Size;
    DWORD                          PrefixSize;
    DWORD                          SuffixSize;
    LPWSTR                         TmpString;
    LPWSTR                         PrefixString;

    *PathOut = NULL;

    if( StoreGetChildType == StoreGetType ) {
        TmpString = PrefixString = hStore->Location;
        TmpString = wcschr(TmpString, L'/'); Require(TmpString); TmpString ++;
        TmpString = wcschr(TmpString, L'/'); Require(TmpString); TmpString ++;
        if( wcschr(TmpString, L'/') ) {
            TmpString = wcschr(TmpString, L'/'); TmpString ++;
        }
        PrefixSize = sizeof(WCHAR)*(DWORD)(TmpString - PrefixString );
        SuffixSize = SizeString(hStore->Location, FALSE)-PrefixSize;
    } else if( StoreGetAbsoluteSameServerType == StoreGetType ) {
        TmpString = PrefixString = hStore->Location;
        TmpString = wcschr(TmpString, L'/'); Require(TmpString); TmpString ++;
        TmpString = wcschr(TmpString, L'/'); Require(TmpString); TmpString ++;
        if( wcschr(TmpString, L'/') ) {
            TmpString = wcschr(TmpString, L'/'); TmpString ++;
        }
        PrefixSize = sizeof(WCHAR)*(DWORD)(TmpString - PrefixString );
        SuffixSize = 0;
    } else if( StoreGetAbsoluteOtherServerType == StoreGetType ) {
        PrefixSize = 0;                           // use the path given by the user
        SuffixSize = 0;
    } else {
        Require(FALSE);
        PrefixSize = SuffixSize = 0;
    }

    Size = PrefixSize + SuffixSize + SizeString(PathIn,FALSE) + sizeof(CONNECTOR) - sizeof(WCHAR);
    TmpString = MemAlloc(Size);
    if( NULL == TmpString ) return ERROR_NOT_ENOUGH_MEMORY;

    if( PrefixSize ) {
        memcpy((LPBYTE)TmpString, (LPBYTE)PrefixString, PrefixSize);
    }
    wcscpy((LPWSTR)(PrefixSize + (LPBYTE)TmpString), PathIn);
    if( SuffixSize ) {
        wcscat(TmpString, CONNECTOR);
        wcscat(TmpString, (LPWSTR)(PrefixSize+(LPBYTE)PrefixString));
    }

    *PathOut = TmpString;
    StoreTrace2("ConvertedPath: %ws\n", TmpString);
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreGetHandle(                                   // get handle to child object, absolute object..
    IN OUT  LPSTORE_HANDLE         hStore,        // this gets modified..
    IN      DWORD                  Reserved,
    IN      DWORD                  StoreGetType,  // same server? just a simple child?
    IN      LPWSTR                 Path,
    IN OUT  STORE_HANDLE          *hStoreOut      // new handle created..
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          Size;
    LPWSTR                         ConvertedPath;
    HANDLE                         ObjectHandle;
    LPBYTE                         Memory;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->Location, ERROR_INVALID_PARAMETER);
    AssertRet(Path, ERROR_INVALID_PARAMETER);
    AssertRet(hStoreOut, ERROR_INVALID_PARAMETER);

    Result = ConvertPath(hStore, StoreGetType, Path, &ConvertedPath);
    if( ERROR_SUCCESS != Result ) return Result;

    Require(ConvertedPath);
    Memory = MemAlloc(hStore->MemSize);
    if( NULL == Memory ) {
        MemFree(ConvertedPath);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hResult = ADSIOpenDSObject(
        ConvertedPath,
        hStore->UserName,
        hStore->Password,
        hStore->AuthFlags,
        &ObjectHandle
    );
    if( FAILED(hResult) ) {
        MemFree(ConvertedPath);
        MemFree(Memory);
        return ConvertHresult(hResult);
    }

    memcpy(Memory, hStore->Memory, hStore->MemSize);
    Size = sizeof(LONG);
    hStoreOut->MemSize = hStore->MemSize;
    hStoreOut->MustBeZero = 0;
    hStoreOut->Location = ConvertedPath;
    hStoreOut->UserName = (LPWSTR)&Memory[Size]; Size += SizeString(hStore->UserName, FALSE);
    hStoreOut->Password = (LPWSTR)&Memory[Size]; Size += SizeString(hStore->Password, FALSE);
    hStoreOut->AuthFlags = hStore->AuthFlags;
    hStoreOut->ADSIHandle = ObjectHandle;
    hStoreOut->SearchHandle = NULL;
    hStoreOut->Memory = Memory;

    if( NULL == hStore->UserName ) hStoreOut->UserName = NULL;
    if( NULL == hStore->Password ) hStoreOut->Password = NULL;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreSetSearchOneLevel(                          // search will return everything one level below
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) //EndExport(function)
{
    HRESULT                        hResult;
    ADS_SEARCHPREF_INFO            SearchPref[3];

    AssertRet(hStore && hStore->ADSIHandle, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);

    SearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    SearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[1].vValue.Integer = DHCPDS_DS_SEARCH_PAGESIZE;

    // Make it cache the results at the client side. This is
    // default, but try it anyway.
    SearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
    SearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
    SearchPref[2].vValue.Boolean = TRUE;

    hResult = ADSISetSearchPreference(
        /* hDSObject           */  hStore->ADSIHandle,
        /* pSearchPrefs        */  SearchPref,
        /* dwNumPrefs          */  2 // sizeof( SearchPref ) / sizeof( SearchPref[ 0 ])
    );

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreSetSearchSubTree(                            // search will return the subtree below in ANY order
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) //EndExport(function)
{
    HRESULT                        hResult;
    ADS_SEARCHPREF_INFO            SearchPref[3];

    AssertRet(hStore && hStore->ADSIHandle, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);

    SearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    SearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[1].vValue.Integer = DHCPDS_DS_SEARCH_PAGESIZE;

    // Make it cache the results at the client side. This is
    // default, but try it anyway.
    SearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
    SearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
    SearchPref[2].vValue.Boolean = TRUE;

    hResult = ADSISetSearchPreference(
        /* hDSObject           */  hStore->ADSIHandle,
        /* pSearchPrefs        */  SearchPref,
        /* dwNumPrefs          */  sizeof( SearchPref ) / sizeof( SearchPref[ 0 ])
    );

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreBeginSearch(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 SearchFilter
) //EndExport(function)
{
    HRESULT                        hResult;
    LPWSTR                         nameAttrib;

    nameAttrib = ATTRIB_NAME;
    AssertRet(hStore && hStore->ADSIHandle, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);
    hResult = ADSIExecuteSearch(
        hStore->ADSIHandle,
        SearchFilter,
        (LPWSTR *)&nameAttrib,
        1,
        &(hStore->SearchHandle)
    );

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    hStore->SearchStarted = FALSE;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreEndSearch(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) //EndExport(function)
{
    HRESULT                        hResult;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->SearchHandle, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);

    hResult = ADSICloseSearchHandle(hStore->ADSIHandle, hStore->SearchHandle);
    hStore->SearchHandle = NULL;

    hStore->SearchStarted = FALSE;
    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;
}


//BeginExport(function)
DWORD                                             // ERROR_NO_MORE_ITEMS if exhausted
StoreSearchGetNext(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    OUT     LPSTORE_HANDLE         hStoreOut
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;
    ADS_SEARCH_COLUMN              Column;
    LPWSTR                         ColumnName;

    AssertRet(hStore && hStore->ADSIHandle && hStoreOut, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);

    if ( !hStore->SearchStarted ) {
        hResult = ADSIGetFirstRow( hStore->ADSIHandle,
                                   hStore->SearchHandle
                                   );
        hStore->SearchStarted = TRUE;
    }
    else {
        hResult = ADSIGetNextRow( hStore->ADSIHandle,
                                  hStore->SearchHandle
                                  );
    }

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    if( S_ADS_NOMORE_ROWS == hResult ) return ERROR_NO_MORE_ITEMS;

    hResult = ADSIGetColumn(
        hStore->ADSIHandle,
        hStore->SearchHandle,
        ATTRIB_NAME,
        &Column
    );
    if( FAILED(hResult) ) {
        Require(FALSE);
        return ConvertHresult(hResult);
    }

    Require(1==Column.dwNumValues);               // single valued
    if( Column.pADsValues[0].dwType == ADSTYPE_DN_STRING ) {
        Require(Column.pADsValues[0].DNString);
        ColumnName = MakeColumnName(Column.pADsValues[0].DNString);
    } else if( Column.pADsValues[0].dwType == ADSTYPE_CASE_IGNORE_STRING ) {
        Require(Column.pADsValues[0].CaseIgnoreString);
        ColumnName = MakeColumnName(Column.pADsValues[0].CaseIgnoreString);
    } else {
        Require(FALSE);
        ColumnName = NULL;
    }
    
    if( NULL == ColumnName ) Result = ERROR_NOT_ENOUGH_MEMORY;
    else {
        Result = StoreGetHandle(
            hStore,
            Reserved,
            StoreGetChildType,
            ColumnName,
            hStoreOut
        );
        MemFree(ColumnName);
    }

    ADSIFreeColumn(
        hStore->ADSIHandle,
        &Column
    );

    return Result;
}

//BeginExport(function)
DWORD
StoreCreateObjectVA(                              // create a new object - var-args ending with ADSTYPE_INVALID
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 NewObjName,    // name of the new object -- must be "CN=name" types
    ...                                           // fmt is AttrType, AttrName, AttrValue [AttrValueLen]
) //EndExport(function)                           // LARGE_INTEGER type has hi_word followed by low_word
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          i;
    DWORD                          ArgType;
    DWORD                          nArgs;
    DWORD                          Arg1;
    va_list                        Args;
    PADS_ATTR_INFO                 Attributes;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(NewObjName, ERROR_INVALID_PARAMETER);

    nArgs = 0;
    va_start(Args, NewObjName);
    do {
        ArgType = va_arg(Args, DWORD);
        if( ADSTYPE_INVALID == ArgType ) break;
        ( void ) va_arg((Args), LPWSTR);                     // skip the name of attrib
        switch(ArgType) {
        case ADSTYPE_DN_STRING :
        case ADSTYPE_CASE_EXACT_STRING:
        case ADSTYPE_CASE_IGNORE_STRING:
        case ADSTYPE_PRINTABLE_STRING:
        case ADSTYPE_NUMERIC_STRING:
        case ADSTYPE_UTC_TIME:
        case ADSTYPE_OBJECT_CLASS:
            ( void ) va_arg(Args, LPWSTR);
            break;

        case ADSTYPE_BOOLEAN:
        case ADSTYPE_INTEGER:
            ( void ) va_arg(Args, DWORD);
            break;

        case ADSTYPE_OCTET_STRING:
            (void ) va_arg(Args, LPBYTE);
            (void ) va_arg(Args, DWORD);                  // additional DWORD values for these..
            break;
        case ADSTYPE_LARGE_INTEGER:
            (void ) va_arg(Args, LONG);
            (void ) va_arg(Args, LONG);                  // additional DWORD values for these..
            break;
        default:
            return ERROR_INVALID_PARAMETER;
        }
        nArgs ++;
    } while( 1 );

    if( 0 == nArgs ) {
        Attributes = NULL;
    } else {
        Attributes = MemAlloc(nArgs * sizeof(*Attributes));
        if( NULL == Attributes ) return ERROR_NOT_ENOUGH_MEMORY;

        memset(Attributes, 0, sizeof(*Attributes));
    }

    va_start(Args, NewObjName);
    for(i = 0; i < nArgs; i ++ ) {
        ArgType = va_arg(Args, DWORD);
        Require(ADSTYPE_INVALID != ArgType);

        Attributes[i].dwNumValues = 1;
        Attributes[i].pADsValues = MemAlloc(sizeof(*Attributes[i].pADsValues));
        if( NULL == Attributes[i].pADsValues ) {
            nArgs = i;
            goto Cleanup;
        }

        Attributes[i].pszAttrName = (LPWSTR)va_arg(Args, LPWSTR);
        Attributes[i].dwControlCode = ADS_ATTR_APPEND;
        Attributes[i].dwADsType = ArgType;
        Attributes[i].pADsValues[0].dwType = ArgType;

        switch(ArgType) {
        case ADSTYPE_DN_STRING :
            Attributes[i].pADsValues[0].DNString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_CASE_EXACT_STRING:
            Attributes[i].pADsValues[0].CaseExactString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_CASE_IGNORE_STRING:
            Attributes[i].pADsValues[0].CaseIgnoreString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_PRINTABLE_STRING:
            Attributes[i].pADsValues[0].PrintableString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_NUMERIC_STRING:
            Attributes[i].pADsValues[0].NumericString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_BOOLEAN:
            Attributes[i].pADsValues[0].Boolean = va_arg(Args,DWORD); break;
        case ADSTYPE_INTEGER:
            Attributes[i].pADsValues[0].Integer = va_arg(Args,DWORD); break;
        case ADSTYPE_OBJECT_CLASS:
            Attributes[i].pADsValues[0].ClassName = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_OCTET_STRING:
            Attributes[i].pADsValues[0].OctetString.lpValue = (LPBYTE)va_arg(Args,LPBYTE);
            Attributes[i].pADsValues[0].OctetString.dwLength = va_arg(Args, DWORD);
            break;
        case ADSTYPE_LARGE_INTEGER:
            Attributes[i].pADsValues[0].LargeInteger.HighPart = (LONG)va_arg(Args,LONG);
            Attributes[i].pADsValues[0].LargeInteger.LowPart = va_arg(Args, ULONG);
            break;
        case ADSTYPE_UTC_TIME:
            Attributes[i].pADsValues[0].UTCTime = *((ADS_UTC_TIME*)va_arg(Args,PVOID));
            break;
        default:
            nArgs = i;
            Result =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }


    hResult = ADSICreateDSObject(
        hStore->ADSIHandle,
        NewObjName,
        Attributes,
        nArgs
    );

    if( HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hResult ||
        HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS) == hResult ||
        E_ADS_OBJECT_EXISTS == hResult ) {
        Result = ERROR_ALREADY_EXISTS;
    } else if( FAILED(hResult) ) {
        Result = ConvertHresult(hResult);
    } else {
        Result = ERROR_SUCCESS;
    }

  Cleanup:

    if( NULL != Attributes ) {
        for( i = 0; i < nArgs ; i ++ ) {
            if( Attributes[i].pADsValues ) MemFree(Attributes[i].pADsValues);
        }
        MemFree(Attributes);
    }

    return Result;
}

//BeginExport(defines)
#define     StoreCreateObject      StoreCreateObjectVA
//EndExport(defines)


//BeginExport(function)
DWORD
StoreDeleteObject(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ObjectName
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(ObjectName, ERROR_INVALID_PARAMETER);

    hResult = ADSIDeleteDSObject(
        hStore->ADSIHandle,
        ObjectName
    );

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC StoreDeleteThisObject deletes the object defined by hStore,StoreGetType and ADsPath.
//DOC The refer to the object just the same way as for StoreGetHandle.
DWORD
StoreDeleteThisObject(                            // delete an object
    IN      LPSTORE_HANDLE         hStore,        // point of anchor frm which reference is done
    IN      DWORD                  Reserved,      // must be zero, reserved for future use
    IN      DWORD                  StoreGetType,  // path is relative, absolute or diff server?
    IN      LPWSTR                 Path           // ADsPath to the object or relative path
)   //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          Size;
    LPWSTR                         ConvertedPath, ChildNameStart,ChildNameEnd;
    LPWSTR                         ChildName;
    HANDLE                         ParentObject;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->Location, ERROR_INVALID_PARAMETER);
    AssertRet(Path, ERROR_INVALID_PARAMETER);

    Result = ConvertPath(hStore, StoreGetType, Path, &ConvertedPath);
    if( ERROR_SUCCESS != Result ) return Result;

    Require(ConvertedPath);
    ChildNameStart = wcschr(ConvertedPath, L'/'); Require(ChildNameStart); ChildNameStart++;
    ChildNameStart = wcschr(ChildNameStart, L'/'); Require(ChildNameStart); ChildNameStart++;
    if( wcschr(ChildNameStart, L'/') ) {
        ChildNameStart = wcschr(ChildNameStart, L'/'); 
        Require(ChildNameStart); ChildNameStart++;
    }
    ChildNameEnd = wcschr(ChildNameStart, L','); Require(ChildNameEnd); *ChildNameEnd++ = L'\0';

    ChildName = MemAlloc((DWORD)((LPBYTE)ChildNameEnd - (LPBYTE)ChildNameStart));
    if( NULL == ChildName ) {
        MemFree(ConvertPath);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(ChildName, ChildNameStart, (int)((LPBYTE)ChildNameEnd - (LPBYTE)ChildNameStart));
    wcscpy(ChildNameStart, ChildNameEnd);         // remove child name from ConvertPath

    hResult = ADSIOpenDSObject(                   // open the parent object
        ConvertedPath,
        hStore->UserName,
        hStore->Password,
        hStore->AuthFlags,
        &ParentObject
    );
    MemFree(ConvertedPath);

    if( FAILED(hResult) ) {
        MemFree(ChildName);
        return ConvertHresult(hResult);
    }

    hResult = ADSIDeleteDSObject(                 // delete the required child object
        ParentObject,
        ChildName
    );
    MemFree(ChildName);
    ADSICloseDSObject(ParentObject);              // free up handles and memory

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;                         // : need to have better error messages than this
}

//================================================================================
// dhcp specific stuff follow here..
//================================================================================

//BeginExport(typedef)
typedef     struct                 _EATTRIB {     // encapsulated attribute
    unsigned int                   Address1_present     : 1;
    unsigned int                   Address2_present     : 1;
    unsigned int                   Address3_present     : 1;
    unsigned int                   ADsPath_present      : 1;
    unsigned int                   StoreGetType_present : 1;
    unsigned int                   Flags1_present       : 1;
    unsigned int                   Flags2_present       : 1;
    unsigned int                   Dword1_present       : 1;
    unsigned int                   Dword2_present       : 1;
    unsigned int                   String1_present      : 1;
    unsigned int                   String2_present      : 1;
    unsigned int                   String3_present      : 1;
    unsigned int                   String4_present      : 1;
    unsigned int                   Binary1_present      : 1;
    unsigned int                   Binary2_present      : 1;

    DWORD                          Address1;      // character "i"
    DWORD                          Address2;      // character "j"
    DWORD                          Address3;      // character "k"
    LPWSTR                         ADsPath;       // character "p" "r" "l"
    DWORD                          StoreGetType;  // "p,r,l" ==> sameserver, child, otherserver
    DWORD                          Flags1;        // character "f"
    DWORD                          Flags2;        // character "g"
    DWORD                          Dword1;        // character "d"
    DWORD                          Dword2;        // character "e"
    LPWSTR                         String1;       // character "s"
    LPWSTR                         String2;       // character "t"
    LPWSTR                         String3;       // character "u"
    LPWSTR                         String4;       // character "v"
    LPBYTE                         Binary1;       // character "b"
    DWORD                          BinLen1;       // # of bytes of above
    LPBYTE                         Binary2;       // character "d"
    DWORD                          BinLen2;       // # of bytes of above
} EATTRIB, *PEATTRIB, *LPEATTRIB;
//EndExport(typedef)

//BeginExport(defines)
#define     IS_ADDRESS1_PRESENT(pEA)              ((pEA)->Address1_present)
#define     IS_ADDRESS1_ABSENT(pEA)               (!IS_ADDRESS1_PRESENT(pEA))
#define     ADDRESS1_PRESENT(pEA)                 ((pEA)->Address1_present = 1 )
#define     ADDRESS1_ABSENT(pEA)                  ((pEA)->Address1_present = 0 )

#define     IS_ADDRESS2_PRESENT(pEA)              ((pEA)->Address2_present)
#define     IS_ADDRESS2_ABSENT(pEA)               (!IS_ADDRESS2_PRESENT(pEA))
#define     ADDRESS2_PRESENT(pEA)                 ((pEA)->Address2_present = 1 )
#define     ADDRESS2_ABSENT(pEA)                  ((pEA)->Address2_present = 0 )

#define     IS_ADDRESS3_PRESENT(pEA)              ((pEA)->Address3_present)
#define     IS_ADDRESS3_ABSENT(pEA)               (!IS_ADDRESS3_PRESENT(pEA))
#define     ADDRESS3_PRESENT(pEA)                 ((pEA)->Address3_present = 1 )
#define     ADDRESS3_ABSENT(pEA)                  ((pEA)->Address3_present = 0 )

#define     IS_ADSPATH_PRESENT(pEA)               ((pEA)->ADsPath_present)
#define     IS_ADSPATH_ABSENT(pEA)                (!IS_ADSPATH_PRESENT(pEA))
#define     ADSPATH_PRESENT(pEA)                  ((pEA)->ADsPath_present = 1)
#define     ADSPATH_ABSENT(pEA)                   ((pEA)->ADsPath_present = 0)

#define     IS_STOREGETTYPE_PRESENT(pEA)          ((pEA)->StoreGetType_present)
#define     IS_STOREGETTYPE_ABSENT(pEA)           (!((pEA)->StoreGetType_present))
#define     STOREGETTYPE_PRESENT(pEA)             ((pEA)->StoreGetType_present = 1)
#define     STOREGETTYPE_ABSENT(pEA)              ((pEA)->StoreGetType_present = 0)

#define     IS_FLAGS1_PRESENT(pEA)                ((pEA)->Flags1_present)
#define     IS_FLAGS1_ABSENT(pEA)                 (!((pEA)->Flags1_present))
#define     FLAGS1_PRESENT(pEA)                   ((pEA)->Flags1_present = 1)
#define     FLAGS1_ABSENT(pEA)                    ((pEA)->Flags1_present = 0)

#define     IS_FLAGS2_PRESENT(pEA)                ((pEA)->Flags2_present)
#define     IS_FLAGS2_ABSENT(pEA)                 (!((pEA)->Flags2_present))
#define     FLAGS2_PRESENT(pEA)                   ((pEA)->Flags2_present = 1)
#define     FLAGS2_ABSENT(pEA)                    ((pEA)->Flags2_present = 0)

#define     IS_DWORD1_PRESENT(pEA)                ((pEA)->Dword1_present)
#define     IS_DWORD1_ABSENT(pEA)                 (!((pEA)->Dword1_present))
#define     DWORD1_PRESENT(pEA)                   ((pEA)->Dword1_present = 1)
#define     DWORD1_ABSENT(pEA)                    ((pEA)->Dword1_present = 0)

#define     IS_DWORD2_PRESENT(pEA)                ((pEA)->Dword2_present)
#define     IS_DWORD2_ABSENT(pEA)                 (!((pEA)->Dword2_present))
#define     DWORD2_PRESENT(pEA)                   ((pEA)->Dword2_present = 1)
#define     DWORD2_ABSENT(pEA)                    ((pEA)->Dword2_present = 0)

#define     IS_STRING1_PRESENT(pEA)               ((pEA)->String1_present)
#define     IS_STRING1_ABSENT(pEA)                (!((pEA)->String1_present))
#define     STRING1_PRESENT(pEA)                  ((pEA)->String1_present = 1)
#define     STRING1_ABSENT(pEA)                   ((pEA)->String1_present = 0)

#define     IS_STRING2_PRESENT(pEA)               ((pEA)->String2_present)
#define     IS_STRING2_ABSENT(pEA)                (!((pEA)->String2_present))
#define     STRING2_PRESENT(pEA)                  ((pEA)->String2_present = 1)
#define     STRING2_ABSENT(pEA)                   ((pEA)->String2_present = 0)

#define     IS_STRING3_PRESENT(pEA)               ((pEA)->String3_present)
#define     IS_STRING3_ABSENT(pEA)                (!((pEA)->String3_present))
#define     STRING3_PRESENT(pEA)                  ((pEA)->String3_present = 1)
#define     STRING3_ABSENT(pEA)                   ((pEA)->String3_present = 0)

#define     IS_STRING4_PRESENT(pEA)               ((pEA)->String4_present)
#define     IS_STRING4_ABSENT(pEA)                (!((pEA)->String4_present))
#define     STRING4_PRESENT(pEA)                  ((pEA)->String4_present = 1)
#define     STRING4_ABSENT(pEA)                   ((pEA)->String4_present = 0)

#define     IS_BINARY1_PRESENT(pEA)               ((pEA)->Binary1_present)
#define     IS_BINARY1_ABSENT(pEA)                (!((pEA)->Binary1_present))
#define     BINARY1_PRESENT(pEA)                  ((pEA)->Binary1_present = 1)
#define     BINARY1_ABSENT(pEA)                   ((pEA)->Binary1_present = 0)

#define     IS_BINARY2_PRESENT(pEA)               ((pEA)->Binary2_present)
#define     IS_BINARY2_ABSENT(pEA)                (!((pEA)->Binary2_present))
#define     BINARY2_PRESENT(pEA)                  ((pEA)->Binary2_present = 1)
#define     BINARY2_ABSENT(pEA)                   ((pEA)->Binary2_present = 0)
//EndExport(defines)

//BeginExport(inline)
BOOL        _inline
IsAnythingPresent(
    IN      PEATTRIB               pEA
)
{
    return IS_ADDRESS1_PRESENT(pEA)
    || IS_ADDRESS2_PRESENT(pEA)
    || IS_ADDRESS3_PRESENT(pEA)
    || IS_ADSPATH_PRESENT(pEA)
    || IS_STOREGETTYPE_PRESENT(pEA)
    || IS_FLAGS1_PRESENT(pEA)
    || IS_FLAGS2_PRESENT(pEA)
    || IS_DWORD1_PRESENT(pEA)
    || IS_DWORD2_PRESENT(pEA)
    || IS_STRING1_PRESENT(pEA)
    || IS_STRING2_PRESENT(pEA)
    || IS_STRING3_PRESENT(pEA)
    || IS_STRING4_PRESENT(pEA)
    || IS_BINARY1_PRESENT(pEA)
    || IS_BINARY2_PRESENT(pEA)
    ;
}
//EndExport(inline)

//BeginExport(inline)
BOOL        _inline
IsEverythingPresent(
    IN      PEATTRIB               pEA
)
{
    return IS_ADDRESS1_PRESENT(pEA)
    && IS_ADDRESS2_PRESENT(pEA)
    && IS_ADDRESS3_PRESENT(pEA)
    && IS_ADSPATH_PRESENT(pEA)
    && IS_STOREGETTYPE_PRESENT(pEA)
    && IS_FLAGS1_PRESENT(pEA)
    && IS_FLAGS2_PRESENT(pEA)
    && IS_DWORD1_PRESENT(pEA)
    && IS_DWORD2_PRESENT(pEA)
    && IS_STRING1_PRESENT(pEA)
    && IS_STRING2_PRESENT(pEA)
    && IS_STRING3_PRESENT(pEA)
    && IS_STRING4_PRESENT(pEA)
    && IS_BINARY1_PRESENT(pEA)
    && IS_BINARY2_PRESENT(pEA)
    ;
}
//EndExport(inline)

//BeginExport(inline)
VOID        _inline
EverythingPresent(
    IN      PEATTRIB               pEA
)
{
    ADDRESS1_PRESENT(pEA);
    ADDRESS2_PRESENT(pEA);
    ADDRESS3_PRESENT(pEA);
    ADSPATH_PRESENT(pEA);
    STOREGETTYPE_ABSENT(pEA);
    FLAGS1_PRESENT(pEA);
    FLAGS2_PRESENT(pEA);
    DWORD1_PRESENT(pEA);
    DWORD2_PRESENT(pEA);
    STRING1_PRESENT(pEA);
    STRING2_PRESENT(pEA);
    STRING3_PRESENT(pEA);
    STRING4_PRESENT(pEA);
    BINARY1_PRESENT(pEA);
    BINARY2_PRESENT(pEA);
}
//EndExport(inline)

//BeginExport(inline)
VOID        _inline
NothingPresent(
    IN      PEATTRIB               pEA
)
{
    ADDRESS1_ABSENT(pEA);
    ADDRESS2_ABSENT(pEA);
    ADDRESS3_ABSENT(pEA);
    ADSPATH_ABSENT(pEA);
    STOREGETTYPE_ABSENT(pEA);
    FLAGS1_ABSENT(pEA);
    FLAGS2_ABSENT(pEA);
    DWORD1_ABSENT(pEA);
    DWORD2_ABSENT(pEA);
    STRING1_ABSENT(pEA);
    STRING2_ABSENT(pEA);
    STRING3_ABSENT(pEA);
    STRING4_ABSENT(pEA);
    BINARY1_ABSENT(pEA);
    BINARY2_ABSENT(pEA);
}
//EndExport(inline)


const       char
ch_Address1          = L'i' ,
ch_Address2          = L'j' ,
ch_Address3          = L'k' ,
ch_ADsPath_relative  = L'r' ,
ch_ADsPath_absolute  = L'p' ,
ch_ADsPath_diff_srvr = L'l' ,
ch_Flags1            = L'f' ,
ch_Flags2            = L'g' ,
ch_Dword1            = L'd' ,
ch_Dword2            = L'e' ,
ch_String1           = L's' ,
ch_String2           = L't' ,
ch_String3           = L'u' ,
ch_String4           = L'v' ,
ch_Binary1           = L'b' ,
ch_Binary2           = L'c' ,
ch_FieldSep          = L'$' ;

DWORD
StringToIpAddress(                                // convert a string to an ip-address
    IN      LPWSTR                 String,
    IN OUT  DWORD                 *Address
)
{
    CHAR                           Buffer[20];    // large enough to hold any ip address stuff
    DWORD                          Count;
    LPSTR                          SkippedWhiteSpace;

    Count = wcstombs(Buffer, String, sizeof(Buffer) - 1); // save space for '\0'
    if( -1 == Count ) return ERROR_INVALID_DATA;
    Buffer[Count] = '\0';

    SkippedWhiteSpace = Buffer;
    while(( ' ' == *SkippedWhiteSpace || '\t' == *SkippedWhiteSpace) &&
          ( SkippedWhiteSpace < &Buffer[Count])) {
        SkippedWhiteSpace++;
    }

    *Address= ntohl(inet_addr(SkippedWhiteSpace));// address is in host order..
    if( '\0' == *SkippedWhiteSpace ) return ERROR_INVALID_DATA;

    return Count <= sizeof("000.000.000.000") ? ERROR_SUCCESS : ERROR_INVALID_DATA;
}

DWORD       _inline
StringToFlags(                                    // convert a string to a DWORD
    IN      LPWSTR                 String,
    IN OUT  DWORD                 *Flags
)
{
    DWORD                          Count;
    LPWSTR                         Remaining;

    *Flags = ntohl(wcstoul(String, &Remaining,0));// see input for # base. conv to host order

    if( *Remaining == L'\0' ) return ERROR_SUCCESS;
    return ERROR_INVALID_DATA;
}

BYTE        _inline
Hex(
    IN      WCHAR                  wCh
)
{
    if( wCh >= '0' && wCh <= '9' ) return wCh - '0';
    if( wCh >= 'A' && wCh <= 'F' ) return wCh - 'A' + 10;
    if( wCh >= 'a' && wCh <= 'f' ) return wCh - 'a' + 10;
    return 0x0F+1;                                // this means error!!!
}

DWORD       _inline
StringToBinary(                                   // inline conversion of a string to binary
    IN OUT  LPWSTR                 String,        // this string is mangled while converting
    IN OUT  LPBYTE                *Bytes,         // this ptr is set to some memory in String..
    IN OUT  DWORD                 *nBytes         // # of hex bytes copied into location Bytes
) {
    LPBYTE                         HexString;
    DWORD                          n;
    BYTE                           ch1, ch2;

    HexString = *Bytes = (LPBYTE)String;
    n = 0;

    while( *String != L'\0' ) {                   // look at each character
        ch1 = Hex(*String++);
        ch2 = Hex(*String++);
        if( ch1 > 0xF || ch2 > 0xF ) {            // invalid hex bytes for input?
            return ERROR_INVALID_DATA;
        }
        *HexString ++ = (ch1 << 4 ) | ch2;
        n ++;
    }
    *nBytes = n;

    return ERROR_SUCCESS;
}

DWORD
ConvertStringtoEAttrib(                           // parse and get the fields out
    IN OUT  LPWSTR                 String,        // may be destroyed in the process
    IN OUT  PEATTRIB               Attrib         // fill this in
)
{
    DWORD                          Result;
    DWORD                          Address;
    DWORD                          Flags;
    WCHAR                          ThisChar;
    LPWSTR                         ThisString;
    CHAR                           Dummy[20];
    WCHAR                          Sep;

    Require(Attrib);
    NothingPresent(Attrib);

    if( String ) StoreTrace2("ConvertStringtoEAttrib(%ws) called\n", String);
    Sep = ch_FieldSep;

    while(String && *String && (ThisChar = *String ++)) {
        ThisString = String;
        do {                                      // skip to the next attrib
            String = wcschr(String, Sep);
            if( NULL == String ) break;
            if( String[1] == Sep ) {              // double consequtive field-sep's stand for the real thing..
                wcscpy(String, &String[1]);       // remove one of the field-separators, and try looking for one lateron.
                String ++;
                continue;
            }
            *String++ = L'\0';                    // ok, got a real separator: mark that zero and prepare for next
            break;
        } while(1);                               // this could as well be while(0) ??

        if( ch_Address1 == ThisChar ) {           // this is address1
            SetInternalFormatError(REPEATED_ADDRESS1, IS_ADDRESS1_PRESENT(Attrib));
            Result = StringToIpAddress(
                ThisString,
                &Address
            );
            if( ERROR_SUCCESS != Result ) {       // should not happen
                SetInternalFormatError(INVALID_ADDRESS1, TRUE);
            } else {
                ADDRESS1_PRESENT(Attrib);
                Attrib->Address1 = Address;
                StoreTrace2("Found address1 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_Address2 == ThisChar ) {
            SetInternalFormatError(REPEATED_ADDRESS2, IS_ADDRESS2_PRESENT(Attrib));
            Result = StringToIpAddress(
                ThisString,
                &Address
            );
            if( ERROR_SUCCESS != Result ) {       // should not happen
                SetInternalFormatError(INVALID_ADDRESS2, TRUE);
            } else {
                ADDRESS2_PRESENT(Attrib);
                Attrib->Address2 = Address;
                StoreTrace2("Found address2 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_Address3 == ThisChar ) {
            SetInternalFormatError(REPEATED_ADDRESS3, IS_ADDRESS3_PRESENT(Attrib));
            Result = StringToIpAddress(
                ThisString,
                &Address
            );
            if( ERROR_SUCCESS != Result ) {       // should not happen
                SetInternalFormatError(INVALID_ADDRESS3, TRUE);
            } else {
                ADDRESS3_PRESENT(Attrib);
                Attrib->Address3 = Address;
                StoreTrace2("Found address3 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_ADsPath_relative == ThisChar ||
            ch_ADsPath_absolute == ThisChar ||
            ch_ADsPath_diff_srvr == ThisChar ) {
            SetInternalFormatError(REPEATED_ADSPATH, IS_ADSPATH_PRESENT(Attrib));
            ADSPATH_PRESENT(Attrib);
            STOREGETTYPE_PRESENT(Attrib);
            Attrib->ADsPath = ThisString;
            if( ch_ADsPath_relative == ThisChar )
                Attrib->StoreGetType = StoreGetChildType;
            else if(ch_ADsPath_absolute == ThisChar )
                Attrib->StoreGetType = StoreGetAbsoluteSameServerType;
            else if(ch_ADsPath_diff_srvr == ThisChar )
                Attrib->StoreGetType = StoreGetAbsoluteOtherServerType;
            StoreTrace3("Found path [%ld] [%ws]\n", Attrib->StoreGetType, ThisString);
            continue;
        }

        if( ch_String1 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING1, IS_STRING1_PRESENT(Attrib));
            STRING1_PRESENT(Attrib);
            Attrib->String1 = ThisString;
            StoreTrace2("Found string1 [%ws]\n", ThisString);
            continue;
        }

        if( ch_String2 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING2, IS_STRING2_PRESENT(Attrib));
            STRING2_PRESENT(Attrib);
            Attrib->String2 = ThisString;
            StoreTrace2("Found string2 [%ws]\n", ThisString);
            continue;
        }

        if( ch_String3 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING3, IS_STRING3_PRESENT(Attrib));
            STRING3_PRESENT(Attrib);
            Attrib->String3 = ThisString;
            StoreTrace2("Found string3 [%ws]\n", ThisString);
            continue;
        }

        if( ch_String4 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING4, IS_STRING4_PRESENT(Attrib));
            STRING4_PRESENT(Attrib);
            Attrib->String4 = ThisString;
            StoreTrace2("Found string4 [%ws]\n", ThisString);
            continue;
        }

        if( ch_Flags1 == ThisChar ) {
            SetInternalFormatError(REPEATED_FLAGS1, IS_FLAGS1_PRESENT(Attrib));
            Result = StringToFlags(
                ThisString,
                &Flags
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_FLAGS1, TRUE);
            } else {
                FLAGS1_PRESENT(Attrib);
                Attrib->Flags1 = Flags;
                StoreTrace2("Found flags1: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Flags2 == ThisChar ) {
            SetInternalFormatError(REPEATED_FLAGS2, IS_FLAGS2_PRESENT(Attrib));
            Result = StringToFlags(
                ThisString,
                &Flags
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_FLAGS2, TRUE);
            } else {
                FLAGS2_PRESENT(Attrib);
                Attrib->Flags2 = Flags;
                StoreTrace2("Found flags2: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Dword1 == ThisChar ) {
            SetInternalFormatError(REPEATED_DWORD1, IS_DWORD1_PRESENT(Attrib));
            Result = StringToFlags(
                ThisString,
                &Flags
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_DWORD1, TRUE);
            } else {
                DWORD1_PRESENT(Attrib);
                Attrib->Dword1 = Flags;
                StoreTrace2("Found dword1: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Dword2 == ThisChar ) {
            SetInternalFormatError(REPEATED_DWORD2, IS_DWORD2_PRESENT(Attrib));
            Result = StringToFlags(
                ThisString,
                &Flags
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_DWORD2, TRUE);
            } else {
                DWORD2_PRESENT(Attrib);
                Attrib->Dword2 = Flags;
                StoreTrace2("Found dword2: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Binary1 == ThisChar ) {
            SetInternalFormatError(REPEATED_BINARY1, IS_BINARY1_PRESENT(Attrib));
            Result = StringToBinary(
                ThisString,
                &Attrib->Binary1,
                &Attrib->BinLen1
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_BINARY1, TRUE);
                BINARY1_ABSENT(Attrib);
            } else {
                BINARY1_PRESENT(Attrib);
                StoreTrace2("Found Binary1 of length %ld\n", Attrib->BinLen1);
            }
            continue;
        }

        if( ch_Binary2 == ThisChar ) {
            SetInternalFormatError(REPEATED_BINARY2, IS_BINARY2_PRESENT(Attrib));
            Result = StringToBinary(
                ThisString,
                &Attrib->Binary2,
                &Attrib->BinLen2
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_BINARY2, TRUE);
                BINARY2_ABSENT(Attrib);
            } else {
                BINARY2_PRESENT(Attrib);
                StoreTrace2("Found Binary2 of length %ld\n", Attrib->BinLen2);
            }
            continue;
        }

        SetInternalFormatError(INVALID_ATTRIB_FIELD, TRUE);
    }

    return IsAnythingPresent(Attrib)? ERROR_SUCCESS : ERROR_INVALID_DATA;
}

BOOL        _inline
InvalidStringInBinary(                            // check if the given binary stream forms a LPWSTR
    IN      LPBYTE                 Data,
    IN      DWORD                  DataLen
)
{
    if( 0 == DataLen ) return TRUE;
    if( DataLen % sizeof(WCHAR) ) return TRUE;
    DataLen /= sizeof(WCHAR);
    if( L'\0' != ((LPWSTR)Data)[DataLen-1] ) return TRUE;
    return FALSE;
}

DWORD
ConvertBinarytoEAttrib(                           // parse and get the fields out
    IN OUT  LPBYTE                 Data,          // input free format data
    IN      DWORD                  DataLen,       // bytes for data length
    IN OUT  PEATTRIB               Attrib         // fill this in
)
{
    DWORD                          Result;
    DWORD                          Address;
    DWORD                          Flags;
    DWORD                          Offset;
    DWORD                          ThisDataLen;
    DWORD                          xDataLen;
    LPBYTE                         xData;
    LPBYTE                         ThisData;
    WCHAR                          ThisChar;
    CHAR                           Dummy[20];

    Require(Attrib);
    NothingPresent(Attrib);

    Offset = 0;
    while( Data && DataLen >= sizeof(BYTE) + sizeof(WORD) ) {
        ThisChar = ntohs(*(LPWORD)Data);
        Data += sizeof(WORD); DataLen -= sizeof(WORD);
        ThisDataLen = ntohs(*(LPWORD)Data);
        Data += sizeof(WORD); DataLen -= sizeof(WORD);
        if( ROUND_UP_COUNT(ThisDataLen, ALIGN_WORD) > DataLen ) {
            SetInternalFormatError(INVALID_BINARY_CODING, TRUE);
            break;
        }
        ThisData = Data;
        Data += ROUND_UP_COUNT(ThisDataLen, ALIGN_WORD);
        DataLen -= ROUND_UP_COUNT(ThisDataLen, ALIGN_WORD);

        if( ch_Address1 == ThisChar ) {           // this is address1
            SetInternalFormatError(REPEATED_ADDRESS1, IS_ADDRESS1_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_ADDRESS1, TRUE);
            } else {
                Address = ntohl(*(DWORD UNALIGNED *)ThisData);
                ADDRESS1_PRESENT(Attrib);
                Attrib->Address1 = Address;
                StoreTrace2("Found address1 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_Address2 == ThisChar ) {
            SetInternalFormatError(REPEATED_ADDRESS2, IS_ADDRESS2_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_ADDRESS2, TRUE);
            } else {
                Address = ntohl(*(DWORD UNALIGNED *)ThisData);
                ADDRESS2_PRESENT(Attrib);
                Attrib->Address2 = Address;
                StoreTrace2("Found address2 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_Address3 == ThisChar ) {
            SetInternalFormatError(REPEATED_ADDRESS3, IS_ADDRESS3_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_ADDRESS3, TRUE);
            } else {
                Address = ntohl(*(DWORD UNALIGNED *)ThisData);
                ADDRESS3_PRESENT(Attrib);
                Attrib->Address3 = Address;
                StoreTrace2("Found address3 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_ADsPath_relative == ThisChar ||
            ch_ADsPath_absolute == ThisChar ||
            ch_ADsPath_diff_srvr == ThisChar ) {
            SetInternalFormatError(REPEATED_ADSPATH, IS_ADSPATH_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_ADSPATH, TRUE);
                continue;
            }

            ADSPATH_PRESENT(Attrib);
            STOREGETTYPE_PRESENT(Attrib);
            Attrib->ADsPath = (LPWSTR)ThisData;
            if( ch_ADsPath_relative == ThisChar )
                Attrib->StoreGetType = StoreGetChildType;
            else if(ch_ADsPath_absolute == ThisChar )
                Attrib->StoreGetType = StoreGetAbsoluteSameServerType;
            else if(ch_ADsPath_diff_srvr == ThisChar )
                Attrib->StoreGetType = StoreGetAbsoluteOtherServerType;
            StoreTrace3("Found path [%ld] [%ws]\n", Attrib->StoreGetType, (LPWSTR)ThisData);
            continue;
        }

        if( ch_String1 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING1, IS_STRING1_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_STRING1, TRUE);
                continue;
            }
            STRING1_PRESENT(Attrib);
            Attrib->String1 = (LPWSTR)ThisData;
            StoreTrace2("Found string1 [%ws]\n", (LPWSTR)ThisData);
            continue;
        }

        if( ch_String2 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING2, IS_STRING2_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_STRING2, TRUE);
                continue;
            }
            STRING2_PRESENT(Attrib);
            Attrib->String2 = (LPWSTR)ThisData;
            StoreTrace2("Found string2 [%ws]\n", (LPWSTR)ThisData);
            continue;
        }

        if( ch_String3 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING3, IS_STRING3_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_STRING3, TRUE);
                continue;
            }
            STRING3_PRESENT(Attrib);
            Attrib->String3 = (LPWSTR)ThisData;
            StoreTrace2("Found string3 [%ws]\n", (LPWSTR)ThisData);
            continue;
        }

        if( ch_String4 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING4, IS_STRING4_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_STRING4, TRUE);
                continue;
            }
            STRING4_PRESENT(Attrib);
            Attrib->String4 = (LPWSTR)ThisData;
            StoreTrace2("Found string4 [%ws]\n", (LPWSTR)ThisData);
            continue;
        }

        if( ch_Flags1 == ThisChar ) {
            SetInternalFormatError(REPEATED_FLAGS1, IS_FLAGS1_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_FLAGS1, TRUE);
            } else {
                Flags = ntohl(*(DWORD UNALIGNED *)ThisData);
                FLAGS1_PRESENT(Attrib);
                Attrib->Flags1 = Flags;
                StoreTrace2("Found flags1: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Flags2 == ThisChar ) {
            SetInternalFormatError(REPEATED_FLAGS2, IS_FLAGS2_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_FLAGS2, TRUE);
            } else {
                Flags = ntohl(*(DWORD UNALIGNED *)ThisData);
                FLAGS2_PRESENT(Attrib);
                Attrib->Flags2 = Flags;
                StoreTrace2("Found flags2: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Dword1 == ThisChar ) {
            SetInternalFormatError(REPEATED_DWORD1, IS_DWORD1_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_DWORD1, TRUE);
            } else {
                Flags = ntohl(*(DWORD UNALIGNED *)ThisData);
                DWORD1_PRESENT(Attrib);
                Attrib->Dword1 = Flags;
                StoreTrace2("Found dword1: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Dword2 == ThisChar ) {
            SetInternalFormatError(REPEATED_DWORD2, IS_DWORD2_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_DWORD2, TRUE);
            } else {
                Flags = ntohl(*(DWORD UNALIGNED *)ThisData);
                DWORD2_PRESENT(Attrib);
                Attrib->Dword2 = Flags;
                StoreTrace2("Found dword2: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Binary1 == ThisChar ) {
            SetInternalFormatError(REPEATED_BINARY1, IS_BINARY1_PRESENT(Attrib));
            BINARY1_PRESENT(Attrib);
            Attrib->Binary1 = ThisData;
            Attrib->BinLen1 = ThisDataLen;
            StoreTrace2("Found %ld bytes of binary 1 data\n", ThisDataLen);
            continue;
        }

        if( ch_Binary2 == ThisChar ) {
            SetInternalFormatError(REPEATED_BINARY2, IS_BINARY2_PRESENT(Attrib));
            BINARY2_PRESENT(Attrib);
            Attrib->Binary2 = ThisData;
            Attrib->BinLen2 = ThisDataLen;
            StoreTrace2("Found %ld bytes of binary 2 data\n", ThisDataLen);
            continue;
        }

        SetInternalFormatError(INVALID_ATTRIB_FIELD, TRUE);
    }

    return IsAnythingPresent(Attrib) ? ERROR_SUCCESS: ERROR_INVALID_DATA;
}

PEATTRIB
CloneAttrib(
    IN      PEATTRIB               Attrib
)
{
    PEATTRIB                       RetVal;
    DWORD                          Size;

    Size = sizeof(*Attrib);
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->ADsPath));
    }
    if( IS_STRING1_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String1));
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String2));
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String3));
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String4));
    }

    if( IS_BINARY1_PRESENT(Attrib) ) Size += Attrib->BinLen1;
    if( IS_BINARY2_PRESENT(Attrib) ) Size += Attrib->BinLen2;

    RetVal = (PEATTRIB)MemAlloc(Size);
    if( NULL == RetVal ) return NULL;

    Size = sizeof(*Attrib);
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    *RetVal = *Attrib;

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        RetVal->ADsPath = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->ADsPath));
        wcscpy(RetVal->ADsPath, Attrib->ADsPath);
    }
    if( IS_STRING1_PRESENT(Attrib) ) {
        RetVal->String1 = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String1));
        wcscpy(RetVal->String1, Attrib->String1);
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        RetVal->String2 = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String2));
        wcscpy(RetVal->String2, Attrib->String2);
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        RetVal->String3 = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String3));
        wcscpy(RetVal->String3, Attrib->String3);
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        RetVal->String4 = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String4));
        wcscpy(RetVal->String4, Attrib->String4);
    }

    if( IS_BINARY1_PRESENT(Attrib) ) {
        RetVal->Binary1 = (Size + (LPBYTE)RetVal);
        Size += Attrib->BinLen1;
        memcpy(RetVal->Binary1, Attrib->Binary1, Attrib->BinLen1);
    }

    if( IS_BINARY2_PRESENT(Attrib) ) {
        RetVal->Binary2 = (Size + (LPBYTE)RetVal);
        Size += Attrib->BinLen2;
        memcpy(RetVal->Binary2, Attrib->Binary2, Attrib->BinLen2);
    }

    return RetVal;
}

DWORD
AddAttribToArray(
    IN OUT  PARRAY                 Array,
    IN      PEATTRIB               Attrib
)
{
    DWORD                          Result;

    Require(Attrib);

    Attrib = CloneAttrib(Attrib);
    if( NULL == Attrib) return ERROR_NOT_ENOUGH_MEMORY;
    Result = MemArrayAddElement(Array, (LPVOID)Attrib);
    if( ERROR_SUCCESS == Result ) return ERROR_SUCCESS;
    MemFree(Attrib);
    return Result;
}

BOOL        _inline
OnlyADsPathPresent(
    IN      PEATTRIB               pEA
)
{
    if( ! IS_ADSPATH_PRESENT(pEA) ) return FALSE;
    return IS_ADDRESS1_ABSENT(pEA)
    && IS_ADDRESS2_ABSENT(pEA)
    && IS_ADSPATH_ABSENT(pEA)
    && IS_STOREGETTYPE_ABSENT(pEA)
    && IS_FLAGS1_ABSENT(pEA)
    && IS_FLAGS2_ABSENT(pEA)
    && IS_STRING1_ABSENT(pEA)
    && IS_STRING2_ABSENT(pEA)
    && IS_BINARY1_ABSENT(pEA)
    && IS_BINARY2_ABSENT(pEA)
    ;
}

DWORD
StoreCollectAttributes(                           // fwd declaration
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,
    IN OUT  PARRAY                 ArrayToAddTo,
    IN      DWORD                  RecursionDepth
);

DWORD       _inline
StoreCollectAttributesInternal(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      PEATTRIB               Attrib,
    IN      LPWSTR                 AttribName,
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
)
{
    DWORD                          Result, Result2;
    STORE_HANDLE                   hStore2;

    if( 0 == RecursionDepth ) {
        Result = AddAttribToArray(ArrayToAddTo, Attrib);
        if( ERROR_SUCCESS != Result ) SetInternalFormatError(UNEXPECTED_INTERNAL_ERROR, TRUE);
        return ERROR_STACK_OVERFLOW;
    }

    StoreTrace2("Recursing to %ws\n", Attrib->ADsPath);
    Result = StoreGetHandle(
        hStore,
        /*Reserved*/ 0,
        Attrib->StoreGetType,
        Attrib->ADsPath,
        &hStore2
    );
    if( ERROR_SUCCESS != Result ) return Result;

    Result = StoreCollectAttributes(
        &hStore2,
        Reserved,
        AttribName,
        ArrayToAddTo,
        RecursionDepth-1
    );

    Result2 = StoreCleanupHandle( &hStore2, 0 );

    return Result;
}

//BeginExport(function)
DWORD
StoreCollectAttributes(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,    // this attrib must be some kind of a text string
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          Error;
    DWORD                          nAttributes;
    DWORD                          i;
    PADS_ATTR_INFO                 Attributes;
    LPWSTR                         Attribs[1];
    LPWSTR                         ThisAttribStr;
    EATTRIB                        ThisEAttrib;

    Attribs[0] = AttribName;
    Attributes = NULL;
    nAttributes = 0;
    hResult = ADSIGetObjectAttributes(
        hStore->ADSIHandle,
        Attribs,
        sizeof(Attribs)/sizeof(Attribs[0]),
        &Attributes,
        &nAttributes
    );
    if( HRESULT_FROM_WIN32( ERROR_DS_NO_ATTRIBUTE_OR_VALUE) == hResult ) {
        return ERROR_SUCCESS;
    }

    if( FAILED(hResult) ) return ConvertHresult(hResult);

    if( 0 == nAttributes || NULL == Attributes )
        return ERROR_SUCCESS;

    Require( 1 == nAttributes );
    Error = ERROR_SUCCESS;

    for( i = 0; i < Attributes[0].dwNumValues ; i ++ ) {
        switch(Attributes[0].pADsValues[i].dwType) {
        case ADSTYPE_DN_STRING:
            ThisAttribStr = Attributes[0].pADsValues[i].DNString; break;
        case ADSTYPE_CASE_EXACT_STRING:
            ThisAttribStr = Attributes[0].pADsValues[i].CaseExactString; break;
        case ADSTYPE_CASE_IGNORE_STRING:
            ThisAttribStr = Attributes[0].pADsValues[i].CaseIgnoreString; break;
        case ADSTYPE_PRINTABLE_STRING:
            ThisAttribStr = Attributes[0].pADsValues[i].PrintableString; break;
        default:
            SetInternalFormatError(UNEXPECTED_COLLECTION_TYPE, TRUE);
            continue;
        }
        Require(ThisAttribStr);
        Result = ConvertStringtoEAttrib(ThisAttribStr, &ThisEAttrib);
        if( ERROR_SUCCESS == Result ) {
            if( OnlyADsPathPresent(&ThisEAttrib) ) {
                Result = StoreCollectAttributesInternal(
                    hStore,
                    Reserved,
                    &ThisEAttrib,
                    AttribName,
                    ArrayToAddTo,
                    RecursionDepth
                );
            } else {
                Result = AddAttribToArray(ArrayToAddTo, &ThisEAttrib);
            }
            if( ERROR_SUCCESS != Result ) Error = Result;
        } else Error = Result;
    }

    FreeADsMem(Attributes);

    return Error;
}

DWORD
StoreCollectBinaryAttributes(                     // fwd declaration
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,
    IN OUT  PARRAY                 ArrayToAddTo,
    IN      DWORD                  RecursionDepth
);

DWORD       _inline
StoreCollectBinaryAttributesInternal(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      PEATTRIB               Attrib,
    IN      LPWSTR                 AttribName,
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
)
{
    DWORD                          Result, Result2;
    STORE_HANDLE                   hStore2;

    if( 0 == RecursionDepth ) {
        Result = AddAttribToArray(ArrayToAddTo, Attrib);
        if( ERROR_SUCCESS != Result ) SetInternalFormatError(UNEXPECTED_INTERNAL_ERROR, TRUE);
        return ERROR_STACK_OVERFLOW;
    }

    StoreTrace2("Recursing to %ws\n", Attrib->ADsPath);
    Result = StoreGetHandle(
        hStore,
        /*Reserved*/ 0,
        Attrib->StoreGetType,
        Attrib->ADsPath,
        &hStore2
    );
    if( ERROR_SUCCESS != Result ) return Result;

    Result = StoreCollectBinaryAttributes(
        &hStore2,
        Reserved,
        AttribName,
        ArrayToAddTo,
        RecursionDepth-1
    );

    Result2 = StoreCleanupHandle( &hStore2, 0 );

    return Result;
}

//BeginExport(function)
DWORD
StoreCollectBinaryAttributes(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,    // accept only attrib type OCTET_STRING
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          Error;
    DWORD                          nAttributes;
    DWORD                          i;
    DWORD                          DataLength;
    PADS_ATTR_INFO                 Attributes;
    LPWSTR                         Attribs[1];
    LPBYTE                         Data;
    EATTRIB                        ThisEAttrib;

    Attribs[0] = AttribName;
    Attributes = NULL;
    nAttributes = 0;
    hResult = ADSIGetObjectAttributes(
        hStore->ADSIHandle,
        Attribs,
        sizeof(Attribs)/sizeof(Attribs[0]),
        &Attributes,
        &nAttributes
    );

    if( HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) == hResult ) {
        return ERROR_SUCCESS;
    }
    if( FAILED(hResult) ) return ConvertHresult(hResult);

    if( 0 == nAttributes || NULL == Attributes )
        return ERROR_SUCCESS;

    Require( 1 == nAttributes );
    Error = ERROR_SUCCESS;

    for( i = 0; i < Attributes[0].dwNumValues ; i ++ ) {
        if( ADSTYPE_OCTET_STRING != Attributes[0].pADsValues[i].dwType ) {
            SetInternalFormatError(UNEXPECTED_COLLECTION_TYPE, TRUE);
            continue;
        }

        Data = Attributes[0].pADsValues[i].OctetString.lpValue;
        DataLength = Attributes[0].pADsValues[i].OctetString.dwLength;

        Result = ConvertBinarytoEAttrib(Data, DataLength, &ThisEAttrib);
        if( ERROR_SUCCESS == Result ) {
            if( OnlyADsPathPresent(&ThisEAttrib) ) {
                Result = StoreCollectBinaryAttributesInternal(
                    hStore,
                    Reserved,
                    &ThisEAttrib,
                    AttribName,
                    ArrayToAddTo,
                    RecursionDepth
                );
            } else {
                Result = AddAttribToArray(ArrayToAddTo, &ThisEAttrib);
            }
            if( ERROR_SUCCESS != Result ) Error = Result;
        } else Error = Result;
    }

    FreeADsMem(Attributes);

    return Error;
}

DWORD       _inline
SizeAfterSeparation(                              // the field separation character has to doubled.
    IN      LPWSTR                 String,        // string with field separation character not escape'ed.
    IN      WCHAR                  Sep
)
{
    DWORD                          RetVal;

    RetVal = wcslen(String);
    while(String = wcschr(String, Sep ) ) {
        RetVal ++;
    }

    return RetVal;
}

LPWSTR
ConvertStringToString(                            // duplicate any field_sep characters found
    IN      LPWSTR                 InStr,
    IN      WCHAR                  PrefixChar,
    IN      LPWSTR                 Str,           // copy into this pre-allocated buffer
    IN      WCHAR                  Sep
)
{
    *Str++ = PrefixChar;
    while( *InStr ) {
        if( Sep != *InStr ) {
            *Str ++ = *InStr;
        } else {
            *Str ++ = Sep;
            *Str ++ = Sep;
        }
        InStr ++;
    }

    *Str = L'\0';
    return Str;
}

LPWSTR                                            // Return the ptr to where the '\0' is stored
ConvertAddressToString(                           // convert ip address to dotted notation LPWSTR
    IN      DWORD                  Address,
    IN      WCHAR                  PrefixChar,
    IN      LPWSTR                 Str            // copy into this pre-allocated buffer
)
{
    LPSTR                          AsciiStr;

    Address = htonl(Address);                     // convert to n/w order before making string..
    *Str ++ = PrefixChar;
    AsciiStr = inet_ntoa(*(struct in_addr *)&Address);

    while( *Str ++ = (WCHAR) *AsciiStr ++ )
        ;

    Str --; *Str = L'\0';
    return Str;
}

LPWSTR
ConvertDwordToString(                             // convert a DWORD to string in 0x.... fmt
    IN      DWORD                  Dword,
    IN      WCHAR                  PrefixChar,
    IN      LPWSTR                 Str            // copy into this pre-allocated buffer
)
{
    UCHAR                          Ch;
    LPWSTR                         Stream;
    INT                            i;

    Dword = htonl(Dword);                         // convert to n/w order before making string.
    *Str ++ = PrefixChar;
    *Str ++ = L'0'; *Str ++ = L'x' ;

    Stream = Str; Str += sizeof(Dword)*2;
    for( i = sizeof(Dword); i ; i -- ) {
        Ch = (BYTE)(Dword & 0x0F);
        Dword >>= 4;
        Stream[i*2 -1] = (Ch < 10)? (L'0'+Ch) : (Ch-10 + L'A');
        Ch = (BYTE)(Dword & 0x0F);
        Dword >>= 4;
        Stream[i*2 -2] = (Ch < 10)? (L'0'+Ch) : (Ch-10 + L'A');
    }
    *Str = L'\0';
    return Str;
}

LPWSTR
ConvertBinaryToString(                            // convert a binary byte sequence to a string as 0F321B etc..
    IN      LPBYTE                 Bytes,
    IN      DWORD                  nBytes,
    IN      WCHAR                  PrefixChar,
    IN      LPWSTR                 Str
)
{
    BYTE                           Ch, Ch1, Ch2;
    DWORD                          i;

    *Str ++ = PrefixChar;

    for( i = 0;  i < nBytes; i ++ ) {
        Ch = *Bytes ++;
        Ch1 = Ch >> 4;
        Ch2 = Ch & 0x0F;

        if( Ch1 >= 10 ) *Str ++ = Ch1 - 10 + L'A';
        else *Str ++ = Ch1 + L'0';

        if( Ch2 >= 10 ) *Str ++ = Ch2 - 10 + L'A';
        else *Str ++ = Ch2 + L'0';
    }

    *Str = L'\0';
    return Str;
}

DWORD
ConvertEAttribToString(                           // inverse of ConvertStringtoEAttrib
    IN      PEATTRIB               Attrib,        // the attrib to encapsulate
    IN OUT  LPWSTR                *String,        // allocated string
    IN      WCHAR                  Sep
)
{
    DWORD                          nChars;
    LPWSTR                         Str;
    WCHAR                          PrefixChar;
    
    AssertRet(String && Attrib, ERROR_INVALID_PARAMETER);
    *String = NULL;

    nChars = 0;
    if( IS_ADDRESS1_PRESENT(Attrib) ) nChars += sizeof(L"$i000.000.000.000");
    if( IS_ADDRESS2_PRESENT(Attrib) ) nChars += sizeof(L"$j000.000.000.000");
    if( IS_ADDRESS3_PRESENT(Attrib) ) nChars += sizeof(L"$k000.000.000.000");

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        AssertRet( IS_STOREGETTYPE_PRESENT(Attrib), ERROR_INVALID_PARAMETER );
        AssertRet( Attrib->ADsPath, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->ADsPath,Sep);
        nChars += sizeof(L"$p");
    }

    if( IS_FLAGS1_PRESENT(Attrib) ) nChars += sizeof(L"$f0x") + sizeof(DWORD)*2*sizeof(WCHAR);
    if( IS_FLAGS2_PRESENT(Attrib) ) nChars += sizeof(L"$g0x") + sizeof(DWORD)*2*sizeof(WCHAR);
    if( IS_DWORD1_PRESENT(Attrib) ) nChars += sizeof(L"$d0x") + sizeof(DWORD)*2*sizeof(WCHAR);
    if( IS_DWORD2_PRESENT(Attrib) ) nChars += sizeof(L"$e0x") + sizeof(DWORD)*2*sizeof(WCHAR);

    if( IS_STRING1_PRESENT(Attrib) ) {
        AssertRet( Attrib->String1, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->String1,Sep);
        nChars += sizeof(L"$s");
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        AssertRet( Attrib->String2, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->String2,Sep);
        nChars += sizeof(L"$t");
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        AssertRet( Attrib->String3, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->String3,Sep);
        nChars += sizeof(L"$u");
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        AssertRet( Attrib->String4, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->String4,Sep);
        nChars += sizeof(L"$v");
    }

    if( IS_BINARY1_PRESENT(Attrib) ) {
        nChars += sizeof(WCHAR) * 2 * Attrib->BinLen1;
        nChars += sizeof(L"$b");
    }

    if( IS_BINARY2_PRESENT(Attrib) ) {
        nChars += sizeof(WCHAR) * 2 * Attrib->BinLen2;
        nChars += sizeof(L"$c");
    }

    if( 0 == nChars ) return ERROR_SUCCESS;       // nothing is present really.

    Str = MemAlloc(nChars + sizeof(L"") );        // take care of terminating the string
    if( NULL == Str ) return ERROR_NOT_ENOUGH_MEMORY;

    *String = Str;                                // save the return value, as Str keeps changing
    if( IS_ADDRESS1_PRESENT(Attrib) ) {
        Str = ConvertAddressToString(Attrib->Address1, ch_Address1, Str);
        *Str++ = Sep;
    }
    if( IS_ADDRESS2_PRESENT(Attrib) ) {
        Str = ConvertAddressToString(Attrib->Address2, ch_Address2, Str);
        *Str++ = Sep;
    }
    if( IS_ADDRESS3_PRESENT(Attrib) ) {
        Str = ConvertAddressToString(Attrib->Address3, ch_Address3, Str);
        *Str++ = Sep;
    }

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        switch(Attrib->StoreGetType) {
        case StoreGetChildType:
            PrefixChar = ch_ADsPath_relative; break;
        case StoreGetAbsoluteSameServerType:
            PrefixChar = ch_ADsPath_absolute; break;
        case StoreGetAbsoluteOtherServerType:
            PrefixChar = ch_ADsPath_diff_srvr; break;
        default:
            Require(FALSE);                       // too late to do anything about this now.
            PrefixChar = ch_ADsPath_diff_srvr; break;
        }
        Str = ConvertStringToString(Attrib->ADsPath, PrefixChar, Str,Sep);
        *Str++ = Sep;
    }

    if( IS_FLAGS1_PRESENT(Attrib) ) {
        Str = ConvertDwordToString(Attrib->Flags1, ch_Flags1, Str);
        *Str++ = Sep;
    }
    if( IS_FLAGS2_PRESENT(Attrib) ) {
        Str = ConvertDwordToString(Attrib->Flags2, ch_Flags2, Str);
        *Str++ = Sep;
    }
    if( IS_DWORD1_PRESENT(Attrib) ) {
        Str = ConvertDwordToString(Attrib->Dword1, ch_Dword1, Str);
        *Str++ = Sep;
    }
    if( IS_DWORD2_PRESENT(Attrib) ) {
        Str = ConvertDwordToString(Attrib->Dword2, ch_Dword2, Str);
        *Str++ = Sep;
    }

    if( IS_STRING1_PRESENT(Attrib) ) {
        Str = ConvertStringToString(Attrib->String1, ch_String1, Str,Sep);
        *Str++ = Sep;
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        Str = ConvertStringToString(Attrib->String2, ch_String2, Str,Sep);
        *Str++ = Sep;
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        Str = ConvertStringToString(Attrib->String3, ch_String3, Str,Sep);
        *Str++ = Sep;
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        Str = ConvertStringToString(Attrib->String4, ch_String4, Str,Sep);
        *Str++ = Sep;
    }
    if( IS_BINARY1_PRESENT(Attrib) ) {
        Str = ConvertBinaryToString(Attrib->Binary1, Attrib->BinLen1, ch_Binary1, Str);
        *Str++ = Sep;
    }
    if( IS_BINARY2_PRESENT(Attrib) ) {
        Str = ConvertBinaryToString(Attrib->Binary2, Attrib->BinLen2, ch_Binary2, Str);
    }

    *Str = L'\0';
    Require(((LPBYTE)Str) < nChars + 1 + ((LPBYTE)(*String)) );

    return ERROR_SUCCESS;
}

LPBYTE
ConvertDwordToBinary(                             // pack a DWORD in binary format
    IN      DWORD                  Dword,
    IN      WCHAR                  Character,
    IN      LPBYTE                 Buffer
)
{
    *(LPWORD)Buffer = htons(Character); Buffer += sizeof(WORD);
    *(LPWORD)Buffer = htons(sizeof(DWORD)); Buffer += sizeof(WORD);
    *(DWORD UNALIGNED *)Buffer = htonl(Dword);
    Buffer += sizeof(DWORD);
    return Buffer;
}

LPBYTE
ConvertAddressToBinary(                           // pack an address to binary format..
    IN      DWORD                  Address,
    IN      WCHAR                  Character,
    IN      LPBYTE                 Buffer
)
{
    return ConvertDwordToBinary(Address,Character,Buffer);
}

LPBYTE
ConvertStringToBinary(                            // pack a string in binary format
    IN      LPWSTR                 Str,
    IN      WCHAR                  Character,
    IN      LPBYTE                 Buffer
)
{
    DWORD                          Size;

    Size = sizeof(WCHAR)*(1+wcslen(Str));

    *(LPWORD)Buffer = htons(Character); Buffer += sizeof(WORD);
    *(LPWORD)Buffer = htons((WORD)Size); Buffer += sizeof(WORD);
    memcpy(Buffer, Str, Size);
    Buffer += ROUND_UP_COUNT(Size, ALIGN_WORD);

    return Buffer;
}

DWORD
ConvertEAttribToBinary(                           // inverse of ConvertBinarytoEAttrib
    IN      PEATTRIB               Attrib,        // the attrib to encapsulate
    IN OUT  LPBYTE                *Bytes,         // allocated buffer
    IN OUT  DWORD                 *nBytes         // # of bytes allocated
)
{
    DWORD                          nChars;
    LPBYTE                         Buf;
    WCHAR                          PrefixChar;

    AssertRet(Bytes && Attrib && nBytes, ERROR_INVALID_PARAMETER);
    *Bytes = NULL; *nBytes =0;

    nChars = 0;                                   // WCHAR_opcode ~ WORD_size ~ DWORD_ipAddress
    if( IS_ADDRESS1_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_ADDRESS2_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_ADDRESS3_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        AssertRet( IS_STOREGETTYPE_PRESENT(Attrib), ERROR_INVALID_PARAMETER );
        AssertRet( Attrib->ADsPath, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1+ wcslen(Attrib->ADsPath));
    }

                                                  // WCHAR_opcode ~ WORD_size ~ DWORD_flags
    if( IS_FLAGS1_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_FLAGS2_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_DWORD1_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_DWORD2_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);

    if( IS_STRING1_PRESENT(Attrib) ) {
        AssertRet( Attrib->String1, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1 + wcslen(Attrib->String1));
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        AssertRet( Attrib->String2, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1 + wcslen(Attrib->String2));
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        AssertRet( Attrib->String3, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1 + wcslen(Attrib->String3));
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        AssertRet( Attrib->String4, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1 + wcslen(Attrib->String4));
    }

    if( IS_BINARY1_PRESENT(Attrib) ) {
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += ROUND_UP_COUNT(Attrib->BinLen1, ALIGN_WORD);
    }

    if( IS_BINARY2_PRESENT(Attrib) ) {
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += ROUND_UP_COUNT(Attrib->BinLen2, ALIGN_WORD);
    }

    if( 0 == nChars ) return ERROR_SUCCESS;       // nothing is present really.

    Buf = MemAlloc(nChars);
    if( NULL == Buf ) return ERROR_NOT_ENOUGH_MEMORY;

    *Bytes = Buf;                                 // save the return value.. Buf itself is changed..
    *nBytes = nChars;
    if( IS_ADDRESS1_PRESENT(Attrib) ) Buf = ConvertAddressToBinary(Attrib->Address1, ch_Address1, Buf);
    if( IS_ADDRESS2_PRESENT(Attrib) ) Buf = ConvertAddressToBinary(Attrib->Address2, ch_Address2, Buf);
    if( IS_ADDRESS3_PRESENT(Attrib) ) Buf = ConvertAddressToBinary(Attrib->Address3, ch_Address3, Buf);

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        switch(Attrib->StoreGetType) {
        case StoreGetChildType:
            PrefixChar = ch_ADsPath_relative; break;
        case StoreGetAbsoluteSameServerType:
            PrefixChar = ch_ADsPath_absolute; break;
        case StoreGetAbsoluteOtherServerType:
            PrefixChar = ch_ADsPath_diff_srvr; break;
        default:
            Require(FALSE);                       // too late to do anything about this now.
            PrefixChar = ch_ADsPath_diff_srvr; break;
        }
        Buf = ConvertStringToBinary(Attrib->ADsPath, PrefixChar, Buf);
    }

    if( IS_FLAGS1_PRESENT(Attrib) ) Buf = ConvertDwordToBinary(Attrib->Flags1, ch_Flags1, Buf);
    if( IS_FLAGS2_PRESENT(Attrib) ) Buf = ConvertDwordToBinary(Attrib->Flags2, ch_Flags2, Buf);
    if( IS_DWORD1_PRESENT(Attrib) ) Buf = ConvertDwordToBinary(Attrib->Dword1, ch_Dword1, Buf);
    if( IS_DWORD2_PRESENT(Attrib) ) Buf = ConvertDwordToBinary(Attrib->Dword2, ch_Dword2, Buf);

    if( IS_STRING1_PRESENT(Attrib) ) Buf = ConvertStringToBinary(Attrib->String1, ch_String1, Buf);
    if( IS_STRING2_PRESENT(Attrib) ) Buf = ConvertStringToBinary(Attrib->String2, ch_String2, Buf);
    if( IS_STRING3_PRESENT(Attrib) ) Buf = ConvertStringToBinary(Attrib->String3, ch_String3, Buf);
    if( IS_STRING4_PRESENT(Attrib) ) Buf = ConvertStringToBinary(Attrib->String4, ch_String4, Buf);

    if( IS_BINARY1_PRESENT(Attrib) ) {
        *(LPWORD)Buf = htons(ch_Binary1); Buf += sizeof(WORD);
        *(LPWORD)Buf = htons((WORD)Attrib->BinLen1); Buf += sizeof(WORD);
        memcpy(Buf, Attrib->Binary1, Attrib->BinLen1);
        Buf += ROUND_UP_COUNT(Attrib->BinLen1, ALIGN_WORD);
    }

    if( IS_BINARY2_PRESENT(Attrib) ) {
        *(LPWORD)Buf = htons(ch_Binary2); Buf += sizeof(WORD);
        *(LPWORD)Buf = htons((WORD)Attrib->BinLen2); Buf += sizeof(WORD);
        memcpy(Buf, Attrib->Binary2, Attrib->BinLen2);
        Buf += ROUND_UP_COUNT(Attrib->BinLen2, ALIGN_WORD);
    }

    Require( Buf  == nChars + (*Bytes) );

    return ERROR_SUCCESS;
}

StoreUpdateAttributesInternal(                    // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be string type
    IN      PARRAY                 Array,         // list of attribs
    IN      WCHAR                  Sep
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;
    LONG                           nValues, i;
    ADS_ATTR_INFO                  Attribute;
    PADSVALUE                      Values;
    ARRAY_LOCATION                 Loc;
    LPWSTR                         Str;
    PEATTRIB                       ThisAttrib;

    if( NULL == hStore || NULL == hStore->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == AttribName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( NULL == Array )
        return ERROR_INVALID_PARAMETER;

    nValues = MemArraySize(Array);

    if( 0 == nValues ) {                         // delete the attribute
        Attribute.pszAttrName = AttribName;
        Attribute.dwControlCode = ADS_ATTR_CLEAR;
        Attribute.dwADsType = ADSTYPE_CASE_IGNORE_STRING;
        Attribute.pADsValues = NULL;
        Attribute.dwNumValues = 0;

        hResult = ADSISetObjectAttributes(
            /* hDSObject        */ hStore->ADSIHandle,
            /* pAttributeEntr.. */ &Attribute,
            /* dwNumAttributes  */ 1,
            /* pdwNumAttribut.. */ &nValues
        );
        if( FAILED(hResult) || 1 != nValues ) {   // something went wrong
            return ConvertHresult(hResult);
        }
        return ERROR_SUCCESS;
    }

    Values = MemAlloc(nValues * sizeof(ADSVALUE));
    if( NULL == Values ) {                        // could not allocate ADs array
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0, Result = MemArrayInitLoc(Array, &Loc)
        ; ERROR_FILE_NOT_FOUND != Result ;        // convert to PADS_ATTR_INFO
        i ++ , Result = MemArrayNextLoc(Array, &Loc)
    ) {
        Result = MemArrayGetElement(Array, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        Str = NULL;
        Result = ConvertEAttribToString(ThisAttrib, &Str, Sep);
        if( ERROR_SUCCESS != Result ) {           // something went wrong!
            goto Cleanup;                         // free allocated memory
        }

        Values[i].dwType = ADSTYPE_CASE_IGNORE_STRING;
        Values[i].CaseIgnoreString = Str;
    }

    Attribute.pszAttrName = AttribName;
    Attribute.dwControlCode = ADS_ATTR_UPDATE;
    Attribute.dwADsType = ADSTYPE_CASE_IGNORE_STRING;
    Attribute.pADsValues = Values;
    Attribute.dwNumValues = nValues;

    hResult = ADSISetObjectAttributes(
        /* hDSObject        */ hStore->ADSIHandle,
        /* pAttributeEntr.. */ &Attribute,
        /* dwNumAttributes  */ 1,
        /* pdwNumAttribut.. */ &nValues
    );
    if( FAILED(hResult) || 1 != nValues ) {       // something went wrong
        Result = ConvertHresult(hResult);
    } else Result = ERROR_SUCCESS;

  Cleanup:

    if( Values ) {                                // got to free allocated memory
        while( i -- ) {                           // got to free converted strings
            if( Values[i].CaseIgnoreString )
                MemFree(Values[i].CaseIgnoreString);
        }
        MemFree(Values);
    }

    return Result;
}


//BeginExport(function)
//DOC StoreUpdateAttributes is sort of the converse of StoreCollectAttributes.
//DOC This function takes an array of type EATTRIB elements and updates the DS
//DOC with this array.  This function does not work when the attrib is of type
//DOC OCTET_STRING etc.  It works only with types that can be derived from
//DOC PrintableString.
DWORD
StoreUpdateAttributes(                            // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be string type
    IN      PARRAY                 Array          // list of attribs
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;

    Result = StoreUpdateAttributesInternal(
        hStore, Reserved, AttribName, Array, ch_FieldSep );

    return Result;
}

//BeginExport(function)
//DOC StoreUpdateBinaryAttributes is sort of the converse of StoreCollectBinaryAttributes
//DOC This function takes an array of type EATTRIB elements and updates the DS
//DOC with this array.  This function works only when the attrib is of type
//DOC OCTET_STRING etc.  It doesnt work with types that can be derived from
//DOC PrintableString!!!.
DWORD
StoreUpdateBinaryAttributes(                      // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be OCTET_STRING type
    IN      PARRAY                 Array          // list of attribs
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;
    LONG                           nValues, i, nBytes;
    ADS_ATTR_INFO                  Attribute;
    PADSVALUE                      Values;
    ARRAY_LOCATION                 Loc;
    LPBYTE                         Bytes;
    PEATTRIB                       ThisAttrib;

    if( NULL == hStore || NULL == hStore->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == AttribName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( NULL == Array )
        return ERROR_INVALID_PARAMETER;

    nValues = MemArraySize(Array);

    if( 0 == nValues ) {                         // delete the attribute
        Attribute.pszAttrName = AttribName;
        Attribute.dwControlCode = ADS_ATTR_CLEAR;
        Attribute.dwADsType = ADSTYPE_OCTET_STRING;
        Attribute.pADsValues = NULL;
        Attribute.dwNumValues = 0;

        hResult = ADSISetObjectAttributes(
            /* hDSObject        */ hStore->ADSIHandle,
            /* pAttributeEntr.. */ &Attribute,
            /* dwNumAttributes  */ 1,
            /* pdwNumAttribut.. */ &nValues
        );
        if( FAILED(hResult) || 1 != nValues ) {   // something went wrong
            return ConvertHresult(hResult);
        }
        return ERROR_SUCCESS;
    }

    Values = MemAlloc(nValues * sizeof(ADSVALUE));
    if( NULL == Values ) {                        // could not allocate ADs array
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0, Result = MemArrayInitLoc(Array, &Loc)
        ; ERROR_FILE_NOT_FOUND != Result ;        // convert to PADS_ATTR_INFO
        i ++ , Result = MemArrayNextLoc(Array, &Loc)
    ) {
        Result = MemArrayGetElement(Array, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        Bytes = NULL; nBytes =0;
        Result = ConvertEAttribToBinary(ThisAttrib, &Bytes, &nBytes);
        if( ERROR_SUCCESS != Result ) {           // something went wrong!
            goto Cleanup;                         // free allocated memory
        }

        Values[i].dwType = ADSTYPE_OCTET_STRING;
        Values[i].OctetString.dwLength = nBytes;
        Values[i].OctetString.lpValue = Bytes;
    }

    Attribute.pszAttrName = AttribName;
    Attribute.dwControlCode = ADS_ATTR_UPDATE;
    Attribute.dwADsType = ADSTYPE_OCTET_STRING;
    Attribute.pADsValues = Values;
    Attribute.dwNumValues = nValues;

    hResult = ADSISetObjectAttributes(
        /* hDSObject        */ hStore->ADSIHandle,
        /* pAttributeEntr.. */ &Attribute,
        /* dwNumAttributes  */ 1,
        /* pdwNumAttribut.. */ &nValues
    );
    if( FAILED(hResult) || 1 != nValues ) {       // something went wrong
        Result = ConvertHresult(hResult);
    } else Result = ERROR_SUCCESS;

  Cleanup:

    if( Values ) {                                // got to free allocated memory
        while( i -- ) {                           // got to free converted strings
            if( Values[i].OctetString.lpValue )
                MemFree(Values[i].OctetString.lpValue);
        }
        MemFree(Values);
    }

    return Result;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\store.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _STORE_HANDLE {                    // this is what is used almost always
    DWORD                          MustBeZero;    // for future use
    LPWSTR                         Location;      // where does this refer to?
    LPWSTR                         UserName;      // who is the user?
    LPWSTR                         Password;      // what is the password?
    DWORD                          AuthFlags;     // what permission was this opened with?
    HANDLE                         ADSIHandle;    // handle to within ADSI
    ADS_SEARCH_HANDLE              SearchHandle;  // any searches going on?
    LPVOID                         Memory;        // memory allocated for this call..
    DWORD                          MemSize;       // how much was really allocated?
    BOOL                           SearchStarted; // Did we start the search?
} STORE_HANDLE, *LPSTORE_HANDLE, *PSTORE_HANDLE;


DWORD
StoreInitHandle(                                  // initialize a handle
    IN OUT  STORE_HANDLE          *hStore,        // will be filled in with stuff..
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN      LPWSTR                 Domain,        // OPTIONAL NULL==>default Domain
    IN      LPWSTR                 UserName,      // OPTIONAL NULL==>default credentials
    IN      LPWSTR                 Password,      // OPTIONAL used only if UserName given
    IN      DWORD                  AuthFlags      // OPTIONAL 0 ==> default??????
) ;


DWORD
StoreCleanupHandle(                               // cleanup the handle
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) ;


enum {
    StoreGetChildType,
    StoreGetAbsoluteSameServerType,
    StoreGetAbsoluteOtherServerType
} _StoreGetType;


DWORD
StoreGetHandle(                                   // get handle to child object, absolute object..
    IN OUT  LPSTORE_HANDLE         hStore,        // this gets modified..
    IN      DWORD                  Reserved,
    IN      DWORD                  StoreGetType,  // same server? just a simple child?
    IN      LPWSTR                 Path,
    IN OUT  STORE_HANDLE          *hStoreOut      // new handle created..
) ;


DWORD
StoreSetSearchOneLevel(                          // search will return everything one level below
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) ;


DWORD
StoreSetSearchSubTree(                            // search will return the subtree below in ANY order
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) ;


DWORD
StoreBeginSearch(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 SearchFilter
) ;


DWORD
StoreEndSearch(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) ;


DWORD                                             // ERROR_NO_MORE_ITEMS if exhausted
StoreSearchGetNext(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    OUT     LPSTORE_HANDLE         hStoreOut
) ;


DWORD
StoreCreateObjectVA(                              // create a new object - var-args ending with ADSTYPE_INVALID
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 NewObjName,    // name of the new object -- must be "CN=name" types
    ...                                           // fmt is AttrType, AttrName, AttrValue [AttrValueLen]
) ;


DWORD
StoreCreateObjectL(                              // create the object as an array
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 NewObjName,   // must be "CN=XXX" types
    IN      PADS_ATTR_INFO         Attributes,   // the required attributes
    IN      DWORD                  nAttributes   // size of above array
) ;


#define     StoreCreateObject      StoreCreateObjectVA


DWORD
StoreDeleteObject(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ObjectName
) ;


//DOC StoreDeleteThisObject deletes the object defined by hStore,StoreGetType and ADsPath.
//DOC The refer to the object just the same way as for StoreGetHandle.
DWORD
StoreDeleteThisObject(                            // delete an object
    IN      LPSTORE_HANDLE         hStore,        // point of anchor frm which reference is done
    IN      DWORD                  Reserved,      // must be zero, reserved for future use
    IN      DWORD                  StoreGetType,  // path is relative, absolute or diff server?
    IN      LPWSTR                 Path           // ADsPath to the object or relative path
) ;


DWORD
StoreSetAttributesVA(                             // set the attributes, var_args interface (nearly similar to CreateVA)
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN OUT  DWORD*                 nAttributesModified,
    ...                                           // fmt is {ADSTYPE, CtrlCode, AttribName, Value}* ending in ADSTYPE_INVALID
) ;


DWORD
StoreSetAttributesL(                              // PADS_ATTR_INFO array equiv for SetAttributesVA
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN OUT  DWORD*                 nAttributesModified,
    IN      PADS_ATTR_INFO         AttribArray,
    IN      DWORD                  nAttributes
) ;


typedef     struct                 _EATTRIB {     // encapsulated attribute
    unsigned int                   Address1_present     : 1;
    unsigned int                   Address2_present     : 1;
    unsigned int                   Address3_present     : 1;
    unsigned int                   ADsPath_present      : 1;
    unsigned int                   StoreGetType_present : 1;
    unsigned int                   Flags1_present       : 1;
    unsigned int                   Flags2_present       : 1;
    unsigned int                   Dword1_present       : 1;
    unsigned int                   Dword2_present       : 1;
    unsigned int                   String1_present      : 1;
    unsigned int                   String2_present      : 1;
    unsigned int                   String3_present      : 1;
    unsigned int                   String4_present      : 1;
    unsigned int                   Binary1_present      : 1;
    unsigned int                   Binary2_present      : 1;

    DWORD                          Address1;      // character "i"
    DWORD                          Address2;      // character "j"
    DWORD                          Address3;      // character "k"
    LPWSTR                         ADsPath;       // character "p" "r" "l"
    DWORD                          StoreGetType;  // "p,r,l" ==> sameserver, child, otherserver
    DWORD                          Flags1;        // character "f"
    DWORD                          Flags2;        // character "g"
    DWORD                          Dword1;        // character "d"
    DWORD                          Dword2;        // character "e"
    LPWSTR                         String1;       // character "s"
    LPWSTR                         String2;       // character "t"
    LPWSTR                         String3;       // character "u"
    LPWSTR                         String4;       // character "v"
    LPBYTE                         Binary1;       // character "b"
    DWORD                          BinLen1;       // # of bytes of above
    LPBYTE                         Binary2;       // character "d"
    DWORD                          BinLen2;       // # of bytes of above
} EATTRIB, *PEATTRIB, *LPEATTRIB;


#define     IS_ADDRESS1_PRESENT(pEA)              ((pEA)->Address1_present)
#define     IS_ADDRESS1_ABSENT(pEA)               (!IS_ADDRESS1_PRESENT(pEA))
#define     ADDRESS1_PRESENT(pEA)                 ((pEA)->Address1_present = 1 )
#define     ADDRESS1_ABSENT(pEA)                  ((pEA)->Address1_present = 0 )

#define     IS_ADDRESS2_PRESENT(pEA)              ((pEA)->Address2_present)
#define     IS_ADDRESS2_ABSENT(pEA)               (!IS_ADDRESS2_PRESENT(pEA))
#define     ADDRESS2_PRESENT(pEA)                 ((pEA)->Address2_present = 1 )
#define     ADDRESS2_ABSENT(pEA)                  ((pEA)->Address2_present = 0 )

#define     IS_ADDRESS3_PRESENT(pEA)              ((pEA)->Address3_present)
#define     IS_ADDRESS3_ABSENT(pEA)               (!IS_ADDRESS3_PRESENT(pEA))
#define     ADDRESS3_PRESENT(pEA)                 ((pEA)->Address3_present = 1 )
#define     ADDRESS3_ABSENT(pEA)                  ((pEA)->Address3_present = 0 )

#define     IS_ADSPATH_PRESENT(pEA)               ((pEA)->ADsPath_present)
#define     IS_ADSPATH_ABSENT(pEA)                (!IS_ADSPATH_PRESENT(pEA))
#define     ADSPATH_PRESENT(pEA)                  ((pEA)->ADsPath_present = 1)
#define     ADSPATH_ABSENT(pEA)                   ((pEA)->ADsPath_present = 0)

#define     IS_STOREGETTYPE_PRESENT(pEA)          ((pEA)->StoreGetType_present)
#define     IS_STOREGETTYPE_ABSENT(pEA)           (!((pEA)->StoreGetType_present))
#define     STOREGETTYPE_PRESENT(pEA)             ((pEA)->StoreGetType_present = 1)
#define     STOREGETTYPE_ABSENT(pEA)              ((pEA)->StoreGetType_present = 0)

#define     IS_FLAGS1_PRESENT(pEA)                ((pEA)->Flags1_present)
#define     IS_FLAGS1_ABSENT(pEA)                 (!((pEA)->Flags1_present))
#define     FLAGS1_PRESENT(pEA)                   ((pEA)->Flags1_present = 1)
#define     FLAGS1_ABSENT(pEA)                    ((pEA)->Flags1_present = 0)

#define     IS_FLAGS2_PRESENT(pEA)                ((pEA)->Flags2_present)
#define     IS_FLAGS2_ABSENT(pEA)                 (!((pEA)->Flags2_present))
#define     FLAGS2_PRESENT(pEA)                   ((pEA)->Flags2_present = 1)
#define     FLAGS2_ABSENT(pEA)                    ((pEA)->Flags2_present = 0)

#define     IS_DWORD1_PRESENT(pEA)                ((pEA)->Dword1_present)
#define     IS_DWORD1_ABSENT(pEA)                 (!((pEA)->Dword1_present))
#define     DWORD1_PRESENT(pEA)                   ((pEA)->Dword1_present = 1)
#define     DWORD1_ABSENT(pEA)                    ((pEA)->Dword1_present = 0)

#define     IS_DWORD2_PRESENT(pEA)                ((pEA)->Dword2_present)
#define     IS_DWORD2_ABSENT(pEA)                 (!((pEA)->Dword2_present))
#define     DWORD2_PRESENT(pEA)                   ((pEA)->Dword2_present = 1)
#define     DWORD2_ABSENT(pEA)                    ((pEA)->Dword2_present = 0)

#define     IS_STRING1_PRESENT(pEA)               ((pEA)->String1_present)
#define     IS_STRING1_ABSENT(pEA)                (!((pEA)->String1_present))
#define     STRING1_PRESENT(pEA)                  ((pEA)->String1_present = 1)
#define     STRING1_ABSENT(pEA)                   ((pEA)->String1_present = 0)

#define     IS_STRING2_PRESENT(pEA)               ((pEA)->String2_present)
#define     IS_STRING2_ABSENT(pEA)                (!((pEA)->String2_present))
#define     STRING2_PRESENT(pEA)                  ((pEA)->String2_present = 1)
#define     STRING2_ABSENT(pEA)                   ((pEA)->String2_present = 0)

#define     IS_STRING3_PRESENT(pEA)               ((pEA)->String3_present)
#define     IS_STRING3_ABSENT(pEA)                (!((pEA)->String3_present))
#define     STRING3_PRESENT(pEA)                  ((pEA)->String3_present = 1)
#define     STRING3_ABSENT(pEA)                   ((pEA)->String3_present = 0)

#define     IS_STRING4_PRESENT(pEA)               ((pEA)->String4_present)
#define     IS_STRING4_ABSENT(pEA)                (!((pEA)->String4_present))
#define     STRING4_PRESENT(pEA)                  ((pEA)->String4_present = 1)
#define     STRING4_ABSENT(pEA)                   ((pEA)->String4_present = 0)

#define     IS_BINARY1_PRESENT(pEA)               ((pEA)->Binary1_present)
#define     IS_BINARY1_ABSENT(pEA)                (!((pEA)->Binary1_present))
#define     BINARY1_PRESENT(pEA)                  ((pEA)->Binary1_present = 1)
#define     BINARY1_ABSENT(pEA)                   ((pEA)->Binary1_present = 0)

#define     IS_BINARY2_PRESENT(pEA)               ((pEA)->Binary2_present)
#define     IS_BINARY2_ABSENT(pEA)                (!((pEA)->Binary2_present))
#define     BINARY2_PRESENT(pEA)                  ((pEA)->Binary2_present = 1)
#define     BINARY2_ABSENT(pEA)                   ((pEA)->Binary2_present = 0)


BOOL        _inline
IsAnythingPresent(
    IN      PEATTRIB               pEA
)
{
    return IS_ADDRESS1_PRESENT(pEA)
    || IS_ADDRESS2_PRESENT(pEA)
    || IS_ADDRESS3_PRESENT(pEA)
    || IS_ADSPATH_PRESENT(pEA)
    || IS_STOREGETTYPE_PRESENT(pEA)
    || IS_FLAGS1_PRESENT(pEA)
    || IS_FLAGS2_PRESENT(pEA)
    || IS_DWORD1_PRESENT(pEA)
    || IS_DWORD2_PRESENT(pEA)
    || IS_STRING1_PRESENT(pEA)
    || IS_STRING2_PRESENT(pEA)
    || IS_STRING3_PRESENT(pEA)
    || IS_STRING4_PRESENT(pEA)
    || IS_BINARY1_PRESENT(pEA)
    || IS_BINARY2_PRESENT(pEA)
    ;
}


BOOL        _inline
IsEverythingPresent(
    IN      PEATTRIB               pEA
)
{
    return IS_ADDRESS1_PRESENT(pEA)
    && IS_ADDRESS2_PRESENT(pEA)
    && IS_ADDRESS3_PRESENT(pEA)
    && IS_ADSPATH_PRESENT(pEA)
    && IS_STOREGETTYPE_PRESENT(pEA)
    && IS_FLAGS1_PRESENT(pEA)
    && IS_FLAGS2_PRESENT(pEA)
    && IS_DWORD1_PRESENT(pEA)
    && IS_DWORD2_PRESENT(pEA)
    && IS_STRING1_PRESENT(pEA)
    && IS_STRING2_PRESENT(pEA)
    && IS_STRING3_PRESENT(pEA)
    && IS_STRING4_PRESENT(pEA)
    && IS_BINARY1_PRESENT(pEA)
    && IS_BINARY2_PRESENT(pEA)
    ;
}


VOID        _inline
EverythingPresent(
    IN      PEATTRIB               pEA
)
{
    ADDRESS1_PRESENT(pEA);
    ADDRESS2_PRESENT(pEA);
    ADDRESS3_PRESENT(pEA);
    ADSPATH_PRESENT(pEA);
    STOREGETTYPE_ABSENT(pEA);
    FLAGS1_PRESENT(pEA);
    FLAGS2_PRESENT(pEA);
    DWORD1_PRESENT(pEA);
    DWORD2_PRESENT(pEA);
    STRING1_PRESENT(pEA);
    STRING2_PRESENT(pEA);
    STRING3_PRESENT(pEA);
    STRING4_PRESENT(pEA);
    BINARY1_PRESENT(pEA);
    BINARY2_PRESENT(pEA);
}


VOID        _inline
NothingPresent(
    IN      PEATTRIB               pEA
)
{
    ADDRESS1_ABSENT(pEA);
    ADDRESS2_ABSENT(pEA);
    ADDRESS3_ABSENT(pEA);
    ADSPATH_ABSENT(pEA);
    STOREGETTYPE_ABSENT(pEA);
    FLAGS1_ABSENT(pEA);
    FLAGS2_ABSENT(pEA);
    DWORD1_ABSENT(pEA);
    DWORD2_ABSENT(pEA);
    STRING1_ABSENT(pEA);
    STRING2_ABSENT(pEA);
    STRING3_ABSENT(pEA);
    STRING4_ABSENT(pEA);
    BINARY1_ABSENT(pEA);
    BINARY2_ABSENT(pEA);
}


DWORD
StoreCollectAttributes(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,    // this attrib must be some kind of a text string
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
) ;


DWORD
StoreCollectBinaryAttributes(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,    // accept only attrib type OCTET_STRING
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
) ;


//DOC StoreUpdateAttributes is sort of the converse of StoreCollectAttributes.
//DOC This function takes an array of type EATTRIB elements and updates the DS
//DOC with this array.  This function does not work when the attrib is of type
//DOC OCTET_STRING etc.  It works only with types that can be derived from
//DOC PrintableString.
DWORD
StoreUpdateAttributes(                            // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be string type
    IN      PARRAY                 Array          // list of attribs
) ;


//DOC StoreUpdateBinaryAttributes is sort of the converse of StoreCollectBinaryAttributes
//DOC This function takes an array of type EATTRIB elements and updates the DS
//DOC with this array.  This function works only when the attrib is of type
//DOC OCTET_STRING etc.  It doesnt work with types that can be derived from
//DOC PrintableString!!!.
DWORD
StoreUpdateBinaryAttributes(                      // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be OCTET_STRING type
    IN      PARRAY                 Array          // list of attribs
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\tdhcpread.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: Rameshv
// Description: this program tests the dhcpread.c module.
//================================================================================

//================================================================================
//  headers
//================================================================================
#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>                            // need all the MM stuff...
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>                     // need all the registry stuff
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpread.h>
#include    <dhcpapi.h>
#include    <dhcpds.h>
#include    <mm\mmdump.h>

void _cdecl main(int argc, char *argv[]) {
    ARRAY                          TestArray;
    ARRAY_LOCATION                 Loc;
    PM_SERVER                      ThisServer;
    DWORD                          Result;
    LPWSTR                         ServerName;
    WCHAR                          Buf[1000];

    if( 1 == argc ) {                             // no arguments?  then dump full ds
        printf("================================================================================\n");
        printf("                     Dump of all DHCP servers in DS\n");
        printf("================================================================================\n");
        printf("***      Use: %s <server-name> to dump for required dhcp server alone        ***\n", argv[0]);
        printf("================================================================================\n");
        ServerName = NULL;
    } else if( 2 == argc ) {
        int i = 0;

        while(Buf[i] = (WCHAR)argv[1][i]) i ++;
        ServerName = Buf;
        printf("================================================================================\n");
        printf("                     Dump DHCP server <%ws>\n", ServerName);
        printf("================================================================================\n");
        printf("***      Use: %s <server-name> to dump for required dhcp server alone        ***\n", argv[0]);
        printf("================================================================================\n");
    } else {
        printf("Usage: %s [dns-name-of-dhcp-server-to-dump]\n", argv[0]);
        return;
    }

    Result = DhcpDsInitDS(0, NULL);
    if( ERROR_SUCCESS != Result ) {
        printf("DhcpDsInitDS failed: 0x%lx (%ld)\n", Result, Result);
        return;
    }

    MemArrayInit(&TestArray);
    Result = DhcpDsGetEnterpriseServers(
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServerName           */ ServerName,
        /* Servers              */ &TestArray
    );

    printf("DhcpDsGetEnterpriseServers(): 0x%lx (%ld)\n", Result, Result);
    printf("TestArray'Size = %ld\n", MemArraySize(&TestArray));

    for( Result = MemArrayInitLoc(&TestArray, &Loc)
         ; ERROR_SUCCESS == Result ;
         Result = MemArrayNextLoc(&TestArray, &Loc)
    ) {
        Result = MemArrayGetElement(&TestArray, &Loc, &ThisServer);
        MmDumpServer(0, ThisServer);
        MemServerFree(ThisServer);
    }
    printf("================================================================================\n");
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\st_srvr.h ===
//================================================================================
//  Copyright 1997 (C) Microsoft Corporation
//  Author: RameshV
//  Description: This is the structure of the server information passed to
//  user via dhcpds.dll.
//================================================================================

#ifndef     _ST_SRVR_H_
#define     _ST_SRVR_H_

//BeginExport(typedef)
typedef     struct                 _DHCPDS_SERVER {
    DWORD                          Version;       // version of this structure -- currently zero
    LPWSTR                         ServerName;    // [DNS?] unique name for server
    DWORD                          ServerAddress; // ip address of server
    DWORD                          Flags;         // additional info -- state
    DWORD                          State;         // not used ...
    LPWSTR                         DsLocation;    // ADsPath to server object
    DWORD                          DsLocType;     // path relative? absolute? diff srvr?
}   DHCPDS_SERVER, *LPDHCPDS_SERVER, *PDHCPDS_SERVER;

typedef     struct                 _DHCPDS_SERVERS {
    DWORD                          Flags;         // not used currently.
    DWORD                          NumElements;   // # of elements in array
    LPDHCPDS_SERVER                Servers;       // array of server info
}   DHCPDS_SERVERS, *LPDHCPDS_SERVERS, *PDHCPDS_SERVERS;
//EndExport(typedef)

#endif      _ST_SRVR_H_

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\test\makefile.inc ===
dhcpmsg.h dhcpmsg.rc msg00001.bin: dhcpmsg.mc
    mc -d -r .\ dhcpmsg.mc

clean::
    -del dhcpmsg.h dhcpmsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\validate.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: Koti, modified by RameshV
// Description: Validates a service against the DS
//================================================================================

#include <hdrmacro.h>
#include <store.h>
#include <dhcpmsg.h>
#include <wchar.h>
#include <dhcpbas.h>
#include <dhcpapi.h>
#include <st_srvr.h>
#include <rpcapi2.h>
#undef   NET_API_FUNCTION
#include <iphlpapi.h>
#include <dnsapi.h>
#include <mmreg\regutil.h>

//
// Retrieve a list of IP addresses for the interfaces
// 

DWORD
GetIpAddressList(
    IN OUT PDWORD *Addresses,
    IN OUT DWORD  *nAddresses
)
{
    DWORD             Size, Error, i;
    PMIB_IPADDRTABLE  IpAddrTable;

    AssertRet((( Addresses != NULL ) && ( nAddresses != NULL)),
	      ERROR_INVALID_PARAMETER );

    Size = 0;

    // Get the required size
    Error = GetIpAddrTable( NULL, &Size, FALSE );

    if( ERROR_INSUFFICIENT_BUFFER != Error ) {
	return Error;
    }
    
    IpAddrTable = MemAlloc( Size );
    if ( NULL == IpAddrTable ) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = GetIpAddrTable( IpAddrTable, &Size, FALSE );
    if (( NO_ERROR != Error ) ||
	( 0 == IpAddrTable->dwNumEntries )) {
	*Addresses = NULL;
	*nAddresses = 0;
	MemFree(IpAddrTable);
	return Error;
    }

    *Addresses = MemAlloc( IpAddrTable->dwNumEntries * sizeof( DWORD ));
    if ( NULL == *Addresses ) {
	*nAddresses = 0;
	MemFree( IpAddrTable );
	return ERROR_NOT_ENOUGH_MEMORY;
    }
    *nAddresses = IpAddrTable->dwNumEntries ;
    
    for( i = 0; i < *nAddresses; i ++ ) {
	(*Addresses)[i] = IpAddrTable->table[i].dwAddr;
    }

    MemFree( IpAddrTable );
    return ERROR_SUCCESS;
} // GetIpAddressList()

LPWSTR GetHostName(
   VOID
)
{
    LPWSTR  HostName;
    DWORD   Length;
    DWORD   Error;

    // Get the required length
    Length = 0;
    GetComputerNameExW( ComputerNameDnsFullyQualified,
			NULL, &Length );

    HostName = MemAlloc( Length * sizeof( WCHAR ));
    if ( NULL == HostName ) {
	return NULL;
    }

    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
			      HostName, &Length )) {
	MemFree( HostName );
	return NULL;
    }

    return HostName;
    
} // GetHostName()

//BeginExport(function)
//DOC This function is declared in dhcpds.c..
//DOC DhcpDsValidateService checks the given service in the DS to see if it exists
//DOC If the machine is a standalone, it sets IsStandAlone and returns ERROR_SUCCESS
//DOC If the entry for the given Address is found, it sets Found to TRUE and returns
//DOC ERROR_SUCCESS. If the DhcpRoot node is found, but entry is not Found, it sets
//DOC Found to FALSE and returns ERROR_SUCCESS; If the DS could not be reached, it
//DOC returns ERROR_FILE_NOT_FOUND or probably other DS errors.
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses, OPTIONAL
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone // not used
)   //EndExport(function)
{
    DWORD               Result, Error,i;
    STORE_HANDLE        hStoreCC, hDhcpC, hDhcpRoot;
    DWORD              *Addr;
    BOOL                TableAddr;
    WCHAR               PrintableIp[ 20 ]; // 000.000.000.000
    LPWSTR              HostName;

    if( NULL == Found || NULL == IsStandAlone ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = ERROR_FILE_NOT_FOUND;

    *IsStandAlone = FALSE;
    *Found = FALSE;

    Result = StoreInitHandle                      // get the config container handle
    (
        /* hStore               */ &hStoreCC,     // config container
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ThisDomain           */ Domain,
        /* UserName             */ UserName,
        /* Password             */ Password,
        /* AuthFlags            */ AuthFlags
    );
    if( ERROR_SUCCESS != Result ) return Result;  // DS error

    Result = DhcpDsGetRoot                        // get dhcp root object
    (
        /* Flags                */ 0,             // no flags
        /* hStoreCC             */ &hStoreCC,
        /* hDhcpRoot            */ &hDhcpRoot
    );

    if( ERROR_SUCCESS != Result ) {

        //
        // If the failure is because the dhcp root object
        // can't be seen, then treat that as positive failure
        // to authorize.
        //

        if( ERROR_DDS_NO_DHCP_ROOT == Result ) {
            Result = GetLastError();
        }

        StoreCleanupHandle(&hStoreCC, 0);
        return Result;
    }

    Result = DhcpDsGetDhcpC
    (
        /* Flags                */ 0,             // no flags
        /* hStoreCC             */ &hStoreCC,
        /* hDhcpC               */ &hDhcpC
    );

    if( ERROR_SUCCESS != Result ) {
        StoreCleanupHandle(&hStoreCC, 0);
        StoreCleanupHandle(&hDhcpRoot, 0);
        return Result;
    }

    do {
	// if addresses are not specified, get it from the ipaddr table

	if( NULL != Addresses && 0 != nAddresses ) {
	    Addr = Addresses;
	    TableAddr = FALSE;
	}
	else {
	    Error = GetIpAddressList( &Addr, &nAddresses );
	    if ( ERROR_SUCCESS != Error) {
		break;
	    }
	    TableAddr = TRUE;
	} // else

	//
	// Check to see if any of the ip addresses or hostname are authorized
	// A seperate call to check for hostname is not necessary because, 
	// the hostname is also added to the filter.
	//

	HostName = GetHostName();
	if ( NULL == HostName ) {
	    Error = GetLastError();
	    break;
	}

	for ( i = 0; i < nAddresses; i++ ) {

	    // skip loopback IP 127.0.0.1
	    if ( INADDR_LOOPBACK == htonl( Addr [ i ] )) {
		continue;
	    }

	    ConvertAddressToLPWSTR( htonl( Addr[ i ] ), PrintableIp );

	    Result = DhcpDsLookupServer( &hDhcpC, &hDhcpRoot,
					 DDS_RESERVED_DWORD,
					 PrintableIp, HostName );
	    if ( Result ) {
		*Found = TRUE;
		Error = ERROR_SUCCESS;
		break;
	    }
	} // for i
    } while ( FALSE );

    StoreCleanupHandle(&hStoreCC, 0);             // free ds handle
    StoreCleanupHandle(&hDhcpRoot, 0);            // free ds handle
    StoreCleanupHandle(&hDhcpC, 0);               // free ds handle

    if( TableAddr && NULL != Addr ) {
	MemFree( Addr );
    }

    return Error;
} // DhcpDsValidateService()

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\upndown.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: Download and Upload related code.
//================================================================================

//================================================================================
//  includes
//================================================================================
#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpapi.h>
#include    <delete.h>
#include    <st_srvr.h>
#include    <rpcapi2.h>
#include    <rpcstubs.h>

//================================================================================
//  utilities
//================================================================================

BOOL        _inline
AddressFoundInHostent(
    IN      DHCP_IP_ADDRESS        AddrToSearch,  // Host-Order addr
    IN      HOSTENT               *ServerEntry    // entry to search for..
)
{
    ULONG                          nAddresses, ThisAddress;

    if( NULL == ServerEntry ) return FALSE;       // no address to search in

    nAddresses = 0;                               // have a host entry to compare for addresses
    while( ServerEntry->h_addr_list[nAddresses] ) {
        ThisAddress = ntohl(*(DHCP_IP_ADDRESS*)ServerEntry->h_addr_list[nAddresses++] );
        if( ThisAddress == AddrToSearch ) {
            return TRUE;                          // yeah address matched.
        }
    }

    return FALSE;
}


//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\test\adsitst.c ===
//================================================================================
//  Copyright (C) 2000 Microsoft Corporation
//  Author : ThiruB
//  Description: ADSI test app
//================================================================================

#define INC_OLE2
#include <activeds.h>
#include <stdio.h>
#include <stdlib.h>
#include <align.h>
#include <lmcons.h>
#include <netlib.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <adsi.h>

LPWSTR
ConvertToLPWSTR(
		IN     /* LPSTR  */ char *                 s
)
{
    LPWSTR                         u, v;

    if( NULL == s ) return L"";

    u = LocalAlloc(LMEM_FIXED, (strlen(s)+1)*sizeof(WCHAR));
    if( NULL == u ) return L"";

    v = u;
    while( *v++ = *s++)
        ;

    return u;
} // ConvertToLPWSTR()

void PrintRow( HANDLE            lh, 
	       ADS_SEARCH_HANDLE sh,
	       LPWSTR            attribs[], 
	       DWORD             count
	       )
{
    DWORD i, j;
    HRESULT hr;
    ADS_SEARCH_COLUMN col;

    for ( i = 0; i < count; i++ ) {
	hr = ADSIGetColumn( lh, sh, attribs[ i ], &col );

	if ( FAILED( hr)) {
	    printf( "Failed for attribute : %ws, ErrorCode: %ld\n",
		    attribs[ i ],
		    GetLastError());
	    continue;
	}
	printf( "AttrName : %ws\n", col.pszAttrName );
	for ( j = 0; j < col.dwNumValues; j++ ) {
	    printf( "\tAttr Value : %ws\n", col.pADsValues[j].DNString );
	}
    } // for
} // PrintRow()

void DumpObject( LPWSTR url, LPWSTR searchFilter )
{

    HANDLE ldapHandle;
    ADS_SEARCH_HANDLE sh;
    HRESULT hr;

    ADS_SEARCHPREF_INFO SearchPref[3];

    LPWSTR attribs[] = { L"name", L"dhcpServers" };
//      LPWSTR attribs[] = { L"dhcpServers" };
//      LPWSTR searchFilter = L"(objectClass=dHCPClass)";
//      LPWSTR searchFilter = L"(dhcpServers~=127)";
    
    hr = ADSIOpenDSObject( url, NULL, NULL, ADS_SECURE_AUTHENTICATION, &ldapHandle );

    if ( SUCCEEDED( hr )) {
	printf( "Successfully opened %ws\n", url );
    } 
    else {
	printf( "Failed to open : %ws\n", url );
	return;
    }

    SearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[0].vValue.Integer = ADS_SCOPE_SUBTREE;

//      SearchPref.dwStatus = ERROR_SUCCESS;

    SearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[1].vValue.Integer = 250;

    // Make it cache the results at the client side. This is
    // default, but try it anyway.
    SearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
    SearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
    SearchPref[2].vValue.Boolean = TRUE;

    hr = ADSISetSearchPreference(
        /* hDSObject           */  ldapHandle,
        /* pSearchPrefs        */  SearchPref,
        /* dwNumPrefs          */  3
    );
    if ( FAILED( hr )) {
	printf( "SetSearchPrefs failed\n");
	return;
    }

    // Begin Search
    hr = ADSIExecuteSearch( ldapHandle,
			    searchFilter,
			    attribs,
			    sizeof(attribs) / sizeof(*attribs),
			    &sh);
    if ( FAILED( hr)) {
	printf( "Search failed for %ws\n", searchFilter );
	return;
    }


    // Search
    
    hr = ADSIGetFirstRow ( ldapHandle, sh );
    if ( !FAILED( hr ) ) {
	PrintRow( ldapHandle, sh,
		  attribs, sizeof(attribs) / sizeof(*attribs) );
    }
    else {
	printf( "GetFirstRow failed \n");
	return;
    }

    while ( 1 ) {
	hr =  ADSIGetNextRow( ldapHandle, sh );
	if ((SUCCEEDED( hr )) &&
	    (hr != S_ADS_NOMORE_ROWS)) {
	    PrintRow ( ldapHandle, sh,
		       attribs, sizeof(attribs) / sizeof(*attribs) );
	}
	else {
            break;
	}
    } // while 
    
    // End Search
    hr = ADSICloseSearchHandle( ldapHandle, sh );
    ADSICloseDSObject( ldapHandle );


} // DumpObject


void _cdecl main( int argc, char *argv[] ) {
    LPWSTR url;
    LPWSTR filter;

    if ( argc > 2 ) {
	url = ConvertToLPWSTR( argv[ 1 ] );
	filter = ConvertToLPWSTR( argv[ 2 ] );
	DumpObject( url, filter );
    } 
} // main()

void _cdecl _bad_main(int argc, char *argv[]) {

   HANDLE  ldapHandle;
   HRESULT hr;
   DWORD   dwLastError;
   WCHAR   szErrorBuf[MAX_PATH];
   WCHAR   szNameBuf[MAX_PATH];
   HRESULT hr_return = S_OK;

   hr = ADSIOpenDSObject( 
			 L"LDAP://192.168.73.1/ROOTDSE",
			 NULL,
			 NULL,
			 0,
			 &ldapHandle );

    if ( SUCCEEDED( hr ) )
    {
        printf( "Successfully opened the ROOTDSE object! \n" );
        ADSICloseDSObject( ldapHandle );
    }
    else
    {
        printf( "Falied to open ROOTDSE ..\n" );
    }

   hr = ADSIOpenDSObject(
//  			 L"LDAP://192.168.73.1/CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration,DC=rterala-test1,DC=officenet",
			 L"LDAP://192.168.73.1/CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration,CN=rterala-test1.rterala.officenet",
			 NULL,
			 NULL,
			 ADS_SECURE_AUTHENTICATION,
			 &ldapHandle );

   if ( SUCCEEDED( hr ) )
    {
        printf( "Successfully opened the DhcpRoot object in RCOST.COM! \n" );
        ADSICloseDSObject( ldapHandle );
    }
    else
    {
        if ( FAILED( hr ) )
        {
            printf( "Failed to open the DHCP ROOT object Errcode is 0x%Xh \n", hr  );

            if (HRESULT_FACILITY(hr)==FACILITY_WIN32)
            {
                hr_return = ADsGetLastError( &dwLastError,
                                             szErrorBuf,
                                             MAX_PATH-1,
                                             szNameBuf,
                                             MAX_PATH-1);
                if (SUCCEEDED(hr_return))
                {
                    wprintf(L"Error Code: %d\n Error Text: %ws\n Provider: %ws\n", dwLastError, szErrorBuf, szNameBuf);
                }
            }

        }
    }

    hr = ADSIOpenDSObject( L"LDAP://192.168.73.1/CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration,DC=rterala-test1,DC=officenet",
//                             L"Administrator",
//                             L"b4,checkin",
			   NULL, NULL,
                           ADS_SECURE_AUTHENTICATION,
                           &ldapHandle );

   if ( SUCCEEDED( hr ) ) 
   {
        printf( "Successfully opened the DhcpRoot object in RCOST.COM! \n" );
        ADSICloseDSObject( &ldapHandle );
   }
   else
   {
        if ( FAILED( hr ) )
        {
           printf( "Failed to open the DHCP ROOT object Errcode is 0x%Xh \n", hr );
        }

        if ( HRESULT_FACILITY(hr) == FACILITY_WIN32 )
        {
            hr_return = ADsGetLastError( &dwLastError,
                                         szErrorBuf,
                                         MAX_PATH-1,
                                         szNameBuf,
                                         MAX_PATH-1 );

            if ( SUCCEEDED( hr_return ) )
            {
                wprintf(L"Error code: %d \n Error Text: %ws\n Provider: %ws \n", dwLastError, szErrorBuf, szNameBuf );
            
            }
             
        }       
   }

   exit(0);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\test\engine.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: generic testing engine
//================================================================================

//===============================
//  headers
//===============================
#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpread.h>
#include    <dhcpapi.h>
#include    <rpcapi1.h>
#include    <rpcapi2.h>

//BeginExport(typedefs)
// supported data types are listed. any new datatypes should be added here.
typedef     enum /* anonymous */ {
    Char,
    wChar,
    Word,
    DWord,
    String,
    wString,
    IpAddress,
    xBytes,
    Invalid
}   NJIN_TYPES, *LPNJIN_TYPES;

typedef    struct /* anonymous */ {
    union         /* anonymous */ {
        CHAR                      *Char;
        WCHAR                     *wChar;
        WORD                      *Word;
        DWORD                     *DWord;
        LPSTR                      String;
        LPWSTR                     wString;
        DWORD                     *IpAddress;
        struct    /* anonymous */ {
            DWORD                 *xBytesLen;
            LPBYTE                 xBytesBuf;
        };
    };
}   NJIN_DATA, *LPNJIN_DATA;

typedef     struct /* anonymous */ {
    LPWSTR                         VarName;
    NJIN_TYPES                     VarType;
    NJIN_DATA                      VarData;
    VOID                           (*VarFunc)(LPWSTR VarName);
    BOOL                           ReadOnly;
}   NJIN_VAR, *LPNJIN_VAR;

typedef     struct /* anonymous */ {
    WCHAR                          cComment;
    WCHAR                          cEquals;
    WCHAR                          cReturn;
    WCHAR                          cEndOfLine;
    WCHAR                          cCharFmtActual;
    WCHAR                          cCharFmtNum;
    BOOL                           fEcho;
    BOOL                           fVerbose;
}   NJIN_ENV, *LPNJIN_ENV;
//EndExport(typedefs)

#define     verbose                if( Env->fVerbose) printf
#define     echo                   if( Env->fEcho) printf

DWORD
ConvertToIntegral(
    IN      LPWSTR                 Str
)
{
    return _wtol(Str);
}

DWORD
ConvertToAddress(
    IN      LPWSTR                 Str
)
{
    CHAR                           Buf[1000];
    LPSTR                          s;

    s = Buf;
    while(*s ++ = (CHAR) *Str++ )
        /* skip */;

    return inet_addr(Buf);
}

DWORD
CloneWString(
    IN      LPWSTR                 Buf,
    IN      LPWSTR                 Dest
)
{
    wcscpy(Dest, Buf);
    return ERROR_SUCCESS;
}

DWORD
CloneString(
    IN      LPWSTR                 Str,
    IN      LPSTR                  s
)
{
    while(*s ++ = (CHAR) *Str ++ )
        /* skip */;

    return ERROR_SUCCESS;
}

BYTE
Hex(
    IN      WCHAR                  C
)
{
    if( C >= L'0' && C <= L'9' ) return C - L'0';
    if( C >= L'A' && C <= L'F' ) return C - L'A' + 10;
    if( C >= L'a' && C <= L'f' ) return C - L'a' + 10;
    return 0x55;
}

DWORD
ConvertToHexBytes(
    IN      LPWSTR                 Str,
    IN OUT  LPBYTE                 Buf,
    IN OUT  LPDWORD                BufLen
)
{
    BYTE                           ch, ch2;

    *BufLen = 0;
    while( (ch = Hex(*Str++)) <= 0xF) {
        ch2 = Hex(*Str++);
        if( ch2 > 0xF ) {
            printf("illegal character found, ignored\n");
            ch2 = 0;
        }
        Buf[(*BufLen)++] = (ch <<4) | ch2;
    }

    return ERROR_SUCCESS;
}

DWORD
ConvertDataType(
    IN      LPNJIN_ENV             Env,
    IN      LPWSTR                 Buf,
    IN      DWORD                  VarType,
    IN      NJIN_DATA             *VarData
)
{
    switch(VarType) {
    case Char:
        if( Env->cCharFmtActual == Buf[0] ) {
            *VarData->Char = (CHAR) Buf[1];
        } else if( Env->cCharFmtNum == Buf[0] ) {
            *VarData->Char = (CHAR) ConvertToIntegral(&Buf[1]);
        } else return ERROR_INVALID_DATA;
        return ERROR_SUCCESS;
    case wChar:
        if( Env->cCharFmtActual == Buf[0] ) {
            *VarData->wChar = Buf[1];
        } else if( Env->cCharFmtNum == Buf[0] ) {
            *VarData->wChar = (WCHAR) ConvertToIntegral(&Buf[1]);
        } else return ERROR_INVALID_DATA;
        return ERROR_SUCCESS;
    case Word:
        *VarData->Word = (WORD) ConvertToIntegral(Buf);
        return ERROR_SUCCESS;
    case DWord:
        *VarData->DWord = ConvertToIntegral(Buf);
        return ERROR_SUCCESS;
    case wString:
        return CloneWString(Buf, VarData->wString);
    case String:
        return CloneString(Buf, VarData->String);
    case IpAddress:
        *VarData->IpAddress = ConvertToAddress(Buf);
        return ERROR_SUCCESS;
    case xBytes:
        return ConvertToHexBytes(Buf, VarData->xBytesBuf, VarData->xBytesLen);
    default:
        verbose("unknown variable type\n");
        return ERROR_INVALID_DATA;
    }
}

//BeginExport(function)
DWORD
NjinExecuteLineA(
    IN      LPNJIN_ENV             Env,
    IN OUT  LPNJIN_VAR             Vars,
    IN      DWORD                  nVars,
    IN      LPWSTR                 Cmd
) //EndExport(function)
{
    CHAR                           Ch, LastCh;
    DWORD                          i, Result;
    LPWSTR                         Var;
    LPWSTR                         Value;

    Var = NULL; Value = NULL;
    for( i = 0; Cmd[i] != L'\0' ; i ++ ) {
        if( Env->cEquals == Cmd[i] ) break;
    }

    if( Cmd[i] ) {
        Cmd[i] = L'\0';
        Var = Cmd;
        Value = &Cmd[i+1];
    } else {
        verbose("No parameter passed\n");
        return ERROR_INVALID_DATA;
    }

    for( i = 0; i < nVars; i ++ ) {
        if( !Vars[i].ReadOnly && 0 == wcscmp(Vars[i].VarName, Var) )
            break;
    }

    if( i >= nVars ) {
        verbose("No such variable or operation\n");
        return ERROR_FILE_NOT_FOUND;
    }

    Result = ConvertDataType(Env, Value, Vars[i].VarType, &Vars[i].VarData);
    if( ERROR_SUCCESS != Result ) {
        verbose("ConvertDataType: 0x%lx (%ld)\n", Result, Result );
        return Result;
    }

    if( Vars[i].VarFunc ) Vars[i].VarFunc(Vars[i].VarName );
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
NjinExecute(
    IN      LPNJIN_ENV             Env,
    IN OUT  LPNJIN_VAR             Vars,
    IN      DWORD                  nVars
) //EndExport(function)
{
    char                           ch, lastch;
    WCHAR                          buffer[1000];
    unsigned int                   i;
    DWORD                          Result;

    verbose("NjinExecute called\n");

    i = 0; lastch = (CHAR)Env->cEndOfLine;
    while ((ch = getchar()) != EOF ) {
        if( Env->cReturn == ch ) ch = (CHAR)Env->cEndOfLine;
        if( Env->cEndOfLine == lastch && Env->cComment == ch ) {
            while((ch = getchar()) != EOF && Env->cEndOfLine != ch )
                ;
            lastch = ch;
            continue;
        }

        if( Env->cEndOfLine == ch ) {
            if( i ) {
                buffer[i] = L'\0';
                Result = NjinExecuteLineA(Env,Vars,nVars, buffer);
                if( ERROR_SUCCESS != Result ) {
                    verbose("Error: %ld (0x%lx)\n", Result, Result);
                return Result;
                }
            }
            i = 0;
        } else {
            buffer[i++] = (WCHAR)ch;
        }
        lastch = ch;
    }

    return ERROR_SUCCESS;
}

//================================================================================
//  DHCP SNAPIN DS WORK -- helper routines
//================================================================================

STORE_HANDLE                       hStore1, hStore2, hStore3, hStore4;
LPSTORE_HANDLE                     hRoot = NULL, hDhcpC = NULL, hObject = NULL, hDhcpRoot = NULL;
WCHAR                              gDsServer[100], gObject[100], gName[100], gComment[100];
WCHAR                              gClassName[100], gClassComment[100];
WCHAR                              Dummy[100];
WCHAR                              gOptName[100], gOptComment[100];
WCHAR                              gServerName[256];

DWORD                              gServerAddress, gServerState;
DWORD                              gOptId, gOptType, gOptLen, gIsVendor;
DWORD                              gDwordOptData;
BYTE                               gOptVal[255], gClassData[255];
DWORD                              gClassDataLen;

VOID
print_DHCP_OPTION_DATA(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION_DATA     OptData
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("NumElements=%ld, Type=%ld [0x%lx]\n",
           OptData->NumElements, OptData->Elements[0].OptionType, OptData->Elements[0].Element.DWordOption
    );
}

VOID
print_DHCP_OPTION(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION          Option
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("Option [x%03x] %ws %ws Type= %ld\n",
           Option->OptionID, Option->OptionName, Option->OptionComment?Option->OptionComment:L"", Option->OptionType
    );

    print_DHCP_OPTION_DATA(nTabs+1, &Option->DefaultValue);
}

VOID
print_DHCP_OPTION_ARRAY(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION_ARRAY    OptArray
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');
    printf("NumElements= %ld\n", OptArray->NumElements);

    for( i = 0; i < OptArray->NumElements; i++ )
        print_DHCP_OPTION(nTabs+1, &OptArray->Options[i]);
}

VOID
print_DHCP_OPTION_VALUE(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION_VALUE    OptVal
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("OptionId=%ld\n", OptVal->OptionID);
    print_DHCP_OPTION_DATA(nTabs+1, &OptVal->Value);
}

VOID
print_DHCP_OPTION_VALUE_ARRAY(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION_VALUE_ARRAY  OptValues
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("NumElements=%ld\n", OptValues->NumElements);
    for( i = 0; i < OptValues->NumElements ; i ++ )
        print_DHCP_OPTION_VALUE(nTabs+1, &OptValues->Values[i]);
}

VOID
print_DHCP_CLASS_INFO(
    IN      DWORD                  nTabs,
    IN      LPDHCP_CLASS_INFO      ClassInfo
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("ClassName= %ws ClassComment= %ws DataLength = %ld\n",
           ClassInfo->ClassName, ClassInfo->ClassComment, ClassInfo->ClassDataLength
    );
}

VOID
print_DHCP_CLASS_INFO_ARRAY(
    IN      DWORD                  nTabs,
    IN      LPDHCP_CLASS_INFO_ARRAY ClassInfoArray
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("NumElements=%ld\n", ClassInfoArray->NumElements);
    for( i = 0; i < ClassInfoArray->NumElements ; i ++ )
        print_DHCP_CLASS_INFO(nTabs+1, &ClassInfoArray->Classes[i]);
}

VOID
print_DHCPDS_SERVER(
    IN      DWORD                  nTabs,
    IN      LPDHCPDS_SERVER        Server
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("Name=[%ws] State=%ld Address=%s Loc=[%ws] Type=%ld\n",
           Server->ServerName, Server->Flags, inet_ntoa(*(struct in_addr *)&Server->IpAddress),
           Server->DsLocation? Server->DsLocation: L"(NULL)",
           Server->DsLocType
    );
}

VOID
print_DHCPDS_SERVERS(
    IN      DWORD                  nTabs,
    IN      LPDHCPDS_SERVERS       Servers
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("NumElements=%ld\n", Servers->NumElements);
    for( i = 0; i < Servers->NumElements ; i ++ )
        print_DHCPDS_SERVER(nTabs+1, &Servers->Servers[i]);
}

VOID
SetDsServer(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Err;

    if( NULL != hRoot ) {
        StoreCleanupHandle(hRoot, 0, TRUE);
    }

    hRoot = &hStore1;
    Err = StoreInitHandle(
        hRoot,
        0,
        wcslen(gDsServer)?gDsServer:NULL,
        NULL,
        NULL,
        NULL,
        0
    );
    if( ERROR_SUCCESS != Err ) {
        printf("StoreInitHandle():%ld 0x%lx\n", Err, Err);
        hRoot = NULL;
        return ;
    }

    if( hDhcpC ) StoreCleanupHandle(hDhcpC, 0, TRUE);
    hDhcpC = &hStore2;

    Err = StoreGetHandle(
        hRoot,
        0,
        StoreGetChildType,
        DHCP_ROOT_OBJECT_PARENT_LOC,
        hDhcpC
    );
    if( ERROR_SUCCESS != Err ) {
        printf("StoreInitHandle():%ld 0x%lx\n", Err, Err);
        hRoot = NULL;
        return ;
    }

    if( hDhcpRoot ) StoreCleanupHandle(hDhcpRoot, 0, TRUE);
    hDhcpRoot = &hStore4;
    Err = DhcpDsGetRoot(
        DDS_FLAGS_CREATE,
        hRoot,
        hDhcpRoot
    );

    if( ERROR_SUCCESS != Err) {
        printf("DhcpDsGetRoot(): %ld 0x%lx", Err, Err);
        hDhcpRoot = NULL;
    }
}

VOID
SetObject(
    IN      LPWSTR                 VarNameUnused
)
{
}

VOID
CreateOptDef(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsCreateOptionDef(
        hDhcpC,
        hObject,
        0,
        gOptName,
        wcslen(gOptComment)?gOptComment:NULL,
        wcslen(gClassName)?gClassName: NULL,
        gOptId,
        gOptType,
        gOptVal,
        gOptLen
    );

    printf("DhcpDsCreateOptionDef: %ld (0x%lx)\n", Result, Result);
}

VOID
ModifyOptDef(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsModifyOptionDef(
        hDhcpC,
        hObject,
        0,
        gOptName,
        wcslen(gOptComment)?gOptComment:NULL,
        wcslen(gClassName)?gClassName: NULL,
        gOptId,
        gOptType,
        gOptVal,
        gOptLen
    );

    printf("DhcpDsModifyOptionDef: %ld (0x%lx)\n", Result, Result);
}

VOID
DeleteOptDef(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsDeleteOptionDef(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)?gClassName: NULL,
        gOptId
    );

    printf("DhcpDsDeleteOptionDef: %ld (0x%lx)\n", Result, Result);
}

VOID
EnumOptDefs(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCP_OPTION_ARRAY            OptArray = NULL;

    Result = DhcpDsEnumOptionDefs(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)?gClassName: NULL,
        gIsVendor,
        &OptArray
    );

    printf("DhcpDsEnumOptionDefs: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCP_OPTION_ARRAY(0, OptArray);
    if( NULL != OptArray ) LocalFree(OptArray);
}

VOID
SetOptValue(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    DHCP_OPTION_DATA               OptData;
    DHCP_OPTION_DATA_ELEMENT       OptDataElement;

    OptData.NumElements = 1;
    OptData.Elements = &OptDataElement;
    OptDataElement.OptionType = DhcpDWordOption;
    OptDataElement.Element.DWordOption = gDwordOptData;

    Result = DhcpDsSetOptionValue(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)?gClassName: NULL,
        gOptId,
        &OptData
    );

    printf("DhcpDsSetOptionValue: %ld (0x%lx)\n", Result, Result);
}

VOID
RemoveOptValue(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsRemoveOptionValue(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)? gClassName : NULL,
        gOptId
    );

    printf("DhcpDsRemoveOptionValue: %ld (0x%lx)\n", Result, Result);
}

VOID
GetOptValue(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCP_OPTION_VALUE            OptVal = NULL;

    Result = DhcpDsGetOptionValue(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)? gClassName : NULL,
        gOptId,
        &OptVal
    );

    printf("DhcpDsGetOptionValue: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCP_OPTION_VALUE(0, OptVal);
    if( OptVal ) LocalFree(OptVal);
}

VOID
EnumOptValues(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCP_OPTION_VALUE_ARRAY      OptValues = NULL;

    Result = DhcpDsEnumOptionValues(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)? gClassName : NULL,
        gIsVendor,
        &OptValues
    );

    printf("DhcpDsEnumOptionValue: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCP_OPTION_VALUE_ARRAY(0, OptValues);
    if( OptValues ) LocalFree(OptValues);
}

VOID
CreateClass(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsCreateClass(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)? gClassName : NULL,
        wcslen(gClassComment)? gClassComment : NULL,
        gClassData,
        gClassDataLen
    );
    printf("DhcpDsCreateClass: %ld (0x%lx)\n", Result, Result);
}

VOID
DeleteClass(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsDeleteClass(
        hDhcpC,
        hObject,
        0,
        gClassName
    );
    printf("DhcpDsDeleteClass: %ld (0x%lx)\n", Result, Result);
}

VOID
EnumClasses(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCP_CLASS_INFO_ARRAY        Classes = NULL;

    Result = DhcpDsEnumClasses(
        hDhcpC,
        hObject,
        0,
        &Classes
    );

    printf("DhcpDsEnumClasses: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCP_CLASS_INFO_ARRAY(0, Classes);
    if( Classes ) LocalFree(Classes);
}

VOID
AddServer(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsAddServer(
        hDhcpC,
        hDhcpRoot,
        0,
        gServerName,
        NULL,
        gServerAddress,
        gServerState
    );

    printf("DhcpDsAddServer: %ld (0x%lx)\n", Result, Result);
}

VOID
DelServer(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsDelServer(
        hDhcpC,
        hDhcpRoot,
        0,
        gServerName,
        NULL,
        gServerAddress
    );

    printf("DhcpDsDelServer: %ld (0x%lx)\n", Result, Result);
}

VOID
EnumServers(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCPDS_SERVERS               Servers;

    Servers = NULL;
    Result = DhcpDsEnumServers(
        hDhcpC,
        hDhcpRoot,
        0,
        &Servers
    );

    printf("DhcpDsEnumServer: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCPDS_SERVERS( 0, Servers);
    if( Servers ) MemFree(Servers);
}


NJIN_VAR VarTable[] = {
    L"DsServer",   wString, { (LPVOID) &gDsServer }, SetDsServer, FALSE,   //0
    L"Object",     wString, { (LPVOID) &gObject }, SetObject,  FALSE,      //1
    L"OptName",    wString, { (LPVOID) &gOptName }, NULL, FALSE,           //2
    L"OptComment", wString, { (LPVOID) &gOptComment }, NULL, FALSE,        //3
    L"ClassName",  wString, { (LPVOID) &gClassName }, NULL, FALSE,         //4
    L"ClassComment",wString,{ (LPVOID) &gClassComment }, NULL, FALSE,      //5
    L"OptId",      DWord, { (LPVOID) &gOptId }, NULL, FALSE,               //6
    L"OptType",    DWord, { (LPVOID) &gOptType }, NULL, FALSE,             //7
    L"OptData",    xBytes, { (LPVOID) NULL }, NULL, FALSE, //############ -> Need to fill pointer..
    L"IsVendor",   DWord, { (LPVOID) &gIsVendor }, NULL, FALSE,            //9
    L"DwordOptData", DWord, { (LPVOID) &gDwordOptData }, NULL, FALSE,      //10
    L"ClassData",  xBytes, { (LPVOID) NULL }, NULL, FALSE, //############ -> need to fill pointer
    L"ServerName", wString, { (LPVOID) &gServerName }, NULL, FALSE,
    L"ServerAddress", IpAddress, { (LPVOID) &gServerAddress }, NULL, FALSE,
    L"ServerState", DWord, { (LPVOID) &gServerState }, NULL, FALSE,

    L"CreateOptionDef", wString, { (LPVOID) &Dummy }, CreateOptDef, FALSE, //12
    L"ModifyOptionDef", wString, { (LPVOID) &Dummy }, ModifyOptDef, FALSE,
    L"EnumOptionDefs",  wString, { (LPVOID) &Dummy }, EnumOptDefs, FALSE,
    L"SetOptionValue",  wString, { (LPVOID) &Dummy }, SetOptValue, FALSE,
    L"RemoveOptionValue", wString, { (LPVOID) &Dummy }, RemoveOptValue, FALSE,
    L"GetOptionValue",    wString, { (LPVOID) &Dummy }, GetOptValue, FALSE,
    L"EnumOptionValues",  wString, { (LPVOID) &Dummy }, EnumOptValues, FALSE,
    L"CreateClass",       wString, { (LPVOID) &Dummy }, CreateClass, FALSE,
    L"DeleteClass",       wString, { (LPVOID) &Dummy }, DeleteClass, FALSE,
    L"EnumClasses",       wString, { (LPVOID) &Dummy }, EnumClasses, FALSE,
    L"AddServer",         wString, { (LPVOID) &Dummy }, AddServer, FALSE,
    L"DelServer",         wString, { (LPVOID) &Dummy }, DelServer, FALSE,
    L"EnumServers",       wString, { (LPVOID) &Dummy }, EnumServers, FALSE,
};

NJIN_ENV Env[] = {
    L'#',
    L'=',
    L'\r',
    L'\n',
    L' ',
    L'#',
    TRUE,
    TRUE
};

#define  VarTableSz                (sizeof(VarTable)/sizeof(VarTable[0]))

void _cdecl main (void) {
    DWORD                          Result;
    DWORD                          i;

    VarTable[8].VarData.xBytesLen = &gOptLen;
    VarTable[8].VarData.xBytesBuf = gOptVal;
    VarTable[11].VarData.xBytesLen = &gClassDataLen;
    VarTable[11].VarData.xBytesBuf = gClassData;

    Result = NjinExecute(
        Env,
        VarTable,
        VarTableSz
    );

    if( ERROR_SUCCESS != Result ) {
        printf("\nResult = %ld\n", Result);
    }
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\validate.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

//DOC This function is declared in dhcpds.c..
//DOC DhcpDsValidateService checks the given service in the DS to see if it exists
//DOC If the machine is a standalone, it sets IsStandAlone and returns ERROR_SUCCESS
//DOC If the entry for the given Address is found, it sets Found to TRUE and returns
//DOC ERROR_SUCCESS. If the DhcpRoot node is found, but entry is not Found, it sets
//DOC Found to FALSE and returns ERROR_SUCCESS; If the DS could not be reached, it
//DOC returns ERROR_FILE_NOT_FOUND
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses, OPTIONAL
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpexim\dhcpeximdlg.cpp ===
// DhcpEximDlg.cpp : implementation file
//

#include "stdafx.h"
#include "DhcpEximx.h"
#include "DhcpEximDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximDlg dialog

CDhcpEximDlg::CDhcpEximDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDhcpEximDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDhcpEximDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CDhcpEximDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDhcpEximDlg)
    DDX_Control(pDX, IDC_RADIO_EXPORT, m_ExportButton);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDhcpEximDlg, CDialog)
	//{{AFX_MSG_MAP(CDhcpEximDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximDlg message handlers

BOOL CDhcpEximDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
    
	// TODO: Add extra initialization here
	m_ExportButton.SetCheck(1);     // Set default as export
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDhcpEximDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDhcpEximDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


void CDhcpEximDlg::OnOK() 
{
	// TODO: Add extra validation here

	// Check whether export or import was chosen by user
	m_fExport = ( m_ExportButton.GetCheck() == 1 ) ;

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpds\upndown.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

//DOC DhcpDsGetLastUpdateTime gets the last update time for the server
//DOC specified by name. If the server does not exist, or if server object doesnt
//DOC exist, then an error is returned.  If the time value
//DOC does not exist on the server object, again, an error is returned.
DWORD
DhcpDsGetLastUpdateTime(                          // last update time for server
    IN      LPWSTR                 ServerName,    // this is server of interest
    IN OUT  LPFILETIME             Time           // fill in this w./ the time
) ;


//DOC AddServer should add the new address to the server's attribs
//DOC it should take this opportunity to reconcile the server.
//DOC Currently it does nothing. (at the least it should probably try to
//DOC check if the object exists, and if not create it.)
//DOC
DWORD
AddServer(                                        // add server and do misc work
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for server obj
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ADsPath,       // ADS path to server object
    IN      DWORD                  IpAddress,     // IpAddress to add to server
    IN      DWORD                  State          // state of server
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpexim\dhcpeximdlg.h ===
// DhcpEximDlg.h : header file
//

#if !defined(AFX_DHCPEXIMDLG_H__2EE7F593_59A2_4FD6_ADA0_1356016342BC__INCLUDED_)
#define AFX_DHCPEXIMDLG_H__2EE7F593_59A2_4FD6_ADA0_1356016342BC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximDlg dialog

class CDhcpEximDlg : public CDialog
{
// Construction
public:
	CDhcpEximDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CDhcpEximDlg)
	enum { IDD = IDD_DHCPEXIM_DIALOG };
	CButton	m_ExportButton;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDhcpEximDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CDhcpEximDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    BOOL m_fExport;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DHCPEXIMDLG_H__2EE7F593_59A2_4FD6_ADA0_1356016342BC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpexim\dhcpeximx.h ===
// DhcpExim.h : main header file for the DHCPEXIM application
//

#if !defined(AFX_DHCPEXIM_H__AE7A8DB3_03A5_426B_8B03_105934DB8466__INCLUDED_)
#define AFX_DHCPEXIM_H__AE7A8DB3_03A5_426B_8B03_105934DB8466__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximApp:
// See DhcpExim.cpp for the implementation of this class
//

class CDhcpEximApp : public CWinApp
{
public:
	CDhcpEximApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDhcpEximApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CDhcpEximApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DHCPEXIM_H__AE7A8DB3_03A5_426B_8B03_105934DB8466__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpexim\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DhcpExim.rc
//
#define IDS_EXPORT_TO_FILE              1
#define IDS_IMPORT_FROM_FILE            2
#define IDS_ERROR_INITIALIZATION        3
#define IDS_ERROR_CLEANUP               4
#define IDS_ERROR_CLASS_CONFLICT        5
#define IDS_ERROR_OPTDEF_CONFLICT       6
#define IDS_ERROR_OPTION_CONFLICT       7
#define IDS_ERROR_SUBNET_OPTION_CONFLICT 8
#define IDS_ERROR_RES_OPTION_CONFLICT   9
#define IDS_ERROR_SUBNET_NOT_FOUND      10
#define IDS_ERROR_SUBNET_CONFLICT       11
#define IDS_ERROR_DBENTRY_FAILED        12
#define IDS_SUCCEEDED                   13

#define IDD_DHCPEXIM_DIALOG             102
#define IDD_EXIM_LISTVIEW_DIALOG        103
#define IDD_EXIM_LISTVIEW_DIALOG2       104
#define IDR_MAINFRAME                   128
#define IDC_RADIO_EXPORT                1000
#define IDC_RADIO_IMPORT                1001
#define IDC_BUTTON_CANCEL               1002
#define IDC_BUTTON_OK                   1003
#define IDC_LIST1                       1004
#define IDC_LIST2                       1005
#define IDC_STATIC_ACTION               1006
#define IDC_CHECK1                      1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpexim\dhcpeximlistdlg.cpp ===
// DhcpEximListDlg.cpp : implementation file
//

#include "stdafx.h"
#include "dhcpeximx.h"
extern "C" {
#include <dhcpexim.h>
}
#include "DhcpEximListDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// DhcpEximListDlg dialog

DhcpEximListDlg::DhcpEximListDlg(CWnd* pParent /*=NULL*/, PDHCPEXIM_CONTEXT Ctxtx , DWORD IDD)
    : CDialog(IDD, pParent)
{
    
	//{{AFX_DATA_INIT(DhcpEximListDlg)
	m_Message = _T("");
	//}}AFX_DATA_INIT
	m_PathName = Ctxtx->FileName;
	m_fExport = Ctxtx->fExport;
    Ctxt = Ctxtx;
    
	CString Str1(_T("&Select the scopes that will be exported to ") );
	CString Str2(_T("&Select the scopes that will be imported from ") );
	CString PathNameStr(m_PathName);
	CString Dot(_T("."));

	// TODO: Add extra initialization here
	if( m_fExport ) 
	{
		m_Message = Str1 + PathNameStr + Dot;
	}
	else
	{
		m_Message = Str2 + PathNameStr + Dot;
	}

}


void DhcpEximListDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DhcpEximListDlg)
	DDX_Control(pDX, IDC_LIST1, m_List);
	DDX_Text(pDX, IDC_STATIC_ACTION, m_Message);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DhcpEximListDlg, CDialog)
	//{{AFX_MSG_MAP(DhcpEximListDlg)
	ON_BN_CLICKED(IDOK, OnOk)
	ON_BN_CLICKED(IDCANCEL, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DhcpEximListDlg message handlers

BOOL DhcpEximListDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	for ( DWORD i = 0; i < Ctxt->nScopes; i ++ )
    {
        m_List.InsertItem(i, Ctxt->Scopes[i].SubnetName );
    }
    
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}




void DhcpEximListDlg::OnOk() 
{
	for( DWORD i = 0; i < Ctxt->nScopes; i ++ )
    {
        if( m_List.GetItemState( i, LVIS_SELECTED) == LVIS_SELECTED)
        {
            Ctxt->Scopes[i].fSelected = TRUE;
        }
        else
        {
            Ctxt->Scopes[i].fSelected = FALSE;
        }
    }

    if( m_fExport ) {
        Ctxt->fDisableExportedScopes = (0 != IsDlgButtonChecked(IDC_CHECK1));
    }

    CDialog::OnOK();
}

void DhcpEximListDlg::OnCancel() 
{
	// TODO: Add your control notification handler code here
	for( DWORD i = 0; i < Ctxt->nScopes; i ++ )
    {
        Ctxt->Scopes[i].fSelected = FALSE;
    }

    CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpexim\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DhcpExim.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpexim\dhcpeximlistdlg.h ===
#if !defined(AFX_DHCPEXIMLISTDLG_H__43CC976B_6C5A_4933_B8C8_44FEAE403B00__INCLUDED_)
#define AFX_DHCPEXIMLISTDLG_H__43CC976B_6C5A_4933_B8C8_44FEAE403B00__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DhcpEximListDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// DhcpEximListDlg dialog

class DhcpEximListDlg : public CDialog
{
// Construction
public:
	DhcpEximListDlg(CWnd* pParent = NULL,
                    PDHCPEXIM_CONTEXT Ctxt = NULL,
                    DWORD IDD=IDD_EXIM_LISTVIEW_DIALOG);   // standard constructor

// Dialog Data
	//{{AFX_DATA(DhcpEximListDlg)
	CListCtrl m_List;
	CString	m_Message;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DhcpEximListDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(DhcpEximListDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnOk();
	afx_msg void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	//
	// local variables
	//

	BOOL m_fExport;
	LPTSTR m_PathName;
    PDHCPEXIM_CONTEXT Ctxt;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DHCPEXIMLISTDLG_H__43CC976B_6C5A_4933_B8C8_44FEAE403B00__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpexim\dhcpeximx.cpp ===
// DhcpExim.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "DhcpEximx.h"
#include "DhcpEximDlg.h"
#include "CommDlg.h"
extern "C" {
#include <dhcpexim.h>
}
#include "DhcpEximListDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximApp

BEGIN_MESSAGE_MAP(CDhcpEximApp, CWinApp)
	//{{AFX_MSG_MAP(CDhcpEximApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximApp construction

CDhcpEximApp::CDhcpEximApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDhcpEximApp object

CDhcpEximApp theApp;

CString
ConvertErrorToString(
    IN DWORD Error
    )
{
    CString RetVal;
    LPTSTR Buffer = NULL;
    
    if( 0 != FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, Error, 0, (LPTSTR)&Buffer, 100, NULL ) ) {
        RetVal = Buffer;
        LocalFree( Buffer );
        return RetVal;
    }

    //
    // Just print out the error as a number:
    //

    RetVal.Format(TEXT("%ld."), Error );
    return RetVal;
}


VOID DoImportExport(BOOL fExport)
{
    BOOL fSuccess, fAbort;
    OPENFILENAME ofn;
    DWORD dwVersion = GetVersion();
    DWORD dwWindowsMajorVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    DWORD dwWindowsMinorVersion =  (DWORD)(HIBYTE(LOWORD(dwVersion)));
    TCHAR FileNameBuffer[MAX_PATH];
    CString Str;
    
    ZeroMemory( &ofn, sizeof(ofn));
    ZeroMemory( FileNameBuffer, sizeof(FileNameBuffer));
    
    if( (dwWindowsMajorVersion >= 5) )
    {
        //use the NT dialog file box
        ofn.lStructSize=sizeof(ofn);
    }
    else
    {
        //use the NT 4 dialog boxes
        ofn.lStructSize=76;
    }

    //determine the parent and instance of the file dialog
    //ofn.hwndOwner=m_hWnd;
    //ofn.hInstance=(HINSTANCE)GetWindowLongPtr(m_hWnd,GWLP_HINSTANCE);

    ofn.lpstrFile=(LPTSTR)FileNameBuffer;
    if( fExport )
    {
        Str.FormatMessage( IDS_EXPORT_TO_FILE );
    }
    else
    {
        Str.FormatMessage( IDS_IMPORT_FROM_FILE );
    }

    ofn.lpstrTitle = Str;
    ofn.lpstrFilter = TEXT("All Files\0*.*\0\0");
    ofn.nMaxFile=MAX_PATH;
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_EXPLORER | OFN_HIDEREADONLY ;
    ofn.Flags |= OFN_NOCHANGEDIR;
    
    //
    // for some vague reason, MFC requires me to run this twice!
    //
    

    if( fExport ) {
        fSuccess = GetSaveFileName(&ofn);
        fSuccess = GetSaveFileName(&ofn);
    } else {
        fSuccess = GetOpenFileName(&ofn);
        fSuccess = GetOpenFileName(&ofn);
    }

    //
    // If user cancelled this, silently return
    //
    
	if( !fSuccess ) return;

    DHCPEXIM_CONTEXT Ctxt;

    DWORD Error = DhcpEximInitializeContext(
        &Ctxt, FileNameBuffer, fExport );
    if( NO_ERROR != Error )
    {
        CString Str;

        Str.FormatMessage(
            IDS_ERROR_INITIALIZATION, (LPCTSTR)ConvertErrorToString(Error) );
        AfxMessageBox(Str);
        return;
    }

    //
    // The file to export to is FileNameBuffer.  Open the next window
    //

    DhcpEximListDlg Dlg(
        NULL, &Ctxt,
        fExport ? IDD_EXIM_LISTVIEW_DIALOG :
        IDD_EXIM_LISTVIEW_DIALOG2 );

    //
    // Now perform the operation
    //

    fAbort = (IDOK != Dlg.DoModal() );
    
	Error = DhcpEximCleanupContext( &Ctxt, fAbort  );
    if( NO_ERROR != Error )
    {

        if( ERROR_CAN_NOT_COMPLETE != Error ) {
            Str.FormatMessage(
                IDS_ERROR_CLEANUP, (LPCTSTR)ConvertErrorToString(Error) );
            AfxMessageBox( Str );
        }
    }
    else if( !fAbort )
    {
        Str.FormatMessage( IDS_SUCCEEDED );
        AfxMessageBox( Str );
    }
        
}


/////////////////////////////////////////////////////////////////////////////
// CDhcpEximApp initialization

BOOL CDhcpEximApp::InitInstance()
{
	int nResponse;
	BOOL fExport;

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    CDhcpEximDlg dlg;
    m_pMainWnd = &dlg;
    nResponse = (int)dlg.DoModal();
    fExport = dlg.m_fExport;

	if (nResponse == IDOK)
	{
        DoImportExport(fExport);
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

//
// Need to implement these routines..
// 

VOID
DhcpEximErrorClassConflicts(
    IN LPWSTR SvcClass,
    IN LPWSTR ConfigClass
    )
{
    CString Str;
    
    Str.FormatMessage(
        IDS_ERROR_CLASS_CONFLICT, SvcClass, ConfigClass );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorOptdefConflicts(
    IN LPWSTR SvcOptdef,
    IN LPWSTR ConfigOptdef
    )
{
    CString Str;
    
    Str.FormatMessage(
        IDS_ERROR_OPTDEF_CONFLICT, SvcOptdef, ConfigOptdef );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorOptionConflits(
    IN LPWSTR SubnetName OPTIONAL,
    IN LPWSTR ResAddress OPTIONAL,
    IN LPWSTR OptId,
    IN LPWSTR UserClass OPTIONAL,
    IN LPWSTR VendorClass OPTIONAL
    )
{
    CString Str;
    DWORD MsgId;
    
    if( NULL == SubnetName ) {
        MsgId = IDS_ERROR_OPTION_CONFLICT;
    } else if( NULL == ResAddress ) {
        MsgId = IDS_ERROR_SUBNET_OPTION_CONFLICT;
    } else {
        MsgId = IDS_ERROR_RES_OPTION_CONFLICT;
    }

    if( NULL == UserClass ) UserClass = L"";
    if( NULL == VendorClass ) VendorClass = L"";
    
    Str.FormatMessage(
         MsgId, OptId, UserClass, VendorClass, SubnetName, ResAddress );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorSubnetNotFound(
    IN LPWSTR SubnetAddress
    )
{
    CString Str;
    
    Str.FormatMessage(
        IDS_ERROR_SUBNET_NOT_FOUND, SubnetAddress );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorSubnetAlreadyPresent(
    IN LPWSTR SubnetAddress,
    IN LPWSTR SubnetName OPTIONAL
    )
{
    CString Str;

    if( NULL == SubnetName ) SubnetName = L"";
    Str.FormatMessage(
         IDS_ERROR_SUBNET_CONFLICT, SubnetAddress, SubnetName );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorDatabaseEntryFailed(
    IN LPWSTR ClientAddress,
    IN LPWSTR ClientHwAddress,
    IN DWORD Error,
    OUT BOOL *fAbort
    )
{
    CString Str;
    WCHAR ErrStr[30];
    
    wsprintf(ErrStr, L"%ld", Error );

    Str.FormatMessage(
        IDS_ERROR_DBENTRY_FAILED, ClientAddress, ClientHwAddress,
        ErrStr);
    (*fAbort) = ( IDYES == AfxMessageBox( Str, MB_YESNO ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\dhcpexim\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__0BD5FBCA_CF28_490E_BBAF_CDDE921E6E14__INCLUDED_)
#define AFX_STDAFX_H__0BD5FBCA_CF28_490E_BBAF_CDDE921E6E14__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0BD5FBCA_CF28_490E_BBAF_CDDE921E6E14__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\iterate.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    iterate.c

Abstract:

    This module contains routines that iterate over the MM data structures

--*/

#include <precomp.h>

DWORD
IterateClasses(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_CLASSDEF ClassDef;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = Server;
    Error = MemArrayInitLoc( &Server->ClassDefs.ClassDefArray, &Loc );
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Server->ClassDefs.ClassDefArray, &Loc, &ClassDef );
        ASSERT( NO_ERROR == Error );

        Ctxt.ClassDef = ClassDef;
        Error = Callback( &Ctxt );
        if( ERROR_KEY_DELETED == Error ) {
            //
            // Delete this class ..
            //
            MemArrayDelElement(
                &Server->ClassDefs.ClassDefArray, &Loc, &ClassDef );
            MemClassDefFree( ClassDef );

            Error = MemArrayAdjustLocation(
                &Server->ClassDefs.ClassDefArray, &Loc );
        } else {
            if( NO_ERROR != Error ) return Error;
            
            Error = MemArrayNextLoc(
                &Server->ClassDefs.ClassDefArray, &Loc );
        }
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

PM_CLASSDEF
FindClass(
    IN PM_SERVER Server,
    IN ULONG ClassId
    )
{
    DWORD Error;
    PM_CLASSDEF Class;

    if( 0 == ClassId ) return NULL;

    Error = MemServerGetClassDef(
        Server, ClassId, NULL, 0, NULL, &Class );

    if( NO_ERROR == Error ) return Class;
    return NULL;
}

DWORD
IterateOptDefs(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc, Loc2;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_OPTDEF OptDef;
    PM_OPTCLASSDEFL_ONE OptClassDefList;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = Server;
    Error = MemArrayInitLoc( &Server->OptDefs.Array, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Server->OptDefs.Array, &Loc, &OptClassDefList );
        ASSERT( NO_ERROR == Error );

        Ctxt.UserClass = FindClass( Server, OptClassDefList->ClassId );
        Ctxt.VendorClass = FindClass( Server, OptClassDefList->VendorId );
        
        Error = MemArrayInitLoc(
            &OptClassDefList->OptDefList.OptDefArray, &Loc2 );
        while( NO_ERROR == Error ) {

            Error = MemArrayGetElement(
                &OptClassDefList->OptDefList.OptDefArray, &Loc2,
                &OptDef );
            ASSERT( NO_ERROR == Error );

            Ctxt.OptDef = OptDef;
            Error = Callback( &Ctxt );
            if( ERROR_KEY_DELETED == Error ) {
                //
                // Delete this optdef..
                //
                MemArrayDelElement(
                    &OptClassDefList->OptDefList.OptDefArray,
                    &Loc2, &OptDef );
                MemOptDefFree( OptDef );

                Error = MemArrayAdjustLocation(
                    &OptClassDefList->OptDefList.OptDefArray,
                    &Loc2 );
            } else {
                if( NO_ERROR != Error ) return Error;

                Error = MemArrayNextLoc(
                    &OptClassDefList->OptDefList.OptDefArray, &Loc2 );
            }
        }
        
        if( ERROR_FILE_NOT_FOUND != Error ) return Error;
                                     
        Error = MemArrayNextLoc( &Server->OptDefs.Array, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

DWORD
IterateOptionsOnOptClass(
    IN PM_SERVER Server,
    IN PM_OPTCLASS OptClass,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc, Loc2;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_OPTION Option;
    PM_ONECLASS_OPTLIST OptList;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = Server;
    Error = MemArrayInitLoc( &OptClass->Array, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &OptClass->Array, &Loc, &OptList );
        ASSERT( NO_ERROR == Error );

        Ctxt.UserClass = FindClass( Server, OptList->ClassId );
        Ctxt.VendorClass = FindClass( Server, OptList->VendorId );
        
        Error = MemArrayInitLoc( &OptList->OptList, &Loc2 );
        while( NO_ERROR == Error ) {

            Error = MemArrayGetElement(
                &OptList->OptList, &Loc2, &Option );
            ASSERT( NO_ERROR == Error );

            Ctxt.Option = Option;
            Error = Callback( &Ctxt );
            if( NO_ERROR != Error ) return Error;

            Error = MemArrayNextLoc( &OptList->OptList, &Loc2 );
        }
        if( ERROR_FILE_NOT_FOUND != Error ) return Error;
                                     
        Error = MemArrayNextLoc( &OptClass->Array, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}
    

DWORD
IterateServerOptions(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    return IterateOptionsOnOptClass(
        Server, &Server->Options, ExtraCtxt, Callback );
}

DWORD
IterateScopeOptions(
    IN PM_SUBNET Subnet,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    return IterateOptionsOnOptClass(
        (PM_SERVER)Subnet->ServerPtr,
        &Subnet->Options, ExtraCtxt, Callback );
}

DWORD
IterateReservationOptions(
    IN PM_SERVER Server,
    IN PM_RESERVATION Res,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    PM_SUBNET Subnet = NULL;

    MemServerGetUAddressInfo(
        Server, Res->Address, &Subnet, NULL, NULL, NULL );
    
    return IterateOptionsOnOptClass(
        Server, &Res->Options, ExtraCtxt, Callback );
}    

PM_SSCOPE
FindSScope(
    IN PM_SERVER Server,
    IN DWORD SScopeId
    )
{
    DWORD Error;
    PM_SSCOPE SScope;

    if( SScopeId == INVALID_SSCOPE_ID ) return NULL;
    Error = MemServerFindSScope(
        Server, SScopeId, NULL, &SScope );
    if( NO_ERROR != Error ) return NULL;
    return SScope;
}

DWORD
IterateScopes(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_SUBNET Scope;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = Server;
    Error = MemArrayInitLoc( &Server->Subnets, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Server->Subnets, &Loc, &Scope );
        ASSERT( NO_ERROR == Error );

        Ctxt.SScope = FindSScope( Server, Scope->SuperScopeId );
        Ctxt.Scope = Scope;
        Error = Callback( &Ctxt );

        if( ERROR_KEY_DELETED == Error ) {
            //
            // Delete this scope
            //
            MemArrayDelElement(
                &Server->Subnets, &Loc, &Scope );
            MemSubnetFree( Scope );

            Error = MemArrayAdjustLocation(
                &Server->Subnets, &Loc );
        } else {
            if( NO_ERROR != Error ) return Error;
            
            Error = MemArrayNextLoc( &Server->Subnets, &Loc );
        }
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

DWORD
IterateScopeRanges(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_RANGE Range;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = (PM_SERVER)Scope->ServerPtr;
    Error = MemArrayInitLoc( &Scope->Ranges, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Scope->Ranges, &Loc, &Range );
        ASSERT( NO_ERROR == Error );

        Ctxt.Range = Range;
        Error = Callback( &Ctxt );
        if( NO_ERROR != Error ) return Error;
        
        Error = MemArrayNextLoc( &Scope->Ranges, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

DWORD
IterateScopeExclusions(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_EXCL Excl;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = (PM_SERVER)Scope->ServerPtr;
    Error = MemArrayInitLoc( &Scope->Exclusions, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Scope->Exclusions, &Loc, &Excl );
        ASSERT( NO_ERROR == Error );

        Ctxt.Excl = Excl;
        Error = Callback( &Ctxt );
        if( NO_ERROR != Error ) return Error;
        
        Error = MemArrayNextLoc( &Scope->Exclusions, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

DWORD
IterateScopeReservations(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_RESERVATION Res;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = (PM_SERVER)Scope->ServerPtr;
    Error = MemArrayInitLoc( &Scope->Reservations, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Scope->Reservations, &Loc, &Res );
        ASSERT( NO_ERROR == Error );

        Ctxt.Res = Res;
        Error = Callback( &Ctxt );
        if( NO_ERROR != Error ) return Error;
        
        Error = MemArrayNextLoc( &Scope->Reservations, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\merge.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    merge.c

Abstract:

    this module merges the configurations provided via a pair of
    MM datastructures..

--*/

#include <precomp.h>

#include "server\uniqid.h"

BOOL
ClassesConflict(
    IN PM_CLASSDEF Class1,
    IN PM_CLASSDEF Class2
    )
{
    LPWSTR Comment1, Comment2;
    
    if( Class1->IsVendor != Class2->IsVendor ) return TRUE;
    if( wcscmp(Class1->Name, Class2->Name) ) return TRUE;
    Comment1 = Class1->Comment; Comment2 = Class2->Comment;
    if( NULL == Comment1 ) Comment1 = L"";
    if( NULL == Comment2 ) Comment2 = L"";
    if( wcscmp(Comment1, Comment2) ) return TRUE;
    if( Class1->nBytes != Class2->nBytes ) return TRUE;
    if( memcmp(Class1->ActualBytes, Class2->ActualBytes,
               Class1->nBytes ) ) {
        return TRUE;
    }

    return FALSE;
}

DWORD
AddClassesCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    PM_SERVER Server = Ctxt->ExtraCtxt;
    PM_CLASSDEF ClassDef;
    
    Error = MemServerGetClassDef(
        Server, 0,
        Ctxt->ClassDef->Name,
        Ctxt->ClassDef->nBytes,
        Ctxt->ClassDef->ActualBytes,
        &ClassDef );
    if( NO_ERROR == Error ) {
        //
        // Check if the classdef matches
        //

        if( ClassesConflict( ClassDef, Ctxt->ClassDef ) ) {
            Tr("Class %ws conflicts with class %ws\n",
               ClassDef->Name, Ctxt->ClassDef->Name );
            DhcpEximErrorClassConflicts(
                ClassDef->Name, Ctxt->ClassDef->Name );
            return ERROR_CAN_NOT_COMPLETE;
        }
        return NO_ERROR;
    }
    
    return MemServerAddClassDef(
        Server, MemNewClassId(),
        Ctxt->ClassDef->IsVendor,
        Ctxt->ClassDef->Name,
        Ctxt->ClassDef->Comment,
        Ctxt->ClassDef->nBytes,
        Ctxt->ClassDef->ActualBytes,
	INVALID_UNIQ_ID );
}

DWORD
GetClassIdByName(
    IN PM_SERVER Server,
    IN LPWSTR Name
    )
{
    PM_CLASSDEF ClassDef;
    DWORD Error;
    
    Error = MemServerGetClassDef(
        Server, 0, Name, 0, NULL, &ClassDef );
    if( NO_ERROR != Error ) return 0;
    return ClassDef->ClassId;
}

BOOL
OptDefsConflict(
    IN PM_OPTDEF OptDef1,
    IN PM_OPTDEF OptDef2
    )
{
    LPWSTR Comment1, Comment2;

    if( OptDef1->OptId != OptDef2->OptId ) return TRUE;
    if( wcscmp(OptDef1->OptName, OptDef2->OptName ) ) return TRUE;
    Comment1 = OptDef1->OptComment; Comment2 = OptDef2->OptComment;
    if( NULL == Comment1 ) Comment1 = L"";
    if( NULL == Comment2 ) Comment2 = L"";
    if( wcscmp(Comment1, Comment2) ) return TRUE;
    if( OptDef1->OptValLen != OptDef2->OptValLen ) return TRUE;
    if( memcmp(OptDef1->OptVal, OptDef2->OptVal,
               OptDef1->OptValLen)) return TRUE;
    
    return FALSE;
}

DWORD
AddOptdefsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error, ClassId, VendorId;
    PM_SERVER Server = Ctxt->ExtraCtxt;
    PM_OPTDEF OptDef;
    
    //
    // Get the user and vendor class id's
    //
    
    if( Ctxt->UserClass == NULL ) ClassId = 0;
    else {
        ClassId = GetClassIdByName( Server, Ctxt->UserClass->Name );
        if( 0 == ClassId ) {
            Tr("Class %ws doesnt exist\n", Ctxt->UserClass->Name );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    if( Ctxt->VendorClass == NULL ) VendorId = 0;
    else {
        VendorId = GetClassIdByName( Server, Ctxt->VendorClass->Name );
        if( 0 == VendorId ) {
            Tr("Class %ws doesnt exist\n", Ctxt->VendorClass->Name );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    //
    // Next check if the specified optdef exists already
    //

    Error = MemServerGetOptDef(
        Server, ClassId, VendorId, Ctxt->OptDef->OptId,
        Ctxt->OptDef->OptName, &OptDef );
    if( NO_ERROR == Error ) {
        if( OptDefsConflict( OptDef, Ctxt->OptDef ) ) {
            Tr("Optdef %ws conflicts with %ws\n",
               OptDef->OptName, Ctxt->OptDef->OptName );

            //
            // attempt to overwrite existing optdef
            //
            //DhcpEximErrorOptdefConflicts(
            //   OptDef->OptName, Ctxt->OptDef->OptName );
            // return ERROR_CAN_NOT_COMPLETE;
            return NO_ERROR;
        }
        return NO_ERROR;
    }

    //
    // Now add the optdef
    //

    return MemServerAddOptDef(
        Server, ClassId, VendorId, Ctxt->OptDef->OptId,
        Ctxt->OptDef->OptName, Ctxt->OptDef->OptComment,
        Ctxt->OptDef->Type, Ctxt->OptDef->OptVal,
        Ctxt->OptDef->OptValLen, INVALID_UNIQ_ID );
}    

        
DWORD static
SetOptionValue(
    IN PM_SERVER Server,
    IN PM_SUBNET Subnet OPTIONAL,
    IN PM_RESERVATION Res OPTIONAL,
    IN ULONG OptId,
    IN LPWSTR UserClass,
    IN LPWSTR VendorClass,
    IN LPBYTE Val,
    IN ULONG Len
)
{
    DWORD Error, ClassId, VendorId;
    PM_OPTCLASS OptClass;
    PM_OPTION Option, DeletedOption;

    //
    // Get the user and vendor class id's
    //
    
    if( UserClass == NULL ) ClassId = 0;
    else {
        ClassId = GetClassIdByName( Server, UserClass );
        if( 0 == ClassId ) {
            Tr("Class %ws doesnt exist\n", UserClass );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    if( VendorClass == NULL ) VendorId = 0;
    else {
        VendorId = GetClassIdByName( Server, VendorClass );
        if( 0 == VendorId ) {
            Tr("Class %ws doesnt exist\n", VendorClass );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }
    
    Error = MemOptInit( &Option, OptId, Len, Val );
    if( ERROR_SUCCESS != Error ) return Error;

    DeletedOption = NULL;

    if( NULL != Res ) {
        OptClass = &Res->Options;
    } else if( NULL != Subnet ) {
        OptClass = &Subnet->Options;
    } else {
        OptClass = &Server->Options;
    }
    
    Error = MemOptClassAddOption(
        OptClass, Option, ClassId, VendorId, &DeletedOption, INVALID_UNIQ_ID );

    if( ERROR_SUCCESS == Error && DeletedOption ) {
        MemFree(DeletedOption);               // if we did replace, free the old option
    }

    if( ERROR_SUCCESS != Error ) {                // something went wrong, clean up
        ULONG LocalError = MemOptCleanup(Option);
        ASSERT(ERROR_SUCCESS == LocalError);
    }

    return Error;
}

DWORD
GetOptionValue(
    IN PM_SERVER Server,
    IN PM_SUBNET Subnet OPTIONAL,
    IN PM_RESERVATION Res OPTIONAL,
    IN ULONG OptId,
    IN LPWSTR UserClass,
    IN LPWSTR VendorClass,
    OUT LPBYTE *Val,
    OUT ULONG *Len
    )
{
    DWORD Error, ClassId, VendorId;
    PM_OPTCLASS OptClass;
    PM_OPTLIST OptList;
    PM_OPTION Opt;

    //
    // Get the user and vendor class id's
    //
    
    if( UserClass == NULL ) ClassId = 0;
    else {
        ClassId = GetClassIdByName( Server, UserClass );
        if( 0 == ClassId ) {
            Tr("Class %ws doesnt exist\n", UserClass );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    if( VendorClass == NULL ) VendorId = 0;
    else {
        VendorId = GetClassIdByName( Server, VendorClass );
        if( 0 == VendorId ) {
            Tr("Class %ws doesnt exist\n", VendorClass );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    //
    // get the options
    //
    
    if( NULL != Res ) {
        OptClass = &Res->Options;
    } else if( NULL != Subnet ) {
        OptClass = &Subnet->Options;
    } else {
        OptClass = &Server->Options;
    }

    //
    // Check if option exists
    //
    
    Error = MemOptClassFindClassOptions(
        OptClass, ClassId, VendorId, &OptList );
    if( NO_ERROR == Error ) {

        Error = MemOptListFindOption( OptList, OptId, &Opt );

        if( NO_ERROR == Error ) {

            *Val = Opt->Val;
            *Len = Opt->Len;
            return NO_ERROR;
        }
    }

    return ERROR_DHCP_OPTION_NOT_PRESENT;
}

DWORD
AddOptionsCallbackEx(
    IN OUT PMM_ITERATE_CTXT Ctxt,
    IN PM_SUBNET Subnet OPTIONAL,
    IN PM_RESERVATION Res OPTIONAL
    )
{
    DWORD Error, Len;
    PM_SERVER Server = Ctxt->ExtraCtxt;
    LPBYTE Val;
    WCHAR Buff1[10], Buf2[30];
    LPWSTR ResAddress = NULL, OptId, SubnetName = NULL;
    
    //
    // Check for option conflict
    //

    wsprintf(Buff1, L"%ld", Ctxt->Option->OptId );
    OptId = (LPWSTR)Buff1;
    
    if( Res ) {
        Subnet = (PM_SUBNET) Res->SubnetPtr;
        IpAddressToStringW( Res->Address, Buf2);
        ResAddress = (LPWSTR)Buf2;
    }
    
    if( Subnet ) {
        Server = (PM_SERVER) Subnet->ServerPtr;
        SubnetName = Subnet->Name;
    }
    
    Error = GetOptionValue(
        Server, Subnet, Res, Ctxt->Option->OptId,
        Ctxt->UserClass ? Ctxt->UserClass->Name : NULL,
        Ctxt->VendorClass ? Ctxt->VendorClass->Name : NULL,
        &Val , &Len );
    if( NO_ERROR == Error ) {
        if( Len != Ctxt->Option->Len ||
            memcmp( Ctxt->Option->Val, Val, Len ) ) {
            
            Tr("Options conflict for opt id %ld\n", Ctxt->Option->OptId );
            DhcpEximErrorOptionConflits(
                SubnetName, ResAddress, OptId,
                Ctxt->UserClass ? Ctxt->UserClass->Name : NULL,
                Ctxt->VendorClass ? Ctxt->VendorClass->Name : NULL
                );
            return ERROR_CAN_NOT_COMPLETE;
        }

        return NO_ERROR;
    } else if( ERROR_DHCP_OPTION_NOT_PRESENT != Error ) {
        Tr("GetOptionValue: %ld\n", Error );
        return Error;
    }
    
    //
    // Create option
    //

    return SetOptionValue( 
        Server, Subnet, Res, Ctxt->Option->OptId,
        Ctxt->UserClass ? Ctxt->UserClass->Name : NULL,
        Ctxt->VendorClass ? Ctxt->VendorClass->Name : NULL,
        Ctxt->Option->Val, Ctxt->Option->Len );
}

DWORD
AddOptionsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    return AddOptionsCallbackEx(
        Ctxt, NULL, NULL );
}

DWORD
AddSubnetOptionsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    return AddOptionsCallbackEx(
        Ctxt, (PM_SUBNET)Ctxt->ExtraCtxt, NULL );

}

DWORD
AddReservationOptionsCallback(
    IN PMM_ITERATE_CTXT Ctxt
    )
{
    return AddOptionsCallbackEx(
        Ctxt, NULL, (PM_RESERVATION)Ctxt->ExtraCtxt );
}

DWORD
AddReservationsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    PM_SERVER Server;
    PM_SUBNET Subnet;
    PM_RESERVATION Res;

    //
    // Create the reservations
    //

    Server = ((PM_SUBNET)Ctxt->ExtraCtxt)->ServerPtr;
    Error = MemServerGetAddressInfo(
        Server, Ctxt->Res->Address, &Subnet, NULL, NULL, NULL );
    ASSERT( NO_ERROR == Error );
    
    Error = MemReserveAdd(
        &Subnet->Reservations, Ctxt->Res->Address,
        Ctxt->Res->Flags, Ctxt->Res->ClientUID, Ctxt->Res->nBytes,
	INVALID_UNIQ_ID ); 
    if( NO_ERROR != Error ) return Error;

    Error = MemServerGetAddressInfo(
        Server, Ctxt->Res->Address, NULL, NULL, NULL, &Res );
    ASSERT( NO_ERROR == Error );
    
    //
    // Now add subnet options
    //

    Res->SubnetPtr = Subnet;
    Error = IterateReservationOptions(
        Ctxt->Server, Ctxt->Res, Res, AddReservationOptionsCallback );

    if( NO_ERROR != Error ) {
        Tr("AddReservationOptionsCallback: %ld\n", Error );
        return Error;
    }

    return NO_ERROR;
}

    
DWORD
AddSubnetsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error, SScopeId;
    PM_SUBNET Subnet;
    PM_SSCOPE SScope;
    PM_SERVER Server = Ctxt->ExtraCtxt;
    WCHAR SubnetIpAdress[30];

    IpAddressToStringW(Ctxt->Scope->Address, (LPWSTR)SubnetIpAdress);

    //
    // First locate the superscope and create it if needed
    //

    SScopeId = 0;
    if( NULL != Ctxt->SScope ) {
        Error = MemServerFindSScope(
            Server, 0, Ctxt->SScope->Name, &SScope );
        if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = MemSScopeInit(
                &SScope, 0, Ctxt->SScope->Name );
            if( NO_ERROR != Error ) return Error;
            
            Error = MemServerAddSScope(Server,SScope);
            ASSERT( NO_ERROR == Error );
            if( NO_ERROR != Error ) return Error;

        } else if( NO_ERROR != Error ) {
            
            Tr("FindSScope(%ws):%ld\n", Ctxt->SScope->Name, Error);
            return Error;
        }

        SScopeId = SScope->SScopeId;
    }
    
    //
    // Create the subnet..
    //

    Error = MemSubnetInit(
        &Subnet,
        Ctxt->Scope->Address,
        Ctxt->Scope->Mask,
        Ctxt->Scope->State,
        SScopeId,
        Ctxt->Scope->Name,
        Ctxt->Scope->Description
    );
    if( ERROR_SUCCESS != Error ) return Error;

    //
    // Add the subnet..
    //
    
    Error = MemServerAddSubnet( Server, Subnet, INVALID_UNIQ_ID );
    if( NO_ERROR != Error ) {
        MemSubnetCleanup( Subnet );

        if( ERROR_OBJECT_ALREADY_EXISTS == Error ) {
            //
            // Subnet already exists -- this is a conflict
            //
            DhcpEximErrorSubnetAlreadyPresent(
                (LPWSTR)SubnetIpAdress, Ctxt->Scope->Name );
                
            Error = ERROR_CAN_NOT_COMPLETE;
        }

        Tr("AddSubnet %ws failed: %ld\n", Ctxt->Scope->Name, Error );
        return Error;
    }

    //
    // Before adding the options, first copy the ranges and
    // exclusions.. 
    //

    Subnet->Ranges = Ctxt->Scope->Ranges;
    Subnet->Exclusions = Ctxt->Scope->Exclusions;
    MemArrayInit( &Ctxt->Scope->Ranges );
    MemArrayInit( &Ctxt->Scope->Exclusions );
    
    //
    // now add the other stuff
    //
    
    Error = IterateScopeOptions(
        Ctxt->Scope, Subnet, AddSubnetOptionsCallback );

    if( NO_ERROR != Error ) {
        Tr("AddSubnetOptionsCallback: %ld\n", Error );
        return Error;
    }

    Error = IterateScopeReservations(
        Ctxt->Scope, Subnet, AddReservationsCallback );

    if( NO_ERROR != Error ) {
        Tr("AddReservationsCallback: %ld\n", Error );
        return Error;
    }

    return NO_ERROR;
}

DWORD
MergeConfigurations(
    IN OUT PM_SERVER DestServer,
    IN OUT PM_SERVER Server
    )
/*++

Routine Description:

    This routine merges the configuration provided in "Server"
    onto the configuration already present in "DestServer".

    Rule 1.  The subnets that exist in DestServer should not
    conflict with the subnets that are to be merged from Server.

    Rule 2.  The classes that exist in DestServer should not
    conflict the classes that are to be added from Server.  

    Rule 3.  The optdefs that exist in DestServer should not
    conflict the optdefs that are to be added from Server.

    Rule 4.  The options that exist in DestServer shoult not
    conflict with the options that are to be added from Server.
      
    For all but the first rule, exact duplicates are not
    considered conflicts. 

    Note:  When subnet ranges and exclusions are merged in, they
    are also removed from "Server"...
    
--*/
{
    DWORD Error;

    Tr("Entering MergeConfigurations\n");
    
    //
    // Add the class defs first
    //
    
    Error = IterateClasses(
        Server, DestServer, AddClassesCallback );
    if( NO_ERROR != Error ) {
        Tr("AddClassesCallback: %ld\n", Error );
        return Error;
    }

    //
    // Add the optdefs
    //

    Error = IterateOptDefs(
        Server, DestServer, AddOptdefsCallback );
    if( NO_ERROR != Error ) {
        Tr("AddOptdefsCallback: %ld\n", Error );
        return Error;
    }

    //
    // Add the global options..
    //

    Error = IterateServerOptions(
        Server, DestServer, AddOptionsCallback );
    if( NO_ERROR != Error ) {
        Tr("AddOptionsCallback: %ld\n", Error );
        return Error;
    }

    //
    // Add the subnets
    //

    Error = IterateScopes(
        Server, DestServer, AddSubnetsCallback );
    if( NO_ERROR != Error ) {
        Tr("IterateScopes: %ld\n", Error );
        return Error;
    }

    //
    // done..
    //
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\mmfile.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    mmfile.c

Abstract;

    This file contains code to read/write MM data structures
    from/to internal file format.. code is nearly ripped off of
    server\dbconfig.c

--*/

#include <precomp.h>

#include "server\uniqid.h"

typedef struct _DB_CREATE_CONTEXT {
    IN ULONG Index;
    IN PM_SERVER Server;
    
    IN PM_CLASSDEF UserClass, VendorClass;
    IN PM_SUBNET Subnet;
    IN PM_RESERVATION Reservation;

} DB_CREATE_CONTEXT, *PDB_CREATE_CONTEXT;


//
// types of records
//

enum {
    DBCFG_CLASS,
    DBCFG_OPT,
    DBCFG_OPTDEF,
    DBCFG_SCOPE,
    DBCFG_MSCOPE,
    DBCFG_RANGE,
    DBCFG_EXCL,
    DBCFG_RESERVATION,
    DBCFG_END
};

//
// attributes/fields
//

enum {
    DBCFG_INDEX,
    DBCFG_TYPE,
    DBCFG_SUBTYPE,
    DBCFG_FLAGS,
    DBCFG_NAME,
    DBCFG_COMMENT,
    DBCFG_INFO,
    DBCFG_OPTION_ID,
    DBCFG_OPTION_USER,
    DBCFG_OPTION_VENDOR,
    DBCFG_IPADDRESS,
    DBCFG_MASK,
    DBCFG_SUPERSCOPE,
    DBCFG_MSCOPEID,
    DBCFG_MSCOPELANG,
    DBCFG_MSCOPETTL,
    DBCFG_MSCOPE_EXPIRY,
    DBCFG_RANGE_START,
    DBCFG_RANGE_END,
    DBCFG_RANGE_MASK,
    DBCFG_BOOTP_ALLOCATED,
    DBCFG_BOOTP_MAX,
    DBCFG_LAST_COLUMN
};

typedef struct _DBCFG_ENTRY {
    ULONG Bitmasks; // indicates which of the fields below is present
    ULONG Index;
    ULONG Type, SubType, Flags;
    LPWSTR Name, Comment;
    PUCHAR Info;
    ULONG OptionId;
    LPWSTR UserClass, VendorClass;
    ULONG IpAddress, Mask;
    LPWSTR SuperScope;
    ULONG MscopeId;
    LPWSTR MscopeLang;
    ULONG Ttl;
    FILETIME ExpiryTime;
    ULONG RangeStart, RangeEnd, RangeMask;
    ULONG BootpAllocated, BootpMax;

    ULONG InfoSize;
    PVOID Buf;
} DBCFG_ENTRY, *PDBCFG_ENTRY;

typedef struct _DBCFG_MAP {
    DWORD Offset, Size;
} DBCFG_MAP;

DBCFG_MAP EntryMap[] = {
    FIELD_OFFSET(DBCFG_ENTRY,Index), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Type), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,SubType), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Flags), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Name), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Comment), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Info), 0,
    FIELD_OFFSET(DBCFG_ENTRY,OptionId), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,UserClass), 0,
    FIELD_OFFSET(DBCFG_ENTRY,VendorClass), 0,
    FIELD_OFFSET(DBCFG_ENTRY,IpAddress), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Mask), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,SuperScope), 0,
    FIELD_OFFSET(DBCFG_ENTRY,MscopeId), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,MscopeLang), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Ttl), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,ExpiryTime), sizeof(FILETIME),
    FIELD_OFFSET(DBCFG_ENTRY,RangeStart), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,RangeEnd), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,RangeMask), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,BootpAllocated), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,BootpMax), sizeof(DWORD)
};

DWORD Bitmasks[] = {
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000,
    0x010000, 0x020000, 0x040000, 0x080000, 0x100000, 0x200000,
    0x400000, 0x80000,
};

DWORD
CreateDbEntry(
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD Error, Size, i, Offset;
    PVOID Data;
    WORD Buffer[4096];
    
    Offset = 0;
    
    for( i = 0; i < DBCFG_LAST_COLUMN; i ++ ) {
        if( (Entry->Bitmasks & Bitmasks[i]) == 0 ) {
            continue;
        }

        Size = EntryMap[i].Size;
        Data = EntryMap[i].Offset + (LPBYTE)Entry;

        if( i == DBCFG_INFO ) {
            //
            // Skip info -- it is added at end
            //
            continue;
        } else if( 0 == Size ) {
            //
            // Calculate the size of the string
            //
            Data = *(LPWSTR *)Data;

            if( NULL != Data ) Size = sizeof(WCHAR)*(
                1 + wcslen(Data));
        }

        if( 0 == Size ) continue;

        Buffer[Offset++] = (WORD)i;
        Buffer[Offset++] = (WORD)Size;
        memcpy(&Buffer[Offset], Data, Size);
        Offset += (Size + sizeof(WORD) - 1 )/sizeof(WORD);

    }

    //
    // add info at the end.
    //

    i = DBCFG_INFO;
    if( Entry->Bitmasks & Bitmasks[i]) {
        Size = EntryMap[i].Size;
        Data = EntryMap[i].Offset + (LPBYTE)Entry;
        Data = *(PUCHAR *)Data;
        
        if( NULL != Data ) Size = Entry->InfoSize;
        if( 0 != Size ) {

            Buffer[Offset++] = (WORD)i;
            Buffer[Offset++] = (WORD)Size;
            memcpy(&Buffer[Offset], Data, Size);
            Offset += (Size + sizeof(WORD) - 1 )/sizeof(WORD);
        }
    }

        
    Buffer[Offset++] = DBCFG_LAST_COLUMN+1;
    Buffer[Offset++] = 0;
    
    //
    // Write the record onto file
    //

    return AddRecordNoSize( (LPBYTE)Buffer, Offset*sizeof(WORD));
}

DWORD
CreateClassEntry(
    IN ULONG Index,
    IN PM_CLASSDEF Class
    )
{
    DBCFG_ENTRY Entry;

    //
    // IsVendor, Type, Name, Comment, nBytes, ActualBytes
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] |
        Bitmasks[DBCFG_FLAGS] | Bitmasks[DBCFG_SUBTYPE] |
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] |
        Bitmasks[DBCFG_INFO] ); 

    Entry.Index = Index;
    Entry.Type = DBCFG_CLASS;

    Entry.Flags = Class->IsVendor;
    Entry.SubType = Class->Type;
    Entry.Name = Class->Name;
    Entry.Comment = Class->Comment;
    Entry.Info = Class->ActualBytes;
    Entry.InfoSize = Class->nBytes;

    return CreateDbEntry( &Entry );
}

DWORD
CreateOptDefEntry(
    IN ULONG Index,
    IN PM_OPTDEF OptDef,
    IN PM_CLASSDEF UserClass,
    IN PM_CLASSDEF VendorClass
    )
{
    DBCFG_ENTRY Entry;

    //
    // OptId, Type, OptName, OptComment, OptVal, OptValLen,
    // User, Vendor
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] | Bitmasks[DBCFG_OPTION_ID] |
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] |
        Bitmasks[DBCFG_INFO] | Bitmasks[DBCFG_OPTION_USER] |
        Bitmasks[DBCFG_OPTION_VENDOR] );  

    Entry.Index = Index;
    Entry.Type = DBCFG_OPTDEF;

    Entry.OptionId = OptDef->OptId;
    Entry.SubType = OptDef->Type;
    Entry.Name = OptDef->OptName;
    Entry.Comment = OptDef->OptComment;
    Entry.Info = OptDef->OptVal;
    Entry.InfoSize = OptDef->OptValLen;
    if( UserClass) Entry.UserClass = UserClass->Name;
    if( VendorClass) Entry.VendorClass = VendorClass->Name;
    
    return CreateDbEntry( &Entry );
}

DWORD
CreateOptionEntry(
    IN ULONG Index,
    IN PM_OPTION Option,
    IN PM_CLASSDEF UserClass,
    IN PM_CLASSDEF VendorClass,
    IN PM_SUBNET Subnet,
    IN PM_RESERVATION Reservation
    )
{
    DBCFG_ENTRY Entry;
    
    //
    // OptId, Len, Val, User, Vendor
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_OPTION_ID] | Bitmasks[DBCFG_INFO] |
        Bitmasks[DBCFG_OPTION_USER] |
        Bitmasks[DBCFG_OPTION_VENDOR] ); 

    if( Reservation ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Reservation->Address;
    } else if( Subnet && Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else if( Subnet && !Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Index = Index;
    Entry.Type = DBCFG_OPT;

    Entry.OptionId = Option->OptId;
    Entry.Info = Option->Val;
    Entry.InfoSize = Option->Len;
    if( UserClass) Entry.UserClass = UserClass->Name;
    if( VendorClass) Entry.VendorClass = VendorClass->Name;

    return CreateDbEntry( &Entry );
}
    
DWORD
CreateScopeEntry(
    IN ULONG Index,
    IN PM_SUBNET Subnet,
    IN PM_SSCOPE SScope
    )
{
    DBCFG_ENTRY Entry;

    //
    // State, Policy, ExpiryTime, Name, Description
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] | Bitmasks[DBCFG_FLAGS] | 
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] );

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= (
            Bitmasks[DBCFG_IPADDRESS] | Bitmasks[DBCFG_MASK] |
            Bitmasks[DBCFG_SUPERSCOPE] );
        Entry.IpAddress = Subnet->Address;
        Entry.Mask = Subnet->Mask;
        if( SScope ) Entry.SuperScope = SScope->Name;
    } else {
        Entry.Bitmasks |= (
            Bitmasks[DBCFG_MSCOPEID] | Bitmasks[DBCFG_MSCOPETTL] |
            Bitmasks[DBCFG_MSCOPELANG] |
            Bitmasks[DBCFG_MSCOPE_EXPIRY] );

        Entry.MscopeId = Subnet->MScopeId;
        Entry.Ttl = Subnet->TTL;
        Entry.MscopeLang = Subnet->LangTag;
        Entry.ExpiryTime = *(FILETIME *)&Subnet->ExpiryTime;
    }
    
    Entry.Index = Index;
    Entry.Type = Subnet->fSubnet ? DBCFG_SCOPE : DBCFG_MSCOPE ;

    Entry.SubType = Subnet->State;
    Entry.Flags = Subnet->Policy;
    Entry.Name = Subnet->Name;
    Entry.Comment = Subnet->Description;
    
    return CreateDbEntry( &Entry );    
}
    
DWORD
CreateRangeEntry(
    IN ULONG Index,
    IN PM_RANGE Range,
    IN PM_SUBNET Subnet
    )
{
    DBCFG_ENTRY Entry;

    //
    // Start, End, Mask, State, BootpAllocated, MaxBootpAllowed
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_RANGE_START] | Bitmasks[DBCFG_RANGE_END] |
        Bitmasks[DBCFG_RANGE_MASK] | Bitmasks[DBCFG_FLAGS] |
        Bitmasks[DBCFG_BOOTP_ALLOCATED] | Bitmasks[DBCFG_BOOTP_MAX] ); 

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Index = Index;
    Entry.Type = DBCFG_RANGE;

    Entry.RangeStart = Range->Start;
    Entry.RangeEnd = Range->End;
    Entry.RangeMask = Range->Mask;
    Entry.Flags = Range->State;
    Entry.BootpAllocated = Range->BootpAllocated;
    Entry.BootpMax = Range->MaxBootpAllowed;
    
    return CreateDbEntry( &Entry );
}

DWORD
CreateExclEntry(
    IN ULONG Index,
    IN PM_EXCL Excl,
    IN PM_SUBNET Subnet
    )
{
    DBCFG_ENTRY Entry;

    //
    // Start, End
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_RANGE_START] | Bitmasks[DBCFG_RANGE_END] );

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Index = Index;
    Entry.Type = DBCFG_EXCL;

    Entry.RangeStart = Excl->Start;
    Entry.RangeEnd = Excl->End;
    
    return CreateDbEntry(  &Entry );
}

DWORD
CreateReservationEntry(
    IN ULONG Index,
    IN PM_RESERVATION Reservation
    )
{
    DBCFG_ENTRY Entry;

    //
    // Address, Flags, nBytes, ClientUID
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_IPADDRESS] | Bitmasks[DBCFG_INFO] |
        Bitmasks[DBCFG_FLAGS] );

    Entry.Index = Index;
    Entry.Type = DBCFG_RESERVATION;

    Entry.IpAddress = Reservation->Address;
    Entry.Flags = Reservation->Flags;
    Entry.Info = Reservation->ClientUID;
    Entry.InfoSize = Reservation->nBytes;
    
    return CreateDbEntry( &Entry );
}

DWORD
IterateArrayWithDbCreateRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PARRAY Array,
    IN DWORD (*Routine)(
        IN PDB_CREATE_CONTEXT Ctxt,
        IN PVOID ArrayElement
        )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    PVOID Element;
    
    Error = MemArrayInitLoc( Array, &Loc );
    while( NO_ERROR == Error ) {

        Error = MemArrayGetElement(
            Array, &Loc, &Element );
        ASSERT( NO_ERROR == Error && NULL != Element );

        Ctxt->Index ++;

        Error = Routine( Ctxt, Element );
        if( NO_ERROR != Error ) return Error;

        Error = MemArrayNextLoc( Array, &Loc );
    }

    if( ERROR_FILE_NOT_FOUND == Error ) return NO_ERROR;
    return Error;
}
    
DWORD
DbCreateClassRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_CLASSDEF Class
    )
{
    return CreateClassEntry( Ctxt->Index, Class );
}

DWORD
DbCreateOptDefRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTDEF OptDef
    )
{
    return CreateOptDefEntry(
        Ctxt->Index, OptDef, Ctxt->UserClass,
        Ctxt->VendorClass );
}

DWORD
DbCreateOptClassDefRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTCLASSDEFL_ONE OptClassDef
    )
{
    DWORD Error;

    if( 0 == MemArraySize(&OptClassDef->OptDefList.OptDefArray) ) {
        return NO_ERROR;
    }
    
    if( 0 == OptClassDef->ClassId ) {
        Ctxt->UserClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptClassDef->ClassId, NULL, 0, NULL,
            &Ctxt->UserClass );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;
    }

    if( 0 == OptClassDef->VendorId ) {
        Ctxt->VendorClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptClassDef->VendorId, NULL, 0, NULL,
            &Ctxt->VendorClass );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;
    }

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &OptClassDef->OptDefList.OptDefArray,
        DbCreateOptDefRoutine );

    return Error;
}

DWORD
DbCreateOptionRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTION Option
    )
{
    return CreateOptionEntry(
        Ctxt->Index, Option, Ctxt->UserClass,
        Ctxt->VendorClass, Ctxt->Subnet, Ctxt->Reservation );
}

DWORD
DbCreateOptListRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_ONECLASS_OPTLIST OptList
    )
{
    DWORD Error;

    if( 0 == MemArraySize(&OptList->OptList) ) {
        return NO_ERROR;
    }
    
    if( 0 == OptList->ClassId ) {
        Ctxt->UserClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptList->ClassId, NULL, 0, NULL,
            &Ctxt->UserClass );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;
    }

    if( 0 == OptList->VendorId ) {
        Ctxt->VendorClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptList->VendorId, NULL, 0, NULL,
            &Ctxt->VendorClass );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;
    }

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &OptList->OptList, DbCreateOptionRoutine );

    return Error;
}

DWORD
DbCreateRangeRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_RANGE Range
    )
{
    return CreateRangeEntry(
        Ctxt->Index, Range, Ctxt->Subnet );
}

DWORD
DbCreateExclRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_EXCL Excl
    )
{
    return CreateExclEntry(
        Ctxt->Index, Excl, Ctxt->Subnet );
}

DWORD
DbCreateReservationRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_RESERVATION Reservation
    )
{
    DWORD Error;
    
    Error = CreateReservationEntry(
        Ctxt->Index, Reservation );
    if( NO_ERROR != Error ) return Error;

    Ctxt->Reservation = Reservation;
    
    //
    // Now add the options for this reservation
    //
    
    return IterateArrayWithDbCreateRoutine(
        Ctxt, &Reservation->Options.Array,
        DbCreateOptListRoutine );
}

DWORD
DbCreateScopeRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_SUBNET Subnet
    )
{
    PM_SSCOPE SScope = NULL;
    DWORD Error;
    
    if( Subnet->fSubnet && Subnet->SuperScopeId ) {
        Error = MemServerFindSScope(
            Ctxt->Server, Subnet->SuperScopeId, NULL, &SScope );
        if( NO_ERROR != Error ) {
            SScope = NULL;
        }
    }

    Error = CreateScopeEntry(
        Ctxt->Index, Subnet, SScope );
    if( NO_ERROR != Error ) return Error;

    //
    // Initialize the two fields that will get used later 
    //
    
    Ctxt->Subnet = Subnet;
    Ctxt->Reservation = NULL;

    //
    // Now add the options for this scope
    //

    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Options.Array,
        DbCreateOptListRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Now add the ranges and exclusions
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Ranges, DbCreateRangeRoutine );
    if( NO_ERROR != Error ) return Error;

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Exclusions, DbCreateExclRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Finally, add the reservations
    //

    return IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Reservations,
        DbCreateReservationRoutine );
}


DWORD
DbCreateServerRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_SERVER Server
    )
{
    DWORD Error;
    
    Ctxt->Server = Server;

    //
    // First look through the classes
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->ClassDefs.ClassDefArray,
        DbCreateClassRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Next save the option defs
    //
    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->OptDefs.Array,
        DbCreateOptClassDefRoutine );
    if( NO_ERROR != Error ) return Error;

    // 
    // Next save the options
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->Options.Array,
        DbCreateOptListRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Next save the scopes and mcast scopes
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->Subnets, DbCreateScopeRoutine );
    if( NO_ERROR != Error ) return Error;

    return NO_ERROR;
}

DWORD
SaveConfigurationToFile(
    IN PM_SERVER Server
    )
{
    DB_CREATE_CONTEXT Ctxt;
    DWORD Error;
    
    ZeroMemory( &Ctxt, sizeof(Ctxt) );
    
    Error = DbCreateServerRoutine(
        &Ctxt, Server );
    
    if( NO_ERROR != Error ) {
        Tr("DbCreateServerRoutine: %ld\n", Error);
    } else {
        //
        // Sentinel
        //
        DBCFG_ENTRY Entry;
        ZeroMemory( &Entry, sizeof(Entry) );
        Entry.Bitmasks = (
            Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] );            
        Entry.Type = DBCFG_END;

        Error = CreateDbEntry( &Entry );
        if( NO_ERROR != Error ) {
            Tr("Create last entry: %ld\n", Error );
        }
    }

    Tr("SaveConfigurationToFile: %ld\n", Error);
    return Error;
}
    
DWORD
GetColumnFromMemory(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN ULONG Col,
    IN OUT PVOID Buffer,
    IN ULONG BufSize,
    IN OUT ULONG *CopiedSize
    )
{
    WORD *WordMem = (WORD *)*Mem;
    DWORD Size;
    
    if( *MemSize < sizeof(WORD)*2 ) return ERROR_INVALID_DATA;
    if( Col != WordMem[0] ) return JET_wrnColumnNull;

    Size = sizeof(WORD)*(
        2 + (WordMem[1]+sizeof(WORD)-1)/sizeof(WORD)  );
    if( Size > *MemSize ) return ERROR_INVALID_DATA;

    if( WordMem[1] >= BufSize ) *CopiedSize = BufSize;
    else *CopiedSize = WordMem[1];

    memcpy(Buffer, &WordMem[2], *CopiedSize );
    
    (*Mem) += Size;
    (*MemSize) -= Size;

    if( WordMem[1] > BufSize ) return JET_wrnBufferTruncated;
    return NO_ERROR;
}
    
DWORD
ReadDbEntry(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN PDBCFG_ENTRY Entry,
    IN PVOID Buffer,
    IN ULONG BufSize
    )
{
    DWORD Size, CopiedSize, i, OldMemSize, DummySize;
    JET_ERR JetError;
    LPVOID Data, Ptr;
    LPBYTE OldMem;

    OldMemSize = *MemSize;
    OldMem = *Mem;
    
    ZeroMemory( Entry, sizeof(*Entry) );
    ZeroMemory( Buffer, BufSize );
    
    for( i = 0; i < DBCFG_LAST_COLUMN; i ++ ) {

        //
        // Info should be read at the very end to avoid screwing
        // up alignment as info is binary while the rest of the
        // variable size columns are all WCHAR strings
        //
        
        if( i == DBCFG_INFO ) continue;
        
        Size = EntryMap[i].Size;
        Data = EntryMap[i].Offset + (LPBYTE)Entry;
        Ptr = Data;
        
        if( 0 == Size ) {
            //
            // Calculate the size of the string
            //
            Data = Buffer;
            Size = BufSize;
        }

        JetError = GetColumnFromMemory(
            Mem, MemSize, i, Data, Size, &CopiedSize );

        //
        // If the column doesn't exist, continue
        //
       
        if( JET_wrnColumnNull == JetError ) continue;
            
        if( JET_wrnBufferTruncated == JetError &&
            Data == Buffer ) {

            (*Mem) = OldMem;
            (*MemSize) = OldMemSize;
            
            return ERROR_INSUFFICIENT_BUFFER;
        }

        if( NO_ERROR != JetError ) {
            Tr( "GetColumnFromMemory: %ld\n", JetError );
            return JetError;
        }
        
        //
        // If it is any of the variable sized params, then
        // set the ptr to point to the buffer where the data is
        // copied, and also update the buffer.
        //
        
        if( Data == Buffer ) {
            (*(LPVOID *)Ptr) = Buffer;
            BufSize -= CopiedSize;
            Buffer = (PVOID)(((PUCHAR)Buffer) + CopiedSize);
        } else {
            ASSERT( CopiedSize == Size );
        }

        //
        // Indicate that the column was retrieved successfully
        //

        Entry->Bitmasks |= Bitmasks[i];
    }

    //
    // Read the info field
    //

    Size = BufSize;
    JetError = GetColumnFromMemory(
        Mem, MemSize, DBCFG_INFO, Buffer, Size, &CopiedSize );

    GetColumnFromMemory(
        Mem, MemSize, DBCFG_LAST_COLUMN+1,NULL, 0, &DummySize);
    
    if( JET_wrnColumnNull == JetError ) return NO_ERROR;
        
    if( JET_wrnBufferTruncated == JetError ) {
        (*Mem) = OldMem;
        (*MemSize) = OldMemSize;
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if( NO_ERROR != JetError ) {
        Tr("GetColumnFromMemory: %ld\n", JetError );
        return JetError;
    }
    
    Entry->Info = Buffer;
    Entry->InfoSize = CopiedSize;
    Entry->Bitmasks  |= Bitmasks[DBCFG_INFO];

    return NO_ERROR;
}

DWORD
ReadDbEntryEx(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN PDBCFG_ENTRY Entry
    )
{
    PVOID Buffer;
    ULONG BufSize;
    DWORD Error;

    Buffer = NULL;
    BufSize = 512;
    
    do {
        if( NULL != Buffer ) LocalFree(Buffer);

        BufSize *= 2;
        Buffer = LocalAlloc( LPTR, BufSize );
        if( NULL == Buffer ) return ERROR_NOT_ENOUGH_MEMORY;
        
        Error = ReadDbEntry(Mem, MemSize, Entry, Buffer, BufSize);

    } while( ERROR_INSUFFICIENT_BUFFER == Error );

    if( !(Entry->Bitmasks & Bitmasks[DBCFG_INDEX]) ||
        !(Entry->Bitmasks & Bitmasks[DBCFG_TYPE]) ) {
        if( NO_ERROR == Error ) {
            ASSERT( FALSE );
            Error = ERROR_INTERNAL_ERROR;
        }
    }
    
    if( NO_ERROR != Error ) {
        LocalFree( Buffer );
        return Error;
    }

    Entry->Buf = Buffer;
    return NO_ERROR;
}

DWORD
AddDbEntry(
    IN PM_SERVER Server,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD UserId, VendorId, SScopeId, Error;
    PM_SUBNET Subnet;
    PM_OPTCLASS OptClass;
    PM_OPTION Option, DelOpt;
    PM_RANGE DelRange;
    PM_EXCL DelExcl;
    PM_RESERVATION Reservation;
    PM_CLASSDEF ClassDef;
    PM_SSCOPE SScope;
    
    Subnet = NULL;
    OptClass = NULL;
    Option = DelOpt = NULL;
    Reservation = NULL;
    DelRange = NULL;
    DelExcl = NULL;
    UserId = 0;
    VendorId = 0;
    SScopeId = 0;
    
    if( Entry->UserClass ) {
        Error = MemServerGetClassDef(
            Server, 0, Entry->UserClass, 0, NULL, &ClassDef );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;

        ASSERT( ClassDef->IsVendor == FALSE );
        UserId = ClassDef->ClassId;
    }

    if( Entry->VendorClass ) {
        Error = MemServerGetClassDef(
            Server, 0, Entry->VendorClass, 0, NULL, &ClassDef );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;

        ASSERT( ClassDef->IsVendor == TRUE);
        VendorId = ClassDef->ClassId;
    }

    if( Entry->SuperScope ) {
        Error = MemServerFindSScope(
            Server, INVALID_SSCOPE_ID, Entry->SuperScope, &SScope );
        if( NO_ERROR == Error ) {
            SScopeId = SScope->SScopeId;
        } else if( ERROR_FILE_NOT_FOUND != Error ) {
            return Error;
        } else {
            Error = MemSScopeInit( &SScope, 0, Entry->SuperScope );
            if( NO_ERROR != Error ) return Error;

            Error = MemServerAddSScope( Server, SScope );
            if( NO_ERROR != Error ) {
                MemSScopeCleanup( SScope );
                return Error;
            }
            SScopeId = SScope->SScopeId;
        }
    }
    
    switch( Entry->Type ) {
    case DBCFG_CLASS :
        //
        // Flags = IsVendor, SubType =Type, Info = ActualBytes
        //
        
        return MemServerAddClassDef(
            Server, MemNewClassId(), Entry->Flags, Entry->Name,
            Entry->Comment, Entry->InfoSize, Entry->Info, INVALID_UNIQ_ID );

    case DBCFG_OPTDEF :
        //
        // OptionId = OptId, SubType = Type, Info = OptVal
        //
        
        return MemServerAddOptDef(
            Server, UserId, VendorId, Entry->OptionId,
            Entry->Name, Entry->Comment, Entry->SubType,
            Entry->Info, Entry->InfoSize, INVALID_UNIQ_ID );

    case DBCFG_OPT:
        //
        // OptionId = OptId, Info = Val
        // If this is a reservation option, address is set to
        // reserved client address. If this is a subnet option,
        // address is set to subnet address. If this is a mscope
        // option, scopeid is set to mscope scopeid.  If it is a
        // global option, neither address not scopeid is set.
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_MSCOPEID] ) {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
            if( NO_ERROR != Error ) return Error;

            OptClass = &Subnet->Options;
        } else if( 0 == (Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] )) {
            OptClass = &Server->Options;
        } else {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                &Reservation );
            ASSERT( NO_ERROR == Error );
            if( NO_ERROR != Error ) return Error;

            if( NULL != Reservation ) {
                OptClass = &Reservation->Options;
            } else OptClass = &Subnet->Options;
        }
        
        Error = MemOptInit(
            &Option, Entry->OptionId, Entry->InfoSize,
            Entry->Info );
        if( NO_ERROR != Error ) return Error;
            
        Error = MemOptClassAddOption(
            OptClass,  Option, UserId, VendorId, &DelOpt, INVALID_UNIQ_ID );

        ASSERT( NULL == DelOpt );
        if( NO_ERROR != Error ) MemFree( Option );

        return Error;

    case DBCFG_SCOPE:
        //
        // IpAddress = Address, Mask = Mask, SubType = State,
        // Flags = Policy
        //

        Error = MemSubnetInit(
            &Subnet, Entry->IpAddress, Entry->Mask,
            Entry->SubType, SScopeId, Entry->Name, Entry->Comment );
        if( NO_ERROR != Error ) return Error;

        Error = MemServerAddSubnet( Server, Subnet, INVALID_UNIQ_ID );
        if( NO_ERROR != Error ) MemSubnetCleanup( Subnet );

        return Error;
            
    case DBCFG_MSCOPE :
        //
        // MscopeId = MScopeId, Ttl = TTL, MscopeLang = LangTag,
        // ExpiryTime = ExpiryTime, SubType = State, Flags =
        // Policy..
        //

        Error = MemMScopeInit(
            &Subnet, Entry->MscopeId, Entry->SubType,
            Entry->Flags, (BYTE)Entry->Ttl, Entry->Name,
            Entry->Comment, Entry->MscopeLang,
            *(DATE_TIME *)&Entry->ExpiryTime );
        if( NO_ERROR != Error ) return Error;

        Error = MemServerAddMScope( Server, Subnet, INVALID_UNIQ_ID );
        if( NO_ERROR != Error ) MemSubnetCleanup( Subnet );

        Subnet->ServerPtr = Server;
        return Error;

    case DBCFG_RANGE :

        //
        // RangeStart = Start, RangeEnd = End, RangeMask = Mask,
        // Flags = State, BootpAllocated, BootpMax =
        // MaxBootpAllowed... Also, IpAddress or MscopeId
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] ) {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                NULL );
        } else {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
        }
        if( NO_ERROR != Error ) return Error;

        return MemSubnetAddRange(
            Subnet, Entry->RangeStart, Entry->RangeEnd,
            Entry->Flags, Entry->BootpAllocated, Entry->BootpMax,
            &DelRange, INVALID_UNIQ_ID );
        
    case DBCFG_EXCL:
        //
        // RangeStart = Start, RangeEnd = End
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] ) {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                NULL );
        } else {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
        }
        if( NO_ERROR != Error ) return Error;

        return MemSubnetAddExcl(
	    Subnet, Entry->RangeStart, Entry->RangeEnd, &DelExcl,
	    INVALID_UNIQ_ID
            );

    case DBCFG_RESERVATION :
        //
        // IpAddress = Address, Flags = Flags, Info = ClientUID
        //

        Error = MemServerGetAddressInfo(
            Server, Entry->IpAddress, &Subnet, NULL, NULL, NULL );
        if( NO_ERROR != Error ) return Error;

        return MemReserveAdd(
            &Subnet->Reservations, Entry->IpAddress,
            Entry->Flags, Entry->Info, Entry->InfoSize,
	    INVALID_UNIQ_ID );
    default:

        return ERROR_INTERNAL_ERROR;
    }        
}

DWORD
AddDbEntryEx(
    IN PM_SERVER Server,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD Error;
    LPSTR EntryTypes[] = {
        "Class", "Opt", "OptDef", "Scope", "Mscope", "Range",
        "Excl", "Reservation", "Unknown1", "Unknown2", "Unknown3"
    };
    
    Error = AddDbEntry( Server, Entry );
    if( NO_ERROR != Error ) {
        Tr("Error adding entry[%ld] %s: 0x%lx\n",
                   Entry->Index, EntryTypes[Entry->Type], Error );
    }

    return Error;
}

DWORD
ReadDbEntries(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN OUT PM_SERVER *Server
    )
{
    DBCFG_ENTRY Entry;
    DWORD Error = NO_ERROR;

    Error = MemServerInit(
        Server, -1, 0, 0, NULL, NULL );
    if( NO_ERROR != Error ) return Error;
    
    while( Error == NO_ERROR ) {

        Error = ReadDbEntryEx( Mem, MemSize, &Entry );
        if( NO_ERROR != Error ) {
            Tr( "ReadDbEntryEx: %ld\n", Error );
            break;
        }

        if( Entry.Type == DBCFG_END ) {
            Error = NO_ERROR;
            break;
        }

        Error = AddDbEntryEx( *Server, &Entry );
        if( NULL != Entry.Buf ) LocalFree( Entry.Buf );
        if( NO_ERROR != Error ) {
            Tr( "AddDbEntryEx: %ld\n", Error );
            return Error;
        }
    }

    Tr("ReadDbEntries: %ld\n", Error);

    if( NO_ERROR != Error ) {
        MemServerFree( *Server );
        (*Server) = NULL;
    }
    
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\readdb.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   readdb.c

Abstract:

   This module reads the configuration from the db into MM data
   structures for whistler+

--*/

#include <precomp.h>

DWORD
DhcpeximReadDatabaseConfiguration(
    IN OUT PM_SERVER *Server
    )
{
    DWORD Error;
    HMODULE hDll;
    FARPROC pDhcpOpenAndReadDatabaseConfig;
    
    hDll = LoadLibrary(TEXT("DHCPSSVC.DLL"));
    if( NULL == hDll ) return GetLastError();


    pDhcpOpenAndReadDatabaseConfig = GetProcAddress(
        hDll, "DhcpOpenAndReadDatabaseConfig" );

    if( NULL == pDhcpOpenAndReadDatabaseConfig ) {
        Error = GetLastError();
    } else {
        Error = (DWORD)pDhcpOpenAndReadDatabaseConfig(
            DhcpEximOemDatabaseName, DhcpEximOemDatabasePath,
            Server );
    }

    FreeLibrary(hDll);

    return Error;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\dbfile.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   db2file.c

Abstract:

   This module reads the database records and writes them into a
   file format.

--*/

#include <precomp.h>

enum {
    RecordTypeDbEntry,
    RecordTypeMcastDbEntry,
};

//
// database table and field names.
//

#define IPADDRESS_INDEX                                0
#define HARDWARE_ADDRESS_INDEX                         1
#define STATE_INDEX                                    2
#define MACHINE_INFO_INDEX                             3
#define MACHINE_NAME_INDEX                             4
#define LEASE_TERMINATE_INDEX                          5
#define SUBNET_MASK_INDEX                              6
#define SERVER_IP_ADDRESS_INDEX                        7
#define SERVER_NAME_INDEX                              8
#define CLIENT_TYPE_INDEX                              9
#define MAX_INDEX                                      10


#define SAVE_THRESHOLD (1000000L)

//
// Globals
//

DWORD JetVersion;
CHAR DatabaseName[1024], DatabasePath[1024];
HMODULE hJet;
JET_INSTANCE JetInstance;
JET_SESID JetSession;
JET_DBID JetDb;
JET_TABLEID JetTbl;
PUCHAR SaveBuf;
ULONG SaveBufSize;
HANDLE hTextFile, hMapping;
PVOID FileView;
WCHAR Winnt32Path[MAX_PATH*2];
CHAR System32Path[MAX_PATH*2];

JET_ERR (JET_API *pJetSetCurrentIndex)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName
    );
JET_ERR (JET_API *pJetRetrieveColumn)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pvData,
	unsigned long	cbData,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo );

JET_ERR (JET_API *pJetSetColumn)(
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    JET_COLUMNID    columnid,
    const void      *pvData,
    unsigned long   cbData,
    JET_GRBIT       grbit,
    JET_SETINFO     *psetinfo );

JET_ERR (JET_API *pJetMove)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	long			cRow,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetSetSystemParameter)(
	JET_INSTANCE	*pinstance,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		lParam,
	const char		*sz );

JET_ERR (JET_API *pJetBeginTransaction)(
    JET_SESID sesid
    );
JET_ERR (JET_API *pJetPrepareUpdate)(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        unsigned long   prep );

JET_ERR (JET_API *pJetUpdate)(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        void                    *pvBookmark,
        unsigned long   cbBookmark,
        unsigned long   *pcbActual);

JET_ERR (JET_API *pJetCommitTransaction)( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR (JET_API *pJetRollback)( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR (JET_API *pJetTerm)( JET_INSTANCE instance );

JET_ERR (JET_API *pJetTerm2)( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR (JET_API *pJetEndSession)( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR (JET_API *pJetBeginSession)(
	JET_INSTANCE	instance,
	JET_SESID		*psesid,
	const char		*szUserName,
	const char		*szPassword );

JET_ERR (JET_API *pJetInit)( JET_INSTANCE *pinstance);

JET_ERR (JET_API *pJetDetachDatabase)(
	JET_SESID		sesid,
	const char		*szFilename );

JET_ERR (JET_API *pJetAttachDatabase)(
	JET_SESID		sesid,
	const char		*szFilename,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetOpenDatabase)(
	JET_SESID		sesid,
	const char		*szFilename,
	const char		*szConnect,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetCloseDatabase)(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetOpenTable)(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const void		*pvParameters,
	unsigned long	cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid );

JET_ERR (JET_API *pJetCloseTable)( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR (JET_API *pJetGetTableColumnInfo)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR (JET_API *pJetGetIndexInfo)(
        JET_SESID               sesid,
        JET_DBID                dbid,
        const char              *szTableName,
        const char              *szIndexName,
        void                    *pvResult,
        unsigned long   cbResult,
        unsigned long   InfoLevel );

#define DB_FUNC(F,I,S) \
{#F, TEXT(#F), #F "@" #S, I, (FARPROC *)& p ## F }

typedef struct _DB_FUNC_ENTRY {
    LPSTR FuncName;
    LPWSTR FuncNameW;
    LPSTR AltName;
    DWORD Index;
    FARPROC *FuncPtr;
} DB_FUNC_ENTRY;

DB_FUNC_ENTRY FuncTable[] = {
    DB_FUNC(JetSetCurrentIndex, 164, 12),
    DB_FUNC(JetRetrieveColumn, 157, 32),
    DB_FUNC(JetSetColumn, 162, 28),
    DB_FUNC(JetMove, 147, 16),
    DB_FUNC(JetSetSystemParameter, 165, 20),
    DB_FUNC(JetTerm, 167, 4),
    DB_FUNC(JetTerm2, 0, 8),
    DB_FUNC(JetEndSession, 124, 8),
    DB_FUNC(JetBeginSession, 104, 16),
    DB_FUNC(JetInit, 145, 4),
    DB_FUNC(JetDetachDatabase, 121, 8),
    DB_FUNC(JetAttachDatabase, 102, 12),
    DB_FUNC(JetOpenDatabase, 148, 20),
    DB_FUNC(JetOpenTable, 149, 28),
    DB_FUNC(JetGetTableColumnInfo, 137, 24),
    DB_FUNC(JetCloseTable,108, 8),
    DB_FUNC(JetCloseDatabase, 107, 12),
    DB_FUNC(JetGetIndexInfo, 131, 28),
    DB_FUNC(JetBeginTransaction, 105, 4),
    DB_FUNC(JetPrepareUpdate, 151, 12),
    DB_FUNC(JetUpdate, 168, 20),
    DB_FUNC(JetCommitTransaction, 109, 8),
    DB_FUNC(JetRollback, 160, 8),
};

#define JetSetCurrentIndex pJetSetCurrentIndex
#define JetRetrieveColumn pJetRetrieveColumn
#define JetSetColumn pJetSetColumn
#define JetMove pJetMove
#define JetSetSystemParameter pJetSetSystemParameter
#define JetTerm pJetTerm
#define JetTerm2 pJetTerm2
#define JetEndSession pJetEndSession
#define JetBeginSession pJetBeginSession
#define JetInit pJetInit
#define JetDetachDatabase pJetDetachDatabase
#define JetAttachDatabase pJetAttachDatabase
#define JetOpenDatabase pJetOpenDatabase
#define JetOpenTable pJetOpenTable
#define JetGetTableColumnInfo pJetGetTableColumnInfo
#define JetCloseTable pJetCloseTable
#define JetCloseDatabase pJetCloseDatabase
#define JetGetIndexInfo pJetGetIndexInfo
#define JetBeginTransaction pJetBeginTransaction
#define JetPrepareUpdate pJetPrepareUpdate
#define JetUpdate pJetUpdate
#define JetCommitTransaction pJetCommitTransaction
#define JetRollback pJetRollback

typedef struct _TABLE_INFO {
    CHAR *ColName;
    JET_COLUMNID ColHandle;
    BOOL fPresent;
    JET_COLTYP ColType;
} TABLE_INFO, *LPTABLE_INFO;

#define IPADDRESS_STRING        "IpAddress"
#define HARDWARE_ADDRESS_STRING "HardwareAddress"
#define STATE_STRING            "State"
#define MACHINE_INFO_STRING     "MachineInformation"
#define MACHINE_NAME_STRING     "MachineName"
#define LEASE_TERMINATE_STRING  "LeaseTerminates"
#define SUBNET_MASK_STRING      "SubnetMask"
#define SERVER_IP_ADDRESS_STRING "ServerIpAddress"
#define SERVER_NAME_STRING      "ServerName"
#define CLIENT_TYPE             "ClientType"

static TABLE_INFO ClientTable[] = {
    { IPADDRESS_STRING        , 0, 1, JET_coltypLong },
    { HARDWARE_ADDRESS_STRING , 0, 1, JET_coltypBinary },
    { STATE_STRING            , 0, 1, JET_coltypUnsignedByte },
    { MACHINE_INFO_STRING     , 0, 1, JET_coltypBinary }, // must modify MACHINE_INFO_SIZE if this changes
    { MACHINE_NAME_STRING     , 0, 1, JET_coltypLongBinary },
    { LEASE_TERMINATE_STRING  , 0, 1, JET_coltypCurrency },
    { SUBNET_MASK_STRING      , 0, 1, JET_coltypLong },
    { SERVER_IP_ADDRESS_STRING, 0, 1, JET_coltypLong },
    { SERVER_NAME_STRING      , 0, 1, JET_coltypLongBinary },
    { CLIENT_TYPE             , 0, 1, JET_coltypUnsignedByte }
};

#define MAGIC_COOKIE_NT4 'NT4 '
#define MAGIC_COOKIE_NT5 'W2K '
#define MAGIC_COOKIE_NT5_PLUS 'W2K1'

DWORD
GetCurrentMagicCookie(
    VOID
    )
{
    OSVERSIONINFO Ver;

    Ver.dwOSVersionInfoSize = sizeof(Ver);
    if( FALSE == GetVersionEx(&Ver) ) return MAGIC_COOKIE_NT5_PLUS;
    if( Ver.dwMajorVersion == 4 ) return MAGIC_COOKIE_NT4;
    else if( Ver.dwMajorVersion == 5 ) {
        if( Ver.dwBuildNumber >= 2200 ) return MAGIC_COOKIE_NT5_PLUS;
        else return MAGIC_COOKIE_NT5;
    }
    return MAGIC_COOKIE_NT4;
}

DWORD
OpenTextFile(
    IN LPWSTR FileName,
    IN BOOL fRead,
    OUT HANDLE *hFile,
    OUT LPBYTE *Mem,
    OUT ULONG *MemSize
    )
{
    DWORD Error, Flags, LoSize, HiSize;

    Flags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;

    hTextFile = CreateFileW(
        FileName, GENERIC_READ | GENERIC_WRITE | DELETE,
        FILE_SHARE_READ, NULL,
        fRead ? OPEN_EXISTING : CREATE_ALWAYS,
        Flags, NULL );

    if( hTextFile == INVALID_HANDLE_VALUE ) {
        hTextFile = NULL;
        Error = GetLastError();
        if( !fRead || ERROR_FILE_NOT_FOUND != Error ) {
            Tr("CreateFile<%ws>: %ld\n", FileName, Error );
        }
        return Error;
    }

    (*hFile) = hTextFile;
    if( !fRead ) {
        //
        // Write the magic cookie
        //
        Flags = GetCurrentMagicCookie();
        if( FALSE == WriteFile(
            hTextFile, (LPBYTE)&Flags, sizeof(Flags), &LoSize,
            NULL ) ) {
            Error = GetLastError();
            CloseHandle(hTextFile);
            return Error;
        }
            
        return NO_ERROR;
    }

    LoSize = GetFileSize( hTextFile, &HiSize );
    if( -1 == LoSize && NO_ERROR != GetLastError() ) {
        return GetLastError();
    }

    if( LoSize <= sizeof(DWORD) ) {
        CloseHandle(hTextFile);
        return ERROR_INVALID_DATA;
    }
       
    (*MemSize) = LoSize;
    (*Mem) = NULL;
    
    hMapping = CreateFileMapping(
        hTextFile, NULL, PAGE_READONLY | SEC_COMMIT, HiSize, LoSize,
        NULL );
    if( NULL == hMapping ) {
        Error = GetLastError();
        Tr("Can't map file: %ld\n", Error );
        return Error;
    }

    FileView = MapViewOfFile(
        hMapping, FILE_MAP_READ, 0, 0, 0 );

    if( NULL == FileView ) {
        Error = GetLastError();
        Tr("Can't create view: %ld\n", Error );
        CloseHandle( hMapping );
        CloseHandle( hTextFile );
        hTextFile = NULL;
        hMapping = NULL;
        return Error;
    }

    (*Mem) = FileView;

    //
    // Before okaying, check if the version of the file is
    // greater than current version
    //

    Error = NO_ERROR;
    CopyMemory(&Flags, *Mem, sizeof(Flags));
    switch(GetCurrentMagicCookie()) {
    case MAGIC_COOKIE_NT5_PLUS :
        if( Flags != MAGIC_COOKIE_NT5 &&
            Flags != MAGIC_COOKIE_NT5_PLUS &&
            Flags != MAGIC_COOKIE_NT4 ) {
            Error = ERROR_NOT_SUPPORTED;
        }
        break;
    case MAGIC_COOKIE_NT5 :
        if( Flags != MAGIC_COOKIE_NT5 &&
            Flags != MAGIC_COOKIE_NT4 ) {
            Error = ERROR_NOT_SUPPORTED;
        }
        break;
    case MAGIC_COOKIE_NT4 :
        if( Flags != MAGIC_COOKIE_NT4 ) {
            Error = ERROR_NOT_SUPPORTED;
        }
        break;
    }

    if( NO_ERROR != Error ) {
        UnmapViewOfFile(FileView);
        CloseHandle( hMapping );
        CloseHandle( hTextFile );
        hTextFile = NULL;
        hMapping = NULL;
        FileView = NULL;
        return Error;
    }
    
    *MemSize -= sizeof(DWORD);
    (*Mem) += sizeof(DWORD);
    return NO_ERROR;
}

VOID
CloseTextFile(
    IN OUT HANDLE hFile,
    IN OUT LPBYTE Mem
    )
{
    ASSERT( hFile == hTextFile );
    
    if( NULL != FileView ) UnmapViewOfFile( FileView );
    FileView = NULL;

    if( NULL != hMapping ) CloseHandle( hMapping );
    hMapping = NULL;

    if( NULL != hTextFile ) CloseHandle( hTextFile );
    hTextFile = NULL;
}

ULONG
ByteSwap(
    IN ULONG Source
    )
{
    ULONG swapped;

    swapped = ((Source)              << (8 * 3)) |
              ((Source & 0x0000FF00) << (8 * 1)) |
              ((Source & 0x00FF0000) >> (8 * 1)) |
              ((Source)              >> (8 * 3));

    return swapped;
}

LPSTR
IpAddressToString(
    IN ULONG Address
    )
{
    static CHAR Buffer[30];
    PUCHAR pAddress;

    pAddress = (PUCHAR)&Address;
    sprintf(Buffer, "%d.%d.%d.%d", pAddress[0], pAddress[1],
            pAddress[2], pAddress[3] );
    return Buffer;
}


VOID static
CleanupDatabase(
    VOID
    )
{
    if( JetTbl != 0 ) {
        JetCloseTable( JetSession, JetTbl );
        JetTbl = 0;
    }

    if( JetSession != 0 ) {
        JetEndSession( JetSession, 0 );
        JetSession = 0;
    }

    if( NULL != hJet ) {
        if( NULL != JetTerm2 ) {
            JetTerm2( JetInstance, JET_bitTermComplete );
        } else {
            JetTerm( JetInstance );
        }
    
        FreeLibrary( hJet ); hJet = NULL;
    }

    JetInstance = 0;
}

DWORD
LoadAndLinkRoutines(
    IN DWORD JetVersion
    )
{
    DWORD Error, i;
    LPTSTR Module;
    LPSTR FuncName;
    
    Module = NULL;
    switch( JetVersion ) {
    case LoadJet2001 : Module = TEXT("esent.dll"); break;
    case LoadJet97 : Module = TEXT("esent.dll"); break;
    case LoadJet500 : Module = TEXT("jet500.dll"); break;
    case LoadJet200 : Module = TEXT("jet.dll"); break;
    default: Module = TEXT("esent.dll"); break;
    }

    hJet = LoadLibrary( Module );
    if( NULL == hJet ) {
        Error = GetLastError();
    } else {
        Error = NO_ERROR;
    }

    Tr( "Loading %ws: %ld\n", Module, Error );
    if( NO_ERROR != Error ) return Error;

    for( i = 0; i < sizeof(FuncTable)/sizeof(FuncTable[0]); i ++ ) {
        (*FuncTable[i].FuncPtr) = NULL;
    }
    
    for( i = 0; i < sizeof(FuncTable)/sizeof(FuncTable[0]); i ++ ) {
        if( LoadJet200 != JetVersion ) {
            FuncName = FuncTable[i].FuncName;
        } else {
            if( 0 == FuncTable[i].Index ) {
                (*FuncTable[i].FuncPtr) = NULL;
                continue;
            }

            FuncName = (LPSTR)ULongToPtr(FuncTable[i].Index);
        }

        Error = NO_ERROR;
        
        (*FuncTable[i].FuncPtr) = GetProcAddress(hJet, FuncName);
        
        if( NULL == FuncTable[i].FuncPtr ) {
            Error = GetLastError();

            if( LoadJet97 == JetVersion || LoadJet2001 == JetVersion ) {
                (*FuncTable[i].FuncPtr) = GetProcAddress(
                    hJet, FuncTable[i].AltName );
                if( NULL != FuncTable[i].FuncPtr ) continue;

                Error = GetLastError();
            }
        }

        Tr("GetProcAddr[%ws]: %ld\n", FuncTable[i].FuncNameW, Error );
        if( NO_ERROR != Error ) break;
    }

    //
    // if erred out, cleanup
    //

    if( NO_ERROR != Error ) {
        FreeLibrary( hJet );
        hJet = NULL;
    }

    return Error;
}


DWORD
SetJetParams(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    DWORD Error, JetParam, LogFileSize;
    CHAR Temp[2048];
    LPSTR DbSysFile = "\\system.mdb";
    LPSTR DbBaseName = "j50";

    JetInstance = 0;
    LogFileSize = 1000;

    if( JetVersion == LoadJet2001 ) LogFileSize = 1024;

    memcpy( Temp, DbPath,
            (( sizeof( Temp ) - 1 ) < strlen( DbPath ))
            ? sizeof( Temp )  : strlen( DbPath ) + 1 );
    Temp[ sizeof( Temp ) - 2 ] = '\0';

    if( LoadJet200 == JetVersion ) {
        strcat(Temp, DbSysFile);
        JetParam = JET_paramSysDbPath_OLD;
    } else {
        strcat(Temp, "\\");
        if( LoadJet97 > JetVersion ) {
            JetParam = JET_paramSystemPath_OLD;
        } else {
            JetParam = JET_paramSystemPath;
        }
    }

    Error = JetSetSystemParameter(
        &JetInstance, (JET_SESID)0, JetParam, 0, Temp );

    Tr("SetDbParam %ld: %ld\n", JetParam, Error );
    if( NO_ERROR != Error ) return Error;

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 > JetVersion ) {
            JetParam = JET_paramBaseName_OLD;
        } else {
            JetParam = JET_paramBaseName;
        }

        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 0, DbBaseName  );

        Tr("SetDbParam %ld: %ld\n", JetParam, Error );
        if( NO_ERROR != Error ) return Error;
    }

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 <= JetVersion ) {
            JetParam = JET_paramLogFileSize;
        } else {
            JetParam = JET_paramLogFileSize_OLD;
        }

        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, LogFileSize, NULL );
        Tr("SetDbParam %ld: %ld\n", JetParam, Error );
        if( NO_ERROR != Error ) return Error;
    }
    
    if( LoadJet200 != JetVersion ) {
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0,
            JET_paramCheckFormatWhenOpenFail, 1, NULL );

        JetParam = JET_paramCheckFormatWhenOpenFail;
        Tr("SetDbParam %ld: %ld\n", JetParam, Error );
        if( NO_ERROR != Error ) return Error;
    }

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 > JetVersion ) {
            JetParam = JET_paramRecovery_OLD;
        } else {
            JetParam = JET_paramRecovery;
        }

        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 0, "on");

        Tr("SetDbParam %ld: %ld\n", JetParam, Error );
        if( NO_ERROR != Error ) return Error;
    }

    //
    // Note: Ideally, the log files should never exist.  Even
    // if the database is opened in readonly mode, they seem to
    // exist.  Not sure what else can be done
    //

    if( LoadJet97 <= JetVersion ) {
        JetParam = JET_paramLogFilePath;
    } else {
        JetParam = JET_paramLogFilePath_OLD;
    }

    strcpy(Temp, DbPath); strcat( Temp, "\\");

    Error = JetSetSystemParameter(
        &JetInstance, (JET_SESID)0, JetParam, 0, Temp );
    Tr("SetDbParam %ld: %ld\n", JetParam, Error );

    return Error;
}

DWORD
OpenDatabase(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    LONG Error;
    DWORD i;
    CHAR FilePath[2048];
    JET_INDEXLIST TmpIdxList;
    DWORD Len, Len1;

    JetSession = 0;
    JetDb = 0;
    JetTbl = 0;

    Error = JetInit( &JetInstance );

    Tr("JetInit: %ld\n", Error );
    if( NO_ERROR != Error ) return Error;

    Error = JetBeginSession(
        JetInstance, &JetSession, "admin", "" );

    Tr("JetBeginSession: %ld\n", Error);
    if( Error < 0 ) return Error;

    Error = JetDetachDatabase( JetSession, NULL );

    Tr("JetDetachDatabase:%ld\n", Error );
    if( Error < 0 ) return Error;

    // Create the filename
    Len = strlen( DbName );
    Len1 = strlen( DbPath );
    if ( sizeof( FilePath ) < ( Len + Len1 + 2 )) { // 2 for '\\' and '\0'
        return ERROR_INVALID_PARAMETER;
    }

    memcpy( FilePath, DbPath, Len1 );
    FilePath[ Len1 ] = '\\';
    memcpy( FilePath + Len1 + 1, DbName, Len );
    FilePath[ Len + Len1 + 1 ] = '\0';

    Error = JetAttachDatabase( JetSession, FilePath, JET_bitDbExclusive );

    Tr("JetAttachDatabase:%ld\n", Error );
    if( Error < 0 ) return Error;

    Error = JetOpenDatabase(
        JetSession, FilePath, NULL, &JetDb,
        JET_bitDbSingleExclusive );

    Tr("JetOpenDatabase: %ld\n", Error);
    if( Error < 0 ) return Error;

    Error = JetOpenTable(
        JetSession, JetDb, (LPSTR)"ClientTable",
        NULL, 0, 0,&JetTbl );

    Tr("JetOpenTable: %ld\n", Error );
    if( Error < 0 ) return Error;

    for( i = 0; i < sizeof(ClientTable)/sizeof(ClientTable[0]); i ++ ) {
        JET_COLUMNDEF ColDef;

        Error = JetGetTableColumnInfo(
            JetSession, JetTbl, ClientTable[i].ColName, &ColDef,
            sizeof(ColDef), 0 );

        if(Error && JET_errColumnNotFound != Error ) {
            Tr("JetGetCol: %ld\n", Error );
        }

        if( Error < 0 ) {
            if( JET_errColumnNotFound == Error ) {
                ClientTable[i].fPresent = FALSE;
                continue;
            } else {
                return Error;
            }
        }

        if( ColDef.coltyp != ClientTable[i].ColType ) {
            ASSERT( FALSE );
            Error = ERROR_BAD_FORMAT;
            return Error;
        }

        ClientTable[i].ColHandle = ColDef.columnid;
    }

    return NO_ERROR;
}

DWORD
LoadAndInitializeDatabase(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    DWORD Error;

    //
    // Attempt to load DLL and retrieve function pointers
    //

    Tr("Loading %ld jet version\n", JetVersion );
    
    Error = LoadAndLinkRoutines( JetVersion );
    if( NO_ERROR != Error ) return Error;

    //
    // set standard jet params
    //
    
    Error = SetJetParams( JetVersion, DbName, DbPath );
    if( NO_ERROR != Error ) {
        FreeLibrary( hJet ); hJet = NULL;
        return Error;
    }

    //
    // Attempt to open database
    //

    Error = OpenDatabase( JetVersion, DbName, DbPath );
    if( NO_ERROR != Error ) {
        CleanupDatabase();
        return Error;
    }
    
    return NO_ERROR;
}

DWORD
LoadAndLinkSecurityRoutines(
    OUT FARPROC *pGetInfo,
    OUT FARPROC *pSetInfo
    )
{
    HMODULE hAdvapi32;

    hAdvapi32 = GetModuleHandle(TEXT("ADVAPI32.DLL"));
    if( NULL == hAdvapi32 ) return GetLastError();

    (*pGetInfo) = GetProcAddress(hAdvapi32, "GetNamedSecurityInfoA");
    if( NULL == *pGetInfo ) return GetLastError();

    (*pSetInfo) = GetProcAddress(hAdvapi32, "SetNamedSecurityInfoA");
    if( NULL == *pSetInfo ) return GetLastError();

    return NO_ERROR;
}

DWORD
ConvertPermissionsOnDbFiles(
    VOID
    )
{
    DWORD Error, dwVersion = GetVersion();
    PSECURITY_DESCRIPTOR pSec;
    PACL pAcl;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAA FileData;
    CHAR FileName[1024];
    FARPROC pGetInfo, pSetInfo;
    CHAR DriversDirPath[MAX_PATH *2 +1];
    DWORD PathLen = sizeof(DriversDirPath)-1;
    
    //
    // Check if version is atleast NT5.
    //
    
    dwVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    if( dwVersion < 5 ) return NO_ERROR;
    
    //
    // First get the requried function pointers..
    //

    Error = LoadAndLinkSecurityRoutines(
        &pGetInfo, &pSetInfo );
    if( NO_ERROR != Error ) return Error;

    ZeroMemory(DriversDirPath, PathLen+1);
    PathLen = ExpandEnvironmentStringsA(
        "%SystemRoot%\\system32\\drivers", DriversDirPath, PathLen );
    if( PathLen == 0 ) {
        Error = GetLastError();
        return Error;
    }
    
    
    pSec = NULL;
    pAcl = NULL;
    Error = (DWORD)pGetInfo(
        DriversDirPath, //"MACHINE\\SYSTEM\\CurrentControlSet\\Services\\DHCPServer",
        SE_FILE_OBJECT, // SE_REGISTRY_KEY
        DACL_SECURITY_INFORMATION, NULL, NULL,
        &pAcl, NULL, &pSec );

    if( NO_ERROR != Error ) return Error;

    Error = (DWORD)pSetInfo(
        DatabasePath, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
        NULL, NULL, pAcl, NULL );
    if( NO_ERROR != Error ) return Error;

    strcpy(FileName, DatabasePath);
    if( FileName[strlen(FileName)-1] != '\\' ) {
        strcat(FileName, "\\");
    }
    strcat(FileName, DatabaseName);

    Error = (DWORD)pSetInfo(
        FileName, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
        NULL, NULL, pAcl, NULL );
    if( NO_ERROR != Error ) goto Cleanup;

    //
    // Now for all files matching "*.log", repeat above operation
    //

    strcpy(FileName, DatabasePath);
    if( FileName[strlen(FileName)-1] != '\\' ) {
        strcat(FileName, "\\");
    }
    strcat(FileName, "*.*");
    
    hSearch = FindFirstFileA( FileName, &FileData );
    if( INVALID_HANDLE_VALUE == hSearch ) {
        Error = GetLastError();
        goto Cleanup;
    }

    do {

        if( 0 != strcmp(FileData.cFileName, ".") &&
            0 != strcmp(FileData.cFileName, "..") ) {
            strcpy(FileName, DatabasePath);
            if( FileName[strlen(FileName)-1] != '\\' ) {
                strcat(FileName, "\\");
            }
            strcat(FileName, FileData.cFileName);
            
            Error = (DWORD)pSetInfo(
                FileName, SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION, NULL, NULL, pAcl, NULL );
            if( NO_ERROR != Error ) break;
        }

        Error = FindNextFileA( hSearch, &FileData );
        if( FALSE != Error ) Error = NO_ERROR;
        else Error = GetLastError();

    } while( NO_ERROR == Error );

    FindClose( hSearch );
    
 Cleanup:

    LocalFree( pSec );

    if( ERROR_FILE_NOT_FOUND == Error ) return NO_ERROR;
    if( ERROR_NO_MORE_FILES == Error ) return NO_ERROR;
    return Error;
}

DWORD
ReadString(
    IN HKEY hKey,
    IN LPSTR KeyName,
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Error, Size, Type;
    CHAR Str[1024];

    Size = sizeof(Str);
    Error = RegQueryValueExA(
        hKey, KeyName, NULL, &Type, (LPSTR)Str, &Size );
    if( NO_ERROR == Error ) {
        if( 0 == Size || 1 == Size ) Error = ERROR_NOT_FOUND;
        if( Type != REG_SZ && Type != REG_EXPAND_SZ && Type !=
            REG_MULTI_SZ ) Error = ERROR_BAD_FORMAT;
    }

    if( NO_ERROR != Error ) return Error;

    Size = ExpandEnvironmentStringsA( (LPSTR)Str, Buffer, BufSize );
    if( Size == 0 || Size > BufSize ) {
        Error = ERROR_META_EXPANSION_TOO_LONG;
    }

    Tr("Expansion failed for %s\n", KeyName );
    return Error;
}

DWORD
ReadRegistry(
    VOID
    )
{
    HKEY hKey;
    DWORD Error, Size, Use351Db, DbType;
    CHAR Str[1024];

    //
    // Open dhcp server parameters key
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    Tr("Open Params key failed %ld\n", Error );
    if( NO_ERROR != Error ) return Error;

    //
    // Read database details
    //

    do {
        Error = ReadString(
            hKey, "DatabasePath", (LPSTR)DatabasePath,
            sizeof(DatabasePath) );

        if( NO_ERROR != Error ) {
            Tr(" Read DatabasePath failed: %ld\n", Error );
            break;
        }

        Error = ReadString(
            hKey, "DatabaseName", (LPSTR)DatabaseName,
            sizeof(DatabaseName) );

        if( NO_ERROR != Error ) {
            Tr("Read DatabaseName failed %ld\n", Error );
            break;
        }

        strcpy(DhcpEximOemDatabaseName, DatabaseName);
        strcpy(DhcpEximOemDatabasePath, DatabasePath);
        CharToOemA(DhcpEximOemDatabaseName, DhcpEximOemDatabaseName);
        CharToOemA(DhcpEximOemDatabasePath, DhcpEximOemDatabasePath);
        
        if( !IsNT5() && !IsNT4() ) JetVersion  = LoadJet2001;
        else {
            if( IsNT5() ) JetVersion = LoadJet97;
            else JetVersion = LoadJet500;
            
            Size = sizeof(DWORD);
            Error = RegQueryValueExA(
                hKey, "Use351Db", NULL, NULL, (LPBYTE)&Use351Db, &Size );
            if( NO_ERROR == Error ) {
                JetVersion = LoadJet200;
            } else {
                Size = sizeof(DWORD);
                Error = RegQueryValueExA(
                    hKey, "DbType", NULL, NULL, (LPBYTE)&DbType, &Size );
                if( NO_ERROR == Error ) {
                    switch(DbType) {
                    case 3: JetVersion = LoadJet200; break;
                    case 4: JetVersion = LoadJet500; break;
                    }
                }
            }
        }
        
        Error = NO_ERROR;

    } while( 0 );

#if DBG
    DbgPrint("JetVersion: %ld\n", JetVersion);
#endif
    
    RegCloseKey( hKey );
    return Error;
}


DWORD
InitializeDatabase(
    VOID
    )
{
    DWORD Error;

    if( FALSE == SetCurrentDirectoryA(DatabasePath) ) {
        Error = GetLastError();
        if( ERROR_FILE_NOT_FOUND == Error ||
            ERROR_PATH_NOT_FOUND == Error ) {
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }
        
        return Error;
    }

    Error = LoadAndInitializeDatabase(
        JetVersion, (LPSTR)DatabaseName, (LPSTR)DatabasePath );

    if( NO_ERROR != Error ) {
        Tr("LoadAndInitializeDatabase(%ld):%ld\n", JetVersion, Error );
    }
    
    return Error;
}

JET_ERR
GetColumnValue(
    IN DWORD Index,
    IN LPSTR Buffer,
    IN OUT ULONG *BufSize
    )
{
    JET_ERR Error = NO_ERROR;
    DWORD Size;

    if( ClientTable[Index].fPresent == FALSE ) {
        (*BufSize) = 0;
        return NO_ERROR;
    }
    
    Error = JetRetrieveColumn(
        JetSession, JetTbl, ClientTable[Index].ColHandle, Buffer,
        *BufSize, &Size, 0, NULL );

    if( JET_errColumnNotFound == Error ) {
        Error = NO_ERROR;
        Size = 0;
    }

    Tr("JetRetrieveColumn(%ld): %ld\n", Index, Error );
    if( Error < 0 ) return Error;

    (*BufSize) = Size;
    return NO_ERROR;
}

JET_ERR
SetColumnValue(
    IN DWORD Index,
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    JET_ERR Error = NO_ERROR;

    if( ClientTable[Index].fPresent == FALSE ) {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    Error = JetSetColumn(
        JetSession, JetTbl, ClientTable[Index].ColHandle, Buffer,
        BufSize, 0, NULL );

    Tr("JetSetColumn(%ld): %ld\n", Index, Error );
    if( Error < 0 ) return Error;

    return NO_ERROR;
}
    

#define CLIENT_TYPE_UNSPECIFIED     0x0 // for backward compatibility
#define CLIENT_TYPE_DHCP            0x1
#define CLIENT_TYPE_BOOTP           0x2
#define CLIENT_TYPE_BOTH    ( CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP )

#define ADDRESS_STATE_OFFERED 0
#define ADDRESS_STATE_ACTIVE 1
#define ADDRESS_STATE_DECLINED 2
#define ADDRESS_STATE_DOOM 3
#define ADDRESS_BIT_DELETED  0x80
#define ADDRESS_BIT_UNREGISTERED 0x40
#define ADDRESS_BIT_BOTH_REC 0x20
#define ADDRESS_BIT_CLEANUP 0x10
#define ADDRESS_BITS_MASK 0xF0

DWORD
AddRecord(
    IN LPSTR Buffer,
    IN ULONG BufSize
    );

DWORD
AddScannedClient(
    IN DWORD IpAddressNetOrder,
    IN DWORD SubnetMaskNetOrder,
    IN LPBYTE HwAddr,
    IN ULONG HwLen,
    IN LPWSTR MachineName,
    IN LPWSTR MachineInfo,
    IN ULONGLONG ExpirationFileTime,
    IN BYTE State,
    IN BYTE ClientType
    )
{
    DWORD i;
    CHAR Buffer[1024];
    ULONG Length, Size;

    Length = 0;
    Buffer[Length++] = (BYTE)RecordTypeDbEntry;
    
    CopyMemory(
        &Buffer[Length], (PVOID)&IpAddressNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);
    
    CopyMemory(
        &Buffer[Length], (PVOID)&SubnetMaskNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);

    Buffer[Length++] = (BYTE)HwLen;
    CopyMemory(&Buffer[Length], HwAddr, HwLen );
    Length += HwLen;
    
    if( NULL == MachineName || 0 == *MachineName ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineName));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    if ( NULL != MachineName ) {
        CopyMemory(&Buffer[Length], (PVOID)MachineName, Size );
        Length += Size;
    }

    if( NULL == MachineInfo || 0 == *MachineInfo ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineInfo));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    if ( NULL != MachineInfo ) {
        CopyMemory(&Buffer[Length], (PVOID)MachineInfo, Size );
        Length += Size;
    }

    CopyMemory(&Buffer[Length], (PVOID)&ExpirationFileTime, sizeof(ULONGLONG));
    Length += sizeof(ULONGLONG);
    Buffer[Length++] = State;
    Buffer[Length++] = ClientType;

    return AddRecord( Buffer, Length );
}


BOOL
SubnetNotSelected(
    IN ULONG Subnet,
    IN PULONG Subnets,
    IN ULONG nSubnets
    )
{
    if( nSubnets == 0 ) return FALSE;
    while( nSubnets -- ) {
        if( Subnet == *Subnets++ ) return FALSE;
    }
    return TRUE;
}

DWORD static
ScanDatabase(
    IN PULONG Subnets,
    IN ULONG nSubnets
    )
{
    LONG Error;
    DWORD Count;
    
    Error = JetSetCurrentIndex(
        JetSession, JetTbl, NULL );

    Tr("JetSetCurrentIndex: %ld\n", Error );
    if( Error < 0 ) return Error;

    Error = JetMove( JetSession, JetTbl, JET_MoveFirst, 0 );

    for( Count = 0 ; Error >= 0 ; Count ++,
         Error = JetMove(JetSession, JetTbl, JET_MoveNext, 0) ) {
        
        DWORD IpAddress, SubnetMask, Size, HwLen;
        FILETIME Expiration;
        CHAR HwAddress[256];
        WCHAR MachineName[300], MachineInfo[300];
        BYTE Type, State;
        
        //
        // Get current client's info.
        //

        Size = sizeof(IpAddress);
        Error = GetColumnValue(
            IPADDRESS_INDEX, (PVOID)&IpAddress, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(IpAddress) ) {
            Tr("Invalid Ip size\n");
            continue;
        }
        
        Size = sizeof(SubnetMask);
        Error = GetColumnValue(
            SUBNET_MASK_INDEX, (PVOID)&SubnetMask, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(SubnetMask) ) {
            Tr("Invalid mask size\n");
            continue;
        }

        //
        // Check if the subnet specified matches the specific
        // subnet 
        //

        if( SubnetNotSelected(
            IpAddress&SubnetMask, Subnets, nSubnets ) ) {
            continue;
        }
        
        HwLen = sizeof(HwAddress);
        Error = GetColumnValue(
            HARDWARE_ADDRESS_INDEX, (PVOID)HwAddress, &HwLen );
        if( NO_ERROR != Error ) break;

        Size = sizeof(MachineName);
        Error = GetColumnValue(
            MACHINE_NAME_INDEX, (PVOID)MachineName, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            Tr("Invalid name size\n");
            continue;
        }

        MachineName[Size/2] = L'\0';

        Size = sizeof(MachineInfo);
        Error = GetColumnValue(
            MACHINE_INFO_INDEX, (PVOID)MachineInfo, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            Tr("Invalid Info size\n");
            continue;
        }

        MachineInfo[Size/2] = L'\0';

        Size = sizeof(Expiration);
        Error = GetColumnValue(
            LEASE_TERMINATE_INDEX, (PVOID)&Expiration, &Size );
        if( NO_ERROR != Error ) break;

        if( Size != sizeof(Expiration) ) {
            Tr("Invalid expiration\n");
            Error = ERROR_INVALID_DATA;
            break;
        }

        Size = sizeof(Type);
        Error = GetColumnValue(
            CLIENT_TYPE_INDEX, (PVOID)&Type, &Size );

        if( NO_ERROR != Error || 0 == Size ) {
            Type = CLIENT_TYPE_DHCP;
        }

        Size = sizeof(State);
        Error = GetColumnValue(
            STATE_INDEX, (PVOID)&State, &Size );

        if( NO_ERROR != Error || 0 == Size ) {
            State = ADDRESS_STATE_ACTIVE;
        }

        if( ADDRESS_STATE_OFFERED == State ) {
            continue;
        }
        
        //
        // Try to add the client
        //

        Error = AddScannedClient(
            ByteSwap(IpAddress), ByteSwap(SubnetMask), HwAddress, HwLen,
            MachineName, MachineInfo, *(PULONGLONG)&Expiration,
            State, Type ); 
        
        if( NO_ERROR != Error ) break;
    }

    Tr("Scanned %ld clients\n", Count );
    
    if( JET_errNoCurrentRecord == Error ) return NO_ERROR;
    if( Error < 0 ) return Error;
    return NO_ERROR;
}


DWORD
DumpData(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    return NO_ERROR;
}

DWORD
AddRecord(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Written, Error = NO_ERROR;

    if( NULL != Buffer ) {
        CopyMemory(&SaveBuf[SaveBufSize], (PVOID)&BufSize, sizeof(DWORD));
        CopyMemory(&SaveBuf[SaveBufSize+sizeof(DWORD)], Buffer, BufSize );
    } else {
        if( 0 == SaveBufSize ) return NO_ERROR;
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize, &Written, NULL ) ) {
            return GetLastError();
        }

        if( Written != SaveBufSize ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }

        return NO_ERROR;
    }
    
    if( SaveBufSize <= SAVE_THRESHOLD ) {
        SaveBufSize += BufSize + sizeof(DWORD);
    } else {
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize + BufSize + sizeof(DWORD),
            &Written, NULL )) {
            return GetLastError();
        }

        if( Written != SaveBufSize + BufSize + sizeof(DWORD) ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }
        
        SaveBufSize = 0;
    }

    return Error;
}


DWORD
AddRecordNoSize(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Written, Error = NO_ERROR;

    if( NULL != Buffer ) {
        CopyMemory(&SaveBuf[SaveBufSize], Buffer, BufSize );
    } else {
        if( 0 == SaveBufSize ) return NO_ERROR;
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize, &Written, NULL ) ) {
            return GetLastError();
        }

        if( Written != SaveBufSize ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }

        return NO_ERROR;
    }
    
    if( SaveBufSize <= SAVE_THRESHOLD ) {
        SaveBufSize += BufSize;
    } else {
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize + BufSize,
            &Written, NULL )) {
            return GetLastError();
        }

        if( Written != SaveBufSize + BufSize ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }
        
        SaveBufSize = 0;
    }

    return Error;
}


DWORD
StopDhcpService(
    VOID
    )
{
    SC_HANDLE hSc, hSvc;
    DWORD Error;

    Error = NO_ERROR;
    hSc = NULL;
    hSvc = NULL;
    
    do {
        hSc = OpenSCManager(
            NULL, NULL, SC_MANAGER_CONNECT | GENERIC_READ | GENERIC_WRITE );
        if( NULL == hSc ) {
            Error = GetLastError();

            Tr("OpenSCManager: %ld\n", Error );
            break;
        }

        hSvc = OpenService(
            hSc, TEXT("DHCPServer"), SERVICE_STOP| SERVICE_QUERY_STATUS );
        if( NULL == hSvc ) {
            Error = GetLastError();

            Tr("OpenService: %ld\n", Error );
            break;
        }

        while( NO_ERROR == Error ) {
            SERVICE_STATUS Status;

            if( FALSE == QueryServiceStatus( hSvc, &Status ) ) {
                Error = GetLastError();
                Tr( "QueryServiceStatus: %ld\n", Error );
                break;
            }

            if( Status.dwCurrentState == SERVICE_STOPPED ) break;
            if( Status.dwCurrentState != SERVICE_RUNNING &&
                Status.dwCurrentState != SERVICE_PAUSED ) {
                Tr( "Waiting, state = %ld\n", Status.dwCurrentState );

                if( Status.dwWaitHint < 1000 ) {
                    Status.dwWaitHint = 1000;
                }
                if( Status.dwWaitHint > 5000 ) {
                    Status.dwWaitHint = 1000;
                }
                
                Sleep(Status.dwWaitHint);
            } else {
                Error = ControlService(
                    hSvc, SERVICE_CONTROL_STOP, &Status );
                if( FALSE != Error ) Error = NO_ERROR;
                else {
                    Error = GetLastError();
                    Tr("ControlService: %ld\n", Error );
                    break;
                }
            }
        }
    } while( 0 );

    if( NULL != hSvc ) CloseServiceHandle( hSvc );
    if( NULL != hSc ) CloseServiceHandle( hSc );
    
    return Error;
}


DWORD
StartDhcpService(
    VOID
    )
{
    SC_HANDLE hSc, hSvc;
    DWORD Error;

    Error = NO_ERROR;
    hSc = NULL;
    hSvc = NULL;
    
    do {
        hSc = OpenSCManager(
            NULL, NULL, SC_MANAGER_CONNECT | GENERIC_READ | GENERIC_WRITE );
        if( NULL == hSc ) {
            Error = GetLastError();

            Tr("OpenSCManager: %ld\n", Error );
            break;
        }

        hSvc = OpenService(
            hSc, TEXT("DHCPServer"), SERVICE_START| SERVICE_QUERY_STATUS );
        if( NULL == hSvc ) {
            Error = GetLastError();

            Tr("OpenService: %ld\n", Error );
            break;
        }

        Error = StartService( hSvc, 0, NULL );
        if( FALSE == Error ) Error = GetLastError(); else Error = NO_ERROR;
        if( NO_ERROR != Error ) break;
        
        while( NO_ERROR == Error ) {
            SERVICE_STATUS Status;

            if( FALSE == QueryServiceStatus( hSvc, &Status ) ) {
                Error = GetLastError();
                Tr("QueryServiceStatus: %ld\n", Error );
                break;
            }

            if( Status.dwCurrentState == SERVICE_RUNNING ) break;
            if( Status.dwCurrentState == SERVICE_START_PENDING ) {
                Tr("Sleeping %ld\n", Status.dwWaitHint );
                if( Status.dwWaitHint < 1000 ) {
                    Status.dwWaitHint = 1000;
                }
                if( Status.dwWaitHint > 5000 ) {
                    Status.dwWaitHint = 5000;
                }
                
                Sleep(Status.dwWaitHint);
            } else {
                Error = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }
    } while( 0 );

    if( NULL != hSvc ) CloseServiceHandle( hSvc );
    if( NULL != hSc ) CloseServiceHandle( hSc );
    
    return Error;
}


DWORD __stdcall PrintRecord(
    IN PDHCP_RECORD Recx
    )
{
    DWORD i;
    DHCP_RECORD Rec = *Recx;
    
    if( Rec.fMcast ) {
        printf("Mcast Record\n" );
        printf("Address: %s\n", IpAddressToString(
            Rec.Info.Mcast.Address ));
        printf("ScopeId: %s\n", IpAddressToString(
            Rec.Info.Mcast.ScopeId ));

        printf("ClientId:");
        for( i = 0 ; i < (DWORD)Rec.Info.Mcast.HwLen; i ++ ) {
            printf(" %02X", Rec.Info.Mcast.ClientId[i]);
        }
        printf("\nState = %02X\n", Rec.Info.Mcast.State);
        
    } else {
        printf("DHCP Record\n" );
        printf("Address: %s\n", IpAddressToString(
            Rec.Info.Dhcp.Address ));
        printf("Mask: %s\n", IpAddressToString(
            Rec.Info.Dhcp.Mask ));

        printf("ClientId:");
        for( i = 0 ; i < (DWORD)Rec.Info.Dhcp.HwLen; i ++ ) {
            printf(" %02X", Rec.Info.Dhcp.HwAddr[i]);
        }
        printf("\nState = %02X\n", Rec.Info.Dhcp.State);
        printf("\nType = %02X\n", Rec.Info.Dhcp.Type);
        if( Rec.Info.Dhcp.Name ) {
            printf("Name = %ws\n", Rec.Info.Dhcp.Name );
        }

        if( Rec.Info.Dhcp.Info ) {
            printf("Comment = %ws\n", Rec.Info.Dhcp.Info );
        }
    }

    return NO_ERROR;
}

DWORD
StringLen(
    IN WCHAR UNALIGNED *Str
    )
{
    DWORD Size = sizeof(WCHAR);

    if( NULL == Str ) return 0;
    while( *Str ++ != L'\0' ) Size += sizeof(WCHAR);

    return Size;
}

DWORD __stdcall
AddRecordToDatabase(
    IN PDHCP_RECORD Recx
    )
{
    DWORD Index;
    JET_ERR Error;
    DHCP_RECORD Rec = *Recx;
    WCHAR Address[30], HwAddress[300];

    IpAddressToStringW(Rec.Info.Dhcp.Address, Address);
    DhcpHexToString(
        HwAddress, Rec.Info.Dhcp.HwAddr,
        Rec.Info.Dhcp.HwLen );
    
    Error = JetBeginTransaction( JetSession );
    Tr( "JetBeginTransaction: %ld\n", Error );
    if( Error < 0 ) return Error;

    do { 
        Error = JetPrepareUpdate( JetSession, JetTbl, JET_prepInsert );
        if( Error ) Tr( "JetPrepareUpdate: %ld\n", Error );
        if( Error < 0 ) break;

        Index = IPADDRESS_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)&Rec.Info.Dhcp.Address, sizeof(DWORD) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;
        
        Index = SUBNET_MASK_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)&Rec.Info.Dhcp.Mask, sizeof(DWORD) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = HARDWARE_ADDRESS_INDEX;
        Error = SetColumnValue(
            Index, Rec.Info.Dhcp.HwAddr, Rec.Info.Dhcp.HwLen );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = STATE_INDEX;
        Error = SetColumnValue(
            Index, &Rec.Info.Dhcp.State, sizeof(BYTE) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = CLIENT_TYPE_INDEX;
        Error = SetColumnValue(
            Index, &Rec.Info.Dhcp.Type, sizeof(BYTE) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = MACHINE_INFO_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)Rec.Info.Dhcp.Info, StringLen(Rec.Info.Dhcp.Info) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = MACHINE_NAME_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)Rec.Info.Dhcp.Name, StringLen(Rec.Info.Dhcp.Name) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = LEASE_TERMINATE_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)&Rec.Info.Dhcp.ExpTime, sizeof(FILETIME) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = SERVER_IP_ADDRESS_INDEX;
        Rec.Info.Dhcp.Address = INADDR_LOOPBACK;
        Error = SetColumnValue(
            Index, (LPBYTE)&Rec.Info.Dhcp.Address, sizeof(DWORD));
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = SERVER_NAME_INDEX;
        Rec.Info.Dhcp.Name = L"";
        Error = SetColumnValue(
            Index, (LPBYTE)Rec.Info.Dhcp.Name, StringLen(Rec.Info.Dhcp.Name));
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Error = JetUpdate( JetSession, JetTbl, NULL, 0, NULL );
        if( Error ) Tr( "JetUpdate: %ld\n", Error );
        if( Error < 0 ) break;

    } while ( 0 );

    if( Error < 0 ) {
        BOOL fAbort;

        JetRollback( JetSession, 0 );

        fAbort = TRUE;
        DhcpEximErrorDatabaseEntryFailed(
            Address, HwAddress, Error, &fAbort );

        if( fAbort ) return ERROR_CAN_NOT_COMPLETE;
    } else {
        JetCommitTransaction( JetSession, 0 );
    }

    return NO_ERROR;
}

DWORD
ProcessDbEntries(
    IN LPSTR Buffer,
    IN ULONG BufSize,
    IN PULONG Subnets,
    IN ULONG nSubnets,
    IN DHCP_ADD_RECORD_ROUTINE AddRec    
    )
{
    DWORD Size, ThisSize, DbEntry;
    LPSTR Buf;
    DWORD Address, i, Error;
    FILETIME Time;
    DHCP_RECORD Rec;

    Error = NO_ERROR;
    
    while( BufSize > sizeof(DWORD) ) {
        CopyMemory(&ThisSize, Buffer, sizeof(DWORD));
        Buffer += sizeof(DWORD);
        BufSize -= sizeof(DWORD);

        if( ThisSize > BufSize ) return ERROR_INVALID_DATA;
        if( ThisSize == 0 ) continue;
        DbEntry = *Buffer;
        Buf = Buffer+1;
        Buffer += ThisSize;
        BufSize -= ThisSize;

        ZeroMemory( &Rec, sizeof(Rec));

        switch(DbEntry) {
        default :
            return ERROR_INVALID_DATA;
            
        case RecordTypeDbEntry :
            Rec.fMcast = FALSE;
            CopyMemory( &Rec.Info.Dhcp.Address, Buf, sizeof(DWORD));
            Rec.Info.Dhcp.Address = ByteSwap(Rec.Info.Dhcp.Address);
            Buf += sizeof(DWORD);

            CopyMemory( &Rec.Info.Dhcp.Mask, Buf, sizeof(DWORD));
            Rec.Info.Dhcp.Mask = ByteSwap(Rec.Info.Dhcp.Mask);
            Buf += sizeof(DWORD);

            Size = Rec.Info.Dhcp.HwLen = *Buf++;
            Rec.Info.Dhcp.HwAddr = Buf;
            Buf += Size;

            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Dhcp.Name = (PVOID)Buf;
                Buf += Size;
            }

            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Dhcp.Info = (PVOID)Buf;
                Buf += Size;
            }

            CopyMemory(&Rec.Info.Dhcp.ExpTime, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            Rec.Info.Dhcp.State = Buf[0];
            Rec.Info.Dhcp.Type = Buf[1];

            //
            // Add the subnet only if it is selected
            //
            
            if( !SubnetNotSelected(
                Rec.Info.Dhcp.Address & Rec.Info.Dhcp.Mask,
                Subnets, nSubnets ) ) {
                Error = AddRec( &Rec );
            }
            
            break;
        case RecordTypeMcastDbEntry :
            Rec.fMcast = TRUE;
            
            CopyMemory( &Rec.Info.Mcast.Address, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            CopyMemory( &Rec.Info.Mcast.ScopeId, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            Size = Rec.Info.Mcast.HwLen = *Buf++;
            Rec.Info.Mcast.ClientId = Buf;
            Buf += Size;

            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Mcast.Info = (PVOID)Buf;
                Buf += Size;
            }

            CopyMemory(&Rec.Info.Mcast.End, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            CopyMemory(&Rec.Info.Mcast.Start, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            Rec.Info.Mcast.State = Buf[0];

            Error = AddRec( &Rec );
            break;
        }

        if( NO_ERROR != Error ) return Error;
    }

    return NO_ERROR;
}


DWORD
SaveDatabaseEntriesToFile(
    IN PULONG Subnets,
    IN ULONG nSubnets
    )
{
    DWORD Error;
    
    Error = InitializeDatabase();
    if( NO_ERROR != Error ) {
        Tr("InitializeDatabase: %ld\n", Error );
        return Error;
    }

    Error = ScanDatabase(Subnets, nSubnets);
    if( NO_ERROR != Error ) {
        Tr("ScanDatabase: %ld\n", Error);
    } else {
        AddRecord( NULL, 0 );
    }

    CleanupDatabase();

    return Error;
}
    
DWORD
SaveFileEntriesToDatabase(
    IN LPBYTE Mem,
    IN ULONG MemSize,
    IN PULONG Subnets,
    IN ULONG nSubnets
    )
{
    DWORD Error;

    Error = InitializeDatabase();
    if( NO_ERROR != Error ) {
        Tr("InitializeDatabase: %ld\n", Error );
        return Error;
    }

    Error = ProcessDbEntries(
        Mem, MemSize, Subnets, nSubnets, AddRecordToDatabase );
    if( NO_ERROR != Error ) {
        Tr("ProcessDbEntries: %ld\n", Error );
    }

    CleanupDatabase();

    return Error;
}

DWORD
InitializeDatabaseParameters(
    VOID
    )
{
    DWORD Error;
    
    //
    // Stop the service
    //
    
    Error = StopDhcpService();
    if( NO_ERROR != Error ) {
        Tr("StopDhcpService: %ld\n", Error );
        return Error;
    }

    //
    // Read the registry and otherwise initialize the database
    // parameters, without actually opening the database.
    //

    Error = ReadRegistry();
    Tr("ReadRegistry: %ld\n", Error );
    if( NO_ERROR != Error ) return Error;

    Error = ConvertPermissionsOnDbFiles();
    Tr("ConvertPermissionsOnDbFiles: %ld\n", Error );
    // ignore error and try best effort

    if( FALSE == SetCurrentDirectoryA(DatabasePath) ) {
        Error = GetLastError();
        if( ERROR_FILE_NOT_FOUND == Error ||
            ERROR_PATH_NOT_FOUND == Error ) {
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }

        return Error;
    }

    return NO_ERROR;
}

DWORD
CleanupDatabaseParameters(
    VOID
    )
{
    DWORD Error;
    
    Error = StartDhcpService();
    if( NO_ERROR != Error ) {
        Tr("StartDhcpService: %ld\n", Error );
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\precomp.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    precompiled header

--*/


//#pragma warning(disable : 4115 )
//#pragma warning(disable : 4214 )
//#pragma warning(disable : 4200 )
//#pragma warning(disable : 4213 )
//#pragma warning(disable : 4211 )
//#pragma warning(disable : 4310 )

//
//  NT public header files
//



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <shellapi.h>
#include <align.h>
#include <time.h>

//#pragma warning(disable : 4115 )
//#pragma warning(disable : 4214 )
//#pragma warning(disable : 4200 )
//#pragma warning(disable : 4213 )
//#pragma warning(disable : 4211 )
//#pragma warning(disable : 4310 )

#include <lmcons.h>
#include <netlib.h>
#include <lmapibuf.h>

#include <winsock2.h>
#include <excpt.h>
#include <accctrl.h>


//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>


//
// MM related files
//

#include    <mm\mm.h>
#include    <mm\array.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <winsock2.h>
#include    <dhcpupg.h>
#include    <esent.h>
#include    <dhcpmsg.h>
#include    <dhcplib.h>
#include    <dhcpexim.h>
#include    <dhcpapi.h>

//
// Constants
//

#define DHCPEXIM_REG_CFG_LOC5 TEXT("Software\\Microsoft\\DHCPServer\\Configuration")
#define DHCPEXIM_REG_CFG_LOC4 TEXT("System\\CurrentControlSet\\Services\\DHCPServer\\Configuration")

#define SAVE_BUF_SIZE (1004096L)

extern CHAR DhcpEximOemDatabaseName[2048];
extern CHAR DhcpEximOemDatabasePath[2048];
extern HANDLE hTextFile; // defined in dbfile.c
extern PUCHAR SaveBuf; // defined in dbfile.c
extern ULONG SaveBufSize; //defined in dbfile.c

enum {
    LoadJet200,
    LoadJet500,
    LoadJet97,  /* Win2K, ESENT */
    LoadJet2001 /* Whistler, ESENT */
};


typedef struct _MM_ITERATE_CTXT {
    //
    // This is filled in for all Iterate* routines
    //
    
    PM_SERVER Server;
    PVOID ExtraCtxt;

    //
    // This is filled in for IterateClasses
    //
    
    PM_CLASSDEF ClassDef;

    //
    // This is filled in for IterateOptDefs
    //

    PM_OPTDEF OptDef;


    //
    // This is filled in for IterateOptions 
    //

    PM_OPTION Option;

    //
    // These two are filled in by both IterateOptDefs and IterateOptions
    //
    
    PM_CLASSDEF UserClass; 
    PM_CLASSDEF VendorClass;
    
    //
    // This is used by IterateScopes
    //

    PM_SUBNET Scope;
    PM_SSCOPE SScope;

    //
    // This is used by IterateScopeRanges
    //

    PM_RANGE Range;

    //
    // This is used by IterateScopeExclusions
    //

    PM_EXCL Excl;

    //
    // This is used by IterateScopeReservations
    //

    PM_RESERVATION Res;
    
}MM_ITERATE_CTXT, *PMM_ITERATE_CTXT;

DWORD
IterateClasses(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateOptDefs(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateOptionsOnOptClass(
    IN PM_SERVER Server,
    IN PM_OPTCLASS OptClass,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateServerOptions(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopeOptions(
    IN PM_SUBNET Subnet,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateReservationOptions(
    IN PM_SERVER Server,
    IN PM_RESERVATION Res,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopes(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopeRanges(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopeExclusions(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopeReservations(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );


//
// readreg.c
//

DWORD
DhcpeximReadRegistryConfiguration(
    IN OUT PM_SERVER *Server
    );


DWORD
DhcpeximReadRegistryParameters(
    VOID
    );

//
// writereg.c
//

DWORD
DhcpeximWriteRegistryConfiguration(
    IN PM_SERVER Server
    );

//
// readdb.c
//

DWORD
DhcpeximReadDatabaseConfiguration(
    IN OUT PM_SERVER *Server
    );

//
// writedb.c
//

DWORD
DhcpeximWriteDatabaseConfiguration(
    IN PM_SERVER Server
    );

//
// dbfile.c
//

DWORD
AddRecordNoSize(
    IN LPSTR Buffer,
    IN ULONG BufSize
    );

DWORD
InitializeDatabaseParameters(
    VOID
    );

DWORD
CleanupDatabaseParameters(
    VOID
    );

DWORD
SaveDatabaseEntriesToFile(
    IN PULONG Subnets,
    IN ULONG nSubnets
    );

DWORD
SaveFileEntriesToDatabase(
    IN LPBYTE Mem,
    IN ULONG MemSize,
    IN PULONG Subnets,
    IN ULONG nSubnets
    );

DWORD
OpenTextFile(
    IN LPWSTR FileName,
    IN BOOL fRead,
    OUT HANDLE *hFile,
    OUT LPBYTE *Mem,
    OUT ULONG *MemSize
    );

VOID
CloseTextFile(
    IN OUT HANDLE hFile,
    IN OUT LPBYTE Mem
    );

//
// mmfile.c
//

DWORD
SaveConfigurationToFile(
    IN PM_SERVER Server
    );

DWORD
ReadDbEntries(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN OUT PM_SERVER *Server
    );

//
// merge.c
//

DWORD
MergeConfigurations(
    IN OUT PM_SERVER DestServer,
    IN OUT PM_SERVER Server
    );

//
// main.c
//

DWORD
Tr(
    IN LPSTR Format, ...
    );

BOOL IsNT4();
BOOL IsNT5(); 

VOID
IpAddressToStringW(
    IN DWORD IpAddress,
    IN LPWSTR String // must have enough space preallocated
    );

DWORD
CmdLineDoExport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    );

DWORD
CmdLineDoImport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    );

DWORD
ImportConfiguration(
    IN OUT PM_SERVER SvcConfig,
    IN ULONG *Subnets,
    IN ULONG nSubnets,
    IN LPBYTE Mem, // import file : shared mem
    IN ULONG MemSize // shared mem size
    );

DWORD
ExportConfiguration(
    IN OUT PM_SERVER SvcConfig,
    IN ULONG *Subnets,
    IN ULONG nSubnets,
    IN HANDLE hFile
    );

DWORD
CleanupServiceConfig(
    IN OUT PM_SERVER Server
    );

DWORD
InitializeAndGetServiceConfig(
    OUT PM_SERVER *pServer
    );

//
// select.c
//

DWORD
SelectConfiguration(
    IN OUT PM_SERVER Server,
    IN ULONG *Subnets,
    IN ULONG nSubnets
    );

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\convert.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    convert.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service.

Author:

    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

    Madan Appiah (madana) 21-Oct-1992

--*/

#include <precomp.h>
#include <winnls.h>


#undef DhcpFreeMemory
#undef DhcpAllocateMemory

VOID
DhcpFreeMemory(
    PVOID Mem
    )
{
    LocalFree( Mem );
}

PVOID
DhcpAllocateMemory(
    IN ULONG Size
    )
{
    return LocalAlloc( LPTR, Size );
}

    

LPWSTR
DhcpOemToUnicodeN(
    IN      LPSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    )
{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        cChars * sizeof( WCHAR );

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            DhcpAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            DhcpFreeMemory( UnicodeString.Buffer );
        }
        return NULL;
    }

    return UnicodeString.Buffer;

}


LPWSTR
DhcpOemToUnicode(
    IN      LPSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
/*++

Routine Description:

    Convert an OEM (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.

    Unicode - Specifies the pointer to the unicode buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/
{
    OEM_STRING  AnsiString;

    RtlInitString( &AnsiString, Ansi );

    return DhcpOemToUnicodeN(
                Ansi,
                Unicode,
                (USHORT) RtlOemStringToUnicodeSize( &AnsiString )
                );
}


ULONG
DhcpUnicodeToOemSize(
    IN LPWSTR Unicode
    )
/*++

Routine Description:

    This routine returns the number of bytes requried
    to store the OEM string equivalent of the provided
    UNICODE string.

Arguments:

    Unicode -- the input unicode string.

Return Values:

    0 -- if the string cannot be converted or is NULL
    number of bytes of storage required

--*/
{
    UNICODE_STRING UnicodeString;

    if( NULL == Unicode ) return 0;
    
    RtlInitUnicodeString( &UnicodeString, Unicode );
    return (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );
}

    

LPSTR
DhcpUnicodeToOem(
    IN LPWSTR Unicode,
    IN LPSTR Ansi
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding OEM
    string.

Arguments:

    Ansi - Specifies the UNICODE zero terminated string to convert.

    Ansi - Specifies the pointer to the oem buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated OEM string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/

{
    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    if( Ansi == NULL ) {
        AnsiString.Buffer = DhcpAllocateMemory( AnsiString.MaximumLength
    ); }
    else {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToOemString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            DhcpFreeMemory( AnsiString.Buffer );
        }

        return NULL;
    }

    return AnsiString.Buffer;
}

DWORD
ConvertUnicodeToUTF8(
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength,
    LPBYTE  UTF8String,
    DWORD   UTF8Length
    )
/*++

Routine Description:

    This functions converts Unicodestring into Utf8 format.
    The unicodestring must be NULL terminated.

Arguments:

    Unicodestring - Pointer to the unicodestring

    UnicodeLength - Length of above string, or pass -1 if the above string is
                    NULL terminated.

    UTF8String - Buffer to receive UTF8String. If this is null then the function
                    returns the # of bytes needed for this buffer for conversion.

    UTF8Length - Length of the above buffer. if this is 0, the function
                will return the required length.

Return Value:

    No. of bytes converted.

--*/
{
    DWORD   Result;
    Result = WideCharToMultiByte(
                CP_UTF8,
                0,
                UnicodeString,
                UnicodeLength,
                UTF8String,
                UTF8Length,
                NULL,
                NULL
                );
    if (Result == 0 ) {
        ASSERT(FALSE);
    }
    return Result;
}

DWORD
ConvertUTF8ToUnicode(
    LPBYTE  UTF8String,
    DWORD   UTF8Length,
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength
    )
/*++

Routine Description:

    This functions converts Unicodestring into Utf8 format.
    The unicodestring must be NULL terminated.

Arguments:

    UTF8String - Buffer to UTFString.

    UTF8Length - Length of above buffer ; or pass -1 if the above string is NULL terminated.

    Unicodestring - Pointer to the buffer receiving unicodestring.

    UnicodeLength - Length of the above buffer. if this is 0, the function
                will return the required length.

Return Value:

    No. of bytes converted.

--*/
{
    DWORD Result;
    Result = MultiByteToWideChar(
                CP_UTF8,
                0,
                UTF8String,
                UTF8Length,
                UnicodeString,
                UnicodeLength
                );
    if (Result == 0 ) {
        ASSERT(FALSE);
    }
    return Result;

}


VOID
DhcpHexToString(
    LPWSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to a Unicode
    string.  The string is not NULL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.


Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length * 2; i+=2 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + L'0';
        } else {
            Buffer[i+1] = j + L'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        HexNumber++;
    }

    return;
}


VOID
DhcpHexToAscii(
    LPSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to an ASCII
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.

Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length; i+=1 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + '0';
        } else {
            Buffer[i+1] = j + 'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + '0';
        } else {
            Buffer[i] = j + 'A' - 10;
        }

        HexNumber++;
    }

    return;
}


VOID
DhcpDecimalToString(
    LPWSTR Buffer,
    BYTE Number
    )
/*++

Routine Description:

    This functions converts a single byte decimal digit to a 3 character
    Unicode string.  The string not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least 3 characters in size.

    Number - The number to convert.

Return Value:

    None.

--*/
{
    Buffer[2] = Number % 10 + L'0';
    Number /= 10;

    Buffer[1] = Number % 10 + L'0';
    Number /= 10;

    Buffer[0] = Number + L'0';

    return;
}


DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    )
/*++

Routine Description:

    This functions converts a dotted decimal form ASCII string to a
    Host order IP address.

Arguments:

    String - The address to convert.

Return Value:

    The corresponding IP address.

--*/
{
    struct in_addr addr;

    addr.s_addr = inet_addr( String );
    return( ntohl(*(LPDWORD)&addr) );
}


LPSTR
DhcpIpAddressToDottedString(
    DWORD IpAddress
    )
/*++

Routine Description:

    This functions converts a Host order IP address to a dotted decimal
    form ASCII string.

Arguments:

    IpAddress - Host order IP Address.

Return Value:

    String for IP Address.

--*/
{
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);
    return(inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress));
}


DWORD
DhcpStringToHwAddress(
    LPSTR AddressBuffer,
    LPSTR AddressString
    )
/*++

Routine Description:

    This functions converts an ASCII string to a hex number.

Arguments:

    AddressBuffer - A pointer to a buffer which will contain the hex number.

    AddressString - The string to convert.

Return Value:

    The number of bytes written to AddressBuffer.

--*/
{
    int i = 0;
    char c1, c2;
    int value1, value2;

    while ( *AddressString != 0) {

        c1 = (char)toupper(*AddressString);

        if ( isdigit(c1) ) {
            value1 = c1 - '0';
        } else if ( c1 >= 'A' && c1 <= 'F' ) {
            value1 = c1 - 'A' + 10;
        }
        else {
            break;
        }

        c2 = (char)toupper(*(AddressString+1));

        if ( isdigit(c2) ) {
            value2 = c2 - '0';
        } else if ( c2 >= 'A' && c2 <= 'F' ) {
            value2 = c2 - 'A' + 10;
        }
        else {
            break;
        }

        AddressBuffer [i] = value1 * 16 + value2;
        AddressString += 2;
        i++;
    }

    return( i );
}


#if 0


DHCP_IP_ADDRESS
DhcpHostOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    )
/*++

Routine Description:

    This functions converts a network order IP address to host order.

Arguments:

    NetworkOrderAddress - A network order IP address.

Return Value:

    The host order IP address.

--*/
{
    return( ntohl( NetworkOrderAddress ) );
}


DHCP_IP_ADDRESS
DhcpNetworkOrder(
    DHCP_IP_ADDRESS HostOrderAddress
    )
/*++

Routine Description:

    This functions converts a network order IP address to host order.

Arguments:

    HostOrderAddress - A host order IP address.

Return Value:

    The network order IP address.

--*/
{
    return( htonl( HostOrderAddress ) );
}


VOID
DhcpIpAddressToString(
    LPWSTR Buffer,
    DWORD IpAddress
    )
/*++

Routine Description:

    This function converts an IP address from host order ASCII form.

Arguments:

    Buffer - Points to a buffer to the receive the ASCII form.  The
        buffer must be at least 8 WCHARs long.

    IpAddress - The IP address to convert.

Return Value:

    Nothing.

--*/
{
    int i;
    int j;

    for (i = 7; i >= 0; i-- ) {
        j = IpAddress & 0xF;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        IpAddress >>=4;
    }

    return;
}



VOID
DhcpStringToIpAddress(
    LPSTR Buffer,
    LPDHCP_IP_ADDRESS IpAddress,
    BOOL NetOrder
    )
/*++

Routine Description:

    This function converts an ASCII string IP Address to binary format.

Arguments:

    Buffer - Pointer to buffer containing the IP address.

    IpAddress - Points to a buffer to contain the binary format IP address.

    NetOrder - If TRUE, the address is converted to a network order address.
               If FALSE, the address is converted to a host order address.

Return Value:

    None.

--*/
{
    DWORD value;

    value = strtol( Buffer, NULL, 16 );

    if ( NetOrder ) {
        *IpAddress = htonl( value );
    } else {
        *IpAddress = value;
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\main.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   main.c

Abstract:

   main module
   
--*/

#include <precomp.h>
#include <dhcpexim.h>

BOOL GlobalIsNT4, GlobalIsNT5;
WCHAR CurrentDir[MAX_PATH*2];

CRITICAL_SECTION DhcpGlobalMemoryCritSect;
CRITICAL_SECTION DhcpGlobalInProgressCritSect;
CHAR DhcpEximOemDatabaseName[2048];
CHAR DhcpEximOemDatabasePath[2048];
HANDLE hLog;

BOOL IsNT4( VOID ) {
    return GlobalIsNT4;
}

BOOL IsNT5( VOID ) {
    return GlobalIsNT5;
}

#define MAX_PRINTF_LEN 4096
char OutputBuf[MAX_PRINTF_LEN];

VOID
StartDebugLog(
    VOID
    )
{
    CHAR Buffer[MAX_PATH*2];

    if( NULL != hLog ) return;
    
    if( 0 == GetWindowsDirectoryA( Buffer, MAX_PATH )) {
        ZeroMemory(Buffer, sizeof(Buffer));
    }

    if( Buffer[strlen(Buffer)-1] != '\\' ) {
        strcat(Buffer, "\\");
    }
    strcat(Buffer, "dhcpexim.log");
    
    hLog = CreateFileA(
        Buffer, GENERIC_WRITE,
        FILE_SHARE_READ, NULL, OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL );

    if( hLog == INVALID_HANDLE_VALUE) {
        hLog = NULL;
    }

    if(GetLastError() == ERROR_ALREADY_EXISTS) {
        //
        // Appending to existing file
        //

        SetFilePointer(hLog,0,NULL,FILE_END);
    }
}

VOID
CloseDebugLog(
    VOID
    )
{
    if( hLog ) {
        CloseHandle( hLog );
        hLog = NULL;
    }
}

DWORD
Tr(
    IN LPSTR Format,
    ...
    )
{
    va_list ArgList;
    ULONG Length;

    strcpy(OutputBuf, "[DHCP] ");
    Length = strlen(OutputBuf);

    va_start(ArgList, Format);
    Length = vsprintf(&OutputBuf[Length], Format, ArgList );
    va_end(ArgList);

#if DBG
    DbgPrint( (PCH)OutputBuf );
#endif
    
    if( hLog ) {
        DWORD Size = strlen(OutputBuf);
        WriteFile(
            hLog, OutputBuf, Size, &Size, NULL );
    }

    return NO_ERROR;
}

BOOL
IsPostW2k(
    VOID
    )
{
    HKEY hKey;
    DWORD Error, Type, Value, Size;


    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    if( NO_ERROR != Error ) return FALSE;

    Type = REG_DWORD; Value = 0; Size = sizeof(Value);
    Error = RegQueryValueEx(
        hKey, TEXT("Version"), NULL, &Type, (PVOID)&Value, &Size );

    RegCloseKey( hKey );

    //
    // if this value is not present, then upgrade is needed
    //

    return (Error == NO_ERROR );
}

DWORD
ReconcileLocalService(
    IN PULONG Subnets,
    IN DWORD nSubnets OPTIONAL
    )
/*++

Routine Description:

    This routine reconciles the specified scopes.
    This is needed after importing as the import doesnt
    actually get the bitmask, but only the database entries.

--*/
{
    DWORD Error, FinalError, nRead, nTotal, i;
    DHCP_RESUME_HANDLE Resume = 0;
    LPDHCP_IP_ARRAY IpArray;
    
    if( 0 == nSubnets ) {
        IpArray = NULL;
        Error = DhcpEnumSubnets(
            L"127.0.0.1", &Resume, (ULONG)(-1), &IpArray, &nRead,
            &nTotal );
        if( NO_ERROR != Error ) {
            Tr("DhcpEnumSubnets: %ld\n", Error);
            return Error;
        }

        if( 0 == nRead || 0 == nTotal || IpArray->NumElements == 0 ) {
            Tr("DhcpEnumSubnets returned none." );
            return NO_ERROR;
        }

        Error = ReconcileLocalService(
            IpArray->Elements, IpArray->NumElements );

        DhcpRpcFreeMemory( IpArray );

        return Error;
    }

    //
    // Reconcile each of the specified scopes
    //

    FinalError = NO_ERROR;
    for( i = 0; i < nSubnets ; i ++ ) {
        LPDHCP_SCAN_LIST ScanList = NULL;
        
        Error = DhcpScanDatabase(
            L"127.0.0.1", Subnets[i], TRUE, &ScanList);

        if( NULL != ScanList ) DhcpRpcFreeMemory( ScanList );

        if( NO_ERROR != Error ) {
            Tr("DhcpScanDatabase(0x%lx): %ld\n", Subnets[i], Error);
            FinalError = Error;
        }
    }

    return FinalError;
}
    
DWORD
InitializeAndGetServiceConfig(
    OUT PM_SERVER *pServer
    )
/*++

Routine Description:

    This routine initializes all the modules and obtains the
    configuration for the service

--*/
{
    DWORD Error;
    OSVERSIONINFO Ver;
    extern DWORD  ClassIdRunningCount; // defined in mm\classdefl.c

    //
    // Initialize globals
    //
    
    GlobalIsNT4 = FALSE;
    GlobalIsNT5 = FALSE;
        
    try {
        InitializeCriticalSection( &DhcpGlobalMemoryCritSect );
        InitializeCriticalSection( &DhcpGlobalInProgressCritSect );
    }except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Error = GetLastError( );
        return Error;
    }

    ClassIdRunningCount = 0x1000;
    
    //
    // Other initialization
    //
    
    Error = NO_ERROR;
    Ver.dwOSVersionInfoSize = sizeof(Ver);
    if( FALSE == GetVersionEx(&Ver) ) return GetLastError();
    if( Ver.dwMajorVersion == 4 ) GlobalIsNT4 = TRUE;
    else if( Ver.dwMajorVersion == 5 ) GlobalIsNT5 = TRUE;
    else if( Ver.dwMajorVersion < 4 ) return ERROR_NOT_SUPPORTED;

    if( GlobalIsNT5 && IsPostW2k() ) GlobalIsNT5 = FALSE;

#if DBG
    DbgPrint("Is NT4: %s, Is NT5: %s\n",
             GlobalIsNT4 ? "yes" : "no",
             GlobalIsNT5 ? "yes" : "no" );
    
    StartDebugLog();
#endif 
    
    //
    //
    //
    SaveBufSize = 0;
    SaveBuf = LocalAlloc( LPTR, SAVE_BUF_SIZE );
    if( NULL == SaveBuf ) {
        return GetLastError();
    }
    
    
    Error = GetCurrentDirectoryW(
        sizeof(CurrentDir)/sizeof(WCHAR), CurrentDir );
    if( 0 != Error ) {
        Error = NO_ERROR;
    } else {
        Error = GetLastError();
        Tr("GetCurrentDirectoryW: %ld\n", Error );
        return Error;
    }


    //
    // Set right permissions on the db directory etc..
    //

    Error = InitializeDatabaseParameters();
    if( NO_ERROR != Error ) {
        Tr("InitializeDatabaseParameters: %ld\n", Error );
        return Error;
    }
    
    //
    // Now obtain the configuration
    //

    if( !GlobalIsNT4 && !GlobalIsNT5 ) {
        //
        // Whistler configuration should be read from the
        // database.. 
        //

        Error = DhcpeximReadDatabaseConfiguration(pServer);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximReadDatabaseConfiguration: %ld\n", Error );
        }
    } else {

        //
        // NT4 or W2K configuration should be read from registry..
        //
        
        Error = DhcpeximReadRegistryConfiguration(pServer);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximReadRegistryConfiguration: %ld\n", Error );
        }
    }

    return Error;
}

DWORD
CleanupServiceConfig(
    IN OUT PM_SERVER Server
    )
{
    DWORD Error;

    if( NULL != SaveBuf ) LocalFree(SaveBuf);
    SaveBuf = NULL;
    SaveBufSize = 0;
    
    if( NULL != Server ) MemServerFree(Server);
    Error =  CleanupDatabaseParameters();
    if( NO_ERROR != Error ) {
        Tr("CleanupServiceConfig: %ld\n", Error );
    }

    if( FALSE == SetCurrentDirectoryW(CurrentDir) ) {
        if( NO_ERROR == Error ) Error = GetLastError();
        Tr("SetCurrentDirectoryW: %ld\n", GetLastError());
    }

    CloseDebugLog();

    DeleteCriticalSection( &DhcpGlobalMemoryCritSect );
    DeleteCriticalSection( &DhcpGlobalInProgressCritSect );

    return Error;
}

DWORD
ExportConfiguration(
    IN OUT PM_SERVER SvcConfig,
    IN ULONG *Subnets,
    IN ULONG nSubnets,
    IN HANDLE hFile
    )
/*++
    
Routine Description:

    This routine attempts to save the service configuration to a
    file after selecting the required subnets.  

--*/
{
    DWORD Error;

    //
    // First select the required subnets and get this
    // configuration alone.
    //

    Error = SelectConfiguration( SvcConfig, Subnets, nSubnets );
    if( NO_ERROR != Error ) return Error;

    //
    // Save the configuration to the specified file handle
    //
    
    hTextFile = hFile;
    Error = SaveConfigurationToFile(SvcConfig);
    if( NO_ERROR != Error ) return Error;

    //
    // Now try to save the database entries to file
    //

    Error = SaveDatabaseEntriesToFile(Subnets, nSubnets);
    if( NO_ERROR != Error ) return Error;

    Tr("ExportConfiguration succeeded\n");
    return NO_ERROR;
}

DWORD
ImportConfiguration(
    IN OUT PM_SERVER SvcConfig,
    IN ULONG *Subnets,
    IN ULONG nSubnets,
    IN LPBYTE Mem, // import file : shared mem
    IN ULONG MemSize // shared mem size
    )
{
    DWORD Error;
    PM_SERVER Server;
    
    //
    // First obtain the configuration from the file
    //
    
    Error = ReadDbEntries( &Mem, &MemSize, &Server );
    if( NO_ERROR != Error ) {
        Tr("ReadDbEntries: %ld\n", Error );
        return Error;
    }

    //
    // Select the configuration required
    //

    Error = SelectConfiguration( Server, Subnets, nSubnets );
    if( NO_ERROR != Error ) return Error;

    //
    // Merge the configuration along with the svc configuration
    //
    Error = MergeConfigurations( SvcConfig, Server );
    if( NO_ERROR != Error ) {
        Tr("MergeConfigurations: %ld\n", Error );
    }

    MemServerFree( Server );

    if( NO_ERROR != Error ) return Error;

    //
    // Now save the new configuration to registry/disk
    //
    if( !GlobalIsNT5 && !GlobalIsNT4 ) {
        //
        // Whistler has config in database
        //
        Error = DhcpeximWriteDatabaseConfiguration(SvcConfig);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximWriteDatabaseConfiguration: %ld\n", Error );
        }
    } else {
        Error = DhcpeximWriteRegistryConfiguration(SvcConfig);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximWriteRegistryConfiguration: %ld\n", Error );
        }
    }

    if( NO_ERROR != Error ) return Error;

    //
    // Now read the database entries from file and stash them
    // into the db.
    // 

    Error = SaveFileEntriesToDatabase(
        Mem, MemSize, Subnets, nSubnets );
    if( NO_ERROR != Error ) {
        Tr("SaveFileEntriesToDatabase: %ld\n", Error );
    }

    return Error;
}

VOID
IpAddressToStringW(
    IN DWORD IpAddress,
    IN LPWSTR String // must have enough space preallocated
    )
{
   PUCHAR pAddress;
   ULONG Size;

   pAddress = (PUCHAR)&IpAddress;
   wsprintf(String, L"%ld.%ld.%ld.%ld",
            pAddress[3], pAddress[2], pAddress[1], pAddress[0] );
}

DWORD
StringToIpAddressW(
    LPWSTR pwszString
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = 0;
    LPSTR pszString = NULL;
    if( pwszString == NULL )
        return dwRes;

    pszString = DhcpUnicodeToOem(pwszString, NULL);
    if( pszString )
    {
        dwRes = DhcpDottedStringToIpAddress(pszString);
    }

    return dwRes;
}
        
DWORD
CmdLineDoImport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    )
{
    //
    // Syntax: Import <filename> <ALL/subnets>
    //
    LPWSTR FileName;
    ULONG Subnets[1024],*pSubnets, nSubnets, MemSize, Error;
    HANDLE hFile;
    LPBYTE Mem;
    PM_SERVER SvcConfig, FileConfig;
    
    if( nArgs == 1 ) return ERROR_BAD_ARGUMENTS;

    FileName = Args[0]; Args ++ ; nArgs --;

    //
    // First open the file 
    //

    Error = OpenTextFile(
        FileName, TRUE, &hFile, &Mem, &MemSize );
    if( NO_ERROR != Error ) {
        Tr("OpenTextFileForRead: %ld\n", Error );
        return Error;
    }

    //
    // Now try to parse the rest of the arguments to see if they
    // are all ok
    //

    if( _wcsicmp(Args[0],L"ALL") == 0 ) {
        nSubnets = 0; pSubnets = NULL;
    } else {
        pSubnets = Subnets;
        nSubnets = 0;
        while( nArgs -- ) {
            pSubnets[nSubnets++] = StringToIpAddressW(*Args++);
            if( pSubnets[nSubnets-1] == INADDR_ANY ||
                pSubnets[nSubnets-1] == INADDR_NONE ) {
                Error = ERROR_BAD_ARGUMENTS;
                goto Cleanup;
            }
        }
    }

    //
    // Initialize parameters
    //

    Error = InitializeAndGetServiceConfig( &SvcConfig );
    if( NO_ERROR != Error ) {
        Tr("InitializeAndGetServiceConfig: %ld\n", Error );
        goto Cleanup;
    }

    Error = ImportConfiguration(
        SvcConfig, pSubnets, nSubnets, Mem, MemSize );
    if( NO_ERROR != Error ) {
        Tr("ImportConfiguration: %ld\n", Error );
    }
    
    //
    // Finally cleanup
    //

    CleanupServiceConfig(SvcConfig);

    //
    // Also reconcile local server
    //

    ReconcileLocalService(pSubnets, nSubnets);
    
 Cleanup:

    CloseTextFile( hFile, Mem );
    return Error;
}

    
DWORD
CmdLineDoExport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    )
{
    //
    // Syntax: Import <filename> <ALL/subnets>
    //
    LPWSTR FileName;
    ULONG Subnets[1024],*pSubnets, nSubnets, MemSize, Error;
    HANDLE hFile;
    LPBYTE Mem;
    PM_SERVER SvcConfig, FileConfig;
    
    if( nArgs == 1 ) return ERROR_BAD_ARGUMENTS;

    FileName = Args[0]; Args ++ ; nArgs --;

    //
    // First open the file 
    //

    Error = OpenTextFile(
        FileName, FALSE, &hFile, &Mem, &MemSize );
    if( NO_ERROR != Error ) {
        Tr("OpenTextFileForRead: %ld\n", Error );
        return Error;
    }

    //
    // Now try to parse the rest of the arguments to see if they
    // are all ok
    //

    if( _wcsicmp(Args[0],L"ALL") == 0 ) {
        nSubnets = 0; pSubnets = NULL;
    } else {
        pSubnets = Subnets;
        nSubnets = 0;
        while( nArgs -- ) {
            pSubnets[nSubnets++] = StringToIpAddressW(*Args++);
            if( pSubnets[nSubnets-1] == INADDR_ANY ||
                pSubnets[nSubnets-1] == INADDR_NONE ) {
                Error = ERROR_BAD_ARGUMENTS;
                goto Cleanup;
            }
        }
    }

    //
    // Initialize parameters
    //

    Error = InitializeAndGetServiceConfig( &SvcConfig );
    if( NO_ERROR != Error ) {
        Tr("InitializeAndGetServiceConfig: %ld\n", Error );
        goto Cleanup;
    }

    //
    //  Export configuration
    //

    Error = ExportConfiguration(
        SvcConfig, pSubnets, nSubnets, hFile );
    if( NO_ERROR != Error ) {
        Tr("ExportConfiguration: %ld\n", Error );
    }
    
    //
    // Finally cleanup
    //

    CleanupServiceConfig(SvcConfig);
    
 Cleanup:

    CloseTextFile( hFile, Mem );
    return Error;
}

PM_SERVER
DhcpGetCurrentServer(
    VOID
)
{
    ASSERT( FALSE );
    //
    // This is there only to let teh compiler compile without
    // having to include dhcpssvc.lib.  This routine should never
    // be called at all
    //
    return NULL;
}

BOOL
SubnetMatches(
    IN DWORD IpAddress,
    IN ULONG *Subnets,
    IN ULONG nSubnets
    )
{
    if( 0 == nSubnets || NULL == Subnets ) return TRUE;
    while( nSubnets -- ) {
        if( IpAddress == *Subnets ++) return TRUE;
    }

    return FALSE;
}
    
VOID
DisableLocalScopes(
    IN ULONG *Subnets,
    IN ULONG nSubnets
    )
{
    DWORD Error;
    PM_SERVER SvcConfig;
    ARRAY_LOCATION Loc;
    PM_SUBNET Subnet;
    
    Error = InitializeAndGetServiceConfig(&SvcConfig);
    if( NO_ERROR != Error ) {
        Tr("DisableLocalScopes: Init: %ld\n", Error );
        return;
    }

    Error = MemArrayInitLoc(&SvcConfig->Subnets, &Loc);
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &SvcConfig->Subnets, &Loc, &Subnet);
        ASSERT( NO_ERROR == Error && NULL != Subnet );

        //
        // Disable the subnet
        //

        if( SubnetMatches(Subnet->Address, Subnets, nSubnets ) ) {
            Subnet->State = DISABLED(Subnet->State);
        }

        Error = MemArrayNextLoc(
            &SvcConfig->Subnets, &Loc);
    }

    //
    // Now save the new configuration to registry/disk
    //

    if( !GlobalIsNT5 && !GlobalIsNT4 ) {
        //
        // Whistler has config in database
        //
        Error = DhcpeximWriteDatabaseConfiguration(SvcConfig);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximWriteDatabaseConfiguration: %ld\n", Error );
        }
    } else {
        Error = DhcpeximWriteRegistryConfiguration(SvcConfig);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximWriteRegistryConfiguration: %ld\n", Error );
        }
    }

    CleanupServiceConfig(SvcConfig);
}


LPWSTR
MakeName(
    IN DWORD IpAddress,
    IN LPWSTR Name
    )
{
    static WCHAR Buffer[40];
    PUCHAR pAddress;
    LPWSTR RetVal;
    ULONG Size;
    
    pAddress = (PUCHAR)&IpAddress;
    wsprintf(Buffer, L"[%d.%d.%d.%d]  ", pAddress[3], pAddress[2],
            pAddress[1], pAddress[0] );

    Size = wcslen(Buffer)+1;
    if( NULL != Name ) Size += wcslen(Name);

    RetVal = LocalAlloc( LPTR, Size * sizeof(WCHAR));
    if( NULL == RetVal ) return NULL;

    wcscpy(RetVal, Buffer);
    if( NULL != Name ) wcscat(RetVal, Name );
    
    return RetVal;
}    
DWORD
InitializeCtxt(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN PM_SERVER Server
    )
{
    DWORD Error,i, Size;
    ARRAY_LOCATION Loc;
    PM_SUBNET Subnet;
    
    //
    // First find the # of subnets and allocate array
    //
    Ctxt->nScopes = i = MemArraySize(&Server->Subnets);
    Ctxt->Scopes = LocalAlloc(LPTR,  i * sizeof(Ctxt->Scopes[0]) );
    if( NULL == Ctxt->Scopes ) {
        Ctxt->nScopes = 0;
        return GetLastError();
    }

    //
    // Walk through the array and setup each element
    //

    i = 0;
    Error = MemArrayInitLoc( &Server->Subnets, &Loc );
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(&Server->Subnets, &Loc, &Subnet );
        ASSERT(NO_ERROR == Error );

        Ctxt->Scopes[i].SubnetAddress = Subnet->Address;
        Ctxt->Scopes[i].SubnetName = MakeName(Subnet->Address, Subnet->Name);
        if( NULL == Ctxt->Scopes[i].SubnetName ) return GetLastError();

        i ++;
        Error = MemArrayNextLoc(&Server->Subnets, &Loc );
    }

    return NO_ERROR;
}
    
DWORD
DhcpEximInitializeContext(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN LPWSTR FileName,
    IN BOOL fExport
    )
{
    DWORD Error;
    LPVOID Mem;
    
    ZeroMemory(Ctxt, sizeof(*Ctxt));

    //
    // First set the FileName and fExport fields
    //
    Ctxt->FileName = FileName;
    Ctxt->fExport = fExport;

    //
    // Next open the file.
    //
    Error = OpenTextFile(
        FileName, !fExport, &Ctxt->hFile, &Ctxt->Mem,
        &Ctxt->MemSize );
    if( NO_ERROR != Error ) {
        Tr("OpenTextFileForRead:%ld\n", Error );
        return Error;
    }

    //
    // Initialize parameters and obtain config
    //

    Error = InitializeAndGetServiceConfig(
        (PM_SERVER*)&Ctxt->SvcConfig);
    if( NO_ERROR != Error ) {
        Tr("InitializeAndGetServiceConfig: %ld\n", Error );

        CloseTextFile(Ctxt->hFile, Ctxt->Mem);
        return Error;
    }

    do {
        //
        // If this is an import, the configuration from the file
        // should also be read.
        //
        
        if( !fExport ) {

            Error = ReadDbEntries(
                &Ctxt->Mem, &Ctxt->MemSize,
                (PM_SERVER*)&Ctxt->FileConfig );
            if( NO_ERROR != Error ) {
                Tr("ReadDbEntries: %ld\n", Error );

                break;
            }
        }
        
        //
        // Allocate and initialize the Ctxt data structures with the
        // service scopes info in case of EXPORT
        //
        
        Error = InitializeCtxt(
            Ctxt, fExport ? Ctxt->SvcConfig : Ctxt->FileConfig );
        
        if( NO_ERROR != Error ) {
            Tr("InitializeCtxt: %ld\n", Error );

            break;
        }
    } while( 0 );

    if( NO_ERROR != Error ) {

        CleanupServiceConfig( Ctxt->SvcConfig );
        if( NULL != Ctxt->FileConfig ) {
            MemServerFree( (PM_SERVER)Ctxt->FileConfig );
        }
        CloseTextFile( Ctxt->hFile, Ctxt->Mem );
    }

    return Error;
}

DWORD
CalculateSubnets(
    IN PDHCPEXIM_CONTEXT Ctxt,
    OUT PULONG *Subnets,
    OUT ULONG *nSubnets
    )
{
    DWORD Error, i;
    PULONG pSubnets;
    
    //
    // First check if there is atleast one unselected subnet
    //
    (*nSubnets) = 0;
    
    for( i = 0; i < Ctxt->nScopes; i ++ ) {
        if( Ctxt->Scopes[i].fSelected ) (*nSubnets) ++;
    }

    //
    // Special case if all subnets are selected
    //
                                          
    if( *nSubnets == Ctxt->nScopes ) {
        *nSubnets = 0;
        *Subnets = NULL;
        return NO_ERROR;
    }

    //
    // Allocate memory
    //

    *Subnets = LocalAlloc( LPTR, sizeof(DWORD)* (*nSubnets));
    if( NULL == *Subnets ) return GetLastError();

    //
    // Copy the subnets
    //

    (*nSubnets) = 0;
    for( i = 0; i < Ctxt->nScopes; i ++ ) {
        if( Ctxt->Scopes[i].fSelected ) {
            (*Subnets)[(*nSubnets)++] = Ctxt->Scopes[i].SubnetAddress;
        }
    }

    return NO_ERROR;
}

DWORD
DhcpEximCleanupContext(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN BOOL fAbort
    )
{
    DWORD Error, i;
    DWORD *Subnets, nSubnets;
    
    Error = NO_ERROR;
    Subnets = NULL;
    nSubnets = 0;
    
    //
    // If not aborting, attempt to execute the operation
    //
    if( !fAbort ) do {
        Error = CalculateSubnets( Ctxt, &Subnets, &nSubnets );
        if( NO_ERROR != Error ) {
            Tr("CalculateSubnets: %ld\n", Error );
            break;
        }

        if( Ctxt->fExport ) {
            // 
            // Export the specified subnets out
            //

            Error = SelectConfiguration(
                Ctxt->SvcConfig, Subnets, nSubnets );
            
            if( NO_ERROR != Error ) {
                Tr("SelectConfiguration: %ld\n", Error );
                break;
            }
            
            Error = SaveConfigurationToFile( Ctxt->SvcConfig);
            if( NO_ERROR != Error ) {
                Tr("SaveConfigurationToFile: %ld\n", Error );
                break;
            }

            //
            // Now try to save the database entries to file
            //
            
            Error = SaveDatabaseEntriesToFile(Subnets, nSubnets);
            if( NO_ERROR != Error ) {
                Tr("SaveDatabaseEntriesToFile: %ld\n", Error );
            }

            break;
        } 

        //
        // Import the specified subnets in
        //
        
        Error = SelectConfiguration(
            Ctxt->FileConfig, Subnets, nSubnets );
        
        if( NO_ERROR != Error ) {
            Tr("SelectConfiguration: %ld\n", Error );
            break;
        }
        
        Error = MergeConfigurations(
            Ctxt->SvcConfig, Ctxt->FileConfig );
        
        if( NO_ERROR != Error ) {
            Tr("MergeConfigurations: %ld\n", Error );
            break;
        } 
        
        
        //
        // Now save the new configuration to registry/disk
        //
        if( !GlobalIsNT5 && !GlobalIsNT4 ) {
            //
            // Whistler has config in database
            //
            Error = DhcpeximWriteDatabaseConfiguration(Ctxt->SvcConfig);
            if( NO_ERROR != Error ) {
                Tr("DhcpeximWriteDatabaseConfiguration: %ld\n", Error );
            }
        } else {
            Error = DhcpeximWriteRegistryConfiguration(Ctxt->SvcConfig);
            if( NO_ERROR != Error ) {
                Tr("DhcpeximWriteRegistryConfiguration: %ld\n", Error );
            }
        }
        
        if( NO_ERROR != Error ) break;
        
        //
        // Now read the database entries from file and stash them
        // into the db.
        // 
            
        Error = SaveFileEntriesToDatabase(
            Ctxt->Mem, Ctxt->MemSize, Subnets, nSubnets );
        if( NO_ERROR != Error ) {
            Tr("SaveFileEntriesToDatabase: %ld\n", Error );
        }
        
    } while( 0 );
        

    //
    // Cleanup
    //

    if( NULL != Ctxt->SvcConfig ) {
        CleanupServiceConfig( Ctxt->SvcConfig );
    }

    if( NULL != Ctxt->FileConfig ) {
        MemServerFree( (PM_SERVER)Ctxt->FileConfig );
    }

    if( !fAbort  && Ctxt->fExport == FALSE ) {
        //
        // Also reconcile local server
        //
        
        ReconcileLocalService( Subnets, nSubnets );
    }        

    CloseTextFile( Ctxt->hFile, Ctxt->Mem );

    //
    // Walk through the array and free up pointers
    //

    for( i = 0 ; i < Ctxt->nScopes ; i ++ ) {
        if( Ctxt->Scopes[i].SubnetName ) {
            LocalFree( Ctxt->Scopes[i].SubnetName );
        }
    }
    if( Ctxt->Scopes ) LocalFree( Ctxt->Scopes );
    Ctxt->Scopes = NULL; Ctxt->nScopes = 0;

    if( !fAbort && Ctxt->fExport && Ctxt->fDisableExportedScopes  ) {
        //
        // Fix the local scopes to all be disabled
        //

        DisableLocalScopes(Subnets, nSubnets);
    }

    if( NULL != Subnets && 0 != nSubnets ) {
        LocalFree( Subnets );
    }
    return Error;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\test.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

   test.c

Abstract:

    helps test the import and export functionality.
    usage: test import filename  { ALL or <scope_address> <scope_address> .. }
           test export filename  { ditto }

--*/

#include <precomp.h>

void _cdecl main(void) {
    LPWSTR CmdLine, *Args;
    ULONG nArgs, Error;
    
    CmdLine = GetCommandLineW();
    Args = CommandLineToArgvW(CmdLine, &nArgs );
    if( NULL == Args ) {
        printf("Error : %ld\n", GetLastError());
        return;
    }

    if( nArgs < 3 ) {
        Error = ERROR_BAD_ARGUMENTS;
    } else if( _wcsicmp(Args[1], L"export" ) == 0 ) {
        Error = CmdLineDoExport( &Args[2], nArgs - 2 );
    } else if( _wcsicmp(Args[1], L"Import" ) == 0 ) {
        Error = CmdLineDoImport( &Args[2], nArgs - 2 );
    } else {
        Error = ERROR_BAD_ARGUMENTS;
    }

    if( ERROR_BAD_ARGUMENTS == Error ) {
        printf("Usage: \n\t%s import filename <scope-list>"
               "\n\t%s export filename <scope-list>\n"
               "\t\t where <scope-list> is \"all\" or "
               "a list of subnet-addresses\n", Args[0], Args[0] );
    } else if( NO_ERROR != Error ) {
        printf("Failed error: %ld\n", Error );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\writedb.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   writedb.c

Abstract:

   This module writes the configuration onto the db for whistler+

--*/

#include <precomp.h>

DWORD
DhcpeximWriteDatabaseConfiguration(
    IN PM_SERVER Server
    )
{
    DWORD Error;
    HMODULE hDll;
    FARPROC pDhcpOpenAndWriteDatabaseConfig;
    
    hDll = LoadLibrary(TEXT("DHCPSSVC.DLL"));
    if( NULL == hDll ) return GetLastError();


    pDhcpOpenAndWriteDatabaseConfig = GetProcAddress(
        hDll, "DhcpOpenAndWriteDatabaseConfig" );

    if( NULL == pDhcpOpenAndWriteDatabaseConfig ) {
        Error = GetLastError();
    } else {
        Error = (DWORD)pDhcpOpenAndWriteDatabaseConfig(
            DhcpEximOemDatabaseName, DhcpEximOemDatabasePath,
            Server );
    }

    FreeLibrary(hDll);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\idl\imports.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Madan Appiah (madana)     10-Sep-1993
    Manny Weiser (mannyw)     11-Aug-1992

Revision History:


--*/


#include <windef.h>
#include <dhcp.h>
#include <dhcpapi.h>
#include <mdhcsapi.h>

#ifdef MIDL_PASS
#define RPC_BOOL DWORD
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\readreg.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   readreg.c

Abstract:

   This module reads the configuration from the registry into the
   MM data structures for NT4 and W2K.

--*/

#include <precomp.h>


DWORD
DhcpeximReadRegistryConfiguration(
    IN OUT PM_SERVER *Server
    )
{
    REG_HANDLE Hdl;
    DWORD Error;
    LPTSTR Loc;
    //
    // The location in the registry where things are read from is
    // different between whether it is NT4 or W2K.
    //

    if( IsNT4() ) Loc = DHCPEXIM_REG_CFG_LOC4;
    else Loc = DHCPEXIM_REG_CFG_LOC5;

    //
    // Now open the regkey
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, Loc, 0, KEY_ALL_ACCESS, &Hdl.Key );
    if( NO_ERROR != Error ) return Error;

    //
    // Set this as the current server
    //

    DhcpRegSetCurrentServer(&Hdl);

    //
    // Read the configuration
    //

    Error = DhcpRegReadThisServer(Server);

    RegCloseKey(Hdl.Key);
    DhcpRegSetCurrentServer(NULL);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\writereg.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   writereg.c

Abstract:

   This module write the configuration to the registry from the
   MM data structures for NT4 and W2K.

--*/

#include <precomp.h>


DWORD
SaveOrRestoreConfigToFile(
    IN HKEY hKey,
    IN LPWSTR ConfigFileName,
    IN BOOL fRestore
    )
/*++

Routine Description:
    This routine backs up or restores the dhcp configuration between
    the registry and the file.

Arguments:
    hKey -- key to backup or restore onto
    ConfigFileName -- file name to use to backup onto or restore from.
        This must be full path name.
    fRestore -- TRUE ==> do a restore from file; FALSE => do backup to
        file.

Return Values:
    Win32 errors...

--*/
{
    DWORD Error;
    BOOL fError;
    BOOLEAN WasEnable;
    NTSTATUS NtStatus;
    HANDLE ImpersonationToken;

    if( FALSE == fRestore ) {
        //
        // If backing up, delete the old file.
        //
        fError = DeleteFile( ConfigFileName );
        if(FALSE == fError ) {
            Error = GetLastError();
            if( ERROR_FILE_NOT_FOUND != Error &&
                ERROR_PATH_NOT_FOUND != Error ) {

                ASSERT(FALSE);
                return Error;
            }
        }
    }

    //
    // Impersonate to self.
    //
    NtStatus = RtlImpersonateSelf( SecurityImpersonation );
    if( !NT_SUCCESS(NtStatus) ) {

        DbgPrint("Impersonation failed: 0x%lx\n", NtStatus);
        Error = RtlNtStatusToDosError( NtStatus );
        return Error;
    }
    
    NtStatus = RtlAdjustPrivilege(
        SE_BACKUP_PRIVILEGE,
        TRUE, // enable privilege
        TRUE, // adjust client token
        &WasEnable
        );
    if( !NT_SUCCESS (NtStatus ) ) {
        
        DbgPrint("RtlAdjustPrivilege: 0x%lx\n", NtStatus );
        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    
    NtStatus = RtlAdjustPrivilege(
        SE_RESTORE_PRIVILEGE,
        TRUE, // enable privilege
        TRUE, // adjust client token
        &WasEnable
        );
    if( !NT_SUCCESS (NtStatus ) ) {

        DbgPrint( "RtlAdjustPrivilege: 0x%lx\n", NtStatus );
        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    
    //
    // Backup or restore appropriately.
    //
    
    if( FALSE == fRestore ) {
        Error = RegSaveKey( hKey, ConfigFileName, NULL );
    } else {
        Error = RegRestoreKey( hKey, ConfigFileName, 0 );
    }

    if( ERROR_SUCCESS != Error ) {
        DbgPrint("Backup/Restore: 0x%lx\n", Error);
    }
    
    //
    // revert impersonation.
    //

Cleanup:
    
    ImpersonationToken = NULL;
    NtStatus = NtSetInformationThread(
        NtCurrentThread(),
        ThreadImpersonationToken,
        (PVOID)&ImpersonationToken,
        sizeof(ImpersonationToken)
        );
    if( !NT_SUCCESS(NtStatus ) ) {
        DbgPrint("NtSetInfo: 0x%lx\n", NtStatus);
        if( ERROR_SUCCESS == Error ) {
            Error = RtlNtStatusToDosError(NtStatus);
        }
    }
    
    return Error;
}

DWORD
DhcpRegDeleteKey(
    HKEY ParentKeyHandle,
    LPWSTR KeyName
    )
/*++

Routine Description:

    This function deletes the specified key and all its subkeys.

Arguments:

    ParentKeyHandle : handle of the parent key.

    KeyName : name of the key to be deleted.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error, NumSubKeys;
    HKEY KeyHandle = NULL;


    //
    // open key.
    //

    Error = RegOpenKeyEx(
        ParentKeyHandle,
        KeyName,
        0,
        KEY_ALL_ACCESS,
        &KeyHandle );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // query key info.
    //

    Error = RegQueryInfoKey(
        KeyHandle, NULL, NULL, NULL, &NumSubKeys, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // delete all its subkeys if they exist.
    //

    if( NumSubKeys != 0 ) {
        DWORD Index;
        DWORD KeyLength;
        WCHAR KeyBuffer[100];
        FILETIME KeyLastWrite;

        for(Index = 0;  Index < NumSubKeys ; Index++ ) {

            //
            // read next subkey name.
            //
            // Note : specify '0' as index each time, since  deleting
            // first element causes the next element as first
            // element after delete.
            //

            KeyLength = sizeof(KeyBuffer)/sizeof(WCHAR);
            Error = RegEnumKeyEx(
                KeyHandle,
                0,                  // index.
                KeyBuffer,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );
            
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            //
            // delete this key recursively.
            //

            Error = DhcpRegDeleteKey(
                KeyHandle,
                KeyBuffer );
            
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }
        }
    }

    //
    // close the key before delete.
    //

    RegCloseKey( KeyHandle );
    KeyHandle = NULL;

    //
    // at last delete this key.
    //

    Error = RegDeleteKey( ParentKeyHandle, KeyName );

Cleanup:

    if( KeyHandle == NULL ) {
        RegCloseKey( KeyHandle );
    }

    return( Error );
}

DWORD
DhcpRegDeleteKeyByName(
    IN LPWSTR Parent,
    IN LPWSTR SubKey
    )
{
    HKEY hKey;
    ULONG Error;
    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        Parent,
        0,
        KEY_ALL_ACCESS,
        &hKey
        );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegDeleteKey(hKey, SubKey);
    RegCloseKey(hKey);

    return Error;
}

DWORD
DhcpeximWriteRegistryConfiguration(
    IN PM_SERVER Server
    )
{
    REG_HANDLE Hdl;
    DWORD Error, Disp;
    LPTSTR Loc, TempLoc;
    HKEY hKey;
    
    //
    // The location in the registry where things are read from is
    // different between whether it is NT4 or W2K.
    //

    if( IsNT4() ) Loc = DHCPEXIM_REG_CFG_LOC4;
    else Loc = DHCPEXIM_REG_CFG_LOC5;

    TempLoc = TEXT("Software\\Microsoft\\DhcpExim");
    
    //
    // Now open the regkey
    //

    Error = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE, TempLoc, 0, TEXT("DHCPCLASS"),
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &Hdl.Key, &Disp );
    if( NO_ERROR != Error ) return Error;

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, Loc, 0, KEY_ALL_ACCESS, &hKey );
    if( NO_ERROR != Error ) {
        RegCloseKey( Hdl.Key );
        return Error;
    }
    
    //
    // Set this as the current server
    //

    DhcpRegSetCurrentServer(&Hdl);

    //
    // Save the configuration temporarily 
    //

    Error = DhcpRegServerSave(Server);

    //
    // Now attempt to save the temporary key to disk and restore
    // it back where it should really be and delete temp key
    //

    if( NO_ERROR == Error ) {
    
        Error = SaveOrRestoreConfigToFile(
            Hdl.Key, L"Dhcpexim.reg", FALSE );

        if( NO_ERROR == Error ) {

            Error = SaveOrRestoreConfigToFile(
                hKey, L"Dhcpexim.reg", TRUE );

            if( NO_ERROR == Error ) {
                RegCloseKey(Hdl.Key);
                Hdl.Key = NULL;
                DhcpRegDeleteKeyByName(
                    L"Software\\Microsoft", L"DhcpExim" );
            }
        }
    }

    if( NULL != Hdl.Key ) RegCloseKey(Hdl.Key);
    RegCloseKey(hKey);
    DhcpRegSetCurrentServer(NULL);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\exim\select.c ===
/*++

Copyright (c) 2000 Microsoft corporation

Module Name:

    select.c

Abstract:

    Implements the partial selection of configuration from the
    full MM configuration data structures.

--*/

#include <precomp.h>

typedef struct _SELECT_CTXT {
    ULONG *Subnets;
    ULONG nSubnets;
    
} SELECT_CTXT, *PSELECT_CTXT;

DWORD
DeleteScopesCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    PSELECT_CTXT SelectCtxt = Ctxt->ExtraCtxt;
    ULONG *Subnets, nSubnets, i;
    
    Subnets = SelectCtxt->Subnets;
    nSubnets = SelectCtxt->nSubnets;

    for( i = 0; i < nSubnets; i ++ ) {
        if( Subnets[i] == Ctxt->Scope->Address ) break;
    }

    if( i == nSubnets ) {
        //
        // Returning KEY_DELETED will cause the IterateScopes
        // routine to delete this scope out.
        //
        return ERROR_KEY_DELETED;
    }
    
    return NO_ERROR;
}

DWORD
OptionCheckForClass(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    PM_CLASSDEF ClassDef = Ctxt->ExtraCtxt;

    //
    // If the class specified in ExtraCtxt matches the current
    // option's user or vendor class, then bummer -- fail
    // immediately with error code ERROR_DEVICE_IN_USE to
    // indicate that this class is needed and can't be deleted
    //
    
    if( Ctxt->UserClass == ClassDef ||
        Ctxt->VendorClass ==  ClassDef ) {
        return ERROR_DEVICE_IN_USE;
    }

    return NO_ERROR;
}

DWORD
OptionCheckForOptDef(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    PMM_ITERATE_CTXT OtherCtxt = Ctxt->ExtraCtxt;

    //
    // If the current option matches the optdef parameters, then
    // we need to save the optdef ..
    //
    
    if( Ctxt->VendorClass == OtherCtxt->VendorClass &&
        Ctxt->Option->OptId == OtherCtxt->OptDef->OptId ) {
        return ERROR_DEVICE_IN_USE;
    }

    return NO_ERROR;
}

DWORD
ScopeReservationsCheckForClass(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    return IterateReservationOptions(
        Ctxt->Server, Ctxt->Res, Ctxt->ExtraCtxt,
        OptionCheckForClass );
}

DWORD
ScopeReservationsCheckForOptDef(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    return IterateReservationOptions(
        Ctxt->Server, Ctxt->Res, Ctxt->ExtraCtxt,
        OptionCheckForOptDef );
}

DWORD
ScopeCheckForClass(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    
    //
    // Iterate over each option in the current scope to see if
    // any of them use the same class
    //

    Error = IterateScopeOptions(
        Ctxt->Scope, Ctxt->ExtraCtxt, OptionCheckForClass );
    if( NO_ERROR != Error ) return Error;

    //
    // Otherwise iterate for each reservation to see if this is a
    // problem. 
    //

    return IterateScopeReservations(
        Ctxt->Scope, Ctxt->ExtraCtxt,
        ScopeReservationsCheckForClass );
}

DWORD
ScopeCheckForOptDef(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    
    //
    // Iterate over each option in the current scope to see if
    // any of them use the same class
    //

    Error = IterateScopeOptions(
        Ctxt->Scope, Ctxt->ExtraCtxt, OptionCheckForOptDef );
    if( NO_ERROR != Error ) return Error;

    //
    // Otherwise iterate for each reservation to see if this is a
    // problem. 
    //

    return IterateScopeReservations(
        Ctxt->Scope, Ctxt->ExtraCtxt,
        ScopeReservationsCheckForOptDef );
}

DWORD
DeleteClassesCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    
    //
    // Go through each subnet to see if there is any option
    // configured to use this class
    //

    Error = IterateScopes(
        Ctxt->Server, Ctxt->ClassDef, ScopeCheckForClass );

    //
    // If the specified class is in use, then don't
    // delete. Otherwise delete.
    //
    
    if( ERROR_DEVICE_IN_USE == Error ) return NO_ERROR;
    if (NO_ERROR == Error ) return ERROR_KEY_DELETED;
    return Error;
}

DWORD
DeleteOptDefsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    
    //
    // Go through each subnet to see if there is any option
    // configured to use this optdef
    //

    Error = IterateScopes(
        Ctxt->Server, Ctxt, ScopeCheckForOptDef );

    //
    // If the specified class is in use, then don't
    // delete. Otherwise delete.
    //
    
    if( ERROR_DEVICE_IN_USE == Error ) return NO_ERROR;
    if (NO_ERROR == Error ) return ERROR_KEY_DELETED;
    return Error;
    
}

DWORD
SelectConfiguration(
    IN OUT PM_SERVER Server,
    IN ULONG *Subnets,
    IN ULONG nSubnets
    )
{
    SELECT_CTXT Ctxt = { Subnets, nSubnets };
    DWORD Error;
    ULONG i;
    WCHAR SubnetAddress[30];
    
    //
    // No selection needed if nSubnets == 0, as this indicates
    // that the whole configuration is to be used
    //

    Tr("SelectConfiguration entered\n");
    
    if( nSubnets == 0 ) return NO_ERROR;

    //
    // First go through all scopes and check if all the required
    // scopes are present
    //

    for( i = 0; i < nSubnets ; i ++ ) {
        PM_SUBNET Subnet;
        
        Error = MemServerGetUAddressInfo(
            Server, Subnets[i], &Subnet, NULL, NULL, NULL );
        if( NO_ERROR != Error ) {
            Tr("Cant find subnet 0x%lx: %ld\n", Subnets[i], Error );
            if( ERROR_FILE_NOT_FOUND == Error ) {
                IpAddressToStringW(Subnets[i], (LPWSTR)SubnetAddress);
                DhcpEximErrorSubnetNotFound( (LPWSTR)SubnetAddress );
                    
                Error = ERROR_CAN_NOT_COMPLETE;
            }
            
            return Error;
        }
    }
    
    //
    // Global options are never needed.. so we can delete them.
    //

    MemOptClassFree( &Server->Options );
    
    //
    // Go through all the subnets and delete ones that are
    // not selected
    //

    Error = IterateScopes(
        Server, &Ctxt, DeleteScopesCallback );

    if( NO_ERROR != Error ) {
        Tr("IterateScopes: %ld\n", Error );
        return Error;
    }


    //
    // Now check if all the option-defs are needed
    //

    Error = IterateOptDefs(
        Server, NULL, DeleteOptDefsCallback );

    if( NO_ERROR != Error ) {
        Tr("IterateOptDefs: %ld\n", Error );
        return Error;
    }

    //
    // Now check if all the user classes are needed
    //

    Error = IterateClasses(
        Server, NULL, DeleteClassesCallback );

    if( NO_ERROR != Error ) {
        Tr("IterateClasses: %ld\n", Error );
        return Error;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\address.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for managing (multicast) scopes
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>
#include    <dhcpapi.h>
#include    <address.h>

//================================================================================
// subnet only address api's
//================================================================================
BOOL
MemSubnetGetThisAddress(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      BOOL                   fAcquire,      // if available, also acquire?
    IN      BOOL                   fBootp
) 
{
    DWORD                          Error;
    DWORD                          Offset;
    DWORD                          OldState;
    PM_RANGE                       Range;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        &Range,
        NULL,
        NULL
    );

    if( ERROR_SUCCESS != Error ) return FALSE;
    Require(Range);
    if( fBootp ) {
        if( 0 == (Range->State & MM_FLAG_ALLOW_BOOTP))
            return FALSE;

        if( fAcquire &&
            Range->BootpAllocated >= Range->MaxBootpAllowed ) {
            return FALSE;
        }
    } else {
        if( 0 == (Range->State & MM_FLAG_ALLOW_DHCP) ) 
            return FALSE;
    }

    Offset = Address - Range->Start;

    if( !fAcquire ) return MemBitIsSet(Range->BitMask, Offset);

    Error = MemBitSetOrClear(
        Range->BitMask,
        Offset,
        TRUE /* Acquire */,
        &OldState
    );
    if( ERROR_SUCCESS != Error ) { Require(FALSE); return FALSE; }

    if( FALSE == OldState ) {
        InterlockedIncrement(&Range->DirtyOps);
        if( fBootp ) InterlockedIncrement( &Range->BootpAllocated );
    }
    return !OldState;
}

BOOL
MemSubnetGetAnAddress(
    IN      PM_SUBNET              Subnet,
    OUT     LPDWORD                AltAddress,
    IN      DWORD                  fAcquire,
    IN      BOOL                   fBootp
) {
    DWORD                          Error;
    DWORD                          Offset;
    DWORD                          Policy;
    ARRAY_LOCATION                 Loc;
    PM_RANGE                       Range;

    if( IS_DISABLED(Subnet->State)) return FALSE;

    Policy = Subnet->Policy;
    if( AddressPolicyNone == Policy )
        Policy = ((PM_SERVER)(Subnet->ServerPtr))->Policy;

    if( AddressPolicyRoundRobin == Policy ) {
        Error = MemArrayRotateCyclical(&Subnet->Ranges);
        Require(ERROR_SUCCESS == Error);
    }

    for ( Error = MemArrayInitLoc(&Subnet->Ranges, &Loc);
          ERROR_FILE_NOT_FOUND != Error ;
          Error = MemArrayNextLoc(&Subnet->Ranges, &Loc) ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Subnet->Ranges, &Loc, (LPVOID *)&Range);
        Require(ERROR_SUCCESS == Error && Range);
        
        if( fBootp ) {
            if( 0 == (Range->State & MM_FLAG_ALLOW_BOOTP) ) {
                continue;
            }
            if( fAcquire && 
                Range->BootpAllocated >= Range->MaxBootpAllowed ) {
                continue;
            }
        } else {
            if( 0 == (Range->State & MM_FLAG_ALLOW_DHCP ) ) {
                continue;
            }
        }

        Error = MemBitGetSomeClearedBit(
            Range->BitMask,
            &Offset,
            fAcquire,
            Range->Start,
            &Subnet->Exclusions
        );
        if( ERROR_SUCCESS == Error ) {
            *AltAddress = Range->Start + Offset;
            InterlockedIncrement(&Range->DirtyOps);
            if( fBootp && fAcquire ) {
                InterlockedIncrement(&Range->BootpAllocated);
            }
            return TRUE;
        }
    }

    return FALSE;
}

//================================================================================
// per-server scans
//================================================================================

BOOL
MemServerGetAddress(                              // acquire address or check for availability
    IN OUT  PM_SERVER              Server,
    IN      PM_SUBNET              Subnet,        // search all subnets in superscope with this, except for this subnet alone
    IN      BOOL                   fAcquire,      // is this just a lookup or a full blown request?
    IN      BOOL                   fBootp,        // is this a DHCP address or BOOTP address?
    OUT     DWORD                 *AltAddress,    // the address that looks available
    OUT     PM_SUBNET             *AltSubnet      // got it from this subnet
) {
    DWORD                          Error;
    DWORD                          SScopeId;
    DWORD                          Size;
    DWORD                          Policy;
    BOOL                           Obtained;
    PM_SUBNET                      NextSubnet;
    PM_SSCOPE                      SScope;

    AssertRet(Server && Subnet && AltAddress && AltSubnet, ERROR_INVALID_PARAMETER );
    AssertRet(NULL == AltAddress || NULL != AltSubnet, ERROR_INVALID_PARAMETER);
    AssertRet(Subnet->fSubnet, FALSE );

    SScopeId = Subnet->SuperScopeId;
    if( 0 == SScopeId ) {
        if( AltSubnet ) *AltSubnet = Subnet;
        return MemSubnetGetAnAddress(Subnet,AltAddress, fAcquire, fBootp);
    }

    Error = MemServerFindSScope(Server, SScopeId, NULL, &SScope);
    if( ERROR_FILE_NOT_FOUND == Error ) {         // the superscope quietly died ?
        Subnet->SuperScopeId = 0;                 // no superscope at all
        if( AltSubnet ) *AltSubnet = Subnet;
        return MemSubnetGetAnAddress(Subnet, AltAddress, fAcquire, fBootp);
    }
    Require(ERROR_SUCCESS == Error);

    Policy = SScope->Policy;
    if( AddressPolicyNone == Policy )
        Policy = Server->Policy;

    if( AddressPolicyRoundRobin != Policy )
        Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
    else Error = MemArrayNextLoc(&Server->Subnets, &Server->Loc);

    Size = MemArraySize(&Server->Subnets);

    while( Size -- ) {
        if(ERROR_FILE_NOT_FOUND == Error) {       // wraparound
            Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
        }
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->Subnets, &Server->Loc, &NextSubnet);
        Require(ERROR_SUCCESS == Error && NextSubnet);

        if( NextSubnet->SuperScopeId == SScopeId ) {
            Obtained = MemSubnetGetAnAddress(NextSubnet,AltAddress,fAcquire, fBootp);
            if( Obtained ) {
                *AltSubnet = NextSubnet;
                return TRUE;
            }
        }

        Error = MemArrayNextLoc(&Server->Subnets, &Server->Loc);
    }

    return FALSE;
}

//BeginExport(function)
BOOL
MemSubnetRequestAddress(
    IN OUT  PM_SUBNET              Subnet,        // the subnet to start the search in
    IN      DWORD                  Address,       // init. addr: 0 => search in SuperScope, SubnetAddr = try subnet first
    IN      BOOL                   fAcquire,      // also acquire the address? or just test for availability?
    IN      BOOL                   fBootp,        // acquire BOOTP address?
    OUT     DWORD                 *RetAddress,    // OPTIONAL if Address is not 0 or SubnetAddr -- address obtained
    OUT     PM_SUBNET             *RetSubnet      // OPTIONAL if Address is not 0 - which subnet is the address from
) //EndExport(function)
{
    BOOL                           Obtained;

    AssertRet( Subnet , ERROR_INVALID_PARAMETER);
    if( 0 == Address ) AssertRet(RetAddress && RetSubnet, ERROR_INVALID_PARAMETER);
    if( Subnet->fSubnet && Subnet->Address == Address ) AssertRet(RetAddress, ERROR_INVALID_PARAMETER);

    if( (!Subnet->fSubnet || Subnet->Address != Address ) && 0 != Address ) {
        Obtained = MemSubnetGetThisAddress(   // for the specific address requested
            Subnet,
            Address,
            fAcquire,
            fBootp
        );
        if( Obtained ) {
            if( RetAddress ) *RetAddress = Address;
            if( RetSubnet ) *RetSubnet = Subnet;
            return TRUE;
        }
    }
    if( !RetAddress ) return FALSE;

    if (0) {
        if( 0 == Address && Subnet->fSubnet ) Obtained = FALSE;      // this case, dont try subnet first.. go thru sscope list instead
        else
            Obtained = MemSubnetGetAnAddress(     // try for some address in this subnet?
                Subnet,
                RetAddress,
                fAcquire,
                fBootp
            );
    }

    Obtained = MemSubnetGetAnAddress(         // try for some address in this subnet?
        Subnet,
        RetAddress,
        fAcquire,
        fBootp
    );

    if( Obtained && RetSubnet ) *RetSubnet = Subnet;
    if( Obtained ) return TRUE;

    // if the address was requested from a particular subnet OR
    // multicast address requested then return FALSE now.
    if( !Subnet->fSubnet || Subnet->Address == Address ) return FALSE;

    return MemServerGetAddress(
        Subnet->ServerPtr,
        Subnet,
        fAcquire,
        fBootp,
        RetAddress,
        RetSubnet
    );
}

//BeginExport(function)
DWORD
MemServerReleaseAddress(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  Address,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    AssertRet(Server, ERROR_INVALID_PARAMETER);

    Error = MemServerGetAddressInfo(
        Server,
        Address,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return Error;
    Require(Subnet);
    if( Subnet->fSubnet ) {
        Require((Subnet->Mask & Address) == Subnet->Address);
    }

    return MemSubnetReleaseAddress(Subnet, Address, fBootp);
}

//BeginExport(function)
BOOL // TRUE ==> allowed, FALSE ==> not allowed
MemSubnetCheckBootpDhcp(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fBootp,
    IN      BOOL                   fCheckSuperScope
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    ULONG                          Error;
    PM_RANGE                       Range;
    PM_SUBNET                      ThisSubnet;
    PARRAY                         Array;

    if( Subnet->fSubnet && !IS_DISABLED( Subnet->State ) ) {
        for( Error = MemArrayInitLoc( &Subnet->Ranges, &Loc );
             ERROR_SUCCESS == Error ;
             Error = MemArrayNextLoc( &Subnet->Ranges, &Loc ) ) {
            Error = MemArrayGetElement( &Subnet->Ranges, &Loc , &Range );
            Require( ERROR_SUCCESS == Error );
            
            if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP : MM_FLAG_ALLOW_DHCP) ) ) {
                continue;
            }
            
            return TRUE;
        }
    }

    if( FALSE == fCheckSuperScope || 0 == Subnet->SuperScopeId ) {
        return FALSE;
    }

    Array = &((PM_SERVER) (Subnet->ServerPtr))->Subnets;
    for( Error = MemArrayInitLoc( Array, &Loc );
         ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc( Array, &Loc ) ) {
        Error = MemArrayGetElement( Array, &Loc, &ThisSubnet );
        Require( ERROR_SUCCESS == Error );

        if( ThisSubnet == Subnet ) continue;
        if( ThisSubnet->SuperScopeId != Subnet->SuperScopeId ) continue;
        if( FALSE == MemSubnetCheckBootpDhcp( ThisSubnet, fBootp, FALSE ) )
            continue;

        return TRUE;
    }
    
    return FALSE;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\address.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _MM_ADDRESS_h_
#define _MM_ADDRESS_H_

#include <dhcpapi.h>

DHCP_SUBNET_STATE __inline
IS_SWITCHED(
    DHCP_SUBNET_STATE state 
)
{
    return(( state == DhcpSubnetDisabledSwitched ) || 
	   ( state == DhcpSubnetEnabledSwitched ));
}

DHCP_SUBNET_STATE __inline
IS_DISABLED(
    DHCP_SUBNET_STATE state
)
{
    return (( state == DhcpSubnetDisabled) || 
	    ( state == DhcpSubnetDisabledSwitched ));
}

DHCP_SUBNET_STATE  __inline
DISABLED(
    DHCP_SUBNET_STATE state
)
{
    if (( state == DhcpSubnetDisabledSwitched ) ||
	( state == DhcpSubnetEnabledSwitched )) {
	return DhcpSubnetDisabledSwitched;
    }
    else {
	return DhcpSubnetDisabled;
    }
}

VOID  __inline
SWITCHED(
    DHCP_SUBNET_STATE *state
)
{
    if ( *state == DhcpSubnetDisabled ) {
	*state = DhcpSubnetDisabledSwitched;
    }
    else if ( *state == DhcpSubnetEnabled ) {
	*state = DhcpSubnetEnabledSwitched;
    }
}

BOOL
MemSubnetRequestAddress(
    IN OUT  PM_SUBNET              Subnet,        // the subnet to start the search in
    IN      DWORD                  Address,       // init. addr: 0 => search in SuperScope, SubnetAddr = try subnet first
    IN      BOOL                   fAcquire,      // also acquire the address? or just test for availability?
    IN      BOOL                   fBootp,        // acquire BOOTP address?
    OUT     DWORD                 *RetAddress,    // OPTIONAL if Address is not 0 or SubnetAddr -- address obtained
    OUT     PM_SUBNET             *RetSubnet      // OPTIONAL if Address is not 0 - which subnet is the address from
) ;


DWORD
MemServerReleaseAddress(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  Address,
    IN      BOOL                   fBootp
) ;


DWORD       _inline
MemSubnetReleaseAddress(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      BOOL                   fBootp
    ) 
{
    DWORD                          Error;
    DWORD                          OldState;
    PM_RANGE                       Range;
    PM_EXCL                        Excl;
    PM_RESERVATION                 Reservation;

    AssertRet(Subnet, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet && Subnet->Address != (Address & Subnet->Mask ) )
        return MemServerReleaseAddress(
            Subnet->ServerPtr,
            Address,
            fBootp
        );

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        &Range,
        NULL,
        &Reservation
    );
    if( ERROR_SUCCESS != Error ) return Error;
    Require(Range);

    if( NULL != Reservation ) {
        Require(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
    
    if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP: MM_FLAG_ALLOW_DHCP))) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = MemBitSetOrClear(
        Range->BitMask,
        Address - Range->Start,
        FALSE /* Release */,
        &OldState
    );
    if( ERROR_SUCCESS != Error ) return Error;
    if( OldState == FALSE ) return ERROR_FILE_NOT_FOUND;

    InterlockedIncrement(&Range->DirtyOps);
    if( fBootp && 0 != Range->BootpAllocated ) {
        InterlockedDecrement( &Range->BootpAllocated );
    }

    return ERROR_SUCCESS;
}


BOOL // TRUE ==> allowed, FALSE ==> not allowed
MemSubnetCheckBootpDhcp(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fBootp,
    IN      BOOL                   fCheckSuperScope
) ;

#endif 

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\array.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements a growable array
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for conventions on reading/writing code that i use
//================================================================================
#include    <mm.h>
#define     FILE                   "mm\\array.h"

#ifdef      IMPORTS
MemAlloc
MemFree
AssertRet
Require
#endif      IMPORTS


//BeginExport(typedef)
typedef struct _ARRAY {
    DWORD                          nElements;
    DWORD                          nAllocated;
    LPVOID                        *Ptrs;
} ARRAY, *PARRAY, *LPARRAY;
//EndExport(typedef)

//BeginExport(typedef)
typedef DWORD                      ARRAY_LOCATION;
typedef ARRAY_LOCATION*            PARRAY_LOCATION;
typedef PARRAY_LOCATION            LPARRAY_LOCATION;
//EndExport(typedef)

//BeginExport(inline)
DWORD _inline
MemArrayInit(                                     // initialize the STRUCTURE
    OUT     PARRAY                 Array          // input structure pre-allocated
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    Array->nElements = Array->nAllocated = 0;
    Array->Ptrs = NULL;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayCleanup(                                  // freeup the memory if any, allocated in this module
    IN OUT  PARRAY                 Array
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    if( Array->Ptrs) MemFree(Array->Ptrs);
    Array->nElements = Array->nAllocated = 0;
    Array->Ptrs = NULL;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArraySize(
    IN      PARRAY                 Array
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    return Array->nElements;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayInitLoc(                                  // Initialize an array location
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    (*Location) = 0;
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
BOOL _inline
MemArrayValidLoc(
    IN      PARRAY                 Array,
    IN      PARRAY_LOCATION        Location
)
{
    AssertRet(Array && Location, FALSE);

    return ( *Location < Array->nElements );
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayNextLoc(                                  // move one step forward
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( (*Location) + 1  >= Array->nElements ) return ERROR_FILE_NOT_FOUND;
    (*Location) ++;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayPrevLoc(
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    if( ((LONG)(*Location)) - 1 < 0 ) return ERROR_FILE_NOT_FOUND;
    (*Location) --;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayLastLoc(
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    (*Location) = Array->nElements -1;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayGetElement(
    IN      PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    OUT     LPVOID                *Element
) {
    AssertRet(Array && Location && Element, ERROR_INVALID_PARAMETER);
    (*Element) = Array->Ptrs[*Location];
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArraySetElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                 Element
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER );
    Array->Ptrs[*Location] = Element;
    return ERROR_SUCCESS;
}
//EndExport(inline)
const
DWORD       MinAllocUnit =         4;
const
DWORD       MinFreeUnit =          4;             // Must be a power of two

LPVOID _inline
MemAllocLpvoid(
    DWORD                          nLpvoids
) {
    return MemAlloc(sizeof(LPVOID)*nLpvoids);
}

//BeginExport(function)
DWORD
MemArrayAddElement(
    IN OUT  PARRAY                 Array,
    IN      LPVOID                 Element
) //EndExport(function)
{
    LPVOID                         Ptrs;

    AssertRet(Array, ERROR_INVALID_PARAMETER );
    if( Array->nElements < Array->nAllocated ) {
        Array->Ptrs[Array->nElements ++ ] = Element;
        return ERROR_SUCCESS;
    }

    if( 0 == Array->nAllocated ) {
        Array->Ptrs = MemAllocLpvoid(MinAllocUnit);
        if( NULL == Array->Ptrs ) return ERROR_NOT_ENOUGH_MEMORY;
        Array->nAllocated = MinAllocUnit;
        Array->nElements = 1;
        Array->Ptrs[0] = Element;
        return ERROR_SUCCESS;
    }

    Ptrs = MemAllocLpvoid(MinAllocUnit+Array->nAllocated);
    if( NULL == Ptrs ) return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(Ptrs, Array->Ptrs, sizeof(LPVOID)*Array->nAllocated);
    MemFree(Array->Ptrs);
    Array->Ptrs = Ptrs;
    Array->Ptrs[Array->nElements++] = Element;
    Array->nAllocated += MinAllocUnit;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
MemArrayInsElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                 Element
) //EndExport(function)
{
    LPVOID                        *Ptrs;

    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);

    if( (*Location) == Array->nElements )
        return MemArrayAddElement(Array,Element);

    if( Array->nElements < Array->nAllocated ) {
        memmove(&Array->Ptrs[1+*Location], &Array->Ptrs[*Location], sizeof(LPVOID)*(Array->nElements - *Location));
        Array->Ptrs[*Location] = Element;
        Array->nElements++;
        return ERROR_SUCCESS;
    }

    Require(Array->nElements);

    Ptrs = MemAllocLpvoid(MinAllocUnit + Array->nAllocated);
    if( NULL == Ptrs ) return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(Ptrs, Array->Ptrs, sizeof(LPVOID)*(*Location) );
    Ptrs[*Location] = Element;
    memcpy(&Ptrs[1+*Location], &Array->Ptrs[*Location], sizeof(LPVOID)*(Array->nElements - *Location));
    MemFree(Array->Ptrs);
    Array->Ptrs = Ptrs;
    Array->nElements ++;
    Array->nAllocated += MinAllocUnit;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
MemArrayDelElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                *Element
) //EndExport(function)
{
    LPVOID                        *Ptrs;

    AssertRet(Array && Location && Array->nElements && Element, ERROR_INVALID_PARAMETER);

    (*Element) = Array->Ptrs[*Location];

    Array->nElements--;

    if( 0 == Array->nElements ) {
        Require(0 == *Location);
        return MemArrayCleanup(Array);
    }

    if( Array->nElements % MinFreeUnit || NULL == (Ptrs = MemAllocLpvoid(Array->nElements))) {
        memcpy(&Array->Ptrs[*Location], &Array->Ptrs[1+*Location], sizeof(LPVOID)*(Array->nElements - (*Location)));
        return ERROR_SUCCESS;
    }

    Require(Ptrs);
    memcpy(Ptrs, Array->Ptrs, sizeof(LPVOID)*(*Location));
    memcpy(&Ptrs[*Location], &Array->Ptrs[1+*Location], sizeof(LPVOID)*(Array->nElements - (*Location)));
    MemFree(Array->Ptrs);
    Array->Ptrs = Ptrs;
    Array->nAllocated = Array->nElements;

    return ERROR_SUCCESS;
}

//BeginExport(inline)
DWORD        _inline
MemArrayAdjustLocation(                           // reset location to "next" after a delete
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Location && Array, ERROR_INVALID_PARAMETER);

    if( *Location >= Array->nElements ) return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemArrayRotateCyclical(                           // rotate forward/right cyclical
    IN      PARRAY                 Array
) {
    LPVOID                         FirstPtr;

    AssertRet(Array, ERROR_INVALID_PARAMETER);

    if( Array->nElements < 2 ) return ERROR_SUCCESS;
    FirstPtr = Array->Ptrs[0];
    memcpy(Array->Ptrs, &Array->Ptrs[1], sizeof(Array->Ptrs[0])* (Array->nElements -1));
    Array->Ptrs[Array->nElements -1] = FirstPtr;

    return ERROR_SUCCESS;
}
//EndExport(inline)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\bitmask.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for bitmasks
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>

#include "bitmask.h"


DWORD       _inline
MemBit1Init(
    OUT     PM_BITMASK1           *Bits,
    IN      DWORD                  nBits
)
{
    PM_BITMASK1                    Bits1;

    Bits1 = MemAlloc(sizeof(*Bits1));
    if( NULL == Bits1 ) return ERROR_NOT_ENOUGH_MEMORY;

    (*Bits) = Bits1;
    Bits1->Size = nBits;
    Bits1->AllocSize = (nBits + 8)/8;
    Bits1->nSet = 0;
    Bits1->Mask = NULL;
    Bits1->nDirtyOps = 0;
    return ERROR_SUCCESS;
}

DWORD       _inline
MemBit1Cleanup(
    IN      PM_BITMASK1            Bits
)
{
    if( Bits->Mask ) MemFree(Bits->Mask);
    MemFree(Bits);

    return ERROR_SUCCESS;
}

DWORD       _inline
MemBit1SetAll(
    IN OUT  PM_BITMASK1            Bits
)
{
    Bits->nDirtyOps ++;
    Bits->nSet = Bits->Size;
    if( Bits->Mask ) {
        MemFree(Bits->Mask);
        Bits->Mask = NULL;
    }

    return ERROR_SUCCESS;
}

DWORD       _inline
MemBit1ClearAll(
    IN OUT  PM_BITMASK1            Bits
)
{
    Bits->nDirtyOps ++;
    Bits->nSet = 0;
    if( Bits->Mask ) {
        MemFree(Bits->Mask);
        Bits->Mask = NULL;
    }
    return ERROR_SUCCESS;
}


// Be careful - the same set of masks are used in regread.c -- don't change this!!!!

static      DWORD                  Masks[] = {
    0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80
};

DWORD
MemBit1SetOrClear(
    IN OUT  PM_BITMASK1            Bits,
    IN      DWORD                  Location,
    IN      BOOL                   fSet,
    OUT     LPBOOL                 fOldState      // OPTIONAL
)
{
    BOOL                           OldState;

    Bits->nDirtyOps ++;

    if( 0 == Bits->nSet ) {
        // No existing bit, so it must all be clear..

        if( fOldState ) *fOldState = FALSE;
        if( !fSet ) return ERROR_SUCCESS;

        // need to set the bit.. if we are setting only bit, don't bother..
        Require(Bits->Size != 0);

        if( 1 == Bits->Size ) {
            Bits->nSet = 1;
            return ERROR_SUCCESS;
        }

        // we have to allocate stuff to set the bit..
        Bits->Mask = MemAlloc(Bits->AllocSize);
        if( NULL == Bits->Mask ) return ERROR_NOT_ENOUGH_MEMORY;
        memset(Bits->Mask, 0, Bits->AllocSize);
    }

    if( Bits->Size == Bits->nSet ) {
        // All existing bits set, so prior state is "Set"

        if( fOldState ) *fOldState = TRUE;
        if( fSet ) return ERROR_SUCCESS;

        // check to see if we got only one bit to clear, then we don't have to do nothing
        if( 1 == Bits->Size ) {
            Bits->nSet = 0;
            return ERROR_SUCCESS;
        }

        // we have to allocate memory for teh bitmap..
        Bits->Mask = MemAlloc(Bits->AllocSize);
        if( NULL == Bits->Mask ) return ERROR_NOT_ENOUGH_MEMORY;
        memset(Bits->Mask, 0xFF, Bits->AllocSize);
    }

    OldState = (Bits->Mask[Location/8] & Masks[Location%8])?TRUE:FALSE;
    if( fOldState ) *fOldState = OldState;

    if( fSet == OldState ) return ERROR_SUCCESS;
    if( fSet ) {
        if( Bits->Size == ++Bits->nSet ) {
            if(Bits->Mask ) MemFree(Bits->Mask);
            Bits->Mask = NULL;
        } else {
            Bits->Mask[Location/8] |= Masks[Location%8];
        }
    } else {
        if( 0 == --Bits->nSet ) {
            if(Bits->Mask) MemFree(Bits->Mask);
            Bits->Mask = NULL;
        } else {
            Bits->Mask[Location/8] &=  ~Masks[Location%8];
        }
    }

    return ERROR_SUCCESS;
}

BOOL        _inline
MemBit1IsSet(
    IN      PM_BITMASK1            Bits,
    IN      DWORD                  Location
)
{
    if( 0 == Bits->nSet ) return FALSE;
    if( Bits->Size == Bits->nSet ) return TRUE;

    if( Bits->Mask[Location/8] & Masks[Location%8] )
        return TRUE;
    return FALSE;
}

DWORD       _inline
IsExcluded(
    IN OUT  DWORD                *Try,            // this is updated to 1 less than end of excl
    IN      DWORD                 StartAddress,
    IN      PARRAY                Exclusions
)
{
    DWORD                         Error;
    ARRAY_LOCATION                Loc;
    PM_EXCL                       Excl;

    if( NULL == Exclusions ) return FALSE;

    Error = MemArrayInitLoc(Exclusions, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Error = MemArrayGetElement(Exclusions, &Loc, &Excl);
        Error = MemArrayNextLoc(Exclusions, &Loc);
        if( Excl->Start > StartAddress + *Try ) continue;
        if( Excl->End < StartAddress + *Try ) continue;

        *Try = Excl->End-StartAddress;
        return TRUE;
    }

    return FALSE;
}

DWORD       _inline
MemBit1GetSomeClearedBit(
    IN OUT  PM_BITMASK1           Bits,
    OUT     LPDWORD               Offset,
    IN      BOOL                  fAcquire,       // is this address to be taken or just looked up?
    IN      DWORD                 StartAddress,
    IN      PARRAY                Exclusions
)
{
    DWORD                         i;
    DWORD                         j;
    DWORD                         Error;
    DWORD                         OldState;

    if( Bits->Size == Bits->nSet ) return ERROR_FILE_NOT_FOUND;
    if( 0 == Bits->nSet ) {                       // got some memory..
        for( i = 0; i < Bits->Size ; i ++ ) {
            if( !IsExcluded(&i, StartAddress, Exclusions) )
                break;
        }

        if( i >= Bits->Size ) {                   // we got no space at all? how odd?
            return ERROR_FILE_NOT_FOUND;
        }

        // bit "i" is free for us!!

        Error = MemBit1SetOrClear(Bits, i, TRUE, &OldState);
        Require( ERROR_SUCCESS == Error );

        if( ERROR_SUCCESS == Error ) *Offset = i;
        return Error;
    }

    for( i = 0 ; i < Bits->AllocSize ; i ++ ) {
        if( 0xFF != Bits->Mask[i] ) {             // if "i" is part of an exclusion, skip to end of exclusion
            for( j = 0; j < 8; j ++ ) {
                if( !(Bits->Mask[i] & Masks[j] )){// available in the bitmask, but need to check if excluded..
                    DWORD  x;
                    x = 8*i + j;                  // this is the actual bit position in the bitmask
                    if( !IsExcluded(&x, StartAddress, Exclusions) )
                        break;                    // this address is not excluded either..
                    j = x % 8;                    // choose the right offset after exclusion
                    if( x > 8*i + 7 ) { j = 8; i = -1 + x/8; break; }
                }
            }
            if( j < 8 ) break;                    // found a good location..
        }
    }

    if( i >= Bits->AllocSize ) return ERROR_FILE_NOT_FOUND;
    Require( (j <= 7) );

    *Offset = j + 8*i;
    if( *Offset >= Bits->Size ) return ERROR_FILE_NOT_FOUND;

    if( fAcquire ) {
        if( Bits->Size == ++ Bits->nSet ) {
            if( Bits->Mask ) MemFree(Bits->Mask);
            Bits->Mask = NULL;
        } else {
            Bits->Mask[i] |= Masks[j];
        }
        Bits->nDirtyOps ++;
    }
    return ERROR_SUCCESS;
}


DWORD       _inline
MemBit1GetSize(
    IN      PM_BITMASK1           Bits
)
{
    return Bits->Size;
}

DWORD		_inline
MemBit1GetSetBitsInRange(
    IN  PM_BITMASK1 Bits,
    IN  DWORD       dwFrom,
    IN  DWORD       dwTo
)
{
    DWORD i;
    DWORD nOnes;

    // simple case: no bits set to 1
    if (Bits->nSet == 0)
        return 0;

    // simple case: all bits set to 1
    if (Bits->nSet == Bits->Size)
        return dwTo - dwFrom + 1;
	
    // we have both types of bits; scan all the bytes concerned
    for (nOnes = 0, i = dwFrom>>3; i <= dwTo>>3; i++)
    {
        BYTE    Byte, Dup;

        // dwFrom and dwTo should both be in the interval [0 .. Bits->Size-1]
        Byte = Bits->Mask[i];

        if (i == (dwFrom>>3))
        {
            //                                  dwFrom
            //                                     v
            // if first byte in the range: ...|...[.....|...
            // mask Byte with                  000 11111
            Byte &= ~((1 << (dwFrom & 0x00000007)) - 1);
        }
        if (i == (dwTo>>3))
        {
            // if last byte in the range:  ...|......]..|...
            // mask Byte with                  111111 00
            //                                      ^
            //                                     dwTo
            Byte &= (1 << ((dwTo & 0x00000007) + 1)) - 1;
        }
        // now compute the nb. of '1' bits from the Byte.
        // log(8) algorithm

        Byte = (Byte & 0x55) + ((Byte & 0xAA) >> 1);
        Byte = (Byte & 0x33) + ((Byte & 0xCC) >> 2);
        Byte = (Byte & 0x0f) + ((Byte & 0xF0) >> 4);

        nOnes += Byte;
    }

    return nOnes;
}

DWORD       _inline
MemBit1GetSetBitsSize(                            // n Set bits in this bitmask ?
    IN      PM_BITMASK1           Bits
)
{
    return Bits->nSet;
}

DWORD        _inline
MemBit1DelBits(
    IN OUT  PM_BITMASK1           Bits,
    IN      DWORD                 nBits,          // new size after contraction
    IN      BOOL                  fEnd            // delete from end or start ?
)
{
    LPBYTE                        Mask;
    DWORD                         Diff;
    DWORD                         i;
    LONG                          j;

    Bits->nDirtyOps ++;

    Diff = Bits->Size - nBits;
    if( Bits->Size == Bits->nSet ) {
        Bits->Size = Bits->nSet = nBits;
        Bits->AllocSize = (nBits + 8)/8;
        Require(Bits->Mask == NULL);
        return ERROR_SUCCESS;
    }

    if( 0 == Bits->nSet ) {
        Bits->AllocSize = (nBits+8)/8;
        Bits->Size = nBits;
        Require(Bits->Mask == NULL);
        return ERROR_SUCCESS;
    }

    Bits->Size = nBits;
    if( fEnd && Bits->AllocSize == (nBits+8)/8) {
        return ERROR_SUCCESS;
    }

    Mask = MemAlloc((nBits+8)/8);
    if( NULL == Mask ) {
        Require(FALSE);                           // what to do? lets live with it
        Mask = Bits->Mask;                        // just use existing mask
    } else {
        memset(Mask, 0, (nBits+8)/8);
    }

    Bits->AllocSize = (nBits +8)/8;

    if( fEnd ) {
        memmove(Mask, Bits->Mask, Bits->AllocSize);
        if(Mask != Bits->Mask ) MemFree(Bits->Mask);
        Bits->Mask = Mask;
        Bits->nSet = 0;
        for( i = 0; i < Bits->Size ; i ++ )       // re-calculate # of set bits
            if( Mask[i/8] & Masks[i%8] ) Bits->nSet ++;
        return ERROR_SUCCESS;
    }

    Bits->nSet = 0;
    for( j = Bits->Size-1; j >=0 ; j -- ) {
        if( Bits->Mask[(j+Diff)/8] & Masks[(j+Diff)%8] ) {
            Mask[j/8] |= Masks[j%8];
            Bits->nSet ++;
        } else Mask[j/8] &= ~Masks[j%8];
    }

    return ERROR_SUCCESS;
}

const       DWORD                  MaxBit1Size = MAX_BIT1SIZE;

DWORD       _inline
MemBit2Init(
    OUT     PM_BITMASK2           *Bits,
    IN      DWORD                  nBits
)
{
    PM_BITMASK2                    Bits2;
    DWORD                          nBit1;
    DWORD                          i;
    DWORD                          Error;
    DWORD                          RetError;
    DWORD                          Offset;

    Bits2 = MemAlloc(sizeof(*Bits2));
    if( NULL == Bits2 ) return ERROR_NOT_ENOUGH_MEMORY;
    Error = MemArrayInit(&Bits2->Array);
    Require(ERROR_SUCCESS == Error);

    *Bits = Bits2;
    Bits2->Size = nBits;

    nBit1 = nBits/MaxBit1Size;

    Bits2->Array.Ptrs = MemAlloc( sizeof( LPVOID ) * nBit1 );
    if ( NULL == Bits2->Array.Ptrs ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    Bits2->Array.nAllocated = nBit1;

    for( i = 0; i < nBit1; i ++ ) {
        PM_BITMASK1                Bit1;
        Error = MemBit1Init(&Bit1, MaxBit1Size);
        if( ERROR_SUCCESS != Error) break;

        Error = MemArrayAddElement(&Bits2->Array,Bit1);
        if( ERROR_SUCCESS != Error) break;

        Bit1->Offset = i * MaxBit1Size;
    }

    if( ERROR_SUCCESS == Error ) {
        PM_BITMASK1                Bit1;

        MemArrayInitLoc(&Bits2->Array, &((*Bits)->Loc));

        if( 0 == (nBits % MaxBit1Size) ) return ERROR_SUCCESS;

        Error = MemBit1Init(&Bit1, nBits % MaxBit1Size);
        if( ERROR_SUCCESS == Error) {
            Error = MemArrayAddElement(&Bits2->Array, Bit1);
            Bit1->Offset = i * MaxBit1Size;
        }

        if( ERROR_SUCCESS == Error) return ERROR_SUCCESS;
    }

    // error, cleanup
    *Bits = NULL;

    RetError = Error;
    {
        ARRAY_LOCATION             Loc;
        PM_BITMASK1                Bit1;

        Error = MemArrayInitLoc(&Bits2->Array, &Loc);
        while(ERROR_FILE_NOT_FOUND != Error) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(
                &Bits2->Array,
                &Loc,
                (LPVOID*)&Bit1
            );
            Require(ERROR_SUCCESS == Error);

            Error = MemBit1Cleanup(Bit1);
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayNextLoc(&Bits2->Array, &Loc);
        }

        Error = MemArrayCleanup(&Bits2->Array);
        Require(ERROR_SUCCESS == Error);

        MemFree(Bits2);
    }

    return RetError;
}

DWORD      _inline
MemBit2Cleanup(
    IN     PM_BITMASK2             Bits
)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_BITMASK1                    Bit1;

    Require(Bits->Size);
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &Bits->Array,
            &Loc,
            &Bit1
        );
        Require(ERROR_SUCCESS == Error && Bit1);

        Error = MemBit1Cleanup(Bit1);
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }

    Error = MemArrayCleanup(&Bits->Array);
    Require(ERROR_SUCCESS == Error);

    MemFree(Bits);
    return ERROR_SUCCESS;
}

DWORD       _inline
MemBit2SetOrClearAll(
    IN OUT  PM_BITMASK2            Bits,
    IN      BOOL                   fSet
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &Bits->Array,
            &Loc,
            &Bit1
        );
        Require(ERROR_SUCCESS == Error && NULL != Bit1);

        if( fSet ) {
            Error = MemBit1SetAll(Bit1);
        } else {
            Error = MemBit1ClearAll(Bit1);
        }
        Require(ERROR_SUCCESS == Error);
    }

    return ERROR_SUCCESS;
}

DWORD
MemBit2SetOrClear(
    IN OUT  PM_BITMASK2            Bits,
    IN      DWORD                  Location,
    IN      BOOL                   fSet,
    OUT     LPBOOL                 fOldState
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          SkippedSize;
    DWORD                          Size;
    DWORD                          Start, Mid, End;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits && Bits->Size > Location, ERROR_INVALID_PARAMETER);

    //: need to expose a binary search in the array.h module....
    Start = 0;
    End = MemArraySize(&Bits->Array);
    while( Start + 1 < End) {
        Mid = (Start + End)/2;

        Bit1 = Bits->Array.Ptrs[Mid];
        if( Bit1->Offset <= Location ) {
            Start = Mid;
        } else {
            End = Mid;
        }
    }
    Require( Start <= MemArraySize(&Bits->Array));
    Bit1 = Bits->Array.Ptrs[Start];
    Require(Bit1->Offset <= Location && Location <= Bit1->Offset + Bit1->Size);

    return( MemBit1SetOrClear(
            Bit1,
            Location - Bit1 -> Offset,
            fSet,
            fOldState ) );
}

BOOL        _inline
MemBit2IsSet(
    IN OUT  PM_BITMASK2            Bits,
    IN      DWORD                  Location
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          SkippedSize;
    DWORD                          Size;
    DWORD                          Start, Mid, End;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits && Bits->Size > Location, ERROR_INVALID_PARAMETER);

    //: need to expose binary search in the array.h module

    Start = 0;
    End = MemArraySize(&Bits->Array);
    while( Start + 1 < End ) {
        Mid = (Start + End)/2;

        Bit1 = Bits->Array.Ptrs[Mid];
        if( Bit1->Offset <= Location ) {
            Start = Mid;
        } else {
            End = Mid;
        }
    }

    Require( Start <= MemArraySize(&Bits->Array) );
    Bit1 = Bits->Array.Ptrs[Start];

    Require(Bit1->Offset <= Location && Location <= Bit1->Offset + Bit1->Size);

    return MemBit1IsSet(
        Bit1,
        Location - Bit1->Offset
    );
}

DWORD       _inline
MemBit2GetSize(
    IN      PM_BITMASK2            Bits
)
{
    AssertRet(Bits, ERROR_INVALID_PARAMETER );

    return Bits->Size;
}

DWORD		_inline
MemBit2GetSetBitsInRange(
    IN  PM_BITMASK2     Bits,
    IN  DWORD           dwFrom,
    IN  DWORD           dwTo
)
{
    ARRAY_LOCATION  Loc;
    PM_BITMASK1     Bit1;
    DWORD           nOnes;
    DWORD           Error;

    AssertRet(Bits, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    nOnes = 0;
    while(ERROR_FILE_NOT_FOUND != Error)
    {
        Error = MemArrayGetElement(
                    &Bits->Array,
                    &Loc,
                    &Bit1
                );
        Require(ERROR_SUCCESS == Error);

        if (dwTo < Bit1->Offset)
            break;

        if (dwFrom < Bit1->Offset + Bit1->Size)
        {
            if (dwFrom < Bit1->Offset)
                dwFrom = Bit1->Offset;

            nOnes += MemBit1GetSetBitsInRange(Bit1, 
                        dwFrom - Bit1->Offset,
                        dwTo < Bit1->Offset + Bit1->Size ? dwTo - Bit1->Offset: Bit1->Size - 1);
        }

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }
    return nOnes;
}

DWORD       _inline
MemBit2GetSetBitsSize(
    IN      PM_BITMASK2            Bits
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          nSet;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits, ERROR_INVALID_PARAMETER);

    nSet = 0;
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &Bits->Array,
            &Loc,
            &Bit1
        );
        Require(ERROR_SUCCESS == Error);

        nSet += MemBit1GetSetBitsSize(Bit1);

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }
    return nSet;
}

DWORD       _inline
MemBit2DelBits(
    IN OUT  PM_BITMASK2            Bits,
    IN      DWORD                  nBitsToDelete,
    IN      BOOL                   fEnd
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          i;
    DWORD                          Size;
    DWORD                          Error;
    PM_BITMASK1                    Bit1, Bit1x;

    AssertRet(Bits && nBitsToDelete && Bits->Size > nBitsToDelete, ERROR_INVALID_PARAMETER);

    if( fEnd ) {
        Error = MemArrayLastLoc(&Bits->Array, &Loc);
    } else {
        Error = MemArrayInitLoc(&Bits->Array, &Loc);
    }

    Require(ERROR_SUCCESS == Error);
    while( nBitsToDelete ) {
        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error);

        Size = MemBit1GetSize(Bit1);

        if( nBitsToDelete >= Size ) {
            nBitsToDelete -= Size;
            Bits->Size -= Size;

            Error = MemBit1Cleanup(Bit1);
            Require(ERROR_SUCCESS == Error);
            Error = MemArrayDelElement(&Bits->Array, &Loc, &Bit1x);
            Require(ERROR_SUCCESS == Error && Bit1x == Bit1);

            // Reset the ptr to the FIRST/LAST location to read the next element
            if( fEnd ) {
                Error = MemArrayLastLoc(&Bits->Array, &Loc);
            } else {
                Error = MemArrayInitLoc(&Bits->Array, &Loc);
            }
        } else {
            Size -= nBitsToDelete;
            Bits->Size -= nBitsToDelete;

            nBitsToDelete = 0;

            Error = MemBit1DelBits(Bit1, Size, fEnd);
        }
        Require(ERROR_SUCCESS == Error);
    }

    Size = 0;
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error && Bit1);

        Bit1->Offset = Size;
        Size += Bit1->Size;

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }

    MemArrayInitLoc( &Bits->Array, &Bits->Loc);
    
    return NO_ERROR;
}

DWORD       _inline
MemBit2AddBits(
    IN OUT  PM_BITMASK2            Bits,
    IN      DWORD                  nBitsToAdd,
    IN      BOOL                   fEnd
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          i;
    DWORD                          Size;
    DWORD                          Error;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits && nBitsToAdd, ERROR_INVALID_PARAMETER);

    while( nBitsToAdd ) {
        Size = (nBitsToAdd > MaxBit1Size) ? MaxBit1Size : nBitsToAdd;
        nBitsToAdd -= Size;

        Error = MemBit1Init(&Bit1, Size);
        if( ERROR_SUCCESS != Error ) break;

        if( fEnd ) {
            Error = MemArrayAddElement(
                &Bits->Array,
                Bit1
            );
        } else {
            Error = MemArrayInitLoc(&Bits->Array, &Loc);
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayInsElement(
                &Bits->Array,
                &Loc,
                Bit1
            );
        }
        if( ERROR_SUCCESS != Error ) break;
        Bits->Size += Size;
    }

    Size = 0;
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error && Bit1);

        Bit1->Offset = Size;
        Size += Bit1->Size;

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }

    MemArrayInitLoc( &Bits->Array, &Bits->Loc);
        
    return NO_ERROR;
}

DWORD       _inline
MemBit2GetSomeClearedBit(
    IN OUT  PM_BITMASK2            Bits,
    OUT     LPDWORD                Offset,
    IN      BOOL                   fAcquire,      // if we find one, do we Set it?
    IN      DWORD                  StartAddress,
    IN      PARRAY                 Exclusions
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Size;
    DWORD                          Error;
    DWORD                          nBit1s;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits && Offset, ERROR_INVALID_PARAMETER);

    nBit1s = MemArraySize(&Bits->Array);

    while( nBit1s-- != 0 ) {

        Error = MemArrayGetElement(&Bits->Array, &Bits->Loc, (LPVOID *)&Bit1);
        Require(ERROR_SUCCESS == Error);

        Error = MemBit1GetSomeClearedBit(Bit1, &Size, fAcquire, StartAddress+Bit1->Offset, Exclusions);
        if( ERROR_SUCCESS == Error ) {
            *Offset = Bit1->Offset + Size;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Bits->Array, &Bits->Loc);
        if( ERROR_SUCCESS != Error ) {
            Error = MemArrayInitLoc(&Bits->Array, &Bits->Loc);
            Require( ERROR_SUCCESS == Error );
        }
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemBitInit(
    OUT     PM_BITMASK            *Bits,
    IN      DWORD                  nBits
) //EndExport(function)
{
    AssertRet(Bits && nBits, ERROR_INVALID_PARAMETER);

    return MemBit2Init(Bits,nBits);
}

//BeginExport(function)
DWORD
MemBitCleanup(
    IN OUT  PM_BITMASK             Bits
) //EndExport(function)
{
    AssertRet(Bits, ERROR_INVALID_PARAMETER);

    return MemBit2Cleanup(Bits);
}

//BeginExport(function)
DWORD
MemBitSetOrClearAll(
    IN OUT  PM_BITMASK             Bits,
    IN      BOOL                   fSet
) //EndExport(function)
{
    return MemBit2SetOrClearAll(Bits,fSet);
}

//BeginExport(function)
DWORD
MemBitSetOrClear(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  Location,
    IN      BOOL                   fSet,
    IN      LPBOOL                 fOldState
) //EndExport(function)
{
    return  MemBit2SetOrClear(Bits,Location,fSet, fOldState);
}


//BeginExport(function)
BOOL
MemBitIsSet(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  Location
) //EndExport(function)
{
    BOOL                           Test;
    Test = MemBit2IsSet(Bits, Location);
    return Test;
}

//BeginExport(function)
DWORD
MemBitGetSize(
    IN      PM_BITMASK             Bits
) //EndExport(function)
{
    return MemBit2GetSize(Bits);
}

//BeginExport(function)
DWORD
MemBitGetSetBitsInRange(
    IN      PM_BITMASK             Bits,
    IN      DWORD                  dwFrom,
    IN      DWORD                  dwTo
) //EndExport(function)
{
    return MemBit2GetSetBitsInRange(Bits, dwFrom, dwTo);
}

//BeginExport(function)
DWORD
MemBitGetSetBitsSize(
    IN      PM_BITMASK             Bits
) //EndExport(function)
{
    return MemBit2GetSetBitsSize(Bits);
}

//BeginExport(function)
DWORD
MemBitAddOrDelBits(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  nBitsToAddOrDelete,
    IN      BOOL                   fAdd,
    IN      BOOL                   fEnd
) //EndExport(function)
{
    if( fAdd ) return MemBit2AddBits(Bits, nBitsToAddOrDelete, fEnd);
    return MemBit2DelBits(Bits,nBitsToAddOrDelete, fEnd);
}

//BeginExport(function)
DWORD
MemBitGetSomeClearedBit(
    IN OUT  PM_BITMASK             Bits,
    OUT     DWORD                 *Offset,
    IN      BOOL                   fAcquire,     // Acquire or just lookup?
    IN      DWORD                  StartAddress,
    IN      PARRAY                 Exclusions
) //EndExport(function)
{
    return MemBit2GetSomeClearedBit(Bits,Offset,fAcquire, StartAddress, Exclusions);
}

//BeginExport(function)
DWORD
MemBitConvertToCluster(
    IN      PM_BITMASK             Bits,
    IN      DWORD                  StartAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClustersSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) //EndExport(function)
{
    DWORD                           Error;
    DWORD                           Cluster;
    DWORD                           i, j;
    DWORD                           nBits;
    DWORD                           nBit1s;
    DWORD                           Size;
    DWORD                           UsedSize;
    DWORD                           InUseSize;
    LPDWORD                         Used;
    LPDWORD                         InUse;
    PM_BITMASK1                     Bit1;
    ARRAY_LOCATION                  Loc;

    nBits = MemBitGetSize(Bits);
    if( 0 == nBits || 0 == MemBitGetSetBitsSize(Bits) ) {
        InUse = MemAlloc(sizeof(DWORD));
        Used = MemAlloc(sizeof(DWORD));
        if( NULL == InUse || NULL == Used ) {
            if( InUse ) MemFree(InUse);
            if( Used ) MemFree(Used);
            Require(FALSE);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        *Used = *InUse = 0;
        *InUseClusters = (LPBYTE)InUse;
        *UsedClusters = (LPBYTE)Used;
        *InUseClustersSize = *UsedClustersSize = sizeof(DWORD);
        return ERROR_SUCCESS;
    }

    nBit1s = MemArraySize(&Bits->Array);
    Require(nBit1s);
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    UsedSize = InUseSize = 1;                     // no matter what, we always use a DWORD for total size
    for(i = 0; i < nBit1s ; i ++ ) {
        Require(ERROR_SUCCESS == Error);
        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error && Bit1);
        Error = MemArrayNextLoc(&Bits->Array, &Loc);

        // : Dont touch Bit1 directly like below? not really clean
        if( 0 == Bit1->nSet ) continue;           // no bit is set, nothing to do..
        if( Bit1->Size == Bit1->nSet ) {          // all bits set, nothing to do except for few odd bits
            UsedSize += Bit1->Size/32;
            if( Bit1->Size % 32 ) InUseSize+=2;   // fill the odd bits in InUse so that we dont mark extra bits as used
            continue;
        }

        for( j = 0; j < Bit1->Size/32; j ++ ) {
            if( 0xFFFFFFFF == ((LPDWORD)(Bit1->Mask))[j] ) {
                UsedSize ++;                      // this 32-bit is completely filled
            } else if ( 0 != ((LPDWORD)(Bit1->Mask))[j]) {
                InUseSize += 2;                   // this 32 bit is partially filled, not quite empty
            }
        }
        if( j * 32 < Bit1->Size ) InUseSize +=2;  // for the last few bits..
    }

    InUse = MemAlloc(InUseSize * sizeof(DWORD));
    Used  = MemAlloc(UsedSize * sizeof(DWORD));
    if( NULL == Used || NULL == InUse ) {
        if( InUse ) MemFree(InUse);
        if( Used ) MemFree(Used);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *InUseClustersSize = sizeof(DWORD)*InUseSize; // fill in the sizes and ptrs to be returned..
    *InUseClusters = (LPBYTE)InUse;
    *UsedClusters = (LPBYTE)Used;
    *UsedClustersSize = sizeof(DWORD)*UsedSize;

    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    UsedSize = InUseSize = 1;
    for(i = 0; i < nBit1s ; i ++ ) {
        Require(ERROR_SUCCESS == Error);
        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error && Bit1);
        Error = MemArrayNextLoc(&Bits->Array, &Loc);

        //  Dont touch Bit1 directly like below? not really clean
        if( 0 == Bit1->nSet ) {                   // all bits clear ==> just ignore
            StartAddress += Bit1->Size;
            continue;
        }
        if( Bit1->nSet == Bit1->Size ) {          // handle all bits set here (loose bits need to be handled later)
            for( j = 0; j < Bit1->Size/32; j ++ ) {
                Used[UsedSize++] = StartAddress + sizeof(DWORD)*j*8;
            }
        } else {
            for( j = 0; j < Bit1->Size/32; j ++ ) {
                if( 0xFFFFFFFF == ((LPDWORD)(Bit1->Mask))[j] ) {
                    Used[UsedSize++] = StartAddress + sizeof(DWORD)*j*8;
                } else if ( 0 != ((LPDWORD)(Bit1->Mask))[j]) {
#ifdef _X86_                                      // on X86, the first byte is the lowest order byte..
                    Cluster = ((LPDWORD)(Bit1->Mask))[j];
#else                                             // it maynot be so on other machines, so combine the bytes manually..
                    Cluster = Bit1->Mask[j*sizeof(DWORD)];
                    Cluster |= (Bit1->Mask[j*sizeof(DWORD)+1]) << 8;
                    Cluster |= (Bit1->Mask[j*sizeof(DWORD)+2]) << 16;
                    Cluster |= (Bit1->Mask[j*sizeof(DWORD)+3]) << 24;
#endif
                    InUse[InUseSize++] = StartAddress + sizeof(DWORD)*j*8;
                    InUse[InUseSize++] = Cluster;
                }
            }
        }

        if( j * 32 < Bit1->Size ) {               // copy the last few bits off..
            InUse[InUseSize++] = StartAddress + sizeof(DWORD)*j*8;
            Cluster = 0;
            j *= 32;
            while( j < Bit1->Size ) {
                if( MemBit1IsSet(Bit1, j) ) Cluster |= (1 << (j%32));
                j ++;
            }
            InUse[InUseSize++] = Cluster;
        }

        StartAddress += Bit1->Size;               // move the start address fwd for the next set..
    }

    InUse[0] = (InUseSize -1)/2;                  // size in header does not include itself
    Used[0] = UsedSize -1;                        // it is just the # of CLUSTERS..

    Require(InUseSize*sizeof(DWORD) == *InUseClustersSize);
    Require(UsedSize*sizeof(DWORD) == *UsedClustersSize);
    return ERROR_SUCCESS;
}

//================================================================================
// End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\bitmask.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _MM_BITMASK_H_
#define _MM_BITMASK_H_

typedef struct _M_EXCL {
    DWORD                          Start;
    DWORD                          End;
    ULONG                          UniqId;
} M_EXCL, *PM_EXCL, *LPM_EXCL;


#define MM_FLAG_ALLOW_DHCP         0x1
#define MM_FLAG_ALLOW_BOOTP        0x2


typedef struct _M_BITMASK1 {
    DWORD                          Size;          // Size in # of bits
    DWORD                          AllocSize;     // Size in BYTES allocated
    DWORD                          nSet;          // nBits set
    LPBYTE                         Mask;          // BUBBUG making this DWORD would make things faster..
    DWORD                          Offset;        // used by Bit2 type..
    ULONG                          nDirtyOps;     // # of unsaved operations done on this bitmask?
} M_BITMASK1, *PM_BITMASK1, *LPM_BITMASK1;


typedef struct _M_BITMASK2 {
    DWORD                          Size;
    ARRAY_LOCATION                 Loc;           // where to start off to look for a bit
    ARRAY                          Array;         // Array of bitmask 1 types
} M_BITMASK2, *PM_BITMASK2, *LPM_BITMASK2;

typedef     M_BITMASK2             M_BITMASK;
typedef     PM_BITMASK2            PM_BITMASK;
typedef     LPM_BITMASK2           LPM_BITMASK;


#define     MAX_BIT1SIZE           (512*4)


DWORD
MemBitInit(
    OUT     PM_BITMASK            *Bits,
    IN      DWORD                  nBits
) ;


DWORD
MemBitCleanup(
    IN OUT  PM_BITMASK             Bits
) ;


DWORD
MemBitSetOrClearAll(
    IN OUT  PM_BITMASK             Bits,
    IN      BOOL                   fSet
) ;


DWORD
MemBitSetOrClear(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  Location,
    IN      BOOL                   fSet,
    IN      LPBOOL                 fOldState
) ;


BOOL
MemBitIsSet(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  Location
) ;


DWORD
MemBitGetSize(
    IN      PM_BITMASK             Bits
) ;


DWORD
MemBitGetSetBitsInRange(
    IN      PM_BITMASK             Bits,
    IN      DWORD                  dwFrom,
    IN      DWORD                  dwTo
) ;


DWORD
MemBitGetSetBitsSize(
    IN      PM_BITMASK             Bits
) ;


DWORD
MemBitAddOrDelBits(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  nBitsToAddOrDelete,
    IN      BOOL                   fAdd,
    IN      BOOL                   fEnd
) ;


DWORD
MemBitGetSomeClearedBit(
    IN OUT  PM_BITMASK             Bits,
    OUT     DWORD                 *Offset,
    IN      BOOL                   fAcquire,     // Acquire or just lookup?
    IN      DWORD                  StartAddress,
    IN      PARRAY                 Exclusions
) ;


DWORD
MemBitConvertToCluster(
    IN      PM_BITMASK             Bits,
    IN      DWORD                  StartAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClustersSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) ;

#endif

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\array.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _ARRAY {
    DWORD                          nElements;
    DWORD                          nAllocated;
    LPVOID                        *Ptrs;
} ARRAY, *PARRAY, *LPARRAY;


typedef DWORD                      ARRAY_LOCATION;
typedef ARRAY_LOCATION*            PARRAY_LOCATION;
typedef PARRAY_LOCATION            LPARRAY_LOCATION;


DWORD _inline
MemArrayInit(                                     // initialize the STRUCTURE
    OUT     PARRAY                 Array          // input structure pre-allocated
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    Array->nElements = Array->nAllocated = 0;
    Array->Ptrs = NULL;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArrayCleanup(                                  // freeup the memory if any, allocated in this module
    IN OUT  PARRAY                 Array
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    if( Array->Ptrs) MemFree(Array->Ptrs);
    Array->nElements = Array->nAllocated = 0;
    Array->Ptrs = NULL;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArraySize(
    IN      PARRAY                 Array
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    return Array->nElements;
}


DWORD _inline
MemArrayInitLoc(                                  // Initialize an array location
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    (*Location) = 0;
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}


BOOL _inline
MemArrayValidLoc(
    IN      PARRAY                 Array,
    IN      PARRAY_LOCATION        Location
)
{
    AssertRet(Array && Location, FALSE);

    return ( *Location < Array->nElements );
}


DWORD _inline
MemArrayNextLoc(                                  // move one step forward
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( (*Location) + 1  >= Array->nElements ) return ERROR_FILE_NOT_FOUND;
    (*Location) ++;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArrayPrevLoc(
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    if( ((LONG)(*Location)) - 1 < 0 ) return ERROR_FILE_NOT_FOUND;
    (*Location) --;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArrayLastLoc(
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    (*Location) = Array->nElements -1;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArrayGetElement(
    IN      PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    OUT     LPVOID                *Element
) {
    AssertRet(Array && Location && Element, ERROR_INVALID_PARAMETER);
    (*Element) = Array->Ptrs[*Location];
    return ERROR_SUCCESS;
}


DWORD _inline
MemArraySetElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                 Element
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER );
    Array->Ptrs[*Location] = Element;
    return ERROR_SUCCESS;
}


DWORD
MemArrayAddElement(
    IN OUT  PARRAY                 Array,
    IN      LPVOID                 Element
) ;


DWORD
MemArrayInsElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                 Element
) ;


DWORD
MemArrayDelElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                *Element
) ;


DWORD        _inline
MemArrayAdjustLocation(                           // reset location to "next" after a delete
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Location && Array, ERROR_INVALID_PARAMETER);

    if( *Location >= Array->nElements ) return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}


DWORD       _inline
MemArrayRotateCyclical(                           // rotate forward/right cyclical
    IN      PARRAY                 Array
) {
    LPVOID                         FirstPtr;

    AssertRet(Array, ERROR_INVALID_PARAMETER);

    if( Array->nElements < 2 ) return ERROR_SUCCESS;
    FirstPtr = Array->Ptrs[0];
    memcpy(Array->Ptrs, &Array->Ptrs[1], sizeof(Array->Ptrs[0])* (Array->nElements -1));
    Array->Ptrs[Array->nElements -1] = FirstPtr;

    return ERROR_SUCCESS;
}

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\classdefl.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _MM_CLASSDEFL_H_
#define _MM_CLASSDEFL_H_

#include <dhcp.h>

typedef struct _M_CLASSDEF {
    DWORD                          RefCount;
    DWORD                          ClassId;
    BOOL                           IsVendor;
    DWORD                          Type;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    DWORD                          nBytes;
    LPBYTE                         ActualBytes;
    ULONG                          UniqId;
} M_CLASSDEF, *PM_CLASSDEF, *LPM_CLASSDEF;

typedef struct _M_CLASSDEFLIST {
    ARRAY                          ClassDefArray;
} M_CLASSDEFLIST, *PM_CLASSDEFLIST, *LPM_CLASSDEFLIST;


DWORD       _inline
MemClassDefListInit(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
) {
    return MemArrayInit(&ClassDefList->ClassDefArray);
}


DWORD       _inline
MemClassDefListCleanup(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
) {
    return MemArrayCleanup(&ClassDefList->ClassDefArray);
}


DWORD
MemClassDefListFindClassDefInternal(              // dont use this fn outside of classdefl.c
    IN      PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes,
    IN      LPBOOL                 pIsVendor,
    OUT     PARRAY_LOCATION        Location
) ;


DWORD       _inline
MemClassDefListFindOptDef(                        // search either by ClassId or by Actual bytes and fill matched stuff
    IN      PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes,
    OUT     PM_CLASSDEF           *ClassDef       // NULL or valid matching class def
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;

    AssertRet(ClassDef, ERROR_INVALID_PARAMETER);

    Error = MemClassDefListFindClassDefInternal(
        ClassDefList,
        ClassId,
        Name,
        ActualBytes,
        nBytes,
        NULL,
        &Location
    );
    if( ERROR_SUCCESS != Error) return Error;

    Error = MemArrayGetElement(
        &ClassDefList->ClassDefArray,
        &Location,
        (LPVOID*)ClassDef
    );
    Require(ERROR_SUCCESS == Error);

    return Error;
}

//BeginExport(function)

DWORD
MemClassDefListAddClassDef(                       // Add or replace option
    IN OUT  PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      BOOL                   IsVendor,
    IN      DWORD                  Type,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes,
    IN      ULONG                  UniqId
) ;


DWORD
MemClassDefListDelClassDef(
    IN OUT  PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes
);

DWORD       _inline
MemClassDefListGetRefCount(
    IN      PM_CLASSDEF            ThisClassDef
) {
    return ThisClassDef->RefCount;
}


DWORD       _inline
MemClassDefListIncRefCount(                       // return increased by one value
    IN      PM_CLASSDEF            ThisClassDef
) {
    return ++ThisClassDef->RefCount;
}


DWORD       _inline
MemClassDefListDecRefCount(                       // return decreased by one value
    IN      PM_CLASSDEF            ThisClassDef
) {
    return --ThisClassDef->RefCount;
}


DWORD
MemNewClassId(
    VOID
) ;


#endif // _MM_CLASSDEFL_H_

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\memfree.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: Routines to recursively free objects
//================================================================================

#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>
#include    <address.h>

//BeginExport(typedef)
typedef     VOID                  (*ARRAY_FREE_FN)(LPVOID  MemObject);
//EndExport(typedef)

//BeginExport(function)
VOID
MemArrayFree(
    IN OUT  PARRAY                 Array,
    IN      ARRAY_FREE_FN          Function
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    LPVOID                         Element;

    Error = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, &Element);
        Require(ERROR_SUCCESS == Error && Element);

        Function(Element);

        Error = MemArrayNextLoc(Array, &Loc);
    }

    Require(ERROR_FILE_NOT_FOUND == Error);

    Error = MemArrayCleanup(Array);
    Require(ERROR_SUCCESS == Error);
}

//BeginExport(function)
VOID
MemOptFree(
    IN OUT  PM_OPTION              Opt
) //EndExport(function)
{
    MemFree(Opt);
}

//BeginExport(function)
VOID
MemOptListFree(
    IN OUT  PM_OPTLIST             OptList
) //EndExport(function)
{
    MemArrayFree(OptList, MemOptFree);
}

//BeginExport(function)
VOID
MemOptClassOneFree(
    IN OUT  PM_ONECLASS_OPTLIST    OptClassOne
) //EndExport(function)
{
    MemOptListFree(&OptClassOne->OptList);
    MemFree(OptClassOne);
}

//BeginExport(function)
VOID
MemOptClassFree(
    IN OUT  PM_OPTCLASS            Options
) //EndExport(function)
{
    MemArrayFree(&Options->Array, MemOptClassOneFree);
}

VOID
MemBitMaskFree(
    IN OUT  PM_BITMASK             BitMask
) //EndExport(Function)
{
    MemBitCleanup(BitMask);
}

//BeginExport(function)
VOID
MemRangeFree(
    IN OUT  PM_RANGE               Range
) //EndExport(function)
{
    MemOptClassFree(&Range->Options);
    MemBitMaskFree(Range->BitMask);
    MemFree(Range);
}

//BeginExport(function)
VOID
MemExclusionFree(
    IN OUT  PM_EXCL                Excl
) //EndExport(function)
{
    MemFree(Excl);
}

//BeginExport(function)
VOID
MemReservationFree(
    IN OUT  PM_RESERVATION         Reservation
) //EndExport(function)
{
    MemOptClassFree(&Reservation->Options);
    MemFree(Reservation);
}

//BeginExport(function)
VOID
MemReservationsFree(
    IN OUT  PM_RESERVATIONS        Reservations
) //EndExport(function)
{
    MemArrayFree(Reservations, MemReservationFree);
}

//BeginExport(function)
VOID
MemSubnetFree(
    IN OUT  PM_SUBNET              Subnet
)//EndExport(function)
{
    MemOptClassFree(&Subnet->Options);
    MemArrayFree(&Subnet->Ranges, MemRangeFree);
    MemArrayFree(&Subnet->Exclusions, MemExclusionFree);
    MemReservationsFree(&Subnet->Reservations);

    MemFree(Subnet);
}

//BeginExport(function)
VOID
MemMScopeFree(
    IN OUT  PM_MSCOPE              MScope
)//EndExport(function)
{
    MemSubnetFree(MScope);
}

//BeginExport(function)
VOID
MemOptDefFree(
    IN OUT  PM_OPTDEF              OptDef
) //EndExport(function)
{
    MemFree(OptDef);
}

//BeginExport(function)
VOID
MemOptDefListFree(
    IN OUT  PM_OPTCLASSDEFL_ONE    OptClassDefListOne
) //EndExport(function)
{
    MemArrayFree(&OptClassDefListOne->OptDefList.OptDefArray, MemOptDefFree);
    MemFree(OptClassDefListOne);
}

//BeginExport(function)
VOID
MemOptClassDefListFree(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) //EndExport(function)
{
    MemArrayFree(&OptClassDefList->Array, MemOptDefListFree);
}

//BeginExport(function)
VOID
MemClassDefFree(
    IN OUT  PM_CLASSDEF            ClassDef
) //EndExport(function)
{
    MemFree(ClassDef);
}

//BeginExport(function)
VOID
MemClassDefListFree(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
)//EndExport(function)
{
    MemArrayFree(&ClassDefList->ClassDefArray, MemClassDefFree);
}



//BeginExport(function)
VOID
MemServerFree(
    IN OUT  PM_SERVER              Server
) //EndExport(function)
{
    MemArrayFree(&Server->Subnets, MemSubnetFree);
    MemArrayFree(&Server->MScopes, MemMScopeFree);
    MemOptClassFree(&Server->Options);
    MemOptClassDefListFree(&Server->OptDefs);
    MemClassDefListFree(&Server->ClassDefs);

    MemFree(Server);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\memfree.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef     VOID                  (*ARRAY_FREE_FN)(LPVOID  MemObject);


VOID
MemArrayFree(
    IN OUT  PARRAY                 Array,
    IN      ARRAY_FREE_FN          Function
) ;


VOID
MemOptFree(
    IN OUT  PM_OPTION              Opt
) ;


VOID
MemOptListFree(
    IN OUT  PM_OPTLIST             OptList
) ;


VOID
MemOptClassOneFree(
    IN OUT  PM_ONECLASS_OPTLIST    OptClassOne
) ;


VOID
MemOptClassFree(
    IN OUT  PM_OPTCLASS            Options
) ;



VOID
MemRangeFree(
    IN OUT  PM_RANGE               Range
) ;


VOID
MemExclusionFree(
    IN OUT  PM_EXCL                Excl
) ;


VOID
MemReservationFree(
    IN OUT  PM_RESERVATION         Reservation
) ;


VOID
MemReservationsFree(
    IN OUT  PM_RESERVATIONS        Reservations
) ;


VOID
MemSubnetFree(
    IN OUT  PM_SUBNET              Subnet
) ;


VOID
MemMScopeFree(
    IN OUT  PM_MSCOPE              MScope
) ;


VOID
MemOptDefFree(
    IN OUT  PM_OPTDEF              OptDef
) ;


VOID
MemOptDefListFree(
    IN OUT  PM_OPTCLASSDEFL_ONE    OptClassDefListOne
) ;


VOID
MemOptClassDefListFree(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) ;


VOID
MemClassDefFree(
    IN OUT  PM_CLASSDEF            ClassDef
) ;


VOID
MemClassDefListFree(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
) ;


VOID
MemServerFree(
    IN OUT  PM_SERVER              Server
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\mm.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: some useful defines and other information
//================================================================================

#ifndef     UNICODE
#define     UNICODE 1
#endif      UNICODE
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <windef.h>
#include    <winbase.h>
#include    <winuser.h>
#include    <align.h>
#include    <dhcp.h>    // need this for DATE_TIME

#if         DBG

VOID        _inline
RequireF(
    IN      LPSTR                  Condition,
    IN      LPSTR                  FileName,
    IN      DWORD                  LineNumber
) {
    RtlAssert(Condition, FileName, LineNumber, "RequireF" );
}

#define     Require(X)             do{ if( !(X) ) RequireF(#X, __FILE__, __LINE__ ); } while(0)
#define     AssertRet(X,Y)         do { if( !(X) ) { RequireF(#X, __FILE__, __LINE__); return Y; } } while(0)

#else       DBG

#define     Require(X)
#define     AssertRet(X,Y)         do { if( !(X) ) { return Y; } } while (0)

#endif      DBG

#include    <..\mm\mminit.h>

#define     DebugPrint2(X,Y)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\classdefl.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for a list of class defintitions
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include <mm.h>
#include <array.h>
#include <wchar.h>

#include "classdefl.h"

#include "server\uniqid.h"


//BeginExport(function)
DWORD
MemClassDefListFindClassDefInternal(              // dont use this fn outside of classdefl.c
    IN      PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes,
    IN      LPBOOL                 pIsVendor,
    OUT     PARRAY_LOCATION        Location
) //EndExport(function)
{
    DWORD                          Error;
    PM_CLASSDEF                    ThisClassDef;

    for( Error = MemArrayInitLoc(&ClassDefList->ClassDefArray, Location)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&ClassDefList->ClassDefArray, Location)
    ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &ClassDefList->ClassDefArray,
            Location,
            (LPVOID *)&ThisClassDef
        );
        Require(ERROR_SUCCESS == Error && ThisClassDef);

        if( pIsVendor != NULL && ThisClassDef->IsVendor != *pIsVendor)
            continue;

        if( ThisClassDef->ClassId == ClassId ) {
            return ERROR_SUCCESS;
        }

        if( nBytes == ThisClassDef->nBytes ) {
            if( 0 == memcmp(ActualBytes, ThisClassDef->ActualBytes, nBytes)) {
                return ERROR_SUCCESS;
            }
        }

        if( Name && 0 == wcscmp(ThisClassDef->Name, Name) ) {
            return ERROR_SUCCESS;
        }
    }

    return ERROR_FILE_NOT_FOUND;
} // MemClassDefListFindClassDefInternal()


DWORD
MemClassDefListDelClassDef(
    IN OUT  PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes
) 
{
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    PM_CLASSDEF                    ThisClassDef;

    Error = MemClassDefListFindClassDefInternal(
        ClassDefList,
        ClassId,
        Name,
        ActualBytes,
        nBytes,
        NULL,
        &Location
    );
    if( ERROR_SUCCESS != Error ) return Error;

    // Delete this class def from the database
    Error = MemArrayGetElement( &ClassDefList->ClassDefArray,
				&Location, 
				&ThisClassDef );
    Require( ERROR_SUCCESS == Error );
    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }
    
    Error = DeleteRecord( ThisClassDef->UniqId );
    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }

    Error = MemArrayDelElement(
        &ClassDefList->ClassDefArray,
        &Location,
        &ThisClassDef
    );
    Require(ERROR_SUCCESS == Error && ThisClassDef);

    MemFree(ThisClassDef);
    return ERROR_SUCCESS;

} // MemClassDefListDelClassDef()

//BeginExport(function)
DWORD
MemClassDefListAddClassDef(                       // Add or replace option
    IN OUT  PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      BOOL                   IsVendor,
    IN      DWORD                  Type,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes,
    IN      ULONG                  UniqId
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    DWORD                          Size;
    PM_CLASSDEF                    ThisClassDef;
    PM_CLASSDEF                    OldClassDef;

    AssertRet(ClassDefList && ClassId && Name && ActualBytes && nBytes, ERROR_INVALID_PARAMETER );

    Error = MemClassDefListFindClassDefInternal(
        ClassDefList,
        ClassId,
        Name,
        ActualBytes,
        nBytes,
        &IsVendor,
        &Location
    );

    Size = sizeof(M_CLASSDEF)+nBytes;
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    Size += (1+wcslen(Name))*sizeof(WCHAR);
    if( Comment ) Size += (1+wcslen(Comment))*sizeof(WCHAR);

    ThisClassDef = MemAlloc(Size);
    if( NULL == ThisClassDef ) return ERROR_NOT_ENOUGH_MEMORY;

    ThisClassDef->RefCount = 1;
    ThisClassDef->ClassId = ClassId;
    ThisClassDef->IsVendor = IsVendor;
    ThisClassDef->Type = Type;
    ThisClassDef->nBytes = nBytes;
    ThisClassDef->ActualBytes = sizeof(M_CLASSDEF) + (LPBYTE)ThisClassDef;
    memcpy(ThisClassDef->ActualBytes, ActualBytes, nBytes);
    ThisClassDef->Name = (LPWSTR)(ROUND_UP_COUNT(sizeof(M_CLASSDEF)+nBytes, ALIGN_WORST) + (LPBYTE)ThisClassDef);
    wcscpy(ThisClassDef->Name, Name);
    if( Comment ) {
        ThisClassDef->Comment = 1 + wcslen(Name) + ThisClassDef->Name;
        wcscpy(ThisClassDef->Comment, Comment);
    } else {
        ThisClassDef->Comment = NULL;
    }

    ThisClassDef->UniqId = UniqId;

    if( ERROR_SUCCESS == Error ) {
        DebugPrint2("Overwriting class definition for class-id 0x%lx\n", ClassId);
        Error = MemArrayGetElement(
            &ClassDefList->ClassDefArray,
            &Location,
            (LPVOID *)&OldClassDef
        );
        Require(ERROR_SUCCESS == Error);

	Error = DeleteRecord( OldClassDef->UniqId );
        MemFree(OldClassDef);

	Require( ERROR_SUCCESS == Error );
	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}

        Error = MemArraySetElement(
            &ClassDefList->ClassDefArray,
            &Location,
            ThisClassDef
        );
        Require(ERROR_SUCCESS == Error);
        return Error;
    } // if

    Error = MemArrayAddElement(
        &ClassDefList->ClassDefArray,
        ThisClassDef
    );
    if( ERROR_SUCCESS != Error ) MemFree(ThisClassDef);

    return Error;
} // MemClassDefListAddClassDef()


ULONG                  ClassIdRunningCount = 100;

//BeginExport(function)
DWORD
MemNewClassId(
    VOID
) //EndExport(function)
{
    return InterlockedIncrement(&ClassIdRunningCount);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\mminit.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: some memory handling stuff
//================================================================================

#include <mm.h>
#include <align.h>

#if  DBG
#define     STATIC          static
#else
#define     STATIC
#endif

STATIC      HANDLE                 MemHeapHandle = NULL;
static      DWORD                  Initialized = FALSE;
static      DWORD                  UseHeap = 0;
ULONG                              MemNBytesAllocated = 0;

//BeginExport(function)
DWORD
MemInit(
    VOID
) //EndExport(function)
{
    Require(Initialized == FALSE);
    MemHeapHandle = HeapCreate(
        /* flOptions     */ 0,
        /* dwInitialSize */ 64000,
        /* dwMaximumSize */ 0
    );
    if( MemHeapHandle == NULL ) return GetLastError();
    Initialized = TRUE;
    UseHeap = 1;
    return ERROR_SUCCESS;
}

//BeginExport(function)
VOID
MemCleanup(
    VOID
) //EndExport(function)
{
    BOOL                           Status;

    if( 0 == Initialized ) return;
    Initialized --;
    Require(MemHeapHandle);
    Status = HeapDestroy(MemHeapHandle);
    MemHeapHandle = NULL;
    Require(FALSE != Status);
    Require(0 == Initialized);
    UseHeap = 0;
}

LPVOID  _inline
MemAllocInternal(
    IN      DWORD                  nBytes
)
{
    LPVOID                         Ptr;
    if( 0 == UseHeap ) {
        Ptr = LocalAlloc(LMEM_FIXED, nBytes);
        // DbgPrint("MEM %08lx ALLOC\n", Ptr);
        return Ptr;
    }

    if( NULL == MemHeapHandle ) return NULL;

    return HeapAlloc(
        /* hHeap    */ MemHeapHandle,
        /* dwFlags  */ HEAP_ZERO_MEMORY,
        /* dwBytes  */ nBytes
    );
}

DWORD  _inline
MemFreeInternal(
    IN      LPVOID                 Mem
)
{
    BOOL                           Status;

    // DbgPrint("MEM %08lx FREE\n", Mem);

    if( 0 == UseHeap ) {
        if(NULL == LocalFree(Mem) )
            return ERROR_SUCCESS;
        return ERROR_INVALID_DATA;
    }

    if( NULL == MemHeapHandle ) {
        Require(FALSE);
        return ERROR_INVALID_DATA;
    }

    Status = HeapFree(
        /* hHeap   */ MemHeapHandle,
        /* dwFlags */ 0,
        /* lpMem   */ Mem
    );

    if( FALSE != Status ) return ERROR_SUCCESS;
    return GetLastError();
}

//BeginExport(function)
LPVOID
MemAlloc(
    IN      DWORD                  nBytes
) //EndExport(function)
{
    LPVOID                         Ptr;

#if DBG
    Ptr = MemAllocInternal(ROUND_UP_COUNT(nBytes + sizeof(ULONG_PTR), ALIGN_WORST));
    if( NULL == Ptr ) return Ptr;
    *((ULONG_PTR *)Ptr) ++ = nBytes;
    InterlockedExchangeAdd(&MemNBytesAllocated, nBytes);
    return Ptr;
#endif

    return MemAllocInternal(nBytes);
}


//BeginExport(function)
DWORD 
MemFree(
    IN      LPVOID                 Mem
) //EndExport(function)
{
    LPVOID                         Ptr;

#if DBG
    Ptr = -1 + (ULONG_PTR *)Mem;
    InterlockedExchangeAdd(&MemNBytesAllocated, - (LONG)(*(ULONG *)Ptr) );
    return MemFreeInternal(Ptr);
#endif

    return MemFreeInternal(Mem);

}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\mmdump.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

VOID
MmDumpOption(
    IN      ULONG                  InitTab,
    IN      PM_OPTION              Option
) ;


VOID
MmDumpOptList(
    IN      ULONG                  InitTab,
    IN      PM_OPTLIST             OptList
) ;


VOID
MmDumpOneClassOptList(
    IN      ULONG                  InitTab,
    IN      PM_ONECLASS_OPTLIST    OptList1
) ;


VOID
MmDumpOptions(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASS            OptClass
) ;


VOID
MmDumpReservation(
    IN      ULONG                  InitTab,
    IN      PM_RESERVATION         Res
) ;


VOID
MmDumpRange(
    IN      ULONG                  InitTab,
    IN      PM_RANGE               Range
) ;


VOID
MmDumpExclusion(
    IN      ULONG                  InitTab,
    IN      PM_EXCL                Range
) ;


VOID
MmDumpSubnets(
    IN      ULONG                  InitTab,
    IN      PM_SUBNET              Subnet
) ;


VOID
MmDumpSscope(
    IN      ULONG                  InitTab,
    IN      PM_SSCOPE              Sscope
) ;


VOID
MmDumpOptDef(
    IN      ULONG                  InitTab,
    IN      PM_OPTDEF              OptDef
) ;


VOID
MmDumpOptClassDefListOne(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASSDEFL_ONE    OptDefList1
) ;


VOID
MmDumpOptClassDefList(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASSDEFLIST     OptDefList
) ;


VOID
MmDumpClassDef(
    IN      ULONG                  InitTab,
    IN      PM_CLASSDEF            ClassDef
) ;


VOID
MmDumpClassDefList(
    IN      ULONG                  InitTab,
    IN      PM_CLASSDEFLIST        ClassDefList
) ;


VOID
MmDumpServer(
    IN      ULONG                  InitTab,        // how much to tab initially..
    IN      PM_SERVER              Server
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\mmdump.c ===
//================================================================================
//  Copyright (C) 1998 Microsoft Corporation
//  Author: RameshV
//  Decription: This module just dumps several types of objects to the debugger.
//   This can be easily modified to be a ntsd extension etc..
//   No separate description is given as this is not supposed to be used for
//   regular use.  This is just there for diagnostic purposes.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>
#include    <winsock2.h>
#include    <stdio.h>

#define TAB                        do{int i = InitTab ; while(i--) printf("\t"); }while(0)

typedef
VOID
DUMPFUNC(                                          // any phonetic resemblance to "dum fuk" is purely incidental..
    IN      ULONG                  InitTab,
    IN      LPVOID                 Struct
);

static
VOID
DumpArray(
    IN      PARRAY                 Array,
    IN      ULONG                  InitTab,
    IN      DUMPFUNC               Func
)
{
    ARRAY_LOCATION                 Loc;
    LPVOID                         ThisElt;
    DWORD                          Err;

    for( Err = MemArrayInitLoc(Array, &Loc)
         ; ERROR_SUCCESS == Err ;
         Err = MemArrayNextLoc(Array, &Loc)
    ) {
        ThisElt = NULL;
        Err = MemArrayGetElement(Array, &Loc, &ThisElt);
        Func(InitTab, ThisElt);
    }

    if( ERROR_FILE_NOT_FOUND != Err ) {
        TAB; printf("Enumeration failure: %ld (0x%08lx)\n", Err, Err);
    }
}

#define     HEX_CHAR(c)            (((c) < 10)?((c)+'0'):((c) - 10 + 'A'))

static
VOID
DumpHex(
    IN      LPSTR                  Name,
    IN      LPBYTE                 Bytes,
    IN      ULONG                  nBytes
)
{
    printf("%s ", Name);
    while(nBytes--) {
        printf("%c%c ", HEX_CHAR(((*Bytes)&0xF0)>>4), HEX_CHAR((*Bytes)&0x0F));
        Bytes ++;
    }
    printf("\n");
}

//BeginExport(function)
VOID
MmDumpOption(
    IN      ULONG                  InitTab,
    IN      PM_OPTION              Option
)   //EndExport(function)
{
    TAB; printf("Option %ld\n", Option->OptId);
    InitTab++;
    TAB; DumpHex("Option value:", Option->Val, Option->Len);
}

//BeginExport(function)
VOID
MmDumpOptList(
    IN      ULONG                  InitTab,
    IN      PM_OPTLIST             OptList
)   //EndExport(function)
{
    DumpArray(OptList, InitTab, MmDumpOption);
}

//BeginExport(function)
VOID
MmDumpOneClassOptList(
    IN      ULONG                  InitTab,
    IN      PM_ONECLASS_OPTLIST    OptList1
)   //EndExport(function)
{
    TAB; printf("OptList for UserClass %ld Vendor Class %ld\n", OptList1->ClassId, OptList1->VendorId);
    InitTab ++;

    MmDumpOptList(InitTab, &OptList1->OptList);
}


//BeginExport(function)
VOID
MmDumpOptions(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASS            OptClass
)   //EndExport(function)
{
    DumpArray(&OptClass->Array, InitTab, MmDumpOneClassOptList);
}

//BeginExport(function)
VOID
MmDumpReservation(
    IN      ULONG                  InitTab,
    IN      PM_RESERVATION         Res
)   //EndExport(function)
{
    TAB; printf("Reservation %s (Type %ld)\n", inet_ntoa(*(struct in_addr *)&Res->Address),Res->Flags);
    InitTab++;
    TAB; DumpHex("Reservation for", Res->ClientUID, Res->nBytes);
    MmDumpOptions(InitTab, &Res->Options);
}

//BeginExport(function)
VOID
MmDumpRange(
    IN      ULONG                  InitTab,
    IN      PM_RANGE               Range
)   //EndExport(function)
{
    TAB; printf("Range: %s to ", inet_ntoa(*(struct in_addr *)&Range->Start));
    printf("%s mask (", inet_ntoa(*(struct in_addr *)&Range->End));
    printf("%s)\n", inet_ntoa(*(struct in_addr *)&Range->Mask));
}

//BeginExport(function)
VOID
MmDumpExclusion(
    IN      ULONG                  InitTab,
    IN      PM_EXCL                Range
)   //EndExport(function)
{
    TAB; printf("Range: %s to ", inet_ntoa(*(struct in_addr *)&Range->Start));
    printf("%s\n", inet_ntoa(*(struct in_addr *)&Range->End));
}

//BeginExport(function)
VOID
MmDumpSubnets(
    IN      ULONG                  InitTab,
    IN      PM_SUBNET              Subnet
)   //EndExport(function)
{
    TAB; printf("Scope %ws : ", Subnet->Name);
    if( Subnet->fSubnet ) {
        printf("ADDRESS %s ", inet_ntoa(*(struct in_addr*)&Subnet->Address));
        printf("MASK %s\n", inet_ntoa(*(struct in_addr*)&Subnet->Mask));
    } else {
        printf("SCOPEID %ld\n", Subnet->MScopeId);
    }
    InitTab++;
    TAB; printf("Subnet Description: %ws\n", Subnet->Description);
    TAB; printf("State/SuperScope/Policy: %ld/%ld/%ld\n", Subnet->State, Subnet->SuperScopeId, Subnet->Policy);
    DumpArray(&Subnet->Ranges, InitTab, MmDumpRange);
    DumpArray(&Subnet->Exclusions, InitTab, MmDumpExclusion);
    MmDumpOptions(InitTab, &Subnet->Options);
    DumpArray(&Subnet->Reservations, InitTab, MmDumpReservation);
}

//BeginExport(function)
VOID
MmDumpSscope(
    IN      ULONG                  InitTab,
    IN      PM_SSCOPE              Sscope
)   //EndExport(function)
{
    TAB; printf("SuperScope %ws (%ld) Policy 0x%08lx\n",
                  Sscope->Name, Sscope->SScopeId, Sscope->Policy
    );
}

//BeginExport(function)
VOID
MmDumpOptDef(
    IN      ULONG                  InitTab,
    IN      PM_OPTDEF              OptDef
)   //EndExport(function)
{
    TAB; printf("Option <%ws> %ld\n", OptDef->OptName, OptDef->OptId);
    InitTab++;
    TAB; printf("Option Comment: %ws\n", OptDef->OptComment);
    TAB; DumpHex("Option Default Value:", OptDef->OptVal, OptDef->OptValLen);
}

//BeginExport(function)
VOID
MmDumpOptClassDefListOne(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASSDEFL_ONE    OptDefList1
)   //EndExport(function)
{
    TAB; printf("Options for UserClass %ld Vendor Class %ld \n",
                  OptDefList1->ClassId, OptDefList1->VendorId
    );
    InitTab++;
    DumpArray(&OptDefList1->OptDefList.OptDefArray, InitTab, MmDumpOptDef);
}

//BeginExport(function)
VOID
MmDumpOptClassDefList(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASSDEFLIST     OptDefList
)   //EndExport(function)
{
    DumpArray(&OptDefList->Array, InitTab, MmDumpOptClassDefListOne);
}

//BeginExport(function)
VOID
MmDumpClassDef(
    IN      ULONG                  InitTab,
    IN      PM_CLASSDEF            ClassDef
)   //EndExport(function)
{
    TAB; printf("Class <%ws> Id: %ld, %s\n", ClassDef->Name, ClassDef->ClassId,
                  ClassDef->IsVendor? "VENDOR CLASS" : "USER CLASS"
    );

    InitTab ++;
    TAB; printf("ClassComment: %ws\n", ClassDef->Comment);
    TAB; printf("ClassType/RefCount: %ld/%ld\n", ClassDef->Type, ClassDef->RefCount);
    TAB; DumpHex("ClassData:", ClassDef->ActualBytes, ClassDef->nBytes);
}


//BeginExport(function)
VOID
MmDumpClassDefList(
    IN      ULONG                  InitTab,
    IN      PM_CLASSDEFLIST        ClassDefList
)   //EndExport(function)
{
    DumpArray(&ClassDefList->ClassDefArray, InitTab, MmDumpClassDef);
}

//BeginExport(function)
VOID
MmDumpServer(
    IN      ULONG                  InitTab,        // how much to tab initially..
    IN      PM_SERVER              Server
)   //EndExport(function)
{
    DWORD                          Err;

    PM_SUBNET                      ThisSubnet;
    PM_MSCOPE                      ThisMScope;
    PM_SSCOPE                      ThisSScope;

    TAB;
    printf("Server: %s <%ws>\n", inet_ntoa(*(struct in_addr*)&Server->Address), Server->Name);
    InitTab++;

    TAB; printf("State: %ld (0x%08lx)\n", Server->State, Server->State);
    TAB; printf("Policy: %ld (0x%08lx)\n", Server->Policy, Server->Policy);

    MmDumpClassDefList(InitTab, &Server->ClassDefs);
    MmDumpOptClassDefList(InitTab, &Server->OptDefs);
    MmDumpOptions(InitTab, &Server->Options);     // dump classes, option defs, options

    DumpArray(&Server->SuperScopes, InitTab, MmDumpSscope);
    DumpArray(&Server->Subnets, InitTab, MmDumpSubnets);
    DumpArray(&Server->MScopes, InitTab, MmDumpSubnets);
}


//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\mmtypes.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

#ifndef _MMTYPES_H_
#define _MMTYPES_H_

typedef struct _ARRAY {
    DWORD                          nElements;
    DWORD                          nAllocated;
    LPVOID                        *Ptrs;
} ARRAY, *PARRAY, *LPARRAY;


typedef DWORD                      ARRAY_LOCATION;
typedef ARRAY_LOCATION*            PARRAY_LOCATION;
typedef PARRAY_LOCATION            LPARRAY_LOCATION;


typedef struct _M_OPTION {
    DWORD                          OptId;
    DWORD                          Len;
    ULONG                          UniqId;
    BYTE                           Val[0];
} M_OPTION, *PM_OPTION, *LP_MOPTION;


typedef     ARRAY                  M_OPTLIST;
typedef     PARRAY                 PM_OPTLIST;
typedef     LPARRAY                LPM_OPTLIST;


typedef struct _M_OPTDEF {
    DWORD                          OptId;
    DWORD                          Type;
    LPWSTR                         OptName;
    LPWSTR                         OptComment;
    LPBYTE                         OptVal;
    DWORD                          OptValLen;
    ULONG                          UniqId;
} M_OPTDEF, *PM_OPTDEF, *LPM_OPTDEF;

typedef struct _M_OPTDEFLIST {
    ARRAY                          OptDefArray;
} M_OPTDEFLIST, *PM_OPTDEFLIST, *LPM_OPTDEFLIST;


typedef struct _M_CLASSDEF {
    DWORD                          RefCount;
    DWORD                          ClassId;
    BOOL                           IsVendor;
    DWORD                          Type;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    DWORD                          nBytes;
    LPBYTE                         ActualBytes;
    ULONG                          UniqId;
} M_CLASSDEF, *PM_CLASSDEF, *LPM_CLASSDEF;

typedef struct _M_CLASSDEFLIST {
    ARRAY                          ClassDefArray;
} M_CLASSDEFLIST, *PM_CLASSDEFLIST, *LPM_CLASSDEFLIST;


// This is pure in-memory structure, uniq-id is not needed.
typedef struct _M_ONECLASS_OPTLIST {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTLIST                      OptList;
} M_ONECLASS_OPTLIST, *PM_ONECLASS_OPTLIST, *LPM_ONECLASS_OPTLIST;

typedef struct _M_OPTCLASS {
    ARRAY                          Array;
} M_OPTCLASS, *PM_OPTCLASS, *LPM_OPTCLASS;


typedef struct _M_EXCL {
    DWORD                          Start;
    DWORD                          End;
    ULONG                          UniqId;
} M_EXCL, *PM_EXCL, *LPM_EXCL;


typedef struct _M_BITMASK1 {
    DWORD                          Size;          // Size in # of bits
    DWORD                          AllocSize;     // Size in BYTES allocated
    DWORD                          nSet;          // nBits set
    LPBYTE                         Mask;          //  making this DWORD would make things faster..
    DWORD                          Offset;        // used by Bit2 type..
    ULONG                          nDirtyOps;     // # of unsaved operations done on this bitmask?
} M_BITMASK1, *PM_BITMASK1, *LPM_BITMASK1;


typedef struct _M_BITMASK2 {
    DWORD                          Size;
    ARRAY_LOCATION                 Loc;           // where to start off to look for a bit
    ARRAY                          Array;         // Array of bitmask 1 types
} M_BITMASK2, *PM_BITMASK2, *LPM_BITMASK2;

typedef     M_BITMASK2             M_BITMASK;
typedef     PM_BITMASK2            PM_BITMASK;
typedef     LPM_BITMASK2           LPM_BITMASK;


typedef struct _M_RESERVATION  {
    LPVOID                         SubnetPtr;
    DWORD                          Address;
    DWORD                          Flags;
    DWORD                          nBytes;
    LPBYTE                         ClientUID;
    M_OPTCLASS                     Options;
    ULONG                          UniqId;
} M_RESERVATION , *PM_RESERVATION , *LPM_RESERVATION ;


typedef ARRAY                      M_RESERVATIONS;
typedef PARRAY                     PM_RESERVATIONS;
typedef LPARRAY                    LPM_RESERVATIONS;


typedef struct _M_RANGE {
    DWORD                          Start;
    DWORD                          End;
    DWORD                          Mask;
    DWORD                          State;
    ULONG                          BootpAllocated;
    ULONG                          MaxBootpAllowed;
    DWORD                          DirtyOps;      // how many unsaved ops done?
    M_OPTCLASS                     Options;
    PM_BITMASK                     BitMask;
    ULONG                          UniqId;
    // Reservations?
} M_RANGE, *PM_RANGE, *LPM_RANGE;


typedef struct _M_SUBNET {
    LPVOID                         ServerPtr;     // Ptr to Server object
    union {
        struct {                                  // for normal subnet.
            DWORD                  Address;
            DWORD                  Mask;
            DWORD                  SuperScopeId;  // unused for MCAST scopes
        };
        struct {                                  // for multicast scope
            DWORD                  MScopeId;
            LPWSTR                 LangTag;       // the language tag for multicast scope
            BYTE                   TTL;
        };
    };
    DWORD                          fSubnet;       // TRUE => Subnet, FALSE => MSCOPE
    DHCP_SUBNET_STATE              State;
    DWORD                          Policy;
    DATE_TIME                      ExpiryTime;     // Scope Lifetime. Currently used for MCast only.
    M_OPTCLASS                     Options;
    ARRAY                          Ranges;
    ARRAY                          Exclusions;
    M_RESERVATIONS                 Reservations;
    ARRAY                          Servers;       // future use, Server-Server protocol
    LPWSTR                         Name;
    LPWSTR                         Description;
    ULONG                          UniqId;
} M_SUBNET, *PM_SUBNET, *LPM_SUBNET;


typedef     M_SUBNET               M_MSCOPE;      // same structure for Multicast Scopes and Subnets
typedef     PM_SUBNET              PM_MSCOPE;     // still, use the correct functions for MScope
typedef     LPM_SUBNET             LPM_MSCOPE;


typedef struct _M_SSCOPE {
    DWORD                          SScopeId;
    DWORD                          Policy;
    LPWSTR                         Name;
    M_OPTCLASS                     Options;
    ULONG                          UniqId;
} M_SSCOPE, *PM_SSCOPE, *LPM_SSCOPE;


typedef struct _M_OPTCLASSDEFL_ONE {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTDEFLIST                   OptDefList;
    ULONG                          UniqId;
} M_OPTCLASSDEFL_ONE, *PM_OPTCLASSDEFL_ONE;

typedef struct _M_OPTCLASSDEFLIST {
    ARRAY                          Array;
} M_OPTCLASSDEFLIST, *PM_OPTCLASSDEFLIST, *LPM_OPTCLASSDEFLIST;


typedef struct _M_SERVER {
    DWORD                          Address;
    //  must be ARRAY type to hold multliple addresses
    DWORD                          State;
    DWORD                          Policy;
    ARRAY                          Subnets;
    ARRAY                          MScopes;
    ARRAY_LOCATION                 Loc;           // if RoundRobin on, then we need this to keep track
    ARRAY                          SuperScopes;
    M_OPTCLASS                     Options;
    M_OPTCLASSDEFLIST              OptDefs;
    M_CLASSDEFLIST                 ClassDefs;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    ULONG                          LastUniqId;    // Uniq id created
} M_SERVER, *PM_SERVER, *LPM_SERVER;


typedef     VOID                  (*ARRAY_FREE_FN)(LPVOID  MemObject);


#endif // _MMTYPES_H_
//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\oclassdl.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for storing complete option configuration info
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================

#include <mm.h>
#include <array.h>
#include <optdefl.h>

#include "oclassdl.h"

#include "server\uniqid.h"

//BeginExport(function)
DWORD
MemOptClassDefListFindOptDefList(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTDEFLIST         *OptDefList
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    PM_OPTCLASSDEFL_ONE            OneClassDefList;

    AssertRet(OptClassDefList && OptDefList, ERROR_INVALID_PARAMETER);

    *OptDefList = NULL;
    for( Error = MemArrayInitLoc(&OptClassDefList->Array, &Location)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&OptClassDefList->Array, &Location)
    ) {
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(
            &OptClassDefList->Array,
            &Location,
            (LPVOID*)&OneClassDefList
        );
        Require(ERROR_SUCCESS == Error && OneClassDefList);

        if( OneClassDefList->ClassId == ClassId &&
            OneClassDefList->VendorId == VendorId ) {
            *OptDefList = &OneClassDefList->OptDefList;
            return ERROR_SUCCESS;
        }
    }
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemOptClassDefListAddOptDef(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId,
    IN      DWORD                  Type,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen,
    IN      ULONG                  UniqId
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTCLASSDEFL_ONE            OneClassDefList;
    PM_OPTDEFLIST                  OptDefList;

    AssertRet(OptClassDefList, ERROR_INVALID_PARAMETER);

    OneClassDefList = NULL;

    Error = MemOptClassDefListFindOptDefList(
        OptClassDefList,
        ClassId,
        VendorId,
        &OptDefList
    );
    if( ERROR_SUCCESS != Error ) {
        Require(ERROR_FILE_NOT_FOUND == Error);
        OneClassDefList = MemAlloc(sizeof(*OneClassDefList));
        if( NULL == OneClassDefList) return ERROR_NOT_ENOUGH_MEMORY;

        // RefCount on ClassId needs to be bumped up?
        OneClassDefList->ClassId = ClassId;
        OneClassDefList->VendorId = VendorId;

        Error = MemOptDefListInit(&OneClassDefList->OptDefList);
        if( ERROR_SUCCESS != Error ) {
            MemFree(OneClassDefList);
            return Error;
        }

        Error = MemArrayAddElement(&OptClassDefList->Array, OneClassDefList);
        if( ERROR_SUCCESS != Error) {
            MemFree(OneClassDefList);
            return Error;
        }

        OptDefList = &OneClassDefList->OptDefList;
    }

    Error = MemOptDefListAddOptDef(
        OptDefList,
        OptId,
        Type,
        Name,
        Comment,
        OptVal,
        OptLen,
	UniqId
    );

    return Error;
} // MemOptDefListAddOptDef()

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\mminit.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
MemInit(
    VOID
) ;


VOID
MemCleanup(
    VOID
) ;


LPVOID
MemAlloc(
    IN      DWORD                  nBytes
) ;


DWORD 
MemFree(
    IN      LPVOID                 Mem
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\oclassdl.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//========================================================================

#ifndef _MM_OCLASSDL_H_
#define _MM_OCLASSDL_H_

#include <dhcp.h>

typedef struct _M_OPTCLASSDEFL_ONE {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTDEFLIST                   OptDefList;
//      ULONG                          UniqId;
} M_OPTCLASSDEFL_ONE, *PM_OPTCLASSDEFL_ONE;

typedef struct _M_OPTCLASSDEFLIST {
    ARRAY                          Array;
} M_OPTCLASSDEFLIST, *PM_OPTCLASSDEFLIST, *LPM_OPTCLASSDEFLIST;


DWORD       _inline
MemOptClassDefListInit(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) {
    return MemArrayInit(&OptClassDefList->Array);
}


DWORD       _inline
MemOptClassDefListCleanup(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) {
    // BUG BUG Bump down class Id refcount?
    return MemArrayCleanup(&OptClassDefList->Array);
}


DWORD
MemOptClassDefListFindOptDefList(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTDEFLIST         *OptDefList
) ;


DWORD
MemOptClassDefListAddOptDef(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId,
    IN      DWORD                  Type,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen,
    IN      ULONG                  UniqId
) ;

#endif // _MM_OCLASSDL_H_

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\opt.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for an option
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================

#include    <mm.h>
#include "opt.h"

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\opt.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _MM_OPT_H
#define _MM_OPT_H

typedef struct _M_OPTION {
    DWORD                          OptId;
    DWORD                          Len;
    ULONG                          UniqId;
    BYTE                           Val[0];
} M_OPTION, *PM_OPTION, *LP_MOPTION;


DWORD       _inline
MemOptInit(
    OUT     PM_OPTION             *Opt,
    IN      DWORD                  OptId,
    IN      DWORD                  Len,
    IN      LPBYTE                 Val
) {
    AssertRet(Opt, ERROR_INVALID_PARAMETER);
    AssertRet(Len || NULL==Val, ERROR_INVALID_PARAMETER);
    AssertRet(0 == Len|| Val, ERROR_INVALID_PARAMETER);

    (*Opt) = MemAlloc(sizeof(M_OPTION)+Len);
    if( NULL == (*Opt) ) return ERROR_NOT_ENOUGH_MEMORY;

    (*Opt)->OptId = OptId;
    (*Opt)->Len = Len;
    memcpy((*Opt)->Val, Val, Len);

    return ERROR_SUCCESS;
} // MemOptInit()


DWORD       _inline
MemOptCleanup(
    IN OUT  PM_OPTION              Opt
) {
    AssertRet(Opt, ERROR_INVALID_PARAMETER);

    MemFree(Opt);
    return ERROR_SUCCESS;
}


LPBYTE      _inline
MemOptVal(
    IN      PM_OPTION              Opt
) {
    return Opt->Val;
}

#endif // _MM_OPT_H_
//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\optclass.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for options, including class id
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include <mm.h>
#include <array.h>
#include <opt.h>
#include <optl.h>

#include "optclass.h"

//BeginExport(function)
MemOptClassFindClassOptions(                      // find options for one particular class
    IN OUT  PM_OPTCLASS            OptClass,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTLIST            *OptList
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    PM_ONECLASS_OPTLIST            ThisOptList;
    DWORD                          Error;

    AssertRet(OptClass && OptList, ERROR_INVALID_PARAMETER);

    for( Error = MemArrayInitLoc(&OptClass->Array, &Location)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&OptClass->Array, &Location)
    ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &OptClass->Array,
            &Location,
            (LPVOID*)&ThisOptList
        );
        Require(ERROR_SUCCESS == Error && ThisOptList);

        if( ThisOptList->ClassId == ClassId &&
            ThisOptList->VendorId == VendorId ) {
            *OptList = &ThisOptList->OptList;
            return ERROR_SUCCESS;
        }
    }
    *OptList = NULL;
    return ERROR_FILE_NOT_FOUND;
} // MemOptClassFindClassOptions()

//BeginExport(function)
DWORD
MemOptClassAddOption(
    IN OUT  PM_OPTCLASS            OptClass,
    IN      PM_OPTION              Opt,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTION             *DeletedOpt,
    IN      ULONG                  UniqId
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTLIST                     ThisOptList;
    PM_ONECLASS_OPTLIST            ThisOneOptList;

    AssertRet(OptClass && Opt && DeletedOpt, ERROR_INVALID_PARAMETER);

    ThisOneOptList = NULL;
    (*DeletedOpt) = NULL;

    Error = MemOptClassFindClassOptions(OptClass,ClassId,VendorId,&ThisOptList);
    if( ERROR_SUCCESS != Error ) {
        ThisOneOptList = MemAlloc(sizeof(*ThisOneOptList));
        if( NULL == ThisOneOptList ) return ERROR_NOT_ENOUGH_MEMORY;

        // RefCount on ClassId has to go up?
        ThisOneOptList->ClassId = ClassId;
        ThisOneOptList->VendorId = VendorId;
        Error = MemOptListInit(&ThisOneOptList->OptList);
        if( ERROR_SUCCESS != Error ) {
            MemFree(ThisOneOptList);
            return Error;
        }

//  	ThisOneOptList->UniqId = UniqId;
        Error = MemArrayAddElement(&OptClass->Array, ThisOneOptList);
        if( ERROR_SUCCESS != Error ) {
            MemFree(ThisOneOptList);
            return Error;
        }

        ThisOptList = &ThisOneOptList->OptList;
    } // if

    Opt->UniqId = UniqId;
    Error = MemOptListAddOption(ThisOptList, Opt, DeletedOpt);

    return Error;
} // MemOptClassAddOption()


// Delete all the options in this optclass
DWORD 
MemOptClassDelClass (
    IN     PM_OPTCLASS  OptClass
)
{
    DWORD                Error;
    ARRAY_LOCATION       Loc;
    PM_ONECLASS_OPTLIST  OptClassList;

    AssertRet( OptClass, ERROR_INVALID_PARAMETER );

    Error = MemArrayInitLoc( &OptClass->Array, &Loc );
    while (( MemArraySize( &OptClass->Array ) > 0 ) && 
	   ( ERROR_FILE_NOT_FOUND != Error )) {
	Require( ERROR_SUCCESS == Error );

	Error = MemArrayGetElement( &OptClass->Array, &Loc,
				    ( LPVOID * ) &OptClassList );
	Require( ERROR_SUCCESS == Error );

	Error = MemOptListDelList( &OptClassList->OptList );
	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}
	Error = MemArrayDelElement( &OptClass->Array, &Loc,
				    ( LPVOID * ) &OptClassList );
	Require( ERROR_SUCCESS == Error && OptClassList );
    } // while 

    if ( ERROR_FILE_NOT_FOUND == Error ) {
	Error = ERROR_SUCCESS;
    }
    return Error;
    } // MemOptClassDelClass()

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\optl.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for a list of options
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================

#include    <mm.h>
#include    <opt.h>
#include    <array.h>

#include "optl.h"

#include "server\uniqid.h"

//BeginExport(function)
DWORD
MemOptListDelOption(
    IN      PM_OPTLIST             OptList,
    IN      DWORD                  OptId
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_OPTION                      Opt;

    AssertRet(OptList, ERROR_INVALID_PARAMETER );

    Error = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(OptList, &Loc, (LPVOID*)&Opt);
        Require(ERROR_SUCCESS == Error && Opt);

        if( Opt->OptId == OptId ) {

	    Error = DeleteRecord( Opt->UniqId );

	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }
            Error = MemArrayDelElement(OptList, &Loc, (LPVOID*)&Opt);
            Require(ERROR_SUCCESS == Error && Opt);
            Error = MemOptCleanup(Opt);
            Require(ERROR_SUCCESS == Error);
            return ERROR_SUCCESS;
        } // if

        Error = MemArrayNextLoc(OptList, &Loc);
    } // while 

    return ERROR_FILE_NOT_FOUND;
} // MemOptListDelOption()


DWORD 
MemOptListDelList(
   IN      PM_OPTLIST    OptList
)
{
    PM_OPTION       Opt;
    ARRAY_LOCATION  Loc;
    DWORD           Error;


    AssertRet( OptList, ERROR_INVALID_PARAMETER );

    Error = MemArrayInitLoc( OptList, &Loc );

    while(( MemArraySize( OptList ) > 0 ) && 
	  ( ERROR_FILE_NOT_FOUND != Error )) {
        Require( ERROR_SUCCESS == Error );

        Error = MemArrayGetElement( OptList, &Loc, ( LPVOID * ) &Opt );
        Require( ERROR_SUCCESS == Error && Opt );

	Error = DeleteRecord( Opt->UniqId );

	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}

	Error = MemArrayDelElement( OptList, &Loc, ( LPVOID * ) &Opt );
	Require( ERROR_SUCCESS == Error && Opt );

	Error = MemOptCleanup( Opt );
	Require( ERROR_SUCCESS == Error);

    } // while 

    if ( ERROR_FILE_NOT_FOUND == Error ) {
	Error = ERROR_SUCCESS;
    }
    return Error;
} // MemOptListDelList()

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\optdefl.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for a list of option definitions
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include <mm.h>
#include <array.h>
#include <wchar.h>

#include "optdefl.h"

#include "server\uniqid.h"

//BeginExport(function)
DWORD
MemOptDefListFindOptDefInternal(                  // Dont use this function out of optdefl.c
    IN      PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,       // either OptId or OptName need only be specified..
    OUT     PARRAY_LOCATION        Location
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTDEF                      RetOptDef;

    Error = MemArrayInitLoc(&OptDefList->OptDefArray, Location);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&OptDefList->OptDefArray, Location, (LPVOID*)&RetOptDef);
        Require(ERROR_SUCCESS == Error);

        if( RetOptDef->OptId == OptId ) return ERROR_SUCCESS;
        if(OptName)
            if( 0 == wcscmp(RetOptDef->OptName, OptName) ) return ERROR_SUCCESS;
        Error = MemArrayNextLoc(&OptDefList->OptDefArray, Location);
    }

    return ERROR_FILE_NOT_FOUND;
}

DWORD 
MemOptDefListDelOptDef(
    IN OUT  PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    PM_OPTDEF                      OptDef;

    Error = MemOptDefListFindOptDefInternal(
        OptDefList,
        OptId,
        NULL,
        &Location
    );
    if( ERROR_SUCCESS != Error ) return Error;
    
    // Delete it from the database first
    Error = MemArrayGetElement( &OptDefList->OptDefArray,
				&Location,
				&OptDef );
    Require( Error == ERROR_SUCCESS );
    
    Error = DeleteRecord( OptDef->UniqId );
    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }
    
    Error = MemArrayDelElement(
        &OptDefList->OptDefArray,
        &Location,
        &OptDef
    );
    Require(ERROR_SUCCESS == Error && OptDef);

    MemFree(OptDef);
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
MemOptDefListAddOptDef(     //  Add or replace an option defintion for given Option Id
    IN OUT  PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      DWORD                  Type,
    IN      LPWSTR                 OptName,
    IN      LPWSTR                 OptComment,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptValLen,
    IN      ULONG                  UniqId
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    PM_OPTDEF                      OptDef;
    PM_OPTDEF                      ThisOptDef;
    DWORD                          Size;
    DWORD                          Error;
    AssertRet(OptDefList, ERROR_INVALID_PARAMETER);

    Error = MemOptDefListFindOptDefInternal(
        OptDefList,
        OptId,
        OptName,
        &Location
    );
    Require(ERROR_FILE_NOT_FOUND == Error || ERROR_SUCCESS == Error);

    Size = sizeof(M_OPTDEF) + OptValLen ;
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    if( OptName ) Size += (1+wcslen(OptName))*sizeof(WCHAR);
    if( OptComment ) Size += (1+wcslen(OptComment))*sizeof(WCHAR);

	// This contains optdef struct + all the values in one buffer
    OptDef = MemAlloc(Size);
    if( NULL == OptDef ) return ERROR_NOT_ENOUGH_MEMORY;
    memcpy(sizeof(M_OPTDEF) +(LPBYTE)OptDef, OptVal, OptValLen);
    Size = sizeof(M_OPTDEF) + OptValLen ;
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    OptDef->OptVal = sizeof(M_OPTDEF) + (LPBYTE)OptDef;
    OptDef->OptValLen = OptValLen;
    OptDef->OptId = OptId;
    OptDef->Type  = Type;
    if( OptName ) {
        OptDef->OptName  = (LPWSTR)(Size + (LPBYTE)OptDef);
        wcscpy(OptDef->OptName, OptName);
        Size += sizeof(WCHAR)*(1 + wcslen(OptName));
    } else {
        OptDef->OptName = NULL;
    }

    if( OptComment) {
        OptDef->OptComment = (LPWSTR)(Size + (LPBYTE)OptDef);
        wcscpy(OptDef->OptComment, OptComment);
    } else {
        OptDef->OptComment = NULL;
    }

    OptDef->UniqId = UniqId;

    if( ERROR_SUCCESS == Error ) {
        Error = MemArrayGetElement(
            &OptDefList->OptDefArray,
            &Location,
            (LPVOID*)&ThisOptDef
        );
        Require(ERROR_SUCCESS == Error && ThisOptDef);

	Error = DeleteRecord( ThisOptDef->UniqId );
        MemFree(ThisOptDef);
	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}

        Error = MemArraySetElement(
            &OptDefList->OptDefArray,
            &Location,
            (LPVOID)OptDef
        );
        Require(ERROR_SUCCESS==Error);
        return Error;
    } // if

    Error = MemArrayAddElement(
        &OptDefList->OptDefArray,
        (LPVOID)OptDef
    );

    if( ERROR_SUCCESS != Error ) MemFree(OptDef);

    return Error;
} // MemOptDefListAddOptDef()

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\optclass.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _MM_OPTCLASS_H_
#define _MM_OPTCLASS_H_

// This is pure in-memory structure, uniq-id is not needed.

typedef struct _M_ONECLASS_OPTLIST {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTLIST                      OptList;
} M_ONECLASS_OPTLIST, *PM_ONECLASS_OPTLIST, *LPM_ONECLASS_OPTLIST;

typedef struct _M_OPTCLASS {
    ARRAY                          Array;
} M_OPTCLASS, *PM_OPTCLASS, *LPM_OPTCLASS;


DWORD       _inline
MemOptClassInit(
    IN OUT  PM_OPTCLASS            OptClass
) {
    return MemArrayInit(&OptClass->Array);
}


DWORD       _inline
MemOptClassCleanup(
    IN OUT  PM_OPTCLASS            OptClass
) {
    // Bump down refcounts?
    return MemArrayCleanup(&OptClass->Array);
}


MemOptClassFindClassOptions(                      // find options for one particular class
    IN OUT  PM_OPTCLASS            OptClass,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTLIST            *OptList
) ;


DWORD
MemOptClassAddOption(
    IN OUT  PM_OPTCLASS            OptClass,
    IN      PM_OPTION              Opt,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTION             *DeletedOpt,
    IN      ULONG                  UniqId
) ;

DWORD 
MemOptClassDelClass (
    IN     PM_OPTCLASS  OptClass
);

#endif _MM_OPTCLASS_H_

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\range.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for options, including class id
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>

#include "range.h"
#include "server\uniqid.h"

//BeginExport(function)
DWORD
MemRangeExtendOrContract(
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // to contract by or expand by
    IN      BOOL                   fExtend,       // is this extend or contract?
    IN      BOOL                   fEnd           // to expand/contract at End or ar Start?
) //EndExport(function)
{
    DWORD                          Error;

    AssertRet(Range && nAddresses > 0, ERROR_INVALID_PARAMETER);

    Error = MemBitAddOrDelBits(
        Range->BitMask,
        nAddresses,
        fExtend,
        fEnd
    );
    if( ERROR_SUCCESS != Error ) return Error;

    if( fExtend ) {
        if( fEnd ) Range->End += nAddresses;
        else Range->Start -= nAddresses;
    } else {
        if( fEnd ) Range->End -= nAddresses;
        else Range->Start += nAddresses;
    }

//      Range->UniqId = INVALID_UNIQ_ID;

    return ERROR_SUCCESS;
} // MemRangeExtendOrContract()


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\optdefl.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//========================================================================

#ifndef _MM_OPTDEFL_H_
#define _MM_OPTDEFL_H_

#include <dhcp.h>

typedef struct _M_OPTDEF {
    DWORD                          OptId;
    DWORD                          Type;
    LPWSTR                         OptName;
    LPWSTR                         OptComment;
    LPBYTE                         OptVal;
    DWORD                          OptValLen;
    ULONG                          UniqId;
} M_OPTDEF, *PM_OPTDEF, *LPM_OPTDEF;

typedef struct _M_OPTDEFLIST {
    ARRAY                          OptDefArray;
} M_OPTDEFLIST, *PM_OPTDEFLIST, *LPM_OPTDEFLIST;


DWORD       _inline
MemOptDefListInit(
    IN OUT  PM_OPTDEFLIST          OptDefList
) {
    AssertRet(OptDefList, ERROR_INVALID_PARAMETER);
    return MemArrayInit(&OptDefList->OptDefArray);
}


DWORD       _inline
MemOptDefListCleanup(
    IN OUT  PM_OPTDEFLIST          OptDefList
) {
    return MemArrayCleanup(&OptDefList->OptDefArray);
}


DWORD
MemOptDefListFindOptDefInternal(                  // Dont use this function out of optdefl.c
    IN      PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,       // either OptId or OptName need only be specified..
    OUT     PARRAY_LOCATION        Location
) ;


DWORD       _inline
MemOptDefListFindOptDef(
    IN      PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,       // only either the name or the option id need be given..
    OUT     PM_OPTDEF             *OptDef
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;

    Error = MemOptDefListFindOptDefInternal(
        OptDefList,
        OptId,
        OptName,
        &Location
    );
    if( ERROR_SUCCESS != Error ) return Error;

    return MemArrayGetElement(
        &OptDefList->OptDefArray,
        &Location,
        (LPVOID *)OptDef
    );
}


DWORD
MemOptDefListAddOptDef(                           // Add or replace an option defintion for given Option Id
    IN OUT  PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      DWORD                  Type,
    IN      LPWSTR                 OptName,
    IN      LPWSTR                 OptComment,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptValLen,
    IN      ULONG                  UniqId
) ;


DWORD
MemOptDefListDelOptDef(
    IN OUT  PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId
);
 
#endif // _MM_OPTDEFL_H_

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\optl.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _MM_OPTL_H_
#define _MM_OPTL_H_

#include "server\uniqid.h"

typedef     ARRAY                  M_OPTLIST;
typedef     PARRAY                 PM_OPTLIST;
typedef     LPARRAY                LPM_OPTLIST;


DWORD       _inline
MemOptListInit(
    IN OUT  PM_OPTLIST             OptList
) {
    return MemArrayInit(OptList);
}


DWORD       _inline
MemOptListCleanup(
    IN OUT  PM_OPTLIST             OptList
) {
    return MemArrayCleanup(OptList);
}


DWORD       _inline
MemOptListAddOption(                              // Add or replace an option
    IN OUT  PM_OPTLIST             OptList,
    IN      PM_OPTION              Opt,
    OUT     PM_OPTION             *DeletedOpt     // OPTIONAL: old option or NULL
) // EndExport(function)
{ // if DeletedOpt is NULL, then the option would just be freed.
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_OPTION                      ThisOpt;

    AssertRet(OptList && Opt, ERROR_INVALID_PARAMETER);

    if( DeletedOpt ) *DeletedOpt  = NULL;
    Error = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(OptList, &Loc, (LPVOID*)&ThisOpt);
        Require(ERROR_SUCCESS == Error );
        Require(ThisOpt);

        if( ThisOpt->OptId == Opt->OptId ) {

	    Error = DeleteRecord( ThisOpt->UniqId );
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }
            Error = MemArraySetElement(OptList, &Loc, (LPVOID)Opt);
            Require(ERROR_SUCCESS == Error);

            if( DeletedOpt ) (*DeletedOpt) = ThisOpt;
            else MemOptCleanup(ThisOpt);

            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(OptList, &Loc);
    } // while

    Error = MemArrayAddElement(OptList, (LPVOID)Opt);
    return Error;
} // MemOptListAddOption()


//BeginExport(inline)

DWORD       _inline
MemOptListAddAnotherOption(                       // add without checking for duplicates
    IN OUT  PM_OPTLIST             OptList,
    IN      PM_OPTION              Opt
) {
    return MemArrayAddElement(OptList, (LPVOID)Opt);
}


DWORD       _inline
MemOptListFindOption(
    IN      PM_OPTLIST             OptList,
    IN      DWORD                  OptId,
    OUT     PM_OPTION             *Opt
) {
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;

    AssertRet(OptList && Opt, ERROR_INVALID_PARAMETER );

    Error = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(OptList, &Loc, (LPVOID*)Opt);
        Require(ERROR_SUCCESS == Error);
        Require(*Opt);

        if( (*Opt)->OptId == OptId )
            return ERROR_SUCCESS;

        Error = MemArrayNextLoc(OptList, &Loc);
    }

    *Opt = NULL;
    return ERROR_FILE_NOT_FOUND;
}


DWORD
MemOptListDelOption(
    IN      PM_OPTLIST             OptList,
    IN      DWORD                  OptId
) ;


DWORD       _inline
MemOptListSize(
    IN      PM_OPTLIST             OptList
) {
    return MemArraySize(OptList);
}


DWORD 
MemOptListDelList(
   IN      PM_OPTLIST    OptList
);

#endif // _MM_OPTL_H_

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\range.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//========================================================================

#ifndef _MM_RANGE_H_
#define _MM_RANGE_H_

typedef struct _M_RANGE {
    DWORD                          Start;
    DWORD                          End;
    DWORD                          Mask;
    DWORD                          State;
    ULONG                          BootpAllocated;
    ULONG                          MaxBootpAllowed;
    DWORD                          DirtyOps;      // how many unsaved ops done?
    M_OPTCLASS                     Options;
    PM_BITMASK                     BitMask;
    ULONG                          UniqId;
    // Reservations?
} M_RANGE, *PM_RANGE, *LPM_RANGE;


DWORD       _inline
MemRangeInit(
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed
) 
{
    DWORD                          Error;

    AssertRet(Range, ERROR_INVALID_PARAMETER);
    if( Start > End || (Start & Mask) != (End & Mask) )
        return ERROR_INVALID_PARAMETER;


    Range->Start = Start;
    Range->End = End;
    Range->Mask = Mask;
    Range->State = State;
    Range->DirtyOps = 0;
    Range->BootpAllocated = BootpAllocated;
    Range->MaxBootpAllowed = MaxBootpAllowed;

    Error = MemBitInit(&Range->BitMask, End - Start + 1);
    if( ERROR_SUCCESS != Error ) return Error;

    return MemOptClassInit(&Range->Options);
} // MemRangeInit()


DWORD       _inline
MemRangeCleanup(
    IN OUT  PM_RANGE               Range
)
{
    DWORD                          Error;
    AssertRet(Range, ERROR_INVALID_PARAMETER);

    Error = MemBitCleanup(Range->BitMask);
    if( ERROR_SUCCESS != Error ) return Error;

    return MemOptClassCleanup(&Range->Options);
}


PM_OPTCLASS _inline
MemRangeGetOptions(
    IN      PM_RANGE               Range
) 
{
    AssertRet(Range, NULL);

    return &Range->Options;
}


enum /* anonymous */ {
    X_LESSTHAN_Y,
    Y_LESSTHAN_X,
    X_IN_Y,
    Y_IN_X,
    X_LESSTHAN_Y_OVERLAP,
    Y_LESSTHAN_X_OVERLAP
};


DWORD       _inline
MemRangeCompare(
    IN      DWORD                  StartX,
    IN      DWORD                  EndX,
    IN      DWORD                  StartY,
    IN      DWORD                  EndY
) 
{
    if( EndX < StartY ) return X_LESSTHAN_Y;
    if( EndY < StartX ) return Y_LESSTHAN_X;

    if( StartX < StartY ) {
        if( EndX < EndY ) return X_LESSTHAN_Y_OVERLAP;
        return Y_IN_X;
    }

    if( StartX == StartY ) {
        if( EndX <= EndY ) return X_IN_Y;
        if( EndY <= EndX ) return Y_IN_X;
    }
        
    if( EndX <= EndY ) return X_IN_Y;
    return Y_LESSTHAN_X_OVERLAP;
} // MemRangeCompare()


DWORD
MemRangeExtendOrContract(
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // to contract by or expand by
    IN      BOOL                   fExtend,       // is this extend or contract?
    IN      BOOL                   fEnd           // to expand/contract at End or ar Start?
) ;


DWORD       _inline
MemRangeConvertToClusters(
    IN      PM_RANGE               Range,
    OUT     LPBYTE                 *InUseClusters,
    OUT     DWORD                  *InUseClustersSize,
    OUT     LPBYTE                 *UsedClusters,
    OUT     DWORD                  *UsedClustersSize
)
{
    AssertRet(Range && InUseClusters && InUseClustersSize, ERROR_INVALID_PARAMETER);
    AssertRet(UsedClusters && UsedClustersSize, ERROR_INVALID_PARAMETER);

    return MemBitConvertToCluster(
        Range->BitMask,  Range->Start,
        InUseClusters, InUseClustersSize,
        UsedClusters, UsedClustersSize
    );
} // MemRangeConvertToClusters()

#endif // _MM_RANGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\reserve.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for superscopes
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>

#include "reserve.h"

//BeginExport(function)
DWORD
MemReserveAdd(                                    // new client, should not exist before
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize,
    IN      ULONG                  UniqId
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    PM_RESERVATION                 Res1;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Address && ClientUID && ClientUIDSize, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( Address == Res1->Address ) return ERROR_OBJECT_ALREADY_EXISTS;
        if( ClientUIDSize == Res1->nBytes && 0 == memcmp(ClientUID, Res1->ClientUID, Res1->nBytes) )
            return ERROR_OBJECT_ALREADY_EXISTS;

        Error = MemArrayNextLoc(Reservation, &Loc);
    }

    Error = MemReserve1Init(
        &Res1,
        Address,
        Flags,
        ClientUID,
        ClientUIDSize
    );
    if( ERROR_SUCCESS != Error ) return Error;
    Res1->UniqId = UniqId;

    Error = MemArrayAddElement(Reservation, Res1);
    if( ERROR_SUCCESS == Error ) return ERROR_SUCCESS;

    LocalError = MemReserve1Cleanup(Res1);
    Require(ERROR_SUCCESS == LocalError);

    return Error;
}

//BeginExport(function)
DWORD
MemReserveReplace(                                // old client, should exist before
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    PM_RESERVATION                 Res1, Res_Deleted;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Address && ClientUID && ClientUIDSize, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( Address == Res1->Address ) {

	    Error = DeleteRecord( Res1->UniqId );
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }
            Error = MemArrayDelElement(Reservation, &Loc, (LPVOID *)&Res_Deleted);
            Require(ERROR_SUCCESS == Error && Res_Deleted);
            break;
        }

        Error = MemArrayNextLoc(Reservation, &Loc);
    } // while

    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemReserve1Init(
        &Res1,
        Address,
        Flags,
        ClientUID,
        ClientUIDSize
    );
    Require( NULL != Res_Deleted );
    if( ERROR_SUCCESS != Error ) {
	Res_Deleted->UniqId = INVALID_UNIQ_ID;
        LocalError = MemArrayAddElement(Reservation, Res_Deleted);
        Require(ERROR_SUCCESS == LocalError);     // just deleted this guy -- should not have trouble adding back
        return Error;
    }

    Res1->Options = Res_Deleted->Options;
    
    Res1->SubnetPtr = Res_Deleted->SubnetPtr;
    MemFree(Res_Deleted);

    Res1->UniqId = INVALID_UNIQ_ID;
    Error = MemArrayAddElement(Reservation, Res1);
    if( ERROR_SUCCESS == Error ) return ERROR_SUCCESS;

    LocalError = MemReserve1Cleanup(Res1);
    Require(ERROR_SUCCESS == LocalError);

    return Error;
} // MemReserveReplace()

//BeginExport(function)
DWORD
MemReserveDel(
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Res1;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Address, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( Address == Res1->Address ) {

	    // Delete any associated Options
	    Error = MemOptClassDelClass( &Res1->Options );
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }

	    Error = DeleteRecord( Res1->UniqId );
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }

            Error = MemArrayDelElement(Reservation, &Loc, (LPVOID *)&Res1);
            Require(ERROR_SUCCESS == Error && Res1);

            Error = MemReserve1Cleanup(Res1);
            Require(ERROR_SUCCESS == Error);

            return Error;
        }

        Error = MemArrayNextLoc(Reservation, &Loc);
    } // while

    return ERROR_FILE_NOT_FOUND;
} // MemReserveDel()

//BeginExport(function)
DWORD
MemReserveFindByClientUID(
    IN      PM_RESERVATIONS        Reservation,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize,
    OUT     PM_RESERVATION        *Res
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Res1;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Res && ClientUID && ClientUIDSize, ERROR_INVALID_PARAMETER);
    *Res = NULL;

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( ClientUIDSize == Res1->nBytes && 0 == memcmp(ClientUID, Res1->ClientUID, ClientUIDSize)) {
            *Res = Res1;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(Reservation, &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemReserveFindByAddress(
    IN      PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    OUT     PM_RESERVATION        *Res
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Res1;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Address, ERROR_INVALID_PARAMETER);
    *Res = 0;

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( Address == Res1->Address ) {
            *Res = Res1;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(Reservation, &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\server.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for a server object
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>

#include "server.h"

#include "server\uniqid.h"

//BeginExport(function)
DWORD
MemServerInit(
    OUT     PM_SERVER             *Server,
    IN      DWORD                  Address,
    IN      DWORD                  State,
    IN      DWORD                  Policy,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    PM_SERVER                      Srv;

    AssertRet(Server, ERROR_INVALID_PARAMETER );

    Size = ROUND_UP_COUNT(sizeof(M_SERVER), ALIGN_WORST);
    if(Name) Size += sizeof(WCHAR)*(1+wcslen(Name));
    if(Comment) Size += sizeof(WCHAR)*(1+wcslen(Comment));

    Srv = MemAlloc(Size);
    if( NULL == Srv ) return ERROR_NOT_ENOUGH_MEMORY;

    Srv->LastUniqId = 0;
    Srv->Address = Address;
    Srv->State   = State;
    Srv->Policy  = Policy;
    Error = MemArrayInit(&Srv->Subnets);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemArrayInitLoc(&Srv->Subnets, &Srv->Loc);
    // Require(ERROR_SUCCESS == Error);           // guaranteed failure as the array is empty now..

    Error = MemArrayInit(&Srv->MScopes);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemArrayInit(&Srv->SuperScopes);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemOptClassInit(&Srv->Options);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemOptClassDefListInit(&Srv->OptDefs);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemClassDefListInit(&Srv->ClassDefs);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Size = ROUND_UP_COUNT(sizeof(M_SERVER), ALIGN_WORST);

    if( Name ) {
        Srv->Name = (LPWSTR)(Size + (LPBYTE)Srv);
        Size += sizeof(WCHAR)*(1 + wcslen(Name));
        wcscpy(Srv->Name, Name);
    }
    if( Comment ) {
        Srv->Comment = (LPWSTR)(Size + (LPBYTE)Srv);
        wcscpy(Srv->Comment, Comment);
    }

    *Server = Srv;
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
MemServerCleanup(
    IN OUT  PM_SERVER              Server
) //EndExport(function)
{
    DWORD                          Error;

    AssertRet(Server, ERROR_INVALID_PARAMETER);

    Error = MemArrayCleanup(&Server->Subnets);
    Require( ERROR_SUCCESS == Error);

    Error = MemArrayCleanup(&Server->MScopes);
    Require( ERROR_SUCCESS == Error);

    Error = MemArrayCleanup(&Server->SuperScopes);
    Require( ERROR_SUCCESS == Error);

    Error = MemOptClassCleanup(&Server->Options);
    Require( ERROR_SUCCESS == Error);

    Error = MemOptClassDefListCleanup(&Server->OptDefs);
    Require( ERROR_SUCCESS == Error);

    Error = MemClassDefListCleanup(&Server->ClassDefs);
    Require( ERROR_SUCCESS == Error);

    MemFree(Server);

    return ERROR_SUCCESS;
}

//================================================================================
//  subnet related functions on the server
//================================================================================

//BeginExport(function)
DWORD
MemServerGetUAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      ThisSubnet;
    DWORD                          Error;
    LONG                           Start, End, Mid;

    AssertRet(Server && (Subnet || Range || Excl || Reservation ), ERROR_INVALID_PARAMETER);
    Require( !CLASSD_HOST_ADDR( Address ) );

    //
    // more efficient binary search
    //

    if( Subnet ) {
        *Subnet = NULL;
    }

    Start = 0;
    End = MemArraySize(&Server->Subnets) - 1;

    while( Start <= End ) {                       // still got an element to go by..
        Mid = (Start + End) /2 ;

        Error = MemArrayGetElement(&Server->Subnets, &Mid, &ThisSubnet);
        Require( ERROR_SUCCESS == Error );

        Require(ThisSubnet->fSubnet);             // can't work if something inbetween aint a subnet
        if( Address < ThisSubnet->Address) {      // not in this subnet ..
            End = Mid - 1;
        } else if( ThisSubnet->Address == (ThisSubnet->Mask & Address) ) {

            //
            // We got the subnet we're looking for..
            //

            if( Range || Excl || Reservation ) {
                Error = MemSubnetGetAddressInfo(
                    ThisSubnet,
                    Address,
                    Range,
                    Excl,
                    Reservation
                    );
            } // if

            if( Subnet ) {
                *Subnet = ThisSubnet;
            }

            //
            // if we got a subnet, but didn't suceed above.. still we got something
            // so return success... otherwise return whatever above returned..
            //

            return ( Subnet && (*Subnet) ) ? ERROR_SUCCESS: Error;
        } else {

            //
            // Has to be one of the furhter down subnets..
            //

            Start = Mid + 1;
        }
    } // while

    //
    // couldn't find it unfortunately..
    //

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemServerGetMAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      ThisMScope;
    DWORD                          Error,Error2;
    PM_RANGE                       RangeTmp;

    AssertRet(Server && (Subnet || Range || Excl || Reservation ), ERROR_INVALID_PARAMETER);

    if( NULL == Range ) Range = &RangeTmp;

    Error = MemArrayInitLoc(&Server->MScopes, &Loc);
    while ( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->MScopes, &Loc, (LPVOID*)&ThisMScope);
        Require(ERROR_SUCCESS == Error);

        Error2 = MemSubnetGetAddressInfo(
            ThisMScope,
            Address,
            Range,
            Excl,
            Reservation
            );

        if (ERROR_SUCCESS == Error2) {
            if( Subnet ) *Subnet = ThisMScope;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->MScopes, &Loc);
        continue;
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemServerAddSubnet(
    IN OUT  PM_SERVER    Server,
    IN      PM_SUBNET    Subnet,  // completely created subnet, must not be
    IN      ULONG        UniqId   //  in Server's list tho'
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      OldSubnet;
    ARRAY_LOCATION                 Loc;

    AssertRet(Server && Subnet, ERROR_INVALID_PARAMETER);
    AssertRet((Subnet->Mask & Subnet->Address), ERROR_INVALID_PARAMETER);

    Subnet->ServerPtr = Server;                   // set the backptr for future use

    //
    // First check if subnet duplicates exist and avoid that
    //
    //
    for(
        Error = MemArrayInitLoc(&Server->Subnets, &Loc);
        NO_ERROR == Error ;
        Error = MemArrayNextLoc(&Server->Subnets, &Loc)
        ) {

        Error = MemArrayGetElement(&Server->Subnets, &Loc, &OldSubnet);
        Require(ERROR_SUCCESS == Error);

        if( (Subnet->Address & OldSubnet->Mask) == OldSubnet->Address
            ||
            (OldSubnet->Address & Subnet->Mask) == Subnet->Address
            ) {
            return ERROR_OBJECT_ALREADY_EXISTS;
        }
    } // for
    
    //
    // Subnets are stored in ascending order of IP addresses.. so insert
    // at the right location
    //

    Subnet->UniqId = UniqId;

    for(
        Error = MemArrayInitLoc(&Server->Subnets, &Loc)
        ; ERROR_SUCCESS == Error ;
        Error = MemArrayNextLoc(&Server->Subnets, &Loc)
    ) {
        Error = MemArrayGetElement(&Server->Subnets, &Loc, &OldSubnet);
        Require(ERROR_SUCCESS == Error);

        if( Subnet->Address == OldSubnet->Address ) {
            //
            // Subnet already present?
            //

            return ERROR_OBJECT_ALREADY_EXISTS;
        }

        if( Subnet->Address < OldSubnet->Address ) {
            //
            // right place to insert the new subnet..
            //

            Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayInsElement(&Server->Subnets, &Loc, Subnet);
            Require(ERROR_SUCCESS == Error);

            return Error;
        }
    } // for

    //
    // This subnet's address is greater than all others.. so add it at end
    //

    Error = MemArrayAddElement(&Server->Subnets, Subnet);
    if( ERROR_SUCCESS != Error) return Error;

    Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
    Require(ERROR_SUCCESS == Error);

    return ERROR_SUCCESS;
} // MemServerAddSubnet()


//
// Delete all the elements attached to this subnet.
// 
DWORD
MemServerDelSubnetElements(
    IN      PM_SUBNET   Subnet
)
{
    DWORD             Error;
    ARRAY_LOCATION    Loc, Loc2;
    PM_EXCL           Excl;
    PM_RANGE          Range;
    PM_RESERVATION    Resrv;
    PM_ONECLASS_OPTLIST OptList;
    PM_OPTION         Option;
	
    // Delete Ranges

    Error = MemArrayInitLoc( &Subnet->Ranges, &Loc );
    while (( MemArraySize( &Subnet->Ranges ) > 0 ) &&
	   ( ERROR_FILE_NOT_FOUND != Error )) {
	Error = MemArrayGetElement( &Subnet->Ranges, &Loc,
				    ( LPVOID * ) &Range );
	Require( ERROR_SUCCESS == Error );
	Error = DeleteRecord( Range->UniqId );
	if ( ERROR_SUCCESS != Error ) {
	    MemFree( Range );
	    return Error;
	}
	Error = MemArrayDelElement( &Subnet->Ranges, &Loc,
				    ( LPVOID * ) &Range );
	Require( ERROR_SUCCESS == Error );
	MemFree( Range );

    } // while
    

    
    // Delete all exclusions
    
    Error = MemArrayInitLoc( &Subnet->Exclusions, &Loc );
    while (( MemArraySize( &Subnet->Exclusions ) > 0 ) && 
	   ( ERROR_FILE_NOT_FOUND != Error )) {
	Error = MemArrayGetElement( &Subnet->Exclusions, &Loc,
				    ( LPVOID * ) &Excl );
	Require( ERROR_SUCCESS == Error );
	Error = DeleteRecord( Excl->UniqId );
	if ( ERROR_SUCCESS != Error ) {
	    MemFree( Excl );
	    return Error;
	}
	Error = MemArrayDelElement( &Subnet->Exclusions, &Loc, 
				    ( LPVOID * ) &Excl );
	Require( ERROR_SUCCESS == Error );
	MemFree( Excl );

    } // while
    
    // Delete all Reservations
    
    Error = MemArrayInitLoc( &Subnet->Reservations, &Loc );
    while (( MemArraySize( &Subnet->Reservations ) > 0 ) &&
	   ( ERROR_FILE_NOT_FOUND != Error )) {
	Error = MemArrayGetElement( &Subnet->Reservations, &Loc,
				    ( LPVOID * ) &Resrv );
	Require( ERROR_SUCCESS == Error );
	Error = MemReserveDel( &Subnet->Reservations, Resrv->Address );
//  	MemFree( Resrv );
    } // while
    
    
    // Delete all option values

    Error = MemOptClassDelClass( &Subnet->Options );

    return Error;
} // MemServerDelSubnetElements()

//BeginExport(function)
DWORD
MemServerDelSubnet(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SubnetAddress,
    OUT     PM_SUBNET             *Subnet
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      DeletedSubnet;
    ARRAY_LOCATION                 Loc;

    AssertRet(Server && Subnet, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->Subnets, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->Subnets, &Loc, (LPVOID*)&DeletedSubnet);
        Require(ERROR_SUCCESS == Error && DeletedSubnet);

        if( SubnetAddress == DeletedSubnet->Address) {
	    Error = MemServerDelSubnetElements( DeletedSubnet );
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }

	    Error = DeleteRecord( DeletedSubnet->UniqId );
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }

            Error = MemArrayDelElement(&Server->Subnets, &Loc, (LPVOID*)Subnet);
            Require(ERROR_SUCCESS == Error && Subnet);
            Require(*Subnet == DeletedSubnet);

            Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
            // Require(ERROR_SUCCESS == Error);   // this may fail if this is the last subnet being deleted
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->Subnets, &Loc);
    } // while

    return ERROR_FILE_NOT_FOUND;
} // MemServerDelSubnet()

//BeginExport(function)
DWORD
MemServerFindSubnetByName(
    IN      PM_SERVER              Server,
    IN      LPWSTR                 Name,
    OUT     PM_SUBNET             *Subnet
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      ThisSubnet;
    ARRAY_LOCATION                 Loc;

    AssertRet(Server && Name && Subnet, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->Subnets, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->Subnets, &Loc, (LPVOID*)&ThisSubnet);
        Require(ERROR_SUCCESS == Error && ThisSubnet);

        if( 0 == wcscmp(Name, ThisSubnet->Name) ) {
            *Subnet = ThisSubnet;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->Subnets, &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//================================================================================
// superscope functionality
//================================================================================

//BeginExport(constant)
#define     INVALID_SSCOPE_ID      0xFFFFFFFF
#define     INVALID_SSCOPE_NAME    NULL
//EndExport(constant)

//BeginExport(function)
DWORD
MemServerFindSScope(                              // find matching with EITHER scopeid ir sscopename
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SScopeId,      // 0xFFFFFFFF == invalid scope id, dont use for search
    IN      LPWSTR                 SScopeName,    // NULL == invalid scope name
    OUT     PM_SSCOPE             *SScope
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_SSCOPE                      ThisSScope;

    AssertRet(Server && SScope, ERROR_INVALID_PARAMETER);
    AssertRet(SScopeId != INVALID_SSCOPE_ID || SScopeName != INVALID_SSCOPE_NAME, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->SuperScopes, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->SuperScopes, &Loc, &ThisSScope);
        Require(ERROR_SUCCESS == Error && ThisSScope);

        if( ThisSScope->SScopeId == SScopeId ||
            (INVALID_SSCOPE_NAME != SScopeName && 0 == wcscmp(ThisSScope->Name, SScopeName) )) {
            *SScope = ThisSScope;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->SuperScopes, &Loc);
    }
    return ERROR_FILE_NOT_FOUND;
}

//
// Each scope has a field that specifies a superscope. The list of super scopes in 
// the memory do not contain any individual physical record in the database. The
// superscope name associated with the scope is the real physical entry.
//

//BeginExport(function)
DWORD
MemServerAddSScope(
    IN OUT  PM_SERVER              Server,
    IN      PM_SSCOPE              SScope
) //EndExport(function)
{
    DWORD                          Error;
    PM_SSCOPE                      OldSScope;

    AssertRet(
        Server && SScope && INVALID_SSCOPE_ID != SScope->SScopeId && INVALID_SSCOPE_NAME != SScope->Name,
        ERROR_INVALID_PARAMETER
    );

    Error = MemServerFindSScope(
        Server,
        SScope->SScopeId,
        SScope->Name,
        &OldSScope
    );
    if( ERROR_SUCCESS == Error && OldSScope ) return ERROR_OBJECT_ALREADY_EXISTS;

    Error = MemArrayAddElement(&Server->SuperScopes, SScope);
    return Error;
} // MemServerAddSScope()

//BeginExport(function)
DWORD
MemServerDelSScope(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SScopeId,
    OUT     PM_SSCOPE             *SScope
) //EndExport(function)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_SSCOPE                      ThisSScope;

    AssertRet(Server && SScope && INVALID_SSCOPE_ID != SScopeId, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->SuperScopes, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->SuperScopes, &Loc, (LPVOID *)&ThisSScope);
        Require(ERROR_SUCCESS == Error && ThisSScope );

        if( ThisSScope->SScopeId == SScopeId ) {
            Error = MemArrayDelElement(&Server->SuperScopes, &Loc, (LPVOID *)SScope);
            Require(ERROR_SUCCESS == Error && *SScope == ThisSScope);

            return Error;
        } // if

        Error = MemArrayNextLoc(&Server->SuperScopes, &Loc);
    } // while
    return ERROR_FILE_NOT_FOUND;
} // MemServerDelSScope()

//================================================================================
// MCAST scope functionality
//================================================================================

//BeginExport(constants)
#define     INVALID_MSCOPE_ID      0x0
#define     INVALID_MSCOPE_NAME    NULL
//EndExport(constants)

//BeginExport(function)
DWORD
MemServerFindMScope(                              // search either based on ScopeId or ScopeName
    IN      PM_SERVER              Server,
    IN      DWORD                  MScopeId,      // Multicast scope id, or 0 if this is not the key to search on
    IN      LPWSTR                 Name,          // Multicast scope name or NULL if this is not the key to search on
    OUT     PM_MSCOPE             *MScope
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_MSCOPE                      ThisMScope;

    AssertRet(Server && MScope, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->MScopes, &Loc);
    while (ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->MScopes, &Loc, &ThisMScope);
        Require(ERROR_SUCCESS == Error && ThisMScope );

        if( MScopeId == ThisMScope->MScopeId ||
            (Name !=  INVALID_MSCOPE_NAME && 0 == wcscmp(Name, ThisMScope->Name)) ) {
            *MScope = ThisMScope;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->MScopes, &Loc);
    }
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemServerAddMScope(
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_MSCOPE              MScope,
    IN      ULONG                  UniqId
) //EndExport(function)
{
    DWORD                          Error;
    PM_MSCOPE                      OldMScope;

    AssertRet(Server && MScope, ERROR_INVALID_PARAMETER);
    AssertRet(MScope->MScopeId != INVALID_MSCOPE_ID && MScope->Name != INVALID_MSCOPE_NAME, ERROR_INVALID_PARAMETER);

    MScope->ServerPtr = Server;                   // set the backptr for future use
    Error = MemServerFindMScope(
        Server,
        MScope->Address,
        MScope->Name,
        &OldMScope
    );

    if( ERROR_SUCCESS == Error && OldMScope ) return ERROR_OBJECT_ALREADY_EXISTS;

    MScope->UniqId = UniqId;
    Error = MemArrayAddElement(&Server->MScopes, (LPVOID)MScope);
    Require(ERROR_SUCCESS == Error);

    return Error;
}

//BeginExport(function)
DWORD
MemServerDelMScope(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  MScopeId,
    IN      LPWSTR                 MScopeName,
    OUT     PM_MSCOPE             *MScope
) //EndExport(function)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_MSCOPE                      ThisMScope;

    AssertRet(Server && MScope && MScopeName != INVALID_MSCOPE_NAME,
              ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->MScopes, &Loc);
    while (ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->MScopes, &Loc, &ThisMScope);
        Require(ERROR_SUCCESS == Error && ThisMScope );

        if ( INVALID_MSCOPE_ID != MScopeId ) {
            if( MScopeId == ThisMScope->MScopeId ) {

		Error = MemServerDelSubnetElements( ThisMScope );
		if ( ERROR_SUCCESS != Error ) {
		    return Error;
		}

		Error = DeleteRecord( ThisMScope->UniqId );
		if ( ERROR_SUCCESS != Error ) {
		    return Error;
		}

                Error = MemArrayDelElement(&Server->MScopes, &Loc, MScope);
                Require(ERROR_SUCCESS == Error && *MScope == ThisMScope);

                return Error;
            } // if
        } // if

        if ( INVALID_MSCOPE_NAME != MScopeName ) {
            if( !wcscmp(MScopeName, ThisMScope->Name ) ) {
		Error = MemServerDelSubnetElements( ThisMScope );
		if ( ERROR_SUCCESS != Error ) {
		    return Error;
		}

		Error = DeleteRecord( ThisMScope->UniqId );
		if ( ERROR_SUCCESS != Error ) {
		    return Error;
		}

                Error = MemArrayDelElement(&Server->MScopes, &Loc, MScope);
                Require(ERROR_SUCCESS == Error && *MScope == ThisMScope);

                return Error;
            }
        } // if

        Error = MemArrayNextLoc(&Server->MScopes, &Loc);
    } // while
    return ERROR_FILE_NOT_FOUND;
} // MemServerDelMScope()

//================================================================================
// ClassId related stuff
//================================================================================
//BeginExport(function)
DWORD
MemServerGetOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,       // required, strict search, no defaulting class to zero
    IN      DWORD                  VendorId,      // required, strict search, no defaulting vendor to zero
    IN      DWORD                  OptId,         // OPTIONAL - search by this or following param
    IN      LPWSTR                 OptName,       // OPTIONAL - search by name or above param
    OUT     PM_OPTDEF             *OptDef         // if found return the opt def here
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTDEFLIST                  OptDefList;

    Require(OptDef);

    Error = MemOptClassDefListFindOptDefList(
        &Server->OptDefs,
        ClassId,
        VendorId,
        &OptDefList
    );
    if( ERROR_SUCCESS != Error ) return Error;

    Require(OptDefList);

    return MemOptDefListFindOptDef(
        OptDefList,
        OptId,
        OptName,
        OptDef
    );
}

//BeginExport(function)
DWORD
MemServerAddOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,
    IN      LPWSTR                 OptComment,
    IN      DWORD                  Type,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptValLen,
    IN      ULONG                  UniqId
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTDEF                      OptDef;

    return MemOptClassDefListAddOptDef(
        &Server->OptDefs,
        ClassId,
        VendorId,
        OptId,
        Type,
        OptName,
        OptComment,
        OptVal,
        OptValLen,
	UniqId
    );
} // MemOptClassDefListAddOptDef()

//BeginExport(function)
DWORD
MemServerDelOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTDEFLIST                  OptDefList;

    Error = MemOptClassDefListFindOptDefList(
        &Server->OptDefs,
        ClassId,
        VendorId,
        &OptDefList
    );
    if( ERROR_SUCCESS != Error ) return Error;

    return MemOptDefListDelOptDef(
        OptDefList,
        OptId
    );
}


//================================================================================
// end of File
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\sscope.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for superscopes
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>

#include "sscope.h"

ULONG                  ScopeIdCount = 1;

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\reserve.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _MM_RESERVE_H_
#define _MM_RESERVE_H_

#include "server\uniqid.h"

typedef struct _M_RESERVATION  {
    LPVOID                         SubnetPtr;
    DWORD                          Address;
    DWORD                          Flags;
    DWORD                          nBytes;
    LPBYTE                         ClientUID;
    M_OPTCLASS                     Options;
    ULONG                          UniqId;
} M_RESERVATION , *PM_RESERVATION , *LPM_RESERVATION ;


typedef ARRAY                      M_RESERVATIONS;
typedef PARRAY                     PM_RESERVATIONS;
typedef LPARRAY                    LPM_RESERVATIONS;


DWORD       _inline
MemReserve1Init(
    OUT     PM_RESERVATION        *Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  nBytesClientUID
) {
    PM_RESERVATION                 Res1;
    DWORD                          Size;
    DWORD                          Error;

    AssertRet(Reservation && ClientUID && nBytesClientUID, ERROR_INVALID_PARAMETER);
    Require(Address);

    *Reservation = NULL;

    Size = ROUND_UP_COUNT(sizeof(M_RESERVATION ), ALIGN_WORST);
    Size += nBytesClientUID;

    Res1 = MemAlloc(Size);
    if( NULL == Res1 ) return ERROR_NOT_ENOUGH_MEMORY;

    Res1->SubnetPtr = NULL;
    Res1->Address   = Address;
    Res1->Flags     = Flags;
    Res1->nBytes    = nBytesClientUID;
    Res1->ClientUID = Size - nBytesClientUID + (LPBYTE)Res1;
    memcpy(Res1->ClientUID, ClientUID, nBytesClientUID);
    Error = MemOptClassInit(&(Res1->Options));
    Require(ERROR_SUCCESS == Error);

    Res1->UniqId = INVALID_UNIQ_ID;

    *Reservation = Res1;

    return ERROR_SUCCESS;
}


DWORD       _inline
MemReserve1Cleanup(
    IN      PM_RESERVATION         Reservation
) {
    DWORD                          Error;
    AssertRet(Reservation, ERROR_INVALID_PARAMETER);

    Error = MemOptClassCleanup(&(Reservation->Options));
    Require(ERROR_SUCCESS == Error);

    MemFree(Reservation);
    return ERROR_SUCCESS;
}


DWORD       _inline
MemReserveInit(
    IN OUT  PM_RESERVATIONS        Reservation
) {
    return MemArrayInit(Reservation);
}


DWORD       _inline
MemReserveCleanup(
    IN      PM_RESERVATIONS        Reservation
) {
    return MemArrayCleanup(Reservation);
}


DWORD
MemReserveAdd(                                    // new client, should not exist before
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize,
    IN      ULONG                  UniqId
) ;


DWORD
MemReserveReplace(                                // old client, should exist before
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize
) ;


DWORD
MemReserveDel(
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address
) ;


DWORD
MemReserveFindByClientUID(
    IN      PM_RESERVATIONS        Reservation,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize,
    OUT     PM_RESERVATION        *Res
) ;


DWORD
MemReserveFindByAddress(
    IN      PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    OUT     PM_RESERVATION        *Res
) ;

#endif // _MM_RESERVE_H_

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\server2.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _MM_SERVER2_H_
#define _MM_SERVER2_H_

BOOL
MemServerIsSwitchedSubnet(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;


BOOL
MemServerIsSubnetDisabled(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;


BOOL
MemServerIsExcludedAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;


BOOL
MemServerIsReservedAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;


BOOL
MemServerIsOutOfRangeAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress,
    IN      BOOL                   fBootp
) ;


DWORD
MemServerGetSubnetMaskForAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;

#endif // _MM_SERVER2_H_

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\sscope.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _MM_SSCOPE_H_
#define _MM_SSCOPE_H_

typedef struct _M_SSCOPE {
    DWORD                          SScopeId;
    DWORD                          Policy;
    LPWSTR                         Name;
    M_OPTCLASS                     Options;
} M_SSCOPE, *PM_SSCOPE, *LPM_SSCOPE;


extern      ULONG                  ScopeIdCount;


DWORD       _inline
MemSScopeInit(
    OUT     PM_SSCOPE             *SScope,
    IN      DWORD                  Policy,
    IN      LPWSTR                 Name
) {
    PM_SSCOPE                      RetVal;
    DWORD                          Size;
    DWORD                          Error;

    AssertRet(SScope, ERROR_INVALID_PARAMETER);

    Size = ROUND_UP_COUNT(sizeof(M_SSCOPE), ALIGN_WORST);
    Size += (1+wcslen(Name))*sizeof(WCHAR);

    RetVal = MemAlloc(Size);
    if( NULL == RetVal ) return ERROR_NOT_ENOUGH_MEMORY;

    RetVal->SScopeId = InterlockedIncrement(&ScopeIdCount);
    RetVal->Policy   = Policy;
    RetVal->Name = (LPWSTR)(ROUND_UP_COUNT(sizeof(M_SSCOPE),ALIGN_WORST) + (LPBYTE)RetVal);
    wcscpy(RetVal->Name, Name);

    Error = MemOptClassInit(&RetVal->Options);
    if( ERROR_SUCCESS != Error ) {
        MemFree(RetVal);
        RetVal = NULL;
    }

    *SScope = RetVal;
    return Error;
}


DWORD       _inline
MemSScopeCleanup(
    IN OUT  PM_SSCOPE              SScope
) {
    DWORD                          Error;

    AssertRet(SScope, ERROR_INVALID_PARAMETER);

    Error = MemOptClassCleanup(&SScope->Options);
    MemFree(SScope);

    return Error;
}


DWORD       _inline
MemSubnetSetSuperScope(
    IN OUT  PM_SUBNET              Subnet,
    IN      PM_SSCOPE              SScope
) {
    AssertRet(Subnet && SScope, ERROR_INVALID_PARAMETER);

    Subnet->SuperScopeId = SScope->SScopeId;
    return ERROR_SUCCESS;
}

#endif // _MM_SSCOPE_H_

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\server.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//========================================================================

#ifndef _MM_SERVER_H_
#define _MM_SERVER_H_

#include    <dhcp.h>

#include "classdefl.h"

typedef struct _M_SERVER {
    DWORD                          Address;
    DWORD                          State;
    DWORD                          Policy;
    ARRAY                          Subnets;
    ARRAY                          MScopes;
    ARRAY_LOCATION                 Loc;           // if RoundRobin on, then we need this to keep track
    ARRAY                          SuperScopes;
    M_OPTCLASS                     Options;
    M_OPTCLASSDEFLIST              OptDefs;
    M_CLASSDEFLIST                 ClassDefs;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    ULONG                          LastUniqId;
} M_SERVER, *PM_SERVER, *LPM_SERVER;


DWORD
MemServerInit(
    OUT     PM_SERVER             *Server,
    IN      DWORD                  Address,
    IN      DWORD                  State,
    IN      DWORD                  Policy,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment
) ;


DWORD
MemServerCleanup(
    IN OUT  PM_SERVER              Server
) ;


DWORD
MemServerGetUAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) ;


DWORD
MemServerGetMAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) ;


DWORD       _inline
MemServerGetAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) {
    if (CLASSD_HOST_ADDR( Address )) {
        return MemServerGetMAddressInfo(
                    Server,
                    Address,
                    Subnet,
                    Range,
                    Excl,
                    Reservation
                    );
    } else {
        return MemServerGetUAddressInfo(
                    Server,
                    Address,
                    Subnet,
                    Range,
                    Excl,
                    Reservation
                    );
    }

} // MemServerGetAddressInfo()


DWORD
MemServerAddSubnet(
    IN OUT  PM_SERVER  Server,
    IN      PM_SUBNET  Subnet,  // completely created subnet, must not
    IN      ULONG      UniqId   // be in Server's list tho'
) ;


DWORD
MemServerDelSubnet(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SubnetAddress,
    OUT     PM_SUBNET             *Subnet
) ;


DWORD
MemServerFindSubnetByName(
    IN      PM_SERVER              Server,
    IN      LPWSTR                 Name,
    OUT     PM_SUBNET             *Subnet
) ;


#define     INVALID_SSCOPE_ID      0xFFFFFFFF
#define     INVALID_SSCOPE_NAME    NULL


DWORD
MemServerFindSScope(                              // find matching with EITHER scopeid ir sscopename
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SScopeId,      // 0xFFFFFFFF == invalid scope id, dont use for search
    IN      LPWSTR                 SScopeName,    // NULL == invalid scope name
    OUT     PM_SSCOPE             *SScope
) ;


DWORD
MemServerAddSScope(
    IN OUT  PM_SERVER              Server,
    IN      PM_SSCOPE              SScope
) ;


DWORD
MemServerDelSScope(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SScopeId,
    OUT     PM_SSCOPE             *SScope
) ;


#define     INVALID_MSCOPE_ID      0x0
#define     INVALID_MSCOPE_NAME    NULL


DWORD
MemServerFindMScope(                              // search either based on ScopeId or ScopeName
    IN      PM_SERVER              Server,
    IN      DWORD                  MScopeId,      // Multicast scope id, or 0 if this is not the key to search on
    IN      LPWSTR                 Name,          // Multicast scope name or NULL if this is not the key to search on
    OUT     PM_MSCOPE             *MScope
) ;


DWORD
MemServerAddMScope(
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_MSCOPE              MScope,
    IN      ULONG                  UniqId
) ;


DWORD
MemServerDelMScope(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  MScopeId,
    IN      LPWSTR                 MScopeName,
    OUT     PM_MSCOPE             *MScope
) ;


DWORD       _inline
MemServerGetClassDef(                             // look up a class id def on Key=ClassId or Key=ClassIdBytes
    IN      PM_SERVER              Server,
    IN      DWORD                  ClassId,       // OPTIONAL, 0 if not used
    IN      LPWSTR                 Name,          // OPTIONAL, NULL if not used
    IN      DWORD                  nClassIdBytes, // OPTIONAL, 0 if not used
    IN      LPBYTE                 ClassIdBytes,  // OPTIONAL, NULL if not used
    OUT     PM_CLASSDEF           *ClassDef
) {
    AssertRet(Server && ClassDef && (0 != ClassId || 0 != nClassIdBytes || Name ), ERROR_INVALID_PARAMETER);
    AssertRet( 0 == nClassIdBytes || NULL != ClassIdBytes, ERROR_INVALID_PARAMETER);
    AssertRet( 0 != nClassIdBytes || NULL == ClassIdBytes, ERROR_INVALID_PARAMETER);

    return MemClassDefListFindOptDef(
        &Server->ClassDefs,
        ClassId,
        Name,
        ClassIdBytes,
        nClassIdBytes,
        ClassDef
    );
}


DWORD       _inline
MemServerAddClassDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      BOOL                   IsVendor,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  nClassIdBytes,
    IN      LPBYTE                 ClassIdBytes,
    IN      ULONG                  UniqId
) 
{
    AssertRet(Server, ERROR_INVALID_PARAMETER);

    return MemClassDefListAddClassDef(
        &Server->ClassDefs,
        ClassId,
        IsVendor,
        0,
        Name,
        Comment,
        ClassIdBytes,
        nClassIdBytes,
	UniqId
    );
} // MemServerAddClassDef()


DWORD       _inline
MemServerDelClassDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      DWORD                  nClassIdBytes,
    IN      LPBYTE                 ClassIdBytes
) {
    AssertRet(Server, ERROR_INVALID_PARAMETER);

    return MemClassDefListDelClassDef(
        &Server->ClassDefs,
        ClassId,
        Name,
        ClassIdBytes,
        nClassIdBytes
    );
}


DWORD
MemServerGetOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,       // required, strict search, no defaulting class to zero
    IN      DWORD                  VendorId,      // required, strict search, no defaulting vendor to zero
    IN      DWORD                  OptId,         // OPTIONAL - search by this or following param
    IN      LPWSTR                 OptName,       // OPTIONAL - search by name or above param
    OUT     PM_OPTDEF             *OptDef         // if found return the opt def here
) ;


DWORD
MemServerAddOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,
    IN      LPWSTR                 OptComment,
    IN      DWORD                  Type,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptValLen,
    IN      ULONG                  UniqId
) ;


DWORD
MemServerDelOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId
) ;

#endif _MM_SERVER_H_

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\server2.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the overall access api's (most of them)
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>
#include    <address.h>
#include    <dhcpapi.h>
#include "server2.h"

//BeginExport(function)
BOOL
MemServerIsSwitchedSubnet(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return IS_SWITCHED(Subnet->State);
}

//BeginExport(function)
BOOL
MemServerIsSubnetDisabled(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return IS_DISABLED(Subnet->State);
}

//BeginExport(function)
BOOL
MemServerIsExcludedAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_EXCL                        Excl;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        NULL,
        NULL,
        &Excl,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return (NULL != Excl);
}

//BeginExport(function)
BOOL
MemServerIsReservedAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Reservation;

    Error = MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        NULL,
        NULL,
        NULL,
        &Reservation
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return NULL != Reservation;
}


//BeginExport(function)
BOOL
MemServerIsOutOfRangeAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;
    PM_RANGE                       Range;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        &Subnet,
        &Range,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return TRUE;

    if( NULL == Range ) return TRUE;
    if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP : MM_FLAG_ALLOW_DHCP) ) ) {
        return TRUE;
    }
    return FALSE;
}

//BeginExport(function)
DWORD
MemServerGetSubnetMaskForAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return 0;

    Require(Subnet);
    return Subnet->Mask;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\subnet2.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

#ifndef _MM_SUBNET2_H_
#define _MM_SUBNET2_H_


DWORD
MemSubnetModify(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      DWORD                  SuperScopeId,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description
) ;


DWORD
MemMScopeModify(
    IN      PM_SUBNET              MScope,
    IN      DWORD                  ScopeId,
    IN      DWORD                  State,
    IN      DWORD                  Policy,
    IN      BYTE                   TTL,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description,
    IN      LPWSTR                 LangTag,
    IN      DATE_TIME              ExpiryTime
) ;

#endif // _MM_SUBNET2_H_

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\subnet.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

#ifndef _MM_SUBNET_H_
#define _MM_SUBNET_H_

typedef struct _M_SUBNET {
    LPVOID                         ServerPtr;     // Ptr to Server object
    union {
        struct {                                  // for normal subnet.
            DWORD                      Address;
            DWORD                      Mask;
            DWORD                      SuperScopeId;  // unused for MCAST scopes
        };
        struct {                                  // for multicast scope
            DWORD                      MScopeId;
            LPWSTR                     LangTag;       // the language tag for multicast scope
            BYTE                       TTL;
        };
    };
    DWORD                          fSubnet;       // TRUE => Subnet, FALSE => MSCOPE
    DWORD                          State;
    DWORD                          Policy;
    DATE_TIME                      ExpiryTime;     // Scope Lifetime. Currently used for MCast only.
    M_OPTCLASS                     Options;
    ARRAY                          Ranges;
    ARRAY                          Exclusions;
    M_RESERVATIONS                 Reservations;
    ARRAY                          Servers;       // future use, Server-Server protocol
    LPWSTR                         Name;
    LPWSTR                         Description;
    ULONG                          UniqId;
} M_SUBNET, *PM_SUBNET, *LPM_SUBNET;


enum /* Anonymous */ {
    AddressPolicyNone = 0,
    AddressPolicySequential,
    AddressPolicyRoundRobin
};


DWORD
MemSubnetInit(
    OUT     PM_SUBNET             *pSubnet,
    IN      DWORD                  Address,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      DWORD                  SuperScopeId,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description
) ;


DWORD
MemMScopeInit(
    OUT     PM_SUBNET             *pMScope,
    IN      DWORD                  MScopeId,
    IN      DWORD                  State,
    IN      DWORD                  AddressPolicy,
    IN      BYTE                   TTL,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description,
    IN      LPWSTR                 LangTag,
    IN      DATE_TIME              ExpiryTime
) ;


DWORD       _inline
MemSubnetCleanup(
    IN OUT  PM_SUBNET              Subnet
)
{
    DWORD                          Error;

    AssertRet(Subnet, ERROR_INVALID_PARAMETER);
    Require(Subnet->Address&Subnet->Mask);

    Error = MemOptClassCleanup(&Subnet->Options);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayCleanup(&Subnet->Ranges);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayCleanup(&Subnet->Exclusions);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayCleanup(&Subnet->Servers);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemReserveCleanup(&Subnet->Reservations);
    if( ERROR_SUCCESS != Error ) return Error;

    MemFree(Subnet);
    return ERROR_SUCCESS;
}


DWORD                                             // SUCCESS if either of Excl or Range get filled, else FILE_NOT_FOUND
MemSubnetGetAddressInfo(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    OUT     PM_RANGE              *Range,         // OPTIONAL -- filled if a range could be found -- even if excluded
    OUT     PM_EXCL               *Excl,          // OPTIONAL -- filled if an exclusion could be found
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL -- filled with  a matching reservation, if found
) ;


DWORD                                             // ERROR_SUCCESS on finding a collition, else ERROR_FILE_NOT_FOUND
MemSubnetFindCollision(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl           // OPTIONAL
) ;


DWORD                                             // ERROR_OBJECT_ALREADY_EXISTS on collision
MemSubnetAddRange(                                // check if the range is valid, and only then add it
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    IN      DWORD                  State,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    OUT     PM_RANGE              *OverlappingRange,
    IN      ULONG                  UniqId
) ;


DWORD
MemSubnetAddRangeExpandOrContract(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  StartAddress,
    IN      DWORD                  EndAddress,
    OUT     DWORD                 *OldStartAddress,
    OUT     DWORD                 *OldEndAddress
) ;


DWORD
MemSubnetAddExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    OUT     PM_EXCL               *OverlappingExcl,
    IN      ULONG                  UniqId
) ;


DWORD
MemSubnetDelRange(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start
) ;


DWORD
MemSubnetDelExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start
) ;


DWORD
MemSubnetExtendOrContractRange(
    IN OUT  PM_SUBNET              Subnet,
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
) ;


DWORD
MemSubnetExtendOrContractExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN OUT  PM_EXCL                Excl,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
) ;


typedef     M_SUBNET               M_MSCOPE;      // same structure for Multicast Scopes and Subnets
typedef     PM_SUBNET              PM_MSCOPE;     // still, use the correct functions for MScope
typedef     LPM_SUBNET             LPM_MSCOPE;


DWORD       _inline
MemMScopeCleanup(
    IN      PM_MSCOPE              MScope
) {
    return MemSubnetCleanup(MScope);
}


#define     MemMScopeGetAddressInfo               MemSubnetGetAddressInfo
#define     MemMScopeFindCollision                MemSubnetFindCollision
#define     MemMScopeAddExcl                      MemSubnetAddExcl
#define     MemMScopeDelRange                     MemSubnetDelRange
#define     MemMScopeDelExcl                      MemSubnetDelExcl
#define     MemMScopeExtendOrContractRange        MemSubnetExtendOrContractRange
#define     MemMScopeExtendOrContractExcl         MemSubnetExtendOrContractExcl

DWORD
MemMScopeGetAddressInfo(
    IN      PM_MSCOPE              MScope,
    IN      DWORD                  MCastAddress,
    OUT     PM_RANGE              *Range,         // OPTIONAL -- filled if a range could be found -- even if excluded
    OUT     PM_EXCL               *Excl,          // OPTIONAL -- filled if an exclusion could be found
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL -- filled with  a matching reservation, if found
);

DWORD                                             // ERROR_SUCCESS on finding a collition, else ERROR_FILE_NOT_FOUND
MemMScopeFindCollision(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart,
    IN      DWORD                  MCastEnd,
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl           // OPTIONAL
);



DWORD       _inline                               // ERROR_OBJECT_ALREADY_EXISTS on collision
MemMScopeAddRange(                                // check if the range is valid, and only then add it
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart,
    IN      DWORD                  MCastEnd,
    IN      DWORD                  State,
    OUT     PM_RANGE              *OverlappingRange,
    IN      ULONG                  UniqId
)
{
    return MemSubnetAddRange( Subnet,MCastStart, MCastEnd,
			      State, 0, 0, OverlappingRange, UniqId );
}


DWORD
MemMScopeAddExcl(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart,
    IN      DWORD                  MCastEnd,
    OUT     PM_EXCL               *OverlappingExcl,
    IN      ULONG                  UniqId
);

DWORD
MemMScopeDelRange(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart
);

DWORD
MemMScopeDelExcl(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart
);

DWORD
MemMScopeExtendOrContractRange(
    IN OUT  PM_MSCOPE              Subnet,
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
);

DWORD
MemMScopeExtendOrContractExcl(
    IN OUT  PM_MSCOPE              Subnet,
    IN OUT  PM_EXCL                Excl,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
);

#endif _MM_SUBNET_H_

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\subnet.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for managing (multicast) scopes
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <dhcp.h>
#include    <winnls.h>

#include "server\uniqid.h"

#include "subnet.h"


// the following are the flags bits used for subnet object.
#define DEFAULT_SCOPE   0x01
#define IS_DEFAULT_SCOPE( _subnet )     ((_subnet)->Flags & DEFAULT_SCOPE == DEFAULT_SCOPE )
#define SET_DEFAULT_SCOPE( _subnet )    ((_subnet)->Flags |= DEFAULT_SCOPE )
#define RESET_DEFAULT_SCOPE( _subnet )  ((_subnet)->Flags &= ~DEFAULT_SCOPE)


//BeginExport(function)
DWORD
MemSubnetInit(
    OUT     PM_SUBNET             *pSubnet,
    IN      DWORD                  Address,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      DWORD                  SuperScopeId,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    PM_SUBNET                      Subnet;

    AssertRet(pSubnet, ERROR_INVALID_PARAMETER);
    AssertRet( !(CLASSD_HOST_ADDR(Address)||CLASSE_HOST_ADDR(Address)),
               ERROR_INVALID_PARAMETER );
    Require((Address&Mask));

    *pSubnet = NULL;

    Size = ROUND_UP_COUNT(sizeof(*Subnet), ALIGN_WORST);
    Size += sizeof(WCHAR) * (Name?(1+wcslen(Name)):0);
    Size += sizeof(WCHAR) * (Description?(1+wcslen(Description)):0);

    Subnet = MemAlloc(Size);
    if( NULL == Subnet) return ERROR_NOT_ENOUGH_MEMORY;

    Size = ROUND_UP_COUNT(sizeof(*Subnet), ALIGN_WORST);

    Subnet->Name = Subnet->Description = NULL;
    if( Name ) {
        Subnet->Name = (LPWSTR)(Size + (LPBYTE)Subnet);
        wcscpy(Subnet->Name, Name);
        Size += sizeof(WCHAR) * ( 1 + wcslen(Name));
    }

    if( Description ) {
        Subnet->Description = (LPWSTR)( Size + (LPBYTE)Subnet );
        wcscpy(Subnet->Description, Description);
    }

    Subnet->ServerPtr    = NULL;
    Subnet->Address      = Address;
    Subnet->Mask         = Mask;
    Subnet->State        = State;
    Subnet->SuperScopeId = SuperScopeId;
    Subnet->fSubnet      = TRUE;
    Subnet->Policy       = AddressPolicyNone;
    Subnet->UniqId       = INVALID_UNIQ_ID;
    
    Error = MemOptClassInit(&Subnet->Options);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    Error = MemArrayInit(&Subnet->Ranges);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    Error = MemArrayInit(&Subnet->Exclusions);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    Error = MemArrayInit(&Subnet->Servers);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    Error = MemReserveInit(&Subnet->Reservations);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    *pSubnet = Subnet;
    return ERROR_SUCCESS;
}

VOID
GetLangTag(
    WCHAR LangTag[]
    )
{
    WCHAR b1[8], b2[8];

    b1[0] = b2[0] = L'\0';
    GetLocaleInfoW(
        LOCALE_SYSTEM_DEFAULT, LOCALE_SISO639LANGNAME,
        b1, sizeof(b1)/sizeof(b1[0])
        );
    
    GetLocaleInfoW(
        LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME,
        b2, sizeof(b2)/sizeof(b2[0])
        );
    
    if (_wcsicmp(b1, b2))
        wsprintf(LangTag, L"%s-%s", b1, b2);
    else
        wcscpy(LangTag, b1);
}

//BeginExport(function)
DWORD
MemMScopeInit(
    OUT     PM_SUBNET             *pMScope,
    IN      DWORD                  MScopeId,
    IN      DWORD                  State,
    IN      DWORD                  AddressPolicy,
    IN      BYTE                   TTL,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description,
    IN      LPWSTR                 LangTag,
    IN      DATE_TIME              ExpiryTime
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    PM_SUBNET                      MScope;
    WCHAR                          DummyLangTag[100];
    
    AssertRet(pMScope, ERROR_INVALID_PARAMETER);
    //AssertRet(MScopeId, ERROR_INVALID_PARAMETER);
    Require(LangTag);

    if( NULL == LangTag ) {
        LangTag = DummyLangTag;
        GetLangTag(DummyLangTag);
    }
    
    *pMScope = NULL;

    Size = ROUND_UP_COUNT(sizeof(*MScope), ALIGN_WORST);
    Size += sizeof(WCHAR) * (Name?(1+wcslen(Name)):0);
    Size += sizeof(WCHAR) * (Description?(1+wcslen(Description)):0);
    Size += sizeof(WCHAR) * (1+wcslen(LangTag));

    MScope = MemAlloc(Size);
    if( NULL == MScope) return ERROR_NOT_ENOUGH_MEMORY;

    Size = ROUND_UP_COUNT(sizeof(*MScope), ALIGN_WORST);

    MScope->Name = MScope->Description = MScope->LangTag = NULL;

    if( Name ) {
        MScope->Name = (LPWSTR)(Size + (LPBYTE)MScope);
        wcscpy(MScope->Name, Name);
        Size += sizeof(WCHAR) * ( 1 + wcslen(Name));
    }

    if( Description ) {
        MScope->Description = (LPWSTR)( Size + (LPBYTE)MScope );
        wcscpy(MScope->Description, Description);
        Size += sizeof(WCHAR) * ( 1 + wcslen(Description));
    }

    MScope->LangTag = (LPWSTR)( Size + (LPBYTE)MScope );
    wcscpy(MScope->LangTag, LangTag);

    MScope->ServerPtr    = NULL;
    MScope->MScopeId     = MScopeId;
    MScope->State        = State;
    MScope->TTL          = TTL;
    MScope->fSubnet      = FALSE;
    MScope->Policy       = AddressPolicy;
    MScope->ExpiryTime   = ExpiryTime;

    Error = MemOptClassInit(&MScope->Options);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    Error = MemArrayInit(&MScope->Ranges);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    Error = MemArrayInit(&MScope->Exclusions);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    Error = MemArrayInit(&MScope->Servers);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    Error = MemReserveInit(&MScope->Reservations);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    *pMScope = MScope;
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD                                             // SUCCESS if either of Excl or Range get filled, else FILE_NOT_FOUND
MemSubnetGetAddressInfo(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    OUT     PM_RANGE              *Range,         // OPTIONAL -- filled if a range could be found -- even if excluded
    OUT     PM_EXCL               *Excl,          // OPTIONAL -- filled if an exclusion could be found
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL -- filled with  a matching reservation, if found
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    DWORD                          RetError;
    PM_RANGE                       ThisRange;
    PM_EXCL                        ThisExcl;

    AssertRet(Subnet && (Range || Excl || Reservation), ERROR_INVALID_PARAMETER );

    if( Subnet->fSubnet && (Address & Subnet->Mask) != Subnet->Address )
        return ERROR_FILE_NOT_FOUND;              // it is ok for MSCOPE objects, as Address refers to ScopeId

    RetError = ERROR_FILE_NOT_FOUND;
    if( Range ) {
        *Range = NULL;
        Error = MemArrayInitLoc(&Subnet->Ranges, &Location);
        while( ERROR_FILE_NOT_FOUND != Error ) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(&Subnet->Ranges, &Location, (LPVOID *)&ThisRange);
            Require(ERROR_SUCCESS == Error && ThisRange);

            if( ThisRange->Start <= Address && Address <= ThisRange->End ) {
                *Range = ThisRange;
                RetError = ERROR_SUCCESS;
                break;
            }

            Error = MemArrayNextLoc(&Subnet->Ranges, &Location);
        }
    }

    if( Excl ) {
        *Excl = NULL;
        Error = MemArrayInitLoc(&Subnet->Exclusions, &Location);
        while( ERROR_FILE_NOT_FOUND != Error ) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(&Subnet->Exclusions, &Location, (LPVOID *)&ThisExcl);
            Require(ERROR_SUCCESS == Error && ThisExcl);

            if( ThisExcl->Start <= Address && Address <= ThisExcl->End ) {
                *Excl = ThisExcl;
                RetError = ERROR_SUCCESS;
                break;
            }

            Error = MemArrayNextLoc(&Subnet->Exclusions, &Location);
        }
    }

    if( Reservation ) {
        *Reservation = NULL;

        Error = MemReserveFindByAddress(&Subnet->Reservations, Address, Reservation);
        if( ERROR_SUCCESS == Error ) RetError = ERROR_SUCCESS;
    }

    return RetError;
}

//BeginExport(function)
DWORD                                             // ERROR_SUCCESS on finding a collition, else ERROR_FILE_NOT_FOUND
MemSubnetFindCollision(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl           // OPTIONAL
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    DWORD                          RetError;
    DWORD                          Cond;
    PM_RANGE                       ThisRange;
    PM_EXCL                        ThisExcl;

    Require(Subnet && (Range || Excl));
    if( Subnet->fSubnet ) {                       // checks ommitted for MCAST scopes.
        if( (Start & Subnet->Mask) != (End & Subnet->Mask) )
            return ERROR_INVALID_PARAMETER;
        if( (Start & Subnet->Mask) != (Subnet->Address & Subnet->Mask) )
            return ERROR_INVALID_PARAMETER;
    }

    RetError = ERROR_FILE_NOT_FOUND;
    if(Range) {
        *Range = NULL;
        Error = MemArrayInitLoc(&Subnet->Ranges, &Location);
        while( ERROR_FILE_NOT_FOUND != Error ) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(&Subnet->Ranges, &Location, (LPVOID *)&ThisRange);
            Require(ERROR_SUCCESS == Error && ThisRange);

            Cond = MemRangeCompare(Start,End, ThisRange->Start, ThisRange->End);
            if( Cond != X_LESSTHAN_Y && Cond != Y_LESSTHAN_X ) {
                // Collision has occured
                *Range = ThisRange;
                RetError = ERROR_SUCCESS;
                break;
            }

            Error = MemArrayNextLoc(&Subnet->Ranges, &Location);
        }
    }

    if( Excl ) {
        *Excl = NULL;
        Error = MemArrayInitLoc(&Subnet->Exclusions, &Location);
        while( ERROR_FILE_NOT_FOUND != Error ) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(&Subnet->Exclusions, &Location, (LPVOID *)&ThisExcl);
            Require(ERROR_SUCCESS == Error && ThisExcl);

            Cond = MemRangeCompare(Start,End, ThisExcl->Start, ThisExcl->End);
            if( Cond != X_LESSTHAN_Y && Cond != Y_LESSTHAN_X ) {
                *Excl = ThisExcl;
                RetError = ERROR_SUCCESS;
                break;
            }

            Error = MemArrayNextLoc(&Subnet->Exclusions, &Location);
        }
    }

    return RetError;
}



//BeginExport(function)
DWORD                                             // ERROR_OBJECT_ALREADY_EXISTS on collision
MemSubnetAddRange(                                // check if the range is valid, and only then add it
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    IN      DWORD                  State,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    OUT     PM_RANGE              *OverlappingRange,
    IN      ULONG                  UniqId
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    PM_RANGE                       NewRange;

    AssertRet(Subnet && OverlappingRange, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet ) {
        if( (Subnet->Address & Subnet->Mask) != (Start & Subnet->Mask) ||
            (Start & Subnet->Mask)  != (End & Subnet->Mask) )
            return ERROR_INVALID_PARAMETER;
    } else {
        if (!CLASSD_HOST_ADDR(Start) || !CLASSD_HOST_ADDR(End)) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if( Start > End ) return ERROR_INVALID_PARAMETER;

    *OverlappingRange = NULL;
    Error = MemSubnetFindCollision(
        Subnet,
        Start,
        End,
        OverlappingRange,
        NULL
    );
    if(ERROR_FILE_NOT_FOUND != Error ) {          // collision with a range?
        Require(ERROR_SUCCESS == Error);
        return ERROR_OBJECT_ALREADY_EXISTS;
    }

    NewRange = MemAlloc(sizeof(*NewRange));
    if( NULL == NewRange ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = MemRangeInit(
        NewRange, Start, End, Subnet->fSubnet ? Subnet->Mask : 0, State,
        BootpAllocated, MaxBootpAllowed );
    if( ERROR_SUCCESS != Error ) {
        MemFree(NewRange);
        return Error;
    }

    NewRange->UniqId = UniqId;
    Error = MemArrayAddElement(
        &Subnet->Ranges,
        NewRange
    );

    if( ERROR_SUCCESS != Error ) {
        LocalError = MemRangeCleanup(NewRange);
        Require(LocalError == ERROR_SUCCESS);
        MemFree(NewRange);
    }

    return Error;
} // MemSubnetAddRange()

//BeginExport(function)
DWORD
MemSubnetAddRangeExpandOrContract(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  StartAddress,
    IN      DWORD                  EndAddress,
    OUT     DWORD                 *OldStartAddress,
    OUT     DWORD                 *OldEndAddress
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Cond;
    DWORD                          nAddresses;
    BOOL                           fExtend;
    PM_RANGE                       OldRange;
    PM_RANGE                       ThisRange;
    PARRAY                         Ranges;
    ARRAY_LOCATION                 Loc;

    Ranges = &Subnet->Ranges;

    *OldStartAddress = *OldEndAddress = 0;
    OldRange = NULL;
    Error = MemArrayInitLoc(Ranges, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Ranges, &Loc, (LPVOID *)&ThisRange);
        Require(ERROR_SUCCESS == Error && ThisRange);

        Cond = MemRangeCompare(StartAddress, EndAddress, ThisRange->Start, ThisRange->End);
        if( Cond != X_LESSTHAN_Y && Cond != Y_LESSTHAN_X ) {
            if( OldRange ) return ERROR_OBJECT_ALREADY_EXISTS;
            if( X_IN_Y != Cond && Y_IN_X != Cond )
                return ERROR_OBJECT_ALREADY_EXISTS;
            OldRange = ThisRange;
        }

        Error = MemArrayNextLoc(Ranges, &Loc);
    } // while

    if( NULL == OldRange ) return ERROR_FILE_NOT_FOUND;

    *OldStartAddress = OldRange->Start;
    *OldEndAddress = OldRange->End;

    if( OldRange->Start < StartAddress ) {
        fExtend = FALSE;
        nAddresses = StartAddress - OldRange->Start;
    } else {
        fExtend = TRUE;
        nAddresses = OldRange->Start - StartAddress;
    }

    Error = ERROR_SUCCESS;
    if( nAddresses ) Error = MemRangeExtendOrContract(
        OldRange,
        nAddresses,
        fExtend,
        FALSE
    );
    if( ERROR_SUCCESS != Error ) return Error;

    if( OldRange->End < EndAddress ) {
        fExtend = TRUE;
        nAddresses = EndAddress - OldRange->End;
    } else {
        fExtend = FALSE;
        nAddresses = OldRange->End - EndAddress;
    }

    if( nAddresses ) Error = MemRangeExtendOrContract(
        OldRange,
        nAddresses,
        fExtend,
        TRUE
    );

    if ( ERROR_SUCCESS == Error ) {
	// range changed, update the database

	Error = DeleteRecord( OldRange->UniqId );
	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}

	// mark it so that a new record is created.
	OldRange->UniqId = INVALID_UNIQ_ID;
    } // if 
    return Error;
} // MemSubnetAddRangeExpandOrContract()

//BeginExport(function)
DWORD
MemSubnetAddExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    OUT     PM_EXCL               *OverlappingExcl,
    IN      ULONG                  UniqId
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    PM_EXCL                        NewExcl;

    AssertRet(Subnet && OverlappingExcl, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet ) {
        if( (Subnet->Address & Subnet->Mask) != (Start & Subnet->Mask) ||
            (Start & Subnet->Mask)  != (End & Subnet->Mask) )
            return ERROR_INVALID_PARAMETER;
    }

    if( Start > End ) return ERROR_INVALID_PARAMETER;

    *OverlappingExcl = NULL;
    Error = MemSubnetFindCollision(
        Subnet,
        Start,
        End,
        NULL,
        OverlappingExcl
    );
    if(ERROR_FILE_NOT_FOUND != Error ) {          // collision with a range?
        Require(ERROR_SUCCESS == Error);
        return ERROR_OBJECT_ALREADY_EXISTS;
    }

    NewExcl = MemAlloc(sizeof(*NewExcl));
    if( NULL == NewExcl ) return ERROR_NOT_ENOUGH_MEMORY;

    NewExcl->Start = Start;
    NewExcl->End = End;
    NewExcl->UniqId = UniqId;

    Error = MemArrayAddElement(
        &Subnet->Exclusions,
        NewExcl
    );

    if( ERROR_SUCCESS != Error ) {
        MemFree(NewExcl);
    }

    return Error;
} // MemSubnetAddExcl()

//BeginExport(function)
DWORD
MemSubnetDelRange(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start
) //EndExport(function)
{
    DWORD                          Error;
    PM_RANGE                       ThisRange;
    ARRAY_LOCATION                 Location;

    Error = MemArrayInitLoc(&Subnet->Ranges, &Location);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Subnet->Ranges, &Location, (LPVOID *)&ThisRange);
        Require(ERROR_SUCCESS == Error && ThisRange);

        if( ThisRange->Start == Start ) {         // Collision has occured

	    Error = DeleteRecord( ThisRange->UniqId );
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }
            Error = MemRangeCleanup(ThisRange);
            Require(ERROR_SUCCESS == Error);

            MemFree(ThisRange);

            Error = MemArrayDelElement(&Subnet->Ranges, &Location, (LPVOID *)&ThisRange);
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Subnet->Ranges, &Location);
    } // while
    return ERROR_FILE_NOT_FOUND;
} // MemSubnetDelRange()

//BeginExport(function)
DWORD
MemSubnetDelExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start
) //EndExport(function)
{
    DWORD                          Error;
    PM_EXCL                        ThisExcl;
    ARRAY_LOCATION                 Location;

    Error = MemArrayInitLoc(&Subnet->Exclusions, &Location);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Subnet->Exclusions, &Location, (LPVOID *)&ThisExcl);
        Require(ERROR_SUCCESS == Error && ThisExcl);

        if( ThisExcl->Start == Start ) {
	    Error = DeleteRecord( ThisExcl->UniqId );
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }
            Error = MemArrayDelElement(&Subnet->Exclusions, &Location, (LPVOID *)&ThisExcl);
            MemFree(ThisExcl);
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Subnet->Exclusions, &Location);
    } // while
    return ERROR_FILE_NOT_FOUND;
} // MemSubnetDelExcl()

//BeginExport(function)
DWORD
MemSubnetExtendOrContractRange(
    IN OUT  PM_SUBNET              Subnet,
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
) //EndExport(function)
{
    DWORD                          Error;
    PM_RANGE                       CollidedRange;

    AssertRet(Subnet && Range, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet ) {                       // for real subnets (non-multicast-scopes) do sanity check
        if( fExtend ) {
            if( fEnd ) {
                if( ((Range->End + nAddresses) & Subnet->Mask) != (Range->Start & Subnet->Mask) )
                    return ERROR_INVALID_PARAMETER;

                Error = MemSubnetFindCollision(
                    Subnet,
                    Range->End +1,
                    Range->End +nAddresses,
                    &CollidedRange,
                    NULL
                );
                if( ERROR_SUCCESS == Error && NULL != CollidedRange)
                    return ERROR_OBJECT_ALREADY_EXISTS;
            }  else {
                if( ((Range->Start - nAddresses) & Subnet->Mask) != (Range->End & Subnet->Mask) )
                    return ERROR_INVALID_PARAMETER;

                Error = MemSubnetFindCollision(
                    Subnet,
                    Range->Start - nAddresses,
                    Range->Start - 1,
                    &CollidedRange,
                    NULL
                );
                if( ERROR_SUCCESS == Error && NULL != CollidedRange)
                    return ERROR_OBJECT_ALREADY_EXISTS;
            } // else
        } // if
    } // if

    if( !fExtend && nAddresses >  Range->End - Range->Start )
        return ERROR_INVALID_PARAMETER;

    Error = MemRangeExtendOrContract(
        Range,
        nAddresses,
        fExtend,
        fEnd
    );

    if ( ERROR_SUCCESS == Error ) {
	// record modified
	Error = DeleteRecord( Range->UniqId );
	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}

	// mark for new rec creation
	Range->UniqId = INVALID_UNIQ_ID;
    } // if
    return Error;
} // MemSubnetExtendOrContractRange()


//BeginExport(function)
DWORD
MemSubnetExtendOrContractExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN OUT  PM_EXCL                Excl,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
) //EndExport(function)
{
    DWORD                          Error;
    PM_EXCL                        CollidedExcl;

    AssertRet(Subnet && Excl, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet ) {                       // for real subnets (non-multicast-scopes) do sanity check
        if( fExtend ) {
            if( fEnd ) {
                if( ((Excl->End + nAddresses) & Subnet->Mask) != (Excl->Start & Subnet->Mask) )
                    return ERROR_INVALID_PARAMETER;

                Error = MemSubnetFindCollision(
                    Subnet,
                    Excl->End +1,
                    Excl->End +nAddresses,
                    NULL,
                    &CollidedExcl
                );
                if( ERROR_SUCCESS == Error && NULL != CollidedExcl)
                    return ERROR_OBJECT_ALREADY_EXISTS;
            }  else {
                if( ((Excl->Start - nAddresses) & Subnet->Mask) != (Excl->End & Subnet->Mask) )
                    return ERROR_INVALID_PARAMETER;

                Error = MemSubnetFindCollision(
                    Subnet,
                    Excl->Start - nAddresses,
                    Excl->Start - 1,
                    NULL,
                    &CollidedExcl
                );
                if( ERROR_SUCCESS == Error && NULL != CollidedExcl)
                    return ERROR_OBJECT_ALREADY_EXISTS;
            }
        } // if
    } // if

    if( !fExtend && nAddresses >  Excl->End - Excl->Start )
        return ERROR_INVALID_PARAMETER;

    if( fExtend )
        if( fEnd )
            Excl->End += nAddresses;
        else
            Excl->Start -= nAddresses;
    else
        if( fEnd )
            Excl->End -= nAddresses;
        else
            Excl->Start += nAddresses;

    Error = DeleteRecord( Excl->UniqId );
    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }
    
    Excl->UniqId = INVALID_UNIQ_ID;

    return NO_ERROR;
} // MemSubnetExtendOrContractExcl()


//================================================================================
//  Multicast Scopes implementation
//================================================================================

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\subnet2.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements an additional subnet function that requires a server typedef..
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>

#include "subnet2.h"
#include "server\uniqid.h"

//BeginExport(function)
DWORD
MemSubnetModify(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      DWORD                  SuperScopeId,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      NewSubnet, ThisSubnet;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;

    AssertRet(Address == Subnet->Address, ERROR_INVALID_PARAMETER);
    Error = MemSubnetInit(
        &NewSubnet,
        Address,
        Mask,
        State,
        SuperScopeId,
        Name,
        Description
    );
    if( ERROR_SUCCESS != Error) return Error;

    Require(NULL != NewSubnet && Subnet->ServerPtr );

    if( Subnet->fSubnet ) {
        pArray = &(((PM_SERVER)(Subnet->ServerPtr))->Subnets);
    } else {
        pArray = &(((PM_SERVER)(Subnet->ServerPtr))->MScopes);
    }
    Error = MemArrayInitLoc(pArray, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(pArray, &Loc, &ThisSubnet);
        Require(ERROR_SUCCESS == Error && NULL != ThisSubnet );

        if( Subnet->Address != ThisSubnet->Address ) {
            Error = MemArrayNextLoc(pArray, &Loc);
            continue;
        }

        Require(Subnet == ThisSubnet);
	
	Error = DeleteRecord( ThisSubnet->UniqId );
	if ( ERROR_SUCCESS != Error ) {
	    MemFree( NewSubnet );
	    return Error;
	}
        Error = MemArraySetElement(pArray, &Loc, NewSubnet);
        Require(ERROR_SUCCESS == Error);

        NewSubnet -> ServerPtr = Subnet->ServerPtr;
        NewSubnet -> Policy = Subnet->Policy;
        NewSubnet -> fSubnet = Subnet->fSubnet;
        NewSubnet -> Options = Subnet->Options;
        NewSubnet -> Ranges = Subnet->Ranges;
        NewSubnet -> Exclusions = Subnet->Exclusions;
        NewSubnet -> Reservations = Subnet->Reservations;
        NewSubnet -> Servers = Subnet->Servers;

        (void) MemFree(Subnet);
        return Error;
    } // while

    MemFree(NewSubnet);
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemMScopeModify(
    IN      PM_SUBNET              MScope,
    IN      DWORD                  ScopeId,
    IN      DWORD                  State,
    IN      DWORD                  Policy,
    IN      BYTE                   TTL,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description,
    IN      LPWSTR                 LangTag,
    IN      DATE_TIME              ExpiryTime
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      NewMScope, ThisMScope;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;

    AssertRet(ScopeId == MScope->MScopeId, ERROR_INVALID_PARAMETER);
    Error = MemMScopeInit(
        &NewMScope,
        ScopeId,
        State,
        Policy,
        TTL,
        Name,
        Description,
        LangTag,
        ExpiryTime
    );
    if( ERROR_SUCCESS != Error) return Error;

    Require(NULL != NewMScope && MScope->ServerPtr );

    pArray = &(((PM_SERVER)(MScope->ServerPtr))->MScopes);

    Error = MemArrayInitLoc(pArray, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(pArray, &Loc, &ThisMScope);
        Require(ERROR_SUCCESS == Error && NULL != ThisMScope );

        if( MScope->MScopeId != ThisMScope->MScopeId ) {
            Error = MemArrayNextLoc(pArray, &Loc);
            continue;
        }

        Require(MScope == ThisMScope);

	// Delete the old mscope
	Error = DeleteRecord( MScope->UniqId );
	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}

        Error = MemArraySetElement(pArray, &Loc, NewMScope);
        Require(ERROR_SUCCESS == Error);

        NewMScope -> ServerPtr = MScope->ServerPtr;
        NewMScope -> Options = MScope->Options;
        NewMScope -> Ranges = MScope->Ranges;
        NewMScope -> Exclusions = MScope->Exclusions;
        NewMScope -> Reservations = MScope->Reservations;
        NewMScope -> Servers = MScope->Servers;
	NewMScope->UniqId = INVALID_UNIQ_ID;

        (void) MemFree(MScope);
        return Error;
    }

    MemFree(NewMScope);
    return ERROR_FILE_NOT_FOUND;
} // MemMScopeModify()

//================================================================================
// end of file
//================================================================================

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\tbitex.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: this is a short program to test the bitmask functionality
//================================================================================

#include <mm.h>
#include <array.h>
#include <bitmask.h>
#include <stdio.h>

PM_BITMASK  Bit;

VOID _cdecl
main(
    VOID
)
{
    DWORD                          Error;
    DWORD                          Offset;
    DWORD                          BitSize;
    DWORD                          ToSet;
    DWORD                          ToSet1, ToSet2;
    DWORD                          InUseSize;
    DWORD                          UsedSize;
    BOOL                           OldState;
    LPBYTE                         InUse;
    LPBYTE                         Used;

    Error = MemBitInit(&Bit, 0x01000000);
    printf("MemBitInit(0x01000000)=%ld\n", Error);

    for( ToSet = 0; ToSet < 0x01000000 ; ToSet ++ ) {
        if( 0 == ( ToSet % 35 ) ) continue;
        Error = MemBitSetOrClear(
            Bit,
            ToSet,
            TRUE,
            &OldState
        );
        if( ERROR_SUCCESS != Error || OldState ) {
            printf("MemBitSetOrClear(%ld)=%ld,OldState=%ld\n", ToSet, Error, OldState);
        }
    }
    printf("Set all stuff\n");
    Error = MemBitConvertToCluster(
        Bit,
        0,
        &InUse,
        &InUseSize,
        &Used,
        &UsedSize
    );
    printf("MemBitconvert: %ld\n", Error);
    if( ERROR_SUCCESS != Error )return;

    printf("InUseSize= %ld, UsedSize = %ld\n", InUseSize, UsedSize);

    printf("InUse[0] = %ld\n", *(LPDWORD)InUse);
    InUse += sizeof(DWORD); InUseSize -= sizeof(DWORD);
    while(InUseSize) {
        Offset = *(LPDWORD)InUse;
        InUse+= sizeof(DWORD);
        for( ToSet = 0; ToSet < 32; ToSet ++ )
            if( (1<<ToSet) & *(LPDWORD)InUse )
                printf("InUse [ %ld ] \n", Offset + ToSet );

        InUse+= sizeof(DWORD);
        InUseSize -= sizeof(DWORD)*2;
    }

    printf("Used[0] = %ld\n", *(LPDWORD)Used);
    Used += sizeof(DWORD);
    UsedSize -= sizeof(DWORD);
    while( UsedSize ) {
        Offset = *(LPDWORD)Used;
        Used += sizeof(DWORD);
        UsedSize -= sizeof(DWORD);
        printf("Used [ %ld ] \n", Offset);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mm\tbitmask.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: this is a short program to test the bitmask functionality
//================================================================================

#include <mm.h>
#include <array.h>
#include <bitmask.h>
#include <stdio.h>

PM_BITMASK  Bit;

VOID _cdecl
main(
    VOID
)
{
    DWORD                          Error;
    DWORD                          Offset;
    DWORD                          BitSize;
    DWORD                          ToSet;
    DWORD                          ToSet1, ToSet2;
    DWORD                          InUseSize;
    DWORD                          UsedSize;
    BOOL                           OldState;
    LPBYTE                         InUse;
    LPBYTE                         Used;

    printf("Size of bitmask: "); scanf("%ld", &BitSize);
    Error = MemBitInit(&Bit, BitSize);
    printf("MemBitInit(&Bit, %ld)=%ld\n", BitSize, Error);

    while(1) {
        printf("Enter bit to set [-1 to quit loop] from to: "); scanf("%ld %ld", &ToSet1, &ToSet2);
        if( -1 == ToSet1 || -1 == ToSet2 ) break;

        for( ToSet = ToSet1; ToSet <= ToSet2; ToSet ++ ) {
            Error = MemBitSetOrClear(
                Bit,
                ToSet,
                TRUE,
                &OldState
            );
            printf("MemBitSetOrClear(%ld)= %ld,OldState=%ld\n", ToSet, Error, OldState);
        }
    }

    Error = MemBitConvertToCluster(
        Bit,
        100,
        &InUse,
        &InUseSize,
        &Used,
        &UsedSize
    );
    printf("MemBitconvert: %ld\n", Error);
    if( ERROR_SUCCESS != Error )return;

    printf("InUseSize= %ld, UsedSize = %ld\n", InUseSize, UsedSize);

    printf("InUse[0] = %ld\n", *(LPDWORD)InUse);
    InUse += sizeof(DWORD); InUseSize -= sizeof(DWORD);
    while(InUseSize) {
        Offset = *(LPDWORD)InUse;
        InUse+= sizeof(DWORD);
        for( ToSet = 0; ToSet < 32; ToSet ++ )
            if( (1<<ToSet) & *(LPDWORD)InUse )
                printf("InUse [ %ld ] \n", Offset + ToSet );

        InUse+= sizeof(DWORD);
        InUseSize -= sizeof(DWORD)*2;
    }

    printf("Used[0] = %ld\n", *(LPDWORD)Used);
    Used += sizeof(DWORD);
    UsedSize -= sizeof(DWORD);
    while( UsedSize ) {
        Offset = *(LPDWORD)Used;
        Used += sizeof(DWORD);
        UsedSize -= sizeof(DWORD);
        printf("Used [ %ld ] \n", Offset);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\mmregpch.h ===
/*++

Coypright (C) 1998 Microsoft Corporation

Module name:

    mmregpch.h

Abstract:

    Precompiled header for MMREG module.

Environment:

    User mode Win32

--*/

#include    <mm\mm.h>
#include    <mm\array.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <winsock2.h>
#include    <dhcpapi.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\regds.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has the functions relating to downloading stuff from
//  off the DS in a safe way onto the registry.  The solution adopted is actually
//  to dowload onto the "Config.DS" key rather than to the "Configuration" key
//  itself.  Then if the full download is successful, backup this key and restore it
//  onto the "Configuration" key -- so if anything fails, atleast the old configuration
//  would be intact.
//================================================================================

#include    <mmregpch.h>
#include    <regutil.h>
#include    <regsave.h>

#define     FreeArray1(X)          Error = LoopThruArray((X), DestroyString, NULL, NULL);Require(ERROR_SUCCESS == Error);
#define     FreeArray2(X)          Error = MemArrayCleanup((X)); Require(ERROR_SUCCESS == Error);
#define     FreeArray(X)           do{ DWORD Error; FreeArray1(X); FreeArray2(X); }while(0)

typedef     DWORD                  (*ARRAY_FN)(PREG_HANDLE, LPWSTR ArrayString, LPVOID MemObject);

extern
DWORD
DestroyString(                                       // defined in regread.c
    IN      PREG_HANDLE            Unused,
    IN      LPWSTR                 StringToFree,
    IN      LPVOID                 Unused2
);

extern
DWORD
LoopThruArray(                                    // defined in regread.c
    IN      PARRAY                 Array,
    IN      ARRAY_FN               ArrayFn,
    IN      PREG_HANDLE            Hdl,
    IN      LPVOID                 MemObject
);

DWORD                                             //  need to include headers..
DhcpDsGetEnterpriseServers(                       // defined in dhcpds\dhcpread.h.
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ServerName,
    IN OUT  PARRAY                 Servers
) ;

//================================================================================
//  module files
//================================================================================
REG_HANDLE  DsConfig = { NULL, NULL, NULL };      // DsConfig key is stored here
PM_SERVER   CurrentServer;
static      const
DWORD       ZeroReserved = 0;

DWORD
PrepareRegistryForDsDownload(                     // make reg changes to download
    VOID
)
{
    DWORD                          Err, Disposition;
    REG_HANDLE                     DsConfigParent;

    if( NULL != DsConfig.Key ) return ERROR_INVALID_PARAMETER;
    memset(&DsConfigParent,0, sizeof(DsConfigParent));

    Err = RegOpenKeyEx(                           // open the parent key for DsConfig.
        HKEY_LOCAL_MACHINE,
        REG_THIS_SERVER_DS_PARENT,
        ZeroReserved,
        REG_ACCESS,
        &DsConfigParent.Key
    );
    if( ERROR_SUCCESS != Err ) return Err;        // cant do much if server key aint there.

    Err = DhcpRegRecurseDelete(&DsConfigParent, REG_THIS_SERVER_DS_VALUE);
    RegCloseKey(DsConfigParent.Key);             // this is all the parent is needed for

    if( ERROR_SUCCESS != Err && ERROR_FILE_NOT_FOUND != Err ) {
        return Err;                               // could not delete the "config_ds" trash?
    }

    Err = RegCreateKeyEx(                         // now create a fresh "config_ds" key
        HKEY_LOCAL_MACHINE,
        REG_THIS_SERVER_DS,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &DsConfig.Key,
        &Disposition
    );
    if( ERROR_SUCCESS != Err ) return Err;        // could not create the key, nowhere to store..

    return DhcpRegSetCurrentServer(&DsConfig);    // now set this as the default server loc to use..
}


VOID
CleanupAfterDownload(                             // keep stuff clean for other modules
    VOID
)
{
    if( NULL != DsConfig.Key ) RegCloseKey(DsConfig.Key);
    DsConfig.Key = NULL;                          // close the config_ds key and,
    DhcpRegSetCurrentServer(NULL);                // forget abt the config_ds key..
    //remote the Ds cache no matter what...
}

DWORD
CopyRegKeys(                                      // copy between reg keys
    IN      HKEY                   SrcKey,        // copy tree rooted at this key
    IN      LPWSTR                 DestKeyLoc,    // onto registry key located here
    IN      LPWSTR                 FileName       // using this as the temp file
)
{
    DWORD                          Err, Disposition;
    HKEY                           DestKey;
    BOOLEAN                        HadBackup;
    NTSTATUS                       NtStatus;

    NtStatus = RtlAdjustPrivilege (SE_BACKUP_PRIVILEGE, TRUE, FALSE, &HadBackup);
    if( ERROR_SUCCESS != NtStatus ) {             // could not request backup priv..
        return RtlNtStatusToDosError(NtStatus);
    }

    NtStatus = RtlAdjustPrivilege (SE_RESTORE_PRIVILEGE, TRUE, FALSE, &HadBackup);
    if( ERROR_SUCCESS != NtStatus ) {
        return RtlNtStatusToDosError(NtStatus);
    }

    Err = RegSaveKey(SrcKey, FileName, NULL);     // NULL ==> no security on file
    if( ERROR_SUCCESS != Err ) return Err;        // if key cant be saved, cant restore.

    Err = RegCreateKeyEx(                         // now create a fresh "config_ds" key
        HKEY_LOCAL_MACHINE,
        DestKeyLoc,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &DestKey,
        &Disposition
    );
    if( ERROR_SUCCESS != Err ) return Err;        // could not create the key, nowhere to store..

    Err = RegRestoreKey(DestKey, FileName, 0 );   // 0 ==> no flags, in particular, not volatile.
    RegCloseKey(DestKey);                         // dont need this key anyways.

    return Err;
}

DWORD
FixSpecificClusters(                              // this fixes a specific cluster
    IN      HKEY                   NewCfgKey,     // root cfg where to copy over
    IN      LPWSTR                 Subnet,        // the subnet to copy to
    IN      LPWSTR                 Range,         // the range to copy to
    IN      LPBYTE                 InUseClusters, // in use cluster value
    IN      ULONG                  InUseSize,
    IN      LPBYTE                 UsedClusters,  // used clusters value
    IN      ULONG                  UsedSize
)
{
    return ERROR_CALL_NOT_IMPLEMENTED;            // not done yet...

    // just concat REG_SUBNETS Subnet REG_RANGES Range and try to open that.
    // if it fails, quit, other wise just set the given values over...
}

DWORD
FixAllClusters1(                                  // copy cluster info frm old to new cfg
    IN      HKEY                   NewCfgKey,
    IN      HKEY                   OldCfgKey
)
{
    REG_HANDLE                     Cfg, Tmp1, Tmp2;
    DWORD                          Err;
    ARRAY                          Subnets, Ranges;
    LPWSTR                         ThisSubnet, ThisRange;
    ARRAY_LOCATION                 Loc1, Loc2;

    Cfg.Key = OldCfgKey;                          // Should not poke inside directly
    MemArrayInit(&Subnets);

    Err = DhcpRegServerGetList(&Cfg, NULL, NULL, &Subnets, NULL, NULL, NULL);
    if( ERROR_SUCCESS != Err ) {
        MemArrayCleanup(&Subnets);
        return Err;
    }

    for( Err = MemArrayInitLoc(&Subnets, &Loc1)
         ; ERROR_FILE_NOT_FOUND != Err ;
         Err = MemArrayNextLoc(&Subnets, &Loc1)
    ) {                                           // for each subnet, look for ranges
        Err = MemArrayGetElement(&Subnets, &Loc1, &ThisSubnet);

        Err = DhcpRegServerGetSubnetHdl(&Cfg, ThisSubnet, &Tmp1);
        if( ERROR_SUCCESS != Err ) {              // what do we do? just ignore it I think
            continue;
        }

        Err = DhcpRegSubnetGetList(&Tmp1, NULL, &Ranges, NULL, NULL, NULL, NULL );
        if( ERROR_SUCCESS != Err ) {
            DhcpRegCloseHdl(&Tmp1);
            continue;
        }

        for( Err = MemArrayInitLoc(&Ranges, &Loc2)
             ; ERROR_FILE_NOT_FOUND != Err ;
             Err = MemArrayNextLoc(&Ranges, &Loc2)
        ) {                                       // for each range try to copy it over..
            LPBYTE                 InUseClusters = NULL, UsedClusters = NULL;
            ULONG                  InUseClustersSize = 0, UsedClustersSize = 0;

            Err = MemArrayGetElement(&Ranges, &Loc2, &ThisRange);

            Err = DhcpRegSubnetGetRangeHdl(&Tmp1, ThisRange, &Tmp2);
            if( ERROR_SUCCESS != Err ) continue;

            Err = DhcpRegRangeGetAttributes(
                &Tmp2,
                NULL /* no name */,
                NULL /* no comm */,
                NULL /* no flags */,
                NULL /* no bootp alloc */,
                NULL /* no max boop allowed */,
                NULL /* no start addr */,
                NULL /* no end addr */,
                &InUseClusters,
                &InUseClustersSize,
                &UsedClusters,
                &UsedClustersSize
            );

            if( ERROR_SUCCESS == Err ) {
                Err = FixSpecificClusters(
                    NewCfgKey, ThisSubnet, ThisRange, InUseClusters, InUseClustersSize,
                    UsedClusters, UsedClustersSize
                );
                if( InUseClusters ) MemFree(InUseClusters);
                if( UsedClusters ) MemFree(UsedClusters);
            }

            DhcpRegCloseHdl(&Tmp2);
        }

        FreeArray(&Ranges);
        DhcpRegCloseHdl(&Tmp1);
    }

    FreeArray(&Subnets);
    return ERROR_SUCCESS;
}

DWORD
FixAllClusters(                                   // copy the clusters over frm existing to DS_CONFIG
    IN      HKEY                   DsKey          // so that when it is copied back nothing is lost
)
{
    HKEY                           OldCfgKey;
    ULONG                          Disposition, Err;

    return ERROR_SUCCESS;                         // Need to fix this..

    Err = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REG_THIS_SERVER,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &OldCfgKey,
        &Disposition
    );
    if( ERROR_SUCCESS != Err ) {
        return Err;                               // ugh? this should not happen
    }

    Err = FixAllClusters1(DsKey, OldCfgKey);
    RegCloseKey(OldCfgKey);
    return Err;
}


VOID
CopyDsConfigToNormalConfig(                       // copy downloaded config to normal config
    VOID
)
{
    BOOL                           Status;
    DWORD                          Err;

    Status = DeleteFile(L"TempDhcpFile.Reg" );    // this file will be used for temp. storage
    if( !Status ) {                               // could not delete this file?
        Err = GetLastError();
        if( ERROR_FILE_NOT_FOUND != Err &&        // the file does exist?
            ERROR_PATH_NOT_FOUND != Err ) {       // this could also happen?

            return;                               // the nwe wont be able to do the copy!
        }
    }
    FixAllClusters(DsConfig.Key);                 // copy the ranges values over from old to new..
    CopyRegKeys(DsConfig.Key, REG_THIS_SERVER, L"TempDhcpFile.Reg");
    DeleteFile(L"TempDhcpFile.Reg" );             // dont need this file anymore..
}

#if 0
DWORD
SaveServerClasses(                                // save all class info onto registry
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PM_CLASSDEFLIST        Classes        // list of defined classes
)
{
    DWORD                          Err, Err2;
    REG_HANDLE                     Hdl;
    ARRAY_LOCATION                 Loc;
    PM_CLASSDEF                    ThisClass;

    for(                                          // save each class definition
        Err = MemArrayInitLoc(&Classes->ClassDefArray, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Classes->ClassDefArray, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Classes->ClassDefArray, &Loc, &ThisClass);
        //= require ERROR_SUCCESS == Err && NULL != ThisClass

        Err = DhcpRegServerGetClassDefHdl(Server,ThisClass->Name,&Hdl);
        if( ERROR_SUCCESS != Err ) return Err;    // registry error?

        Err = DhcpRegClassDefSetAttributes        // save this class information
        (
            /* Hdl              */ &Hdl,
            /* Name             */ &ThisClass->Name,
            /* Comment          */ &ThisClass->Comment,
            /* Flags            */ &ThisClass->Type,
            /* Value            */ &ThisClass->ActualBytes,
            /* ValueSize        */ ThisClass->nBytes
        );

        Err2 = DhcpRegCloseHdl(&Hdl);             //= require ERROR_SUCCESS == Err2
        if( ERROR_SUCCESS != Err) return Err;     // could not set-attribs in reg.
    }

    return ERROR_SUCCESS;                         // everything went fine.
}

DWORD
SaveServerOptDefs1(                               // save some option definition
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      LPWSTR                 ClassName,     // name of the class of option
    IN      PM_OPTDEFLIST          OptDefList     // list of option definitions
)
{
    DWORD                          Err, Err2;
    ARRAY_LOCATION                 Loc;
    PM_OPTDEF                      ThisOptDef;

    for(                                          // save each opt definition
        Err = MemArrayInitLoc(&OptDefList->OptDefArray, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&OptDefList->OptDefArray, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&OptDefList->OptDefArray, &Loc, &ThisOptDef);
        //= require ERROR_SUCCESS == Err && NULL != ThisOptDef

        Err = DhcpRegSaveOptDef                   // save the option def
        (
            /* OptId          */ ThisOptDef->OptId,
            /* ClassName      */ ClassName,
            /* Name           */ ThisOptDef->OptName,
            /* Comment        */ ThisOptDef->OptComment,
            /* OptType        */ ThisOptDef->Type,
            /* OptVal         */ ThisOptDef->OptVal,
            /* OptLen         */ ThisOptDef->OptValLen
        );
        if( ERROR_SUCCESS != Err ) return Err;    // reg. err saving opt def
    }

    return ERROR_SUCCESS;                         // everything went fine.
}

DWORD
SaveServerOptdefs(                                // save all the opt def's onto registry
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PM_OPTCLASSDEFLIST     Optdefs
)
{
    DWORD                          Err, Err2;
    ARRAY_LOCATION                 Loc;
    PM_OPTCLASSDEFL_ONE            ThisOptClass;
    LPWSTR                         ClassName;
    PM_CLASSDEF                    ClassDef;

    for(                                          // save each opt definition
        Err = MemArrayInitLoc(&Optdefs->Array, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Optdefs->Array, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Optdefs->Array, &Loc, &ThisOptClass);
        //= require ERROR_SUCCESS == Err && NULL != ThisClass

        if( 0 == ThisOptClass->ClassId ) {        // no class for this option
            ClassName = NULL;
        } else {                                  // lookup class in this server struct
            Err = MemServerGetClassDef(
                CurrentServer,                    // need to pass this as param
                ThisOptClass->ClassId,
                NULL,
                0,
                NULL,
                &ClassDef
            );
            if( ERROR_SUCCESS != Err) return Err; // could not find the class? invalid struct
            ClassName = ClassDef->Name;           // found the class, use this name
        }

        Err = SaveServerOptDefs1(Server, ClassName, &ThisOptClass->OptDefList);
        if( ERROR_SUCCESS != Err) return Err;     // could not save some opt definition..
    }

    return ERROR_SUCCESS;                         // everything went fine.
}

DWORD
SaveServerOptions1(                               // save some option
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      LPWSTR                 ClassName,     // name of the class of option
    IN      PM_OPTLIST             OptList        // list of options
)
{
    DWORD                          Err, Err2;
    ARRAY_LOCATION                 Loc;
    PM_OPTION                      ThisOpt;

    for(                                          // save each option
        Err = MemArrayInitLoc(OptList, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(OptList, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(OptList, &Loc, &ThisOpt);
        //= require ERROR_SUCCESS == Err && NULL != ThisOpt

        Err = DhcpRegSaveGlobalOption             // save the option
        (
            /* OptId          */ ThisOpt->OptId,
            /* ClassName      */ ClassName,
            /* Value          */ ThisOpt->Val,
            /* ValueSize      */ ThisOpt->Len
        );
        if( ERROR_SUCCESS != Err ) return Err;    // reg. err saving option
    }

    return ERROR_SUCCESS;                         // everything went fine.
}

DWORD
SaveServerOptions(                                // save all options onto registry
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PM_OPTCLASS            Options
)
{
    DWORD                          Err, Err2;
    ARRAY_LOCATION                 Loc;
    PM_ONECLASS_OPTLIST            ThisOptClass;
    LPWSTR                         ClassName;
    PM_CLASSDEF                    ClassDef;

    for(                                          // save each class definition
        Err = MemArrayInitLoc(&Options->Array, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Options->Array, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Options->Array, &Loc, &ThisOptClass);
        //= require ERROR_SUCCESS == Err && NULL != ThisOptClass

        if( 0 == ThisOptClass->ClassId ) {        // no class for this option
            ClassName = NULL;
        } else {                                  // lookup class in this server struct
            Err = MemServerGetClassDef(
                CurrentServer,                    //  need to pass this as param
                ThisOptClass->ClassId,
                NULL,
                0,
                NULL,
                &ClassDef
            );
            if( ERROR_SUCCESS != Err) return Err; // could not find the class? invalid struct
            ClassName = ClassDef->Name;           // found the class, use this name
        }

        Err = SaveServerOptions1(Server, ClassName, &ThisOptClass->OptList);
        if( ERROR_SUCCESS != Err) return Err;     // could not save some option..
    }

    return ERROR_SUCCESS;                         // everything went fine.

}

DWORD
SaveServerScope(                                  // save unicast-or-mcast scope onto reg.
    IN      PREG_HANDLE            ServerHdl,     // registry handle to server config
    IN      PM_SERVER              MemServer,     // server object in memory
    IN      LPVOID                 Scope,         // either PM_SUBNET or PM_MSCOPE object
    IN      BOOL                   fSubnet        // TRUE ==> Subnet type, FALSE ==> MScope type.
)
{
    DWORD                          Err;
    PM_SUBNET                      Subnet = Scope;
    PM_MSCOPE                      Subnet = MScope;
    PM_SSCOPE                      SScope;

    if( fSubnet ) {                               // if subnet, need to add it to superscope..
        if( 0 != Subnet->SuperScopeId ) {         // this belongs to superscope?
            Err = MemServerFindSScope(MemServer, Subnet->SuperScopeId, NULL, &SScope);
            if( ERROR_SUCCESS != Err ) {          // wrong superscope?  invlaid data
                return Err;
            }
            Err = DhcpRegSScopeSaveSubnet(SScope->Name, Subnet->Address);
            if( ERROR_SUCCESS != Err ) return Err;// could not add subnet to superscope?
        }
    }

    if( fSubnet ) {
        Err = DhcpRegSaveSubnet                   // save this subnet
        (
            /* SubnetAddress    */ Subnet->Address,
            /* SubnetMask       */ Subnet->Mask,
            /* SubnetState      */ Subnet->State,
            /* SubnetName       */ Subnet->Name
            /* SubnetComment    */ Subnet->Description
        );
    } else {
        Err = DhcpRegSaveMScope                   // save this mcast scope
        (
            /* MScopeId         */ MScope->MScopeId,
            /* SubnetState      */ MScope->State,
            /* AddressPolicy    */ MScope->Policy,
            /* TTL              */ MScope->TTL,
            /* pMScopeName      */ MScope->Name,
            /* pMScopeComment   */ MScope->Description,
            /* LangTag          */ MScope->LangTag,
            /* ExpiryTime       */ &MScope->ExpiryTime
        );
    }
    if( ERROR_SUCCESS != Err ) return Err;        // could not save subnet info?


}

DWORD
SaveServerScopes(                                 // save unicast-or-mcast scopes onto reg.
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PARRAY                 Scopes,        // array of PM_SUBNET or PM_MSCOPE types
    IN      BOOL                   fSubnet        // TRUE ==> Subnet type, FALSE ==> MScope type.
)
{
    DWORD                          Err;
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      Subnet;

    for(                                          // save each scope..
        Err = MemArrayInitLoc(Scopes, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(Scopes, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(Scopes, &Loc, &Subnet);
        //= require ERROR_SUCCESS == Err && NULL != Subnet

        Err = SaveServerScope(Server, CurrentServer, Subnet, fSubnet);
        if( ERROR_SUCCESS != Err ) return Err;    // could not save the subnet/m-scope..
    }
    return ERROR_SUCCESS;
}

DWORD
SaveServerSubnets(                                // save all subnet info onto reg.
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PARRAY                 Subnets        // array of type PM_SUBNET elements
)
{
    return SaveServerScopes(Server, Subnets, TRUE);  // call common routine
}

DWORD
SaveServerMScopes(                                // save all the m-cast scopes onto reg.
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PARRAY                 MScopes        // array of type PM_MSCOPE elements
)
{
    return SaveServerScopes(Server, MScopes, FALSE); // call common routine
}


DWORD
DownloadServerInfoFromDs(                         // save the server info onto registry
    IN      PM_SERVER              Server         // the server to save onto registry
)
{
    DWORD                          Err;
    REG_HANDLE                     Hdl, Hdl2;
    ARRAY_LOCATION                 Loc;

    CurrentServer = Server;                       // this global used by several funcs above..

    Err = DhcpRegGetThisServer(&Hdl);             // get current server hdl
    if( ERROR_SUCCESS != Err ) return Err;

    Err = DhcpRegServerSetAttributes              // set server attributes
    (
        /* PREG_HANDLE  Hdl     */ &Hdl,
        /* LPWSTR *Name         */ &Server->Name,
        /* LPWSTR *Comment      */ &Server->Comment,
        /* DWORD  *Flags        */ &Server->State
    );
    // ignore errors..

    Err = SaveServerClasses(&Hdl, &Server->ClassDefs);
    if( ERROR_SUCCESS == Err ) {                  // saved classes? save optdefs..
        Err = SaveServerOptdefs(&Hdl, &Server->OptDefs);
    }
    if( ERROR_SUCCESS == Err ) {                  // saved optdefs? save options..
        Err = SaveServerOptions(&Hdl, &Server->Options);
    }
    if( ERROR_SUCCESS == Err ) {                  // saved options? save subnets..
        Err = SaveServerSubnets(&Hdl, &Server->Subnets);
    }
    if( ERROR_SUCCESS == Err ) {                  // saved subnets? save mcast scopes
        Err = SaveServerMScopes(&Hdl, &Server->MScopes);
    }

    (void)DhcpRegCloseHdl(&Hdl);                  // free resource
    return Err;
}

#endif  0

DWORD
DownloadServerInfoFromDs(                         // save the server info onto registry
    IN      PM_SERVER              Server         // the server to save onto registry
)
{
    return DhcpRegServerSave(Server);
}

DWORD
DownloadFromDsForReal(                            // really try to downlaod from DS
    IN      LPWSTR                 ServerName
)
{
    DWORD                          Err, Err2;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PM_SERVER                      ThisServer;

    Err = MemArrayInit(&Servers);                 // initialize array
    if( ERROR_SUCCESS != Err ) return Err;

    Err = DhcpDsGetEnterpriseServers              // fetch the server info from DS
    (
        /* Reserved             */ ZeroReserved,
        /* ServerName           */ ServerName,
        /* Servers              */ &Servers
    );

    Err2 = ERROR_SUCCESS;                         // init return value
    for(                                          // process all the information
        Err = MemArrayInitLoc(&Servers, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Servers, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisServer);
        //= require ERROR_SUCCESS == Err && NULL != ThisServer

        Err = DownloadServerInfoFromDs(ThisServer);
        if( ERROR_SUCCESS != Err ) {              // oops.. could not do it?
            Err2 = Err;                           // store error..
        }

        MemServerFree(ThisServer);                // free all this memory.
    }

    Err = MemArrayCleanup(&Servers);              // free mem allcoated for array
    if( ERROR_SUCCESS != Err ) Err2 = Err;        // something went wrong?

    return Err2;
}


//================================================================================
// the only exported function is this.
//================================================================================

VOID
DhcpRegDownloadDs(                                // safe download of stuff onto registry
    IN      LPWSTR                 ServerName     // name of dhcp servre to download for
)
{
    DWORD                          Err;


    Err = PrepareRegistryForDsDownload();         // prepare the Config.DS key and stuff..
    if( ERROR_SUCCESS != Err ) return;            // oops, could not even do this?

    Err = DownloadFromDsForReal(ServerName);      // actually try to download from DS.
    if( ERROR_SUCCESS == Err ) {                  // could actually download successfully
        CopyDsConfigToNormalConfig();             // now copy this configuration to nrml loc.
    }

    CleanupAfterDownload();                       // now cleanup the regsitry handles etc..
    DhcpRegUpdateTime();                          // fix the time stamp to now..
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\regflush.c ===
//================================================================================
//  Copyright (c) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: this file deals with the part that keeps the registry bitmask in
//  sync.  the way, this is done is by keeping a count in each RANGE object to
//  count the # of operations that have been performed on it.. if it crosses
//  a threshold, it is saved to registry..
//================================================================================

//#include    <dhcpsrv.h>
#include    <mmregpch.h>
#include    <regutil.h>
#include    <regsave.h>

extern CRITICAL_SECTION DhcpGlobalInProgressCritSect;
extern CRITICAL_SECTION DhcpGlobalMemoryCritSect;

#define LOCK_MEMORY()            EnterCriticalSection(&DhcpGlobalMemoryCritSect)
#define UNLOCK_MEMORY()          LeaveCriticalSection(&DhcpGlobalMemoryCritSect)
#define LOCK_INPROGRESS_LIST()   EnterCriticalSection(&DhcpGlobalInProgressCritSect)
#define UNLOCK_INPROGRESS_LIST() LeaveCriticalSection(&DhcpGlobalInProgressCritSect)

#define     DIRT_THRESHOLD         10             // flush every 10 addresses

//BeginExport(defines)
#define     FLUSH_MODIFIED_DIRTY   0
#define     FLUSH_MODIFIED         1
#define     FLUSH_ANYWAY           2
//EndExport(defines)

DWORD
FlushCheckLoop(
    IN      PARRAY                 ArrayToLoopThru,
    IN      DWORD                  (*Iterator)(LPVOID Element, DWORD FlushNow, LPVOID Context),
    IN      DWORD                  FlushNow,
    IN      LPVOID                 Context
)
{
    DWORD                          LastFailure;
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    LPVOID                         Element;

    LastFailure = ERROR_SUCCESS;
    Error = MemArrayInitLoc(ArrayToLoopThru, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(ArrayToLoopThru, &Loc, &Element);
        Require(ERROR_SUCCESS == Error && NULL != Element);

        Error = Iterator(Element, FlushNow, Context);
        Require(ERROR_SUCCESS == Error);
        if( ERROR_SUCCESS != Error ) LastFailure = Error;

        Error = MemArrayNextLoc(ArrayToLoopThru, &Loc);
    }

    return LastFailure;
}

BOOL _inline
SpecialValues(
    IN      LPWSTR                 ValueName
)
{
    return (0 == wcscmp(ValueName, REG_RANGE_START_ADDRESS) ||
            0 == wcscmp(ValueName, REG_RANGE_END_ADDRESS) ||
            0 == wcscmp(ValueName, REG_FLAGS) ||
            0 == wcscmp(ValueName, REG_SUBNET_EXCL) ||
            0 == wcscmp(ValueName, REG_SUBNET_SWITCHED_FLAG) ||
            0 == wcscmp(ValueName, REG_MSCOPE_NAME) ||
            0 == wcscmp(ValueName, REG_MSCOPE_COMMENT) ||
            0 == wcscmp(ValueName, REG_MSCOPE_SCOPEID) ||
            0 == wcscmp(ValueName, REG_MSCOPE_STATE) ||
            0 == wcscmp(ValueName, REG_MSCOPE_ADDR_POLICY) ||
            0 == wcscmp(ValueName, REG_MSCOPE_TTL) ||
            0 == wcscmp(ValueName, REG_MSCOPE_LANG_TAG) ||
            0 == wcscmp(ValueName, REG_MSCOPE_EXPIRY_TIME)
        );
}

typedef struct _FLSH_BITS_CTXT {
    REG_HANDLE                    *Hdl;
    PM_SUBNET                      Subnet;
    PM_RANGE                       Range;
    LONG                           Index;
}   FLSH_BITS_CTXT, *LPFLSH_BITS_CTXT;

static
BYTE TempBuffer[MAX_BIT1SIZE + sizeof(DWORD)*4];

DWORD
FlushBitmask(
    IN      PM_BITMASK1            Bits1,
    IN      DWORD                  FlushNow,
    IN      LPVOID                 FlushCtxt
)
{
    LPFLSH_BITS_CTXT               Ctxt = FlushCtxt;
    HKEY                           Key = Ctxt->Hdl->Key;
    WCHAR                          BitsValueName[REG_RANGE_BITS_PREFIX_WCHAR_COUNT+57];
    LONG                           Count, Index = (Ctxt->Index++);
    ULONG                          WriteSize = 4*sizeof(DWORD), Tmp;
    DWORD                          Error;
    LPWSTR                         TmpStr;
    
    if( FLUSH_ANYWAY != FlushNow && 0 == Bits1->nDirtyOps ) {
        return ERROR_SUCCESS;
    }

    Bits1->nDirtyOps = 0;

    ZeroMemory( BitsValueName, sizeof(BitsValueName));
    ConvertAddressToLPWSTR(Ctxt->Range->Start, BitsValueName);
    wcscat(BitsValueName, L" ");
    wcscat(BitsValueName, REG_RANGE_BITS_PREFIX);
    TmpStr = &BitsValueName[wcslen(BitsValueName)];
    for( Count = 5; Count >= 0; Count -- ) {
        TmpStr[Count] = (WCHAR)(L'0' + (Index%10)); Index/= 10;
    }
    TmpStr[6] = L'\0';

    if( 0 == Bits1->nSet ) {

        //
        // If no bit is set, we don't have to write this to registry -- just need to REMOVE value..
        //

        Error = RegDeleteValue(Key, (LPWSTR)BitsValueName);
        if( ERROR_FILE_NOT_FOUND == Error || ERROR_PATH_NOT_FOUND == Error ) {
            return ERROR_SUCCESS;
        }
        return Error;
    }

    //
    // compose TempBuffer -- note that this whole func is serialized, so we can use
    // TempBuffer safely..
    //

    Tmp = htonl(Bits1->Size); memcpy(&TempBuffer[0*sizeof(DWORD)], &Tmp, sizeof(DWORD));
    if( Bits1->Size == Bits1->nSet ) {
        Require(Bits1->Mask == NULL);
        Tmp = 0;
    } else Tmp = htonl(Bits1->AllocSize);
    memcpy(&TempBuffer[1*sizeof(DWORD)], &Tmp, sizeof(DWORD));
    Tmp = htonl(Bits1->nSet); memcpy(&TempBuffer[2*sizeof(DWORD)], &Tmp, sizeof(DWORD));
    Tmp = htonl(Bits1->Offset); memcpy(&TempBuffer[3*sizeof(DWORD)], &Tmp, sizeof(DWORD));
    if( Bits1->Mask ) {
        memcpy(&TempBuffer[4*sizeof(DWORD)], Bits1->Mask, Bits1->AllocSize);
        WriteSize += Bits1->AllocSize;
    }

    return RegSetValueEx(
        Key,
        (LPWSTR)BitsValueName,
        0,
        REG_BINARY,
        TempBuffer,
        WriteSize
    );
}

DWORD
DhcpRegClearupRangeValues(
    IN      PM_SUBNET              Subnet,
    IN      PM_RANGE               Range
)
/*++

Routine Description:

    This routine clears up all values for a given Range (this can be
    specified via a single Key for the range, or via the Range/Subnet
    object pair) excepting "StartAddress", "EndAddress" and "Flags".

Arguments:

    Key                            INVALID_HANDLE_VALUE if range is specified
                                   via Range, Subnet pair. Else Range key in registry.

    Subnet                         Subnet object if Key is not speificed.

    Range                          Range object if key is not specified.

Returns:

    Win32 errors (registry) or ERROR_SUCCESS on success.

--*/
{
    ULONG                          Error, nValues, Index;
    REG_HANDLE                     Hdl;
    HKEY                           UseKey;
    WCHAR                          ValueNameBuf[100], RangeStr[50];
    DWORD                          ValueNameSize, ValueType;

    Error = DhcpRegGetThisServer( &Hdl );
    if( NO_ERROR != Error ) return Error;

    ZeroMemory( RangeStr, sizeof(RangeStr));
    ConvertAddressToLPWSTR( Range->Start, RangeStr );
    
    UseKey = Hdl.Key;

    do {
        Error = RegQueryInfoKey(
            UseKey, NULL, NULL, NULL, NULL, NULL, NULL, &nValues, NULL, NULL, NULL, NULL
        );
        if( ERROR_SUCCESS != Error ) break;

        Index = nValues -1;
        while( nValues ) {

            ValueNameSize = sizeof(ValueNameBuf)/sizeof(WCHAR);
            Error = RegEnumValue(
                UseKey,
                Index,
                (LPWSTR)ValueNameBuf,
                &ValueNameSize,
                NULL,
                &ValueType,
                NULL,
                NULL
            );
            if( ERROR_SUCCESS != Error ) break;

            if( 0 == wcsncmp( ValueNameBuf, RangeStr,
                              wcslen(RangeStr) ) ) {
                RegDeleteValue(UseKey, (LPWSTR)ValueNameBuf);
            }

            Index --;
            nValues --;
        }

    } while ( 0 );

    DhcpRegCloseHdl(&Hdl);

    return Error;
}


// This function is ALSO CALLED FROM REGREAD.C while reading in a subnet info..
    
//BeginExport(function)
DWORD
FlushRanges(
    IN      PM_RANGE               Range,
    IN      DWORD                  FlushNow,
    IN      PM_SUBNET              Subnet
)   //EndExport(function)
{
    DWORD                          Error;
    REG_HANDLE                     Hdl;
    PM_BITMASK                     BitMask;
    FLSH_BITS_CTXT                 Ctxt = { &Hdl, Subnet, Range, 0};

    if( (FLUSH_ANYWAY != FlushNow && 0 == Range->DirtyOps) ||
        (FLUSH_MODIFIED_DIRTY == FlushNow && Range->DirtyOps < DIRT_THRESHOLD ) ) {
        return ERROR_SUCCESS;
    }

    Error = DhcpRegGetThisServer( &Hdl );
    if( NO_ERROR != Error ) return Error;

    //
    // Lock is needed to serialize access to memory -- shouldn't be allocating addresses
    // while we're planning to save it to registry..
    //

    LOCK_INPROGRESS_LIST();
    LOCK_MEMORY();

    Range->DirtyOps = 0;
    BitMask = Range->BitMask;

    if( FLUSH_ANYWAY == FlushNow ) {
        DhcpRegClearupRangeValues(Subnet, Range);
    }
    
    Error = FlushCheckLoop(&BitMask->Array, FlushBitmask, FlushNow, &Ctxt );

    DhcpRegCloseHdl( &Hdl );
    
    UNLOCK_MEMORY();
    UNLOCK_INPROGRESS_LIST();

    return Error;
}

DWORD
FlushSubnets(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  FlushNow,
    IN      LPVOID                 Context_UNUSED
)
{
    ULONG                          Error;

    Error = FlushCheckLoop(&Subnet->Ranges, FlushRanges, FlushNow, Subnet);
    Require( ERROR_SUCCESS == Error );

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegServerFlush(
    IN      PM_SERVER              Server,
    IN      DWORD                  FlushNow
) //EndExport(function)
{
    DWORD   Error;

    Error = FlushCheckLoop(&Server->Subnets, FlushSubnets, FlushNow, NULL);
    Require(ERROR_SUCCESS == Error);
    Error = FlushCheckLoop(&Server->MScopes, FlushSubnets, FlushNow, NULL);
    Require(ERROR_SUCCESS == Error);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegFlushServer(
    IN      DWORD                  FlushNow
) //EndExport(function)
{
    PM_SERVER                      Server;
    DWORD                          Error;
    PM_SERVER                      DhcpGetCurrentServer(VOID);

    Server = DhcpGetCurrentServer();

    Error = FlushCheckLoop(&Server->Subnets, FlushSubnets, FlushNow, NULL);
    Require(ERROR_SUCCESS == Error);
    Error = FlushCheckLoop(&Server->MScopes, FlushSubnets, FlushNow, NULL);
    Require(ERROR_SUCCESS == Error);
    return Error;
}

//================================================================================
// ds support routines -- flush a full server to disk
//================================================================================

DWORD
SaveArray(
    IN      PARRAY                 Array,
    IN      DWORD                  (*Func)(LPVOID, LPVOID, LPVOID),
    IN      LPVOID                 Arg2,
    IN      LPVOID                 Arg3
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Result;
    LPVOID                         ThisPtr;

    Result = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Result ) {
        Result = MemArrayGetElement(Array, &Loc, &ThisPtr);
        Require(ERROR_SUCCESS == Result && NULL != ThisPtr );

        Result = Func(ThisPtr, Arg2, Arg3);
        if( ERROR_SUCCESS != Result ) return Result;

        Result = MemArrayNextLoc(Array, &Loc);
    }
    return ERROR_SUCCESS;
}

DWORD
DhcpRegSaveOptList(
    IN      PM_ONECLASS_OPTLIST    OptClassOptList,
    IN      LPVOID                 Arg1,
    IN      LPVOID                 Arg2
)
{
    DWORD                          Result;
    DWORD                          ClassId;
    DWORD                          VendorId;
    LPWSTR                         ClassName;
    LPWSTR                         VendorName;
    PM_OPTLIST                     OptList;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    PM_SSCOPE                      SScope;
    PM_OPTION                      Option;
    PM_CLASSDEF                    ClassDef;
    ARRAY_LOCATION                 Loc;

    ClassId = OptClassOptList->ClassId;
    VendorId = OptClassOptList->VendorId;
    OptList = &OptClassOptList->OptList;

    if( NULL != Arg1 && NULL != Arg2 ) {          // reservations
        Reservation = Arg1; Subnet = Arg2;
        Server = Subnet->ServerPtr;
    } else if( NULL == Arg2 ) {                   // subnet options
        Reservation = NULL; Subnet = Arg1;
        Server = Subnet->ServerPtr;
    } else if( NULL == Arg1 ) {                   // global options
        Reservation = NULL; Subnet = NULL;
        Server = Arg2;
    } else {                                      // enterprise options?
        return ERROR_NOT_SUPPORTED;
    }

    Result = MemServerGetClassDef(                // get the vendor name first
        Server,
        VendorId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Result ) {
        VendorName = NULL;
    } else {
        VendorName = ClassDef->Name;
        Require(ClassDef->IsVendor == TRUE);
    }

    Result = MemServerGetClassDef(                // get the class name for this class
        Server,
        ClassId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Result ) {
        ClassName = NULL;
    } else {
        ClassName = ClassDef->Name;
        Require(ClassDef->IsVendor == FALSE);
    }

    Result = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(OptList, &Loc, &Option);
        //- ERROR_SUCCESS == Result && NULL != Option
        if( NULL != Reservation ) {               // save reservation options
            Result = DhcpRegSaveReservedOption(
                Subnet->Address,
                Reservation->Address,
                Option->OptId,
                ClassName,
                VendorName,
                Option->Val,
                Option->Len
            );
        } else if( NULL != Subnet ) {             // save subnet optinos
            Result = DhcpRegSaveSubnetOption(
                Subnet,
                Option->OptId,
                ClassName,
                VendorName,
                Option->Val,
                Option->Len
            );
        } else if( NULL != Server ) {             // save global options
            Result = DhcpRegSaveGlobalOption(
                Option->OptId,
                ClassName,
                VendorName,
                Option->Val,
                Option->Len
            );
        } else {                                  // save enterprise wide optinos
            return ERROR_CALL_NOT_IMPLEMENTED;
        }
        if( ERROR_SUCCESS != Result ) return Result;

        Result = MemArrayNextLoc(OptList, &Loc);
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpRegSaveReservationOptions(
    IN      PM_OPTCLASS            OptClass,
    IN      PM_RESERVATION         Reservation,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          Result;
    ARRAY_LOCATION                 Loc;

    return SaveArray(&OptClass->Array, DhcpRegSaveOptList, Reservation, Subnet);
}

DWORD
DhcpRegSaveSubnetOptions(
    IN      PM_OPTCLASS            OptClass,
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Unused
)
{
    return SaveArray(&OptClass->Array, DhcpRegSaveOptList, Subnet, NULL);
}

DWORD
DhcpRegSaveGlobalOptions(
    IN      PM_OPTCLASS            OptClass,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return SaveArray(&OptClass->Array, DhcpRegSaveOptList, NULL, Server);
}

DWORD
DhcpRegSaveOptDefList(
    IN      PM_OPTCLASSDEFL_ONE    OClassDefL,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    DWORD                          Result;
    DWORD                          ClassId;
    DWORD                          VendorId;
    LPWSTR                         ClassName;
    LPWSTR                         VendorName;
    PM_OPTDEFLIST                  OptDefList;
    PM_OPTDEF                      OptDef;
    PM_CLASSDEF                    ClassDef;
    ARRAY_LOCATION                 Loc;

    ClassId = OClassDefL->ClassId;
    VendorId = OClassDefL->VendorId;
    OptDefList = &OClassDefL->OptDefList;

    Result = MemServerGetClassDef(                // first find the vendor name
        Server,
        VendorId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Result ) {
        VendorName = NULL;
    } else {
        VendorName = ClassDef->Name;
        Require(ClassDef->IsVendor == TRUE);
    }

    Result = MemServerGetClassDef(                // now find the class name
        Server,
        ClassId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Result ) {
        ClassName = NULL;
    } else {
        ClassName = ClassDef->Name;
        Require(ClassDef->IsVendor == FALSE);
    }

    Result = MemArrayInitLoc(&OptDefList->OptDefArray, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(&OptDefList->OptDefArray, &Loc, &OptDef);
        //- ERROR_SUCCESS == Result && NULL != OptDef
        Result = DhcpRegSaveOptDef(
            OptDef->OptId,
            ClassName,
            VendorName,
            OptDef->OptName,
            OptDef->OptComment,
            OptDef->Type,
            OptDef->OptVal,
            OptDef->OptValLen
        );
        if( ERROR_SUCCESS != Result ) return Result;

        Result = MemArrayNextLoc(&OptDefList->OptDefArray, &Loc);
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpRegSaveOptDefs(
    IN      PM_OPTCLASSDEFLIST     OptDefs,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return SaveArray(&OptDefs->Array, DhcpRegSaveOptDefList, Server, NULL);
}

DWORD
DhcpRegSaveClass(
    IN      PM_CLASSDEF            Class,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return DhcpRegSaveClassDef(
        Class->Name,
        Class->Comment,
        (DWORD)Class->IsVendor,
        Class->ActualBytes,
        Class->nBytes
    );
}

DWORD
DhcpRegSaveClassDefs(
    IN      PM_CLASSDEFLIST        ClassDefs,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return SaveArray(&ClassDefs->ClassDefArray, DhcpRegSaveClass, Server, NULL);
}

DWORD
DhcpRegSaveRanges(
    IN      PM_RANGE               Range,
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Unused
)
{
    DWORD                          Result;
    DWORD                          Zero = 0;
    
    return DhcpRegAddRangeEx(
        Subnet,
        Range->Start,
        Range->End,
        Range->BootpAllocated,
        Range->MaxBootpAllowed,
        Range->State,
        (LPBYTE)&Zero,
        sizeof(Zero),
        (LPBYTE)&Zero,
        sizeof(Zero)
    );
}

DWORD
DhcpRegSaveExcls(
    IN      PM_SUBNET              Subnet,
    IN      PARRAY                 Excl
)
{
    DWORD                          Result;
    DWORD                          nElems;
    DWORD                         *ExclArray;
    DWORD                          i;
    ARRAY_LOCATION                 Loc;
    PM_RANGE                       ThisRange;

    nElems = MemArraySize(Excl);
    ExclArray = MemAlloc(( nElems*2+1) *sizeof(DWORD));
    if( NULL == ExclArray ) return ERROR_NOT_ENOUGH_MEMORY;

    ExclArray[0] = nElems;

    MemArrayInitLoc(Excl, &Loc);
    for( i = 0 ; i < nElems ; i ++ ) {
        MemArrayGetElement(Excl, &Loc, &ThisRange);
        Require(ThisRange != NULL);

        ExclArray[2*i+1] = ThisRange->Start;
        ExclArray[2*i+2] = ThisRange->End;
        MemArrayNextLoc(Excl, &Loc);
    }

    Result = DhcpRegSaveExcl(Subnet, (LPBYTE)ExclArray, sizeof(DWORD)*(nElems*2+1));
    MemFree(ExclArray);

    return Result;
}


DWORD
DhcpRegSaveReservation1(
    IN      PM_RESERVATION         Reservation,
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Unused
)
{
    DWORD                          Result;

    Result = DhcpRegSaveReservation(
        Subnet->Address,
        Reservation->Address,
        Reservation->Flags,
        Reservation->ClientUID,
        Reservation->nBytes
    );
    if( ERROR_SUCCESS != Result ) return Result;

    return DhcpRegSaveReservationOptions(
        &Reservation->Options, Reservation, Subnet
    );
}

DWORD
DhcpRegSaveReservations(
    IN      PM_RESERVATIONS        Reservations,
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Unused
)
{
    return SaveArray(Reservations, DhcpRegSaveReservation1, Subnet, NULL);
}


DWORD
DhcpRegSaveSubnets(
    IN      PM_SUBNET              Subnet,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused2
)
{
    DWORD                          Result;
    PM_SSCOPE                      SScope;

    if( Subnet->fSubnet ) {
        Result = DhcpRegSaveSubnet(
            Subnet->Address,
            Subnet->Mask,
            Subnet->State,
            Subnet->Name,
            Subnet->Description
        );
    } else {
        Result = DhcpRegSaveMScope(
            Subnet->MScopeId,
            Subnet->State,
            Subnet->Policy,
            Subnet->TTL,
            Subnet->Name,
            Subnet->Description,
            Subnet->LangTag,
            &Subnet->ExpiryTime
        );
    }
    if( ERROR_SUCCESS != Result ) return Result;

    Result = SaveArray(&Subnet->Ranges, DhcpRegSaveRanges, Subnet, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveExcls(
        Subnet,
        &Subnet->Exclusions
    );
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveSubnetOptions(&Subnet->Options, Subnet, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveReservations(&Subnet->Reservations, Subnet, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    if( 0 == Subnet->SuperScopeId ) return ERROR_SUCCESS;
    Result = MemServerFindSScope(
        Server,
        Subnet->SuperScopeId,
        NULL,
        &SScope
    );
    if( ERROR_FILE_NOT_FOUND == Result ) return ERROR_SUCCESS;
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSScopeSaveSubnet(SScope->Name, Subnet->Address);
    if( ERROR_SUCCESS != Result ) return Result;

    return ERROR_SUCCESS;
}

DWORD
DhcpRegSaveMScopes(
    IN      PM_MSCOPE              MScope,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return DhcpRegSaveSubnets(MScope, Server, NULL);
}


//BeginExport(function)
DWORD
DhcpRegServerSave(
    IN      PM_SERVER              Server
)   //EndExport(function)
{
    DWORD                          Result;

#if 0
    Result = DhcpRegServerSetAttributes(
        Hdl,
        &Server->Name,
        &Server->Comment,
        &Server->State
    );
    if( ERROR_SUCCESS != Result ) return Result;
#endif

    Result = SaveArray(&Server->Subnets, DhcpRegSaveSubnets, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = SaveArray(&Server->MScopes, DhcpRegSaveMScopes, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

#if 0
    Result = SaveArray(&Server->SuperScopes, DhcpRegSaveSuperScopes, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;
#endif

    Result = DhcpRegSaveGlobalOptions(&Server->Options, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveOptDefs(&Server->OptDefs, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveClassDefs(&Server->ClassDefs, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    return ERROR_SUCCESS;
}

#if 0
// ---BeginExport(function)
DWORD
DhcpRegSaveThisServer(
    IN      LPWSTR                 Location,
    IN      PM_SERVER              Server
) //   ---EndExport(function)
{
    DWORD                          Result, Result2;
    REG_HANDLE                     Hdl;
    REG_HANDLE                     SaveHdl;

    Result = DhcpRegGetThisServer(&Hdl);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegGetNextHdl(&Hdl, Location, &SaveHdl);
    Result2 = DhcpRegCloseHdl(&Hdl);
    Require( ERROR_SUCCESS == Result2 );

    if( ERROR_SUCCESS != Result ) return Result;

    DhcpRegSetCurrentServer(&SaveHdl);

    Result = DhcpRegServerSave(Server);

    DhcpRegSetCurrentServer(NULL);
    Result2 = DhcpRegCloseHdl(&SaveHdl);
    Require( ERROR_SUCCESS == Result2 );

    return Result;
}
#endif

//BeginExport(function)
DWORD
DhcpMigrateMScopes(
    IN LPCWSTR OldMscopeName,
    IN LPCWSTR NewMscopeName,
    IN DWORD (*SaveOrRestoreRoutine)(
        IN HKEY Key, IN LPWSTR ConfigName, IN BOOL fRestore
        )
    ) //EndExport(function)
/*++

Routine Description:

    This routine attempts to migrate the key stored under
    OldMscopeName to NewMscopeName name.

    N.B.  It does not delete the old key.
    
Return Values:

    Win32 error codes

--*/
{
    REG_HANDLE Hdl1, Hdl2, Hdl3;
    ULONG Error, Error2;
    
    Error = DhcpRegGetThisServer(&Hdl1);
    if( NO_ERROR != Error ) return Error;

    Error = DhcpRegServerGetMScopeHdl(
        &Hdl1, (LPWSTR)OldMscopeName, &Hdl2
        );
    if( NO_ERROR == Error ) {
        Error2 = DhcpRegServerGetMScopeHdl(
            &Hdl1, (LPWSTR)NewMscopeName, &Hdl3
            );
    }

    DhcpRegCloseHdl(&Hdl1);
    if( NO_ERROR != Error ) return Error;
    if( NO_ERROR != Error2 ) {
        DhcpRegCloseHdl(&Hdl2);
        return Error2;
    }
    
    Error = SaveOrRestoreRoutine(
        Hdl2.Key, L"DHCPMSCOPE.CFG", FALSE
        );

    if( NO_ERROR == Error ) {
        Error = SaveOrRestoreRoutine(
            Hdl3.Key, L"DHCPMSCOPE.CFG", TRUE
            );
    }

    DhcpRegCloseHdl(&Hdl2);
    DhcpRegCloseHdl(&Hdl3);

    return Error;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\regread.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This implements the init time reading in of the registry
// (this may/may work even when used to read at any other time.. but is not efficient)
//================================================================================

#include    <mmregpch.h>
#include    <regutil.h>
#include    <regsave.h>

#include "server\uniqid.h"

#define     InitArray(X)           do{DWORD Error = MemArrayInit((X)); Require(ERROR_SUCCESS == Error); }while(0)
#define     ERRCHK                 do{if( ERROR_SUCCESS != Error ) goto Cleanup; }while(0)
#define     FreeArray1(X)          Error = LoopThruArray((X), DestroyString, NULL, NULL);Require(ERROR_SUCCESS == Error);
#define     FreeArray2(X)          Error = MemArrayCleanup((X)); Require(ERROR_SUCCESS == Error);
#define     FreeArray(X)           do{ DWORD Error; FreeArray1(X); FreeArray2(X); }while(0)

#if DBG
#define     Report(Who)            if(Error) DbgPrint("[DHCPServer] %s: %ld [0x%lx]\n", Who, Error, Error)
#define     INVALID_REG            DbgPrint
#else
#define     Report(Who)
#define     INVALID_REG            (void)
#endif


typedef     DWORD                  (*ARRAY_FN)(PREG_HANDLE, LPWSTR ArrayString, LPVOID MemObject);

DWORD
LoopThruArray(
    IN      PARRAY                 Array,
    IN      ARRAY_FN               ArrayFn,
    IN      PREG_HANDLE            Hdl,
    IN      LPVOID                 MemObject
)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    LPWSTR                         ArrayString;

    Error = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, (LPVOID *)&ArrayString);
        Require(ERROR_SUCCESS == Error && ArrayString);

        Error = ArrayFn(Hdl, ArrayString, MemObject);
        if( ERROR_SUCCESS != Error ) {
            //
            // Operation failed -- but ignore it.
            //
            // return Error;
        }

        Error = MemArrayNextLoc(Array, &Loc);
    }

    return ERROR_SUCCESS;
}

DWORD
DestroyString(
    IN      PREG_HANDLE            Unused,
    IN      LPWSTR                 StringToFree,
    IN      LPVOID                 Unused2
)
{
    MemFree(StringToFree);
    return ERROR_SUCCESS;
}

DWORD
WStringToAddress(
    IN      LPWSTR                 Str
)
{
    CHAR                           IpString[100];
    DWORD                          Count;

    Count = wcstombs(IpString, Str, sizeof(IpString)-1);
    if( -1 == Count ) return 0;

    return htonl(inet_addr(IpString));
}

DWORD
ConvertWStringToDWORD(
    IN      LPWSTR                 Str
)
{
    return  _wtoi(Str);
}

DWORD
DhcpRegpSubnetAddServer(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ServerName,
    IN      PM_SUBNET              Subnet
)
{
    return ERROR_SUCCESS;
}

DWORD
SetBitForRange(
    IN      PM_RANGE               Range,
    IN      DWORD                  Address
)
{
    BOOL                           WasSet;
    if( Address > Range->End || Address < Range->Start )
        return ERROR_INVALID_PARAMETER;

    return MemBitSetOrClear(
        Range->BitMask,
        Address - Range->Start,
        TRUE,
        &WasSet
    );
}


DWORD GlobalWorkingOnOldStyleSubnet = 0;
DWORD GlobalWorkingOnPreWin2kMScope =  0;
const       DWORD                  One = 0x1;

DWORD
DhcpRegFillClusterAddresses(
    IN OUT  PM_RANGE               Range,
    IN      LPBYTE                 InUseClusters,
    IN      DWORD                  InUseClustersSize,
    IN      LPBYTE                 UsedClusters,
    IN      DWORD                  UsedClustersSize
) {
    DWORD                          Error;
    DWORD                          i;
    DWORD                          Address;
    DWORD   UNALIGNED*             InUseBits;
    DWORD   UNALIGNED*             UsedBits;
    DWORD                          nInUseBits;
    DWORD                          nUsedBits;

    if( InUseClusters && InUseClustersSize ) {
        nInUseBits = InUseClustersSize/sizeof(DWORD);
        InUseBits = (DWORD UNALIGNED*)InUseClusters;

        Require(nInUseBits == 2*InUseBits[0] + 1 );
        nInUseBits --; InUseBits ++;

        while(nInUseBits) {
            for(i = 0; i < sizeof(DWORD)*8; i ++ )
                if( InUseBits[1] & ( One << i ) )
                    SetBitForRange(Range, InUseBits[0] + i );
            nInUseBits -= 2;
            InUseBits += 2;
        }
    }

    if( UsedClusters && UsedClustersSize ) {
        nUsedBits = UsedClustersSize/sizeof(DWORD);
        UsedBits = (DWORD UNALIGNED*)UsedClusters;

        Require(nUsedBits == UsedBits[0] + 1);
        nUsedBits --; UsedBits ++;

        while(nUsedBits) {
            for( i = 0; i < sizeof(DWORD)*8; i ++ )
                SetBitForRange(Range, UsedBits[0] + i);
            UsedBits ++;
            nUsedBits --;
        }
    }

    return ERROR_SUCCESS;
}

static      DWORD                  Masks[] = {
    0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80
};

DWORD
DhcpRegpFillBitsForRange(
    IN      LPBYTE                 Buffer,
    IN      ULONG                  BufSize,
    IN OUT  PM_RANGE               Range,
    IN      PM_SUBNET              Subnet
)
{
    ULONG                          Size, AllocSize, nSet, Offset;
    ULONG                          nBitsSet, Index;
    ULONG                          Error;

    Size = ntohl(((UNALIGNED DWORD *)Buffer)[0]);
    AllocSize = ntohl(((UNALIGNED DWORD *)Buffer)[1]);
    nSet = ntohl(((UNALIGNED DWORD *)Buffer)[2]);
    Offset = ntohl(((UNALIGNED DWORD *)Buffer)[3]);


    //
    // do not check for validity of the offset sizes.
    // SetBitForRange does this check anyway.
    //
    
    // if( Range->Start + Offset + Size > 1+Range->End )
    //     return ERROR_INVALID_DATA;
    
    Require(nSet != 0);
    if( nSet == 0 ) return ERROR_SUCCESS;
    if( nSet == Size ) {
        Require( AllocSize == 0 );
        for( Index = 0; Index < nSet ; Index ++ ) {
            Error = SetBitForRange(Range, Range->Start + Index);
            Require( ERROR_SUCCESS == Error );
        }
        return ERROR_SUCCESS;
    }

    if( AllocSize + sizeof(DWORD)*4  != BufSize ) return ERROR_INVALID_DATA;

    nBitsSet = 0;
    Require( Size/8 <= AllocSize );
    for( Index = 0; Index < Size ; Index ++ ) {
        if( Buffer[ 4*sizeof(DWORD) + (Index/8) ] & Masks[Index%8] ) {
            nBitsSet ++;
            //
            // whistler bug 283457, offset not taken into account
            //
            Error = SetBitForRange( Range, Range->Start + Index + Offset );
            Require( ERROR_SUCCESS == Error );
        }
    }

    Require(nBitsSet == nSet);
    return ERROR_SUCCESS;
}

static
BYTE TempBuffer[MAX_BIT1SIZE + sizeof(DWORD)*4];

DWORD
DhcpRegpFillBitmasks(
    IN      HKEY                   Key,
    IN      PM_RANGE               Range,
    IN      PM_SUBNET              Subnet
)
{
    ULONG                          Error, nValues, Index;
    WCHAR                          ValueNameBuf[100];
    DWORD                          ValueNameSize, ValueType;
    DWORD                          ValueSize;
    WCHAR                          RangeStartStr[30];
    BOOL                           fPostNt5 = FALSE;
    REG_HANDLE                     Hdl;
    
    if( NULL == Key ) {
        ConvertAddressToLPWSTR( Range->Start, RangeStartStr);
        fPostNt5 = TRUE;
        Error = DhcpRegGetThisServer( &Hdl );
        if( NO_ERROR != Error ) return Error;
        Key = Hdl.Key;
    }
            
    Error = RegQueryInfoKey(
        Key, NULL, NULL, NULL, NULL, NULL, NULL, &nValues, NULL, NULL, NULL, NULL
    );
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    Index = nValues -1;
    while( nValues ) {

        ValueNameSize = sizeof(ValueNameBuf)/sizeof(WCHAR);
        ValueSize = sizeof(TempBuffer)/sizeof(WCHAR);
        Error = RegEnumValue(
            Key,
            Index,
            ValueNameBuf,
            &ValueNameSize,
            NULL,
            &ValueType,
            TempBuffer,
            &ValueSize
        );
        if( ERROR_SUCCESS != Error ) goto Cleanup;

        if( fPostNt5 && 0 != wcsncmp(
            ValueNameBuf, RangeStartStr, wcslen(RangeStartStr)) ) {
    
            //
            // Skip irrelevant bitmaps
            //

            Index --;
            nValues --;
            continue;
        }
        
        if( REG_BINARY == ValueType && ValueSize >= sizeof(DWORD)*4 ) {
            Error = DhcpRegpFillBitsForRange(
                TempBuffer,
                ValueSize,
                Range,
                Subnet
            );
            if( ERROR_SUCCESS != Error ) {
                Require(FALSE);
                goto Cleanup;
            }
        }

        Index --;
        nValues --;
    }

    Cleanup:

        if( fPostNt5 ) {
            DhcpRegCloseHdl( &Hdl );
        }

        return Error;
}


DWORD
DhcpRegpSubnetAddRange(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 RangeName,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          LocalError;
    DWORD                          Error;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Flags;
    DWORD                          StartAddress;
    DWORD                          EndAddress;
    LPBYTE                         InUseClusters = NULL;
    DWORD                          InUseClustersSize;
    LPBYTE                         UsedClusters = NULL;
    DWORD                          UsedClustersSize;
    ULONG                          Alloc, MaxAlloc;
    PM_RANGE                       OverlappingRange;
    PM_RANGE                       ThisRange = NULL;
    BOOL                           fRangeAdded = FALSE;
    
    Error = DhcpRegSubnetGetRangeHdl(Hdl, RangeName, &Hdl2);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRangeGetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Alloc,
        &MaxAlloc,
        &StartAddress,
        &EndAddress,
        &InUseClusters,
        &InUseClustersSize,
        &UsedClusters,
        &UsedClustersSize
    );
    ERRCHK;

    if( 0 == StartAddress || 0 == EndAddress ) {
        INVALID_REG("[DHCPServer] Noticed undefined range: %ws (ignored)\n", RangeName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( FALSE == Subnet->fSubnet && GlobalWorkingOnPreWin2kMScope ) {
        Subnet->MScopeId = StartAddress;
        GlobalWorkingOnPreWin2kMScope = FALSE;
    }

    Error = MemSubnetAddRange(
        Subnet,
        StartAddress,
        EndAddress,
        Flags,
        Alloc,
        MaxAlloc,
        &OverlappingRange,
	INVALID_UNIQ_ID
    );
    ERRCHK;

    fRangeAdded = TRUE;
    
    Error = MemSubnetGetAddressInfo(
        Subnet,
        StartAddress,
        &ThisRange,
        NULL,
        NULL
    );
    ERRCHK;

    if( InUseClustersSize || UsedClustersSize ) {

        //
        // Old style information?  Save it as new style
        //

        GlobalWorkingOnOldStyleSubnet ++;
        DhcpRegFillClusterAddresses(
            ThisRange,
            InUseClusters,
            InUseClustersSize,
            UsedClusters,
            UsedClustersSize
        );  // this is always returning ERROR_SUCCESS.

        //
        // Error = FlushRanges(ThisRange, FLUSH_ANYWAY, Subnet);
        // Require( ERROR_SUCCESS == Error );
        //
        // Do not actually write back the stuff to the registry..
        // This read code path is used in dhcpexim at which time
        // the registry should not be munged..
        //
        
    } else {

        //
        // Need to read new style bitmasks..
        //

        Error = DhcpRegpFillBitmasks(
            Hdl2.Key,
            ThisRange,
            Subnet
        );
        Require( ERROR_SUCCESS == Error );
    }

  Cleanup:
    Report("SubnetAddRange");

    if( ERROR_SUCCESS != Error && ThisRange ) {
        if( !fRangeAdded ) {
            LocalError = MemRangeCleanup(ThisRange);
            Require( ERROR_SUCCESS == LocalError );
        } else {
            LocalError = MemSubnetDelRange( 
                Subnet, StartAddress );
            Require( ERROR_SUCCESS == LocalError );
        }
    }
    
    if( Name ) MemFree(Name);
    if( Comment ) MemFree(Comment);
    if( InUseClusters ) MemFree(InUseClusters);
    if( UsedClusters ) MemFree(UsedClusters);

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);

    return Error;
}

DWORD
DhcpRegpReservationAddOption(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    IN      PM_RESERVATION         Reservation
)
{
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    DWORD                          OptionId;
    LPWSTR                         ClassName = NULL;
    LPWSTR                         VendorName = NULL;
    DWORD                          Flags;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTION                      Option = NULL;
    PM_OPTION                      DeletedOption = NULL;
    PM_CLASSDEF                    ThisClasDef;

    Error = DhcpRegReservationGetOptHdl(Hdl, OptionName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegOptGetAttributes(
        &Hdl2,
        &OptionId,
        &ClassName,
        &VendorName,
        &Flags,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( OptionId == 0 )  // old registry format does not contain "OptionId" value => it can be taken from the key name.
        OptionId = _wtol(OptionName);

    if( OptionId == 0 || NULL == Value || 0 == ValueSize ) {
        INVALID_REG("[DHCPServer] Found invalid option %ws (ignored)\n", OptionName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( NULL == ClassName || wcslen(ClassName) == 0) ClassId = 0;
    else {
        PM_SUBNET                  Subnet = Reservation->SubnetPtr;
        PM_SERVER                  Server = Subnet->ServerPtr;
        Error = MemServerGetClassDef(Server,0, ClassName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            if (*(DWORD *)ClassName != OptionId)    // some registry entries were corrupted due to an old bug. Load these entries too (see bug #192933)
            {
                INVALID_REG("ReservationAddOption(%ws): unknown class (ignored)\n", OptionName);
                Error = ERROR_SUCCESS;
                goto Cleanup;
            }
            else
            {
                ClassId = 0;
            }

        } else {
            ClassId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == FALSE);
        }
    }

    if( NULL == VendorName || wcslen(VendorName) == 0 ) VendorId = 0;
    else {
        PM_SUBNET                  Subnet = Reservation->SubnetPtr;
        PM_SERVER                  Server = Subnet->ServerPtr;
        Error = MemServerGetClassDef(Server,0, VendorName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            INVALID_REG("ReservationAddOption(%ws): unknown vendor (ignored)\n", OptionName);
            Error = ERROR_SUCCESS;
            goto Cleanup;
        } else {
            VendorId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == TRUE);
        }
    }

    if( 0 == OptionId ) OptionId = ConvertWStringToDWORD(OptionName);

    Error = MemOptInit(&Option, OptionId, ValueSize, Value);
    ERRCHK;

    Error = MemOptClassAddOption( &(Reservation->Options), Option, ClassId,
				 VendorId, &DeletedOption, INVALID_UNIQ_ID );
    ERRCHK;

  Cleanup:
    Report("ReservationAddOption");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( ClassName ) MemFree(ClassName);
    if( VendorName ) MemFree(VendorName);
    if( Value ) MemFree(Value);
    if( DeletedOption ) {
        LocalError = MemOptCleanup(DeletedOption);
        Require(ERROR_SUCCESS == LocalError);
    }
    if( ERROR_SUCCESS != Error && Option ) {
        LocalError = MemOptCleanup(Option);
        Require(ERROR_SUCCESS == LocalError);
    }
    return Error;

}

DWORD
DhcpRegpSubnetAddReservation(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ReservationName,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          LocalError;
    DWORD                          Error;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Flags;
    DWORD                          Address;
    LPBYTE                         ClientUID = NULL;
    DWORD                          ClientUIDSize;
    PM_RESERVATION                 ThisReservation;
    ARRAY                          Options;

    Error = DhcpRegSubnetGetReservationHdl(Hdl, ReservationName, &Hdl2);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegReservationGetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Address,
        &ClientUID,
        &ClientUIDSize
    );
    ERRCHK;

    if( 0 == Address || NULL == ClientUID || 0 == ClientUIDSize ) {
        INVALID_REG("[DHCPServer] Found invalid reservation %ws (ignored)\n", ReservationName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = MemReserveAdd(
        &(Subnet->Reservations),
        Address,
        Flags,
        ClientUID,
        ClientUIDSize,
	INVALID_UNIQ_ID
    );
    // if the reservation is a duplicate ignore the error and do no further processing as the
    // reservation structure was already initialized. The duplicate reservation will simply be
    // ignored.
    if (ERROR_SUCCESS == Error)
    {
        Error = MemReserveFindByAddress(
            &(Subnet->Reservations),
            Address,
            &ThisReservation
        );
        ERRCHK;

        ThisReservation->SubnetPtr = Subnet;

        Error = MemArrayInit(&Options);
        ERRCHK;

        Error = DhcpRegReservationGetList(
            &Hdl2,
            &Options
        );
        ERRCHK;

        Error = LoopThruArray(&Options, DhcpRegpReservationAddOption, &Hdl2, ThisReservation);

    } else if ( ERROR_OBJECT_ALREADY_EXISTS == Error )
        Error = ERROR_SUCCESS;

  Cleanup:
    Report("SubnetAddReservation");

    if( Name ) MemFree(Name);
    if( Comment ) MemFree(Comment);
    if( ClientUID ) MemFree(ClientUID);

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);

    FreeArray(&Options);
    return Error;
}


DWORD
DhcpRegpSubnetAddOption(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    DWORD                          OptionId;
    LPWSTR                         ClassName = NULL;
    LPWSTR                         VendorName = NULL;
    DWORD                          Flags;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTION                      Option = NULL;
    PM_OPTION                      DeletedOption = NULL;
    PM_CLASSDEF                    ThisClasDef;

    Error = DhcpRegSubnetGetOptHdl(Hdl, OptionName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegOptGetAttributes(
        &Hdl2,
        &OptionId,
        &ClassName,
        &VendorName,
        &Flags,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( OptionId == 0 )  // old registry format does not contain "OptionId" value => it can be taken from the key name.
        OptionId = _wtol(OptionName);


    if( OptionId == 0 || NULL == Value || 0 == ValueSize ) {
        INVALID_REG("[DHCPServer] Found invalid option %ws (ignored)\n", OptionName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( NULL == ClassName || wcslen(ClassName) == 0) ClassId = 0;
    else {
        Error = MemServerGetClassDef((PM_SERVER)(Subnet->ServerPtr),0, ClassName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            if (*(DWORD *)ClassName != OptionId)    // some registry entries were corrupted due to an old bug. Load these entries too (see bug #192933)
            {
                INVALID_REG("SubnetAddOption(%ws): unknown class (ignored)\n", OptionName);
                Error =  ERROR_SUCCESS;
                goto Cleanup;
            }
            else
            {
                ClassId = 0;
            }
        } else {
            ClassId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == FALSE);
        }
    }
    if( NULL == VendorName || wcslen(VendorName) == 0 ) VendorId = 0;
    else {
        Error = MemServerGetClassDef((PM_SERVER)(Subnet->ServerPtr),0, VendorName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            INVALID_REG("SubnetAddOption(%ws): unknown class (ignored)\n", OptionName);
            Error =  ERROR_SUCCESS;
            goto Cleanup;
        } else {
            VendorId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == TRUE);
        }
    }
    if( 0 == OptionId ) OptionId = ConvertWStringToDWORD(OptionName);

    Error = MemOptInit(&Option, OptionId, ValueSize, Value);
    ERRCHK;

    Error = MemOptClassAddOption( &(Subnet->Options), Option, ClassId,
				 VendorId, &DeletedOption, INVALID_UNIQ_ID );
    ERRCHK;

  Cleanup:
    Report("Subnet Add Option");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( ClassName ) MemFree(ClassName);
    if( VendorName ) MemFree(VendorName);
    if( Value ) MemFree(Value);
    if( DeletedOption ) {
        LocalError = MemOptCleanup(DeletedOption);
        Require(ERROR_SUCCESS == LocalError);
    }
    if( ERROR_SUCCESS != Error && Option ) {
        LocalError = MemOptCleanup(Option);
        Require(ERROR_SUCCESS == LocalError);
    }
    return Error;

}

DWORD
DhcpRegSubnetAddExclusions(
    IN      PM_SUBNET              Subnet,
    IN      LPBYTE                 Excl,
    IN      DWORD                  ExclSize
)
{
    DWORD   UNALIGNED*             Addr;
    DWORD                          Count, i, j;
    DWORD                          Error;
    PM_EXCL                        OverlappingExcl;

    Count = ExclSize / sizeof(DWORD);
    Addr = (DWORD UNALIGNED*)Excl;

    if( 0 == Count || 0 == Addr[0] || 0 == Addr[1] ) {
        INVALID_REG("[DHCPServer] invalid exclusion ignored\n");
        return ERROR_SUCCESS;
    }

    Require(Count == 2*Addr[0] + 1);
    Count --; Addr ++;

    while(Count) {
        Error = MemSubnetAddExcl(
            Subnet,
            Addr[0],
            Addr[1],
            &OverlappingExcl,
	    INVALID_UNIQ_ID
        );
        if( ERROR_SUCCESS != Error ) {
            INVALID_REG("[DHCPServer] DhcpRegSubnetAddExclusions:MemSubnetAddExcl;0x%lx\n", Error);
        } else {
            if( Subnet->fSubnet && GlobalWorkingOnOldStyleSubnet ) {
                //
                // For subnets alone (not mscopes), check if
                // we are upgrading from pre-win2k -- then make sure
                // all address from the excluded range are removed
                // from the bitmask
                //
            
                for( i = Addr[0]; i <= Addr[1]; i ++ ) {
                    MemSubnetReleaseAddress(
                        Subnet, i, FALSE
                        );
                }
            }
        
        }

        Addr += 2;
        Count -= 2;
    }
    return ERROR_SUCCESS;
}

DWORD
DhcpRegServerAddSubnet(
    IN      PREG_HANDLE            Hdl,
    IN      PM_SERVER              Server,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          Error;
    DWORD                          Index;
    ARRAY                          Servers;
    ARRAY                          IpRanges;
    ARRAY                          Reservations;
    ARRAY                          Options;
    LPBYTE                         Excl = NULL;
    DWORD                          ExclSize;
    struct {
        PARRAY                     Array;
        ARRAY_FN                   Fn;
    } Lists[] = {
        &Servers,                  DhcpRegpSubnetAddServer,
        &IpRanges,                 DhcpRegpSubnetAddRange,
        &Reservations,             DhcpRegpSubnetAddReservation,
        &Options,                  DhcpRegpSubnetAddOption
    };

    Subnet->ServerPtr = Server;
    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        InitArray(Lists[Index].Array);
    }

    Error = DhcpRegSubnetGetList(
        Hdl, &Servers, &IpRanges, &Reservations, &Options, &Excl, &ExclSize
    );

    GlobalWorkingOnOldStyleSubnet = 0;
    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        Error = LoopThruArray(Lists[Index].Array, Lists[Index].Fn, Hdl, Subnet);
        ERRCHK;
    }

    if( GlobalWorkingOnOldStyleSubnet ) {
        Report("Old style subnet found, careful with exclusions\n");
    }
    
    if( Excl ) Error = DhcpRegSubnetAddExclusions(Subnet, Excl, ExclSize);
    
    ERRCHK;

    Error = Subnet->fSubnet ? MemServerAddSubnet(Server, Subnet, INVALID_UNIQ_ID )
                            : MemServerAddMScope(Server, Subnet, INVALID_UNIQ_ID );

  Cleanup:
    GlobalWorkingOnOldStyleSubnet = 0;
    GlobalWorkingOnPreWin2kMScope = 0;
    Report("ServerAddSubnet");

    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        FreeArray(Lists[Index].Array);
    }

    return Error;
}

DWORD
DhcpRegServerAddMScope(
    IN      PREG_HANDLE            Hdl,
    IN      PM_SERVER              Server,
    IN      PM_MSCOPE              MScope
)
{
    return DhcpRegServerAddSubnet(Hdl, Server, MScope);
}

DWORD
DhcpRegServerAddSScope(
    IN      PREG_HANDLE            Hdl,
    IN      PM_SERVER              Server,
    IN      PM_SSCOPE              SScope
)
{
    DWORD                          Error;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    LPWSTR                         SubnetWString;
    DWORD                          SubnetAddress;
    PM_SUBNET                      Subnet;

    InitArray(&Subnets);

    Error = DhcpRegSScopeGetList(Hdl, &Subnets);
    ERRCHK;

    Error = MemArrayInitLoc(&Subnets, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Subnets, &Loc, &SubnetWString);
        Require(ERROR_SUCCESS == Error && SubnetWString);

        SubnetAddress = WStringToAddress(SubnetWString);

        Error = MemServerGetAddressInfo(
            Server,
            SubnetAddress,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_SUCCESS == Error && Subnet ) {
            Error = MemSubnetSetSuperScope(Subnet,SScope);
            Require(ERROR_SUCCESS == Error);
        }

        Error = MemArrayNextLoc(&Subnets, &Loc);
    }
    Error = MemServerAddSScope( Server, SScope );

  Cleanup:
    Report("ServerAddSScope");

    FreeArray(&Subnets);

    return Error;
} // DhcpRegpServerAddSScope()

DWORD
DhcpRegpServerAddSubnet(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 SubnetName,
    IN      PM_SERVER              Server
)
{
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Address;
    DWORD                          Flags;
    DWORD                          Mask;
    PM_SUBNET                      Subnet = NULL;

    Error = DhcpRegServerGetSubnetHdl(Hdl, SubnetName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegSubnetGetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Address,
        &Mask
    );
    ERRCHK;

    if( NULL == Name || 0 == Address || 0 == Mask ) {
        INVALID_REG("[DHCPServer] invalid subnet %ws ignored\n", SubnetName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = MemSubnetInit(
        &Subnet,
        Address,
        Mask,
        Flags,
        0,
        Name,
        Comment
    );
    ERRCHK;

    Error = DhcpRegServerAddSubnet(&Hdl2, Server, Subnet);

  Cleanup:
    Report("ServerAddSubnet");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require( ERROR_SUCCESS == LocalError);
    if( Name ) MemFree(Name);
    if( Comment ) MemFree(Comment);

    if( ERROR_SUCCESS != Error ) {
        if( Subnet ) {
            LocalError = MemSubnetCleanup(Subnet);
            Require(ERROR_SUCCESS == LocalError);
        }
    }
    return Error;
}

DWORD
DhcpRegpServerAddMScope(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 MScopeName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Comment = NULL;
    DWORD                          State;
    DWORD                          ScopeId;
    DWORD                          Policy;
    PM_MSCOPE                      MScope = NULL;
    LPWSTR                         LangTag = NULL;
    DWORD                          TTL = 32;
    PDATE_TIME                     ExpiryTime = NULL;

    GlobalWorkingOnPreWin2kMScope = 0;
    Error = DhcpRegServerGetMScopeHdl(Hdl, MScopeName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegMScopeGetAttributes(
        &Hdl2,
        &Comment,
        &State,
        &ScopeId,
        &Policy,
        &TTL,
        &LangTag,
        &ExpiryTime
    );
    if( ERROR_INVALID_DATA == Error ) {
        GlobalWorkingOnPreWin2kMScope = TRUE;
        //
        // hackorama isn't it? 
        //
        Error = NO_ERROR;
    }
    ERRCHK;

    if( 0 == ScopeId || GlobalWorkingOnPreWin2kMScope ) {
        INVALID_REG("[DHCPServer] invalid m-scope %ws, id %ld ignored\n", MScopeName, ScopeId);
        Error = ERROR_SUCCESS;
        //goto Cleanup;
    }

    Error = MemMScopeInit(
        &MScope,
        ScopeId,
        State,
        Policy,
        (BYTE)TTL,
        MScopeName,
        Comment,
        LangTag,
        *ExpiryTime
    );
    ERRCHK;

    Error = DhcpRegServerAddMScope(&Hdl2, Server, MScope);

  Cleanup:

    GlobalWorkingOnPreWin2kMScope = 0;
    Report("Server Add MScope");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( Comment ) MemFree(Comment);
    if( LangTag ) MemFree(LangTag);
    if( ExpiryTime ) MemFree(ExpiryTime);

    if( ERROR_SUCCESS != Error ) {
        if( MScope ) {
            LocalError = MemMScopeCleanup(MScope);
            Require(ERROR_SUCCESS == Error);
        }
    }
    return Error;
}

DWORD
DhcpRegpServerAddSScope(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 SScopeName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Flags;
    PM_SSCOPE                      SScope = NULL;

    Error = DhcpRegServerGetSScopeHdl(Hdl, SScopeName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

#if 0                                             // superscope name is given above -- nothing else to be done
    Error = DhcpRegSScopeGetAttributes(
        &Hdl2,
        &Name,
        &Description,
        &Flags
    );
    ERRCHK;
#endif

    Error = MemSScopeInit(
        &SScope,
        0,
        SScopeName
    );
    ERRCHK;

    Error = DhcpRegServerAddSScope(&Hdl2, Server, SScope);

  Cleanup:
    Report("Server Add Scope");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);

    if( ERROR_SUCCESS != Error ) {
        if( SScope ) {
            LocalError = MemSScopeCleanup(SScope);
            Require(ERROR_SUCCESS == Error);
        }
    }
    return Error;
}

DWORD
DhcpRegpServerAddOption(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    DWORD                          OptionId;
    LPWSTR                         ClassName = NULL;
    LPWSTR                         VendorName = NULL;
    DWORD                          Flags;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTION                      Option = NULL;
    PM_OPTION                      DeletedOption = NULL;
    PM_CLASSDEF                    ThisClasDef;

    Error = DhcpRegServerGetOptHdl(Hdl, OptionName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegOptGetAttributes(
        &Hdl2,
        &OptionId,
        &ClassName,
        &VendorName,
        &Flags,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( OptionId == 0 )  // old registry format does not contain "OptionId" value => it can be taken from the key name.
        OptionId = _wtol(OptionName);

    if( 0 == OptionId || NULL == Value || 0 == ValueSize ) {
        INVALID_REG("[DHCPServer] found invalid option %ws (ignored)\n", OptionName );
        Error =  ERROR_SUCCESS;
        goto Cleanup;
    }

    if( NULL == ClassName || wcslen(ClassName) == 0) ClassId = 0;
    else {
        Error = MemServerGetClassDef(Server,0, ClassName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            if (*(DWORD *)ClassName != OptionId)    // some registry entries were corrupted due to an old bug. Load these entries too (see bug #192933)
            {
                INVALID_REG("ServerAddOption(%ws): unknown class (ignored)\n", OptionName);
                Error = ERROR_SUCCESS;
                goto Cleanup;
            }
            else
            {
                ClassId = 0;
            }
        } else {
            ClassId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == FALSE);
        }
    }
    if( NULL == VendorName || wcslen(VendorName) == 0) VendorId = 0;
    else {
        Error = MemServerGetClassDef(Server,0, VendorName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            INVALID_REG("ServerAddOption(%ws): unknown class (ignored)\n", OptionName);
            Error = ERROR_SUCCESS;
            goto Cleanup;
        } else {
            VendorId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == TRUE);
        }
    }

    Error = MemOptInit(&Option, OptionId, ValueSize, Value);
    ERRCHK;

    Error = MemOptClassAddOption( &(Server->Options), Option, ClassId,
				 VendorId, &DeletedOption, INVALID_UNIQ_ID );
    ERRCHK;

  Cleanup:
    Report("Server Add Option");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( ClassName ) MemFree(ClassName);
    if( VendorName ) MemFree(VendorName);
    if( Value ) MemFree(Value);
    if( DeletedOption ) {
        LocalError = MemOptCleanup(DeletedOption);
        Require(ERROR_SUCCESS == LocalError);
    }
    if( ERROR_SUCCESS != Error && Option ) {
        LocalError = MemOptCleanup(Option);
        Require(ERROR_SUCCESS == LocalError);
    }
    return Error;
}

DWORD
DhcpRegpServerAddDefList(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 DefName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comments = NULL;
    DWORD                          Flags;
    DWORD                          OptionId;
    LPWSTR                         ClassName = NULL;
    LPWSTR                         VendorName = NULL;
    DWORD                          ClassId;
    DWORD                          VendorId;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;
    PM_CLASSDEF                    ThisClassDef;

    Error = DhcpRegServerGetOptDefHdl(Hdl, DefName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegOptDefGetAttributes(
        &Hdl2,
        &Name,
        &Comments,
        &Flags,
        &OptionId,
        &ClassName,
        &VendorName,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( OptionId == 0)
        OptionId = _wtol(DefName);

    if( NULL == Name || 0 == OptionId ) {
        INVALID_REG("[DHCPServer] invalid option def %ws ignored\n", DefName );
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( NULL == ClassName || wcslen(ClassName) == 0) ClassId = 0;
    else {
        Error = MemServerGetClassDef(Server,0, ClassName,0,NULL,&ThisClassDef);
        if( ERROR_SUCCESS != Error ) ClassId = 0;
        else {
            ClassId = ThisClassDef->ClassId;
            Require(ThisClassDef->IsVendor == FALSE);
        }
    }
    if( NULL == VendorName || wcslen(VendorName) == 0 ) VendorId = 0;
    else {
        Error = MemServerGetClassDef(Server,0, VendorName,0,NULL,&ThisClassDef);
        if( ERROR_SUCCESS != Error ) VendorId = 0;
        else {
            VendorId = ThisClassDef->ClassId;
            Require(ThisClassDef->IsVendor == TRUE);
        }
    }

    Error = MemOptClassDefListAddOptDef(
        &(Server->OptDefs),
        ClassId,
        VendorId,
        OptionId,
        Flags,
        Name,
        Comments,
        Value,
        ValueSize,
	INVALID_UNIQ_ID
    );

  Cleanup:
    Report("Server Add DefList");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( Name ) MemFree(Name);
    if( Comments ) MemFree(Comments);
    if( ClassName ) MemFree(ClassName);
    if( VendorName ) MemFree(VendorName);
    if( Value ) MemFree(Value);

    return Error;
}

DWORD
DhcpRegpServerAddClassDef(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ClassDefName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Flags;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;

    Error = DhcpRegServerGetClassDefHdl(Hdl, ClassDefName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegClassDefGetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( NULL == Name || 0 == ValueSize || NULL == Value ) {
        INVALID_REG("[DHCPServer] invalid class def %ws ignored\n", ClassDefName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = MemClassDefListAddClassDef(
        &(Server->ClassDefs),
        MemNewClassId(),
        Flags,
        0, /* no Type... */
        Name,
        Comment,
        Value,
        ValueSize,
	INVALID_UNIQ_ID
    );
    ERRCHK;

  Cleanup:
    Report("Server Add ClassDef");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( Name ) MemFree(Name);
    if( Comment ) MemFree(Comment);
    if( Value ) MemFree(Value);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegReadSubServer(                             // read all the sub objects of a server and add 'em
    IN      PREG_HANDLE            Hdl,
    IN OUT  PM_SERVER              Server
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Index;
    ARRAY                          OptList;
    ARRAY                          DefList;
    ARRAY                          ClassDefs;
    ARRAY                          Subnets;
    ARRAY                          MScopes;
    ARRAY                          SScopes;
    struct {
        PARRAY                     Array;
        ARRAY_FN                   Fn;
    } Lists[] = {
        &ClassDefs,                DhcpRegpServerAddClassDef,
        &DefList,                  DhcpRegpServerAddDefList,
        &OptList,                  DhcpRegpServerAddOption,
        &Subnets,                  DhcpRegpServerAddSubnet,
        &MScopes,                  DhcpRegpServerAddMScope,
        &SScopes,                  DhcpRegpServerAddSScope
    };

    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        InitArray(Lists[Index].Array);
    }

    Error = DhcpRegServerGetList(
        Hdl, &OptList, &DefList, &Subnets, &SScopes, &ClassDefs, &MScopes
    );
    ERRCHK;

    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        Error = LoopThruArray(Lists[Index].Array, Lists[Index].Fn, Hdl, Server);
        ERRCHK;
    }

  Cleanup:

    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        FreeArray(Lists[Index].Array);
    }

    Report("ServerAddSubServer");

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegReadServer(                                // read the server and all its sub objects
    IN      PREG_HANDLE            Hdl,
    OUT     PM_SERVER             *Server         // return the created object
) //EndExport(function)
{
    DWORD                          Error;
    LPWSTR                         Name;
    LPWSTR                         Comments;
    DWORD                          Flags;
    PM_SERVER                      ThisServer;

    Name = NULL; Comments = NULL; Flags = 0; ThisServer = NULL;

    Error = DhcpRegServerGetAttributes(
        Hdl,
        &Name,
        &Comments,
        &Flags
    );
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    Error = MemServerInit(
        &ThisServer,
        0xFFFFFFFF,
        Flags,
        0,
        Name,
        Comments
    );
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    Error = DhcpRegReadSubServer(Hdl, ThisServer);
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    *Server = ThisServer;

  Cleanup:
    if( NULL != Name ) MemFree(Name);
    if( NULL != Comments) MemFree(Comments);
    if( ERROR_SUCCESS != Error && NULL != ThisServer) {
        MemServerCleanup(ThisServer);
    }

    return Error;
}
//BeginExport(function)
DWORD
DhcpRegReadThisServer(                            // recursively read for the current server
    OUT     PM_SERVER             *Server
) //EndExport(function)
{
    DWORD                          Error;
    REG_HANDLE                     ThisServer;
    LPWSTR                         Name;
    LPWSTR                         Comment;


    Error = DhcpRegGetThisServer(&ThisServer);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegReadServer(&ThisServer, Server);
    DhcpRegCloseHdl(&ThisServer);

    return Error;
}

DWORD
DhcpRegReadScopeBitmasks(
    IN OUT PM_SUBNET Scope
    )
{
    PM_RANGE Range;
    ARRAY_LOCATION Loc;
    DWORD Error;
    WCHAR SubnetStr[sizeof("000.000.000.000")];
    REG_HANDLE Hdl, Hdl1;

    
    Error = MemArrayInitLoc( &Scope->Ranges, &Loc);
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement( &Scope->Ranges, &Loc, &Range );
        Require( NO_ERROR == Error && NULL != Range );

        //
        // Fill in the range
        //

 
        Error = DhcpRegpFillBitmasks(
            NULL, Range, Scope );
        ASSERT( NO_ERROR == Error );
        
        Error = MemArrayNextLoc( &Scope->Ranges, &Loc );
    }

    if( ERROR_FILE_NOT_FOUND != Error ) return Error;
    return NO_ERROR;
}

//BeginExport(function)
DWORD
DhcpRegReadServerBitmasks(
    IN OUT PM_SERVER Server
) // EndExport(function)
{
    PM_SUBNET Scope, MScope;
    ARRAY_LOCATION Loc;
    DWORD Error;
    
    Error = MemArrayInitLoc(&Server->Subnets, &Loc);
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement( &Server->Subnets, &Loc, &Scope);
        Require( NO_ERROR == Error && NULL != Scope );

        //
        // get the keys to the scope in question
        //

        Error = DhcpRegReadScopeBitmasks(Scope);
        if( NO_ERROR != Error ) return Error;
        
        Error = MemArrayNextLoc( &Server->Subnets, &Loc );
    }

    if( ERROR_FILE_NOT_FOUND != Error ) return Error;

    Error = MemArrayInitLoc(&Server->MScopes, &Loc);
    while( NO_ERROR == Error ) {
        Require( ERROR_SUCCESS == Error );

        Error = MemArrayGetElement( &Server->MScopes, &Loc, &MScope);
        Require( NO_ERROR == Error && NULL != MScope );

        //
        // get the keys to the scope in question
        //

        Error = DhcpRegReadScopeBitmasks(MScope);
        if( NO_ERROR != Error ) return Error;

        Error = MemArrayNextLoc( &Server->MScopes, &Loc );
    }

    if( ERROR_FILE_NOT_FOUND != Error ) return Error;
    return NO_ERROR;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\regread.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
DhcpRegReadSubServer(                             // read all the sub objects of a server and add 'em
    IN      PREG_HANDLE            Hdl,
    IN OUT  PM_SERVER              Server
) ;


DWORD
DhcpRegReadServer(                                // read the server and all its sub objects
    IN      PREG_HANDLE            Hdl,
    OUT     PM_SERVER             *Server         // return the created object
) ;


DWORD
DhcpRegReadThisServer(                            // recursively read for the current server
    OUT     PM_SERVER             *Server
) ;

DWORD
DhcpRegReadServerBitmasks(
    IN OUT PM_SERVER Server
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\regsave.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This implements the save functionality.. whenever something needs
// to be saved onto the registry, this is the place...
// it is expected that this would be used only during API re-configuration or
// during routine "address-allocation" where the bitmask needs to be flushed to disk
//================================================================================

#include    <mmregpch.h>
#include    <regutil.h>

#define     InitArray(X)           do{DWORD Error = MemArrayInit((X)); Require(ERROR_SUCCESS == Error); }while(0)
#define     ERRCHK                 do{if( ERROR_SUCCESS != Error ) goto Cleanup; }while(0)
#define     FreeArray1(X)          Error = LoopThruArray((X), DestroyString, NULL, NULL);Require(ERROR_SUCCESS == Error);
#define     FreeArray2(X)          Error = MemArrayCleanup((X)); Require(ERROR_SUCCESS == Error);
#define     FreeArray(X)           do{ DWORD Error; FreeArray1(X); FreeArray2(X); }while(0)
#define     Report(Who)            if(Error) DbgPrint("[DHCPServer] %s: %ld [0x%lx]\n", Who, Error, Error)


typedef     DWORD                  (*ARRAY_FN)(PREG_HANDLE, LPWSTR ArrayString, LPVOID MemObject);

DWORD
LoopThruArray(
    IN      PARRAY                 Array,
    IN      ARRAY_FN               ArrayFn,
    IN      PREG_HANDLE            Hdl,
    IN      LPVOID                 MemObject
);

DWORD
DestroyString(
    IN      PREG_HANDLE            RegHdl,
    IN      LPWSTR                 Str,
    IN      LPVOID                 Something
);

//BeginExport(function)
DWORD
DhcpRegSaveOptDef(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  OptType,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    LPWSTR                         OptDefStr;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        Error = DhcpRegServerGetOptDefHdl(&Hdl, OptDefStr, &Hdl2);
        MemFree(OptDefStr);
    }
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegOptDefSetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &OptType,
        &OptId,
        &ClassName,
        &VendorName,
        &OptVal,
        OptLen
    );

    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteOptDef(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    LPWSTR                         OptDefStr;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        Error = DhcpRegServerGetOptDefHdl(&Hdl, L"", &Hdl2);
        if( ERROR_SUCCESS == Error ) {
            Error = DhcpRegRecurseDelete(&Hdl2, OptDefStr);
            Error2 = DhcpRegCloseHdl(&Hdl2);
            Require(ERROR_SUCCESS == Error2);
        }
        MemFree(OptDefStr);
    }
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveGlobalOption(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    LPWSTR                         OptDefStr;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpRegServerGetOptHdl(&Hdl, OptDefStr, &Hdl2);
    MemFree(OptDefStr);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegOptSetAttributes(
            &Hdl2,
            &OptId,
            &ClassName,
            &VendorName,
            NULL,
            &Value,
            ValueSize
        );
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteGlobalOption(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    LPWSTR                         OptDefStr;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        Error = DhcpRegServerGetOptHdl(&Hdl, L"", &Hdl2);
        if( ERROR_SUCCESS == Error ) {
            Error = DhcpRegRecurseDelete(&Hdl2, OptDefStr);
            Error2 = DhcpRegCloseHdl(&Hdl2);
            Require(ERROR_SUCCESS == Error2);
        }
        MemFree(OptDefStr);
    }
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveSubnetOption(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    LPWSTR                         OptDefStr;
    WCHAR                          SubnetStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, SubnetStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegSubnetGetOptHdl(&Hdl2, OptDefStr, &Hdl3);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }
    MemFree(OptDefStr);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegOptSetAttributes(
            &Hdl3,
            &OptId,
            &ClassName,
            &VendorName,
            NULL,
            &Value,
            ValueSize
        );
        Error2 = DhcpRegCloseHdl(&Hdl3);
        Require(ERROR_SUCCESS == Error2);
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteSubnetOption(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    LPWSTR                         OptDefStr;
    WCHAR                          SubnetStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, SubnetStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegSubnetGetOptHdl(&Hdl2, L"", &Hdl3);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegRecurseDelete(&Hdl3, OptDefStr);
        Error2 = DhcpRegCloseHdl(&Hdl3);
        Require(ERROR_SUCCESS == Error2);
    }
    MemFree(OptDefStr);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveReservedOption(
    IN      DWORD                  Address,
    IN      DWORD                  ReservedAddress,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    LPWSTR                         OptDefStr;
    WCHAR                          SubnetStr[sizeof("000.000.000.000")];
    WCHAR                          ReservedStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Address, SubnetStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegSubnetGetReservationHdl(&Hdl2, ConvertAddressToLPWSTR(ReservedAddress, ReservedStr), &Hdl3);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegReservationGetOptHdl(&Hdl3, OptDefStr, &Hdl2);
        Error2 = DhcpRegCloseHdl(&Hdl3);
        Require(ERROR_SUCCESS == Error2);
    }

    MemFree(OptDefStr);
    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegOptSetAttributes(
            &Hdl2,
            &OptId,
            &ClassName,
            &VendorName,
            NULL,
            &Value,
            ValueSize
        );
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteReservedOption(
    IN      DWORD                  Address,
    IN      DWORD                  ReservedAddress,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    LPWSTR                         OptDefStr;
    WCHAR                          SubnetStr[sizeof("000.000.000.000")];
    WCHAR                          ReservedStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Address, SubnetStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegSubnetGetReservationHdl(&Hdl2, ConvertAddressToLPWSTR(ReservedAddress, ReservedStr), &Hdl3);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegReservationGetOptHdl(&Hdl3, L"", &Hdl2);
        Error2 = DhcpRegCloseHdl(&Hdl3);
        Require(ERROR_SUCCESS == Error2);
    }

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegRecurseDelete(&Hdl2, OptDefStr);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }
    MemFree(OptDefStr);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveClassDef(
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  Flags,
    IN      LPBYTE                 Data,
    IN      DWORD                  DataLength
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;

    if( NULL == Name ) return ERROR_INVALID_PARAMETER;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetClassDefHdl(&Hdl, Name, &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    Error = DhcpRegClassDefSetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Data,
        DataLength
    );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteClassDef(
    IN      LPWSTR                 Name
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;

    if( NULL == Name ) return ERROR_INVALID_PARAMETER;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetClassDefHdl(&Hdl, L"", &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    Error = DhcpRegRecurseDelete(&Hdl2, Name);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveReservation(
    IN      DWORD                  Subnet,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDLength
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet, AddressStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegSubnetGetReservationHdl(&Hdl2, ConvertAddressToLPWSTR(Address, AddressStr), &Hdl3);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegReservationSetAttributes(
        &Hdl3,
        NULL,
        NULL,
        &Flags,
        &Address,
        &ClientUID,
        ClientUIDLength
    );
    Error2 = DhcpRegCloseHdl(&Hdl3);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteReservation(
    IN      DWORD                  Subnet,
    IN      DWORD                  Address
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet, AddressStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegSubnetGetReservationHdl(&Hdl2, L"", &Hdl3);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRecurseDelete(&Hdl3, ConvertAddressToLPWSTR(Address, AddressStr));
    Error2 = DhcpRegCloseHdl(&Hdl3);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSScopeDeleteSubnet(
    IN      LPWSTR                 SScopeName,
    IN      DWORD                  SubnetAddress
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSScopeHdl(&Hdl, SScopeName, &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRecurseDelete(&Hdl2, ConvertAddressToLPWSTR(SubnetAddress, AddressStr));
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

DWORD
DhcpRegpDelSubnetFromSScope(
    IN      PREG_HANDLE            Unused,
    IN      LPWSTR                 SScopeName,
    IN      LPVOID                 Address
)
{
    DWORD                          Error;

    Error =  DhcpRegSScopeDeleteSubnet(SScopeName, PtrToUlong(Address));
    return ERROR_SUCCESS;                         // ignore if this subnet is not found in this sscope
}

//BeginExport(function)
DWORD
DhcpRegDelSubnetFromAllSScopes(
    IN      DWORD                  Address
) //EndExport(function)
{
    DWORD                          Error, Error2;
    ARRAY                          Array;
    REG_HANDLE                     Hdl, Hdl2;

    Error = MemArrayInit(&Array);
    Require(ERROR_SUCCESS == Error);

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetList(&Hdl, NULL, NULL, NULL, &Array, NULL, NULL);
    if( ERROR_SUCCESS == Error ) {
        Error = LoopThruArray(
            &Array, DhcpRegpDelSubnetFromSScope, &Hdl,
            ULongToPtr(Address));
    }

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    FreeArray(&Array);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSScopeSaveSubnet(
    IN      LPWSTR                 SScopeName,
    IN      DWORD                  Address
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSScopeHdl(&Hdl, SScopeName, &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegGetNextHdl(&Hdl2, ConvertAddressToLPWSTR(Address, AddressStr), &Hdl);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteSScope(
    IN      LPWSTR                 SScopeName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSScopeHdl(&Hdl, L"", &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRecurseDelete(&Hdl2, SScopeName );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveSubnet(
    IN      DWORD                  SubnetAddress,
    IN      DWORD                  SubnetMask,
    IN      DWORD                  SubnetState,
    IN      LPWSTR                 SubnetName,
    IN      LPWSTR                 SubnetComment
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;

    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(SubnetAddress, AddressStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetSetAttributes(
        &Hdl2,
        &SubnetName,
        &SubnetComment,
        &SubnetState,
        &SubnetAddress,
        &SubnetMask
    );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteSubnet(
    IN      PM_SUBNET               Subnet
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];
    LPWSTR                         KeyName;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;

    Error = Subnet->fSubnet ? DhcpRegServerGetSubnetHdl(&Hdl, L"" , &Hdl2)
                            : DhcpRegServerGetMScopeHdl(&Hdl, L"" , &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    KeyName = Subnet->fSubnet ? ConvertAddressToLPWSTR(Subnet->Address, AddressStr) : Subnet->Name;
    Error = DhcpRegRecurseDelete(&Hdl2, KeyName);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegAddRange(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      DWORD                  RangeEndAddress,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    IN      DWORD                  Type
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];
    LPWSTR                         KeyName;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegRangeSetAttributes(
        &Hdl,
        NULL,
        NULL,
        &Type,
        &BootpAllocated,
        &MaxBootpAllowed,
        &RangeStartAddress,
        &RangeEndAddress,
        NULL,
        0,
        NULL,
        0
    );

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require( ERROR_SUCCESS == Error2 );

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegAddRangeEx(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      DWORD                  RangeEndAddress,
    IN      DWORD                  Type,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    IN      LPBYTE                 InUseClusters,
    IN      DWORD                  InUseClustersSize,
    IN      LPBYTE                 UsedClusters,
    IN      DWORD                  UsedClustersSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetGetRangeHdl(&Hdl2, ConvertAddressToLPWSTR(RangeStartAddress, AddressStr), &Hdl);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRangeSetAttributes(
        &Hdl,
        NULL,
        NULL,
        &Type,
        &BootpAllocated,
        &MaxBootpAllowed,
        &RangeStartAddress,
        &RangeEndAddress,
        &InUseClusters,
        InUseClustersSize,
        &UsedClusters,
        UsedClustersSize
    );

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteRange(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetGetRangeHdl(&Hdl2, L"", &Hdl);
    Error2  = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRecurseDelete(&Hdl, ConvertAddressToLPWSTR(RangeStartAddress, AddressStr));
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteRangeEx(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClustersSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetGetRangeHdl(&Hdl2, ConvertAddressToLPWSTR(RangeStartAddress, AddressStr), &Hdl);
    Error2  = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRangeGetAttributes(
        &Hdl,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        InUseClusters,
        InUseClustersSize,
        UsedClusters,
        UsedClustersSize
    );
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;
    return DhcpRegDeleteRange(Subnet, RangeStartAddress);
}

//BeginExport(function)
DWORD
DhcpRegSaveExcl(
    IN      PM_SUBNET              Subnet,
    IN      LPBYTE                 ExclBytes,
    IN      DWORD                  nBytes
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetSetExclusions(
        &Hdl2,
        &ExclBytes,
        nBytes
    );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveBitMask(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      LPBYTE                 InUse,
    IN      DWORD                  InUseSize,
    IN      LPBYTE                 Used,
    IN      DWORD                  UsedSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetGetRangeHdl(&Hdl2, ConvertAddressToLPWSTR(RangeStartAddress, AddressStr), &Hdl);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRangeSetAttributes(
        &Hdl,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        &InUse,
        InUseSize,
        &Used,
        UsedSize
    );
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveMScope(
    IN      DWORD                  MScopeId,
    IN      DWORD                  SubnetState,
    IN      DWORD                  AddressPolicy,
    IN      DWORD                  TTL,
    IN      LPWSTR                 pMScopeName,
    IN      LPWSTR                 pMScopeComment,
    IN      LPWSTR                 LangTag,
    IN      PDATE_TIME              ExpiryTime
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Require( pMScopeName );

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;

    Error = DhcpRegServerGetMScopeHdl(&Hdl, pMScopeName, &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegMScopeSetAttributes(
        &Hdl2,
        &pMScopeComment,
        &SubnetState,
        &MScopeId,
        &AddressPolicy,
        &TTL,
        &LangTag,
        &ExpiryTime
    );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\regds.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================
//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\regsave.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

DWORD
DhcpRegSaveOptDef(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  OptType,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen
) ;


DWORD
DhcpRegDeleteOptDef(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD
DhcpRegSaveGlobalOption(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegDeleteGlobalOption(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD
DhcpRegSaveSubnetOption(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegDeleteSubnetOption(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD
DhcpRegSaveReservedOption(
    IN      DWORD                  Address,
    IN      DWORD                  ReservedAddress,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegDeleteReservedOption(
    IN      DWORD                  Address,
    IN      DWORD                  ReservedAddress,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD
DhcpRegSaveClassDef(
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  Flags,
    IN      LPBYTE                 Data,
    IN      DWORD                  DataLength
) ;


DWORD
DhcpRegDeleteClassDef(
    IN      LPWSTR                 Name
) ;


DWORD
DhcpRegSaveReservation(
    IN      DWORD                  Subnet,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDLength
) ;


DWORD
DhcpRegDeleteReservation(
    IN      DWORD                  Subnet,
    IN      DWORD                  Address
) ;


DWORD
DhcpRegSScopeDeleteSubnet(
    IN      LPWSTR                 SScopeName,
    IN      DWORD                  SubnetAddress
) ;


DWORD
DhcpRegDelSubnetFromAllSScopes(
    IN      DWORD                  Address
) ;


DWORD
DhcpRegSScopeSaveSubnet(
    IN      LPWSTR                 SScopeName,
    IN      DWORD                  Address
) ;


DWORD
DhcpRegDeleteSScope(
    IN      LPWSTR                 SScopeName
) ;


DWORD
DhcpRegSaveSubnet(
    IN      DWORD                  SubnetAddress,
    IN      DWORD                  SubnetMask,
    IN      DWORD                  SubnetState,
    IN      LPWSTR                 SubnetName,
    IN      LPWSTR                 SubnetComment
) ;


DWORD
DhcpRegDeleteSubnet(
    IN      PM_SUBNET               Subnet
) ;


DWORD
DhcpRegAddRange(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      DWORD                  RangeEndAddress,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    IN      DWORD                  Type
) ;


DWORD
DhcpRegAddRangeEx(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      DWORD                  RangeEndAddress,
    IN      DWORD                  Type,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    IN      LPBYTE                 InUseClusters,
    IN      DWORD                  InUseClustersSize,
    IN      LPBYTE                 UsedClusters,
    IN      DWORD                  UsedClustersSize
) ;


DWORD
DhcpRegDeleteRange(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress
) ;


DWORD
DhcpRegDeleteRangeEx(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClustersSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) ;


DWORD
DhcpRegSaveExcl(
    IN      PM_SUBNET              Subnet,
    IN      LPBYTE                 ExclBytes,
    IN      DWORD                  nBytes
) ;


DWORD
DhcpRegSaveBitMask(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      LPBYTE                 InUse,
    IN      DWORD                  InUseSize,
    IN      LPBYTE                 Used,
    IN      DWORD                  UsedSize
) ;


DWORD
DhcpRegSaveMScope(
    IN      DWORD                  MScopeId,
    IN      DWORD                  SubnetState,
    IN      DWORD                  AddressPolicy,
    IN      DWORD                  TTL,
    IN      LPWSTR                 pMScopeName,
    IN      LPWSTR                 pMScopeComment,
    IN      LPWSTR                 LangTag,
    IN      PDATE_TIME              ExpiryTime
) ;

//========================================================================
//  end of file
//========================================================================
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

#define     FLUSH_MODIFIED_DIRTY   0
#define     FLUSH_MODIFIED         1
#define     FLUSH_ANYWAY           2


DWORD
FlushRanges(
    IN      PM_RANGE               Range,
    IN      DWORD                  FlushNow,
    IN      PM_SUBNET              Subnet
) ;


DWORD
DhcpRegServerFlush(
    IN      PM_SERVER              Server,
    IN      DWORD                  FlushNow
) ;


DWORD
DhcpRegFlushServer(
    IN      DWORD                  FlushNow
) ;


DWORD
DhcpRegServerSave(
    IN      PM_SERVER              Server
) ;

DWORD
DhcpMigrateMScopes(
    IN LPCWSTR OldMscopeName,
    IN LPCWSTR NewMscopeName, 
    IN DWORD (*SaveOrRestoreRoutine)(
        IN HKEY Key, IN LPWSTR ConfigName, IN BOOL fRestore
        )
    ) ;

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\test.c ===
//
//  Copyright (C) 1998 Microsoft Corporation
//

#define  UNICODE

#include    <mm\mm.h>
#include    <mm\array.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <winsock2.h>
#include    <stdlib.h>

#include <regutil.h>
#include <regread.h>
#include <regsave.h>
#include <stdio.h>

CRITICAL_SECTION                   DhcpGlobalInProgressCritSect;

PM_SERVER
DhcpGetCurrentServer(
    VOID
)
{
    return NULL;
}

void _cdecl main(void) {
    DWORD                          RetVal;
    PM_SERVER                      ThisServer;

    RetVal = DhcpRegReadThisServer(&ThisServer);
    if( ERROR_SUCCESS != RetVal ) {
        printf("DhcpRegReadThisServer: %ld 0x%lx\n", RetVal, RetVal);
    }

    InitializeCriticalSection(&DhcpGlobalInProgressCritSect);
    DhcpRegServerFlush(ThisServer, TRUE);
    DeleteCriticalSection(&DhcpGlobalInProgressCritSect);
    MemServerFree(ThisServer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\regutil.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: simple registry utilities
//================================================================================

#include <mmregpch.h>

//BeginExport(typedef)
typedef struct _REG_HANDLE {
    HKEY                           Key;
    HKEY                           SubKey;
    LPWSTR                         SubKeyLocation;
} REG_HANDLE, *PREG_HANDLE, *LPREG_HANDLE;
//EndExport(typedef)

//BeginExport(constants)
#define     REG_THIS_SERVER                       L"Software\\Microsoft\\DHCPServer\\Configuration"
#define     REG_THIS_SERVER_DS                    L"Software\\Microsoft\\DHCPServer\\Config_DS"
#define     REG_THIS_SERVER_DS_VALUE              L"Config_DS"
#define     REG_THIS_SERVER_DS_PARENT             L"Software\\Microsoft\\DHCPServer"

#define     REG_SERVER_GLOBAL_OPTIONS             L"GlobalOptionValues"
#define     REG_SERVER_OPTDEFS                    L"OptionInfo"
#define     REG_SERVER_SUBNETS                    L"Subnets"
#define     REG_SERVER_SSCOPES                    L"SuperScope"
#define     REG_SERVER_CLASSDEFS                  L"ClassDefs"
#define     REG_SERVER_MSCOPES                    L"MulticastScopes"

#define     REG_SUBNET_SERVERS                    L"DHCPServers"
#define     REG_SUBNET_RANGES                     L"IpRanges"
#define     REG_SUBNET_RESERVATIONS               L"ReservedIps"
#define     REG_SUBNET_OPTIONS                    L"SubnetOptions"

#define     REG_SUBNET_EXCL                       L"ExcludedIpRanges"
#define     REG_SUBNET_ADDRESS                    L"SubnetAddress"
#define     REG_SUBNET_NAME                       L"SubnetName"
#define     REG_SUBNET_COMMENT                    L"SubnetComment"
#define     REG_SUBNET_MASK                       L"SubnetMask"
#define     REG_SUBNET_STATE                      L"SubnetState"
#define     REG_SUBNET_SWITCHED_FLAG              L"SwitchedNetworkFlag"

#define     REG_MSCOPE_NAME                       L"MScopeName"
#define     REG_MSCOPE_COMMENT                    L"MScopeComment"
//
// Win2K Beta2 and Beta3 went out with scope id param value MScopeId.
// Since their meaning is being changed, to avoid any costly upgrade
// code, this value is being changed to MScopeIdValue: to automatically
// chose a good scope id, TTL values.  Note that the default value of 
// zero is treated specially for this scope id param. It implies that
// this was probably a pre-RC1 upgrade.  In this case, the Scope ID
// defaults to first value in the range.
//
#define     REG_MSCOPE_SCOPEID                    L"MScopeIdValue"
#define     REG_MSCOPE_STATE                      L"MScopeState"
#define     REG_MSCOPE_ADDR_POLICY                L"MScopeAddressPolicy"
#define     REG_MSCOPE_TTL                        L"MScopeTTL"
#define     REG_MSCOPE_LANG_TAG                   L"MScopeLangTag"
#define     REG_MSCOPE_EXPIRY_TIME                L"MScopeExpiryTime"

#define     REG_SUB_SERVER_NAME                   L"ServerHostName"
#define     REG_SUB_SERVER_COMMENT                L"ServerComment"
#define     REG_SUB_SERVER_ADDRESS                L"ServerAddress"
#define     REG_SUB_SERVER_ROLE                   L"Role"

#define     REG_RANGE_NAME                        L"RangeName"
#define     REG_RANGE_COMMENT                     L"RangeComment"
#define     REG_RANGE_START_ADDRESS               L"StartAddress"
#define     REG_RANGE_END_ADDRESS                 L"EndAddress"
#define     REG_RANGE_INUSE_CLUSTERS              L"InUseClusters"
#define     REG_RANGE_USED_CLUSTERS               L"UsedClusters"
#define     REG_RANGE_BITS_PREFIX                 L"Bits "
#define     REG_RANGE_BITS_PREFIX_WCHAR_COUNT     (5)
#define     REG_RANGE_FLAGS                       L"RangeFlags"
#define     REG_RANGE_ALLOC                       L"RangeBootpAllocated"
#define     REG_RANGE_MAX_ALLOC                   L"RangeBootpMaxAllowed"

#define     REG_OPTION_NAME                       L"OptionName"
#define     REG_OPTION_COMMENT                    L"OptionComment"
#define     REG_OPTION_TYPE                       L"OptionType"
#define     REG_OPTION_VALUE                      L"OptionValue"
#define     REG_OPTION_ID                         L"OptionId"
#define     REG_OPTION_CLASSNAME                  L"OptionClassName"
#define     REG_OPTION_VENDORNAME                 L"OptionVendorName"

#define     REG_CLASSDEF_NAME                     L"ClassName"
#define     REG_CLASSDEF_COMMENT                  L"ClassComment"
#define     REG_CLASSDEF_TYPE                     L"ClassType"
#define     REG_CLASSDEF_VALUE                    L"ClassValue"

#define     REG_RESERVATION_ADDRESS               L"IpAddress"
#define     REG_RESERVATION_UID                   L"ClientUID"
#define     REG_RESERVATION_TYPE                  L"AllowedClientTypes"
#define     REG_RESERVATION_NAME                  L"ReservationName"
#define     REG_RESERVATION_COMMENT               L"ReservationComment"

#define     REG_FLAGS                             L"Flags"

#define     REG_ACCESS                            KEY_ALL_ACCESS
#define     REG_DEFAULT_SUBNET_STATE              0
#define     REG_DEFAULT_SUBNET_MASK               0xFFFFFFFF
#define     REG_DEFAULT_SWITCHED_FLAG             FALSE

#define     REG_CLASS                             L"DhcpClass"

#define DHCP_LAST_DOWNLOAD_TIME_VALUE             L"LastDownloadTime"
#define DHCP_LAST_DOWNLOAD_TIME_TYPE              REG_BINARY

#define     DEF_RANGE_ALLOC                       0
#define     DEF_RANGE_MAX_ALLOC                   (~(ULONG)0)

//EndExport(constants)

const       DWORD                                 ZeroReserved = 0;
const       LPVOID                                NullReserved = 0;
#define     MAX_KEY_SIZE                          512
#define     DEF_RANGE_FLAG_VAL                    (MM_FLAG_ALLOW_DHCP)
#define     DEF_RESERVATION_TYPE                  (MM_FLAG_ALLOW_DHCP|MM_FLAG_ALLOW_BOOTP)

//BeginExport(comment)
//================================================================================
//  The basic open/traverse/close functions are here
//================================================================================
//EndExport(comment)
HKEY        CurrentServerKey  = NULL;

//BeginExport(function)
DWORD
DhcpRegSetCurrentServer(
    IN OUT  PREG_HANDLE            Hdl
) //EndExport(function)
{
    CurrentServerKey = Hdl? Hdl->Key : NULL;
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegGetThisServer(
    IN OUT  PREG_HANDLE            Hdl
) //EndExport(function)
{
    DWORD                          Disposition;

    if( NULL != CurrentServerKey ) {
        return RegOpenKeyEx(                      // duplicate key
            CurrentServerKey,
            NULL,
            ZeroReserved,
            REG_ACCESS,
            &Hdl->Key
        );
    }
    return RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REG_THIS_SERVER,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &Hdl->Key,
        &Disposition
    );
}

//BeginExport(function)
DWORD
DhcpRegGetNextHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 NextLoc,
    OUT     PREG_HANDLE            OutHdl
) //EndExport(function)
{
    DWORD                          Disposition;
    DWORD                          Error;

    Error = RegCreateKeyEx(
        Hdl->Key,
        NextLoc,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &OutHdl->Key,
        &Disposition
    );
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegCloseHdl(
    IN OUT  PREG_HANDLE            Hdl
) //EndExport(function)
{
    DWORD                          Error;

    Error = RegCloseKey(Hdl->Key);
    Hdl->Key = NULL;
    return Error;
}

//BeginExport(comment)
//================================================================================
//   MISC utilities for registry manipulation
//================================================================================
//EndExport(comment)
//BeginExport(function)
DWORD
DhcpRegFillSubKeys(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array          // fill in a list of key names
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Index;
    DWORD                          Size;
    WCHAR                          KeyName[MAX_KEY_SIZE];
    LPWSTR                         ThisKeyName;

    Index = 0;
    do {
        Size = sizeof(KeyName)/sizeof(KeyName[0]);
        Error = RegEnumKeyEx(
            Hdl->Key,
            Index++,
            KeyName,
            &Size,
            NullReserved,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_NO_MORE_ITEMS == Error ) {
            Error = ERROR_SUCCESS;
            break;
        }
        if( ERROR_SUCCESS != Error ) break;
        Require(0 != Size);
        Size += 1;                                // for the terminating L'\0' char
        Size *= sizeof(WCHAR);                    // looks like the units are WCHAR!!

        ThisKeyName = MemAlloc(Size);
        if( NULL == ThisKeyName ) return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy(ThisKeyName, KeyName);

        Error = MemArrayAddElement(Array, (LPVOID)ThisKeyName);
        if( ERROR_SUCCESS != Error ) {
            MemFree(ThisKeyName);
        }
    } while( ERROR_SUCCESS == Error );

    Require(ERROR_MORE_DATA != Error);
    return Index? ERROR_SUCCESS : Error;          // if we added something, dont bother about reporting error
}

//BeginExport(function)
LPVOID                                            // DWORD or LPWSTR or LPBYTE
DhcpRegRead(                                      // read differnt values from registry and allocate if not DWORD
    IN      PREG_HANDLE            Hdl,
    IN      DWORD                  Type,          // if DWORD dont allocate memory
    IN      LPWSTR                 ValueName,
    IN      LPVOID                 RetValue       // value to use if nothing found
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    DWORD                          Dword;
    LPVOID                         Ret;

    if( REG_DWORD == Type ) {
        Size = sizeof(DWORD);
        Ret = (LPVOID)&Dword;
    } else {
        Size = 0;
        Error = RegQueryValueEx(
            Hdl->Key,
            ValueName,
            NullReserved,
            NULL,
            NULL,
            &Size
        );
        if( ERROR_SUCCESS != Error ) return RetValue;
        if (Size == 0) return RetValue;           // MemAlloc does not check the size!
        Ret = MemAlloc(Size);
        if( NULL == Ret ) return RetValue;        // should not really happen
    }

    Error = RegQueryValueEx(
        Hdl->Key,
        ValueName,
        NullReserved,
        NULL,
        Ret,
        &Size
    );
    if( ERROR_SUCCESS != Error && Ret != (LPVOID)&Dword ) {
        MemFree(Ret);
        Ret = NULL;
    }

    if( ERROR_SUCCESS != Error) return RetValue;

    if( Ret == (LPVOID)&Dword ) {
        return ULongToPtr(Dword);
    } else {
        return Ret;
    }
}

//BeginExport(function)
DWORD
DhcpRegReadBinary(                                // read binary type
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ValueName,
    OUT     LPBYTE                *RetVal,
    OUT     DWORD                 *RetValSize
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    LPVOID                         Ret;

    *RetVal = NULL;
    *RetValSize = 0;

    Size = 0;
    Error = RegQueryValueEx(
        Hdl->Key,
        ValueName,
        NullReserved,
        NULL,
        NULL,
        &Size
    );
    if( ERROR_SUCCESS != Error ) return Error;
    if( 0 == Size ) return ERROR_SUCCESS;
    Ret = MemAlloc(Size);
    if( NULL == Ret ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = RegQueryValueEx(
        Hdl->Key,
        ValueName,
        NullReserved,
        NULL,
        Ret,
        &Size
    );
    if( ERROR_SUCCESS != Error ) {
        MemFree(Ret);
        return Error;
    }

    *RetVal = Ret;
    *RetValSize = Size;
    return ERROR_SUCCESS;
}

//BeginExport(function)
LPWSTR
DhcpRegCombineClassAndOption(                     // create string based on class name and option id
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptionId
) //EndExport(function)
{
    DWORD                          Size;
    LPWSTR                         Ptr;

    if( NULL == VendorName && NULL == ClassName ) {

        //
        // Special case usual options for downward compatability with older
        // options.. (NT4 options in registry don't have any "!" in them.
        //

        Ptr = MemAlloc( 4 * sizeof(WCHAR) );
        if( NULL == Ptr ) return NULL;
        Ptr [2] = L'0' + (BYTE)(OptionId %10); OptionId /= 10;
        Ptr [1] = L'0' + (BYTE)(OptionId %10); OptionId /= 10;
        Ptr [0] = L'0' + (BYTE)(OptionId %10);
        Ptr [3] = L'\0';
        return Ptr;
    }

    if( NULL == VendorName ) VendorName = L"";
    if( NULL == ClassName ) ClassName = L"";
    Size = (wcslen(ClassName) + 1 + 5)*sizeof(WCHAR);
    Size += wcslen(VendorName)*sizeof(WCHAR);

    Ptr = MemAlloc(Size);
    if( NULL == Ptr ) return NULL;

    Size = 0;

    Ptr[2+Size] = L'0' + (BYTE)(OptionId % 10); OptionId /= 10;
    Ptr[1+Size] = L'0' + (BYTE)(OptionId % 10); OptionId /= 10;
    Ptr[0+Size] = L'0' + (BYTE)(OptionId % 10);
    Ptr[3+Size] = L'\0';
    wcscat(Ptr, L"!");
    wcscat(Ptr, VendorName);
    wcscat(Ptr, L"!");
    wcscat(Ptr, ClassName);
    return Ptr;
}

//BeginExport(function)
LPWSTR
ConvertAddressToLPWSTR(
    IN      DWORD                  Address,
    IN OUT  LPWSTR                 BufferStr      // input buffer to fill with dotted notation
) //EndExport(function)
{
    LPSTR                          AddressStr;
    DWORD                          Count;

    Address = ntohl(Address);
    AddressStr = inet_ntoa(*(struct in_addr *)&Address);
    Count = mbstowcs(BufferStr, AddressStr, sizeof("000.000.000.000"));
    if( -1 == Count ) return NULL;
    return BufferStr;
}

//BeginExport(comment)
//================================================================================
//  the following functions help traversing the registry
//================================================================================
//EndExport(comment)

DWORD
DhcpRegGetNextNextHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Loc1,
    IN      LPWSTR                 Loc2,
    OUT     PREG_HANDLE            Hdl2
)
{
    WCHAR                          Loc[MAX_KEY_SIZE*2];
    Loc[ 0 ] = L'\0';

    if ( ( wcslen(Loc1) + wcslen(Loc2) + 1 ) < ( MAX_KEY_SIZE * 2 ) )
    {
        wcscpy(Loc,Loc1);
        wcscat(Loc, L"\\");
        wcscat(Loc,Loc2);
    }

    return DhcpRegGetNextHdl(Hdl, Loc, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetSubnetHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Subnet,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_SUBNETS, Subnet, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetSScopeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 SScope,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_SSCOPES, SScope, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetOptDefHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptDef,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_OPTDEFS, OptDef, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Opt,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_GLOBAL_OPTIONS, Opt, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetMScopeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 MScope,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_MSCOPES, MScope, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetClassDefHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ClassDef,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_CLASSDEFS, ClassDef, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Opt,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SUBNET_OPTIONS, Opt, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetRangeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Range,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SUBNET_RANGES, Range, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetReservationHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Reservation,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SUBNET_RESERVATIONS, Reservation, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetServerHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Server,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SUBNET_SERVERS, Server, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegReservationGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextHdl(Hdl, OptionName, Hdl2);
}

//BeginExport(comment)
//================================================================================
//   List retrieval functions.. for servers, subnets, ranges etc.
//================================================================================
//EndExport(comment)

//BeginExport(function)
DWORD
DhcpRegServerGetList(
    IN      PREG_HANDLE            Hdl,           // ptr to server location
    IN OUT  PARRAY                 OptList,       // list of LPWSTR options
    IN OUT  PARRAY                 OptDefList,    // list of LPWSTR optdefs
    IN OUT  PARRAY                 Subnets,       // list of LPWSTR subnets
    IN OUT  PARRAY                 SScopes,       // list of LPWSTR sscopes
    IN OUT  PARRAY                 ClassDefs,     // list of LPWSTR classes
    IN OUT  PARRAY                 MScopes        // list of LPWSTR mscopes
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Index;
    REG_HANDLE                     Hdl2;
    struct {
        PARRAY                     Array;
        LPWSTR                     Location;
    } Table[] = {
        OptList,                   REG_SERVER_GLOBAL_OPTIONS,
        OptDefList,                REG_SERVER_OPTDEFS,
        Subnets,                   REG_SERVER_SUBNETS,
        SScopes,                   REG_SERVER_SSCOPES,
        ClassDefs,                 REG_SERVER_CLASSDEFS,
        MScopes,                   REG_SERVER_MSCOPES
    };
   
    Error = ERROR_SUCCESS;

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]); Index ++ ) {
        if( NULL == Table[Index].Array ) continue;

        Error = DhcpRegGetNextHdl(Hdl, Table[Index].Location, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegFillSubKeys(&Hdl2, Table[Index].Array);
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetExclusions(
    IN      PREG_HANDLE            Hdl,
    OUT     LPBYTE                *Excl,
    OUT     DWORD                 *ExclSize
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    DWORD                          Type;

    if( NULL == Excl ) return ERROR_SUCCESS;

    Size = 0;
    Error = RegQueryValueEx(
        Hdl->Key,
        REG_SUBNET_EXCL,
        NullReserved,
        &Type,
        NULL,
        &Size
    );
    if( ERROR_SUCCESS != Error ) return Error;

    *Excl = NULL;
    *ExclSize = 0;
    if( 0 == Size ) return ERROR_SUCCESS;

    *Excl = MemAlloc(Size);
    if( NULL == *Excl ) return ERROR_NOT_ENOUGH_MEMORY;
    *ExclSize = Size;
    Error = RegQueryValueEx(
        Hdl->Key,
        REG_SUBNET_EXCL,
        NullReserved,
        &Type,
        *Excl,
        ExclSize
    );
    if( ERROR_SUCCESS != Error ) {
        MemFree(*Excl);
        *Excl = NULL;
    }
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Servers,
    IN OUT  PARRAY                 IpRanges,
    IN OUT  PARRAY                 Reservations,
    IN OUT  PARRAY                 Options,
    OUT     LPBYTE                *Excl,
    OUT     DWORD                 *ExclSizeInBytes
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Index;
    REG_HANDLE                     Hdl2;
    struct {
        PARRAY                     Array;
        LPWSTR                     Location;
    } Table[] = {
        Servers,                   REG_SUBNET_SERVERS,
        IpRanges,                  REG_SUBNET_RANGES,
        Reservations,              REG_SUBNET_RESERVATIONS,
        Options,                   REG_SUBNET_OPTIONS,
        // Exclusions are to be handled a bit differently
    };

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]); Index ++ ) {
        if( NULL == Table[Index].Array ) continue;

        Error = DhcpRegGetNextHdl(Hdl, Table[Index].Location, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegFillSubKeys(&Hdl2, Table[Index].Array);
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    // Now read the exclusions from off here
    return DhcpRegSubnetGetExclusions(Hdl, Excl, ExclSizeInBytes );
}

//BeginExport(function)
DWORD
DhcpRegSScopeGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Subnets
) //EndExport(function)
{
    return DhcpRegFillSubKeys(Hdl, Subnets);
}

//BeginExport(function)
DWORD
DhcpRegReservationGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Options
) //EndExport(function)
{
    return DhcpRegFillSubKeys(Hdl, Options);
}

//BeginExport(comment)
//================================================================================
//  the separate stuff are here -- these are not list stuff, but just simple
//  single valued attributes
//  some of these actually, dont even go to the registry, but that's fine alright?
//================================================================================
//EndExport(comment)

//BeginExport(function)
DWORD
DhcpRegServerGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags
    // more attributes will come here soon?
) //EndExport(function)
{
    if( Name ) *Name = NULL;
    if( Comment ) *Comment = NULL;
    if( Flags ) *Flags = 0;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     DWORD                 *Mask
) //EndExport(function)
{
    DWORD                          fSwitched;

    if( Name )  *Name = DhcpRegRead(Hdl, REG_SZ, REG_SUBNET_NAME, NULL);
    if( Comment ) *Comment = DhcpRegRead(Hdl, REG_SZ, REG_SUBNET_COMMENT, NULL);
    if( Flags ) {
        *Flags = PtrToUlong(DhcpRegRead(Hdl, REG_DWORD, REG_SUBNET_STATE, (LPVOID)REG_DEFAULT_SUBNET_STATE));
        fSwitched = PtrToUlong(DhcpRegRead(Hdl, REG_DWORD, REG_SUBNET_SWITCHED_FLAG, (LPVOID)REG_DEFAULT_SWITCHED_FLAG));
        if(fSwitched) SWITCHED(( DHCP_SUBNET_STATE * ) Flags);
    }
    if( Address )
        *Address = PtrToUlong(DhcpRegRead(Hdl, REG_DWORD, REG_SUBNET_ADDRESS, (LPVOID)0));
    if( Mask ) *Mask = PtrToUlong(DhcpRegRead(Hdl, REG_DWORD, REG_SUBNET_MASK, ULongToPtr(REG_DEFAULT_SUBNET_MASK)));

    return ERROR_SUCCESS;
}

typedef struct {
    LPVOID                     RetPtr;
    LPWSTR                     ValueName;
    DWORD                      ValueType;
    LPVOID                     Defaults;
} ATTRIB_TBL, *PATTRIB_TBL, *LPATTRIB_TBL;

VOID
DhcpRegFillAttribTable(
    IN      PREG_HANDLE            Hdl,
    IN      PATTRIB_TBL            Table,
    IN      DWORD                  TableSize
) {
    DWORD                          i;
    PVOID                          Tmp;
    
    for( i = 0; i < TableSize ; i ++ ) {
        if( NULL == Table[i].RetPtr) continue;
        Tmp = DhcpRegRead(
            Hdl,
            Table[i].ValueType,
            Table[i].ValueName,
            Table[i].Defaults
        );
        if( REG_DWORD == Table[i].ValueType ) {
            *((DWORD *)Table[i].RetPtr) = PtrToUlong(Tmp);
        } else {
            *((LPVOID *)Table[i].RetPtr) = Tmp;
        }
    }
}

//
// Hack O Rama -- This routine returns ERROR_INVALID_DATA if 
// the registry has been upgraded from pre-win2k build to win2k.
// So that defaults can be chosen for ScopeId etc.
//
//BeginExport(function)
DWORD
DhcpRegMScopeGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Comments,
    OUT     DWORD                 *State,
    OUT     DWORD                 *ScopeId,
    OUT     DWORD                 *Policy,
    OUT     DWORD                 *TTL,
    OUT     LPWSTR                *LangTag,
    OUT     PDATE_TIME            *ExpiryTime
) //EndExport(function)
{
    DATE_TIME                      DefaultExpiryTime = {DHCP_DATE_TIME_INFINIT_LOW, DHCP_DATE_TIME_INFINIT_HIGH};
    LPWSTR                         DefaultLangTag = L"en-US";

    ATTRIB_TBL                     Table[] = {
        Comments,                  REG_MSCOPE_COMMENT,          REG_SZ,        NULL,
        State,                     REG_MSCOPE_STATE,            REG_DWORD,     (LPVOID)0,
        ScopeId,                   REG_MSCOPE_SCOPEID,          REG_DWORD,     (LPVOID)0,
        Policy,                    REG_MSCOPE_ADDR_POLICY,      REG_DWORD,     (LPVOID)0,
        TTL,                       REG_MSCOPE_TTL,              REG_DWORD,     (LPVOID)DEFAULT_MCAST_TTL,
        LangTag,                   REG_MSCOPE_LANG_TAG,         REG_SZ,        (LPVOID)0,
        ExpiryTime,                REG_MSCOPE_EXPIRY_TIME,      REG_BINARY,    (LPVOID)0
    };
    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if (*LangTag == 0) {
        *LangTag = MemAlloc(wcslen((DefaultLangTag)+1)*sizeof(WCHAR));
        if (*LangTag) {
            wcscpy(*LangTag, DefaultLangTag);
        } else {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if (*ExpiryTime == 0) {
        *ExpiryTime = MemAlloc(sizeof (DefaultExpiryTime));
        if (*ExpiryTime) {
            **ExpiryTime = DefaultExpiryTime;
        } else {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegOptDefGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comments,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *OptionId,
    OUT     LPWSTR                *ClassName,
    OUT     LPWSTR                *VendorName,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_OPTION_NAME,       REG_SZ,         NULL,
        Comments,                  REG_OPTION_COMMENT,    REG_SZ,         NULL,
        ClassName,                 REG_OPTION_CLASSNAME,  REG_SZ,         NULL,
        VendorName,                REG_OPTION_VENDORNAME, REG_SZ,         NULL,
        Flags,                     REG_OPTION_TYPE,       REG_DWORD,      (LPVOID)0,
        OptionId,                  REG_OPTION_ID,         REG_DWORD,      (LPVOID)0
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( Value ) {
        Error = DhcpRegReadBinary(Hdl, REG_OPTION_VALUE, Value, ValueSize);
        Require(*Value);
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegSScopeGetAttributes(                       // superscopes dont have any information stored.. dont use this
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags
) //EndExport(function)
{
    Require(FALSE);
    return ERROR_INVALID_PARAMETER;
}

//BeginExport(function)
DWORD
DhcpRegClassDefGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_CLASSDEF_NAME,     REG_SZ,       NULL,
        Comment,                   REG_CLASSDEF_COMMENT,  REG_SZ,       NULL,
        Flags,                     REG_CLASSDEF_TYPE,     REG_DWORD,    (LPVOID)0
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( Value ) {
        Error = DhcpRegReadBinary(Hdl, REG_CLASSDEF_VALUE, Value, ValueSize);
        Require(*Value);
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegSubnetServerGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     DWORD                 *Role
) //EndExport(function)
{
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_SUB_SERVER_NAME,   REG_SZ,       NULL,
        Comment,                   REG_SUB_SERVER_COMMENT,REG_SZ,       NULL,
        Flags,                     REG_FLAGS,             REG_DWORD,    (LPVOID)0,
        Address,                   REG_SUB_SERVER_ADDRESS,REG_DWORD,    (LPVOID)0,
        Role,                      REG_SUB_SERVER_ROLE,   REG_DWORD,    (LPVOID)0
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegRangeGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     ULONG                 *AllocCount,
    OUT     ULONG                 *MaxAllocCount,
    OUT     DWORD                 *StartAddress,
    OUT     DWORD                 *EndAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClusterSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) //EndExport(function)
{
    DWORD                          Error;
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_RANGE_NAME,        REG_SZ,       NULL,
        Comment,                   REG_RANGE_COMMENT,     REG_SZ,       NULL,
        Flags,                     REG_RANGE_FLAGS,       REG_DWORD,    (LPVOID)(DEF_RANGE_FLAG_VAL),
        AllocCount,                REG_RANGE_ALLOC,       REG_DWORD,    (LPVOID)(DEF_RANGE_ALLOC),
        MaxAllocCount,             REG_RANGE_MAX_ALLOC,   REG_DWORD,    (LPVOID)(ULONG_PTR)(DEF_RANGE_MAX_ALLOC),
        StartAddress,              REG_RANGE_START_ADDRESS, REG_DWORD,  (LPVOID)0,
        EndAddress,                REG_RANGE_END_ADDRESS, REG_DWORD,    (LPVOID)0
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( InUseClusters ) {
        Error = DhcpRegReadBinary(Hdl, REG_RANGE_INUSE_CLUSTERS, InUseClusters, InUseClusterSize);
        //Require(ERROR_SUCCESS == Error); //-- after registry changed, NO_SUCH_FILE could come up here as well.
    }
    if( UsedClusters ) {
        Error = DhcpRegReadBinary(Hdl, REG_RANGE_USED_CLUSTERS, UsedClusters, UsedClustersSize);
        //Require(ERROR_SUCCESS == Error); //-- after registry changed, NO_SUCH_FILE could come up here as well.
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegReservationGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     LPBYTE                *ClientUID,
    OUT     DWORD                 *ClientUIDSize
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          deftype = DEF_RESERVATION_TYPE;
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_RESERVATION_NAME,  REG_SZ,       NULL,
        Comment,                   REG_RESERVATION_COMMENT, REG_SZ,     NULL,
        Flags,                     REG_RESERVATION_TYPE,  REG_DWORD,    ULongToPtr(deftype),
        Address,                   REG_RESERVATION_ADDRESS, REG_DWORD,  (LPVOID)0,
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( ClientUID ) {
        Error = DhcpRegReadBinary(Hdl, REG_RESERVATION_UID, ClientUID, ClientUIDSize);
        Require(ERROR_SUCCESS == Error);
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegOptGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     DWORD                 *OptionId,
    OUT     LPWSTR                *ClassName,
    OUT     LPWSTR                *VendorName,
    OUT     DWORD                 *Flags,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    ATTRIB_TBL                     Table[] = {
        OptionId,                  REG_OPTION_ID,         REG_DWORD,    (LPVOID)0,
        ClassName,                 REG_OPTION_CLASSNAME,  REG_SZ,       NULL,
        VendorName,                REG_OPTION_VENDORNAME, REG_SZ,       NULL,
        Flags,                     REG_OPTION_TYPE,       REG_DWORD,    (LPVOID)0,
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( Value ) {
        Error = DhcpRegReadBinary(Hdl, REG_OPTION_VALUE, Value, ValueSize);
    }
    return ERROR_SUCCESS;
}

//BeginExport(comment)
//================================================================================
//  the following functiosn help in writing to the registry
//================================================================================
//EndExport(comment)

typedef struct {
    LPVOID                         Value;
    DWORD                          Size;
    DWORD                          Type;
    LPWSTR                         ValueName;
} WATTRIB_TBL, *PWATTRIB_TBL, *LPWATTRIB_TBL;

DWORD
DhcpRegSaveAttribTable(
    IN      PREG_HANDLE            Hdl,
    IN      PWATTRIB_TBL           Table,
    IN      DWORD                  Size
)
{
    DWORD                          i;
    DWORD                          Error;
    DWORD                          PtrSize;
    LPBYTE                         Ptr;

    for(i = 0; i < Size; i ++ ) {
        if( NULL == Table[i].Value ) continue;
        PtrSize = Table[i].Size;
        Ptr = *(LPBYTE *)Table[i].Value;
        switch(Table[i].Type) {
        case REG_SZ:
            if( NULL == *(LPWSTR *)Table[i].Value) { PtrSize = sizeof(WCHAR); Ptr = (LPBYTE)L""; break; }
            PtrSize = sizeof(WCHAR)*(wcslen(*((LPWSTR *)Table[i].Value))+1);
            Ptr = *(LPBYTE *)Table[i].Value;
            break;
        case REG_DWORD:
            PtrSize = sizeof(DWORD);
            Ptr =  Table[i].Value;                // This is because we deref this ptr down below..
            break;
        }

        Error = RegSetValueEx(
            Hdl->Key,
            Table[i].ValueName,
            ZeroReserved,
            Table[i].Type,
            Ptr,
            PtrSize
        );
        if( ERROR_SUCCESS != Error ) {
            return Error;
        }
    }
    return ERROR_SUCCESS;
}

//BeginExport(functions)
DWORD
DhcpRegSaveSubKeys(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    REG_HANDLE                     Hdl2;
    LPWSTR                         KeyName;

    Error = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, (LPVOID *)&KeyName);
        Require(ERROR_SUCCESS == Error && NULL != KeyName);

        Error = DhcpRegGetNextHdl(Hdl, KeyName, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayNextLoc(Array, &Loc);
    }
    return ERROR_SUCCESS;
}

//BeginExport(functions)
DWORD
DhcpRegSaveSubKeysPrefixed(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array,
    IN      LPWSTR                 CommonPrefix
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    REG_HANDLE                     Hdl2;
    LPWSTR                         KeyName;

    Error = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, (LPVOID *)&KeyName);
        Require(ERROR_SUCCESS == Error && NULL != KeyName);

        Error = DhcpRegGetNextNextHdl(Hdl, CommonPrefix, KeyName, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayNextLoc(Array, &Loc);
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegServerSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 OptList,       // list of LPWSTR options
    IN      PARRAY                 OptDefList,    // list of LPWSTR optdefs
    IN      PARRAY                 Subnets,       // list of LPWSTR subnets
    IN      PARRAY                 SScopes,       // list of LPWSTR sscopes
    IN      PARRAY                 ClassDefs,     // list of LPWSTR classes
    IN      PARRAY                 MScopes        // list of LPWSTR mscopes
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Index;
    REG_HANDLE                     Hdl2;
    struct {
        PARRAY                     Array;
        LPWSTR                     Location;
    } Table[] = {
        OptList,                   REG_SERVER_GLOBAL_OPTIONS,
        OptDefList,                REG_SERVER_OPTDEFS,
        Subnets,                   REG_SERVER_SUBNETS,
        SScopes,                   REG_SERVER_SSCOPES,
        ClassDefs,                 REG_SERVER_CLASSDEFS,
        MScopes,                   REG_SERVER_MSCOPES
    };

    Error = ERROR_SUCCESS;

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]); Index ++ ) {
        if( NULL == Table[Index].Array ) continue;

        Error = DhcpRegGetNextHdl(Hdl, Table[Index].Location, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegSaveSubKeys(&Hdl2, Table[Index].Array);
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSubnetSetExclusions(
    IN      PREG_HANDLE            Hdl,
    IN      LPBYTE                *Excl,
    IN      DWORD                  ExclSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        (LPVOID*)Excl,  ExclSize, REG_BINARY, REG_SUBNET_EXCL,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegSubnetSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 Servers,
    IN      PARRAY                 IpRanges,
    IN      PARRAY                 Reservations,
    IN      PARRAY                 Options,
    IN      LPBYTE                *Excl,
    IN      DWORD                  ExclSizeInBytes
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Index;
    REG_HANDLE                     Hdl2;
    struct {
        PARRAY                     Array;
        LPWSTR                     Location;
    } Table[] = {
        Servers,                   REG_SUBNET_SERVERS,
        IpRanges,                  REG_SUBNET_RANGES,
        Reservations,              REG_SUBNET_RESERVATIONS,
        Options,                   REG_SUBNET_OPTIONS,
        // Exclusions are to be handled a bit differently
    };

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]); Index ++ ) {
        if( NULL == Table[Index].Array ) continue;

        Error = DhcpRegGetNextHdl(Hdl, Table[Index].Location, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegSaveSubKeys(&Hdl2, Table[Index].Array);
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    // Now read the exclusions from off here
    return DhcpRegSubnetSetExclusions(Hdl, Excl, ExclSizeInBytes );
}

//BeginExport(function)
DWORD
DhcpRegSScopeSetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Subnets
) //EndExport(function)
{
    return DhcpRegSaveSubKeys(Hdl, Subnets);
}

//BeginExport(function)
DWORD
DhcpRegReservationSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 Subnets
) //EndExport(function)
{
    return DhcpRegSaveSubKeys(Hdl, Subnets);
}

//BeginExport(comment)
//================================================================================
//  the single stuff are here -- these are not list stuff, but just simple
//  single valued attributes
//  some of these actually, dont even go to the registry, but that's fine alright?
//================================================================================
//EndExport(comment)

//BeginExport(function)
DWORD
DhcpRegServerSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags
    // more attributes will come here soon?
) //EndExport(function)
{
#if 0
    WATTRIB_TBL                    Table[] = {
        Name,    REG_SERVER_NAME
    }
    if( Name ) *Name = NULL;
    if( Comment ) *Comment = NULL;
    if( Flags ) *Flags = 0;
#endif

    return ERROR_SUCCESS;
}

DWORD
DhcpRegSubnetSetAttributesInternal(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Mask,
    IN      DWORD                 *SwitchedNetwork
)
{
    DWORD                          Error, SrvIpAddress, SrvRole;
    LPWSTR                         EmptyString;
    REG_HANDLE                     Hdl2;
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,        REG_SUBNET_NAME,
        Comment,         0,        REG_SZ,        REG_SUBNET_COMMENT,
        Flags,           0,        REG_DWORD,     REG_SUBNET_STATE,
        Address,         0,        REG_DWORD,     REG_SUBNET_ADDRESS,
        Mask,            0,        REG_DWORD,     REG_SUBNET_MASK,
        SwitchedNetwork, 0,        REG_DWORD,     REG_SUBNET_SWITCHED_FLAG
    };

    Error = DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( NO_ERROR != Error ) return Error;

    //
    // The following lines are for backward compat with NT4.
    //
    
    //
    // Create the reservation key in any case
    //

    Error = DhcpRegGetNextHdl(
        Hdl, REG_SUBNET_RESERVATIONS, &Hdl2 );
    if( NO_ERROR != Error ) return Error;

    DhcpRegCloseHdl( &Hdl2 );

    //
    // Create the servers key
    //

    Error = DhcpRegGetNextHdl(
        Hdl, L"DHCPServers", &Hdl2 );
    if( NO_ERROR != Error ) return Error;
    DhcpRegCloseHdl( &Hdl2 );

    Error = DhcpRegGetNextNextHdl(
        Hdl, L"DHCPServers", L"127.0.0.1", &Hdl2 );
    if( NO_ERROR != Error ) return Error;

    //
    // Now set the role of the newly created server as primary
    //
    SrvIpAddress = INADDR_LOOPBACK;
    SrvRole = 1; // primary
    EmptyString = L"";
    {
        WATTRIB_TBL SrvTable[] = {
            &SrvRole,  0, REG_DWORD, L"Role",
            &SrvIpAddress, 0, REG_DWORD, L"ServerIpAddress",
            &EmptyString, 0, REG_SZ, L"ServerHostName",
            &EmptyString, 0, REG_SZ, L"ServerNetBiosName"
        };

        Error = DhcpRegSaveAttribTable(
            &Hdl2, SrvTable, sizeof(SrvTable)/sizeof(SrvTable[0]));
    }

    DhcpRegCloseHdl(&Hdl2);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSubnetSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Mask
) //EndExport(function)
{
    DWORD xFlags, SwitchedNetwork = FALSE;
    OSVERSIONINFO Ver;

    Ver.dwOSVersionInfoSize = sizeof(Ver);
    if( FALSE == GetVersionEx(&Ver) ) return GetLastError();

    if( Flags && Ver.dwMajorVersion < 5 ) {
        SwitchedNetwork = IS_SWITCHED(*Flags);
        xFlags = IS_DISABLED(*Flags);
        Flags = &xFlags;
    }
    
    return DhcpRegSubnetSetAttributesInternal(
        Hdl, Name, Comment, Flags, Address, Mask,
        Flags ? &SwitchedNetwork : NULL );
}

//BeginExport(function)
DWORD
DhcpRegMScopeSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Comments,
    IN      DWORD                 *State,
    IN      DWORD                 *ScopeId,
    IN      DWORD                 *Policy,
    IN      DWORD                 *TTL,
    IN      LPWSTR                *LangTag,
    IN      PDATE_TIME             *ExpiryTime
) //EndExport(function)
{
    WATTRIB_TBL                    Table[] = {
        Comments,        0,        REG_SZ,          REG_MSCOPE_COMMENT,
        State,           0,        REG_DWORD,       REG_MSCOPE_STATE,
        ScopeId,         0,        REG_DWORD,       REG_MSCOPE_SCOPEID,
        Policy,          0,        REG_DWORD,       REG_MSCOPE_ADDR_POLICY,
        TTL,             0,        REG_DWORD,       REG_MSCOPE_TTL,
        LangTag,         0,        REG_SZ,          REG_MSCOPE_LANG_TAG,
        ExpiryTime,      sizeof(**ExpiryTime),   REG_BINARY,      REG_MSCOPE_EXPIRY_TIME
    };
    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegOptDefSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comments,
    IN      DWORD                 *Flags,
    IN      DWORD                 *OptionId,
    IN      LPWSTR                *ClassName,
    IN      LPWSTR                *VendorName,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,           REG_OPTION_NAME,
        Comments,        0,        REG_SZ,           REG_OPTION_COMMENT,
        ClassName,       0,        REG_SZ,           REG_OPTION_CLASSNAME,
        VendorName,      0,        REG_SZ,           REG_OPTION_VENDORNAME,
        Flags,           0,        REG_DWORD,        REG_OPTION_TYPE,
        OptionId,        0,        REG_DWORD,        REG_OPTION_ID,
        Value,           ValueSize,REG_BINARY,       REG_OPTION_VALUE
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegSScopeSetAttributes(                       // superscopes dont have any information stored.. dont use this
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags
) //EndExport(function)
{
    Require(FALSE);
    return ERROR_INVALID_PARAMETER;
}

//BeginExport(function)
DWORD
DhcpRegClassDefSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,           REG_CLASSDEF_NAME,
        Comment,         0,        REG_SZ,           REG_CLASSDEF_COMMENT,
        Flags,           0,        REG_DWORD,        REG_CLASSDEF_TYPE,
        Value,           ValueSize,REG_BINARY,       REG_CLASSDEF_VALUE
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegSubnetServerSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Role
) //EndExport(function)
{
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,           REG_SUB_SERVER_NAME,
        Comment,         0,        REG_SZ,           REG_SUB_SERVER_COMMENT,
        Flags,           0,        REG_DWORD,        REG_FLAGS,
        Address,         0,        REG_DWORD,        REG_SUB_SERVER_ADDRESS,
        Role,            0,        REG_DWORD,        REG_SUB_SERVER_ROLE,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegRangeSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      ULONG                 *AllocCount,
    IN      ULONG                 *MaxAllocCount,
    IN      DWORD                 *StartAddress,
    IN      DWORD                 *EndAddress,
    IN      LPBYTE                *InUseClusters,
    IN      DWORD                  InUseClusterSize,
    IN      LPBYTE                *UsedClusters,
    IN      DWORD                  UsedClustersSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                     Table[] = {
        Name,            0,        REG_SZ,           REG_RANGE_NAME,
        Comment,         0,        REG_SZ,           REG_RANGE_COMMENT,
        Flags,           0,        REG_DWORD,        REG_RANGE_FLAGS,
        AllocCount,      0,        REG_DWORD,        REG_RANGE_ALLOC,
        MaxAllocCount,   0,        REG_DWORD,        REG_RANGE_MAX_ALLOC,
        StartAddress,    0,        REG_DWORD,        REG_RANGE_START_ADDRESS,
        EndAddress,      0,        REG_DWORD,        REG_RANGE_END_ADDRESS,
        InUseClusters,   InUseClusterSize, REG_BINARY, REG_RANGE_INUSE_CLUSTERS,
        UsedClusters,    UsedClustersSize, REG_BINARY, REG_RANGE_USED_CLUSTERS,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegReservationSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      LPBYTE                *ClientUID,
    IN      DWORD                  ClientUIDSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,           REG_RESERVATION_NAME,
        Comment,         0,        REG_SZ,           REG_RESERVATION_COMMENT,
        Flags,           0,        REG_DWORD,        REG_RESERVATION_TYPE,
        Address,         0,        REG_DWORD,        REG_RESERVATION_ADDRESS,
        ClientUID,       ClientUIDSize, REG_BINARY,  REG_RESERVATION_UID,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegOptSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      DWORD                 *OptionId,
    IN      LPWSTR                *ClassName,
    IN      LPWSTR                *VendorName,
    IN      DWORD                 *Flags,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        OptionId,        0,        REG_DWORD,        REG_OPTION_ID,
        ClassName,       0,        REG_SZ,           REG_OPTION_CLASSNAME,
        VendorName,      0,        REG_SZ,           REG_OPTION_VENDORNAME,
        Flags,           0,        REG_DWORD,        REG_OPTION_TYPE,
        Value,           ValueSize,REG_BINARY,       REG_OPTION_VALUE,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//================================================================================
//  recursive deleting of keys...
//================================================================================

//BeginExport(function)
DWORD
DhcpRegRecurseDelete(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 KeyName
) //EndExport(function)
{
    REG_HANDLE                     Hdl2;
    DWORD                          Error;
    DWORD                          LocalError, RetError;
    ARRAY                          Array;         // sub keys
    ARRAY_LOCATION                 Loc;
    LPWSTR                         SubKey;

    RetError = ERROR_SUCCESS;

    Error = DhcpRegGetNextHdl(Hdl, KeyName, &Hdl2);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayInit(&Array);
    if( ERROR_SUCCESS != Error ) {
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);
        return Error;
    }

    Error = DhcpRegFillSubKeys(&Hdl2, &Array);
    Require( ERROR_SUCCESS == Error );

    Error = MemArrayInitLoc(&Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Array, &Loc, (LPVOID *)&SubKey);
        Require(ERROR_SUCCESS == Error && SubKey);

        Error = DhcpRegRecurseDelete(&Hdl2, SubKey);
        if( ERROR_SUCCESS != Error ) RetError = Error;

        if( SubKey ) MemFree(SubKey);

        Error = MemArrayNextLoc(&Array, &Loc);
    }

    Error = MemArrayCleanup(&Array);
    Require(ERROR_SUCCESS == Error);

    Error = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error);

    Error = RegDeleteKey(Hdl->Key, KeyName);
    if( ERROR_SUCCESS != Error ) RetError = Error;

    return RetError;
}

//BeginExport(function)
DWORD
DhcpRegRecurseDeleteBunch(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 KeysArray
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    LPWSTR                         ThisKeyName;
    DWORD                          Error;

    Error = MemArrayInitLoc(KeysArray, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(KeysArray, &Loc, &ThisKeyName);
        Require(ERROR_SUCCESS == Error && NULL != ThisKeyName);

        Error = DhcpRegRecurseDelete(Hdl, ThisKeyName);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = MemArrayNextLoc(KeysArray, &Loc);
    }

    return ERROR_SUCCESS;
}

static
VOID
GetLocalFileTime(                                 // fill in filetime struct w/ current local time
    IN OUT  LPFILETIME             Time           // struct to fill in
)
{
    BOOL                           Status;
    SYSTEMTIME                     SysTime;

    GetSystemTime(&SysTime);                      // get sys time as UTC time.
    Status = SystemTimeToFileTime(&SysTime,Time); // conver system time to file time
    if( FALSE == Status ) {                       // convert failed?
        Time->dwLowDateTime = 0xFFFFFFFF;         // set time to weird value in case of failiure
        Time->dwHighDateTime = 0xFFFFFFFF;
    }
}

//BeginExport(function)
DWORD
DhcpRegUpdateTime(                                // update the last modified time
    VOID
)   //EndExport(function)
{
    FILETIME                       Time;
    DWORD                          Err, Size;
    HKEY                           hKey;

    GetLocalFileTime(&Time);                      // first get current time
    (*(LONGLONG *)&Time) += 10*1000*60*2;         // 2 minutes (Filetime is in 100-nano seconds)
    // HACK! the previous line is there as the DS takes a little while to update the
    // last changed time..
    Time.dwLowDateTime =Time.dwHighDateTime =0;   // set time to "long back" initially
    Err = RegOpenKeyEx                            // try to open the config key.
    (
        /* hKey                 */ HKEY_LOCAL_MACHINE,
        /* lpSubKey             */ REG_THIS_SERVER,
        /* ulOptions            */ 0 /* Reserved */ ,
        /* samDesired           */ KEY_ALL_ACCESS,
        /* phkResult            */ &hKey
    );
    if( ERROR_SUCCESS != Err ) return Err;        // time is still set to ages back

    Err = RegSetValueEx                           // now save the time value
    (
        /* hKey                 */ hKey,
        /* lpValueName          */ DHCP_LAST_DOWNLOAD_TIME_VALUE,
        /* lpReserved           */ 0,
        /* lpType               */ REG_BINARY,
        /* lpData               */ (LPBYTE)&Time,
        /* lpcData              */ sizeof(Time)
    );
    RegCloseKey(hKey);                            // close key before we forget

    return Err;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\mmreg\regutil.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

#ifndef _MMREG_REGUTIL_H
#define _MMREG_REGUTIL_H

typedef struct _REG_HANDLE {
    HKEY                           Key;
    HKEY                           SubKey;
    LPWSTR                         SubKeyLocation;
} REG_HANDLE, *PREG_HANDLE, *LPREG_HANDLE;


#define     REG_THIS_SERVER                       L"Software\\Microsoft\\DHCPServer\\Configuration"
#define     REG_THIS_SERVER_DS                    L"Software\\Microsoft\\DHCPServer\\Config_DS"
#define     REG_THIS_SERVER_DS_VALUE              L"Config_DS"
#define     REG_THIS_SERVER_DS_PARENT             L"Software\\Microsoft\\DHCPServer"

#define     REG_SERVER_GLOBAL_OPTIONS             L"GlobalOptionValues"
#define     REG_SERVER_OPTDEFS                    L"OptionInfo"
#define     REG_SERVER_SUBNETS                    L"Subnets"
#define     REG_SERVER_SSCOPES                    L"SuperScope"
#define     REG_SERVER_CLASSDEFS                  L"ClassDefs"
#define     REG_SERVER_MSCOPES                    L"MulticastScopes"

#define     REG_SUBNET_SERVERS                    L"DHCPServers"
#define     REG_SUBNET_RANGES                     L"IpRanges"
#define     REG_SUBNET_RESERVATIONS               L"ReservedIps"
#define     REG_SUBNET_OPTIONS                    L"SubnetOptions"

#define     REG_SUBNET_EXCL                       L"ExcludedIpRanges"
#define     REG_SUBNET_ADDRESS                    L"SubnetAddress"
#define     REG_SUBNET_NAME                       L"SubnetName"
#define     REG_SUBNET_COMMENT                    L"SubnetComment"
#define     REG_SUBNET_MASK                       L"SubnetMask"
#define     REG_SUBNET_STATE                      L"SubnetState"
#define     REG_SUBNET_SWITCHED_FLAG              L"SwitchedNetworkFlag"

#define     REG_MSCOPE_NAME                       L"MScopeName"
#define     REG_MSCOPE_COMMENT                    L"MScopeComment"
#define     REG_MSCOPE_SCOPEID                    L"MScopeIdValue"
#define     REG_MSCOPE_STATE                      L"MScopeState"
#define     REG_MSCOPE_ADDR_POLICY                L"MScopeAddressPolicy"
#define     REG_MSCOPE_TTL                        L"MScopeTTL"
#define     REG_MSCOPE_LANG_TAG                   L"MScopeLangTag"
#define     REG_MSCOPE_EXPIRY_TIME                L"MScopeExpiryTime"

#define     REG_SUB_SERVER_NAME                   L"ServerHostName"
#define     REG_SUB_SERVER_COMMENT                L"ServerComment"
#define     REG_SUB_SERVER_ADDRESS                L"ServerAddress"
#define     REG_SUB_SERVER_ROLE                   L"Role"

#define     REG_RANGE_NAME                        L"RangeName"
#define     REG_RANGE_COMMENT                     L"RangeComment"
#define     REG_RANGE_START_ADDRESS               L"StartAddress"
#define     REG_RANGE_END_ADDRESS                 L"EndAddress"
#define     REG_RANGE_INUSE_CLUSTERS              L"InUseClusters"
#define     REG_RANGE_USED_CLUSTERS               L"UsedClusters"
#define     REG_RANGE_BITS_PREFIX                 L"Bits "
#define     REG_RANGE_BITS_PREFIX_WCHAR_COUNT     (5)
#define     REG_RANGE_FLAGS                       L"RangeFlags"
#define     REG_RANGE_ALLOC                       L"RangeBootpAllocated"
#define     REG_RANGE_MAX_ALLOC                   L"RangeBootpMaxAllowed"

#define     REG_OPTION_NAME                       L"OptionName"
#define     REG_OPTION_COMMENT                    L"OptionComment"
#define     REG_OPTION_TYPE                       L"OptionType"
#define     REG_OPTION_VALUE                      L"OptionValue"
#define     REG_OPTION_ID                         L"OptionId"
#define     REG_OPTION_CLASSNAME                  L"OptionClassName"
#define     REG_OPTION_VENDORNAME                 L"OptionVendorName"

#define     REG_CLASSDEF_NAME                     L"ClassName"
#define     REG_CLASSDEF_COMMENT                  L"ClassComment"
#define     REG_CLASSDEF_TYPE                     L"ClassType"
#define     REG_CLASSDEF_VALUE                    L"ClassValue"

#define     REG_RESERVATION_ADDRESS               L"IpAddress"
#define     REG_RESERVATION_UID                   L"ClientUID"
#define     REG_RESERVATION_TYPE                  L"AllowedClientTypes"
#define     REG_RESERVATION_NAME                  L"ReservationName"
#define     REG_RESERVATION_COMMENT               L"ReservationComment"

#define     REG_FLAGS                             L"Flags"

#define     REG_ACCESS                            KEY_ALL_ACCESS
#define     REG_DEFAULT_SUBNET_STATE              0
#define     REG_DEFAULT_SUBNET_MASK               0xFFFFFFFF
#define     REG_DEFAULT_SWITCHED_FLAG             FALSE

#define     REG_CLASS                             L"DhcpClass"

#define DHCP_LAST_DOWNLOAD_TIME_VALUE             L"LastDownloadTime"
#define DHCP_LAST_DOWNLOAD_TIME_TYPE              REG_BINARY

#define     DEF_RANGE_ALLOC                       0
#define     DEF_RANGE_MAX_ALLOC                   (~(ULONG)0)



//================================================================================
//  The basic open/traverse/close functions are here
//================================================================================


DWORD
DhcpRegSetCurrentServer(
    IN OUT  PREG_HANDLE            Hdl
) ;


DWORD
DhcpRegGetThisServer(
    IN OUT  PREG_HANDLE            Hdl
) ;


DWORD
DhcpRegGetNextHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 NextLoc,
    OUT     PREG_HANDLE            OutHdl
) ;


DWORD
DhcpRegCloseHdl(
    IN OUT  PREG_HANDLE            Hdl
) ;


//================================================================================
//   MISC utilities for registry manipulation
//================================================================================


DWORD
DhcpRegFillSubKeys(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array          // fill in a list of key names
) ;


LPVOID                                            // DWORD or LPWSTR or LPBYTE
DhcpRegRead(                                      // read differnt values from registry and allocate if not DWORD
    IN      PREG_HANDLE            Hdl,
    IN      DWORD                  Type,          // if DWORD dont allocate memory
    IN      LPWSTR                 ValueName,
    IN      LPVOID                 RetValue       // value to use if nothing found
) ;


DWORD
DhcpRegReadBinary(                                // read binary type
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ValueName,
    OUT     LPBYTE                *RetVal,
    OUT     DWORD                 *RetValSize
) ;


LPWSTR
DhcpRegCombineClassAndOption(                     // create string based on class name and option id
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptionId
) ;


LPWSTR
ConvertAddressToLPWSTR(
    IN      DWORD                  Address,
    IN OUT  LPWSTR                 BufferStr      // input buffer to fill with dotted notation
) ;


//================================================================================
//  the following functions help traversing the registry
//================================================================================


DWORD
DhcpRegServerGetSubnetHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Subnet,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetSScopeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 SScope,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetOptDefHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptDef,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Opt,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetMScopeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 MScope,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetClassDefHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ClassDef,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegSubnetGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Opt,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegSubnetGetRangeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Range,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegSubnetGetReservationHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Reservation,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegSubnetGetServerHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Server,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegReservationGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    OUT     PREG_HANDLE            Hdl2
) ;


//================================================================================
//   List retrieval functions.. for servers, subnets, ranges etc.
//================================================================================


DWORD
DhcpRegServerGetList(
    IN      PREG_HANDLE            Hdl,           // ptr to server location
    IN OUT  PARRAY                 OptList,       // list of LPWSTR options
    IN OUT  PARRAY                 OptDefList,    // list of LPWSTR optdefs
    IN OUT  PARRAY                 Subnets,       // list of LPWSTR subnets
    IN OUT  PARRAY                 SScopes,       // list of LPWSTR sscopes
    IN OUT  PARRAY                 ClassDefs,     // list of LPWSTR classes
    IN OUT  PARRAY                 MScopes        // list of LPWSTR mscopes
) ;


DWORD
DhcpRegSubnetGetExclusions(
    IN      PREG_HANDLE            Hdl,
    OUT     LPBYTE                *Excl,
    OUT     DWORD                 *ExclSize
) ;


DWORD
DhcpRegSubnetGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Servers,
    IN OUT  PARRAY                 IpRanges,
    IN OUT  PARRAY                 Reservations,
    IN OUT  PARRAY                 Options,
    OUT     LPBYTE                *Excl,
    OUT     DWORD                 *ExclSizeInBytes
) ;


DWORD
DhcpRegSScopeGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Subnets
) ;


DWORD
DhcpRegReservationGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Options
) ;


//================================================================================
//  the separate stuff are here -- these are not list stuff, but just simple
//  single valued attributes
//  some of these actually, dont even go to the registry, but that's fine alright?
//================================================================================


DWORD
DhcpRegServerGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags
    // more attributes will come here soon?
) ;


DWORD
DhcpRegSubnetGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     DWORD                 *Mask
) ;


DWORD
DhcpRegMScopeGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Comments,
    OUT     DWORD                 *State,
    OUT     DWORD                 *ScopeId,
    OUT     DWORD                 *Policy,
    OUT     DWORD                 *TTL,
    OUT     LPWSTR                *LangTag,
    OUT     PDATE_TIME            *ExpiryTime
) ;


DWORD
DhcpRegOptDefGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comments,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *OptionId,
    OUT     LPWSTR                *ClassName,
    OUT     LPWSTR                *VendorName,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) ;


DWORD
DhcpRegSScopeGetAttributes(                       // superscopes dont have any information stored.. dont use this
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags
) ;


DWORD
DhcpRegClassDefGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) ;


DWORD
DhcpRegSubnetServerGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     DWORD                 *Role
) ;


DWORD
DhcpRegRangeGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     ULONG                 *AllocCount,
    OUT     ULONG                 *MaxAllocCount,
    OUT     DWORD                 *StartAddress,
    OUT     DWORD                 *EndAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClusterSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) ;


DWORD
DhcpRegReservationGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     LPBYTE                *ClientUID,
    OUT     DWORD                 *ClientUIDSize
) ;


DWORD
DhcpRegOptGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     DWORD                 *OptionId,
    OUT     LPWSTR                *ClassName,
    OUT     LPWSTR                *VendorName,
    OUT     DWORD                 *Flags,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) ;


//================================================================================
//  the following functiosn help in writing to the registry
//================================================================================


DWORD
DhcpRegSaveSubKeys(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array
) ;


DWORD
DhcpRegSaveSubKeysPrefixed(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array,
    IN      LPWSTR                 CommonPrefix
) ;


DWORD
DhcpRegServerSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 OptList,       // list of LPWSTR options
    IN      PARRAY                 OptDefList,    // list of LPWSTR optdefs
    IN      PARRAY                 Subnets,       // list of LPWSTR subnets
    IN      PARRAY                 SScopes,       // list of LPWSTR sscopes
    IN      PARRAY                 ClassDefs,     // list of LPWSTR classes
    IN      PARRAY                 MScopes        // list of LPWSTR mscopes
) ;


DWORD
DhcpRegSubnetSetExclusions(
    IN      PREG_HANDLE            Hdl,
    IN      LPBYTE                *Excl,
    IN      DWORD                  ExclSize
) ;


DWORD
DhcpRegSubnetSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 Servers,
    IN      PARRAY                 IpRanges,
    IN      PARRAY                 Reservations,
    IN      PARRAY                 Options,
    IN      LPBYTE                *Excl,
    IN      DWORD                  ExclSizeInBytes
) ;


DWORD
DhcpRegSScopeSetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Subnets
) ;


DWORD
DhcpRegReservationSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 Subnets
) ;


//================================================================================
//  the single stuff are here -- these are not list stuff, but just simple
//  single valued attributes
//  some of these actually, dont even go to the registry, but that's fine alright?
//================================================================================


DWORD
DhcpRegServerSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags
    // more attributes will come here soon?
) ;


DWORD
DhcpRegSubnetSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Mask
) ;


DWORD
DhcpRegMScopeSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Comments,
    IN      DWORD                 *State,
    IN      DWORD                 *ScopeId,
    IN      DWORD                 *Policy,
    IN      DWORD                 *TTL,
    IN      LPWSTR                *LangTag,
    IN      PDATE_TIME             *ExpiryTime
) ;


DWORD
DhcpRegOptDefSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comments,
    IN      DWORD                 *Flags,
    IN      DWORD                 *OptionId,
    IN      LPWSTR                *ClassName,
    IN      LPWSTR                *VendorName,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegSScopeSetAttributes(                       // superscopes dont have any information stored.. dont use this
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags
) ;


DWORD
DhcpRegClassDefSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegSubnetServerSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Role
) ;


DWORD
DhcpRegRangeSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      ULONG                 *AllocCount,
    IN      ULONG                 *MaxAllocCount,
    IN      DWORD                 *StartAddress,
    IN      DWORD                 *EndAddress,
    IN      LPBYTE                *InUseClusters,
    IN      DWORD                  InUseClusterSize,
    IN      LPBYTE                *UsedClusters,
    IN      DWORD                  UsedClustersSize
) ;


DWORD
DhcpRegReservationSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      LPBYTE                *ClientUID,
    IN      DWORD                  ClientUIDSize
) ;


DWORD
DhcpRegOptSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      DWORD                 *OptionId,
    IN      LPWSTR                *ClassName,
    IN      LPWSTR                *VendorName,
    IN      DWORD                 *Flags,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegRecurseDelete(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 KeyName
) ;


DWORD
DhcpRegRecurseDeleteBunch(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 KeysArray
) ;


DWORD
DhcpRegUpdateTime(                                // update the last modified time
    VOID
) ;


#endif // _MMREG_REGUTIL_H

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\access.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    _access.c

Abstract:

    This module contains the dhcpserver security support routines
    which create security objects and enforce security _access checking.

Author:

    Madan Appiah (madana) 4-Apr-1994

Revision History:

--*/

#include "dhcppch.h"
#include <lmaccess.h>
#include <lmerr.h>
#include <accctrl.h>
#include <aclapi.h>

// The name used to register the service to the service controller
// is stored at ???. Use that name when you find it.

DWORD
DhcpCreateAndLookupSid(
    IN OUT PSID *Sid,
    IN GROUP_INFO_1 *GroupInfo
    )
/*++

Routine Description:
    This routine tries to create the SID required if it
    isn't already present. Also, it tries to lookup the SID
    if it isn't already present.

Arguments:
    Sid -- the sid to fill.
    GroupInfo -- the group information to create.
    
Return Values:
    Win32 errors.

--*/
{
    ULONG Status, Error;
    ULONG SidSize, ReferencedDomainNameSize;
    LPWSTR ReferencedDomainName;
    SID_NAME_USE SidNameUse;
    
    try {
        Status = NetLocalGroupAdd(
            NULL,
            1,
            (PVOID)GroupInfo,
            NULL
            );
        if( NERR_Success != Status
            && NERR_GroupExists != Status
            && ERROR_ALIAS_EXISTS != Status ) {
            //
            // Didn't create the group and group doesn't exist either.
            //
            Error = Status;
            
            return Error;
        }
        
        //
        // Group created. Now lookup the SID.
        //
        SidSize = ReferencedDomainNameSize = 0;
        ReferencedDomainName = NULL;
        Status = LookupAccountName(
            NULL,
            GroupInfo->grpi1_name,
            (*Sid),
            &SidSize,
            ReferencedDomainName,
            &ReferencedDomainNameSize,
            &SidNameUse
            );
        if( Status ) return ERROR_SUCCESS;
        
        Error = GetLastError();
        if( ERROR_INSUFFICIENT_BUFFER != Error ) return Error;
        
        (*Sid) = DhcpAllocateMemory(SidSize);
        ReferencedDomainName = DhcpAllocateMemory(
            sizeof(WCHAR)*(1+ReferencedDomainNameSize)
            );
        if( NULL == (*Sid) || NULL == ReferencedDomainName ) {
            if( *Sid ) DhcpFreeMemory(*Sid);
            *Sid = NULL;
            if( ReferencedDomainNameSize ) {
                DhcpFreeMemory(ReferencedDomainName);
            }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        Status = LookupAccountName(
            NULL,
            GroupInfo->grpi1_name,
            (*Sid),
            &SidSize,
            ReferencedDomainName,
            &ReferencedDomainNameSize,
            &SidNameUse
            );
        if( 0 == Status ) {
            //
            // Failed.
            //
            Error = GetLastError();
            
            if( ReferencedDomainName ) {
                DhcpFreeMemory(ReferencedDomainName);
            }
            if( (*Sid ) ) DhcpFreeMemory( *Sid );
            (*Sid) = NULL;
            return Error;
        }
        
        if( ReferencedDomainName ) {
            DhcpFreeMemory(ReferencedDomainName);
        }
        Error = ERROR_SUCCESS;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Error = GetExceptionCode();
    }
    
    return Error;
} // DhcpCreateAndLookupSid()

// Borrowed from MSDN docs

BOOL SetPrivilege(
    HANDLE hToken,          // access token handle
    LPCTSTR lpszPrivilege,  // name of privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    ) 
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    
    if ( !LookupPrivilegeValue( 
			       NULL,            // lookup privilege on local system
			       lpszPrivilege,   // privilege to lookup 
			       &luid ) ) {      // receives LUID of privilege
	return FALSE; 
    }
    
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if (bEnablePrivilege) {
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    }
    else {
	tp.Privileges[0].Attributes = 0;
    }
    
    // Enable the privilege or disable all privileges.
    
    AdjustTokenPrivileges(  hToken,  FALSE, 
			    &tp,  sizeof(TOKEN_PRIVILEGES), 
			    NULL, NULL); 
    
    // Call GetLastError to determine whether the function succeeded.
    
    if (GetLastError() != ERROR_SUCCESS) { 
	return FALSE; 
    } 
    
    return TRUE;
} // SetPrivilege()

DWORD
EnableSecurityPrivilege( VOID ) 
{
    HANDLE tokHandle;
    DWORD  Error = ERROR_SUCCESS;

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_ALL_ACCESS,
			    &tokHandle )) {
	return GetLastError();
    }

    DhcpPrint(( DEBUG_TRACE, "done\nSetting privilege ... " ));

    if ( !SetPrivilege( tokHandle, SE_SECURITY_NAME, TRUE )) {
	Error = GetLastError();
    }

    if ( !CloseHandle( tokHandle )) {
	if ( ERROR_SUCCESS != Error ) {
	    Error = GetLastError();
	}
    }
    return Error;
} // EnableSecurityPrivilege()


// The following code is based on Q180116 KB article
DWORD
DhcpSetScmAcl(
    ACE_DATA *AceData,
    DWORD    num
    ) 
{

    SC_HANDLE             schManager = NULL;
    SC_HANDLE             schService = NULL;
    SECURITY_DESCRIPTOR   sd;
    PSECURITY_DESCRIPTOR  psd = NULL;
    DWORD                 dwSize;
    DWORD                 Error;
    BOOL                  bDaclPresent, bDaclDefaulted;
    EXPLICIT_ACCESS       ea;
    PACL                  pacl = NULL;
    PACL                  pNewAcl = NULL;
    DWORD                 i;

    // Buffer size for psd to start with
    const int PSD_ALLOC_SIZE = 0x25;

    Error = ERROR_SUCCESS;

    do {
	schManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
	if ( NULL == schManager ) {
	    Error = GetLastError();
	    break;
	}

	// Enable current thread's privilage to ACCESS_SYSTEM_SECURITY
	
	Error = EnableSecurityPrivilege();
	if ( ERROR_SUCCESS != Error ) {
	    break;
	}
	
	schService = OpenService( schManager, DHCP_SERVER,
				  ACCESS_SYSTEM_SECURITY | 
				  READ_CONTROL | WRITE_DAC );
	if ( NULL == schService ) {
	    Error = GetLastError();
	    break;
	}
	
	// Get the current security descriptor
	dwSize = PSD_ALLOC_SIZE;

	psd = ( PSECURITY_DESCRIPTOR ) HeapAlloc( GetProcessHeap(),
						  HEAP_ZERO_MEMORY, dwSize );
	if ( NULL == psd ) {
	    Error = ERROR_NOT_ENOUGH_MEMORY;
	    break;
	}
	if ( !QueryServiceObjectSecurity( schService,
					  DACL_SECURITY_INFORMATION,
					  psd, dwSize, &dwSize )) {
	    Error = GetLastError();

	    if ( ERROR_INSUFFICIENT_BUFFER == Error ) {
		HeapFree( GetProcessHeap(), 0, ( LPVOID ) psd );

		psd = ( PSECURITY_DESCRIPTOR ) HeapAlloc( GetProcessHeap(),
							  HEAP_ZERO_MEMORY,
							  dwSize );
		if ( NULL == psd ) {
		    Error = ERROR_NOT_ENOUGH_MEMORY;
		    break;
		}
		
		Error = ERROR_SUCCESS;
		if ( !QueryServiceObjectSecurity( schService,
						  DACL_SECURITY_INFORMATION,
						  psd, dwSize, &dwSize )) {
		    Error = GetLastError();
		    break;
		} // if
	    } // if
	    else {
		Error =  GetLastError();
		break;
	    }
	} // if

	if ( ERROR_SUCCESS != Error ) {
	    break;
	}

	// get the DACL
	if ( !GetSecurityDescriptorDacl( psd, &bDaclPresent, &pacl,
					 &bDaclDefaulted )) {
	    Error = GetLastError();
	    break;
	}

	// create an ACL from the ACEDATA
	for ( i = 0; i < num; i++ ) {
	    ea.grfAccessPermissions = AceData[i].Mask;
  	    ea.grfAccessMode = GRANT_ACCESS;
	    ea.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	    ea.Trustee.pMultipleTrustee = NULL;
	    ea.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
	    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	    ea.Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
  	    ea.Trustee.ptstrName = (LPTSTR) *AceData[i].Sid;
	    Error = SetEntriesInAcl( 1, &ea, pacl, &pNewAcl );
	    if ( ERROR_SUCCESS != Error ) {
		Error = GetLastError();
		break;
	    }
	    pacl = pNewAcl;
  	} // for

	// Initialize a new security descriptor
	
	if ( !InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION )) {
	    Error = GetLastError();
	    break;
	}
	
	// Set the new DACL in the security descriptor
	if ( !SetSecurityDescriptorDacl( &sd, TRUE, pNewAcl, FALSE )) {
	    Error = GetLastError();
	    break;
	}
	
	// set the new DACL for the service object
	if ( !SetServiceObjectSecurity( schService, 
					DACL_SECURITY_INFORMATION, &sd )) {
	    Error = GetLastError();
	    break;
	}
	
    } while ( FALSE );


    // Close the handles
    if ( NULL != schManager ) {
	if ( !CloseServiceHandle( schManager )) {
	    Error = GetLastError();
	}
    }
    if ( NULL != schService ) {
	if ( !CloseServiceHandle( schService )) {
	    Error = GetLastError();
	}
    }

    // Free allocated memory
    if ( NULL != pNewAcl ) {
	LocalFree(( HLOCAL ) pNewAcl );

    }
    if ( NULL != psd ) {
	HeapFree( GetProcessHeap(), 0, ( LPVOID ) psd );
    }

    return Error;

} // DhcpSetScmAcl()
    
DWORD
DhcpCreateSecurityObjects(
    VOID
    )
/*++

Routine Description:

    This function creates the dhcpserver user-mode objects which are
    represented by security descriptors.

Arguments:

    None.

Return Value:

    WIN32 status code

--*/
{
    NTSTATUS Status;
    ULONG Error;

    //
    // Order matters!  These ACEs are inserted into the DACL in the
    // following order.  Security access is granted or denied based on
    // the order of the ACEs in the DACL.
    //
    //
    ACE_DATA AceData[] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &AliasAdminsSid},
	{ACCESS_ALLOWED_ACE_TYPE, 0, 0, DHCP_ALL_ACCESS, &DhcpAdminSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, DHCP_VIEW_ACCESS, &DhcpSid}
    };
    GROUP_INFO_1 DhcpGroupInfo = { 
        GETSTRING(DHCP_USERS_GROUP_NAME),
        GETSTRING(DHCP_USERS_GROUP_DESCRIPTION),
    };
    GROUP_INFO_1 DhcpAdminGroupInfo = {
        GETSTRING(DHCP_ADMINS_GROUP_NAME),
        GETSTRING(DHCP_ADMINS_GROUP_DESCRIPTION)
    };

    //
    // First try to create the DhcpReadOnly group..
    //

    Error = DhcpCreateAndLookupSid(
        &DhcpSid,
        &DhcpGroupInfo
        );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "CreateAndLookupSid: %ld\n", Error));
        DhcpReportEventW(
            DHCP_EVENT_SERVER,
            EVENT_SERVER_READ_ONLY_GROUP_ERROR,
            EVENTLOG_ERROR_TYPE,
            0,
            sizeof(ULONG),
            NULL,
            (PVOID)&Error
            );
        return Error;
    }

    Error = DhcpCreateAndLookupSid(
        &DhcpAdminSid,
        &DhcpAdminGroupInfo
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "CreateAndLookupSid: %ld\n", Error));
        DhcpReportEventW(
            DHCP_EVENT_SERVER,
            EVENT_SERVER_ADMIN_GROUP_ERROR,
            EVENTLOG_ERROR_TYPE,
            0,
            sizeof(ULONG),
            NULL,
            (PVOID)&Error
            );
        return Error;
    }
    
    //
    // Actually create the security descriptor.
    //

    Status = NetpCreateSecurityObject(
        AceData,
        sizeof(AceData)/sizeof(AceData[0]),
        NULL, //LocalSystemSid,
        NULL, //LocalSystemSid,
        &DhcpGlobalSecurityInfoMapping,
        &DhcpGlobalSecurityDescriptor
        );
    
    // DhcpFreeMemory(Sid);


    Error = DhcpSetScmAcl( AceData, sizeof( AceData ) / sizeof( AceData[ 0 ]));
    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }

    return RtlNtStatusToDosError( Status );
} // DhcpCreateSecurityObjects()

DWORD
DhcpApiAccessCheck(
    ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This function checks to see the caller has required access to
    execute the calling API.

Arguments:

    DesiredAccess - required access to call the API.

Return Value:

    WIN32 status code

--*/
{
    DWORD Error;

    Error = NetpAccessCheckAndAudit(
                DHCP_SERVER,                        // Subsystem name
                DHCP_SERVER_SERVICE_OBJECT,         // Object typedef name
                DhcpGlobalSecurityDescriptor,       // Security descriptor
                DesiredAccess,                      // Desired access
                &DhcpGlobalSecurityInfoMapping );   // Generic mapping

    if(Error != ERROR_SUCCESS) {
        return( ERROR_ACCESS_DENIED );
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\callout.c ===
/*++

Copyright (C) Microsoft Corporation 1997.

Module Name:

    callout.c

Abstract:

    Load and define macros for DHCP Server Callouts.

Author:

    Ramesh V K (Rameshv) Before March 1998.  Mabye in 1997.

--*/
#include <dhcppch.h>

//BeginExport(multiple-redef-prevention)
#ifndef   _CALLOUT_H_
#define   _CALLOUT_H_
//EndExport(multiple-redef-prevention)

//
// Types, Structs, Defines.
//

//BeginExport(defines)

//
// The location in registry where the REG_MULTI_SZ list of callout DLLs 
// that the DHCP Server will try to load.
//

#define   DHCP_CALLOUT_LIST_KEY    L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters"
#define   DHCP_CALLOUT_LIST_VALUE  L"CalloutDlls"
#define   DHCP_CALLOUT_LIST_TYPE   REG_MULTI_SZ
#define   DHCP_CALLOUT_ENTRY_POINT "DhcpServerCalloutEntry"
#define   DHCP_CALLOUT_ENABLE_VALUE L"CalloutEnabled"

//
// Control CODES used by DHCP Server to notify server state change.
//

#define   DHCP_CONTROL_START       0x00000001
#define   DHCP_CONTROL_STOP        0x00000002
#define   DHCP_CONTROL_PAUSE       0x00000003
#define   DHCP_CONTROL_CONTINUE    0x00000004

//
// Other ControlCodes used by various Callout HOOKS.
//

#define   DHCP_DROP_DUPLICATE      0x00000001     // duplicate of pkt being processed
#define   DHCP_DROP_NOMEM          0x00000002     // not enough server mem in queues
#define   DHCP_DROP_INTERNAL_ERROR 0x00000003     // ooops?
#define   DHCP_DROP_TIMEOUT        0x00000004     // too late, pkt is too old
#define   DHCP_DROP_UNAUTH         0x00000005     // server is not authorized to run
#define   DHCP_DROP_PAUSED         0x00000006     // service is paused
#define   DHCP_DROP_NO_SUBNETS     0x00000007     // no subnets configured on server
#define   DHCP_DROP_INVALID        0x00000008     // invalid packet or client
#define   DHCP_DROP_WRONG_SERVER   0x00000009     // client in different DS enterprise
#define   DHCP_DROP_NOADDRESS      0x0000000A     // no address available to offer
#define   DHCP_DROP_PROCESSED      0x0000000B     // packet has been processed
#define   DHCP_DROP_GEN_FAILURE    0x00000100     // catch-all error
#define   DHCP_SEND_PACKET         0x10000000     // send the packet on wire
#define   DHCP_PROB_CONFLICT       0x20000001     // address conflicted..
#define   DHCP_PROB_DECLINE        0x20000002     // an addr got declined
#define   DHCP_PROB_RELEASE        0x20000003     // an addr got released
#define   DHCP_PROB_NACKED         0x20000004     // a client is being nacked.
#define   DHCP_GIVE_ADDRESS_NEW    0x30000001     // give client a "new" address
#define   DHCP_GIVE_ADDRESS_OLD    0x30000002     // renew client's "old" address
#define   DHCP_CLIENT_BOOTP        0x30000003     // client is a BOOTP client
#define   DHCP_CLIENT_DHCP         0x30000004     // client is a DHCP client
//EndExport(defines)


//BeginExport(typedefs)

typedef
DWORD
(APIENTRY *LPDHCP_CONTROL)(
    IN DWORD dwControlCode,
    IN LPVOID lpReserved
)
/*++

Routine Description:

    This routine is called whenever the DHCP Server service is
    started, stopped, paused or continued as defined by the values of
    the dwControlCode parameter.  The lpReserved parameter is reserved
    for future use and it should not be interpreted in any way.   This
    routine should not block. 

Arguments:

    dwControlCode - one of the DHCP_CONTROL_* values
    lpReserved - reserved for future use.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_NEWPKT)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN OUT LPVOID *PktContext,
    OUT LPBOOL ProcessIt
)
/*++

Routine Description:

    This routine is called soon after the DHCP Server receives a
    packet that it attempts to process.  This routine is in the
    critical path of server execution and should return very fast, as
    otherwise server performance will be impacted.  The Callout DLL
    can modify the buffer or return a new buffer via the Packet,
    PacketSize arguments.  Also, if the callout DLL has internal
    structures to keep track of the packet and its progress, it can
    then return a context to this packet in the PktContext parameter.
    This context will be passed to almost all other hooks to indicate
    the packet being referred to.  Also, if the Callout DLL is
    planning on processing the packet or for some other reason the
    DHCP server is not expected to process this packet, then it can
    set the ProcessIt flag to FALSE to indicate that the packet is to
    be dropped. 
    
Arguments:

    Packet - This parameter points to a character buffer that holds
    the actual packet received by the DHCP Server. 

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer. 

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on. 

    Reserved -Reserved for future use.

    PktContect - This is an opaque pointer used by the DHCP Server for
    future references to this packet.  It is expected that the callout
    DLL will provide this pointer if it is interested in keeping track
    of the packet.  (See the descriptions for the hooks below for
    other usage of this Context). 

    ProcessIt - This is a BOOL flag that the CalloutDll can set to
    TRUE or reset to indicate if the DHCP Server should continue
    processing this packet or not, respectively. 

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_DROP_SEND)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD ControlCode,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN LPVOID PktContext
)
/*++

Routine Description:

    This hook is called if a packet is (DropPktHook) dropped for some
    reason or if the packet is completely processed.   (If a packet is
    dropped, the hook is called twice as it is called once again to
    note that the packet has been completely processed).  The callout
    DLL should  be prepared to handle this hook multiple times for a
    packet. This routine should not block. The ControlCode parameter
    defines the reasons for the packet being dropped:  

    * DHCP_DROP_DUPLICATE - This packet is a duplicate of another
      received by the server. 
    * DHCP_DROP_NOMEM - Not enough memory to process the packet.
    * DHCP_DROP_INTERNAL_ERROR - Unexpected nternal error occurred.
    * DHCP_DROP_TIMEOUT - The packet is too old to process.
    * DHCP_DROP_UNAUTH - The server is not authorized.
    * DHCP_DROP_PAUSED - The server is paused.
    * DHCP_DROP_NO_SUBNETS - There are no subnets configured.
    * DHCP_DROP_INVALID - The packet is invalid or it came on an
      invalid socket .. 
    * DHCP_DROP_WRONG_SERVER - The packet was sent to the wrong DHCP Server.
    * DHCP_DROP_NOADDRESS - There is no address to offer.
    * DHCP_DROP_PROCESSED - The packet has been processed.
    * DHCP_DROP_GEN_FAILURE - An unknown error occurred.

    This routine is also called right before a response is sent down
    the wire (SendPktHook) and in this case the ControlCode has a
    value of DHCP_SEND_PACKET.

Arguments:

    Packet - This parameter points to a character buffer that holds
    the packet being processed by the DHCP Server. 

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer. 

    ControlCode - See description for various control codes.

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on. 

    Reserved - Reserved for future use.

    PktContext - This parameter is the packet context that the Callout
    DLL NewPkt Hook returned for this packet.  This can be used to
    track a packet. 
   
--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_PROB)( 
    IN LPBYTE Packet, 
    IN DWORD PacketSize, 
    IN DWORD ControlCode, 
    IN DWORD IpAddress, 
    IN DWORD AltAddress, 
    IN LPVOID Reserved, 
    IN LPVOID PktContext 
)
/*++

Routine Description:

    This routine is called whenever special events occur that cause
    the packet to be dropped etc.  The possible ControlCodes and their
    meanings are as follows: 

    * DHCP_PROB_CONFLICT - The address attempted to be offered
      (AltAddress) is in use in the network already.  
    * DHCP_PROB_DECLINE - The packet was a DECLINE message for the
      address specified in AltAddress.
    * DHCP_PROB_RELEASE - The packet was a RELEASE message for the
      address specified in AltAddress.
    * DHCP_PROB_NACKED - The packet was a REQUEST message for address
      specified in AltAddress and it was NACKed by the server.  

    This routine should not block.  

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    ControlCode - Specifies the event. See description below for
    control codes and meanings. 

    IpAddress - IpV4 address of socket this packet was received on. 

    AltAddress - Request IpV4 Address or Ip address that is in
    conflict. 

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_GIVE_ADDRESS)( 
    IN LPBYTE Packet, 
    IN DWORD PacketSize, 
    IN DWORD ControlCode, 
    IN DWORD IpAddress, 
    IN DWORD AltAddress, 
    IN DWORD AddrType, 
    IN DWORD LeaseTime, 
    IN LPVOID Reserved, 
    IN LPVOID PktContext 
)
/*++

Routine Description:

    This routine is called when the server is about to send an ACK to
    a REQUEST message.  The ControlCode specifies if the address is a
    totally new address or if it an renewal of an old address (with
    values DHCP_GIVE_ADDRESS_NEW and DHCP_GIVE_ADDRESS_OLD
    respectively). The address being offered is passed as the
    AltAddress parameter and the AddrType parameter can be one of
    DHCP_CLIENT_BOOTP or DHCP_CLIENT_DHCP indicating whether the
    client is using BOOTP or DHCP respectively. This call should not
    block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    ControlCode -  See description above for control codes and
    meanings. 

    IpAddress - IpV4 address of socket this packet was received on. 

    AltAddress - IpV4 address being ACKed to the client.

    AddrType - Is this a DHCP or BOOTP address?

    LeaseTime - Lease duration being passed.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_HANDLE_OPTIONS)(
    IN LPBYTE Packet,
    IN DWORD PacketSize,
    IN LPVOID Reserved,
    IN LPVOID PktContext,
    IN OUT LPDHCP_SERVER_OPTIONS ServerOptions
)
/*++

Routine Description:

    This routine can be utilized by the CalloutDLL to avoid parsing
    the whole packet.  The packet is parsed by the server and some
    commonly used options are returned in the parsed pointers
    structure (see header for definition of DHCP_SERVER_OPTIONS).  The
    hook is expected to make a copy of the structure pointed to by
    ServerOptions if it needs it beyond this function call.  This
    routine may be called several times for a single packet.  This
    routine should not block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

    ServerOptions - This parameter is the structure that contains a
    bunch of pointers that represent corresponding options. 

--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_DELETE_CLIENT)( 
    IN DWORD IpAddress, 
    IN LPBYTE HwAddress, 
    IN ULONG HwAddressLength, 
    IN DWORD Reserved, 
    IN DWORD ClientType 
)
/*++

Routine Description:

    This routine is called before a client lease is deleted off the
    active leases database.  The ClientType field is currently not
    provided and this should not be used.  This routine should not
    block.  

Arguments:

    IpAddress - IpV4 address of the client lease being deleted.

    HwAddress - Buffer holding the Hardware address of the client (MAC).

    HwAddressLength - This specifies the length of the above buffer.

    Reserved - Reserved for future use.

    ClientType - Reserved for future use.
--*/
;

typedef
struct      _DHCP_CALLOUT_TABLE {
    LPDHCP_CONTROL                 DhcpControlHook;
    LPDHCP_NEWPKT                  DhcpNewPktHook;
    LPDHCP_DROP_SEND               DhcpPktDropHook;
    LPDHCP_DROP_SEND               DhcpPktSendHook;
    LPDHCP_PROB                    DhcpAddressDelHook;
    LPDHCP_GIVE_ADDRESS            DhcpAddressOfferHook;
    LPDHCP_HANDLE_OPTIONS          DhcpHandleOptionsHook;
    LPDHCP_DELETE_CLIENT           DhcpDeleteClientHook;
    LPVOID                         DhcpExtensionHook;
    LPVOID                         DhcpReservedHook;
}   DHCP_CALLOUT_TABLE, *LPDHCP_CALLOUT_TABLE;

typedef
DWORD
(APIENTRY *LPDHCP_ENTRY_POINT_FUNC) ( 
    IN LPWSTR ChainDlls, 
    IN DWORD CalloutVersion, 
    IN OUT LPDHCP_CALLOUT_TABLE CalloutTbl
)
/*++

Routine Description:

    This is the routine that is called by the DHCP Server when it
    successfully loads a DLL.    If the routine succeeds, then the
    DHCP Server does not attempt to load any of the DLLs specified in
    the ChainDlls list of DLLs.   If this function fails for some
    reason, then the DHCP Server proceeds to the next DLL in the
    ChainDlls structure.  

    Note that for version negotiation, the server may call this
    routine several times until a compatible version is found. 

    It is expected that the entrypoint routine would walk through the
    names of the dlls and attempt to load each of them and when it
    succeeds in retrieving the entry point, it attempts to get the
    cumulative set of hooks by repeating the above procedure (as done
    by the DHCP Server).  

Arguments:

    ChainDlls - This is a set of DLL names in REG_MULTI_SZ format (as
    returned by Registry function calls).  This does not contain the
    name of the current DLL itself, but only the names of all DLLs
    that follow the current DLL. 

    CalloutVersion - This is the version that the Callout DLL is
    expected to support.  The current version number is 0.

    CalloutTbl - This is the cumulative set of Hooks that is needed by
    the current DLLs as well as all the DLLs in ChainDlls.   It is the
    responsibility of the current DLL to retrive the cumulative set of
    Hooks and merge that with its own set of hooks and return that in
    this table structure.  The table structure is defined above.

--*/
;

//EndExport(typedefs)

//BeginExport(macros)

//
//  Macros for ease of use.  Lots of code to handle exceptions when
//  they happen.
//

#define    _PROTECT1               try
#define    _PROTECT2               \
except(EXCEPTION_EXECUTE_HANDLER) \
{ \
      DhcpCalloutLogAV(GetExceptionCode());\
} 

#define    _XX(Fn)                 Dhcp ## Fn ## Hook
#define    WRAPPER(Fn, Params)     \
do{ \
    _PROTECT1 { \
        if(CalloutTbl. _XX(Fn)){ \
            CalloutTbl. _XX(Fn) Params ;\
        }\
    } _PROTECT2 \
}while(0)

#define    _GiveAddrPkt(P,Code,Type,A,Time) \
WRAPPER(AddressOffer, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (Code),\
    ntohl((P)->ReqContext.EndPointIpAddress),\
    (A),\
    (Type),\
    (Time),\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _DropPkt(P,Drop,Code)   \
WRAPPER(PktDrop, (&((P)->ReqContext.ReceiveBuffer),\
    &((P)->ReqContext.ReceiveMessageSize),\
    (Code),\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _NewPkt(P,Dropit)       \
WRAPPER(NewPkt, ( &((P)->ReqContext.ReceiveBuffer),\
    &((P)->ReqContext.ReceiveMessageSize),\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID*)&((P)->CalloutContext),\
     Dropit)\
)

//
// CALLOUT_CONTROL( ControlCode )
//

#define    CALLOUT_CONTROL(_ccode) WRAPPER(Control, (_ccode, NULL))

//
// CALLOUT_NEWPKT( Packet, fProcessIt )
//

#define    CALLOUT_NEWPKT(P,Drop)  _NewPkt(P,Drop)

//
// CALLOUT_DROPPED(Packet, DropReason)
//

#define    CALLOUT_DROPPED(P,Code) _DropPkt(P,DropPkt, Code)

//
// CALLOUT_SENDPKT(Packet)
//

#define    CALLOUT_SENDPKT(P)      \
WRAPPER(PktSend, (&((P)->ReqContext.SendBuffer),\
    &((P)->ReqContext.SendMessageSize),\
    DHCP_SEND_PACKET,\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _ProbPkt(P,Code,A)      \
WRAPPER(AddressDel, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (Code),\
    (P)->ReqContext.EndPointIpAddress,\
    (A),\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

//
// CALLOUT_CONFLICT(Packet)
//

#define    CALLOUT_CONFLICT(P)     _ProbPkt(P, DHCP_PROB_CONFLICT,P->PingAddress)

//
// CALLOUT_DECLINED(Packet, Address)
//

#define    CALLOUT_DECLINED(P,A)   _ProbPkt(P, DHCP_PROB_DECLINE, A)

//
// CALLOUT_RELEASE(Packet, Address)
//

#define    CALLOUT_RELEASE(P,A)    _ProbPkt(P, DHCP_PROB_RELEASE, A)

//
// CALLOUT_NACK_DHCP(Packet, Address)
//

#define    CALLOUT_NACK_DHCP(P,A)  _ProbPkt(P, DHCP_PROB_NACKED, A)

//
// CALLOUT_RENEW_BOOTP(Packet, Address, LeaseTime)
//

#define    CALLOUT_RENEW_BOOTP(P,Addr,Time) \
    _GiveAddrPkt(P, DHCP_GIVE_ADDRESS_OLD, DHCP_CLIENT_BOOTP, Addr, Time)

//
// CALLOUT_RENEW_DHCP(Packet, Address, Time, fExists)
//

#define    CALLOUT_RENEW_DHCP(P,Addr,Time,Exists) \
    _GiveAddrPkt(P, (Exists)?DHCP_GIVE_ADDRESS_OLD: \
       DHCP_GIVE_ADDRESS_NEW,DHCP_CLIENT_DHCP, Addr, Time)

//
// CALLOUT_MARK_OPTIONS(Packet, DhcpServerOptions)
//

#define    CALLOUT_MARK_OPTIONS(P,DhcpOptions) \
WRAPPER(HandleOptions, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (P), (LPVOID)((P)->CalloutContext), (DhcpOptions)))

//
// CALLOUT_PINGING(Packet)
//

#define    CALLOUT_PINGING(P)

//
// CALLOUT_DELETED(Address, HwAddress, HwLength, ClientType)
//

#define    CALLOUT_DELETED(Addr, HwAddr, HwLen, Type) \
    WRAPPER(DeleteClient, ((Addr), (HwAddr), (HwLen), 0, (Type)))

//EndExport(macros)

//BeginExport(externs)
extern
DHCP_CALLOUT_TABLE                 CalloutTbl;   // globals are init'ed to NULL
//EndExport(externs)

//BeginExport(multiple-redef-prevention)
#endif     _CALLOUT_H_
//EndExport(multiple-redef-prevention)

//
// Static Variables for this module
//

static BOOL Excepted = FALSE;
static DWORD Initialized = 0;
DHCP_CALLOUT_TABLE CalloutTbl;
HMODULE CalloutDll = NULL;

//
// Helper routines.
//

//BeginExport(fucntion)
VOID
DhcpCalloutLogAV(
    IN ULONG ExceptionCode
)   //EndExport(function)
/*++

Routine Description:

    This routine logs an event in the system event log about the fact
    that there was an exception in some of the callout DLLs.   It
    makes sure that this is done exactly once per server invocation. 

Arguments:

    ExceptionCode -- This ULONG value gives the exception number to log.

--*/
{
    DhcpPrint((DEBUG_ERRORS, "Callout caused 0x%lx"
               " exception. ignored\n",  ExceptionCode));
    if( FALSE == Excepted ) {
        Excepted = TRUE;
        DhcpServerEventLog(
            EVENT_SERVER_CALLOUT_UNHANDLED_EXCEPTION,
            EVENTLOG_ERROR_TYPE,
            ExceptionCode
        );
    }
}

//BeginExport(fucntion)
VOID
DhcpCalloutLogLoadFailure(
    IN      ULONG                  ExceptionCode
)   //EndExport(function)
/*++

Routine Description:

    This routine logs an event in the System event log.

Arguments:

    The exception code when the DLL LoadLibrary was attempted.

--*/
{
    DhcpPrint((DEBUG_ERRORS, "Callout caused 0x%lx " 
               "exception while loading. ignored\n", ExceptionCode));

    DhcpServerEventLog(
        EVENT_SERVER_CALLOUT_LOAD_EXCEPTION,
        EVENTLOG_ERROR_TYPE,
        ExceptionCode
        );
}

VOID
DhcpCalloutLogLoadSuccess(
    VOID
)
/*++

Routine Description:

   This routine logs the fact that a Callout DLL has been successfully
   loaded. 

--*/
{
    DhcpServerEventLog(
        EVENT_SERVER_CALLOUT_LOAD_SUCCESS,
        EVENTLOG_INFORMATION_TYPE,
        0
    );
}

DWORD
LoadDll(
    IN LPWSTR DllName,
    OUT HMODULE *Dll,
    OUT LPDHCP_ENTRY_POINT_FUNC *EntryPoint
)
/*++

Routine Description:

   This routine tries to load a DLL specified by the DllName parameter
   and retrive its entrypoint procedure.   It traps any exceptions
   generated by LoadLibrary and in case of error it returns the error
   code and also logs an event to this effect.

Arguments:

   DllName - wide character name of the DLL to load.
   Dll - output pointer where the module handle will be stored.
   EntryPoint - pointer to entrypoint procedure, filled in if
   successful.

Return Values:

   If the function succeeds, it returns ERROR_SUCCESS and fills in the
   paramters Dll and Entrypoint.

   On error, it returns Win32 errors.

--*/
{
    DWORD Err;

    try {
        //
        // Protect from any exceptions by the callout DLL
        //

        *Dll = NULL;
        *EntryPoint = NULL;

        *Dll = LoadLibrary(DllName);
        if( NULL != *Dll ) {
            *EntryPoint = (LPDHCP_ENTRY_POINT_FUNC)GetProcAddress( 
                *Dll, 
                DHCP_CALLOUT_ENTRY_POINT
                );
        } else {
            *EntryPoint = NULL;
        }

        if( NULL != *EntryPoint ) return ERROR_SUCCESS;

        //
        // Load failed.
        //

        Err = GetLastError();
        DhcpServerEventLog(
            EVENT_SERVER_CALLOUT_LOAD_FAILED,
            EVENTLOG_WARNING_TYPE,
            Err
            );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        DhcpCalloutLogLoadFailure(Err = GetExceptionCode());
    }
    
    if( *Dll ) FreeLibrary(*Dll);
    *Dll = NULL;
    *EntryPoint = NULL;
    return Err;
}

DWORD
GetTable(
    IN HMODULE Dll,
    IN LPWSTR DllList,
    IN LPDHCP_ENTRY_POINT_FUNC EntryPoint
)
/*++

Routine Description:

    This routine attempts to get the table of hooks from the
    entrypoint routine, and if it succeeds, it also remembers the Dll
    handle in the file-static variable CalloutDll.  It traps
    exceptions and returns the exception code as error.

Arguments:

    Dll -- DLL module handle
    
    DllList -- REG_MULTI_SZ format of Dll names of those that follow
    current DLL.

    EntryPoint -- entrypoint routine.

Returns:

    Returns ERROR_SUCCESS on Success and Win32 errors on failure.

--*/
{
    DWORD Err;

    try {
        //
        // Protect from exceptions caused by entrypoint table ..
        //

        DllList += wcslen(DllList) + 1;
        Err = EntryPoint(
            DllList,
            0,
            &CalloutTbl
            );
        if( ERROR_SUCCESS == Err ) {
            CALLOUT_CONTROL(DHCP_CONTROL_START);
            CalloutDll = Dll;
            DhcpCalloutLogLoadSuccess();
            return ERROR_SUCCESS;
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) { 
        DhcpCalloutLogLoadFailure(Err = GetExceptionCode());
    }

    //
    // Cleanup on error
    //

    memset(&CalloutTbl,0,sizeof(CalloutTbl));
    CalloutDll = NULL;
    
    return Err;
}

VOID
FreeTable(                                        // free table and module..
    VOID
)
/*++

Routine description:

    This routine frees the library and cleans up the callout table. 

--*/
{
    DhcpAssert(NULL != CalloutDll); 
    if( NULL != CalloutDll ) {
        CALLOUT_CONTROL(DHCP_CONTROL_STOP);
        memset(&CalloutTbl,0,sizeof(CalloutTbl));
        FreeLibrary(CalloutDll);
        CalloutDll = NULL;
    }
}

//
// Exported Routines.
//

//BeginExport(function)
DWORD
CalloutInit(                                      // init callout fn table etc..
    VOID
)   //EndExport(function)
/*++

Routine Description:

    This routine reads the registry, initializes callout tables etc.
    It can be called multiple times (it executes only once).

    It is not thread safe, and it depends on debug module and the 
    eventlogger module, registry module.

Return Value:

    In case of failure, it returns Win32 errors and also cleans up its
    internal structures.

--*/
{
    DWORD Err;
    HKEY ParamKey;
    LPWSTR AllocedMem, DllList;
    LPDHCP_ENTRY_POINT_FUNC EntryPoint;
    HMODULE Dll;
    DWORD fEnabled;
    
    if( 0 != Initialized ) {
        return ERROR_SUCCESS;
    }

    Excepted = FALSE;

    Err = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        DHCP_CALLOUT_LIST_KEY,
        0,
        KEY_ALL_ACCESS,
        &ParamKey
    );
    if( ERROR_SUCCESS != Err ) {
        return ERROR_SUCCESS;
    }

    //
    // Do not load the callout DLLs if callouts are not enabled.
    //
    
    Err = DhcpRegGetValue(
        ParamKey, DHCP_CALLOUT_ENABLE_VALUE, REG_DWORD,
        (LPBYTE)&fEnabled );
    if( ERROR_SUCCESS == Err && 0 == fEnabled ) {
        RegCloseKey(ParamKey);
        return ERROR_SUCCESS;
    }
    
    DllList = NULL;
    Err = DhcpRegGetValue(
        ParamKey,
        DHCP_CALLOUT_LIST_VALUE,
        DHCP_CALLOUT_LIST_TYPE,
        (LPBYTE)&DllList
    );
    RegCloseKey(ParamKey);
    if( ERROR_SUCCESS != Err ) {
        return ERROR_SUCCESS;
    }

    for(  AllocedMem = DllList ;
          0 != wcslen(DllList) ; 
          DllList += 1 + wcslen(DllList)
        ) {

        Dll = NULL;
        Err = LoadDll(DllList, &Dll, &EntryPoint);
        if( ERROR_SUCCESS != Err ) {
            DhcpPrint((DEBUG_ERRORS, "Could not load dll:"
                       " %ws (0x%lx)\n", DllList, Err));
            continue; 
        }
        Err = GetTable(Dll, DllList, EntryPoint);
        if( ERROR_SUCCESS != Err ) {
            DhcpPrint((DEBUG_ERRORS, "Could not get tbl for" 
                       "  dll: %ws (0x%lx)\n", DllList, Err));
            FreeLibrary(Dll);
        } else {
            //
            // Loaded library, got entrypoint and callout tables..
            //

            Initialized ++;
            DhcpPrint((DEBUG_ERRORS, "Initialized callout dll"
                       " successfully\n")); 
            break;
        }
    }

    MIDL_user_free(AllocedMem);
    return ERROR_SUCCESS;
}

//BeginExport(function)
VOID
CalloutCleanup(
    VOID
)   //EndExport(function)
/*++

Routine Description:

    This routine is the converse of the Initialize routine and it
    cleans up any handles and the callout table.

--*/
{
    Initialized --;
    if(0 != Initialized) return ;
    FreeTable(); 
    Excepted = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\auditlog.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV (originally written by Cheng Yang (t-cheny))
//  Description: Implements dhcp server auditlogging in an improved way.
//================================================================================


#include "dhcppch.h"
#include "rpcapi.h"

#include <time.h>

//================================================================================
//  here are the parameters that affect the server behaviour
//================================================================================
LPWSTR   AuditLogFilePath = NULL;                 // where to log stuff
LPWSTR   AuditLogFileName = NULL;                 // full file name of audit log..
DWORD    DiskSpaceCheckInterval = 0;              // how often to check for diskspace
DWORD    CurrentDay = 0;                          // what day are we on now?
DWORD    MaxSizeOfLogFile = 0;                    // how big in MBytes can each file be?
DWORD    MinSpaceOnDisk = 0;                      // how much space should exist on disk?

static
DWORD    Initialized = 0;                         // is this module initialized yet?
DWORD    AuditLogErrorLogged = 0;                 // already logged error?
HANDLE   AuditLogHandle = INVALID_HANDLE_VALUE;   // handle to file to log in..
CRITICAL_SECTION AuditLogCritSect;                // used for serializeing multiple logs..

//================================================================================
//  here are the defaults for the above parameters where applicable..
//================================================================================
#define  DEFAULT_DISK_SPACE_CHECK_INTERVAL        50 // once every fifty messages
#define  MIN_DISK_SPACE_CHECK_INTERVAL            2  // check once every two messages
#define  MAX_DISK_SPACE_CHECK_INTERVAL            0xFFFFFFF0
#define  DEFAULT_MAX_LOG_FILE_SIZE                70 // 70 megs for all files 7 file together
#define  DEFAULT_MIN_SPACE_ON_DISK                20 // atleast 20 megs of space must be available..

//================================================================================
//  here's the list of string names as required for reading away from the registry..
//================================================================================
#define  DHCP_REGSTR_SPACE_CHECK_INTERVAL         L"DhcpLogDiskSpaceCheckInterval"
#define  DHCP_REGSTR_MAX_SZ_OF_FILES              L"DhcpLogFilesMaxSize"
#define  DHCP_REGSTR_MIN_SPACE_ON_DISK            L"DhcpLogMinSpaceOnDisk"

//================================================================================
//  helper functions
//================================================================================
LPWSTR
DefaultLogFileName(                               // allocate space and return string
    VOID
)
{
    return DhcpOemToUnicode(DhcpGlobalOemDatabasePath, NULL);
}


//
// Open an exising log file or create a new one?
//

BOOL
OpenExisting(
    IN      LPWSTR                 FileName
)
{
    DWORD                          Error;
    BOOL                           Status;
    FILETIME                       Now;
    LONGLONG                       ADayInFileTime;
    HANDLE                         hndl;
    WIN32_FIND_DATA                FindData;

    // Get the last write date. FindFirstFile returns
    // UTC time 
    hndl = FindFirstFile( FileName, &FindData );

    if( INVALID_HANDLE_VALUE == hndl ) {
	return FALSE;
    }

    if ( !FindClose( hndl )) {
	return FALSE;
    }

    // File already exists. Get the time and compare it.
    GetSystemTimeAsFileTime( &Now ); // in UTC

    // Is this file created more than a day ago? 

    ADayInFileTime = 1 * 24*60*60;      // in seconds
    ADayInFileTime *= 10000000;     // in 100 nano seconds..
    (*( LONGLONG * ) &Now) =
	(*(LONGLONG *) &Now) - ADayInFileTime;
    if( CompareFileTime( &FindData.ftCreationTime, &Now ) >= 0 ) {
        DhcpPrint((DEBUG_AUDITLOG, "Opening existing file %ws\n",
		   FileName ));
        return TRUE;
    }

    // this *is* a fresh file, delete file if it exists before returning
    ( void ) DeleteFile( FileName ); // ignore return value
    return FALSE;
} // OpenExisting()

LPWSTR
FormAuditLogFileName(                             // given directory and day, form file name

    IN      LPWSTR                 FilePath,      // directory where audit log file would be
    IN      DWORD                  Day            // current day of week
)
{
    LPWSTR                         FileName;
    LPWSTR                         DayOfWeek;
    DWORD                          Size;

    DhcpAssert( Day <= 6 );                       // assuming all of us work 7 day week <grin>
    DayOfWeek = GETSTRING((Day + DHCP_LOG_FILE_NAME_SUNDAY));

    Size = wcslen(FilePath) + wcslen(DayOfWeek) + sizeof(DHCP_KEY_CONNECT);
    FileName = DhcpAllocateMemory(Size*sizeof(WCHAR));
    if( NULL == FileName ) return NULL;

    wcscpy(FileName, FilePath);                   // concat FilePath,DayOfWeek w/ L"\\" inbetweem
    wcscat(FileName, DHCP_KEY_CONNECT);
    wcscat(FileName, DayOfWeek);

    return FileName;
}

VOID
LogStartupFailure(                                // log in the system event log about auditlog startup failure
    IN      DWORD                  Error          // error code (win32) reason for failure
)
{
    DhcpServerEventLog(                           // not much to this one really. just log event.
        EVENT_SERVER_INIT_AUDIT_LOG_FAILED,
        EVENTLOG_ERROR_TYPE,
        Error
    );
}

DWORD
AuditLogStart(                                    // open file handles etc and start
    VOID
)
{
    LPWSTR                         FileName;      // file name of audit log file..
    LPWSTR                         Header;        // header that we want in the file..
    LPSTR                          szHeader;
    DWORD                          Creation;      // how to create?
    DWORD                          Tmp;
    DWORD                          Error;
    HMODULE                        SelfLibrary;   // for some string

    DhcpPrint((DEBUG_AUDITLOG, "AuditLogStart called\n"));

    if( NULL != AuditLogFileName ) {              // free old file name if exists..
        DhcpFreeMemory(AuditLogFileName);
    }

    AuditLogFileName = FormAuditLogFileName(AuditLogFilePath, CurrentDay);
    FileName = AuditLogFileName;
    if( NULL == FileName ) return ERROR_NOT_ENOUGH_MEMORY;

    if( OpenExisting(FileName) ) {           // old log file from last week?
        Creation = OPEN_ALWAYS;
    } else {                                      // this is not an old log file, but was just used recently..
        Creation = CREATE_ALWAYS;
    }

    AuditLogHandle = CreateFile(                  // now open this file
        FileName,                                 // this is "Dhcp server log for Sunday" types..
        GENERIC_WRITE,                            // access
        FILE_SHARE_READ,                          // allow others to only read this file
        NULL,                                     // default security
        Creation,                                 // start from scratch or just use it as it is?
        FILE_ATTRIBUTE_NORMAL,                    // FILE_FLAG_SEQUENTIAL_SCAN may be only for reads?
        NULL                                      // no template handle required
    );
    if( INVALID_HANDLE_VALUE == AuditLogHandle ){ // could not open the file for some strange reason?
        Error = GetLastError();
        DhcpPrint((DEBUG_AUDITLOG, "CreateFile(%ws,0x%lx) failed %ld\n", FileName, Creation, Error));
        LogStartupFailure(Error);                 // log this problem and return..
        DhcpFreeMemory(FileName);                 // dont lose this memory.. free it!
        AuditLogFileName = NULL;
        return Error;
    }

    SetFilePointer(                               // go to end of file if we're using existing file
        AuditLogHandle,
        0,
        NULL,
        FILE_END
    );

    SelfLibrary = LoadLibrary(DHCP_SERVER_MODULE_NAME);
    if( NULL == SelfLibrary ) {                   // alright, cant get our own dll handle? uhg?
        DhcpAssert(FALSE);                        // whatever the reason, i'd like to konw.. <smile>
        return ERROR_SUCCESS;                     // not that this matters... so let go
    }

    // 
    // Dump the header only if creating a new file
    //

    if ( CREATE_ALWAYS == Creation ) {
        // now get the header string out
        Error = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                               FORMAT_MESSAGE_FROM_HMODULE,
                               SelfLibrary,                     // dhcpssvc.dll module actually.
                               DHCP_IP_LOG_HEADER,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                               (LPWSTR)&Header, 1, NULL );
        if( 0 == Error ) {                            // for some reason, we could not find this string?
            DhcpAssert(FALSE);
            FreeLibrary(SelfLibrary);
            return ERROR_SUCCESS;
        }


        szHeader = DhcpUnicodeToOem( Header, NULL);
        if( NULL != szHeader ) {
            // alright, could convert to simple ansi code page
            // bug #22349 requires file to be written in ANSI
            OemToCharBuffA(szHeader, szHeader, strlen(szHeader) );
            WriteFile( AuditLogHandle, szHeader, strlen(szHeader), &Tmp, NULL);
            DhcpFreeMemory(szHeader);
        }

        (LocalFree)(Header);                          // protect from #defines for LocalFree
    } // if file created

    FreeLibrary(SelfLibrary);                     // free library, dont need it anymore

    return ERROR_SUCCESS;                         // dunnet.
}

VOID
AuditLogStop(                                     // stop logging, release resources?
    VOID                                          // lot easier, just close handle..
)
{
    DhcpPrint((DEBUG_AUDITLOG, "AuditLogStop called\n"));
    if( INVALID_HANDLE_VALUE == AuditLogHandle ){ // never started?
        DhcpPrint((DEBUG_AUDITLOG, "AuditLog was never started..\n"));
    } else {
        CloseHandle(AuditLogHandle);
        AuditLogHandle = INVALID_HANDLE_VALUE;
    }

}

BOOL
IsFileTooBigOrDiskFull(                           // is the auditlog file too big?
    IN      HANDLE                 FileHandle,    // file to check size of
    IN      LPWSTR                 FileName,      // if no handle, use file name
    IN      DWORD                  MaxSize,       // how big can file get? (MBytes)
    IN      DWORD                  MinDiskSpace   // how much space should be left on disk (MBytes)
)
{
    BOOL                    Status;
    DWORD                   Error;
    LARGE_INTEGER           Sz;
    WCHAR                   Drive[4];
    ULARGE_INTEGER          FreeSpace, DiskSize;

    
    if( INVALID_HANDLE_VALUE == FileHandle ) {
	WIN32_FILE_ATTRIBUTE_DATA  Attributes;

        if(!GetFileAttributesEx(FileName, GetFileExInfoStandard, &Attributes) ) {
            Error = GetLastError();               // could not get file size?
            if( ERROR_FILE_NOT_FOUND == Error ) { // file does not exist?
                Attributes.nFileSizeHigh = Attributes.nFileSizeLow = 0;
            } 
	    else {
                DhcpPrint((DEBUG_ERRORS, "GetFileAttributesEx failed 0x%lx\n", Error));
                return TRUE;
            }
        } // if

	Sz.HighPart = Attributes.nFileSizeHigh;
	Sz.LowPart = Attributes.nFileSizeLow;
    }  // if
    else {    // got the file handle. do easy check.
	if ( !GetFileSizeEx( FileHandle, &Sz )) {
	    DhcpPrint(( DEBUG_ERRORS, "GetFileSizeEx() failed\n" ));
	    return TRUE;
	}

    } // else

    Sz.QuadPart >>= 20;  // In MB

    DhcpPrint(( DEBUG_AUDITLOG, "File size is %lu\n", Sz.LowPart ));

    if( Sz.LowPart >= MaxSize ) return TRUE;      // ok, file is too big..

    FileName = AuditLogFilePath;                  // use this to calculate the drive..
    while( iswspace(*FileName) ) FileName++;      // skip leading space

    Drive[0] = *FileName;                         // here goes the drive letter calculation
    Drive[1] = L':';
    Drive[2] = DHCP_KEY_CONNECT_CHAR;
    Drive[3] = L'\0';

    Status = GetDiskFreeSpaceEx( Drive, &FreeSpace, &DiskSize, NULL );
    if( FALSE == Status ) {
	// system call failed?
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, 
		   "GetDiskFreeSpace(%ws): 0x%lx\n",
		   Drive, Error));
        return TRUE;
    } // if 

    FreeSpace.QuadPart >>= 20;     // In MB

    DhcpPrint((DEBUG_AUDITLOG, "FreeSpace is %lu MEGS\n", FreeSpace));
    return (( DWORD ) FreeSpace.QuadPart <= MinDiskSpace );  // reqd free space left?
    
} // IsFileTooBigOrDiskFull()

BOOL
HasDayChanged(                                    // have we moved over to new day?
    IN OUT  DWORD                 *CurrentDay     // if this is not current day, set it to current day..
)
{
    SYSTEMTIME                     SysTime;

    GetLocalTime(&SysTime);                       // get current time
    if( *CurrentDay == SysTime.wDayOfWeek ) {     // no change
        return FALSE;
    }
    *CurrentDay = SysTime.wDayOfWeek;             // since there was a change, correct day..
    return TRUE;
}

//================================================================================
//  initialization and cleanup of this module
//================================================================================

//BeginExport(function)
DWORD
DhcpAuditLogInit(                                 // intialize audit log
    VOID                                          // must be called after initializing registry..
)   //EndExport(function)
{
    DWORD                Error;
    SYSTEMTIME           SysTime;
    BOOL                 BoolError;
    HKEY                 RegKey;
    DWORD                KeyDisposition;
    
    if( 0 != Initialized ) {                      // already initialized?
        return ERROR_ALREADY_INITIALIZED;
    }

    if( NULL == DhcpGlobalRegParam ) {            // registry is not initialized yet?
        DhcpAssert(FALSE);                        // should not happen really.
        return ERROR_INTERNAL_ERROR;
    }

    AuditLogFilePath = NULL;
    Error = DhcpRegGetValue(                      // get the audit log file name
        DhcpGlobalRegParam,
        DHCP_LOG_FILE_PATH_VALUE,
        DHCP_LOG_FILE_PATH_VALUE_TYPE,
        (LPBYTE)&AuditLogFilePath
    );
    if( ERROR_SUCCESS != Error
	|| NULL == AuditLogFilePath
	|| L'\0' == *AuditLogFilePath ) {

        AuditLogFilePath = DefaultLogFileName();  // use the default file name if none specified
        if( NULL == AuditLogFilePath ) {          // could not allocate space or some such thing..
            return ERROR_NOT_ENOUGH_MEMORY;
        }


	DhcpPrint(( DEBUG_ERRORS,
		    "Auditlog is invalid. Defaulting to %ws\n",
		    AuditLogFilePath ));

	// Add value to the key
	Error = RegSetValueEx( DhcpGlobalRegParam,
			       DHCP_LOG_FILE_PATH_VALUE,
			       0, DHCP_LOG_FILE_PATH_VALUE_TYPE,
			       ( LPBYTE ) AuditLogFilePath,
			       ( wcslen( AuditLogFilePath) + 1) * sizeof( WCHAR ));

	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}

    } // if

    DhcpPrint(( DEBUG_MISC,
		"Initializing auditlog at (%ws) ... \n",
		AuditLogFilePath ));

    BoolError = CreateDirectoryPathW(
        AuditLogFilePath,
        DhcpGlobalSecurityDescriptor
        );
    if( FALSE == BoolError ) {

	// Log an event
	DhcpServerEventLog( EVENT_SERVER_AUDITLOG_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE,
			    GetLastError());
        return Error = GetLastError();
    }
    
    GetLocalTime(&SysTime);                       // calculate current day
    CurrentDay = SysTime.wDayOfWeek;              // 0 ==> sunday, 1 ==> monday etc..

    Error = DhcpRegGetValue(                      // get the disk space check interval
        DhcpGlobalRegParam,
        DHCP_REGSTR_SPACE_CHECK_INTERVAL,
        REG_DWORD,
        (LPBYTE)&DiskSpaceCheckInterval
    );
    if( ERROR_SUCCESS != Error ) {                // no value specified? use default
        DiskSpaceCheckInterval = DEFAULT_DISK_SPACE_CHECK_INTERVAL;
    } 

    if( DiskSpaceCheckInterval < MIN_DISK_SPACE_CHECK_INTERVAL ) {
        DiskSpaceCheckInterval = MIN_DISK_SPACE_CHECK_INTERVAL;
    }

    if( DiskSpaceCheckInterval > MAX_DISK_SPACE_CHECK_INTERVAL ) {
        DiskSpaceCheckInterval = MAX_DISK_SPACE_CHECK_INTERVAL;
    }

    Error = DhcpRegGetValue(                      // get the max size of all log files etc..
        DhcpGlobalRegParam,
        DHCP_REGSTR_MAX_SZ_OF_FILES,
        REG_DWORD,
        (LPBYTE)&MaxSizeOfLogFile
    );
    if( ERROR_SUCCESS != Error ) {                // no value specified? use default
        MaxSizeOfLogFile = DEFAULT_MAX_LOG_FILE_SIZE;
    }

    Error = DhcpRegGetValue(                      // get min space on disk value
        DhcpGlobalRegParam,
        DHCP_REGSTR_MIN_SPACE_ON_DISK,
        REG_DWORD,
        (LPBYTE)&MinSpaceOnDisk
    );
    if( ERROR_SUCCESS != Error ) {                // no value specified? use defaults
        MinSpaceOnDisk = DEFAULT_MIN_SPACE_ON_DISK;
    } else if( 0 == MinSpaceOnDisk ) {
        MinSpaceOnDisk = DEFAULT_MIN_SPACE_ON_DISK; // dont allow zeroes..
    }

    try {
        InitializeCriticalSection(&AuditLogCritSect); 
    }except( EXCEPTION_EXECUTE_HANDLER ) {

        // shouldnt happen but you never know.
        Error = GetLastError( );
        return( Error );
    }

    Initialized ++;                               // mark it as initialized

    // Now get hold of the file and do the rest..
    Error = AuditLogStart();                      // start hte logging

    return ERROR_SUCCESS;                         // ignore startup errors..
}

//BeginExport(function)
VOID
DhcpAuditLogCleanup(                              // undo the effects of the init..
    VOID
)   //EndExport(function)
{
    if( 0 == Initialized ) {                      // was never initialized ...
        return;
    }

    Initialized --;                               // alright, we're as good as clean
    DhcpAssert( 0 == Initialized );

    AuditLogStop();                               // stop logging..
    if( NULL != AuditLogFilePath ) {              // cleanup any memory we got
        DhcpFreeMemory(AuditLogFilePath);
        AuditLogFilePath = NULL;
    }
    if( NULL != AuditLogFileName ) {
        DhcpFreeMemory(AuditLogFileName);
        AuditLogFileName = NULL;
    }

    DeleteCriticalSection(&AuditLogCritSect);     // freeup the crit section resources
}

//================================================================================
//  actual logging routine
//================================================================================

//DOC This routine logs the foll information: Date &Time, IpAddress, HwAddress, M/cName
//DOC and ofcourse, the task name.  All this goes into the current open auditlog file..
//DOC This routine makes absolutely no checks on file size etc.. (which is why "blind")
DWORD
DhcpUpdateAuditLogBlind(                          // do the actual logging
    IN      DWORD                  Task,          // DHCP_IP_LOG_* events..
    IN      LPWSTR                 TaskName,      // name of task
    IN      DHCP_IP_ADDRESS        IpAddress,     // ipaddr related to task
    IN      LPBYTE                 HwAddress,     // hardware addr related to task
    IN      DWORD                  HwLen,         // size of above buffer in bytes
    IN      LPWSTR                 MachineName,   // name of m/c related to task
    IN      ULONG                  ErrorCode      // Error code
)
{
    DWORD                          Error;
    DWORD                          i, n, c, Size;
    WCHAR                          DateBuf[9], TimeBuf[9], UserName[UNLEN+DNLEN+4];
    LPSTR                          Format1 = "%.2d,%ls,%ls,%ls,%hs,%ls,";
    LPSTR                          Format2 = "%.2d,%ls,%ls,%ls,%hs,%ls,%ld";
    LPSTR                          Format = (ErrorCode == 0)?Format1 : Format2;
    LPSTR                          LogEntry, Temp;
    LPSTR                          IpAddressString;

    if( !DhcpGlobalAuditLogFlag ) {               // auditlogging turned off.
        return ERROR_SUCCESS;
    }

    if( INVALID_HANDLE_VALUE == AuditLogHandle ){ // ==> could not start audit logging!!..
        DhcpPrint((DEBUG_ERRORS, "Not logging as unable to start audit logging..\n"));
        return ERROR_SUCCESS;
    }

    if( NO_ERROR != GetUserAndDomainName( (LPWSTR)UserName ) ) {
        UserName[0] = L'\0';
    }

    Error = ERROR_SUCCESS;

    _wstrdate( DateBuf );                          // date
    _wstrtime( TimeBuf );                          // time
    if( NULL == TaskName ) TaskName = L"";        // should not really happen.. but.
    if( NULL == MachineName ) MachineName = L"";  // like empty string better
    if( 0 == IpAddress ) IpAddressString = "";    // ditto
    else IpAddressString = DhcpIpAddressToDottedString(IpAddress);

    if ( NULL == IpAddressString ) {
        IpAddressString = "";
    }

    Size = DHCP_CB_MAX_LOG_ENTRY + HwLen*2 + wcslen(DateBuf);
    Size += wcslen(TaskName) + wcslen(TimeBuf);
    Size += strlen(IpAddressString) + wcslen(MachineName);
    Size += wcslen(UserName) + 10;

    LogEntry = DhcpAllocateMemory( Size );
    if( NULL == LogEntry ) {                      // unhappy state of affairs..
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Temp = LogEntry;

    Temp += wsprintfA(
        Temp, Format, Task, DateBuf, TimeBuf,
        TaskName, IpAddressString, MachineName, ErrorCode );
    for( i = 0; i < HwLen ; i ++ ) {              // now dump the hw address
        Temp += wsprintfA(Temp, "%.2X", *(HwAddress++));
    }

    Temp += wsprintfA(Temp, ",%ls", UserName );
    strcpy(Temp, "\r\n");

    DhcpAssert( strlen(LogEntry) < Size);

    if( !WriteFile(AuditLogHandle, LogEntry, strlen(LogEntry), &n, NULL) ) {
        Error = GetLastError();                   // write failed for some strange reason..

        DhcpPrint((DEBUG_ERRORS, "WriteFile: 0x%lx\n", Error));
        DhcpFreeMemory(LogEntry);
        goto Cleanup;
    }

    DhcpFreeMemory(LogEntry);
    return ERROR_SUCCESS;

  Cleanup:

    if( AuditLogErrorLogged ) {                   // nothing much to do..
        return Error;
    }

    AuditLogErrorLogged = TRUE;                   // we are just logging it..
    DhcpServerEventLog(
        EVENT_SERVER_AUDIT_LOG_APPEND_FAILED,
        EVENTLOG_ERROR_TYPE,
        Error
    );

    return Error;
}

BOOL                               DiskSpaceLow = FALSE;
DWORD                              Counter = 0;   // counter for checking dsk sp.

//DOC This routine just causes the next audit log to check for change of day..
//BeginExport(function)
VOID
DhcpChangeAuditLogs(                              // shift for new log
    VOID
)   //EndExport(function)
{
    ULONG Error, Day;
    EnterCriticalSection(&AuditLogCritSect);      // take readlocks here..
    Day = CurrentDay;
    if( HasDayChanged( &CurrentDay)) {            // ok day has changed..
        AuditLogStop();                           // stop logging
        Error = AuditLogStart();                  // pickup new stuff..
        if( ERROR_SUCCESS != Error ) {            // couldn't restart..so need to try later..
            CurrentDay = Day;
            AuditLogStop();
        }
        AuditLogErrorLogged = FALSE;              // reset it each day..
        DiskSpaceLow = FALSE;                     // reset disk space low..
    }
    LeaveCriticalSection(&AuditLogCritSect);      // use read/wrtie locks..
}

//DOC This routine logs the foll information: Date &Time, IpAddress, HwAddress, M/cName
//DOC and ofcourse, the task name.  All this goes into the current open auditlog file..
DWORD
DhcpUpdateAuditLogEx(                             // do the actual logging
    IN      DWORD                  Task,          // DHCP_IP_LOG_* events..
    IN      LPWSTR                 TaskName,      // name of task
    IN      DHCP_IP_ADDRESS        IpAddress,     // ipaddr related to task
    IN      LPBYTE                 HwAddress,     // hardware addr related to task
    IN      DWORD                  HwLen,         // size of above buffer in bytes
    IN      LPWSTR                 MachineName,   // name of m/c related to task
    IN      ULONG                  ErrorCode      // additional error code
)
{
    DWORD                          Error;
    DWORD                          Status;

    Error = ERROR_SUCCESS;

    if( !Initialized ) return ERROR_SUCCESS;

    EnterCriticalSection(&AuditLogCritSect);      // take readlocks here..

    if( 0 == Counter ) {                          // time to make checks..
        Counter = DiskSpaceCheckInterval+1;       // reset counter

        if( IsFileTooBigOrDiskFull(AuditLogHandle, AuditLogFileName, MaxSizeOfLogFile/7, MinSpaceOnDisk) ) {
            if( FALSE == DiskSpaceLow ) {         // it just got low?
                DiskSpaceLow = TRUE;
                DhcpUpdateAuditLogBlind(          // log that we are low on disk space..
                    DHCP_IP_LOG_DISK_SPACE_LOW,
                    GETSTRING(DHCP_IP_LOG_DISK_SPACE_LOW_NAME),
                    0,
                    NULL,
                    0,
                    NULL,
                    0
                );
                AuditLogStop();                   // stop logging, no poing doing this
            }
        } else {
            if( TRUE == DiskSpaceLow ) {          // was stopped before
                AuditLogStart();
                DiskSpaceLow = FALSE;
            }

        }
    }
    Counter --;                                   // decrement this once..

    if( FALSE == DiskSpaceLow ) {                 // got some space..
        Error = DhcpUpdateAuditLogBlind(          // no checks, update of log ..
            Task,
            TaskName,
            IpAddress,
            HwAddress,
            HwLen,
            MachineName,
            ErrorCode
        );
    }

    LeaveCriticalSection(&AuditLogCritSect);      // use read/wrtie locks..

    return Error;
}

DWORD
DhcpUpdateAuditLog(                               // do the actual logging
    IN      DWORD                  Task,          // DHCP_IP_LOG_* events..
    IN      LPWSTR                 TaskName,      // name of task
    IN      DHCP_IP_ADDRESS        IpAddress,     // ipaddr related to task
    IN      LPBYTE                 HwAddress,     // hardware addr related to task
    IN      DWORD                  HwLen,         // size of above buffer in bytes
    IN      LPWSTR                 MachineName    // name of m/c related to task
)
{
    return DhcpUpdateAuditLogEx(Task, TaskName, IpAddress, HwAddress, HwLen, MachineName, 0);
}

//================================================================================
//  here are audit log api calls to set the various parameters..
//================================================================================

//BeginExport(function)
DWORD
AuditLogSetParams(                                // set some auditlogging params
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
)   //EndExport(function)
{
    DWORD                          Error;

    Error = CreateDirectoryPathW(
        AuditLogDir, DhcpGlobalSecurityDescriptor );
    if( FALSE == Error ) return GetLastError();
        
    Error = RegSetValueEx(                         // write the info to the registry
        DhcpGlobalRegParam,
        DHCP_LOG_FILE_PATH_VALUE,
        0,
        DHCP_LOG_FILE_PATH_VALUE_TYPE,
        (LPBYTE)AuditLogDir,
        (NULL == AuditLogDir ) ? 0 : (wcslen(AuditLogDir)+1)*sizeof(WCHAR)
    );
    if( ERROR_SUCCESS != Error ) {                 // could not do it?
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(LOG_FILE_PATH):0x%lx\n", Error));
        return Error;
    }

    Error = RegSetValueEx(                         // write the info to the registry
        DhcpGlobalRegParam,
        DHCP_REGSTR_SPACE_CHECK_INTERVAL,
        0,
        REG_DWORD,
        (LPBYTE)&DiskCheckInterval,
        sizeof(DiskCheckInterval)
    );
    if( ERROR_SUCCESS != Error ) {                 // could not do it?
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(SPACE_CHECK_INTERVAL):0x%lx\n", Error));
        return Error;
    }

    Error = RegSetValueEx(                         // write the info to the registry
        DhcpGlobalRegParam,
        DHCP_REGSTR_MAX_SZ_OF_FILES,
        0,
        REG_DWORD,
        (LPBYTE)&MaxLogFilesSize,
        sizeof(MaxLogFilesSize)
    );
    if( ERROR_SUCCESS != Error ) {                 // could not do it?
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(MAX_SZ_OF_FILES):0x%lx\n", Error));
        return Error;
    }

    Error = RegSetValueEx(                         // write the info to the registry
        DhcpGlobalRegParam,
        DHCP_REGSTR_MIN_SPACE_ON_DISK,
        0,
        REG_DWORD,
        (LPBYTE)&MinSpaceOnDisk,
        sizeof(MinSpaceOnDisk)
    );
    if( ERROR_SUCCESS != Error ) {                 // could not do it?
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(MIN_SPACE_ON_DISK):0x%lx\n", Error));
        return Error;
    }

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
AuditLogGetParams(                                // get the auditlogging params
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDiskP    // ditto
)   //EndExport(function)
{
    DWORD     Error;

    if( AuditLogDir ) {
	*AuditLogDir =  CloneLPWSTR( AuditLogFilePath );
    }

    if( DiskCheckInterval ) {
	*DiskCheckInterval = DiskSpaceCheckInterval;
    }

    if( MaxLogFilesSize ) {
	*MaxLogFilesSize = MaxSizeOfLogFile;
    }

    if( MinSpaceOnDiskP ) {
	*MinSpaceOnDiskP = MinSpaceOnDisk;
    }

    return ERROR_SUCCESS;
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\bootphlp.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    optapi.c --> modified to bootphlp.c

Abstract:

    This module contains the implementation of DHCP Option APIs.

Author:

    Madan Appiah (madana)  27-Sep-1993

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny)  17-Jul-1996  vendor specific information
    Frankbee              9/6/96       #ifdef'd vendor specific stuff for sp1

--*/

#include "dhcppch.h"
#include <strsafe.h>

BOOL
ScanBootFileTable(
    WCHAR *wszTable,
    char *szRequest,
    char *szBootfile,
    char  *szServer
    )
/*++

Routine Description:

    Searches the specified boot file table for the specified request.

    As a side effect, commas in wszTable are replaced with L'\0'

    .
Arguments:

    wszTable - Boot file table, stored as follows:
               <generic boot file name1>,[<boot server1>],<boot file name1>L\0
               <generic boot file name1>,[<boot server1>],<boot file name1>L\0
               \0
    szRequest   - the generic boot file name requested by the caller
    szBootfile  - if the function was successful, stores the boot file name
                  associated with szRequest.
    szServer    - if the function was successful, stores the boot server name
                  associated with szRequest.


Return Value:
        Success  - TRUE
        Failure  - FALSE
  .

--*/
{
    char szGenericName[ BOOT_FILE_SIZE ];

    DhcpAssert( strlen( szRequest ) <= BOOT_FILE_SIZE );

	while( *wszTable )
	{
		size_t cbEntry;
        DWORD  dwResult;

        cbEntry = wcslen( wszTable ) + 1;

        dwResult = DhcpParseBootFileString(
                                   wszTable,
                                   szGenericName,
                                   szBootfile,
                                   szServer
                                   );

        if ( ERROR_SUCCESS != dwResult )
        {
            *szBootfile = '\0';
            *szServer   = '\0';
            return FALSE;
        }

        if ( !_strcmpi( szGenericName, szRequest ) )
        {
            return TRUE;
        }

		// no match, skip to the next record
		wszTable += cbEntry;
	}

	// no match

    *szBootfile = '\0';
    *szServer   = '\0';
	return FALSE;
}

DWORD
LoadBootFileTable(
    WCHAR **ppwszTable,
    DWORD  *pcb
    )
/*++

Routine Description:

    Loads the boot file table string from the registry.
    .
Arguments:

    ppwszTable - points to the location of the pointer to the boot file
        table string.

Return Value:
    Success -  ERROR_SUCCESS

    Failure -  ERROR_NOT_ENOUGH_MEMORY
               Windows registry error.

    .

--*/

{
	DWORD	dwType;
    DWORD   dwResult;

    *ppwszTable = NULL;
    *pcb       = 0;

    dwResult = RegQueryValueEx( DhcpGlobalRegParam, DHCP_BOOT_FILE_TABLE, 0,
                                &dwType, NULL, pcb );

    if ( ERROR_SUCCESS != dwResult || dwType != DHCP_BOOT_FILE_TABLE_TYPE )
    {
        dwResult = ERROR_SERVER_INVALID_BOOT_FILE_TABLE;
        goto done;
    }

    // 
    // pcb points to the size of the array in bytes. However, the RPC marshalling code
    // assumes that this is the _number_of_elements_in_the_array_ and not the 
    // size of the array in bytes. See net\published\inc\dhcpapi.w to see the actual
    // declaraion in the size_is section. Also, we cannot change the return value of pcb
    // to be half of what it is since it might break the old clients. So, twice the size
    // of the array is allocated and this memory will be freed by the Marshaller.

    *ppwszTable = (WCHAR *) MIDL_user_allocate( *pcb * sizeof( WCHAR ));

    if ( !*ppwszTable )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    dwResult = RegQueryValueEx( DhcpGlobalRegParam, DHCP_BOOT_FILE_TABLE, 0,
                                &dwType, (BYTE *) *ppwszTable, pcb );

done:
    if ( ERROR_SUCCESS != dwResult && *ppwszTable )
    {
        MIDL_user_free( *ppwszTable );
        *ppwszTable = NULL;
        *pcb = 0;
    }

    return dwResult;
}


DWORD
DhcpParseBootFileString(
    WCHAR *wszBootFileString,
    char  *szGenericName OPTIONAL,
    char  *szBootFileName,
    char  *szServerName
    )
/*++

Routine Description:

    Takes as input a Unicode string with the following format:

    [<generic boot file name>,][<boot server>],<boot file name>

    The function extracts the generic boot file name, boot server and boot file
    name and stores them as Ansi strings in buffers supplied by the caller.

Arguments:

    wszBootFileString -  Unicode string with the format desribed above.
    szGenericName - if supplied, stores generic boot file name

    szBootFileName - stores the boot file name

    szServerName - stores the boot server name

Return Value:
    Success -  ERROR_SUCCESS

    Failure -  ERROR_INVALID_PARAMETER
               Unicode conversion error

    .

--*/
{

    struct _DHCP_PARSE_RESULTS
    {
        char *sz;
        int   cb;
    };

    int   i;

    struct _DHCP_PARSE_RESULTS pResults[3] =
    {
       { szGenericName,  BOOT_FILE_SIZE },
       { szServerName,   BOOT_SERVER_SIZE },
       { szBootFileName, BOOT_FILE_SIZE }
    };

    int cResults = sizeof( pResults ) / sizeof( struct _DHCP_PARSE_RESULTS );
    WCHAR *pwch  = wszBootFileString;
    DWORD dwResult = ERROR_SUCCESS;

    for ( i = ( szGenericName ) ? 0 : 1 ; i < cResults; i++ )
    {
        while( *pwch && *pwch != BOOT_FILE_STRING_DELIMITER_W )
            if ( !*pwch++ )
                return ERROR_INVALID_PARAMETER;

        //
        // protect the input buffer
        //

        if ( pwch - wszBootFileString >= pResults[i].cb )
        {
            dwResult = ERROR_INVALID_PARAMETER;
            goto done;
        }

        if (  pwch - wszBootFileString )
        {
            if ( !WideCharToMultiByte(  CP_ACP,
                                        0,
                                        wszBootFileString,
                                        (int)(pwch - wszBootFileString), // # of unicode chars
                                                                   // to convert
                                        pResults[i].sz,
                                        BOOT_SERVER_SIZE,
                                        NULL,
                                        FALSE ))
            {
                dwResult = GetLastError();
                goto done;
            }
        }

        //
        // null terminate ansi representation
        //

        pResults[i].sz[ pwch - wszBootFileString ] = '\0';

        //
        // skip over delimiter
        //

        pwch++;
        wszBootFileString = pwch;
    }

done:

    if ( !strlen( szBootFileName ) )
    {
        dwResult = ERROR_INVALID_PARAMETER;
    }

    return dwResult;
}

VOID
DhcpGetBootpInfo(
    IN LPDHCP_REQUEST_CONTEXT Ctxt,
    IN DHCP_IP_ADDRESS IpAddress,
    IN DHCP_IP_ADDRESS Mask,
    IN CHAR *szRequest,
    OUT CHAR *szBootFileName,
    OUT DHCP_IP_ADDRESS *pBootpServerAddress
        )
/*++

Routine Description:

    Retrieves the boot file name and boot server name for the specified
    client.
    
Arguments:
    Ctxt - dhcp client context
    IpAddress - The client's IP address
    Mask - The client's subnet mask
    szRequest - the generic boot file name requested by the client
    szBootFileName - If the function is successful, stores a copy of the
        boot file name that the client is configured to use.  Otherwise,
        stores a null string.
    pBootpServerAddress - When the fuction returns, this will point to one
        of three values:
        INADDR_NONE   - the admin specified an invalid
                        server name
        0             - no bootp server was specified for
                        the specified client
        any           - a valid IP address.

--*/
{
    DWORD dwResult,
          dwBootfileOptionLevel,
          dwUnused;
    BYTE  *pbBootFileName   = NULL,
          *pbBootServerName = NULL;
    CHAR   szBootServerName[ BOOT_SERVER_SIZE ];

    //
    // this routine does not work for multicast address.
    //
    DhcpAssert( !CLASSD_HOST_ADDR(IpAddress) );

    *szBootFileName = '\0';

    dwBootfileOptionLevel = DHCP_OPTION_LEVEL_GLOBAL;

    dwResult = DhcpGetParameter(
        IpAddress,
        Ctxt,
        OPTION_BOOTFILE_NAME,
        &pbBootFileName,
        &dwUnused,
        &dwBootfileOptionLevel
    );
    if ( ERROR_SUCCESS == dwResult ) {
        DhcpGetParameter(
            IpAddress,
            Ctxt,
            OPTION_TFTP_SERVER_NAME,
            &pbBootServerName,
            &dwUnused,
            &dwUnused
        );
    }

    if ( ERROR_SUCCESS != DhcpLookupBootpInfo(szRequest,szBootFileName,szBootServerName ) ||
         DHCP_OPTION_LEVEL_GLOBAL != dwBootfileOptionLevel ) {
        if ( pbBootFileName )  {
            strncpy( szBootFileName, pbBootFileName, BOOT_FILE_SIZE );

            if ( pbBootServerName ) {
                strncpy( szBootServerName, pbBootServerName, BOOT_SERVER_SIZE - 1 );
		szBootServerName[ BOOT_SERVER_SIZE - 1 ] = '\0';
            }
        }
    }

    if ( pBootpServerAddress ) {
        if ( szBootServerName[ 0 ] != '\0' ) { // if this is not NULL
            *pBootpServerAddress = DhcpResolveName( szBootServerName );
        }
        else {
            *pBootpServerAddress = 0;
        }
    }

    if ( pbBootServerName ) {
        DhcpFreeMemory( pbBootServerName );
    }

    if ( pbBootFileName ) {
        DhcpFreeMemory( pbBootFileName );
    }
}

DWORD
DhcpLookupBootpInfo(
    LPBYTE ReceivedBootFileName,
    LPBYTE BootFileName,
    LPBYTE BootFileServer
    )
/*++

Routine Description:

    This function gets the value of BootFileName for the bootp clients.

Arguments:

    IpAddress - The IP address of the client requesting the parameter.

    ReceivedBootFileName - Pointer to the BootFileName field in the client request.

    BootFileName - Pointer to where the BootFileName is to be returned.

    BootFileServer - Receives the optional Boot file server name

Return Value:

    Registry Errors.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    LPWSTR BootFileNameRegValue = NULL;

    *BootFileServer = 0;
    *BootFileName   = 0;

    if ( !*ReceivedBootFileName )  {
        //
        // the client didn't specify a boot file name.
        //
        Error = ERROR_SERVER_UNKNOWN_BOOT_FILE_NAME;

    } else  {
        //
        // the client specified a generic boot file name.  attempt
        // to satisfy this request from the global boot file table
        //
        WCHAR   *pwszTable;
        DWORD   cb;

        Error = LoadBootFileTable( &pwszTable, &cb );
        if ( ERROR_SUCCESS != Error )   {
            static s_fLogEvent = TRUE;

            // log the event once to avoid filling the event log

            if ( s_fLogEvent ) {
                DhcpServerEventLog(
                    EVENT_SERVER_BOOT_FILE_TABLE,
                    EVENTLOG_WARNING_TYPE,
                    Error );
                s_fLogEvent = FALSE;
            }

            return Error;
        }

        if ( !ScanBootFileTable(
            pwszTable, ReceivedBootFileName,
            BootFileName, BootFileServer ) )  {

            Error = ERROR_SERVER_UNKNOWN_BOOT_FILE_NAME;
        }

        MIDL_user_free( pwszTable );
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\binl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    binl.c

Abstract:

    This file manages the interactions between the DHCP server service
    and the BINL service used to setup and load NetPC machines.

Author:

    Colin Watson (colinw)  28-May-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include <dhcppch.h>

DhcpStateChange DhcpToBinl = NULL;
ReturnBinlState IsBinlRunning = NULL;
ProcessBinlDiscoverCallback BinlDiscoverCallback = NULL;
ProcessBinlRequestCallback BinlRequestCallback = NULL;
BOOL AttemptedLoad = FALSE;
BOOL Loaded = FALSE;
HINSTANCE   dllHandle = NULL;

BOOL
LoadDhcpToBinl(
    VOID
    );

VOID
UnLoadDhcpToBinl(
    VOID
    );

VOID
InformBinl(
    int NewState
    )
/*++

Routine Description:

    This routine informs BINL when to start & stop listening for broadcasts
    on the DHCP socket.

Arguments:

    NewState - Supplies a value which specifies the DHCP state

Return Value:

    None.

--*/
{
    if( DHCP_READY_TO_UNLOAD == NewState ) {
        UnLoadDhcpToBinl();
        return;
    }
    
    if (!LoadDhcpToBinl()) {
        return;
    }

    (*DhcpToBinl)(NewState);

}

BOOL
CheckForBinlOnlyRequest(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions
    )
{
    BOOL rc;
    LPDHCP_MESSAGE dhcpReceiveMessage;
    DWORD relayAddress;
    DWORD sourceAddress;

    //
    //  if binl is running and this client already has an IP address and
    //  the client specified PXECLIENT as an option, then we just pass this
    //  discover on to BINL
    //

    sourceAddress = ((struct sockaddr_in *)(&RequestContext->SourceName))->sin_addr.s_addr;
    dhcpReceiveMessage  = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    relayAddress = dhcpReceiveMessage->RelayAgentIpAddress;

    if ( BinlRunning() &&
         ( sourceAddress != 0 ) &&
         ( sourceAddress != relayAddress ) &&
         ( RequestContext->BinlClassIdentifierLength >= (sizeof("PXEClient") - 1) ) &&
         ( memcmp(RequestContext->BinlClassIdentifier, "PXEClient", sizeof("PXEClient") - 1) == 0 ) ) {

        rc = TRUE;

    } else {

        rc = FALSE;
    }

    return rc;
}

LPOPTION
BinlProcessRequest(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions,
    LPOPTION Option,
    PBYTE OptionEnd
    )
/*++

Routine Description:

    This routine takes a DHCP request packet. If it includes the PXEClient
    option and BINL is running then it updates the reply to include the
    BINL server information.

Arguments:

    RequestContext - A pointer to the current request context.

    DhcpOptions - A pointer to the DhcpOptions structure.

    Option - placeholder to put next option

    OptionEnd - end of buffer to put options

Return Value:

    ERROR_SUCCESS if binl supports this client, otherwise non-success error.

--*/
{
    //  Is this client looking for a BINL server and ours running?
    if ((RequestContext->BinlClassIdentifierLength >= (sizeof("PXEClient") -1)) &&
        (!memcmp(RequestContext->BinlClassIdentifier, "PXEClient",sizeof("PXEClient") -1)) &&
        (BinlRunning())) {

        DWORD err;
        LPDHCP_MESSAGE dhcpSendMessage;
        LPOPTION tempOption = Option;

        if (DhcpOptions->Server != NULL &&
            *DhcpOptions->Server != RequestContext->EndPointIpAddress) {

            goto ExcludeBinl;
        }

        dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;

        err = (*BinlRequestCallback)(   (PDHCP_MESSAGE) RequestContext->ReceiveBuffer,
                                        DhcpOptions,
                                        &dhcpSendMessage->HostName[0],
                                        &dhcpSendMessage->BootFileName[0],
                                        &dhcpSendMessage->BootstrapServerAddress,
                                        &tempOption,
                                        OptionEnd
                                        );

        if (err != ERROR_SUCCESS) {

            goto ExcludeBinl;
        }

        //
        //  if the binl server didn't fill in the bootstrap server address
        //  but it worked, then it wants us to fill in the correct one.
        //

        if (dhcpSendMessage->BootstrapServerAddress == 0) {

            dhcpSendMessage->BootstrapServerAddress = RequestContext->EndPointIpAddress;
        }
        Option = tempOption;        // it worked and binl has added options

    } else {

ExcludeBinl:
        //  Avoid including BINL flag in the response.
        RequestContext->BinlClassIdentifierLength = 0;
        RequestContext->BinlClassIdentifier = NULL;
    }
    return Option;
}

VOID
BinlProcessDiscover(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions
    )
/*++

Routine Description:

    This routine takes a DHCP request packet. If it includes the PXEClient
    option and BINL is running then it updates the reply to include the
    BINL server information.

Arguments:

    RequestContext - A pointer to the current request context.

    DhcpOptions - A pointer to the DhcpOptions structure.

Return Value:

    ERROR_SUCCESS if binl supports this client, otherwise non-success error.

--*/
{
    DWORD err;

    //  Is this client looking for a BINL server and ours running?
    if ((RequestContext->BinlClassIdentifierLength >= (sizeof("PXEClient") -1)) &&
        (!memcmp(RequestContext->BinlClassIdentifier, "PXEClient",sizeof("PXEClient") -1)) &&
        (BinlRunning())) {

        if (DhcpOptions->Server != NULL &&
            *DhcpOptions->Server != RequestContext->EndPointIpAddress) {

            goto ExcludeBinl;
        }

        err = (*BinlDiscoverCallback)( (PDHCP_MESSAGE) RequestContext->ReceiveBuffer,
                                        DhcpOptions );

        if (err != ERROR_SUCCESS) {

            goto ExcludeBinl;
        }
        //  Yes so point the client at the BINL server.

        ((LPDHCP_MESSAGE)RequestContext->SendBuffer)->BootstrapServerAddress =
            RequestContext->EndPointIpAddress;

    } else {

ExcludeBinl:
        //  Avoid including BINL flag in the response.
        RequestContext->BinlClassIdentifierLength = 0;
        RequestContext->BinlClassIdentifier = NULL;
    }
    return;
}



BOOL
BinlRunning(
    VOID
    )
/*++

Routine Description:

    This routine determines if BINL is currently running. Note, The service may change
    state almost immediately so we may tell a client it's running even though it is
    stopped when it gets around to talking to it.

Arguments:

    None.

Return Value:

    True if running.

--*/
{
    if (!LoadDhcpToBinl()) {
        return FALSE;
    }

    return (*IsBinlRunning)();
}

BOOL
LoadDhcpToBinl(
    VOID
    )
/*++

Routine Description:

    This routine loads the pointers into the BINL dll

Arguments:

    None.

Return Value:

    TRUE - pointers loaded

--*/
{

    DWORD       Error;

    if (Loaded) {
        return TRUE;
    }

    if (AttemptedLoad) {
        return FALSE;   // We tried to load it once and failed.
    }

    AttemptedLoad = TRUE;

    //
    // Load the BINL DLL.
    //

    dllHandle = LoadLibrary( BINL_LIBRARY_NAME );
    if ( dllHandle == NULL ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_MISC, "Failed to load DLL %ws: %ld\n",
                     BINL_LIBRARY_NAME, Error));
        return FALSE;
    }

    //
    // Get the address of the service's main entry point.  This
    // entry point has a well-known name.
    //

    DhcpToBinl = (DhcpStateChange)GetProcAddress(dllHandle,
                                                BINL_STATE_ROUTINE_NAME);
    if ( DhcpToBinl == NULL ) {
        DhcpPrint(( DEBUG_MISC, "Failed to find entry %ws: %ld\n",
                     BINL_STATE_ROUTINE_NAME, GetLastError()));
        FreeLibrary(dllHandle);
        dllHandle = NULL;
        return FALSE;
    }

    IsBinlRunning = (ReturnBinlState)GetProcAddress(dllHandle,
                                            BINL_READ_STATE_ROUTINE_NAME);
    if ( BinlRunning == NULL ) {
        DhcpPrint(( DEBUG_MISC, "Failed to find entry %ws: %ld\n",
                     BINL_READ_STATE_ROUTINE_NAME, GetLastError()));
        FreeLibrary(dllHandle);
        dllHandle = NULL;
        return FALSE;
    }

    BinlDiscoverCallback = (ProcessBinlDiscoverCallback)GetProcAddress(dllHandle,
                                            BINL_DISCOVER_CALLBACK_ROUTINE_NAME);
    if ( BinlDiscoverCallback == NULL ) {
        DhcpPrint(( DEBUG_MISC, "Failed to find entry %ws: %ld\n",
                     BINL_DISCOVER_CALLBACK_ROUTINE_NAME, GetLastError()));
        FreeLibrary(dllHandle);
        dllHandle = NULL;
        return FALSE;
    }

    BinlRequestCallback = (ProcessBinlRequestCallback)GetProcAddress(dllHandle,
                                            BINL_REQUEST_CALLBACK_ROUTINE_NAME);
    if ( BinlRequestCallback == NULL ) {
        DhcpPrint(( DEBUG_MISC, "Failed to find entry %ws: %ld\n",
                     BINL_REQUEST_CALLBACK_ROUTINE_NAME, GetLastError()));
        FreeLibrary(dllHandle);
        dllHandle = NULL;
        return FALSE;
    }

    Loaded = TRUE;
    return TRUE;
}

VOID
UnLoadDhcpToBinl(
    VOID
    )
/*++

Routine Description:

    This routine unloads the pointers into the BINL dll

Arguments:

    None.

Return Value:

    None.

--*/
{

    if (dllHandle != NULL) {
        FreeLibrary(dllHandle);
        dllHandle = NULL;
    }

    AttemptedLoad = FALSE;
    Loaded = FALSE;
    return;
}

PCHAR
GetDhcpDomainName(
    VOID
    )
/*++

Routine Description:

    This routine returns the name of our domain to BINL.  We've discovered it
    through rogue detection.  BINL

Arguments:

    None.

Return Value:

    None.

--*/
{
    PCHAR domain = NULL;

    EnterCriticalSection( &DhcpGlobalBinlSyncCritSect );

    if ( DhcpGlobalDSDomainAnsi ) {

        domain = LocalAlloc( LPTR, strlen( DhcpGlobalDSDomainAnsi ) + 1 );

        if (domain != NULL) {
            strcpy( domain, DhcpGlobalDSDomainAnsi );
        }
    }
    LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );

    return domain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\cltapi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cltapi.c

Abstract:

    This module contains the implementation of DHCP Client APIs.

Author:

    Madan Appiah (madana)  27-Sep-1993

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny)  30-May-1996  superscope
    Cheng Yang (t-cheny)  24-Jun-1996  IP address detection, audit log


--*/

#include "dhcppch.h"
#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>
#include <thread.h>
#include <rpcapi.h>

#define IS_INFINITE_LEASE(DateTime)  \
    ( (DateTime).dwLowDateTime == DHCP_DATE_TIME_INFINIT_LOW && \
      (DateTime).dwHighDateTime == DHCP_DATE_TIME_INFINIT_HIGH )

#define IS_ZERO_LEASE(DateTime) \
    ((DateTime).dwLowDateTime == 0 && (DateTime).dwHighDateTime == 0)

DWORD
DhcpDeleteSubnetClients(
    DHCP_IP_ADDRESS SubnetAddress
    )
/*++

Routine Description:

    This functions cleans up all clients records of the specified subnet
    from the database.

Arguments:

    SubnetAddress : subnet address whose clients should be cleaned off.

Return Value:

    Database error code or ERROR_SUCCESS.

--*/
{
    DWORD Error, Count = 0;
    DWORD ReturnError = ERROR_SUCCESS;

    LOCK_DATABASE();

    Error = DhcpJetPrepareSearch(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                TRUE,   // Search from start
                NULL,
                0 );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Walk through the entire database looking looking for the
    // specified subnet clients.
    //
    //

    for ( ;; ) {

        DWORD Size;
        DHCP_IP_ADDRESS IpAddress;
        DHCP_IP_ADDRESS SubnetMask;

        //
        // read IpAddress and SubnetMask to filter unwanted clients.
        //

        Size = sizeof(IpAddress);
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                    &IpAddress,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(IpAddress) );

        Size = sizeof(SubnetMask);
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                    &SubnetMask,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(SubnetMask) );

        if( (IpAddress & SubnetMask) == SubnetAddress ) {

            //
            // found a specified subnet client record , delete it.
            //

            Error = DhcpJetBeginTransaction();

            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            // Check if we can delete this IpAddress - should be able to do it
            // only if DynDns is already done..
            (void) DhcpDoDynDnsCheckDelete(IpAddress) ;

            // Actually, give DNS a chance and delete these anyway.
            Error = DhcpJetDeleteCurrentRecord();

            if( Error != ERROR_SUCCESS ) {

                DhcpPrint((DEBUG_ERRORS, "Deleting current record failed:%ld\n",  Error ));
                Error = DhcpJetRollBack();
                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }

                goto ContinueError;
            }

            Error = DhcpJetCommitTransaction();

            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            Count ++;
        }

ContinueError:

        if( Error != ERROR_SUCCESS ) {

            DhcpPrint(( DEBUG_ERRORS,
                "Cleanup current database record failed, %ld.\n",
                    Error ));

            ReturnError = Error;
        }

        //
        // move to next record.
        //

        Error = DhcpJetNextRecord();

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }

            goto Cleanup;
        }
    }

Cleanup:

    if( Error == ERROR_SUCCESS ) {
        Error = ReturnError;
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
            "DhcpDeleteSubnetClients failed, %ld.\n", Error ));
    }
    else  {
        DhcpPrint(( DEBUG_APIS,
            "DhcpDeleteSubnetClients finished successfully.\n" ));
    }

    DhcpPrint((DEBUG_APIS, "DhcpDeleteSubnetClients: deleted %ld  clients\n",
               Count));
    UNLOCK_DATABASE();
    return(Error);
}


DhcpGetCurrentClientInfo(
    LPDHCP_CLIENT_INFO_V4 *ClientInfo,
    LPDWORD InfoSize, // optional parameter.
    LPBOOL ValidClient, // optional parameter.
    DWORD SubnetAddress // optional parameter.
    )
/*++

Routine Description:

    This function retrieves current client information information. It
    allocates MIDL memory for the client structure (and for variable
    length structure fields). The caller is responsible to lock the
    database when this function is called.

Arguments:

    ClientInfo - pointer to a location where the client info structure
                    pointer is returned.

    InfoSize - pointer to a DWORD location where the number of bytes
                    consumed in the ClientInfo is returned.

    ValidClient - when this parameter is specified this
        function packs the current record only if the client

            1. belongs to the specified subnet.
            2. address state is ADDRESS_STATE_ACTIVE.

    SubnetAddress - the subnet address to filter client.

Return Value:

    Jet Errors.

--*/
{
    DWORD Error;
    LPDHCP_CLIENT_INFO_V4 LocalClientInfo = NULL;
    DWORD LocalInfoSize = 0;
    DWORD Size;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS SubnetMask;
    DHCP_IP_ADDRESS ClientSubnetAddress;
    BYTE AddressState;

    DhcpAssert( *ClientInfo == NULL );

    //
    // read IpAddress and SubnetMask to filter unwanted clients.
    //

    Size = sizeof(IpAddress);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                &IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(IpAddress) );

    Size = sizeof(SubnetMask);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                &SubnetMask,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(SubnetMask) );

    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                &AddressState,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(AddressState) );

    //
    // filter client if we are asked to do so.
    //

    if( ValidClient != NULL ) {

        //
        // don't filter client if the SubnetAddress is zero.
        //

        if( (SubnetAddress != 0) &&
                (IpAddress & SubnetMask) != SubnetAddress ) {
            *ValidClient = FALSE;
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        // NT40 caller => should not return DELETED clients.
        if( IsAddressDeleted(AddressState) ) {
            *ValidClient = FALSE;
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        *ValidClient = TRUE;
    }

    //
    // allocate return Buffer.
    //

    LocalClientInfo = MIDL_user_allocate( sizeof(DHCP_CLIENT_INFO_V4) );

    if( LocalClientInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    memset( LocalClientInfo, 0, sizeof( LocalClientInfo ));

    LocalInfoSize = sizeof(DHCP_CLIENT_INFO_V4);

    LocalClientInfo->ClientIpAddress = IpAddress;
    LocalClientInfo->SubnetMask = SubnetMask;

    //
    // read additional client info from database.
    //

    LocalClientInfo->ClientHardwareAddress.DataLength = 0;
        // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                &LocalClientInfo->ClientHardwareAddress.Data,
                &LocalClientInfo->ClientHardwareAddress.DataLength );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    LocalInfoSize += LocalClientInfo->ClientHardwareAddress.DataLength;

    //
    // strip off the client UID prefix.
    //

    ClientSubnetAddress = IpAddress & SubnetMask;

    if( (LocalClientInfo->ClientHardwareAddress.DataLength >
            sizeof(ClientSubnetAddress)) &&
         (memcmp( LocalClientInfo->ClientHardwareAddress.Data,
                    &ClientSubnetAddress,
                    sizeof(ClientSubnetAddress)) == 0) ) {

        DWORD PrefixSize;

        PrefixSize = sizeof(ClientSubnetAddress) + sizeof(BYTE);

        LocalClientInfo->ClientHardwareAddress.DataLength -= PrefixSize;

        memmove( LocalClientInfo->ClientHardwareAddress.Data,
                    (LPBYTE)LocalClientInfo->ClientHardwareAddress.Data +
                            PrefixSize,
                    LocalClientInfo->ClientHardwareAddress.DataLength );
    }

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
                &LocalClientInfo->ClientName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientName != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientName) + 1) *
                        sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
                &LocalClientInfo->ClientComment,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientComment != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientComment) + 1) *
                        sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;


    Size = sizeof( LocalClientInfo->bClientType );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[ CLIENT_TYPE_INDEX ].ColHandle,
                &LocalClientInfo->bClientType,
                &Size );
    if ( ERROR_SUCCESS != Error )
        goto Cleanup;

    DhcpAssert( Size <=1 );

    if ( !Size )
    {
        //
        // this is a record that was present when the db was updated, and
        // doesn't yet have a client id.  Since the previous version of
        // DHCP server didn't support BOOTP, we know this must be a DHCP
        // lease.
        //

        Size = sizeof( LocalClientInfo->bClientType );
        LocalClientInfo->bClientType = CLIENT_TYPE_DHCP;
    }

    LocalInfoSize += Size;

    Size = sizeof( LocalClientInfo->ClientLeaseExpires );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &LocalClientInfo->ClientLeaseExpires,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->ClientLeaseExpires ) );

    RtlZeroMemory(
        &LocalClientInfo->OwnerHost, sizeof(LocalClientInfo->OwnerHost)
        );

    Size = sizeof( LocalClientInfo->OwnerHost.IpAddress );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SERVER_IP_ADDRESS_INDEX].ColHandle,
                &LocalClientInfo->OwnerHost.IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    //DhcpAssert( Size == sizeof(LocalClientInfo->OwnerHost.IpAddress) );



    Size = 0;
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SERVER_NAME_INDEX].ColHandle,
                &LocalClientInfo->OwnerHost.NetBiosName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if ( LocalClientInfo->OwnerHost.NetBiosName != NULL ) {
        DhcpAssert( Size ==
            (wcslen(LocalClientInfo->OwnerHost.NetBiosName) + 1) *
                sizeof(WCHAR) );

    }
    else {
        DhcpAssert( Size == 0 );
    }
    
    LocalInfoSize += Size;

    *ClientInfo = LocalClientInfo;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, return alloted memory.
        //

        if( LocalClientInfo != NULL ) {
            _fgs__DHCP_CLIENT_INFO ( LocalClientInfo );
        }
        LocalInfoSize = 0;
    }

    if( InfoSize != NULL ) {
        *InfoSize =  LocalInfoSize;
    }

    return( Error );
}

// same as above but for NT50.
DhcpGetCurrentClientInfoV5(
    LPDHCP_CLIENT_INFO_V5 *ClientInfo,
    LPDWORD InfoSize, // optional parameter.
    LPBOOL ValidClient, // optional parameter.
    DWORD SubnetAddress // optional parameter.
    )
/*++

Routine Description:

    This function retrieves current client information information. It
    allocates MIDL memory for the client structure (and for variable
    length structure fields). The caller is responsible to lock the
    database when this function is called.

Arguments:

    ClientInfo - pointer to a location where the client info structure
                    pointer is returned.

    InfoSize - pointer to a DWORD location where the number of bytes
                    consumed in the ClientInfo is returned.

    ValidClient - when this parameter is specified this
        function packs the current record only if the client

            1. belongs to the specified subnet.
            2. address state is ADDRESS_STATE_ACTIVE.

    SubnetAddress - the subnet address to filter client.

Return Value:

    Jet Errors.

--*/
{
    DWORD Error;
    LPDHCP_CLIENT_INFO_V5 LocalClientInfo = NULL;
    DWORD LocalInfoSize = 0;
    DWORD Size;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS SubnetMask;
    DHCP_IP_ADDRESS ClientSubnetAddress;
    DHCP_IP_ADDRESS realSubnetMask;
    BYTE AddressState;

    DhcpAssert( *ClientInfo == NULL );

    //
    // read IpAddress and SubnetMask to filter unwanted clients.
    //

    Size = sizeof(IpAddress);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                &IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(IpAddress) );

    Size = sizeof(SubnetMask);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                &SubnetMask,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(SubnetMask) );

    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                &AddressState,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(AddressState) );

    //
    // for several reasons, the subnet mask could be wrong?
    //

    realSubnetMask = DhcpGetSubnetMaskForAddress(IpAddress);
    // need to investigate those on a case by case basis.
    if( realSubnetMask != SubnetMask ) {
        DhcpPrint((DEBUG_ERRORS, "Ip Address <%s> ",inet_ntoa(*(struct in_addr *)&IpAddress)));
        DhcpPrint((DEBUG_ERRORS, "has subnet mask <%s> in db, must be ",inet_ntoa(*(struct in_addr *)&SubnetMask)));
        DhcpPrint((DEBUG_ERRORS, " <%s>\n",inet_ntoa(*(struct in_addr *)&realSubnetMask)));

        DhcpAssert(realSubnetMask == SubnetMask);
    }

    //
    // filter client if we are asked to do so.
    //

    if( ValidClient != NULL ) {

        //
        // don't filter client if the SubnetAddress is zero.
        //

        if( (SubnetAddress != 0) &&
                (IpAddress & realSubnetMask) != SubnetAddress ) {
            *ValidClient = FALSE;
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        *ValidClient = TRUE;
    }

    //
    // allocate return Buffer.
    //

    LocalClientInfo = MIDL_user_allocate( sizeof(DHCP_CLIENT_INFO_V5) );

    if( LocalClientInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalInfoSize = sizeof(DHCP_CLIENT_INFO_V5);

    LocalClientInfo->ClientIpAddress = IpAddress;
    LocalClientInfo->SubnetMask = SubnetMask;
    LocalClientInfo->AddressState = AddressState;

    //
    // read additional client info from database.
    //

    LocalClientInfo->ClientHardwareAddress.DataLength = 0;
        // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                &LocalClientInfo->ClientHardwareAddress.Data,
                &LocalClientInfo->ClientHardwareAddress.DataLength );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    LocalInfoSize += LocalClientInfo->ClientHardwareAddress.DataLength;

    //
    // strip off the client UID prefix.
    //

    ClientSubnetAddress = IpAddress & SubnetMask;

    if( (LocalClientInfo->ClientHardwareAddress.DataLength >
            sizeof(ClientSubnetAddress)) &&
         (memcmp( LocalClientInfo->ClientHardwareAddress.Data,
                    &ClientSubnetAddress,
                    sizeof(ClientSubnetAddress)) == 0) ) {

        DWORD PrefixSize;

        PrefixSize = sizeof(ClientSubnetAddress) + sizeof(BYTE);

        LocalClientInfo->ClientHardwareAddress.DataLength -= PrefixSize;

        memmove( LocalClientInfo->ClientHardwareAddress.Data,
                    (LPBYTE)LocalClientInfo->ClientHardwareAddress.Data +
                            PrefixSize,
                    LocalClientInfo->ClientHardwareAddress.DataLength );
    }

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
                &LocalClientInfo->ClientName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientName != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientName) + 1) *
                    sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
                &LocalClientInfo->ClientComment,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientComment != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientComment) + 1) *
                        sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;


    Size = sizeof( LocalClientInfo->bClientType );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[ CLIENT_TYPE_INDEX ].ColHandle,
                &LocalClientInfo->bClientType,
                &Size );
    if ( ERROR_SUCCESS != Error )
        goto Cleanup;

    DhcpAssert( Size <=1 );

    if ( !Size )
    {
        //
        // this is a record that was present when the db was updated, and
        // doesn't yet have a client id.  Since the previous version of
        // DHCP server didn't support BOOTP, we know this must be a DHCP
        // lease.
        //

        Size = sizeof( LocalClientInfo->bClientType );
        LocalClientInfo->bClientType = CLIENT_TYPE_DHCP;
    }

    LocalInfoSize += Size;

    Size = sizeof( LocalClientInfo->ClientLeaseExpires );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &LocalClientInfo->ClientLeaseExpires,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->ClientLeaseExpires ) );

    RtlZeroMemory(
        &LocalClientInfo->OwnerHost, sizeof(LocalClientInfo->OwnerHost)
        );

    Size = sizeof( LocalClientInfo->OwnerHost.IpAddress );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SERVER_IP_ADDRESS_INDEX].ColHandle,
                &LocalClientInfo->OwnerHost.IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->OwnerHost.IpAddress) );



    Size = 0;
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SERVER_NAME_INDEX].ColHandle,
                &LocalClientInfo->OwnerHost.NetBiosName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if ( LocalClientInfo->OwnerHost.NetBiosName != NULL ) {
        DhcpAssert( Size ==
            (wcslen(LocalClientInfo->OwnerHost.NetBiosName) + 1) *
                sizeof(WCHAR) );

    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;

    *ClientInfo = LocalClientInfo;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, return alloted memory.
        //

        if( LocalClientInfo != NULL ) {
            _fgs__DHCP_CLIENT_INFO_V5 ( LocalClientInfo );
        }
        LocalInfoSize = 0;
    } else if( LocalClientInfo ) {
        //
        // Irrespective of leasetime we have to check ?
        //
        if( DhcpServerIsAddressReserved(
            DhcpGetCurrentServer(), IpAddress
        ) ){
            LocalClientInfo->bClientType |= CLIENT_TYPE_RESERVATION_FLAG;
        }

    }

    if( InfoSize != NULL ) {
        *InfoSize =  LocalInfoSize;
    }

    return( Error );
}

DWORD                                                  // DATABASE locks must be taken
DhcpCreateClientEntry(                                 // create a client record for a specific ip address
    IN      DHCP_IP_ADDRESS        ClientIpAddress,    // the address to create record for
    IN      LPBYTE                 ClientHardwareAddress,
    IN      DWORD                  HardwareAddressLength, // the hardware address --UID of the client
    IN      DATE_TIME              LeaseTerminates,    // when does the lease terminate
    IN      LPWSTR                 MachineName,        // machine name?
    IN      LPWSTR                 ClientInformation,  // other comment?
    IN      BYTE                   bClientType,        // DHCP_CLIENT_TYPE_ DHCP/BOOTP  [BOTH/NONE]
    IN      DHCP_IP_ADDRESS        ServerIpAddress,    // which server is this?
    IN      BYTE                   AddressState,       // what is the state of the address anyways?
    IN      BOOL                   OpenExisting        // is this record a totally fresh one or updating an old one?
)
{
    DHCP_IP_ADDRESS                RequestedClientAddress = ClientIpAddress;
    DHCP_IP_ADDRESS                SubnetMask;
    DWORD                          Error;
    DWORD                          LocalError;
    DATE_TIME                      LocalLeaseTerminates;
    JET_ERR                        JetError = JET_errSuccess;
    LPWSTR                         OldMachineName;
    BOOL                           BadAddress = FALSE;
    BYTE                           bAllowedClientTypes;
    BYTE                           PreviousAddressState;
    DWORD                          Size;

    DhcpAssert(0 != ClientIpAddress);
    if( ADDRESS_STATE_DECLINED == AddressState ) BadAddress = TRUE;

    LOCK_DATABASE();
    Error = DhcpJetBeginTransaction();
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    // Do any dirty work needed for DynDns stuff.
    // Essentially, if this address/hostname is getting overwritten (for some
    // reason), and if this address has not completed DynDns work yet, then
    // do that now.  On the other hand, if we are giving this address away
    // to someone else.. this should not really happen.
    DhcpDoDynDnsCreateEntryWork(
        &ClientIpAddress,                              // IpAddress for Update
        bClientType,                                   // Dhcp or Bootp or both?
        MachineName,                                   // Client Name, if known. else NULL
        &AddressState,                                 // New address state
        &OpenExisting,                                 // Do we expect a record to exist?
        BadAddress                                     // Is this a bad address
    );

    // Note that both AddressState and OpenExisting could get changed by the above function...

    Error = DhcpJetPrepareUpdate(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (LPBYTE)&ClientIpAddress,
        sizeof( ClientIpAddress ),
        !OpenExisting
    );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    if( !OpenExisting ) {                              // update fixed info for new records
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
            (LPBYTE)&ClientIpAddress,
            sizeof( ClientIpAddress ) );

        if( Error != ERROR_SUCCESS )  goto Cleanup;
    }

    SubnetMask = DhcpGetSubnetMaskForAddress(ClientIpAddress);
    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
        &SubnetMask,
        sizeof(SubnetMask)
    );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    //
    // bug #65666
    //
    // it was possible for dhcp server to lease the same address to multiple
    // clients in the following case:
    //
    // 1. dhcp server leases ip1 to client1.
    // 2. dhcp server receives a late arriving dhcpdiscover from client1.
    //    In response, the server changes the address state of ip1 to
    //    ADDRESS_STATE_OFFERED and sends an offer.
    // 3. Since client1 already received a lease, it doesn't reply to the offer.
    // 4. The scavenger thread runs and deletes the lease for ip1 ( since its state is
    //    ADDRESS_STATE_OFFERED.
    // 5. dhcp server leases ip1 to client2.
    //
    //
    // The solution is to check avoid changing an address from ADDRESS_STATE_ACTIVE
    // to ADDRESS_STATE_OFFERED.  This will prevent the scavenger thread from deleting
    // the lease.  Note that this requires a change to ProcessDhcpRequest - see the comments
    // in that function for details.
    //
    // The above is currently handled in DhcpDoDynDnsCreateEntryWork... so see there for info.
    // The function changes AddressState correctly, so we can always do the following.

    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        sizeof(AddressState)
    );

    DhcpAssert( (ClientHardwareAddress != NULL) && (HardwareAddressLength > 0) );

    // see cltapi.c@v27 for an #if0 re: #66286 bad address by ping

    if ( !BadAddress ) {
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            ClientHardwareAddress,
            HardwareAddressLength
        );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
    } else {
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            (LPBYTE)&ClientIpAddress,
            sizeof(ClientIpAddress)
        );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
    }

    // see cltapi.c@v27 for an #if0 re: #66286 (I think)

    if (BadAddress) {                                  // this address is in use somewhere
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
            GETSTRING( DHCP_BAD_ADDRESS_NAME ),
            (wcslen(GETSTRING(DHCP_BAD_ADDRESS_NAME)) + 1) * sizeof(WCHAR)
        );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
            GETSTRING( DHCP_BAD_ADDRESS_INFO ),
            (wcslen(GETSTRING( DHCP_BAD_ADDRESS_INFO )) + 1) * sizeof(WCHAR)
        );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        LocalLeaseTerminates = LeaseTerminates;
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
            &LocalLeaseTerminates,
            sizeof(LeaseTerminates)
        );
        if( Error != ERROR_SUCCESS ) goto Cleanup;
    } else {
        // During DISCOVER time if machine name is not supplied and if
        // this is an existing record, dont overwrite the original name with NULL

        if ( !OpenExisting || MachineName ) {
            Error = DhcpJetSetValue(
                DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
                MachineName,
                (MachineName == NULL) ? 0 :
                (wcslen(MachineName) + 1) * sizeof(WCHAR)
            );
        }
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        if ( !OpenExisting || ClientInformation ) {
            Error = DhcpJetSetValue(
                DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
                ClientInformation,
                (ClientInformation == NULL) ? 0 :
                (wcslen(ClientInformation) + 1) * sizeof(WCHAR)
            );
        }
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        // For reserved clients set the time to a large value so that
        // they will not expire anytime. However zero lease time is
        // special case for unused reservations.
        //

        if( (LeaseTerminates.dwLowDateTime != DHCP_DATE_TIME_ZERO_LOW) &&
            (LeaseTerminates.dwHighDateTime != DHCP_DATE_TIME_ZERO_HIGH) &&
            DhcpServerIsAddressReserved(DhcpGetCurrentServer(), ClientIpAddress) ) {
            LocalLeaseTerminates.dwLowDateTime = DHCP_DATE_TIME_INFINIT_LOW;
            LocalLeaseTerminates.dwHighDateTime = DHCP_DATE_TIME_INFINIT_HIGH;
        } else {
            LocalLeaseTerminates = LeaseTerminates;
        }

        // If we are opening an existing client, we make sure that we don't
        // reset the lease to DHCP_CLIENT_REQUESTS_EXPIRE*2 time when we receive
        // a delayed/rogue discover packet. We also make sure that expiration time
        // is at least DHCP_CLIENT_REQUESTS_EXPIRE*2.

        // NOTE: this code has been removed as this would no longer occur -- no database entries
        // exists for clients who are just offered addresses -- only on requests do we fill in the db at all

        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
            &LocalLeaseTerminates,
            sizeof(LeaseTerminates)
        );
        if( Error != ERROR_SUCCESS ) goto Cleanup;
    }

    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[SERVER_NAME_INDEX].ColHandle,
        DhcpGlobalServerName,
        DhcpGlobalServerNameLen
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[SERVER_IP_ADDRESS_INDEX].ColHandle,
        &ServerIpAddress,
        sizeof(ServerIpAddress)
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
        &bClientType,
        sizeof(bClientType )
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    JetError = JetUpdate(                              // commit the changes
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        NULL,
        0,
        NULL
    );

    if( JET_errKeyDuplicate == JetError ) {
        DhcpAssert(FALSE);
        Error = ERROR_DHCP_JET_ERROR;
    } else Error = DhcpMapJetError(JetError, "CreateClientEntry:JetUpdate");

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    if (BadAddress) {                                  // commit the transaction to record the bad address
        LocalError = DhcpJetCommitTransaction();
        DhcpAssert( LocalError == ERROR_SUCCESS );

        DhcpUpdateAuditLog(                        // log this activity
            DHCP_IP_LOG_CONFLICT,
            GETSTRING( DHCP_IP_LOG_CONFLICT_NAME ),
            ClientIpAddress,
            NULL,
            0,
            GETSTRING( DHCP_BAD_ADDRESS_NAME )
        );

        UNLOCK_DATABASE();
        return Error;
    }

Cleanup:

    if( ERROR_SUCCESS != Error ) {
        LocalError = DhcpJetRollBack();
        DhcpAssert(ERROR_SUCCESS == LocalError);
    } else {
        LocalError = DhcpJetCommitTransaction();
        DhcpAssert(ERROR_SUCCESS == LocalError);
    }
    UNLOCK_DATABASE();
    return Error;
}

DWORD
DhcpRemoveClientEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength,
    BOOL ReleaseAddress,
    BOOL DeletePendingRecord
    )
/*++

Routine Description:

    This function removes a client entry from the client database.

Arguments:

    ClientIpAddress - The IP address of the client.

    HardwareAddress - client's hardware address.

    HardwareAddressLength - client's hardware address length.

    ReleaseAddress - if this flag is TRUE, release the address bit from
        registry, otherwise don't.

    DeletePendingRecord - if this flag is TRUE, the record is deleted
        only if the state of the record is ADDRESS_STATE_OFFERED.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError;
    DWORD Error;
    BOOL TransactBegin = FALSE;
    BYTE bAllowedClientTypes, bClientType;
    LPWSTR OldClientName = NULL;
    BYTE State;
    DWORD Size = sizeof(State);
    BOOL  Reserved = FALSE;

    LOCK_DATABASE();

    // start transaction before a create/update database record.
    Error = DhcpJetBeginTransaction();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    TransactBegin = TRUE;

    JetError = JetSetCurrentIndex(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName );

    Error = DhcpMapJetError( JetError, "RemoveClientEntry:SetCurrentIndex" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    JetError = JetMakeKey(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    &ClientIpAddress,
                    sizeof(ClientIpAddress),
                    JET_bitNewKey );

    Error = DhcpMapJetError( JetError, "RemoveClientEntry:MakeKey" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    JetError = JetSeek(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    JET_bitSeekEQ );

    Error = DhcpMapJetError( JetError, "RemoveClientEntry:Seek" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // HARDWARE address match check removed.. see cltapi.c@v27 for other details.
    // (was already #if0'd)

    //
    // Get Client type -- we need that to figure out what kind of client it is
    // that we are trying to delete..
    //
    Size = sizeof(bClientType);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
        &bClientType,
        &Size
        );
    if( ERROR_SUCCESS != Error ) {
        bClientType = CLIENT_TYPE_DHCP;
    }

    //
    // if we are asked to delete only pending records, check it now.
    //
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &State,
        &Size );

    if( DeletePendingRecord ) {
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        if(!IS_ADDRESS_STATE_OFFERED(State) )
        {
            DhcpPrint( ( DEBUG_ERRORS,
                         "DhcpRemoveClientEntry: Attempting to remove record with state == %d\n",
                          State )
                     );

            Error = ERROR_SUCCESS;
            goto Cleanup;
        }
    }

    //
    // if this is reserved entry, so don't remove.
    //

    { // get the machine name (required for Dyn Dns stuff) for possibly existing stuff.
        DWORD lSize = 0; // DhcpJetGetValue would allocate space.
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
            &OldClientName,
            &lSize );
    }

    if(Reserved = DhcpServerIsAddressReserved(DhcpGetCurrentServer(), ClientIpAddress )) {
        DATE_TIME ZeroDateTime;

        //
        // set the time value to zero to indicate that this reserved
        // address and it is no more in use.
        //

        ZeroDateTime.dwLowDateTime = DHCP_DATE_TIME_ZERO_LOW;
        ZeroDateTime.dwHighDateTime = DHCP_DATE_TIME_ZERO_HIGH;

        Error = DhcpJetPrepareUpdate(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            &ClientIpAddress,
            sizeof( ClientIpAddress ),
            FALSE
        );

        if( Error == ERROR_SUCCESS ) {
            Error = DhcpJetSetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &ZeroDateTime,
                sizeof(ZeroDateTime)
            );
            DhcpDoDynDnsReservationWork(ClientIpAddress, OldClientName, State);
            if( Error == ERROR_SUCCESS ) {
                Error = DhcpJetCommitUpdate();
            }
        }

        if( Error == ERROR_SUCCESS ) {
            Error = ERROR_DHCP_RESERVED_CLIENT;
        }

        goto Cleanup;
    }

    // Check if delete is safe from Dyn Dns point of view.
    if( DhcpDoDynDnsCheckDelete(ClientIpAddress) ) {
        JetError = JetDelete(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle );
        Error = DhcpMapJetError( JetError, "RemoveClientEntry:Delete" );
    } else Error = ERROR_SUCCESS;

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Could not delete client entry: %ld\n", JetError));
        goto Cleanup;
    }

    //
    // Finally, mark the IP address available
    //

    if( ReleaseAddress == TRUE ) {

        if( CLIENT_TYPE_BOOTP != bClientType ) {
            Error = DhcpReleaseAddress( ClientIpAddress );
        } else {
            Error = DhcpReleaseBootpAddress( ClientIpAddress );
        }

        //
        // it is ok if this address is not in the bit map.
        //

        if( ERROR_SUCCESS != Error ) {
            Error = ERROR_SUCCESS;
        }
    }

Cleanup:

    if ( (Error != ERROR_SUCCESS) &&
            (Error != ERROR_DHCP_RESERVED_CLIENT) ) {

        //
        // if the transaction has been started, than roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        //
        if( TransactBegin == TRUE ) {
            DWORD LocalError;

            LocalError = DhcpJetRollBack();
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }

        DhcpPrint(( DEBUG_ERRORS, "Can't remove client entry from the "
                    "database, %ld.\n", Error));

    }
    else {

        //
        // commit the transaction before we return.
        //

        DWORD LocalError;

        DhcpAssert( TransactBegin == TRUE );

        LocalError = DhcpJetCommitTransaction();
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }

    UNLOCK_DATABASE();

    if(OldClientName) DhcpFreeMemory(OldClientName);
    return( Error );
}

// return TRUE if address given out to this client, address not given out in DB or bad/declined/reconciled address
BOOL
DhcpIsClientValid(                                     // is it acceptable to offer this client the ipaddress?
    IN      DHCP_IP_ADDRESS        ClientIpAddress,
    IN      LPBYTE                 OptionHardwareAddress,
    IN      DWORD                  OptionHardwareAddressLength,
    OUT     BOOL                  *fReconciled
) {
    LPBYTE                         LocalHardwareAddress = NULL;
    LPSTR                          IpAddressString;
    DWORD                          Length;
    DWORD                          Error;
    BOOL                           ReturnStatus = TRUE;

    (*fReconciled) = FALSE;
    LOCK_DATABASE();

    do {

        Error = DhcpJetOpenKey( DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                                &ClientIpAddress,
                                sizeof( ClientIpAddress )
                                );

        if ( Error != ERROR_SUCCESS ) {
            break;
        }

        Length = 0;
        Error = DhcpJetGetValue( DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                                 &LocalHardwareAddress,
                                 &Length
                                 );

        if ( ERROR_SUCCESS != Error ) {
            ReturnStatus = FALSE;
            break;
        }
        // length should always be > 0 when the query is successful
        DhcpAssert( 0 != Length );

        if (Length == OptionHardwareAddressLength + sizeof(ClientIpAddress) + sizeof(BYTE) &&
            (RtlCompareMemory(( LPBYTE ) LocalHardwareAddress + sizeof( DHCP_IP_ADDRESS ) + sizeof( BYTE ),
                              OptionHardwareAddress,
                              Length - sizeof(DHCP_IP_ADDRESS) - sizeof(BYTE)) ==
             Length - sizeof(DHCP_IP_ADDRESS) - sizeof(BYTE))) {
            break;
        }

#if 1

        //
        // ?? this can be removed when all client UIDs are converted from
        // old farmat to new. OldFormat - just hardware address
        // NewFormat- Subnet + HWType + HWAddress.
        //

        if( Length == OptionHardwareAddressLength &&
            (RtlCompareMemory(LocalHardwareAddress,OptionHardwareAddress,Length) == Length) ) {
            break;
        }

#endif

        if( Length >= sizeof(ClientIpAddress) &&
            RtlCompareMemory(LocalHardwareAddress, (LPBYTE)&ClientIpAddress, sizeof(ClientIpAddress)) == sizeof(ClientIpAddress)) {
            // Bad address
            (*fReconciled) = TRUE;
            break;
        }

        IpAddressString = DhcpIpAddressToDottedString(ClientIpAddress);
        if ( NULL == IpAddressString ) {
            ReturnStatus = FALSE;
            break;
        }

        if( Length >= strlen(IpAddressString) &&
            RtlCompareMemory(LocalHardwareAddress, IpAddressString, strlen(IpAddressString)) == strlen(IpAddressString)) {
            // reconciled address?
            (*fReconciled) = TRUE;
            break;
        }

        ReturnStatus = FALSE;
    } while ( FALSE );

    UNLOCK_DATABASE();

    if( LocalHardwareAddress != NULL ) {
        MIDL_user_free( LocalHardwareAddress );
    }

    return( ReturnStatus );
}


BOOL
DhcpValidateClient(
    DHCP_IP_ADDRESS ClientIpAddress,
    PVOID HardwareAddress,
    DWORD HardwareAddressLength
    )
/*++

Routine Description:

    This function verifies that an IP address and hardware address match.

Arguments:

    ClientIpAddress - The IP address of the client.

    HardwareAddress - The hardware address of the client

    HardwareAddressLenght - The length, in bytes, of the hardware address.

Return Value:

    The status of the operation.

--*/
{
    LPBYTE LocalHardwareAddress = NULL;
    DWORD Length;
    DWORD Error;
    BOOL ReturnStatus = FALSE;

    LOCK_DATABASE();

    Error = DhcpJetOpenKey(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                &ClientIpAddress,
                sizeof( ClientIpAddress ) );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Length = 0;
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                &LocalHardwareAddress,
                &Length );
    if ( ERROR_SUCCESS != Error ) {
        goto Cleanup;
    }

    if (Length == HardwareAddressLength &&
        DhcpInSameSuperScope(
                *((LPDHCP_IP_ADDRESS) LocalHardwareAddress),
                *((LPDHCP_IP_ADDRESS) HardwareAddress))       &&
        (RtlCompareMemory(
                (LPBYTE) LocalHardwareAddress + sizeof(DHCP_IP_ADDRESS),
                (LPBYTE) HardwareAddress + sizeof(DHCP_IP_ADDRESS),
                Length - sizeof(DHCP_IP_ADDRESS) )
                    == Length - sizeof(DHCP_IP_ADDRESS)))
    {
        ReturnStatus = TRUE;
        goto Cleanup;
    }

#if 1

    //
    // ?? this can be removed when all client UIDs are converted from
    // old farmat to new. OldFormat - just hardware address
    // NewFormat- Subnet + HWType + HWAddress.
    //

    if ( (Length == (HardwareAddressLength -
                        sizeof(DHCP_IP_ADDRESS) - sizeof(BYTE))) &&
            (RtlCompareMemory(
                LocalHardwareAddress,
                (LPBYTE)HardwareAddress +
                    sizeof(DHCP_IP_ADDRESS) + sizeof(BYTE),
                Length ) == Length) ) {

        ReturnStatus = TRUE;
        goto Cleanup;
    }

#endif

Cleanup:

    UNLOCK_DATABASE();

    if( LocalHardwareAddress != NULL ) {
        MIDL_user_free( LocalHardwareAddress );
    }

    return( ReturnStatus );
}

//
// Client APIs
//


DWORD
R_DhcpCreateClientInfo(
    DHCP_SRV_HANDLE     ServerIpAddress,
    LPDHCP_CLIENT_INFO  ClientInfo
    )
/*++

Routine Description:
    This function is provided for use by older versions of the DHCP
    Manager application.  It's semantics are identical to
    R_DhcpCreateClientInfoV4.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/

{
    DWORD                dwResult;
    DHCP_CLIENT_INFO_V4 *pClientInfoV4;

    pClientInfoV4 = CopyClientInfoToV4( ClientInfo );

    if ( pClientInfoV4 )
    {
        pClientInfoV4->bClientType = CLIENT_TYPE_NONE;

        dwResult = R_DhcpCreateClientInfoV4(
                            ServerIpAddress,
                            pClientInfoV4
                            );
        _fgs__DHCP_CLIENT_INFO( pClientInfoV4 );
        MIDL_user_free( pClientInfoV4 );

    }
    else
        dwResult = ERROR_NOT_ENOUGH_MEMORY;


    return dwResult;
}


DWORD
R_DhcpCreateClientInfoV4(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
/*++

Routine Description:

    This function creates a client record in server's database. Also
    this marks the specified client IP address as unavailable (or
    distributed). This function returns error under the following cases :

    1. If the specified client IP address is not within the server
        management.

    2. If the specified client IP address is already unavailable.

    3. If the specified client record is already in the server's
        database.

    This function may be used to distribute IP addresses manually.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS ClientSubnetMask;

    BYTE *ClientUID = NULL;
    DWORD ClientUIDLength;


    DhcpAssert( ClientInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    IpAddress = ClientInfo->ClientIpAddress;
    DhcpPrint(( DEBUG_APIS, "DhcpCreateClientInfo is called, (%s).\n",
                    DhcpIpAddressToDottedString(IpAddress) ));

    if( (ClientInfo->ClientHardwareAddress.Data == NULL) ||
            (ClientInfo->ClientHardwareAddress.DataLength == 0 )) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // make client UID from client hardware address.
    //

    ClientSubnetMask = DhcpGetSubnetMaskForAddress( IpAddress );
    if( ClientSubnetMask == 0) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    ClientUID = NULL;
    Error = DhcpMakeClientUID(
        ClientInfo->ClientHardwareAddress.Data,
        (BYTE)ClientInfo->ClientHardwareAddress.DataLength,
        HARDWARE_TYPE_10MB_EITHERNET,
        IpAddress & ClientSubnetMask,
        &ClientUID,
        &ClientUIDLength
    );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpAssert( (ClientUID != NULL) && (ClientUIDLength != 0) );

    //
    // DhcpCreateClientEntry locks database.
    //

    Error = DhcpCreateClientEntry(
        IpAddress,
        ClientUID,
        ClientUIDLength,
        ClientInfo->ClientLeaseExpires,
        ClientInfo->ClientName,
        ClientInfo->ClientComment,
        CLIENT_TYPE_NONE,
        DhcpRegKeyToIpAddress(ServerIpAddress),
        // IpAddress of the server
        ADDRESS_STATE_ACTIVE,   // make active immediately.
        FALSE                   // not existing..
    );

    if( Error == ERROR_SUCCESS ) {
        DhcpAssert( IpAddress == ClientInfo->ClientIpAddress);
    }
    else {

        //
        // if the specified address exists, then the client
        // already exists.
        //

        if( Error == ERROR_DHCP_ADDRESS_NOT_AVAILABLE ) {

            Error = ERROR_DHCP_CLIENT_EXISTS;
        }
    }

Cleanup:

    if( ClientUID != NULL ) {
        DhcpFreeMemory( ClientUID );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpCreateClientInfo failed, %ld.\n",
                        Error ));
    }

    return( Error );
}

DWORD
R_DhcpSetClientInfo(
    DHCP_SRV_HANDLE     ServerIpAddress,
    LPDHCP_CLIENT_INFO  ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.  It is provided for compatibility with older versions of
    the DHCP Administrator application.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/

{
    DHCP_CLIENT_INFO_V4 *pClientInfoV4 = NULL;
    DHCP_SEARCH_INFO    SearchInfo;
    DWORD               dwResult;


    //
    // first retrieve the existing client info
    //

    SearchInfo.SearchType                 = DhcpClientIpAddress;
    SearchInfo.SearchInfo.ClientIpAddress = ClientInfo->ClientIpAddress;


    dwResult = R_DhcpGetClientInfoV4(
                        ServerIpAddress,
                        &SearchInfo,
                        &pClientInfoV4
                        );

    //
    // the fields below are causing whistler bug 221104
    // setting them explicitly to NULL.
    //

    if ( pClientInfoV4 )
    {
        pClientInfoV4 -> OwnerHost.NetBiosName = NULL;
        pClientInfoV4 -> OwnerHost.HostName = NULL;
    }

    if (( ERROR_SUCCESS == dwResult ) &&
        ( NULL != pClientInfoV4 ))
    {
        BYTE bClientType;

        //
        // save the client type
        //

        bClientType = pClientInfoV4->bClientType;
        _fgs__DHCP_CLIENT_INFO( pClientInfoV4 );
        MIDL_user_free( pClientInfoV4 );

        pClientInfoV4 = CopyClientInfoToV4( ClientInfo );
        if ( pClientInfoV4 )
        {
            pClientInfoV4->bClientType = bClientType;

            dwResult = R_DhcpSetClientInfoV4(
                            ServerIpAddress,
                            pClientInfoV4
                            );

            _fgs__DHCP_CLIENT_INFO( pClientInfoV4 );
            MIDL_user_free( pClientInfoV4 );
        }
        else dwResult = ERROR_NOT_ENOUGH_MEMORY;

    }
    else
    {
        DhcpPrint( (DEBUG_APIS, "R_DhcpGetClientInfo failed from R_DhcpSetClientInfo: %d\n",
                                dwResult ));
    }

    return dwResult;
}


DWORD
R_DhcpSetClientInfoV4(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    DHCP_REQUEST_CONTEXT   DummyCtxt;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS ClientSubnetMask;
    DHCP_IP_ADDRESS ClientSubnetAddress;

    BYTE *ClientUID = NULL;
    DWORD ClientUIDLength;

    BYTE *SetClientUID = NULL;
    DWORD SetClientUIDLength;

    WCHAR KeyBuffer[DHCP_IP_KEY_LEN * 5];
    LPWSTR KeyName;

    HKEY ReservedIpHandle = NULL;

    DhcpAssert( ClientInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    IpAddress = ClientInfo->ClientIpAddress;
    DhcpPrint(( DEBUG_APIS, "DhcpSetClientInfo is called, (%s).\n",
                    DhcpIpAddressToDottedString(IpAddress) ));

    if( (ClientInfo->ClientHardwareAddress.Data == NULL) ||
            (ClientInfo->ClientHardwareAddress.DataLength == 0 )) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // make client UID from client hardware address, if the caller just
    // specified hardware address.
    //

    ClientSubnetMask = DhcpGetSubnetMaskForAddress( IpAddress );
    if( ClientSubnetMask == 0) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    ClientSubnetAddress = IpAddress & ClientSubnetMask;

    if( (ClientInfo->ClientHardwareAddress.DataLength >
            sizeof(ClientSubnetAddress)) &&
         (memcmp( ClientInfo->ClientHardwareAddress.Data,
                    &ClientSubnetAddress,
                    sizeof(ClientSubnetAddress)) == 0) ) {

        SetClientUID = ClientInfo->ClientHardwareAddress.Data;
        SetClientUIDLength =
            (BYTE)ClientInfo->ClientHardwareAddress.DataLength;
    }
    else {
        ClientUID = NULL;
        Error = DhcpMakeClientUID(
            ClientInfo->ClientHardwareAddress.Data,
            (BYTE)ClientInfo->ClientHardwareAddress.DataLength,
            HARDWARE_TYPE_10MB_EITHERNET,
            IpAddress & ClientSubnetMask,
            &ClientUID,
            &ClientUIDLength
        );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpAssert( (ClientUID != NULL) && (ClientUIDLength != 0) );

        SetClientUID = ClientUID;
        SetClientUIDLength = ClientUIDLength;
    }

    //
    // DhcpCreateClientEntry locks database.
    //

    IpAddress = ClientInfo->ClientIpAddress;
    memset( &DummyCtxt, 0, sizeof( DummyCtxt ));
    DummyCtxt.Server = DhcpGetCurrentServer();
    Error = DhcpRequestSpecificAddress(
        &DummyCtxt,
        IpAddress
    );
    // if( ERROR_SUCCESS != Error ) goto Cleanup;

    Error = DhcpCreateClientEntry(
                IpAddress,
                SetClientUID,
                SetClientUIDLength,
                ClientInfo->ClientLeaseExpires,
                ClientInfo->ClientName,
                ClientInfo->ClientComment,
                CLIENT_TYPE_NONE,
                ClientInfo->OwnerHost.IpAddress,
                ADDRESS_STATE_ACTIVE,   // make active immediately.
                TRUE );                 // Existing

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpAssert( IpAddress == ClientInfo->ClientIpAddress);


    Error = DhcpBeginWriteApi("DhcpSetClientInfoV4");
    if( NO_ERROR != Error ) goto Cleanup;
    
    if( DhcpServerIsAddressReserved(DhcpGetCurrentServer(), IpAddress ) ) {
        Error = DhcpUpdateReservationInfo(
            IpAddress,
            SetClientUID,
            SetClientUIDLength
        );

        Error = DhcpEndWriteApiEx(
            "DhcpSetClientInfoV4", Error, FALSE, FALSE, 0, 0,
            IpAddress );
    } else {

        Error = DhcpEndWriteApi("DhcpSetClientInfoV4", Error);
    }

    if( Error != ERROR_SUCCESS ) goto Cleanup;

Cleanup:

    if( ClientUID != NULL ) {
        DhcpFreeMemory( ClientUID );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpSetClientInfo failed, %ld.\n",
                        Error ));
    }

    if( ReservedIpHandle != NULL ) {
        RegCloseKey( ReservedIpHandle );
    }

    return( Error );
}

DWORD
R_DhcpGetClientInfo(
    DHCP_SRV_HANDLE     ServerIpAddress,
    LPDHCP_SEARCH_INFO  SearchInfo,
    LPDHCP_CLIENT_INFO  *ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.  It is provided for use by older versions of the DHCP
    Administrator application.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/

{
    DHCP_CLIENT_INFO_V4 *pClientInfoV4 = NULL;
    DWORD                dwResult;

    dwResult = R_DhcpGetClientInfoV4(
                    ServerIpAddress,
                    SearchInfo,
                    &pClientInfoV4
                    );

    if ( ERROR_SUCCESS == dwResult )
    {
        //
        // since the V4 fields are at the end of the struct, it is safe to
        // simply return the V4 struct
        //

        *ClientInfo = ( DHCP_CLIENT_INFO *) pClientInfoV4;
    }

    return dwResult;
}


DWORD
R_DhcpGetClientInfoV4(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_CLIENT_INFO_V4 *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    LPDHCP_CLIENT_INFO_V4 LocalClientInfo = NULL;

    DhcpAssert( SearchInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LOCK_DATABASE();

    //
    // open appropriate record and set current position.
    //

    switch( SearchInfo->SearchType ) {
    case DhcpClientIpAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo is called, (%s).\n",
                        DhcpIpAddressToDottedString(
                            SearchInfo->SearchInfo.ClientIpAddress) ));
        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    &SearchInfo->SearchInfo.ClientIpAddress,
                    sizeof( DHCP_IP_ADDRESS ) );

        break;
    case DhcpClientHardwareAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo is called "
                        "with HW address.\n"));
        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
                    SearchInfo->SearchInfo.ClientHardwareAddress.Data,
                    SearchInfo->SearchInfo.ClientHardwareAddress.DataLength );

        break;
    case DhcpClientName:
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo is called, (%ws).\n",
                        SearchInfo->SearchInfo.ClientName ));

        if( SearchInfo->SearchInfo.ClientName == NULL ) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColName,
                    SearchInfo->SearchInfo.ClientName,
                    (wcslen(SearchInfo->SearchInfo.ClientName) + 1) *
                        sizeof(WCHAR) );

        break;
    default:
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo is called "
                        "with invalid parameter.\n"));
        Error = ERROR_INVALID_PARAMETER;
        break;
    }


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpGetCurrentClientInfo( ClientInfo, NULL, NULL, 0 );

Cleanup:

    UNLOCK_DATABASE();

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo failed, %ld.\n",
                        Error ));
    }

    return( Error );
}


DWORD
R_DhcpDeleteClientInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    )
/*++

Routine Description:

    This function deletes the specified client record. Also it frees up
    the client IP address for redistribution.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to a client information which is the key for
        the client's record search.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    DHCP_IP_ADDRESS FreeIpAddress, SubnetAddress;
    DWORD Size;
    LPBYTE HardwareAddress = NULL, Hw;
    DWORD HardwareAddressLength = 0, HwLen, HwType;
    BOOL TransactBegin = FALSE;
    BYTE bAllowedClientTypes, bClientType;
    BYTE AddressState;
    BOOL AlreadyDeleted = FALSE;

    DhcpAssert( ClientInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // lock both registry and database locks here to avoid dead lock.
    //

    LOCK_DATABASE();

    //
    // start transaction before a create/update database record.
    //

    Error = DhcpJetBeginTransaction();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    TransactBegin = TRUE;

    //
    // open appropriate record and set current position.
    //

    switch( ClientInfo->SearchType ) {
    case DhcpClientIpAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo is called, (%s).\n",
                        DhcpIpAddressToDottedString(
                            ClientInfo->SearchInfo.ClientIpAddress) ));
        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    &ClientInfo->SearchInfo.ClientIpAddress,
                    sizeof( DHCP_IP_ADDRESS ) );
        break;
    case DhcpClientHardwareAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo is called "
                        "with HW address.\n"));
        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
                    ClientInfo->SearchInfo.ClientHardwareAddress.Data,
                    ClientInfo->SearchInfo.ClientHardwareAddress.DataLength );
        break;
    case DhcpClientName:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo is called, (%ws).\n",
                        ClientInfo->SearchInfo.ClientName ));

        if( ClientInfo->SearchInfo.ClientName == NULL ) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColName,
                    ClientInfo->SearchInfo.ClientName,
                    (wcslen(ClientInfo->SearchInfo.ClientName) + 1) *
                        sizeof(WCHAR) );
        break;

    default:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo is called "
                        "with invalid parameter.\n"));
        Error = ERROR_INVALID_PARAMETER;
        break;
    }


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // read IpAddress and Hardware Address info from database.
    //

    Size = sizeof(DHCP_IP_ADDRESS);
    Error = DhcpJetGetValue(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
            &FreeIpAddress,
            &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetGetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            &HardwareAddress,
            &HardwareAddressLength );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


#if DBG

    switch( ClientInfo->SearchType ) {
    case DhcpClientIpAddress:
        DhcpAssert(
            FreeIpAddress ==
                ClientInfo->SearchInfo.ClientIpAddress );
        break;
    case DhcpClientHardwareAddress:

        DhcpAssert(
            HardwareAddressLength ==
                ClientInfo->SearchInfo.ClientHardwareAddress.DataLength );

        DhcpAssert(
            RtlCompareMemory(
                HardwareAddress,
                ClientInfo->SearchInfo.ClientHardwareAddress.Data,
                HardwareAddressLength ) ==
                    HardwareAddressLength );

        break;

    case DhcpClientName:
        break;
    }

#endif // DBG

    //
    // if this IP address is reserved, we shouldn't be deleting the entry.
    //

    if( DhcpServerIsAddressReserved(DhcpGetCurrentServer(), FreeIpAddress )) {
        Error = ERROR_DHCP_RESERVED_CLIENT;
        goto Cleanup;
    }

    //
    // Get Client type -- we need that to figure out what kind of client it is
    // that we are trying to delete..
    //
    Size = sizeof(bClientType);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
        &bClientType,
        &Size
        );
    if( ERROR_SUCCESS != Error ) {
        bClientType = CLIENT_TYPE_DHCP;
    }

    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        &Size
    );

    if( ERROR_SUCCESS != Error ) goto Cleanup;

    DhcpUpdateAuditLog(
        DHCP_IP_LOG_DELETED,
        GETSTRING( DHCP_IP_LOG_DELETED_NAME),
        FreeIpAddress,
        HardwareAddress,
        HardwareAddressLength,
        NULL
    );

    SubnetAddress = (
        DhcpGetSubnetMaskForAddress(FreeIpAddress) & FreeIpAddress
        );
    if( HardwareAddressLength > sizeof(SubnetAddress) &&
        0 == memcmp((LPBYTE)&SubnetAddress, HardwareAddress, sizeof(SubnetAddress) )) {
        //
        // First four characters are subnet address.. So, we will strip that...
        //
        Hw = HardwareAddress + sizeof(SubnetAddress);
        HwLen = HardwareAddressLength - sizeof(SubnetAddress);
    } else {
        Hw = HardwareAddress ;
        HwLen = HardwareAddressLength;
    }

    if( HwLen ) {
        HwLen --;
        HwType = *Hw++;
    } else {
        HwType = 0;
        Hw = NULL;
    }
    
    CALLOUT_DELETED( FreeIpAddress, Hw, HwLen, 0);

    if( IsAddressDeleted(AddressState) ) {
        DhcpDoDynDnsCheckDelete(FreeIpAddress);
        DhcpPrint((DEBUG_ERRORS, "Forcibly deleting entry for ip-address %s\n",
                   inet_ntoa(*(struct in_addr *)&FreeIpAddress)));
        AlreadyDeleted = TRUE;
    } else if( !DhcpDoDynDnsCheckDelete(FreeIpAddress) ) {
        // Dont delete if not asked to
        DhcpPrint((DEBUG_ERRORS, "Not deleting record because of DNS de-registration pending!\n"));
    } else {
        Error = DhcpMapJetError(
            JetDelete(
                DhcpGlobalJetServerSession,
                DhcpGlobalClientTableHandle ),
            "DeleteClientInfo:Delete");

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

    //
    // Finally, mark the IP address available
    //

    if( AlreadyDeleted ) {
        Error = ERROR_SUCCESS;                         // if this deleted, address wont be there in bitmap..
    } else {
        if( CLIENT_TYPE_BOOTP == bClientType ) {
            Error = DhcpReleaseBootpAddress( FreeIpAddress );
            if( ERROR_SUCCESS != Error ) {
                DhcpReleaseAddress( FreeIpAddress );
            }
        } else {
            Error = DhcpReleaseAddress( FreeIpAddress );
            if( ERROR_SUCCESS != Error ) {
                DhcpReleaseBootpAddress( FreeIpAddress );
            }
        }

        if( ERROR_FILE_NOT_FOUND == Error )
            Error = ERROR_SUCCESS;                     // ok -- may be deleting deleted records..
    }

Cleanup:

    if ( Error != ERROR_SUCCESS ) {

        //
        // if the transaction has been started, than roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        //

        if( TransactBegin == TRUE ) {
            DWORD LocalError;

            LocalError = DhcpJetRollBack();
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }

        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo failed, %ld.\n",
                        Error ));
    }
    else {

        //
        // commit the transaction before we return.
        //

        DWORD LocalError;

        DhcpAssert( TransactBegin == TRUE );

        LocalError = DhcpJetCommitTransaction();
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }

    UNLOCK_DATABASE();

    return(Error);
}

DWORD
R_DhcpEnumSubnetClients(
    DHCP_SRV_HANDLE             ServerIpAddress,
    DHCP_IP_ADDRESS             SubnetAddress,
    DHCP_RESUME_HANDLE         *ResumeHandle,
    DWORD                       PreferredMaximum,
    DHCP_CLIENT_INFO_ARRAY    **ClientInfo,
    DWORD                      *ClientsRead,
    DWORD                      *ClientsTotal
    )

/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet. However it returns clients from all subnets if the subnet
    address specified is zero.   This function is provided for use by
    older version of the DHCP Administrator application.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet. Client filter is disabled
        and clients from all subnet are returned if this subnet address
        is zero.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DHCP_CLIENT_INFO_ARRAY_V4 *pClientInfoV4 = NULL;
    DWORD                      dwResult;

    dwResult = R_DhcpEnumSubnetClientsV4(
                        ServerIpAddress,
                        SubnetAddress,
                        ResumeHandle,
                        PreferredMaximum,
                        &pClientInfoV4,
                        ClientsRead,
                        ClientsTotal
                        );

    if ( ERROR_SUCCESS == dwResult || ERROR_MORE_DATA == dwResult )
    {
        *ClientInfo = ( DHCP_CLIENT_INFO_ARRAY * )
                            pClientInfoV4;
    }
    else
    {
        //
        // if R_DhcpEnumSubnetClientsV4 failed, pClientInfoV4 should be NULL.
        //

        DhcpAssert( !pClientInfoV4 );
        DhcpPrint( ( DEBUG_ERRORS,
                    "R_DhcpEnumSubnetClients failed.\n" ));
    }


    DhcpPrint( ( DEBUG_MISC,
                "R_DhcpEnumSubnetClients returns %x\n", dwResult ));

    DhcpPrint( ( DEBUG_MISC,
                "R_DhcpEnumSubnetClients: Clients read =%d, ClientsTotal = %d\n",
                *ClientsRead,
                *ClientsTotal ) );

    return dwResult;
}


DWORD
R_DhcpEnumSubnetClientsV4(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V4 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet. However it returns clients from all subnets if the subnet
    address specified is zero.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet. Client filter is disabled
        and clients from all subnet are returned if this subnet address
        is zero.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    JET_ERR JetError;
    DWORD i;
    JET_RECPOS JetRecordPosition;
    LPDHCP_CLIENT_INFO_ARRAY_V4 LocalEnumInfo = NULL;
    DWORD ElementsCount;

    DWORD RemainingRecords;
    DWORD ConsumedSize;
    DHCP_RESUME_HANDLE LocalResumeHandle = 0;

    DhcpPrint(( DEBUG_APIS, "DhcpEnumSubnetClients is called, (%s).\n",
                    DhcpIpAddressToDottedString(SubnetAddress) ));

    DhcpAssert( *ClientInfo == NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LOCK_DATABASE();

    //
    // position the current record pointer to appropriate position.
    //

    if( *ResumeHandle == 0 ) {

        //
        // fresh enumeration, start from begining.
        //

        Error = DhcpJetPrepareSearch(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    TRUE,   // Search from start
                    NULL,
                    0
                    );
    }
    else {

        //
        // start from the record where we stopped last time.
        //

        //
        // we place the IpAddress of last record in the resume handle.
        //

        DhcpAssert( sizeof(*ResumeHandle) == sizeof(DHCP_IP_ADDRESS) );

        Error = DhcpJetPrepareSearch(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    FALSE,
                    ResumeHandle,
                    sizeof(*ResumeHandle) );

     }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


    //
    // now query remaining records in the database.
    //

    JetError = JetGetRecordPosition(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    &JetRecordPosition,
                    sizeof(JET_RECPOS) );

    Error = DhcpMapJetError( JetError, "EnumClientsV4:GetRecordPosition" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpPrint(( DEBUG_APIS, "JetGetRecordPosition returned, "
                    "entriesLT = %ld, "
                    "entriesInRange = %ld, "
                    "entriesTotal = %ld.\n",
                        JetRecordPosition.centriesLT,
                        JetRecordPosition.centriesInRange,
                        JetRecordPosition.centriesTotal ));

#if 0
    //
    // IpAddress is unique, we find exactly one record for this key.
    //

    DhcpAssert( JetRecordPosition.centriesInRange == 1 );

    RemainingRecords = JetRecordPosition.centriesTotal -
                            JetRecordPosition.centriesLT;

    DhcpAssert( (INT)RemainingRecords > 0 );

    if( RemainingRecords == 0 ) {
        Error = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

#else

    //
    // ?? always return big value, until we know a reliable way to
    // determine the remaining records.
    //

    RemainingRecords = 0x7FFFFFFF;

#endif


    //
    // limit resource.
    //

    if( PreferredMaximum > DHCP_ENUM_BUFFER_SIZE_LIMIT ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT;
    }

    //
    // if the PreferredMaximum buffer size is too small ..
    //

    if( PreferredMaximum < DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN;
    }

    //
    // allocate enum array.
    //

    //
    // determine possible number of records that can be returned in
    // PreferredMaximum buffer;
    //

    ElementsCount =
        ( PreferredMaximum - sizeof(DHCP_CLIENT_INFO_ARRAY_V4) ) /
            (sizeof(LPDHCP_CLIENT_INFO_V4) + sizeof(DHCP_CLIENT_INFO_V4));

    LocalEnumInfo = MIDL_user_allocate( sizeof(DHCP_CLIENT_INFO_ARRAY_V4) );

    if( LocalEnumInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalEnumInfo->NumElements = 0;

    LocalEnumInfo->Clients =
        MIDL_user_allocate(sizeof(LPDHCP_CLIENT_INFO_V4) * ElementsCount);

    if( LocalEnumInfo->Clients == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ConsumedSize = sizeof(DHCP_CLIENT_INFO_ARRAY_V4);
    for( i = 0;
                // if we have filled up the return buffer.
            (LocalEnumInfo->NumElements < ElementsCount) &&
                // no more record in the database.
            (i < RemainingRecords);
                        i++ ) {

        LPDHCP_CLIENT_INFO_V4 CurrentClientInfo;
        DWORD CurrentInfoSize;
        DWORD NewSize;
        BOOL ValidClient;

        //
        // read current record.
        //


        CurrentClientInfo = NULL;
        CurrentInfoSize = 0;
        ValidClient = FALSE;

        Error = DhcpGetCurrentClientInfo(
                    &CurrentClientInfo,
                    &CurrentInfoSize,
                    &ValidClient,
                    SubnetAddress );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        if( ValidClient ) {

            //
            // client belongs to the requested subnet, so pack it.
            //

            NewSize =
                ConsumedSize +
                    CurrentInfoSize +
                        sizeof(LPDHCP_CLIENT_INFO_V4); // for pointer.

            if( NewSize < PreferredMaximum ) {

                //
                // we have space for the current record.
                //

                LocalEnumInfo->Clients[LocalEnumInfo->NumElements] =
                    CurrentClientInfo;
                LocalEnumInfo->NumElements++;

                ConsumedSize = NewSize;
            }
            else {

                //
                // we have filled the buffer.
                //

                Error = ERROR_MORE_DATA;

                if( 0 ) {
                    //
                    //  resume handle has to be the LAST ip address RETURNED.
                    //  this is the next one.. so don't do this..
                    //
                    LocalResumeHandle =
                       (DHCP_RESUME_HANDLE)CurrentClientInfo->ClientIpAddress;
                }

                //
                // free last record.
                //

                _fgs__DHCP_CLIENT_INFO ( CurrentClientInfo );

                break;
            }

        }

        //
        // move to next record.
        //

        Error = DhcpJetNextRecord();

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                break;
            }

            goto Cleanup;
        }
    }

    *ClientInfo = LocalEnumInfo;
    *ClientsRead = LocalEnumInfo->NumElements;

    if( Error == ERROR_NO_MORE_ITEMS ) {

        *ClientsTotal = LocalEnumInfo->NumElements;
        *ResumeHandle = 0;
        Error = ERROR_SUCCESS;

#if 0
        //
        // when we have right RemainingRecords count.
        //

        DhcpAssert( RemainingRecords == LocalEnumInfo->NumElements );
#endif

    }
    else {

        *ClientsTotal = RemainingRecords;
        if( LocalResumeHandle != 0 ) {

            *ResumeHandle = LocalResumeHandle;
        }
        else {

            *ResumeHandle =
                LocalEnumInfo->Clients
                    [LocalEnumInfo->NumElements - 1]->ClientIpAddress;
        }

        Error = ERROR_MORE_DATA;
    }

Cleanup:

    UNLOCK_DATABASE();

    if( (Error != ERROR_SUCCESS) &&
        (Error != ERROR_MORE_DATA) ) {

        //
        // if we aren't succssful return locally allocated buffer.
        //

        if( LocalEnumInfo != NULL ) {
            _fgs__DHCP_CLIENT_INFO_ARRAY( LocalEnumInfo );
            MIDL_user_free( LocalEnumInfo );
        }

        DhcpPrint(( DEBUG_APIS, "DhcpEnumSubnetClients failed, %ld.\n",
                        Error ));
    }

    return(Error);
}


DWORD
R_DhcpEnumSubnetClientsV5(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V5 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet. However it returns clients from all subnets if the subnet
    address specified is zero.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet. Client filter is disabled
        and clients from all subnet are returned if this subnet address
        is zero.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    JET_ERR JetError;
    DWORD i;
    JET_RECPOS JetRecordPosition;
    LPDHCP_CLIENT_INFO_ARRAY_V5 LocalEnumInfo = NULL;
    DWORD ElementsCount;

    DWORD RemainingRecords;
    DWORD ConsumedSize;
    DHCP_RESUME_HANDLE LocalResumeHandle = 0;

    DhcpPrint(( DEBUG_APIS, "DhcpEnumSubnetClients is called, (%s).\n",
                    DhcpIpAddressToDottedString(SubnetAddress) ));

    DhcpAssert( *ClientInfo == NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LOCK_DATABASE();

    //
    // position the current record pointer to appropriate position.
    //

    if( *ResumeHandle == 0 ) {

        //
        // fresh enumeration, start from begining.
        //

        Error = DhcpJetPrepareSearch(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    TRUE,   // Search from start
                    NULL,
                    0
                    );
    }
    else {

        //
        // start from the record where we stopped last time.
        //

        //
        // we place the IpAddress of last record in the resume handle.
        //

        DhcpAssert( sizeof(*ResumeHandle) == sizeof(DHCP_IP_ADDRESS) );

        Error = DhcpJetPrepareSearch(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    FALSE,
                    ResumeHandle,
                    sizeof(*ResumeHandle) );

     }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


    //
    // now query remaining records in the database.
    //

    JetError = JetGetRecordPosition(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    &JetRecordPosition,
                    sizeof(JET_RECPOS) );

    Error = DhcpMapJetError( JetError, "EnumClientsV5:GetRecordPosition" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpPrint(( DEBUG_APIS, "JetGetRecordPosition returned, "
                    "entriesLT = %ld, "
                    "entriesInRange = %ld, "
                    "entriesTotal = %ld.\n",
                        JetRecordPosition.centriesLT,
                        JetRecordPosition.centriesInRange,
                        JetRecordPosition.centriesTotal ));

#if 0
    //
    // IpAddress is unique, we find exactly one record for this key.
    //

    DhcpAssert( JetRecordPosition.centriesInRange == 1 );

    RemainingRecords = JetRecordPosition.centriesTotal -
                            JetRecordPosition.centriesLT;

    DhcpAssert( (INT)RemainingRecords > 0 );

    if( RemainingRecords == 0 ) {
        Error = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

#else

    //
    // ?? always return big value, until we know a reliable way to
    // determine the remaining records.
    //

    RemainingRecords = 0x7FFFFFFF;

#endif


    //
    // limit resource.
    //

    if( PreferredMaximum > DHCP_ENUM_BUFFER_SIZE_LIMIT ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT;
    }

    //
    // if the PreferredMaximum buffer size is too small ..
    //

    if( PreferredMaximum < DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN;
    }

    //
    // allocate enum array.
    //

    //
    // determine possible number of records that can be returned in
    // PreferredMaximum buffer;
    //

    ElementsCount =
        ( PreferredMaximum - sizeof(DHCP_CLIENT_INFO_ARRAY_V5) ) /
            (sizeof(LPDHCP_CLIENT_INFO_V5) + sizeof(DHCP_CLIENT_INFO_V5));

    LocalEnumInfo = MIDL_user_allocate( sizeof(DHCP_CLIENT_INFO_ARRAY_V5) );

    if( LocalEnumInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalEnumInfo->NumElements = 0;

    LocalEnumInfo->Clients =
        MIDL_user_allocate(sizeof(LPDHCP_CLIENT_INFO_V5) * ElementsCount);

    if( LocalEnumInfo->Clients == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ConsumedSize = sizeof(DHCP_CLIENT_INFO_ARRAY_V5);
    for( i = 0;
                // if we have filled up the return buffer.
            (LocalEnumInfo->NumElements < ElementsCount) &&
                // no more record in the database.
            (i < RemainingRecords);
                        i++ ) {

        LPDHCP_CLIENT_INFO_V5 CurrentClientInfo;
        DWORD CurrentInfoSize;
        DWORD NewSize;
        BOOL ValidClient;

        //
        // read current record.
        //


        CurrentClientInfo = NULL;
        CurrentInfoSize = 0;
        ValidClient = FALSE;

        Error = DhcpGetCurrentClientInfoV5(
                    &CurrentClientInfo,
                    &CurrentInfoSize,
                    &ValidClient,
                    SubnetAddress );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        if( ValidClient ) {

            //
            // client belongs to the requested subnet, so pack it.
            //

            NewSize =
                ConsumedSize +
                    CurrentInfoSize +
                        sizeof(LPDHCP_CLIENT_INFO_V5); // for pointer.

            if( NewSize < PreferredMaximum ) {

                //
                // we have space for the current record.
                //

                LocalEnumInfo->Clients[LocalEnumInfo->NumElements] =
                    CurrentClientInfo;
                LocalEnumInfo->NumElements++;

                ConsumedSize = NewSize;
            }
            else {

                //
                // we have filled the buffer.
                //

                Error = ERROR_MORE_DATA;

                if( 0 ) {
                    //
                    //  resume handle has to be the LAST ip address RETURNED.
                    //  this is the next one.. so don't do this..
                    //
                    LocalResumeHandle =
                       (DHCP_RESUME_HANDLE)CurrentClientInfo->ClientIpAddress;
                }

                //
                // free last record.
                //

                _fgs__DHCP_CLIENT_INFO_V5 ( CurrentClientInfo );

                break;
            }

        }

        //
        // move to next record.
        //

        Error = DhcpJetNextRecord();

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                break;
            }

            goto Cleanup;
        }
    }

    *ClientInfo = LocalEnumInfo;
    *ClientsRead = LocalEnumInfo->NumElements;

    if( Error == ERROR_NO_MORE_ITEMS ) {

        *ClientsTotal = LocalEnumInfo->NumElements;
        *ResumeHandle = 0;
        Error = ERROR_SUCCESS;

#if 0
        //
        // when we have right RemainingRecords count.
        //

        DhcpAssert( RemainingRecords == LocalEnumInfo->NumElements );
#endif

    }
    else {

        *ClientsTotal = RemainingRecords;
        if( LocalResumeHandle != 0 ) {

            *ResumeHandle = LocalResumeHandle;
        }
        else {

            *ResumeHandle =
                LocalEnumInfo->Clients
                    [LocalEnumInfo->NumElements - 1]->ClientIpAddress;
        }

        Error = ERROR_MORE_DATA;
    }

Cleanup:

    UNLOCK_DATABASE();

    if( (Error != ERROR_SUCCESS) &&
        (Error != ERROR_MORE_DATA) ) {

        //
        // if we aren't succssful return locally allocated buffer.
        //

        if( LocalEnumInfo != NULL ) {
            _fgs__DHCP_CLIENT_INFO_ARRAY_V5( LocalEnumInfo );
            MIDL_user_free( LocalEnumInfo );
        }

        DhcpPrint(( DEBUG_APIS, "DhcpEnumSubnetClients failed, %ld.\n",
                        Error ));
    }

    return(Error);
}


DWORD
R_DhcpGetClientOptions(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_MASK ClientSubnetMask,
    LPDHCP_OPTION_LIST *ClientOptions
    )
/*++

Routine Description:

    This function retrieves the options that are given to the
    specified client on boot request.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientIpAddress : IP Address of the client whose options to be
        retrieved

    ClientSubnetMask : Subnet mask of the client.

    ClientOptions : Pointer to a location where the retrieved option
        structure pointer is returned. Caller should free up
        the buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the specified client subnet is
        not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    Other WINDOWS errors.
--*/
{
    DWORD Error;

    DhcpPrint(( DEBUG_APIS, "DhcpGetClientOptions is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    Error = ERROR_CALL_NOT_IMPLEMENTED;

// Cleanup:

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientOptions  failed, %ld.\n",
                        Error ));
    }

    return(Error);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\callout.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef   _CALLOUT_H_
#define   _CALLOUT_H_



//
// The location in registry where the REG_MULTI_SZ list of callout DLLs 
// that the DHCP Server will try to load.
//

#define   DHCP_CALLOUT_LIST_KEY    L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters"
#define   DHCP_CALLOUT_LIST_VALUE  L"CalloutDlls"
#define   DHCP_CALLOUT_LIST_TYPE   REG_MULTI_SZ
#define   DHCP_CALLOUT_ENTRY_POINT "DhcpServerCalloutEntry"
#define   DHCP_CALLOUT_ENABLE_VALUE L"CalloutEnabled"

//
// Control CODES used by DHCP Server to notify server state change.
//

#define   DHCP_CONTROL_START       0x00000001
#define   DHCP_CONTROL_STOP        0x00000002
#define   DHCP_CONTROL_PAUSE       0x00000003
#define   DHCP_CONTROL_CONTINUE    0x00000004

//
// Other ControlCodes used by various Callout HOOKS.
//

#define   DHCP_DROP_DUPLICATE      0x00000001     // duplicate of pkt being processed
#define   DHCP_DROP_NOMEM          0x00000002     // not enough server mem in queues
#define   DHCP_DROP_INTERNAL_ERROR 0x00000003     // ooops?
#define   DHCP_DROP_TIMEOUT        0x00000004     // too late, pkt is too old
#define   DHCP_DROP_UNAUTH         0x00000005     // server is not authorized to run
#define   DHCP_DROP_PAUSED         0x00000006     // service is paused
#define   DHCP_DROP_NO_SUBNETS     0x00000007     // no subnets configured on server
#define   DHCP_DROP_INVALID        0x00000008     // invalid packet or client
#define   DHCP_DROP_WRONG_SERVER   0x00000009     // client in different DS enterprise
#define   DHCP_DROP_NOADDRESS      0x0000000A     // no address available to offer
#define   DHCP_DROP_PROCESSED      0x0000000B     // packet has been processed
#define   DHCP_DROP_GEN_FAILURE    0x00000100     // catch-all error
#define   DHCP_SEND_PACKET         0x10000000     // send the packet on wire
#define   DHCP_PROB_CONFLICT       0x20000001     // address conflicted..
#define   DHCP_PROB_DECLINE        0x20000002     // an addr got declined
#define   DHCP_PROB_RELEASE        0x20000003     // an addr got released
#define   DHCP_PROB_NACKED         0x20000004     // a client is being nacked.
#define   DHCP_GIVE_ADDRESS_NEW    0x30000001     // give client a "new" address
#define   DHCP_GIVE_ADDRESS_OLD    0x30000002     // renew client's "old" address
#define   DHCP_CLIENT_BOOTP        0x30000003     // client is a BOOTP client
#define   DHCP_CLIENT_DHCP         0x30000004     // client is a DHCP client



typedef
DWORD
(APIENTRY *LPDHCP_CONTROL)(
    IN DWORD dwControlCode,
    IN LPVOID lpReserved
)
/*++

Routine Description:

    This routine is called whenever the DHCP Server service is
    started, stopped, paused or continued as defined by the values of
    the dwControlCode parameter.  The lpReserved parameter is reserved
    for future use and it should not be interpreted in any way.   This
    routine should not block. 

Arguments:

    dwControlCode - one of the DHCP_CONTROL_* values
    lpReserved - reserved for future use.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_NEWPKT)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN OUT LPVOID *PktContext,
    OUT LPBOOL ProcessIt
)
/*++

Routine Description:

    This routine is called soon after the DHCP Server receives a
    packet that it attempts to process.  This routine is in the
    critical path of server execution and should return very fast, as
    otherwise server performance will be impacted.  The Callout DLL
    can modify the buffer or return a new buffer via the Packet,
    PacketSize arguments.  Also, if the callout DLL has internal
    structures to keep track of the packet and its progress, it can
    then return a context to this packet in the PktContext parameter.
    This context will be passed to almost all other hooks to indicate
    the packet being referred to.  Also, if the Callout DLL is
    planning on processing the packet or for some other reason the
    DHCP server is not expected to process this packet, then it can
    set the ProcessIt flag to FALSE to indicate that the packet is to
    be dropped. 
    
Arguments:

    Packet - This parameter points to a character buffer that holds
    the actual packet received by the DHCP Server. 

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer. 

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on. 

    Reserved -Reserved for future use.

    PktContect - This is an opaque pointer used by the DHCP Server for
    future references to this packet.  It is expected that the callout
    DLL will provide this pointer if it is interested in keeping track
    of the packet.  (See the descriptions for the hooks below for
    other usage of this Context). 

    ProcessIt - This is a BOOL flag that the CalloutDll can set to
    TRUE or reset to indicate if the DHCP Server should continue
    processing this packet or not, respectively. 

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_DROP_SEND)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD ControlCode,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN LPVOID PktContext
)
/*++

Routine Description:

    This hook is called if a packet is (DropPktHook) dropped for some
    reason or if the packet is completely processed.   (If a packet is
    dropped, the hook is called twice as it is called once again to
    note that the packet has been completely processed).  The callout
    DLL should  be prepared to handle this hook multiple times for a
    packet. This routine should not block. The ControlCode parameter
    defines the reasons for the packet being dropped:  

    * DHCP_DROP_DUPLICATE - This packet is a duplicate of another
      received by the server. 
    * DHCP_DROP_NOMEM - Not enough memory to process the packet.
    * DHCP_DROP_INTERNAL_ERROR - Unexpected nternal error occurred.
    * DHCP_DROP_TIMEOUT - The packet is too old to process.
    * DHCP_DROP_UNAUTH - The server is not authorized.
    * DHCP_DROP_PAUSED - The server is paused.
    * DHCP_DROP_NO_SUBNETS - There are no subnets configured.
    * DHCP_DROP_INVALID - The packet is invalid or it came on an
      invalid socket .. 
    * DHCP_DROP_WRONG_SERVER - The packet was sent to the wrong DHCP Server.
    * DHCP_DROP_NOADDRESS - There is no address to offer.
    * DHCP_DROP_PROCESSED - The packet has been processed.
    * DHCP_DROP_GEN_FAILURE - An unknown error occurred.

    This routine is also called right before a response is sent down
    the wire (SendPktHook) and in this case the ControlCode has a
    value of DHCP_SEND_PACKET.

Arguments:

    Packet - This parameter points to a character buffer that holds
    the packet being processed by the DHCP Server. 

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer. 

    ControlCode - See description for various control codes.

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on. 

    Reserved - Reserved for future use.

    PktContext - This parameter is the packet context that the Callout
    DLL NewPkt Hook returned for this packet.  This can be used to
    track a packet. 
   
--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_PROB)( 
    IN LPBYTE Packet, 
    IN DWORD PacketSize, 
    IN DWORD ControlCode, 
    IN DWORD IpAddress, 
    IN DWORD AltAddress, 
    IN LPVOID Reserved, 
    IN LPVOID PktContext 
)
/*++

Routine Description:

    This routine is called whenever special events occur that cause
    the packet to be dropped etc.  The possible ControlCodes and their
    meanings are as follows: 

    * DHCP_PROB_CONFLICT - The address attempted to be offered
      (AltAddress) is in use in the network already.  
    * DHCP_PROB_DECLINE - The packet was a DECLINE message for the
      address specified in AltAddress.
    * DHCP_PROB_RELEASE - The packet was a RELEASE message for the
      address specified in AltAddress.
    * DHCP_PROB_NACKED - The packet was a REQUEST message for address
      specified in AltAddress and it was NACKed by the server.  

    This routine should not block.  

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    ControlCode - Specifies the event. See description below for
    control codes and meanings. 

    IpAddress - IpV4 address of socket this packet was received on. 

    AltAddress - Request IpV4 Address or Ip address that is in
    conflict. 

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_GIVE_ADDRESS)( 
    IN LPBYTE Packet, 
    IN DWORD PacketSize, 
    IN DWORD ControlCode, 
    IN DWORD IpAddress, 
    IN DWORD AltAddress, 
    IN DWORD AddrType, 
    IN DWORD LeaseTime, 
    IN LPVOID Reserved, 
    IN LPVOID PktContext 
)
/*++

Routine Description:

    This routine is called when the server is about to send an ACK to
    a REQUEST message.  The ControlCode specifies if the address is a
    totally new address or if it an renewal of an old address (with
    values DHCP_GIVE_ADDRESS_NEW and DHCP_GIVE_ADDRESS_OLD
    respectively). The address being offered is passed as the
    AltAddress parameter and the AddrType parameter can be one of
    DHCP_CLIENT_BOOTP or DHCP_CLIENT_DHCP indicating whether the
    client is using BOOTP or DHCP respectively. This call should not
    block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    ControlCode -  See description above for control codes and
    meanings. 

    IpAddress - IpV4 address of socket this packet was received on. 

    AltAddress - IpV4 address being ACKed to the client.

    AddrType - Is this a DHCP or BOOTP address?

    LeaseTime - Lease duration being passed.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_HANDLE_OPTIONS)(
    IN LPBYTE Packet,
    IN DWORD PacketSize,
    IN LPVOID Reserved,
    IN LPVOID PktContext,
    IN OUT LPDHCP_SERVER_OPTIONS ServerOptions
)
/*++

Routine Description:

    This routine can be utilized by the CalloutDLL to avoid parsing
    the whole packet.  The packet is parsed by the server and some
    commonly used options are returned in the parsed pointers
    structure (see header for definition of DHCP_SERVER_OPTIONS).  The
    hook is expected to make a copy of the structure pointed to by
    ServerOptions if it needs it beyond this function call.  This
    routine may be called several times for a single packet.  This
    routine should not block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

    ServerOptions - This parameter is the structure that contains a
    bunch of pointers that represent corresponding options. 

--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_DELETE_CLIENT)( 
    IN DWORD IpAddress, 
    IN LPBYTE HwAddress, 
    IN ULONG HwAddressLength, 
    IN DWORD Reserved, 
    IN DWORD ClientType 
)
/*++

Routine Description:

    This routine is called before a client lease is deleted off the
    active leases database.  The ClientType field is currently not
    provided and this should not be used.  This routine should not
    block.  

Arguments:

    IpAddress - IpV4 address of the client lease being deleted.

    HwAddress - Buffer holding the Hardware address of the client (MAC).

    HwAddressLength - This specifies the length of the above buffer.

    Reserved - Reserved for future use.

    ClientType - Reserved for future use.
--*/
;

typedef
struct      _DHCP_CALLOUT_TABLE {
    LPDHCP_CONTROL                 DhcpControlHook;
    LPDHCP_NEWPKT                  DhcpNewPktHook;
    LPDHCP_DROP_SEND               DhcpPktDropHook;
    LPDHCP_DROP_SEND               DhcpPktSendHook;
    LPDHCP_PROB                    DhcpAddressDelHook;
    LPDHCP_GIVE_ADDRESS            DhcpAddressOfferHook;
    LPDHCP_HANDLE_OPTIONS          DhcpHandleOptionsHook;
    LPDHCP_DELETE_CLIENT           DhcpDeleteClientHook;
    LPVOID                         DhcpExtensionHook;
    LPVOID                         DhcpReservedHook;
}   DHCP_CALLOUT_TABLE, *LPDHCP_CALLOUT_TABLE;

typedef
DWORD
(APIENTRY *LPDHCP_ENTRY_POINT_FUNC) ( 
    IN LPWSTR ChainDlls, 
    IN DWORD CalloutVersion, 
    IN OUT LPDHCP_CALLOUT_TABLE CalloutTbl
)
/*++

Routine Description:

    This is the routine that is called by the DHCP Server when it
    successfully loads a DLL.    If the routine succeeds, then the
    DHCP Server does not attempt to load any of the DLLs specified in
    the ChainDlls list of DLLs.   If this function fails for some
    reason, then the DHCP Server proceeds to the next DLL in the
    ChainDlls structure.  

    Note that for version negotiation, the server may call this
    routine several times until a compatible version is found. 

    It is expected that the entrypoint routine would walk through the
    names of the dlls and attempt to load each of them and when it
    succeeds in retrieving the entry point, it attempts to get the
    cumulative set of hooks by repeating the above procedure (as done
    by the DHCP Server).  

Arguments:

    ChainDlls - This is a set of DLL names in REG_MULTI_SZ format (as
    returned by Registry function calls).  This does not contain the
    name of the current DLL itself, but only the names of all DLLs
    that follow the current DLL. 

    CalloutVersion - This is the version that the Callout DLL is
    expected to support.  The current version number is 0.

    CalloutTbl - This is the cumulative set of Hooks that is needed by
    the current DLLs as well as all the DLLs in ChainDlls.   It is the
    responsibility of the current DLL to retrive the cumulative set of
    Hooks and merge that with its own set of hooks and return that in
    this table structure.  The table structure is defined above.

--*/
;




//
//  Macros for ease of use.  Lots of code to handle exceptions when
//  they happen.
//

#define    _PROTECT1               try
#define    _PROTECT2               \
except(EXCEPTION_EXECUTE_HANDLER) \
{ \
      DhcpCalloutLogAV(GetExceptionCode());\
} 

#define    _XX(Fn)                 Dhcp ## Fn ## Hook
#define    WRAPPER(Fn, Params)     \
do{ \
    _PROTECT1 { \
        if(CalloutTbl. _XX(Fn)){ \
            CalloutTbl. _XX(Fn) Params ;\
        }\
    } _PROTECT2 \
}while(0)

#define    _GiveAddrPkt(P,Code,Type,A,Time) \
WRAPPER(AddressOffer, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (Code),\
    ntohl((P)->ReqContext.EndPointIpAddress),\
    (A),\
    (Type),\
    (Time),\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _DropPkt(P,Drop,Code)   \
WRAPPER(PktDrop, (&((P)->ReqContext.ReceiveBuffer),\
    &((P)->ReqContext.ReceiveMessageSize),\
    (Code),\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _NewPkt(P,Dropit)       \
WRAPPER(NewPkt, ( &((P)->ReqContext.ReceiveBuffer),\
    &((P)->ReqContext.ReceiveMessageSize),\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID*)&((P)->CalloutContext),\
     Dropit)\
)

//
// CALLOUT_CONTROL( ControlCode )
//

#define    CALLOUT_CONTROL(_ccode) WRAPPER(Control, (_ccode, NULL))

//
// CALLOUT_NEWPKT( Packet, fProcessIt )
//

#define    CALLOUT_NEWPKT(P,Drop)  _NewPkt(P,Drop)

//
// CALLOUT_DROPPED(Packet, DropReason)
//

#define    CALLOUT_DROPPED(P,Code) _DropPkt(P,DropPkt, Code)

//
// CALLOUT_SENDPKT(Packet)
//

#define    CALLOUT_SENDPKT(P)      \
WRAPPER(PktSend, (&((P)->ReqContext.SendBuffer),\
    &((P)->ReqContext.SendMessageSize),\
    DHCP_SEND_PACKET,\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _ProbPkt(P,Code,A)      \
WRAPPER(AddressDel, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (Code),\
    (P)->ReqContext.EndPointIpAddress,\
    (A),\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

//
// CALLOUT_CONFLICT(Packet)
//

#define    CALLOUT_CONFLICT(P)     _ProbPkt(P, DHCP_PROB_CONFLICT,P->PingAddress)

//
// CALLOUT_DECLINED(Packet, Address)
//

#define    CALLOUT_DECLINED(P,A)   _ProbPkt(P, DHCP_PROB_DECLINE, A)

//
// CALLOUT_RELEASE(Packet, Address)
//

#define    CALLOUT_RELEASE(P,A)    _ProbPkt(P, DHCP_PROB_RELEASE, A)

//
// CALLOUT_NACK_DHCP(Packet, Address)
//

#define    CALLOUT_NACK_DHCP(P,A)  _ProbPkt(P, DHCP_PROB_NACKED, A)

//
// CALLOUT_RENEW_BOOTP(Packet, Address, LeaseTime)
//

#define    CALLOUT_RENEW_BOOTP(P,Addr,Time) \
    _GiveAddrPkt(P, DHCP_GIVE_ADDRESS_OLD, DHCP_CLIENT_BOOTP, Addr, Time)

//
// CALLOUT_RENEW_DHCP(Packet, Address, Time, fExists)
//

#define    CALLOUT_RENEW_DHCP(P,Addr,Time,Exists) \
    _GiveAddrPkt(P, (Exists)?DHCP_GIVE_ADDRESS_OLD: \
       DHCP_GIVE_ADDRESS_NEW,DHCP_CLIENT_DHCP, Addr, Time)

//
// CALLOUT_MARK_OPTIONS(Packet, DhcpServerOptions)
//

#define    CALLOUT_MARK_OPTIONS(P,DhcpOptions) \
WRAPPER(HandleOptions, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (P), (LPVOID)((P)->CalloutContext), (DhcpOptions)))

//
// CALLOUT_PINGING(Packet)
//

#define    CALLOUT_PINGING(P)

//
// CALLOUT_DELETED(Address, HwAddress, HwLength, ClientType)
//

#define    CALLOUT_DELETED(Addr, HwAddr, HwLen, Type) \
    WRAPPER(DeleteClient, ((Addr), (HwAddr), (HwLen), 0, (Type)))



extern
DHCP_CALLOUT_TABLE                 CalloutTbl;   // globals are init'ed to NULL


#endif     _CALLOUT_H_


VOID
DhcpCalloutLogAV(
    IN ULONG ExceptionCode
) ;


VOID
DhcpCalloutLogLoadFailure(
    IN      ULONG                  ExceptionCode
) ;


DWORD
CalloutInit(                                      // init callout fn table etc..
    VOID
) ;


VOID
CalloutCleanup(
    VOID
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\convguid.c ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    dhcpm\server\server\convguid.c
    (was iphlpapi\guid.c)

Abstract:

    Cut-n-Paste of rtl\guid.c but without UNICODE_STRINGs

Revision History:

    AmritanR Created 

--*/

#include <dhcppch.h>
#include <guiddef.h>

#define GUID_FORMAT_W   L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"

int
__cdecl
ScanHexFormat(
    IN const WCHAR* pwszBuffer,
    IN ULONG        ulCharCount,
    IN const WCHAR* pwszFormat,
    ...
    )

/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    pwszBuffer  Source buffer which is to be scanned.

    ulCharCount Maximum length in characters for which Buffer is searched.
                This implies that Buffer need not be UNICODE_NULL terminated.

    Format      Format string which defines both the acceptable string form as
                contained in pwszBuffer


Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     iFormatItems;

    va_start(ArgList, pwszFormat);

    //
    // Count of number of parameters filled
    //

    iFormatItems = 0;

    while(TRUE)
    {
        switch (*pwszFormat) 
        {
            case UNICODE_NULL:
            {
                //
                // end of string
                //

                return (*pwszBuffer && ulCharCount) ? -1 : iFormatItems;
            }

            case L'%':
            {
                //
                // Format specifier
                //

                pwszFormat++;

                if (*pwszFormat != L'%') 
                {
                    ULONG   ulNumber;
                    int     iWidth;
                    int     iLong;
                    PVOID   pvPointer;

                    //
                    // So it isnt a %%
                    //

                    iLong = 0;
                    iWidth = 0;

                    while(TRUE)
                    {
                        if((*pwszFormat >= L'0') && 
                           (*pwszFormat <= L'9')) 
                        {
                            iWidth = iWidth * 10 + *pwszFormat - '0';
                        } 
                        else
                        {
                            if(*pwszFormat == L'l') 
                            {
                                iLong++;
                            } 
                            else 
                            {
                                if((*pwszFormat == L'X') || 
                                   (*pwszFormat == L'x')) 
                                {
                                    break;
                                }
                            }
                        }
                       
                        //
                        // Move to the next specifier
                        //
 
                        pwszFormat++;
                    }

                    pwszFormat++;

                    for(ulNumber = 0; iWidth--; pwszBuffer++, ulCharCount--) 
                    {
                        if(!ulCharCount)
                        {
                            return -1;
                        }

                        ulNumber *= 16;

                        if((*pwszBuffer >= L'0') && 
                           (*pwszBuffer <= L'9')) 
                        {
                            ulNumber += (*pwszBuffer - L'0');
                        } 
                        else
                        {
                            if((*pwszBuffer >= L'a') && 
                               (*pwszBuffer <= L'f')) 
                            {
                                ulNumber += (*pwszBuffer - L'a' + 10);
                            }
                            else
                            {
                                if((*pwszBuffer >= L'A') && 
                                   (*pwszBuffer <= L'F')) 
                                {
                                    ulNumber += (*pwszBuffer - L'A' + 10);
                                } 
                                else 
                                {
                                    return -1;
                                }
                            }
                        }
                    }

                    pvPointer = va_arg(ArgList, PVOID);

                    if(iLong) 
                    {
                        *(PULONG)pvPointer = ulNumber;
                    } 
                    else 
                    {
                        *(PUSHORT)pvPointer = (USHORT)ulNumber;
                    }

                    iFormatItems++;

                    break;
                }
           
                //
                // NO BREAK
                // 

            }

            default:
            {
                if (!ulCharCount || (*pwszBuffer != *pwszFormat))
                {
                    return -1;
                }

                pwszBuffer++;

                ulCharCount--;

                pwszFormat++;

                break;
            }
        }
    }
}

DWORD
ConvertGuidToString(
    IN  GUID    *pGuid,
    OUT PWCHAR  pwszBuffer
    )

/*++

Routine Description:

    Constructs the standard string version of a GUID, in the form:
    "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    pGuid       Contains the GUID to translate.

    pwszBuffer  Space for storing the string. Must be >= 39 * sizeof(WCHAR)

Return Value:


--*/

{
    return swprintf(pwszBuffer, 
                    (LPCWSTR)GUID_FORMAT_W, 
                    pGuid->Data1, 
                    pGuid->Data2, 
                    pGuid->Data3, 
                    pGuid->Data4[0], 
                    pGuid->Data4[1], 
                    pGuid->Data4[2], 
                    pGuid->Data4[3], 
                    pGuid->Data4[4], 
                    pGuid->Data4[5], 
                    pGuid->Data4[6], 
                    pGuid->Data4[7]);
}

DWORD
ConvertStringToGuid(
    IN  const WCHAR  *pwszGuid,
    IN  ULONG   ulStringLen,
    OUT GUID    *pGuid
    )

/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

Return Value:

    Returns STATUS_SUCCESS if the buffer contained a valid GUID, else
    STATUS_INVALID_PARAMETER if the string was invalid.

--*/

{
    USHORT    Data4[8];
    int       Count;

    if (ScanHexFormat(pwszGuid,
                      ulStringLen/sizeof(WCHAR),
                      (LPCWSTR)GUID_FORMAT_W,
                      &pGuid->Data1, 
                      &pGuid->Data2, 
                      &pGuid->Data3, 
                      &Data4[0], 
                      &Data4[1], 
                      &Data4[2], 
                      &Data4[3], 
                      &Data4[4], 
                      &Data4[5], 
                      &Data4[6], 
                      &Data4[7]) == -1) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    for(Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) 
    {
        pGuid->Data4[Count] = (UCHAR)Data4[Count];
    }

    return NO_ERROR;
}


BOOL
ConvertGuidToIfNameString(
    IN GUID *Guid,
    IN OUT LPWSTR Buffer,
    IN ULONG BufSize
    )
{
    if( BufSize < sizeof(GUID)*2 + 3 + 4 ) return FALSE;
    ConvertGuidToString(Guid, Buffer);
    return TRUE;
}
    

BOOL
ConvertGuidFromIfNameString(
    OUT GUID *Guid,
    IN LPCWSTR IfName
    )
{
    return (
        NO_ERROR == ConvertStringToGuid(IfName, wcslen(IfName)*sizeof(WCHAR),Guid)
        );
}

//
// end of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\convguid.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    convguid.h

Abstract:
    conversion between guids and interface names.

Environment:
    Any

--*/

#ifndef CONVGUID_H_INCLUDED
#define CONVGUID_H_INCLUDED

#ifdef _cplusplus
extern "C" {
#endif


BOOL
ConvertGuidToIfNameString(
    IN GUID *Guid,
    IN OUT LPWSTR Buffer,
    IN ULONG BufSize
    );
    
BOOL
ConvertGuidFromIfNameString(
    OUT GUID *Guid,
    IN LPCWSTR IfName
    );

#ifdef _cplusplus
}
#endif


#endif  CONVGUID_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\database.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  database.c

  Abstract:

  This module contains the functions for interfacing with the JET
  database API.

  Author:

  Madan Appiah (madana)  10-Sep-1993
  Manny Weiser (mannyw)  14-Dec-1992

  Environment:

  User Mode - Win32

  Revision History:

  --*/

#include "dhcppch.h"
#include <dhcpupg.h>
#include <mdhcpsrv.h>
#include "dhcpwriter.h"

extern
DWORD
DhcpOpenMCastDbTable(
    JET_SESID   SessId,
    JET_DBID    DbId
);

#define MAX_NO_SESSIONS         10
#define DATABASE_SYS_FILE       "system.mdb"
#define DATABASE_LOG_FILE       "Dhcp.log"
#define DATABASE_TMP_FILE       "Dhcp.tmp"
#define DATABASE_BASE_NAME      "j50"

#define CLIENT_TABLE_NAME       "ClientTable"

#define IPADDRESS_STRING        "IpAddress"
#define HARDWARE_ADDRESS_STRING "HardwareAddress"
#define STATE_STRING            "State"
#define MACHINE_INFO_STRING     "MachineInformation"
#define MACHINE_NAME_STRING     "MachineName"
#define LEASE_TERMINATE_STRING  "LeaseTerminates"
#define SUBNET_MASK_STRING      "SubnetMask"
#define SERVER_IP_ADDRESS_STRING "ServerIpAddress"
#define SERVER_NAME_STRING      "ServerName"
#define CLIENT_TYPE             "ClientType"


//
// Bitmask table 
//

#define BITMASK_TABLE_NAME            "BitmaskTable"
#define BITMASK_TABLE_RANGE           "Range"
#define BITMASK_TABLE_NUMBITS         "NumBits"
#define BITMASK_TABLE_BITMAP          "Bitmap"
#define BITMASK_TABLE_OFFSET          "Offset"


//
// Bitmask table globals
//
// The bitmap for a scope is not stored as one contiguous block, but is
// broken into smaller parts, 2048 bits each. An array of these bit buckets
// is used for a range. This record structure reflects the bitmaps in the 
// memory.
//
// Bitmask table columns:
//   Range     : The Ip Range of this record
//   Offset    : Offset of this record in the IP range
//   Numbits   : Number of bits valid in this record
//   Bitmap    : The bitmap.
//

JET_TABLEID BitmaskTbl;
typedef enum BitmaskCols {
    BITMASK_RANGE = 0,
    BITMASK_BITMAP,
    BITMASK_OFFSET,
    BITMASK_NUMBITS

}; 

STATIC TABLE_INFO BitmaskTable[] = {
    { BITMASK_TABLE_RANGE,   0, JET_coltypLong },
    { BITMASK_TABLE_BITMAP,  0, JET_coltypLongBinary },
    { BITMASK_TABLE_OFFSET,  0, JET_coltypLong },
    { BITMASK_TABLE_NUMBITS, 0, JET_coltypLong }
}; // BitmaskTable[]

#define BITMASK_TABLE_NUM_COLS \
        (sizeof( BitmaskTable ) / sizeof( TABLE_INFO ))


//
// Tls Index for storing last Jet error
//
DWORD JetTlsIndex = TLS_OUT_OF_INDEXES;

//
// Bitmask clean flag is stored in its own table. 
//

JET_TABLEID  BitmaskCleanFlagTbl;
JET_COLUMNID BitmaskCleanFlagColId;
#define BITMASK_CLEAN_TABLE_NAME  "BitmaskCleanTable"
#define BITMASK_CLEAN_FLAG_NAME   "BitmaskClean"
#define BITMASK_CLEAN_FLAG_TYPE   JET_coltypUnsignedByte



//
// Useful for performance tuning
//

#define JET_MAX_CACHE_SIZE           500

// These values are based on JET_MAX_CACHE_SIZE
#define JET_START_FLUSH_THRESHOLD    25   /* 1% */
#define JET_STOP_FLUSH_THRESHOLD     50  /* 2% */


    //
    //  Structure of the DHCP database is as below.
    //
    //  Tables - currently DHCP has only one table.
    //
    //      1. ClientTable - this table has 6 columns.
    //
    //      Columns :
    //
    //          Name                Type
    //
    //      1. IpAddress            JET_coltypLong - 4-byte integer, signed.
    //      2. HwAddress            JET_coltypBinary - Binary data, < 255 bytes.
    //      3. State                JET_coltypUnsignedByte - 1-byte integer, unsigned.
    //      4. MachineInfo          JET_coltypBinary - Binary data, < 255 bytes.
    //      5. MachineName          JET_coltypBinary - Binary data, < 255 bytes.
    //      6. LeaseTermination     JET_coltypCurrency - 8-byte integer, signed
    //      7. SubnetMask           JET_coltypLong - 4-byte integer, signed
    //      8. ServerIpAddress      JET_coltypLong - 4-byte integer, signed
    //      9. ServerName           JET_coltypBinary - Binary data, < 255 bytes
    //      10 ClientType           JET_coltypUnsignedByte - 1-byte integer, unsigned
    //

    //
    // global data structure.
    // ColName and ColType are constant, so they are initialized here.
    // ColType is initialized when the database is created or reopened.
    //


    STATIC TABLE_INFO ClientTable[] = {
        { IPADDRESS_STRING        , 0, JET_coltypLong },
        { HARDWARE_ADDRESS_STRING , 0, JET_coltypBinary },
        { STATE_STRING            , 0, JET_coltypUnsignedByte },
        { MACHINE_INFO_STRING     , 0, JET_coltypBinary }, // must modify MACHINE_INFO_SIZE if this changes
        { MACHINE_NAME_STRING     , 0, JET_coltypLongBinary },
        { LEASE_TERMINATE_STRING  , 0, JET_coltypCurrency },
        { SUBNET_MASK_STRING      , 0, JET_coltypLong },
        { SERVER_IP_ADDRESS_STRING, 0, JET_coltypLong },
        { SERVER_NAME_STRING      , 0, JET_coltypLongBinary },
        { CLIENT_TYPE             , 0, JET_coltypUnsignedByte }
    };

JET_INSTANCE JetInstance = 0;

#define CLIENT_TABLE_NUM_COLS   (sizeof(ClientTable) / sizeof(TABLE_INFO))

DWORD
DhcpMapJetError(
    JET_ERR JetError,
    LPSTR CallerInfo OPTIONAL
)
    /*++

      Routine Description:

      This function maps the Jet database errors to Windows error.

      Arguments:

      JetError - an error JET function call.

      Return Value:

      Windows Error.

      --*/
{
    if( JetError == JET_errSuccess ) {
        return(ERROR_SUCCESS);
    }

    if( JetError < 0 ) {

        DWORD Error;
        INT64 ErrorValue = ( INT64 ) JetError;

        DhcpPrint(( DEBUG_JET, "Jet Error : %ld\n", JetError ));

        TlsSetValue( JetTlsIndex, ( LPVOID ) ErrorValue );

        //
        // Jet Errors.
        //

        switch( JetError ) {
        case JET_errNoCurrentRecord:
            Error = ERROR_NO_MORE_ITEMS;
            break;

        case JET_errRecordNotFound: // record not found
            DhcpPrint(( DEBUG_JET, "Jet Record not found.\n" ));

            Error = ERROR_DHCP_JET_ERROR;
            break;

        case JET_errKeyDuplicate :
            DhcpAssert(FALSE);
            Error = ERROR_DHCP_JET_ERROR;

            break;

        case JET_errObjectNotFound: {
            Error = ERROR_DHCP_JET_ERROR;
            break;
        }

        default:
            DhcpPrint(( DEBUG_JET, "Jet Function call failed, %ld.\n",
                        JetError ));

            DhcpServerJetEventLog(
                EVENT_SERVER_JET_ERROR,
                EVENTLOG_ERROR_TYPE,
                JetError,
                CallerInfo);

            Error = ERROR_DHCP_JET_ERROR;
        }

        return(Error);
    }

    //
    // Jet Warnings.
    //

    DhcpPrint(( DEBUG_JET, "Jet Function call retured warning %ld.\n",
                JetError ));

    switch( JetError ) {

    case JET_wrnColumnNull:
    case JET_wrnDatabaseAttached:
        break;

    default:
        DhcpServerJetEventLog(
            EVENT_SERVER_JET_WARNING,
            EVENTLOG_WARNING_TYPE,
            JetError,
            CallerInfo);
    }

    return(ERROR_SUCCESS);
}



DWORD
DhcpJetOpenKey(
    char *ColumnName,
    PVOID Key,
    DWORD KeySize
)
    /*++

      Routine Description:

      This function opens a key for the named index.

      Arguments:

      ColumnName - The column name of an index column.

      Key - The key to look up.

      KeySize - The size of the specified key, in bytes.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetCurrentIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        ColumnName );

    Error = DhcpMapJetError( JetError, "DhcpJetOpenKey:SetCurrentIndex" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError( JetError, ColumnName );
        return(Error);
    }

    JetError = JetMakeKey(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        Key,
        KeySize,
        JET_bitNewKey );

    Error = DhcpMapJetError( JetError, "DhcpJetOpenKey:MakeKey" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError( JetError, ColumnName );
        return(Error);
    }

    JetError = JetSeek( DhcpGlobalJetServerSession, DhcpGlobalClientTableHandle, JET_bitSeekEQ );
    return( DhcpMapJetError( JetError, "DhcpJetOpenKey:JetSeek" ));
}



DWORD
DhcpJetBeginTransaction(
    VOID
)
    /*++

      Routine Description:

      This functions starts a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetBeginTransaction( DhcpGlobalJetServerSession );

    Error = DhcpMapJetError( JetError, "DhcpJetBeginTransaction" );
    return(Error);
}



DWORD
DhcpJetRollBack(
    VOID
)
    /*++

      Routine Description:

      This functions rolls back a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetRollback(
        DhcpGlobalJetServerSession,
        0 ); // Rollback the last transaction.

    Error = DhcpMapJetError( JetError, "DhcpJetRollBack" );
    return(Error);
}




DWORD
DhcpJetCommitTransaction(
    VOID
)
    /*++

      Routine Description:

      This functions commits a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetCommitTransaction(
        DhcpGlobalJetServerSession,
        JET_bitCommitLazyFlush);

    Error = DhcpMapJetError( JetError, "DhcpJetCommitTransaction" );
    return(Error);
}




DWORD
DhcpJetPrepareUpdate(
    char *ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
)
    /*++

      Routine Description:

      This function prepares the database for the creation of a new record,
      or updating an existing record.

      Arguments:

      ColumnName - The column name of an index column.

      Key - The key to update/create.

      KeySize - The size of the specified key, in bytes.

      NewRecord - TRUE to create the key, FALSE to update an existing key.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    if ( !NewRecord ) {
        JetError = JetSetCurrentIndex(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            ColumnName );

        Error = DhcpMapJetError( JetError, "JetPrepareUpdate:SetCurrentIndex" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError( JetError, ColumnName );
            return( Error );
        }

        JetError = JetMakeKey(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            Key,
            KeySize,
            JET_bitNewKey );

        Error = DhcpMapJetError( JetError, "JetPrepareUpdate:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError( JetError, ColumnName );
            return( Error );
        }

        JetError = JetSeek(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            JET_bitSeekEQ );

        Error = DhcpMapJetError( JetError, "JetPrepareUpdate:Seek");
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError( JetError, ColumnName );
            return( Error );
        }

    }

    JetError = JetPrepareUpdate(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        NewRecord ? JET_prepInsert : JET_prepReplace );

    return( DhcpMapJetError( JetError, "JetPrepareUpdate:PrepareUpdate" ));
}



DWORD
DhcpJetCommitUpdate(
    VOID
)
    /*++

      Routine Description:

      This function commits an update to the database.  The record specified
      by the last call to DhcpJetPrepareUpdate() is committed.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetUpdate(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        NULL,
        0,
        NULL );

    return( DhcpMapJetError( JetError, "DhcpJetCommitUpdate" ));
}



DWORD
DhcpJetSetValue(
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
)
    /*++

      Routine Description:

      This function updates the value of an entry in the current record.

      Arguments:

      KeyColumnId - The Id of the column (value) to update.

      Data - A pointer to the new value for the column.

      DataSize - The size of the data, in bytes.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetColumn(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        KeyColumnId,
        Data,
        DataSize,
        0,
        NULL );

    Error = DhcpMapJetError( JetError, "JetSetValue:Setcolumn") ;
    return Error;
}



DWORD
DhcpJetGetValue(
    JET_COLUMNID ColumnId,
    PVOID Data,
    PDWORD DataSize
)
    /*++

      Routine Description:

      This function read the value of an entry in the current record.

      Arguments:

      ColumnId - The Id of the column (value) to read.

      Data - Pointer to a location where the data that is read from the
      database returned,  or pointer to a location where data is.

      DataSize - if the pointed value is non-zero then the Data points to
      a buffer otherwise this function allocates buffer for return data
      and returns buffer pointer in Data.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;
    DWORD ActualDataSize;
    DWORD NewActualDataSize;
    LPBYTE DataBuffer = NULL;

    if( *DataSize  != 0 ) {

        JetError = JetRetrieveColumn(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            ColumnId,
            Data,
            *DataSize,
            DataSize,
            0,
            NULL );

        Error = DhcpMapJetError( JetError, "JetGetValue:RetrieveColumn1" );
        goto Cleanup;
    }

    //
    // determine the size of data.
    //

    JetError = JetRetrieveColumn(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        ColumnId,
        NULL,
        0,
        &ActualDataSize,
        0,
        NULL );

    //
    // JET_wrnBufferTruncated is expected warning.
    //

    if( JetError != JET_wrnBufferTruncated ) {
        Error = DhcpMapJetError( JetError, "JetGetValue:RetrieveColumn2" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }
    else {
        Error = ERROR_SUCCESS;
    }

    if( ActualDataSize == 0 ) {
        //
        // field is NULL.
        //
        *(LPBYTE *)Data = NULL;
        goto Cleanup;
    }

    DataBuffer = MIDL_user_allocate( ActualDataSize );

    if( DataBuffer == NULL ) {
        *(LPBYTE *)Data = NULL;
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    JetError = JetRetrieveColumn(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        ColumnId,
        DataBuffer,
        ActualDataSize,
        &NewActualDataSize,
        0,
        NULL );

    Error = DhcpMapJetError( JetError, "JetGetValue:RetrieveColumn3" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpAssert( ActualDataSize == NewActualDataSize );
    *(LPBYTE *)Data = DataBuffer;
    *DataSize = ActualDataSize;

    Error = ERROR_SUCCESS;

  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // freeup local buffer.
        //

        if( DataBuffer != NULL ) {
            MIDL_user_free( DataBuffer );
        }
    }

    return( Error );
}



DWORD
DhcpJetPrepareSearch(
    char *ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
)
    /*++

      Routine Description:

      This function prepares for a search of the client database.

      Arguments:

      ColumnName - The column name to use as the index column.

      SearchFromStart - If TRUE, search from the first record in the
      database.  If FALSE, search from the specified key.

      Key - The key to start the search.

      KeySize - The size, in bytes, of key.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetCurrentIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        ColumnName );

    Error = DhcpMapJetError( JetError, "PrepareSearch:SetCurrentIndex" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError(JetError, ColumnName );
        return( Error );
    }

    if ( SearchFromStart ) {
        JetError = JetMove(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            JET_MoveFirst,
            0 );
    } else {
        JetError =  JetMakeKey(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            Key,
            KeySize,
            JET_bitNewKey );

        Error = DhcpMapJetError( JetError, "PrepareSearch:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError(JetError, ColumnName);
            return( Error );
        }

        JetError = JetSeek(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            JET_bitSeekGT );
    }

    return( DhcpMapJetError( JetError, "PrepareSearch:Move/Seek" ));
}



DWORD
DhcpJetNextRecord(
    VOID
)
    /*++

      Routine Description:

      This function advances to the next record in a search.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetMove(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        JET_MoveNext,
        0 );

    return( DhcpMapJetError( JetError, "JetNextRecord" ) );
}



DWORD
DhcpJetDeleteCurrentRecord(
    VOID
)
    /*++

      Routine Description:

      This function deletes the current record.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetDelete( DhcpGlobalJetServerSession, DhcpGlobalClientTableHandle );
    return( DhcpMapJetError( JetError, "DeleteCurrentRecord:Delete" ) );
}



DHCP_IP_ADDRESS
DhcpJetGetSubnetMaskFromIpAddress(
    DHCP_IP_ADDRESS IpAddress
)
    /*++

      Routine Description:

      This function returns the SubnetMask of the specified client.

      Arguments:

      IpAddress - Client address.


      Return Value:

      SubnetMask of the client.

      --*/
{

    DWORD Error;
    DWORD Size;
    DHCP_IP_ADDRESS SubnetAddress = 0;

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress) );

    if ( Error != ERROR_SUCCESS ) {
        return( SubnetAddress );
    }

    Size = sizeof(SubnetAddress);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
        (LPBYTE)&SubnetAddress,
        &Size );

    if ( Error != ERROR_SUCCESS ) {
        SubnetAddress = 0;
        return( SubnetAddress );
    }

    DhcpAssert( Size == sizeof(SubnetAddress) );

    return( SubnetAddress );
}


BOOL
DhcpGetIpAddressFromHwAddress(
    LPBYTE HardwareAddress,
    BYTE HardwareAddressLength,
    LPDHCP_IP_ADDRESS IpAddress
)
    /*++

      Routine Description:

      This function looks up the IP address corresponding to the given
      hardware address.

      Arguments:

      HardwareAddress - The hardware to look up.
      HardwareAddressLength - The length of the hardware address.
      IpAddress - Returns the corresponding IP address.

      Return Value:

      TRUE - The IP address was found.
      FALSE - The IP address could not be found.  *IpAddress = -1.


      --*/
{
    DWORD Error;
    DWORD Size;

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
        HardwareAddress,
        HardwareAddressLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    // Get the ip address information for this client.
    //

    Size = sizeof( *IpAddress );

    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
        (LPBYTE)IpAddress,
        &Size );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    return( TRUE );
}



BOOL
DhcpGetHwAddressFromIpAddress(
    DHCP_IP_ADDRESS IpAddress,
    PBYTE HardwareAddress,
    DWORD HardwareAddressLength
)
    /*++

      Routine Description:

      This function looks up the IP address corresponding to the given
      hardware address.

      Arguments:

      IpAddress - Ipaddress of a record whose hw address is requested.
      HardwareAddress - pointer to a buffer where the hw address is returned.
      HardwareAddressLength - length of the above buffer.

      Return Value:

      TRUE - The IP address was found.
      FALSE - The IP address could not be found.  *IpAddress = -1.


      --*/
{
    DWORD Error;
    DWORD Size;

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress) );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    // Get the ip address information for this client.
    //

    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
        HardwareAddress,
        &HardwareAddressLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    return( TRUE );
}




DWORD
DhcpCreateAndInitDatabase(
    CHAR *Connect,
    JET_DBID *DatabaseHandle,
    JET_GRBIT JetBits
)
    /*++

      Routine Description:

      This routine creates DHCP database and initializes it.

      Arguments:

      Connect - database type. NULL specifies the default engine (blue).

      DatabaseHandle - pointer database handle returned.

      JetBits - Create flags.

      Return Value:

      JET errors.

      --*/
{

    JET_ERR JetError;
    DWORD Error;
    JET_COLUMNDEF   ColumnDef;
    CHAR *IndexKey;
    DWORD i;
    CHAR DBFilePath[MAX_PATH];

    DBFilePath[ 0 ] = '\0';

    //
    // Create Database.
    //

    if ( ( strlen( DhcpGlobalOemDatabasePath ) + strlen( DhcpGlobalOemDatabaseName ) + 2 ) < MAX_PATH )
    {
        strcpy( DBFilePath, DhcpGlobalOemDatabasePath );
        strcat( DBFilePath, DHCP_KEY_CONNECT_ANSI );
        strcat( DBFilePath, DhcpGlobalOemDatabaseName );
    }

    //
    // Convert name to ANSI
    //
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
    
    JetError = JetCreateDatabase(
        DhcpGlobalJetServerSession,
        DBFilePath,
        Connect,
        DatabaseHandle,
        JetBits );

    Error = DhcpMapJetError( JetError, "CreateDatabase" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Create Table.
    //

    JetError = JetCreateTable(
        DhcpGlobalJetServerSession,
        *DatabaseHandle,
        CLIENT_TABLE_NAME,
        DB_TABLE_SIZE,
        DB_TABLE_DENSITY,
        &DhcpGlobalClientTableHandle );

    Error = DhcpMapJetError( JetError, "CreateTable" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Create columns.
    //

    //
    // Init fields of columndef that do not change between addition of
    // columns
    //

    ColumnDef.cbStruct  = sizeof(ColumnDef);
    ColumnDef.columnid  = 0;
    ColumnDef.wCountry  = 1;
    ColumnDef.langid    = DB_LANGID;
    ColumnDef.cp        = DB_CP;
    ColumnDef.wCollate  = 0;
    ColumnDef.cbMax     = 0;
    ColumnDef.grbit     = 0; // variable length binary and text data.


    for ( i = 0; i < CLIENT_TABLE_NUM_COLS; i++ ) {

        ColumnDef.coltyp   = DhcpGlobalClientTable[i].ColType;
        JetError = JetAddColumn(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            DhcpGlobalClientTable[i].ColName,
            &ColumnDef,
            NULL, // no optinal value.
            0,
            &DhcpGlobalClientTable[i].ColHandle );

        Error = DhcpMapJetError( JetError, "AddColumn" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

    //
    // finally create index.
    //

    IndexKey =  "+" IPADDRESS_STRING "\0";
    JetError = JetCreateIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        JET_bitIndexPrimary,
        // ?? JET_bitIndexClustered will degrade frequent
        // update response time.
        IndexKey,
        strlen(IndexKey) + 2, // for two termination chars
        50
    );

    Error = DhcpMapJetError( JetError, "CreateIndex" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    IndexKey =  "+" HARDWARE_ADDRESS_STRING "\0";
    JetError = JetCreateIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
        JET_bitIndexUnique,
        IndexKey,
        strlen(IndexKey) + 2, // for two termination chars
        50
    );

    Error = DhcpMapJetError( JetError, "CreateIndex" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    IndexKey =  "+" MACHINE_NAME_STRING "\0";
    JetError = JetCreateIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColName,
        JET_bitIndexIgnoreNull,
        IndexKey,
        strlen(IndexKey) + 2, // for two termination chars + 2, // for two termination chars
        50
    );

    Error = DhcpMapJetError( JetError, "CreateIndex" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpOpenMCastDbTable(
                 DhcpGlobalJetServerSession,
                 DhcpGlobalDatabaseHandle);

  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_JET, "Database creation failed, %ld.\n", Error ));
    }
    else {

        DhcpPrint(( DEBUG_JET, "Succssfully Created DHCP database ..\n" ));
    }

    return(Error);
}

DWORD
DhcpSetJetParameters(
    VOID
)
    /*++

      Routine Description:

      This routine sets all the jet system params.

      Arguments:

      none.

      Return Value:

      Windows Error.

      --*/
{

    JET_ERR JetError;
    CHAR DBFilePath[MAX_PATH];
    DWORD Error;

    DBFilePath[ 0 ] = '\0';

    // First check registry DynLoadJet parameter for value:
    // If it does not exist, then proceed, otherwise,
    // set DhcpGlobalDynLoadJet to this value!
    // Delete the key afterwards, anyways... so that things
    // work right the next time dhcp comes up.

    // this is to be done.

    DhcpPrint((DEBUG_MISC, "DhcpJetSetParameters: entered\n"));

    //
    // set checkpoint file path.
    //
    if ( ( strlen( DhcpGlobalOemDatabasePath ) + 2 ) < MAX_PATH )
    {
        strcpy( DBFilePath, DhcpGlobalOemDatabasePath );
        strcat( DBFilePath, DHCP_KEY_CONNECT_ANSI );
    }
    
    //
    // Convert OemPath to Ansi..
    //
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );

    DhcpPrint(( DEBUG_MISC, 
		"Jet: Using the filepath: %s \n",
		DBFilePath ));

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramSystemPath,
        0,
        DBFilePath );
    
    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam SystemPath : %ld\n", JetError));
        goto Cleanup;
    }
    
    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramBaseName,
        0,
        DATABASE_BASE_NAME );
    
    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam paramBaseName : %ld\n", JetError ));
        goto Cleanup;
    }
    
    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramLogFileSize,
        1024,               // 1024kb - default is 5mb
        NULL );


    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam paramLogFileSize : %ld\n", JetError ));
        goto Cleanup;
    }

    strcpy( DBFilePath, DhcpGlobalOemDatabasePath );
    strcat( DBFilePath, DHCP_KEY_CONNECT_ANSI );

    //
    // Convert OEM to ANSI
    //
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );

    // maybe TempPath is just a directory name!!
    // the upgrade.doc Appendix is not very clear..
    // It says: TempPath is a pathname and not a filename
    // anymore.... (JET97)
    // Clarification from: cheen liao: pathnames should
    // end in '\' ==> only directory names allowed.

    DhcpPrint(( DEBUG_MISC, "Jet: tempPath = %s\n", 
		DBFilePath ));
    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramTempPath,
        0,
        DBFilePath );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam: TempPath : %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // The max number of buffers for database usage
    //
    // The default number is 500.  600 events are allocated for 500
    // buffers -- Ian 10/21/93.  Each buffer is 4K.  By keeping the
    // number small, we impact performamce
    //

    // If you change the # of buffers, be sure to change
    // JET_paramStartFlushThreshold and StopFlushThreshold also!!!
    // Those numbers are percentages of this!

    // Note that for JET97, JET_paramMaxBuffers has been redefined
    // as JET_paramCacheSizeMax!

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramCacheSizeMax,
        JET_MAX_CACHE_SIZE,  // larger buffers take more space but are good for perf
        NULL );             //ignored
    
    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam CacheSizeMax : %ld\n", JetError));
        goto Cleanup;
    }
    
    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramCacheSizeMin,
        4 * MAX_NO_SESSIONS,//see comment near JET_paramMaxSessions on this number
        NULL
        );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam MaxBuffers : %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // The max. number of buffers to store old version of a record
    // (snapshot at the start of a transaction) Each version store is 16k
    // bytes.  A version store stores structures that hold information
    // derived from a snapshot of the database prior to an insert (20 bytes
    // roughly) or update (size of the record + 20 bytes).
    //
    // For small transactions (i.e. a transaction around each update),
    // this number should be >= the max. number of sessions that can be
    // updating/inserting at the same time.  Each session will have one
    // version bucket.  Since 16k of version bucket size can result in a
    // lot of wastage per session (since each record is < .5k, and on the
    // average around 50 bytes), it may be better to specify the max.  size
    // of the version bucket (<< 16k).  Ian will provide a system param for
    // this if we absolutely need it
    //
    // since we serialize the database access with the dhcp server, num.
    // of session will be one.
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxVerPages,
        1500, // 1
        NULL);

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam paramMaxVerPages: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Set the File Control Block Param
    //
    // This is the max. number of tables that can be open at any time.
    // If multiple threads open the same table they use the same FCB.
    // FCB is 1 per table/index. Now, for a create database, we need
    // atleast 18 FCBS and 18 IDBS.  However apart from create database
    // and ddl operations, we don't need to have these tables open.
    // Default value is 300. Size of an FCB is 112 bytes.
    //
    // we have just one table.
    //

    // For __JET97, maxopentables and maxopentableindexes are combined
    // here .. So, the # here should be 18 + maxopentableindexes.

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxOpenTables,
        18 + 18 , //10
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam MaxOpenTables: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Set the File Usage Control Block to 100.  This parameter indicates
    // the max.  number of cursors that can be open at any one time.  This
    // is therefore dependent on the the max.  number of sessions that we
    // can have running concurrently.  For each session, there would be 4
    // cursors (for the two tables) + a certain number of internal cursors.
    // For good measure we add a pad.  Default value is 300.  Size of each
    // is 200 bytes.  We use MAX_SESSIONS * 4 + pad (around 100)
    //
    // MAX_SESSION = 1
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxCursors,
        100, //32
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam MaxCursors: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Set the number of index description blocks. This is one per
    // table/index.  We have two tables each with two indices.  We use 9i
    // (see comment for FCBs above).  Default value is 300.  Size of each
    // is 128 bytes.
    //
    // We have only 2 indices.
    //

    // note that this parameter is subsumed in JET_paramMaxOpenTables.
    // so, to change this, a corresponding change must be effected there.
    // : JET97



    //
    // Set the Sort Control block.  This should be 1 per concurrent Create
    // Index.  Default value is 20.  Size of each is 612 bytes.  In the
    // case of WINS, the main thread creates the indices.  We therefore set
    // it to 1.
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxTemporaryTables,
        1,
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam MaxTemporaryTables : %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Set the Number for the Database Attribute Block
    //
    // This is max.  number of Open Databases done.  Since we can have a
    // max of MAX_NO_SESSIONS at one time.  This should be equal to that
    // number (since we have just one database) Default number is 100.
    // Size is 14 bytes
    //

    //
    // The min percentage of buffers not yet dirtied before
    // background flushing begins
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramStartFlushThreshold,
	JET_START_FLUSH_THRESHOLD,
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam BfThrshldLowPrcnt : %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // The max percentage of buffers not yet dirtied before
    // background flushing begins
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramStopFlushThreshold,
	JET_STOP_FLUSH_THRESHOLD,
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam ThrshldHiPrcnt : %ld\n", JetError ));
        goto Cleanup;
    }


    //
    // No JET informational event logs
    //

    JetError = JetSetSystemParameter( &JetInstance, ( JET_SESID ) 0,
				      JET_paramNoInformationEvent,
				      TRUE, NULL );
    Error = DhcpMapJetError( JetError, "JET_paramNoInformationEvent" );
    if ( ERROR_SUCCESS != Error ) {
	DhcpPrint(( DEBUG_MISC, 
		    "JET_paramNoInformationEvent failed: %ld\n", JetError ));
	goto Cleanup;
    }

    //
    // The max.  number of sessions that can be open at any time
    //
    // Note: Jet does not preallocate resources corresponding to the max.
    // value.  It allocates them dynamically upto the limit -- according to
    // Ian Jose 7/12/93
    //
    // When checked with Ian again on 10/21, he said that they are
    // allocated statically
    //

    //
    // Note that paramMaxSessions mut be atleast fourtimes > MinBufferSize
    //  according to Cheen Liao (10/30/97) - RameshV
    // Just looked at wins code and it appears like
    //   Min cache size must be atlast 4 times the size of # of sessions
    //   according to Cheen.  Presume its my fault in inverting the ienqueality..
    // -- RameshV 05/18/98.
    // so we carefully fix the MinBufferSize variable..
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxSessions,
        MAX_NO_SESSIONS,
        NULL );


    if( DhcpGlobalDatabaseLoggingFlag ) {

        JetError = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JET_paramRecovery, TRUE,
            "on"
            );
        Error = DhcpMapJetError( JetError, "SetSysParam" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "JetSetSysParam Recovery %ld\n", JetError ));
            goto Cleanup;
        }

        //
        // The number of log sectors.  Each sector is 512 bytes.  We should
        // keep the size more than the threshold so that if the threshold is
        // reached and flushing starts, Jet can still continue to log in the
        // spare sectors.  Point to note is that if the log rate is faster than
        // the flush rate, then the Jet engine thread will not be able to log
        // when the entire buffer is filled up.  It will then wait until
        // space becomes available.
        //

        JetError = JetSetSystemParameter(
            &JetInstance,
            (JET_SESID)0,           //SesId - ignored
            JET_paramLogBuffers,
            30,                    // 30 sectors
            NULL );                 //ignored

        Error = DhcpMapJetError( JetError, "SetSysParam" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "JetSetSysParam LogBuffers %ld\n", JetError ));
            goto Cleanup;
        }


        //
        // Set the number of log buffers dirtied before they are
        // flushed.  This number should always be less than the number
        // for LogBuffers so that spare sectors are there for concurrent
        // logging.  Also, we should make this number high enough to
        // handle burst of traffic.
        //

        // For JET97 this is automaticall set as half of LogBuffers.. and
        // cannot be set by user..

        //
        // Set the wait time (in msecs) to wait prior to flushing the
        // log on commit transaction to allow other users (sessions) to
        // share the flush
        //
        // This is the time after which the user (a session) will ask
        // the log manager to flush.  If we specify 0 here than it means
        // flush every time a transaction commits.  In the DHCP server
        // case, every insertion or modification is done under an
        // implicit transaction.  So, it means that there will be
        // a flush after every such transaction.  It has been seen on a
        // 486/66 (Cheen Liao) machine that it takes roughly 16 msecs to
        // do the flush.  The time it takes to do the flush is dependent
        // upon the type of disk (how fast it is), the CPU speed,
        // the type of file system etc. We can for now go with the
        // assumption that it is in the range 15-25 msecs. I am pushing
        // for this WaitTime to be made a session specific param so that
        // it can be changed on the fly if the admin. finds that
        // the DHCP server is slow due to the WaitTime being very low or
        // if it finds it to be so large that in case of a crash, there
        // is possibility to loose a lot of data.


        //
        // Making this session specific is also very important for
        // replication where we do want to set it to a high value (high
        // enough to ensure that most of the records that need to be
        // inserted are inserted before a flush action takes place.  The
        // wait time would be set every time a bunch of records are pulled
        // in for replication.  It will be computed based on the number of
        // records pulled in and the time it takes to insert one record in
        // the jet buffer.  The wait time should preferably be < than the
        // above computed time (it does not have to be).

        // NOTE: In the Pull thread, I will need to start two sessions,
        // one for updating the OwnerId-Version number table (0 wait time)
        // and the other to update the name-address mapping table (wait
        // time computed based on the factors mentioned above)


        //
        // The following will set the WaitLogFlush time for all sessions.
        //

        JetError = JetSetSystemParameter(
            &JetInstance,
            (JET_SESID)0,        //SesId - ignored
            JET_paramWaitLogFlush,
            100,        //wait 100 msecs after commit
            //before flushing
            NULL);      //ignored

        Error = DhcpMapJetError( JetError, "SetSysParam" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "JetSetSysParam: WaitLogFlush : %ld\n", JetError ));
            goto Cleanup;
        }

        //
        // There does not seem to be any need to set Log Flush Period.
        //

        //
        // set the log file path
        //

        strcpy( DBFilePath, DhcpGlobalOemDatabasePath );
        strcat( DBFilePath, DHCP_KEY_CONNECT_ANSI );

        //
        // Convert OEM to ANSI
        //
        OemToCharBuffA(DBFilePath, DBFilePath, strlen( DBFilePath) );
        
        //
        // jet does't allow us to set the LOG file name for some
        // technical resons.
        //
        // strcat( DBFilePath, DATABASE_LOG_FILE );
        //

        JetError = JetSetSystemParameter(
            &JetInstance,
            (JET_SESID)0,       //SesId - ignored
            JET_paramLogFilePath,
            0,
            DBFilePath );

        Error = DhcpMapJetError( JetError, "SetSysParam" );
        if( NO_ERROR != Error ) {
            goto Cleanup;
        }
    } // if global database logging flag
    else {
        //
        // Do not set the recovery flag so that it won't try to recover from the
        // default place : %windir%\system32
        //

        JetError = JetSetSystemParameter( &JetInstance, ( JET_SESID ) 0,
                                          JET_paramRecovery, FALSE, "off" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS,
                        "JetSetSystemParmater failed on ChkFmtWhnOpnFail\n"));
            goto Cleanup;
        }
    } // else

    // Now set the JET_paramCheckFormatWhenOpenFail so that opening
    // the oldformat database would retrun JET_errDatabaseXXXFormat

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID) 0,
        JET_paramCheckFormatWhenOpenFail,
        1,
        NULL);

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
                    "JetSetSystemParmater failed on ChkFmtWhnOpnFail\n"));
        goto Cleanup;
    }


    //
    // Rotate log file option
    //
    JetError = JetSetSystemParameter(
        &JetInstance,
	(JET_SESID) 0,
	JET_paramCircularLog,
	1, 
	NULL );
    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if ( Error != ERROR_SUCCESS ) {
	DhcpPrint(( DEBUG_ERRORS, 
		    "JetSetSystemParameter failed on CircularLog\n" ));
	goto Cleanup;
    }

    //
    // dont restore if the old logs are not matching
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID) 0,
        JET_paramDeleteOutOfRangeLogs,
        1,
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if ( Error != ERROR_SUCCESS )
    {
        DhcpPrint( ( DEBUG_ERRORS,
                    "JetSetSystemParameter failed on DeleteOutOfRangeLogs\n"));
        
        goto Cleanup;
    }
                    
  Cleanup:

    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
                    "DhcpJetSetParameters failed, %ld.\n", Error ));
    }
    return( Error );
}

VOID
DhcpTerminateJet()
/*++
    This routine ends the jet session and terminates the jet engine.
--*/
{
    DWORD   JetError;

    if( DhcpGlobalJetServerSession != 0 ) {
        JetError = JetEndSession( DhcpGlobalJetServerSession, 0 );
        DhcpPrint((DEBUG_MISC, "JetEndSession\n")); // JET TRACE
        DhcpMapJetError( JetError, "EndSession" );
        DhcpGlobalJetServerSession = 0;
    }

    // Close Terminate the DHCP Writer
    JetError = DhcpWriterTerm();
    if ( ERROR_SUCCESS != JetError ) {
	DhcpPrint(( DEBUG_MISC, "DhcpWriterTerm failed\n" ));
    }
    JetError = JetTerm2( JetInstance, JET_bitTermComplete );
    DhcpMapJetError( JetError, "JetTerm/JetTerm2" );
}

static ULONG InitCount = 0;


DWORD __stdcall
DhcpUpgradeAddDbEntry(
    IN PDHCP_RECORD Rec
    );

DWORD
UpgradeDhcpDatabase(
    VOID
    )
{
    DWORD Error;
    
    Error = DhcpUpgConvertTempToDhcpDb( DhcpUpgradeAddDbEntry );
    
    if( NO_ERROR != Error ) {

        DhcpServerEventLog(
            EVENT_SERVER_DATABASE_CONVERSION,
            EVENTLOG_ERROR_TYPE,
            Error );
        
    }

    return Error;
}


DWORD
DhcpDeleteFiles(
    LPSTR DatabasePath,
    LPSTR Files
)
    /*++

      Routine Description:

      Delete files .

      Arguments:

      DatabasePath - full path name where the database is restored.

      Files - files to be deleted (can have wild char. in filename).

      Return Value:

      Windows Error.

      --*/
{
    DWORD Error;
    CHAR CurrentDir[ MAX_PATH ];
    HANDLE HSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAA FileData;

    CHAR DstFile[ MAX_PATH ];
    LPSTR DstFileNamePtr;

    //
    // Read and save current directory to restore CD at the end.
    //

    if( GetCurrentDirectoryA( MAX_PATH, CurrentDir ) == 0 ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_JET,
                    "GetCurrentDirctoryA failed, Error = %ld.\n", Error ));
        return( Error );
    }

    //
    // set current directory to backup path.
    //

    if( SetCurrentDirectoryA( DatabasePath ) == FALSE ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_JET,
                    "SetCurrentDirctoryA failed, Error = %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // Start file serach on current dir.
    //

    HSearch = FindFirstFileA( Files, &FileData );

    if( HSearch == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_JET,
                    "FindFirstFileA failed (Files = %s), Error = %ld.\n",
		    Files, Error ));
        goto Cleanup;
    }

    //
    // delete files.
    //

    for( ;; ) {

        if( DeleteFileA( FileData.cFileName ) == FALSE ) {

            Error = GetLastError();
            DhcpPrint(( DEBUG_JET,
                        "CopyFileA failed, Error = %ld.\n", Error ));
            goto Cleanup;
        }

        //
        // Find next file.
        //

        if ( FindNextFileA( HSearch, &FileData ) == FALSE ) {

            Error = GetLastError();

            if( Error == ERROR_NO_MORE_FILES ) {
                break;
            }

            DhcpPrint(( DEBUG_JET,
                        "FindNextFileA failed, Error = %ld.\n", Error ));
            goto Cleanup;
        }
    }

  Cleanup:

    if( HSearch != INVALID_HANDLE_VALUE ) {
        FindClose( HSearch );
    }

    if( ERROR_NO_MORE_FILES == Error ) Error = NO_ERROR;
    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    
    //
    // reset current currectory.
    //

    SetCurrentDirectoryA( CurrentDir );

    return( Error );
}

DWORD
DhcpInitializeDatabaseEx(
    IN BOOL fReadOnly
)
/*++

Routine Description:
    This function initializes the DHCP database. If the DHCP database
    exists then it open the database and initialize all ColumnIds,
    otherwise it creates a new database and obtains ColumnsIds.

Arguments:
    fReadOnly -- this parameter is set to TRUE only if it is
    called from outside the service -- in this case nothing new
    must be created..

Return Value:
    Windows Error.

--*/
{
    JET_ERR JetError;
    JET_COLUMNDEF columnDef;
    DWORD Error;
    DWORD i;
    CHAR DBFilePath[MAX_PATH];
    BOOL fRunUpgradeStuff = FALSE;

    DBFilePath[ 0 ] = '\0';

    if( 0 != InitCount ) return ERROR_SUCCESS;

    //
    // Allocate the TLS index used for jet errors
    //
    JetTlsIndex = TlsAlloc();
    if ( TLS_OUT_OF_INDEXES == JetTlsIndex ) {
        return GetLastError();
    }


    //
    // If upgrade is not completed yet, delete all the log files
    // and remember this so that soon after the database is
    // created, the upgrade code can be run
    //
    
    if( !fReadOnly && TRUE == DhcpCheckIfDatabaseUpgraded(FALSE) ) {

        fRunUpgradeStuff = TRUE;

        if ( strlen( DhcpGlobalOemDatabasePath ) < MAX_PATH )
            strcpy( DBFilePath, DhcpGlobalOemDatabasePath );

	OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
        
        Error = DhcpDeleteFiles( DBFilePath, "j50*.log" );
        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "Delete log files: 0x%lx\n",
                       Error));
            return Error;
        }

        Error = DhcpDeleteFiles( DBFilePath, "res*.log" );
        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "Delete log files: 0x%lx\n",
                       Error));
            return Error;
        }

        Error = DhcpDeleteFiles( DBFilePath, "*.mdb" );
        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "Delete mdb files: 0x%lx\n",
                       Error ));
            return Error;
        }
    } // if upgrade
        
    LOCK_DATABASE();

    DhcpPrint((DEBUG_MISC, "Entering DhcpInitializeDatabase\n"));
    Error = DhcpSetJetParameters();
    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // -------------------------------------------------------------------
    //
    DhcpPrint(( DEBUG_ERRORS,
                "Calling JetInit\n" ));
    JetError = JetInit( &JetInstance );
    DhcpPrint((DEBUG_MISC,"DhcpInitializeDatabase: JetInit(_): %ld\n", JetError));

    DhcpPrint(( DEBUG_ERRORS,
                "After Calling JetInit\n" ));

    Error = DhcpMapJetError( JetError, "JetInit" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // Initialize the DHCP writer
    Error = DhcpWriterInit();
    if ( ERROR_SUCCESS != Error ) {
	DhcpPrint(( DEBUG_ERRORS, "Failed to initialize DhcpWriter\n" ));
	goto Cleanup;
    }

    JetError = JetBeginSession(
        JetInstance,
        &DhcpGlobalJetServerSession,
        "admin",
        "" );

    if( *(DWORD *)(DhcpGlobalJetServerSession) == -1 ) {
        DhcpPrint((DEBUG_MISC, "JetBeginSession returned -1 session!\n"));
    }

    DhcpPrint((DEBUG_MISC, "JetBeginSession\n")); //JET TRACE
    Error = DhcpMapJetError( JetError, "JetBeginSEssion" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetBeginSession: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Attach the database so that it always looks at the place where
    // we want to.
    //

    DBFilePath[ 0 ] = '\0';

    if ( ( strlen( DhcpGlobalOemDatabasePath ) + strlen( DhcpGlobalOemDatabaseName) + 2 ) < MAX_PATH )
    {
        strcpy(DBFilePath, DhcpGlobalOemDatabasePath );
        strcat(DBFilePath, DHCP_KEY_CONNECT_ANSI );
        strcat(DBFilePath, DhcpGlobalOemDatabaseName );
    }

    //
    // Convert OEM to ANSI
    //
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
    
    //
    // detach all previous installation of dhcp databases.
    //

    DhcpPrint((DEBUG_MISC, "Trying to JetDetachDb(%ld)\n", DhcpGlobalJetServerSession)); // JET TRACE
    JetError = JetDetachDatabase(
        DhcpGlobalJetServerSession,
        NULL );

    DhcpPrint((DEBUG_MISC, "JetDetachDatabase\n")); // JET TRACE

    Error = DhcpMapJetError( JetError, "JetDetachDatabase" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "DhcpDetachDatabase: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // attach current dhcp database file.
    //

    DhcpPrint((DEBUG_MISC, "Trying to JetAttachDatabase %s\n", DBFilePath));
    JetError = JetAttachDatabase(
        DhcpGlobalJetServerSession,
        DBFilePath,
        0 );

    DhcpPrint((DEBUG_MISC, "JetAttachDatabase\n")); // JET TRACE

    //
    // if the database is not found, it is ok. We will create it later.
    //

    if ( JetError != JET_errFileNotFound ) {

        Error = DhcpMapJetError( JetError, "AttachDatabase" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "DhcpMapJetError %ld\n", JetError ));
            goto Cleanup;
        }
    }

    //
    // hook the client table pointer.
    //

    DhcpGlobalClientTable = ClientTable;
    DhcpAssert( CLIENT_TABLE_NUM_COLS == MAX_INDEX );

    JetError = JetOpenDatabase(
        DhcpGlobalJetServerSession,
        DBFilePath,  // full path and file name.
        NULL, // default engine
        &DhcpGlobalDatabaseHandle,
	0 );

    DhcpPrint((DEBUG_MISC, "JetOpenDatabase\n")); // JET TRACE
    //
    // if no database exists then create one and also initize it for
    // use.
    //

    if( !fReadOnly && JetError == JET_errDatabaseNotFound ) {

        Error = DhcpCreateAndInitDatabase(
            NULL, // default engine
            &DhcpGlobalDatabaseHandle,
            0 );


        DhcpPrint((DEBUG_MISC, "JetCreateAndInitDatabase\n")); // JET TRACE
        goto Cleanup;
    }

    Error = DhcpMapJetError( JetError, "CreateAndInitDb" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "DhcpOpenDatabase %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // database is successfully opened, open table and columns now.
    //

    JetError = JetOpenTable(
        DhcpGlobalJetServerSession,
        DhcpGlobalDatabaseHandle,
        CLIENT_TABLE_NAME,
        NULL,
        0,
        0,
        &DhcpGlobalClientTableHandle );
    DhcpPrint((DEBUG_MISC, "JetOpenTable\n")); // JET TRACE

    Error = DhcpMapJetError( JetError, "OpenTable" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "DhcpOpenTable %ld\n", JetError ));
        goto Cleanup;
    }

    for ( i = 0; i < CLIENT_TABLE_NUM_COLS; i++ ) {

        JetError = JetGetTableColumnInfo(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            DhcpGlobalClientTable[i].ColName,
            &columnDef,
            sizeof(columnDef),
            0);
        DhcpPrint((DEBUG_MISC, "JetCreateTableColumnInfo\n")); // JET TRACE

        //
        // if the column doesn't exist, add it now.
        //

        if ( JET_errColumnNotFound == JetError )
        {
            JET_COLUMNDEF   ColumnDef;

            ColumnDef.cbStruct = sizeof( ColumnDef );
            ColumnDef.columnid = 0;
            ColumnDef.wCountry = 1;
            ColumnDef.langid   = DB_LANGID;
            ColumnDef.cp       = DB_CP;
            ColumnDef.wCollate = 0;
            ColumnDef.cbMax    = 0;
            ColumnDef.grbit    = 0;

            ColumnDef.coltyp   = DhcpGlobalClientTable[i].ColType;
            JetError = JetAddColumn(
                DhcpGlobalJetServerSession,
                DhcpGlobalClientTableHandle,
                DhcpGlobalClientTable[i].ColName,
                &ColumnDef,
                NULL,
                0,
                &DhcpGlobalClientTable[i].ColHandle );
            DhcpPrint((DEBUG_MISC, "JetAddColumn\n")); // JET TRACE
        }

        Error = DhcpMapJetError( JetError, "AddColumn" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "JetTableColumnInfo %ld\n", Error ));
            goto Cleanup;
        }

        DhcpGlobalClientTable[i].ColHandle  = columnDef.columnid;
    }

    Error = DhcpOpenMCastDbTable(
                 DhcpGlobalJetServerSession,
                 DhcpGlobalDatabaseHandle);

  Cleanup:
    DhcpPrint((DEBUG_MISC, "Exiting DhcpInitializeDatabase %ld\n", Error));

    if( ERROR_SUCCESS == Error ) {
        InitCount ++;
        if( fRunUpgradeStuff ) {
            Error = UpgradeDhcpDatabase();
            if( NO_ERROR != Error ) {
                DhcpPrint((DEBUG_MISC, "UpgradeDhcpDatabase: 0x%lx\n", Error));
            }
        }
    }
    
    if( NO_ERROR != Error ) {
        
        //
        // terminate/cleanup jet session, if we are not successful.
        //

        if( DhcpGlobalClientTableHandle != 0 ) {
            JetError = JetCloseTable(
                DhcpGlobalJetServerSession,
                DhcpGlobalClientTableHandle );
            DhcpMapJetError( JetError, "CloseTable" );
            DhcpPrint((DEBUG_MISC, "JetCloseTable\n")); // JET TRACE
            DhcpGlobalClientTableHandle = 0;
        }

        if( DhcpGlobalDatabaseHandle != 0 ) {
            JetError = JetCloseDatabase(
                DhcpGlobalJetServerSession,
                DhcpGlobalDatabaseHandle,
                0 );
            DhcpPrint((DEBUG_MISC, "JetCloseDatabase\n")); // JET TRACE
            DhcpMapJetError( JetError, "CloseDatabse" );
            DhcpGlobalDatabaseHandle = 0;
        }

        DhcpTerminateJet();
    }

    UNLOCK_DATABASE();
    return( Error );
}

DWORD
DhcpInitializeDatabase(
    VOID
)
{
    return DhcpInitializeDatabaseEx( FALSE );
}

VOID
DhcpCleanupDatabase(
    IN DWORD ErrorCode
)
/*++

Routine Description:
    This function cleans up the JET database data structures after
    gracefully shutting down the JET.

Arguments:
    ErrorCode - Supplies the error code of the failure

Return Value:
    none.

 --*/
{
    DWORD Error;
    JET_ERR JetError;
    CHAR DBFilePath[MAX_PATH];
    char *backupPrefix = "\\New";

    DBFilePath[ 0 ] = '\0';

    //
    // Convert path to ANSI
    //
    if( NULL != DhcpGlobalOemJetBackupPath ) {
    if ( ( strlen( DhcpGlobalOemJetBackupPath ) + strlen( backupPrefix ) ) < MAX_PATH )
        strcpy(DBFilePath, DhcpGlobalOemJetBackupPath );
        strcat(DBFilePath, backupPrefix );

        OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
    }

    if( 0 == InitCount ) return;
    InitCount --;
    if( 0 != InitCount ) return;

    LOCK_DATABASE();


    // write the bitmask to the database
    FlushBitmaskToDatabase();

    if( DhcpGlobalClientTableHandle != 0 ) {
        JetError = JetCloseTable(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle );
        DhcpMapJetError( JetError, "CloseTable" );
        DhcpGlobalClientTableHandle = 0;
    }


    if( DhcpGlobalDatabaseHandle != 0 ) {
        JetError = JetCloseDatabase(
            DhcpGlobalJetServerSession,
            DhcpGlobalDatabaseHandle,
            0 );
        DhcpMapJetError( JetError, "CloseDatabase" );
        DhcpGlobalDatabaseHandle = 0;
    }

    DhcpTerminateJet();

    UNLOCK_DATABASE();

    // Free the Tls Index
    if ( TLS_OUT_OF_INDEXES != JetTlsIndex ) {
        if ( !TlsFree( JetTlsIndex )) {
            Error = GetLastError();

            // Should not have problems freeing a valid index
            DhcpAssert( ERROR_SUCCESS == Error );
        }
    } // if

} // DhcpCleanupDatabase()

DWORD
DhcpBackupDatabase(
    LPSTR BackupPath
)
    /*++

      Routine Description:

      This functions backup the JET database. FullBackup copies the
      database file and all log files. Incremental backup copies only
      the log files that are modified since the last backup.

      Arguments:

      BackupPath - full path name where the database is backed up.

      Return Value:

      Windows Error.

      --*/
{
    DWORD Error;
    JET_ERR JetError;
    JET_GRBIT BackupBits = 0;
    CHAR DBFilePath[MAX_PATH];

    DBFilePath[ 0 ] = '\0';

    //
    // Convert path to ANSI
    //
    if( NULL != BackupPath ) {
        if ( strlen( BackupPath ) < MAX_PATH ) 
            strcpy(DBFilePath, BackupPath);

        OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
        BackupPath = DBFilePath;
    }

    //
    // According to the jetapi.doc, we don't need to take any locks while backing up..
    //

    DhcpPrint(( DEBUG_JET,
                "DhcpBackupDatabase (%s) called.\n", BackupPath ));

    // Create the backup path if it exists
    if ( !CreateDirectoryPathOem( BackupPath, NULL )) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Create Backup path failed : Error = %x\n",
                    Error ));
        return Error;
    } // if

    BackupBits  =   JET_bitBackupAtomic | JET_bitBackupFullWithAllLogs;

    JetError = JetBackup( BackupPath, BackupBits, NULL );

    Error = DhcpMapJetError( JetError, (BackupPath)? "JetBackup" : "JetBackupToNULL");

    DhcpPrint(( DEBUG_JET,
                "DhcpBackupDatabase (FULL) completed.\n" ));

    return( Error );
} // DhcpBackupDatabase()
DWORD
DhcpRestoreDatabase(
    LPSTR BackupPath
)
    /*++

      Routine Description:

      This function restores the database from the backup path to
      the working directory. It also plays pack the log files from the
      backup path first and then the log files from working path. After
      this restore the database should be brought back to the state when
      the last successful update on the database was performed.

      Arguments:

      BackupPath - full path name where the database is backed up.

      Return Value:

      Windows Error.

      --*/
{
    DWORD Error;
    JET_ERR JetError;
    CHAR DBFilePath[MAX_PATH];

    //
    // Convert path to ANSI
    //

    ASSERT( NULL != BackupPath );
    strcpy(DBFilePath, BackupPath);
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
    BackupPath = DBFilePath;
    
    DhcpPrint(( DEBUG_JET, "DhcpRestoreDatabase(%s) called.\n", BackupPath ));
    
    LOCK_DATABASE();

    Error = DhcpSetJetParameters();

    do {
	if ( Error != ERROR_SUCCESS ) {
	    break;
	}
	
	//
	// HACK! delete all log files in the database directory. The
	// reason for doing this is because, JetRestore just copies
	// over the backed up database and log files and replays all
	// the logfiles -- including the ones present before the restore.
	// This is obviously no good as the logs could have been
	// there after the backup...  
	//
	
	DhcpPrint(( DEBUG_MISC, 
		    "BackupPath = %s, DhcpGlobalOemJetBackupPath = %s\n",
		    BackupPath, DhcpGlobalOemJetBackupPath ));

	if( _stricmp(BackupPath, DhcpGlobalOemJetBackupPath) ) {
	    
	    Error = DhcpDeleteFiles( DhcpGlobalOemDatabasePath, "j50*.log" );
	    if( NO_ERROR != Error ) {
		break;
	    }
	} // if 

	//
	// Since DHCP has only one database and we need to restore it, it is
	// not necessary to specify the list of databases to restore, so the
	// parameters 2, 3, and 4 are set to ZERO.
	//
	JetError = JetRestore( BackupPath,
			       0);      // restore all databases.
	
	Error = DhcpMapJetError( JetError, "JetRestore" );
    } // do
    while ( FALSE );
    

    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Restore failed: 0x%lx\n", Error));
    } // if
    
    UNLOCK_DATABASE();
    return( Error );
} // DhcpRestoreDatabase()

DWORD __stdcall
DhcpUpgradeAddDbEntry(
    IN PDHCP_RECORD Rec
    )
{
    WCHAR Name[512], Info[512];
    WCHAR *pName, *pInfo;
    DWORD Address, ScopeId;
    
    pName = pInfo = NULL;
    
    //
    // Add a DHCP or madcap record
    //
    
    if( Rec->fMcast == FALSE ) {
        if( NULL != Rec->Info.Dhcp.Name ) {
            pName = Name;
            while( *pName = *Rec->Info.Dhcp.Name ) {
                pName ++; Rec->Info.Dhcp.Name ++;
            }
            pName = Name;
        }

        if( NULL != Rec->Info.Dhcp.Info ) {
            pInfo = Info;
            while( *pInfo = *Rec->Info.Dhcp.Info ) {
                pInfo ++; Rec->Info.Dhcp.Info ++;
            }
            pInfo = Info;
        }
        
        return CreateClientDBEntry(
            ntohl(Rec->Info.Dhcp.Address),
            ntohl(Rec->Info.Dhcp.Mask),
            Rec->Info.Dhcp.HwAddr, Rec->Info.Dhcp.HwLen, 
            *(DATE_TIME *)&Rec->Info.Dhcp.ExpTime, pName, pInfo,
            INADDR_LOOPBACK, Rec->Info.Dhcp.State,
            Rec->Info.Dhcp.Type );
        
    } else {

        //
        // Fake name and info for madcap
        //
        
        if( NULL != Rec->Info.Mcast.Info ) {
            pInfo = Info;
            while( *pInfo = *Rec->Info.Mcast.Info ) {
                pInfo ++; Rec->Info.Mcast.Info ++;
            }
            pInfo = Info;
        }

        Address = ntohl(Rec->Info.Mcast.Address);
        ScopeId = ntohl(Rec->Info.Mcast.ScopeId);

        return MadcapCreateClientEntry(
            (PVOID)&Address, sizeof(Address), ScopeId, 
            Rec->Info.Mcast.ClientId, Rec->Info.Mcast.HwLen, 
            pInfo, *(DATE_TIME *)&Rec->Info.Mcast.Start,
            *(DATE_TIME *)&Rec->Info.Mcast.End,
            INADDR_ANY, Rec->Info.Mcast.State, 0, FALSE );
    }
}

DWORD
DhcpOpenAndReadDatabaseConfig(
    IN LPSTR OemDatabaseName,
    IN LPSTR OemDatabasePath,
    OUT PM_SERVER *Server
    )
{
    BOOL LoadStrings(VOID);
    VOID FreeStrings(VOID);
    DWORD Error;

    //
    // Initialize required globals so that InitDatabase can be called.
    //
    
    DhcpGlobalOemDatabasePath = OemDatabasePath;
    DhcpGlobalOemDatabaseName = OemDatabaseName;
    if( FALSE == LoadStrings() ) return ERROR_NOT_ENOUGH_MEMORY;
    DhcpGlobalDatabaseLoggingFlag = TRUE;
    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;

    try {
        InitializeCriticalSection(&DhcpGlobalJetDatabaseCritSect);
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Error = GetLastError( );
        return Error;
    }

    Error = DhcpInitializeDatabaseEx(TRUE);
    DeleteCriticalSection(&DhcpGlobalJetDatabaseCritSect);

    //
    // Read config, uninitialize everything and return
    //
    
    if( NO_ERROR == Error ) Error = DhcpReadConfigInfo( Server );
            
    FreeStrings();
    DhcpTerminateJet();
    DhcpGlobalOemDatabasePath = NULL;
    DhcpGlobalOemDatabaseName = NULL;
    
    return Error;
} // DhcpOpenAndReadDatabaseConfig()

DWORD
DhcpOpenAndWriteDatabaseConfig(
    IN LPSTR OemDatabaseName,
    IN LPSTR OemDatabasePath,
    IN PM_SERVER Server
    )
{
    BOOL LoadStrings(VOID);
    VOID FreeStrings(VOID);
    DWORD Error;

    //
    // Initialize required globals so that InitDatabase can be called.
    //

    DhcpGlobalOemDatabasePath = OemDatabasePath;
    DhcpGlobalOemDatabaseName = OemDatabaseName;
    if( FALSE == LoadStrings() ) return ERROR_NOT_ENOUGH_MEMORY;
    DhcpGlobalDatabaseLoggingFlag = TRUE;
    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;

    try {
        InitializeCriticalSection(&DhcpGlobalJetDatabaseCritSect);
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Error = GetLastError( );
        return Error;
    }

    Error = DhcpInitializeDatabaseEx(TRUE);
    //
    // write config, uninitialize everything and return
    //

    if( NO_ERROR == Error ) {
        Error = DhcpOpenConfigTable(
            DhcpGlobalJetServerSession, DhcpGlobalDatabaseHandle );

        if( NO_ERROR == Error ) {
            Error = DhcpSaveConfigInfo(
                Server, FALSE, FALSE, 0, 0, 0 );
        }
    }

    FreeStrings();
    DhcpTerminateJet();

    DeleteCriticalSection(&DhcpGlobalJetDatabaseCritSect);

    DhcpGlobalOemDatabasePath = NULL;
    DhcpGlobalOemDatabaseName = NULL;

    return Error;
} // DhcpOpenAndWriteDatabaseConfig()

//
// Context type to be used when saving bitmasks
//

typedef struct BitmaskCtxt {
    DWORD RangeStart; // Starting IP of the range
    DWORD Offset;     // Offset from the RangeStart for this bitmap
} BitmaskContext;


typedef struct DbBitmaskStruct {
    DWORD RangeStart;
    DWORD Offset;
    DWORD NumBits;
    DWORD Size;
    LPBYTE Buf;
    DWORD  BufSize;
} DB_BITMASK, *PDB_BITMASK, *LPDB_BITMASK;


DWORD 
OpenBitmaskCleanFlagTable( void )
{
    DWORD   Error;
    JET_ERR JetError;
    JET_COLUMNDEF ColDef;    


    //
    // Open the BitmaskClean table. If not found, create it
    //


    JetError = JetOpenTable( DhcpGlobalJetServerSession,
			     DhcpGlobalDatabaseHandle,
			     BITMASK_CLEAN_TABLE_NAME,
			     NULL, 0, 0, &BitmaskCleanFlagTbl );
    Error = DhcpMapJetError( JetError, "Bitmask clean table open" );
    if ( ERROR_SUCCESS != Error ) {
	// Create the table

	JetError = JetCreateTable( DhcpGlobalJetServerSession,
				   DhcpGlobalDatabaseHandle,
				   BITMASK_CLEAN_TABLE_NAME,
				   DB_TABLE_SIZE, DB_TABLE_DENSITY,
				   &BitmaskCleanFlagTbl );
	Error = DhcpMapJetError( JetError, "Create bitmask clean table" );
	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}



	// Create the column


	ColDef.cbStruct = sizeof( ColDef );
	ColDef.columnid = 0;
	ColDef.wCountry = DB_LANGID;
	ColDef.cp       = DB_CP;
	ColDef.wCollate = 0;
	ColDef.grbit    = 0;
	ColDef.coltyp   = BITMASK_CLEAN_FLAG_TYPE;
	JetError = JetAddColumn( DhcpGlobalJetServerSession,
				 BitmaskCleanFlagTbl,
				 BITMASK_CLEAN_FLAG_NAME,
				 &ColDef, NULL, 0, &BitmaskCleanFlagColId );
	Error = DhcpMapJetError( JetError, "Bitmask clean add column" );
    } // if 
    else {
	// Get column id

	JetError = JetGetColumnInfo( DhcpGlobalJetServerSession,
				     DhcpGlobalDatabaseHandle,
				     BITMASK_CLEAN_TABLE_NAME,
				     BITMASK_CLEAN_FLAG_NAME, 
				     &ColDef, sizeof( ColDef ), 0 );
	Error = DhcpMapJetError( JetError, "Get column info: bitmask clean flag" );
	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}
	
	BitmaskCleanFlagColId = ColDef.columnid;

    } // else table already exists


    return Error;
} // OpenBitmaskCleanFlagTable()

//
// Mark the Bitmap Clean flag 
//

DWORD
MarkBitmaskCleanFlag(
    BYTE Flag
)
{
    DWORD   Error;
    JET_ERR JetError;
    ULONG   Prep;

    Error = OpenBitmaskCleanFlagTable();

    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }

    do {
	// Go to the first record
	JetError = JetMove( DhcpGlobalJetServerSession, BitmaskCleanFlagTbl, 
			    JET_bitMoveFirst, 0 );
	Error = DhcpMapJetError( JetError, "Bitmask flag jetmove" );
	if (( ERROR_NO_MORE_ITEMS != Error ) &&
	    ( ERROR_SUCCESS != Error )) {

	    break;
	} // if


	// Write the field to the record 
	
	Prep = ( ERROR_SUCCESS == Error ) 
	    ? JET_prepReplace 
	    : JET_prepInsert;
	
	JetError = JetPrepareUpdate( DhcpGlobalJetServerSession,
				     BitmaskCleanFlagTbl, Prep );
	Error = DhcpMapJetError( JetError, "Bitmask clean prepare update" );
	if ( ERROR_SUCCESS != Error ) {
	    break;
	} // if
	
	
	JetError = JetSetColumn( DhcpGlobalJetServerSession,
				 BitmaskCleanFlagTbl,
				 BitmaskCleanFlagColId, &Flag,
				 sizeof( Flag ), 0, NULL );
	DhcpAssert( JET_errSuccess == JetError );
	
	JetError = JetUpdate( DhcpGlobalJetServerSession, BitmaskCleanFlagTbl,
			      NULL, 0, NULL );
	Error = DhcpMapJetError( JetError, "Jet update" );
    } while ( 0 );

    JetError = JetCloseTable( DhcpGlobalJetServerSession,
			      BitmaskCleanFlagTbl );
    DhcpAssert( JET_errSuccess == JetError );

    return Error;
} // MarkBitmaskCleanFlag()

DWORD
GetBitmaskCleanFlag( BYTE *pFlag )
{

    DWORD   Error;
    JET_ERR JetError;
    DWORD   Actual;

    DhcpAssert( pFlag != NULL );

    Error = OpenBitmaskCleanFlagTable();

    do {
	if ( ERROR_SUCCESS != Error ) {
	    *pFlag = 0;
	    break;
	}

	// Move to the first record and read the contents if any
	
	JetError = JetMove( DhcpGlobalJetServerSession, BitmaskCleanFlagTbl, 
			    JET_bitMoveFirst, 0 );
	Error = DhcpMapJetError( JetError, "Bitmask flag jetmove" );
	
	// Is the table empty?
	if ( ERROR_SUCCESS != Error ) {
	    *pFlag = 0;
	    if ( ERROR_NO_MORE_ITEMS == Error ) {
		Error = ERROR_SUCCESS;
	    }
	    break;
	} // if 
	
	// Bitmask flag is defined. Read it.
	JetError = JetRetrieveColumn( DhcpGlobalJetServerSession,
				      BitmaskCleanFlagTbl,
				      BitmaskCleanFlagColId,
				      pFlag, sizeof( *pFlag ),
				      &Actual, JET_bitRetrieveCopy, NULL );
	Error = DhcpMapJetError( JetError, "Bitmask flag read" );
	if ( ERROR_SUCCESS != Error ) {
	    *pFlag = 0;
	    break;
	}
	DhcpAssert( Actual == sizeof( *pFlag ));

    } while ( 0 );
    

    // Cleanup
    JetError = JetCloseTable( DhcpGlobalJetServerSession,
			      BitmaskCleanFlagTbl );
    DhcpAssert( JET_errSuccess == JetError );
    
    return Error;
} // GetBitmaskCleanFlag()

//
// Delete the bitmask table if it exists
//

DWORD
DeleteBitmaskTable(
    JET_SESID SesId,
    JET_DBID  DbId
)
{
    JET_ERR JetError;

    JetError = JetDeleteTable( SesId, DbId,
                               BITMASK_TABLE_NAME );

    DhcpAssert( JET_errTableInUse != JetError );
    DhcpAssert( JET_errInvalidSesid != JetError );
    DhcpAssert( JET_errInvalidDatabaseId != JetError );
    
    if (( JET_errObjectNotFound == JetError ) ||
        ( JET_errSuccess == JetError ) ||
        ( JET_errInvalidName == JetError )) {
        return ERROR_SUCCESS;
    }

    DhcpPrint(( DEBUG_JET, "Table %s deleted\n", BITMASK_TABLE_NAME ));
    return DhcpMapJetError( JetError, "JetDeleteTable(Bitmask)");

} // DeleteBitmaskTable()


//
// Create the bitmask table
//

DWORD 
CreateBitmaskTable(
    JET_SESID SesId,
    JET_DBID  DbId
)
{
    JET_ERR JetError;
    DWORD   Error;
    JET_COLUMNDEF ColDef;
    DWORD   i;

    // Create the table

    JetError = JetCreateTable( SesId, DbId, BITMASK_TABLE_NAME,
                               DB_TABLE_SIZE, DB_TABLE_DENSITY,
                               &BitmaskTbl);
    Error = DhcpMapJetError( JetError, "Create Bitmask Table" );
    if ( ERROR_SUCCESS != Error ) {
        return Error;
    }

    DhcpPrint(( DEBUG_JET, "Table created: %s\n",
                BITMASK_TABLE_NAME ));

    // Create the columns
    ColDef.cbStruct = sizeof( ColDef );
    ColDef.columnid = 0;
    ColDef.wCountry = 1;
    ColDef.langid = DB_LANGID;
    ColDef.cp = DB_CP;
    ColDef.wCollate = 0;
    ColDef.cbMax = 0;
    ColDef.grbit = 0;  // variable length binary and text data

    for ( i = 0; i < BITMASK_TABLE_NUM_COLS; i++ ) {
        ColDef.coltyp = BitmaskTable[ i ].ColType;
        JetError = JetAddColumn( SesId, BitmaskTbl,
                                 BitmaskTable[ i ].ColName,
                                 &ColDef, NULL, 0,
                                 &BitmaskTable[ i ].ColHandle );
        Error = DhcpMapJetError( JetError, "BitmaskAddColumn");
        if ( ERROR_SUCCESS != Error ) {
            return Error;
        }
        DhcpPrint(( DEBUG_JET, "Creating column: %s\n",
                    BitmaskTable[ i ].ColName ));
    } // for
    
    return Error;
} // CreateBitmaskTable()

//
// Open Existing bitmap table
//

DWORD
OpenBitmaskTable(
    JET_SESID SesId,
    JET_DBID  DbId
)
{
    JET_ERR JetError;
    JET_COLUMNDEF ColDef;
    DWORD   Error, i;


    // Open as read only.
    JetError = JetOpenTable( SesId, DbId, BITMASK_TABLE_NAME,
                             NULL, 0, JET_bitTableReadOnly,
                             &BitmaskTbl );
    Error = DhcpMapJetError( JetError, "BitmaskOpenTable" );
    if ( ERROR_SUCCESS != Error ) {
        return Error;
    }

    // Get the column handles

    for ( i = 0; i < BITMASK_TABLE_NUM_COLS; i++ ) {
        JetError = JetGetColumnInfo( SesId, DbId, BITMASK_TABLE_NAME,
                                     BitmaskTable[ i ].ColName,
                                     &ColDef, sizeof( ColDef ), 0
                                     );
        Error = DhcpMapJetError( JetError, "Bitmask: GetColumnInfo" );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }

        BitmaskTable[ i ].ColHandle = ColDef.columnid;
        DhcpAssert( BitmaskTable[ i ].ColType == ColDef.coltyp );

    } // for
    
    return Error;

} // OpenBitmaskTable()


//
// Close the Bitmask table
// 

DWORD 
CloseBitmaskTable(
    JET_SESID SesId
)
{
    JET_ERR JetError;
    DWORD   Error;

    JetError = JetCloseTable( SesId, BitmaskTbl );
    Error = DhcpMapJetError( JetError, "BitmaskCloseTable");

    DhcpPrint(( DEBUG_JET, "Table %s closed\n",
                BITMASK_TABLE_NAME ));
    return Error;

} // CloseBitmaskTable()



DWORD 
FlushLoop(
    PARRAY   ArrayToLoopThru,
    DWORD    ( *IteratorFunction) ( LPVOID Element, LPVOID Ctxt ),
    LPVOID   Ctxt
)
{

    DWORD   Error;
    ARRAY_LOCATION Loc;
    LPVOID  Element;


    Error = MemArrayInitLoc( ArrayToLoopThru, &Loc );
    while ( ERROR_FILE_NOT_FOUND != Error ) {
        Require( ERROR_SUCCESS == Error );

        Error = MemArrayGetElement( ArrayToLoopThru, &Loc, &Element);
        Require( ERROR_SUCCESS == Error );

        Error = IteratorFunction( Element, Ctxt );
        Require( ERROR_SUCCESS == Error );

        Error = MemArrayNextLoc( ArrayToLoopThru, &Loc );
    } // while

    if ( ERROR_FILE_NOT_FOUND == Error ) {
        Error = ERROR_SUCCESS;
    }

    return Error;
} // FlushLoop()

DWORD
WriteBitmaskRecord(
    PM_BITMASK1     Bits,
    BitmaskContext *Ctxt
)
{
    DWORD     Error;
    JET_ERR   JetError;
    JET_SESID SesId;
    DWORD     BitsSize;

    DhcpAssert( NULL != Ctxt );


    //
    // No work to do
    //

    if( 0 == Bits->nSet ) {
        // Update the index in the context
	Ctxt->Offset += Bits->Size;
	return ERROR_SUCCESS;
    }

    DhcpPrint(( DEBUG_TRACE, "flusing range: %x, offset=%d size = %d nset = %d\n", 
                Ctxt->RangeStart, Ctxt->Offset, Bits->Size, Bits->nSet ));

    SesId = DhcpGlobalJetServerSession;

    
    JetError = JetPrepareUpdate( SesId, BitmaskTbl, JET_prepInsert );
    Error = DhcpMapJetError( JetError, "Flushbitmask:JetPrepareUpdate" );
    if ( ERROR_SUCCESS != Error ) {
        return Error;
    }

    do {
	JetError = JetSetColumn( SesId, BitmaskTbl, 
				 BitmaskTable[ BITMASK_RANGE ].ColHandle,
				 &Ctxt->RangeStart, sizeof( DWORD ),
				 0, NULL );
	if ( JET_errSuccess != JetError ) {
	    break;
	}

	BitsSize = ((( Bits->Size / 8 ) * 8 ) < Bits->Size )
	    ? (( Bits->Size / 8 ) + 1 )
	    : (Bits->Size / 8 );
	JetError = JetSetColumn( SesId, BitmaskTbl, 
				 BitmaskTable[ BITMASK_BITMAP ].ColHandle,
				 Bits->Mask, BitsSize,
				 0, NULL );
	if ( JET_errSuccess != JetError ) {
	    break;
	}

	JetError = JetSetColumn( SesId, BitmaskTbl, 
				 BitmaskTable[ BITMASK_OFFSET ].ColHandle,
				 &Ctxt->Offset, sizeof( DWORD ),
				 0, NULL );
	if ( JET_errSuccess != JetError ) {
	    break;
	}

	JetError = JetSetColumn( SesId, BitmaskTbl, 
				 BitmaskTable[ BITMASK_NUMBITS ].ColHandle,
				 &Bits->Size, sizeof( DWORD ),
				 0, NULL );
    } while ( 0 );
    if ( JET_errSuccess == JetError ) {
	JetError = JetUpdate( SesId, BitmaskTbl, NULL, 0, NULL );
	Error = DhcpMapJetError( JetError, "Bitmask : JetUpdate" );
    }
    else {
	Error = DhcpMapJetError( JetError, "Bitmask : JetUpdate" );

	// Ignore this error;
    	JetError = JetPrepareUpdate( SesId, BitmaskTbl, JET_prepCancel );
    } // else 
    
    if ( ERROR_SUCCESS != Error ) {
        return Error;
    }

    // Update the index in the context
    Ctxt->Offset += Bits->Size;

    DhcpPrint(( DEBUG_TRACE, 
                "Bitmap flushed: Range: %x, Offset: %x, Size: %x, JetError = %d\n",
                Ctxt->RangeStart, Ctxt->Offset, Bits->Size, JetError ));

    return Error;

} // WriteBitmaskRecord()


DWORD
FlushBitmaskRanges(
    IN  PM_RANGE               Range,
    IN  PM_SUBNET              Subnet
)
{
    DWORD          Error;
    PM_BITMASK     BitMask;
    BitmaskContext Ctxt;
    
    BitMask = Range->BitMask;

    Ctxt.RangeStart = Range->Start;
    Ctxt.Offset = 0;

    DhcpPrint(( DEBUG_TRACE, "Flushing range: %x -> %x\n",
                Range->Start, Range->End ));

    Error = FlushLoop(&BitMask->Array, WriteBitmaskRecord, &Ctxt );

    // Check if all the bitmaps have been dumped.
    DhcpAssert( Range->Start + Ctxt.Offset >= Range->End );

    return Error;
} // FlushBitmaskRanges()

DWORD
FlushBitmaskSubnets(
   IN  PM_SUBNET  Subnet,
   IN  LPVOID     Context
)
{
    ULONG                          Error;

    Error = FlushLoop(&Subnet->Ranges, FlushBitmaskRanges, Subnet);
    Require( ERROR_SUCCESS == Error );

    return Error;
} // FlushBitmaskSubnets()

DWORD
FlushServerBitmasks()
{
    PM_SERVER Server;
    DWORD     Error;

    Server = DhcpGetCurrentServer();

    Error = FlushLoop( &Server->Subnets, FlushBitmaskSubnets, NULL );
    Require( ERROR_SUCCESS == Error );

    Error = FlushLoop( &Server->MScopes, FlushBitmaskSubnets, NULL );
    Require( ERROR_SUCCESS == Error );

    return Error;
    
} // FlushSubnetBitmasks()


// 
// Write the bitmasks to the database
//

DWORD
FlushBitmaskToDatabase( VOID )
{
    DWORD Error;

    // Delete the table

    Error = DeleteBitmaskTable( DhcpGlobalJetServerSession,
                                DhcpGlobalDatabaseHandle );
    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint(( DEBUG_ERRORS, "Error deleting bitmask table : %x\n", Error ));
        return Error;
    }

    // Create the table again
    Error = CreateBitmaskTable(DhcpGlobalJetServerSession,
                               DhcpGlobalDatabaseHandle );
    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint(( DEBUG_ERRORS, "Error creating bitmask table : %x\n", Error ));
        return Error;
    }
    
    //
    // Begin a transcation
    //
    Error = DhcpJetBeginTransaction();
    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }

    // Dump the bitmask
    Error = FlushServerBitmasks();
    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint(( DEBUG_ERRORS, "Error flushing the bitmasks : %x\n", Error ));
        return Error;
    }

    // Mark the clean flag in the registry if successful
    if ( ERROR_SUCCESS == Error ) {
	Error = MarkBitmaskCleanFlag( 1 );
    } // if 
    
    // 
    // End the tranaction
    // 
    Error = DhcpJetCommitTransaction();
    DhcpPrint(( DEBUG_JET, "Commited bitmap table ... Error = %d\n",
            Error ));
    if ( ERROR_SUCCESS != Error ) {
        return Error;
    }

    Error = CloseBitmaskTable( DhcpGlobalJetServerSession );
    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint(( DEBUG_ERRORS, "Error closing bitmask table : %x\n", Error ));
    }

    return Error;
} // FlushBitmaskToDatabase()


DWORD 
ReadBitmaskRecord(
    JET_SESID SesId,
    JET_DBID  DbId,
    PDB_BITMASK pbm
)
{
    DWORD   Error, i;
    JET_ERR JetError;
    DWORD   Actual;

    do {
        // Get Range 
        JetError = JetRetrieveColumn( SesId, BitmaskTbl,
                                      BitmaskTable[ BITMASK_RANGE ].ColHandle,
                                      &pbm->RangeStart,
                                      sizeof( pbm->RangeStart ), 
                                      &Actual, JET_bitRetrieveCopy, NULL );
        Error = DhcpMapJetError( JetError, "Bitmask Range" );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }
        DhcpAssert( Actual == sizeof( pbm->RangeStart ));

        // Get Offset 
        JetError = JetRetrieveColumn( SesId, BitmaskTbl,
                                      BitmaskTable[ BITMASK_OFFSET ].ColHandle,
                                      &pbm->Offset,
                                      sizeof( pbm->Offset ), 
                                      &Actual, JET_bitRetrieveCopy, NULL );
        Error = DhcpMapJetError( JetError, "Bitmask Range" );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }
        DhcpAssert( Actual == sizeof( pbm->Offset ));

        // Get Numbits 
        JetError = JetRetrieveColumn( SesId, BitmaskTbl,
                                      BitmaskTable[ BITMASK_NUMBITS ].ColHandle,
                                      &pbm->NumBits,
                                      sizeof( pbm->NumBits ), 
                                      &Actual, JET_bitRetrieveCopy, NULL );
        Error = DhcpMapJetError( JetError, "Bitmask Range" );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }
        DhcpAssert( Actual == sizeof( pbm->NumBits ));

        // Get Bitmask 
        JetError = JetRetrieveColumn( SesId, BitmaskTbl,
                                      BitmaskTable[ BITMASK_BITMAP ].ColHandle,
                                      pbm->Buf, pbm->BufSize,
                                      &Actual, JET_bitRetrieveCopy, NULL );
        Error = DhcpMapJetError( JetError, "Bitmask Range" );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }
        DhcpAssert( Actual < pbm->BufSize );
        pbm->Size = Actual;

    } while ( FALSE );
            
    return Error;
} // ReadBitmaskRecord()

PM_RANGE
GetRange( 
    DWORD RangeStart
)
{
    ARRAY_LOCATION sLoc, rLoc;
    PM_SUBNET      pSubnet;
    PM_SERVER      pServer;
    PM_RANGE       pRange;	
    ARRAY          *pSubnets;
    DWORD          Error, rError;

    pServer = DhcpGetCurrentServer();
    
    if ( CLASSD_HOST_ADDR( RangeStart )) {
        pSubnets = &pServer->MScopes;
    }
    else {
        pSubnets = &pServer->Subnets;
    }

    Error = MemArrayInitLoc( pSubnets, &sLoc );

    // Loop through the subnets
    while ( ERROR_SUCCESS == Error ) {
        Error = MemArrayGetElement( pSubnets, &sLoc, &pSubnet );
        if ( ERROR_SUCCESS == Error ) {
            // Loop through the ranges
            rError = MemArrayInitLoc( &pSubnet->Ranges, &rLoc );
            while ( ERROR_SUCCESS == rError ) {
                rError = MemArrayGetElement( &pSubnet->Ranges, &rLoc, &pRange );
                if (( ERROR_SUCCESS == rError ) &&
                    ( RangeStart == pRange->Start )) {
                    return pRange;
                } // if
                rError = MemArrayNextLoc( &pSubnet->Ranges, &rLoc );
            } // while
        } // if

        Error = MemArrayNextLoc( pSubnets, &sLoc );
    } // while 
    

    return NULL;

} // GetRange()

DWORD
UpdateBitmask(
    PDB_BITMASK pbm
)
{
    DWORD      Error;
    PM_RANGE   pRange;
    
    DWORD      nBitsSet, i;
    BOOL       bWasSet;

    static DWORD  Masks[] = {
	0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80
    };


    DhcpAssert( NULL != pbm );

    // Get the range for this record

    pRange = GetRange( pbm->RangeStart );
    DhcpAssert( NULL != pRange ); // Should never get this in a clean db.
    if ( NULL == pRange ) {
        return ERROR_OBJECT_NOT_FOUND;
    } // if 

    // Sanity check
    DhcpAssert(( pbm->RangeStart + pbm->Offset + pbm->NumBits - 1 ) <=
               pRange->End );

    // 
    // Now set the bits in the bitmap
    //
    for ( i = 0; i < pbm->NumBits; i++ ) {
	if ( pbm->Buf[ i / 8 ] & Masks[ i % 8 ] ) {
	    Error = MemBitSetOrClear( pRange->BitMask, pbm->Offset + i,
				      TRUE, &bWasSet );
	    Require( ERROR_SUCCESS == Error );
	} // if 
    } // for 

    return ERROR_SUCCESS;

} // UpdateBitmask()

DWORD
ReadBitmasksFromDb(
    JET_SESID SesId,
    JET_DBID  DbId
)
{
    DWORD      Error;
    JET_ERR    JetError;
    DB_BITMASK bm;
    BYTE       Buf[ MAX_BIT1SIZE / sizeof( BYTE ) + 1 ];


    Error = OpenBitmaskTable( SesId, DbId );

    // if this table cannot be read, rebuild the bitmasks 
    // from the lease database.
    if ( ERROR_SUCCESS != Error ) {
        return Error;
    }

    bm.Buf = Buf;
    bm.BufSize = sizeof( Buf );

    DhcpPrint(( DEBUG_TRACE, "Okay, starting to read the bitmasks \n" ));

    JetError = JetMove( SesId, BitmaskTbl, JET_MoveFirst, 0 );
    Error = DhcpMapJetError( JetError, "Bitmask move first" );
    do {
        if ( ERROR_SUCCESS != Error ) {
            break;
        }
    
	
        Error = ReadBitmaskRecord( SesId, DbId, &bm );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }

        if ( bm.Size > 0) {
            DhcpPrint(( DEBUG_TRACE,
                        "Bitmask: Range : %x, Offset: %d, Numbits: %d, Size %d\n",
                        bm.RangeStart, bm.Offset, bm.NumBits, bm.Size ));
        }
        Error = UpdateBitmask( &bm );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }

        JetError = JetMove( SesId, BitmaskTbl, JET_MoveNext, 0 );
        Error = DhcpMapJetError( JetError, "Bitmask Move next " );
        
    } while ( ERROR_SUCCESS == Error );

    if ( ERROR_NO_MORE_ITEMS == Error ) {
        Error = ERROR_SUCCESS;
    }
    
    // Ignore errors while closing the table
    CloseBitmaskTable( SesId );

    return Error;
} // ReadBitmasksFromDb()

DWORD
UpdateBitmaskForIpAddr(
    DWORD IpAddr
)
{
    
    DWORD          Error;
    PM_SUBNET      pSubnet = NULL;
    PM_RANGE       pRange = NULL;
    PM_EXCL        pExcl = NULL;
    PM_RESERVATION pResrv = NULL;
    BOOL           bWasSet;

    Error = MemServerGetAddressInfo( DhcpGetCurrentServer(),
				     IpAddr, &pSubnet, &pRange,
				     &pExcl, &pResrv );
    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }
#ifdef DBG
    DhcpAssert( NULL != pSubnet );
    if ( NULL == pRange ) {
        DhcpAssert( NULL != pResrv );
    }
#endif

    // update the bitmask only when the IP address falls in the range.
    // Ignore reservations that are out of scope.
    if ( NULL != pRange ) {
        Error = MemBitSetOrClear( pRange->BitMask,
                                  IpAddr - pRange->Start,
                                  TRUE, &bWasSet );
    } // if

    Require( ERROR_SUCCESS == Error );

    return Error;

} // UpdateBitmaskForIpAddr()

DWORD
UpdateBitmasksFromDb( 
   JET_SESID   SesId,
   JET_DBID    DbId
)
{
    DWORD    Error;
    JET_ERR  JetError;
    DWORD    IpAddr, IpAddrSize;
    
    // The lease table is already open, don't close it.

    JetError = JetMove( SesId, DhcpGlobalClientTableHandle,
			JET_MoveFirst, 0 );
    Error = DhcpMapJetError( JetError, "LeaseTable move first" );
    do {
	if ( ERROR_SUCCESS != Error ) {
	    break;
	}

	// 
	// Any entry that is in the lease database will be added
	// to the bitmask, even the doomed ones. When the lease record
	// is actually deleted, it will update the bitmask.
	//

	IpAddrSize = sizeof( IpAddr );
	Error = DhcpJetGetValue( ClientTable[ IPADDRESS_INDEX ].ColHandle,
				 &IpAddr, &IpAddrSize );
	if ( ERROR_SUCCESS != Error ) {
	    break;
	}
	DhcpAssert( sizeof( IpAddr ) == IpAddrSize );

	Error = UpdateBitmaskForIpAddr( IpAddr );
	if ( ERROR_SUCCESS != Error ) {
	    break;
	}

	JetError = JetMove( SesId, DhcpGlobalClientTableHandle, 
			    JET_MoveNext, 0 );
	Error = DhcpMapJetError( JetError, "lease table move next" );

    } while ( ERROR_SUCCESS == Error );

    if ( ERROR_NO_MORE_ITEMS == Error ){
	Error = ERROR_SUCCESS;
    }

    return Error;

} // UpdateBitmasksFromDb()

DWORD
ReadServerBitmasks( void )
{
    DWORD Error, Error2;
    BYTE  CleanFlag = 0;
    
    // 
    // Do we have a clean database?
    //

    Error = GetBitmaskCleanFlag( &CleanFlag );
    if ( ERROR_SUCCESS == Error ) {
        // Get rid of the clean flag
	
	Error = MarkBitmaskCleanFlag( 0 );
    } // if 


    if (( ERROR_SUCCESS == Error ) &&
        ( CleanFlag )) {
        // Update the bitmasks from the database.

        DhcpPrint(( DEBUG_TRACE, "Reading bitmaks from the database\n" ));
        
        Error = ReadBitmasksFromDb( DhcpGlobalJetServerSession,
                                    DhcpGlobalDatabaseHandle );

        if ( ERROR_SUCCESS == Error ) {
            return Error;
        }
    } // if

    
    DhcpPrint(( DEBUG_TRACE, "constructing the bitmasks...\n" ));

    // We do not have a clean database.
    // construct the bitmap by reading the lease info.
    
    UpdateBitmasksFromDb( DhcpGlobalJetServerSession,
			  DhcpGlobalDatabaseHandle );

    return ERROR_SUCCESS;
} // ReadServerBitmasks()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debugging macros for the DHCP server.

Author:

    Madan Appiah  (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:


--*/

#include "dhcppch.h"

#if DBG
VOID
DhcpOpenDebugFile(
    IN BOOL ReopenFlag
    )
/*++

Routine Description:

    Opens or re-opens the debug file

Arguments:

    ReopenFlag - TRUE to indicate the debug file is to be closed, renamed,
        and recreated.

Return Value:

    None

--*/

{
    WCHAR LogFileName[500];
    WCHAR BakFileName[500];
    DWORD FileAttributes;
    DWORD PathLength;
    DWORD WinError;

    //
    // Close the handle to the debug file, if it is currently open
    //

    EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
    if ( DhcpGlobalDebugFileHandle != NULL ) {
        CloseHandle( DhcpGlobalDebugFileHandle );
        DhcpGlobalDebugFileHandle = NULL;
    }
    LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );

    //
    // make debug directory path first, if it is not made before.
    //
    if( DhcpGlobalDebugSharePath == NULL ) {

        if ( !GetWindowsDirectoryW(
                LogFileName,
                sizeof(LogFileName)/sizeof(WCHAR) ) ) {
            DhcpPrint((DEBUG_ERRORS, "Window Directory Path can't be "
                        "retrieved, %lu.\n", GetLastError() ));
            return;
        }

        //
        // check debug path length.
        //

        PathLength = wcslen(LogFileName) * sizeof(WCHAR) +
                        sizeof(DEBUG_DIR) + sizeof(WCHAR);

        if( (PathLength + sizeof(DEBUG_FILE) > sizeof(LogFileName) )  ||
            (PathLength + sizeof(DEBUG_BAK_FILE) > sizeof(BakFileName) ) ) {

            DhcpPrint((DEBUG_ERRORS, "Debug directory path (%ws) length is too long.\n",
                        LogFileName));
            goto ErrorReturn;
        }

        wcscat(LogFileName, DEBUG_DIR);

        //
        // copy debug directory name to global var.
        //

        DhcpGlobalDebugSharePath =
            DhcpAllocateMemory( (wcslen(LogFileName) + 1) * sizeof(WCHAR) );

        if( DhcpGlobalDebugSharePath == NULL ) {
            DhcpPrint((DEBUG_ERRORS, "Can't allocated memory for debug share "
                                    "(%ws).\n", LogFileName));
            goto ErrorReturn;
        }

        wcscpy(DhcpGlobalDebugSharePath, LogFileName);
    }
    else {
        wcscpy(LogFileName, DhcpGlobalDebugSharePath);
    }

    //
    // Check this path exists.
    //

    FileAttributes = GetFileAttributesW( LogFileName );

    if( FileAttributes == 0xFFFFFFFF ) {

        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {

            //
            // Create debug directory.
            //

            if( !CreateDirectoryW( LogFileName, NULL) ) {
                DhcpPrint((DEBUG_ERRORS, "Can't create Debug directory (%ws), "
                            "%lu.\n", LogFileName, GetLastError() ));
                goto ErrorReturn;
            }

        }
        else {
            DhcpPrint((DEBUG_ERRORS, "Can't Get File attributes(%ws), "
                        "%lu.\n", LogFileName, WinError ));
            goto ErrorReturn;
        }
    }
    else {

        //
        // if this is not a directory.
        //

        if(!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            DhcpPrint((DEBUG_ERRORS, "Debug directory path (%ws) exists "
                         "as file.\n", LogFileName));
            goto ErrorReturn;
        }
    }

    //
    // Create the name of the old and new log file names
    //

    (VOID) wcscpy( BakFileName, LogFileName );
    (VOID) wcscat( LogFileName, DEBUG_FILE );
    (VOID) wcscat( BakFileName, DEBUG_BAK_FILE );


    //
    // If this is a re-open,
    //  delete the backup file,
    //  rename the current file to the backup file.
    //

    if ( ReopenFlag ) {

        if ( !DeleteFile( BakFileName ) ) {
            WinError = GetLastError();
            if ( WinError != ERROR_FILE_NOT_FOUND ) {
                DhcpPrint((DEBUG_ERRORS,
                    "Cannot delete %ws (%ld)\n",
                    BakFileName,
                    WinError ));
                DhcpPrint((DEBUG_ERRORS, "   Try to re-open the file.\n"));
                ReopenFlag = FALSE;     // Don't truncate the file
            }
        }
    }

    if ( ReopenFlag ) {
        if ( !MoveFile( LogFileName, BakFileName ) ) {
            DhcpPrint((DEBUG_ERRORS,
                    "Cannot rename %ws to %ws (%ld)\n",
                    LogFileName,
                    BakFileName,
                    GetLastError() ));
            DhcpPrint((DEBUG_ERRORS,
                "   Try to re-open the file.\n"));
            ReopenFlag = FALSE;     // Don't truncate the file
        }
    }

    //
    // Open the file.
    //

    EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
    DhcpGlobalDebugFileHandle = CreateFileW( LogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  ReopenFlag ? CREATE_ALWAYS : OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );


    if ( DhcpGlobalDebugFileHandle == NULL 
	 || INVALID_HANDLE_VALUE == DhcpGlobalDebugFileHandle ) {
        DhcpPrint((DEBUG_ERRORS,  "cannot open %ws ,\n",
                    LogFileName ));
        LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );
        goto ErrorReturn;
    } else {
        // Position the log file at the end
        (VOID) SetFilePointer( DhcpGlobalDebugFileHandle,
                               0,
                               NULL,
                               FILE_END );
    }

    LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );
    return;

ErrorReturn:
    DhcpPrint((DEBUG_ERRORS,
            "   Debug output will be written to debug terminal.\n"));
    return;
}


VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    LPSTR Text;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (DhcpGlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // If the log file is getting huge,
        //  truncate it.
        //

        if ( DhcpGlobalDebugFileHandle != NULL &&
             !TruncateLogFileInProgress ) {

            //
            // Only check every 50 lines,
            //

            LineCount++;
            if ( LineCount >= 50 ) {
                DWORD FileSize;
                LineCount = 0;

                //
                // Is the log file too big?
                //

                FileSize = GetFileSize( DhcpGlobalDebugFileHandle, NULL );
                if ( FileSize == 0xFFFFFFFF ) {
                    (void) DbgPrint( "[DhcpServer] Cannot GetFileSize %ld\n",
                                     GetLastError() );
                } else if ( FileSize > DhcpGlobalDebugFileMaxSize ) {
                    TruncateLogFileInProgress = TRUE;
                    LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );
                    DhcpOpenDebugFile( TRUE );
                    DhcpPrint(( DEBUG_MISC,
                              "Logfile truncated because it was larger than %ld bytes\n",
                              DhcpGlobalDebugFileMaxSize ));
                    EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
                    TruncateLogFileInProgress = FALSE;
                }

            }
        }

        //
        // If we're writing to the debug terminal,
        //  indicate this is a DHCP server's message.
        //

        if ( DhcpGlobalDebugFileHandle == NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[DhcpServer] " );
        }

        //
        // Put the timestamp at the begining of the line.
        //
        IF_DEBUG( TIMESTAMP ) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }


	//
	// Print the Thread ID
	//
	length += ( ULONG ) sprintf( &OutputBuffer[ length ],
		                     "[%x] ", GetCurrentThreadId());
        //
        // Indicate the type of message on the line
        //
        switch (DebugFlag) {
        case DEBUG_ADDRESS:
            Text = "ADDRESS";
            break;

        case DEBUG_CLIENT:
            Text = "CLIENT";
            break;

        case DEBUG_PARAMETERS:
            Text = "PARAMETERS";
            break;

        case DEBUG_OPTIONS:
            Text = "OPTIONS";
            break;

        case DEBUG_ERRORS:
            Text = "ERRORS";
            break;

        case DEBUG_STOC:
            Text = "STOC";
            break;

        case DEBUG_INIT:
            Text = "INIT";
            break;

        case DEBUG_SCAVENGER:
            Text = "SCAVENGER";
            break;

        case DEBUG_TIMESTAMP:
            Text = "TIMESTAMP";
            break;

        case DEBUG_APIS:
            Text = "APIS";
            break;

        case DEBUG_REGISTRY:
            Text = "REGISTRY";
            break;

        case DEBUG_JET:
            Text = "JET";
            break;

        case DEBUG_THREADPOOL:
            Text = "THREADPOOL";
            break;

        case DEBUG_AUDITLOG:
            Text = "AUDITLOG" ;
            break;

        case DEBUG_MISC:
            Text = "MISC";
            break;

        case DEBUG_MESSAGE:
            Text = "MESSAGE";
            break;

        case DEBUG_API_VERBOSE:
            Text = "API_VERBOSE";
            break;

        case DEBUG_DNS :
            Text = "DNS" ;
            break;

        case DEBUG_MSTOC:
            Text = "MSTOC";
            break;
            
        case DEBUG_ROGUE:
            Text = "ROGUE" ;
            break;

        case DEBUG_PNP:
            Text = "PNP";
            break;
            
        case DEBUG_PERF:
            Text = "PERF";
            break;

        case DEBUG_PING:
            Text = "PING";
            break;

        case DEBUG_THREAD:
            Text = "THREAD";
            break;
            
        case DEBUG_TRACE :
            Text = "TRACE";
            break;

        case DEBUG_LOG_IN_FILE:
            Text = "LOG_IN_FILE";
            break;

        default:
            Text = NULL;
            break;
        }

        if ( Text != NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[%s] ", Text );
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);


    //
    // Output to the debug terminal,
    //  if the log file isn't open or we are asked to do so.
    //

    if ( (DhcpGlobalDebugFileHandle == NULL) ||
         !(DhcpGlobalDebugFlag & DEBUG_LOG_IN_FILE) ) {

        (void) DbgPrint( (PCH) OutputBuffer);

    //
    // Write the debug info to the log file.
    //

    } else {
        if ( !WriteFile( DhcpGlobalDebugFileHandle,
                         OutputBuffer,
                         lstrlenA( OutputBuffer ),
                         &BytesWritten,
                         NULL ) ) {
            (void) DbgPrint( (PCH) OutputBuffer);
        }

    }

    LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );

}

//
// for debug builds these symbols will be redefined to dbg_calloc
// and dbg_free.
//

#undef MIDL_user_allocate
#undef MIDL_user_free


void __RPC_FAR * __RPC_USER MIDL_user_allocate( size_t n )
/*++

Routine Description:
    Allocate memory for use by the RPC stubs.
    .
Arguments:

    n   - # of bytes to allocate .

Return Value:

    Success - A pointer to the new block
    Failure - NULL

--*/
{
    return DhcpAllocateMemory( n );
}

void __RPC_USER MIDL_user_free( void __RPC_FAR *pv )
/*++

Routine Description:

    Free memory allocated by MIDL_user_allocate.

    .
Arguments:

    pv - A pointer to the block.

Return Value:

    void

    .

--*/

{
    DhcpFreeMemory( pv );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dbconfig.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dbconfig.c

Abstract:

    implements the routines needed to read and write
    configuration information to the database.

--*/

#include <dhcppch.h>

#include "uniqid.h"

#define DBCFG_INDEX_STR "DbcfgIndex"
#define DBCFG_TYPE_STR "DbcfgType"
#define DBCFG_SUBTYPE_STR "DbcfgSubType"
#define DBCFG_FLAGS_STR "DbcfgFlags"

#define DBCFG_NAME_STR "DbcfgName"
#define DBCFG_COMMENT_STR "DbcfgComment"
#define DBCFG_INFO_STR "DbcfgInfo"

//
// class definitions
//

//
// Option definitions
//

#define DBCFG_OPTION_ID_STR "DbcfgOptionId"
#define DBCFG_OPTION_USER_STR "DbcfgUserClass"
#define DBCFG_OPTION_VENDOR_STR "DbcfgVendorClass"

//
// Subnet defintions
//

#define DBCFG_IPADDRESS_STR "DbcfgIpAddress"
#define DBCFG_MASK_STR "DbcfgMaskStr"
#define DBCFG_SUPERSCOPE_STR "DbcfgSuperScopeName"

//
// Mscope definitions
//

#define DBCFG_MSCOPEID_STR "DbcfgMscopeId"
#define DBCFG_MSCOPELANG_STR "DbcfgMscopeLang"
#define DBCFG_MSCOPETTL_STR "DbcfgMscopeTtl"
#define DBCFG_MSCOPE_EXPIRY_STR "DbcfgMscopeExpiry"

//
// Range definitions
//

#define DBCFG_RANGE_START_STR "DbcfgRangeStart"
#define DBCFG_RANGE_END_STR "DbcfgRangeEnd"
#define DBCFG_RANGE_MASK_STR "DbcfgRangeMask"
#define DBCFG_BOOTP_ALLOCATED_STR "DbcfgBootpAlloc"
#define DBCFG_BOOTP_MAX_STR "DbcfgBootMax"

//
// Reservation definitions
//

//
// types of records
//

enum {
    DBCFG_CLASS,
    DBCFG_OPT,
    DBCFG_OPTDEF,
    DBCFG_SCOPE,
    DBCFG_MSCOPE,
    DBCFG_RANGE,
    DBCFG_EXCL,
    DBCFG_RESERVATION
};

TABLE_INFO DbcfgTable[] = {
    DBCFG_INDEX_STR,0, JET_coltypLong,
    DBCFG_TYPE_STR,0, JET_coltypLong,
    DBCFG_SUBTYPE_STR,0, JET_coltypLong,
    DBCFG_FLAGS_STR,0, JET_coltypLong,
    DBCFG_NAME_STR,0, JET_coltypLongBinary,
    DBCFG_COMMENT_STR,0, JET_coltypLongBinary,
    DBCFG_INFO_STR,0, JET_coltypLongBinary,
    DBCFG_OPTION_ID_STR,0, JET_coltypLong,
    DBCFG_OPTION_USER_STR,0, JET_coltypLongBinary,
    DBCFG_OPTION_VENDOR_STR,0, JET_coltypLongBinary,
    DBCFG_IPADDRESS_STR,0, JET_coltypLong,
    DBCFG_MASK_STR,0, JET_coltypLong,
    DBCFG_SUPERSCOPE_STR,0, JET_coltypLongBinary,
    DBCFG_MSCOPEID_STR,0, JET_coltypLong,
    DBCFG_MSCOPELANG_STR,0, JET_coltypLongBinary,
    DBCFG_MSCOPETTL_STR,0, JET_coltypLong,
    DBCFG_MSCOPE_EXPIRY_STR,0, JET_coltypCurrency,
    DBCFG_RANGE_START_STR,0, JET_coltypLong,
    DBCFG_RANGE_END_STR,0, JET_coltypLong,
    DBCFG_RANGE_MASK_STR,0, JET_coltypLong,
    DBCFG_BOOTP_ALLOCATED_STR,0, JET_coltypLong,
    DBCFG_BOOTP_MAX_STR,0, JET_coltypLong,
};

enum {
    DBCFG_INDEX,
    DBCFG_TYPE,
    DBCFG_SUBTYPE,
    DBCFG_FLAGS,
    DBCFG_NAME,
    DBCFG_COMMENT,
    DBCFG_INFO,
    DBCFG_OPTION_ID,
    DBCFG_OPTION_USER,
    DBCFG_OPTION_VENDOR,
    DBCFG_IPADDRESS,
    DBCFG_MASK,
    DBCFG_SUPERSCOPE,
    DBCFG_MSCOPEID,
    DBCFG_MSCOPELANG,
    DBCFG_MSCOPETTL,
    DBCFG_MSCOPE_EXPIRY,
    DBCFG_RANGE_START,
    DBCFG_RANGE_END,
    DBCFG_RANGE_MASK,
    DBCFG_BOOTP_ALLOCATED,
    DBCFG_BOOTP_MAX,
    DBCFG_LAST_COLUMN
};

JET_TABLEID DbcfgTbl;

#define DBCFG_TABLE_NAME "DbcfgTable"


typedef struct _DB_CREATE_CONTEXT {
    IN JET_SESID SesId;
    IN ULONG Index;
    IN PM_SERVER Server;
    
    IN PM_CLASSDEF UserClass, VendorClass;
    IN PM_SUBNET Subnet;
    IN PM_RESERVATION Reservation;

    //
    // If all of the below are zero, then it is a complete
    // wildcard. If fClassChanged or fOptionsChanged changed,
    // then only classes or options are changed.  In case of the
    // latter, AffectedSubnet or AffectedMscope or
    // AffectedReservation indicates only the specific options got
    // affected (if none specified, "global" is assumed).
    // If no options/class changed, but subnet/mscope/reservation
    // specified, only those are affected.
    //
    IN BOOL fClassChanged;
    IN BOOL fOptionsChanged;
    IN DWORD AffectedSubnet;
    IN DWORD AffectedMscope;
    IN DWORD AffectedReservation;
} DB_CREATE_CONTEXT, *PDB_CREATE_CONTEXT;

typedef struct _DBCFG_ENTRY {
    ULONG Bitmasks; // indicates which of the fields below is present
    ULONG Index;
    ULONG Type, SubType, Flags;
    LPWSTR Name, Comment;
    PUCHAR Info;
    ULONG OptionId;
    LPWSTR UserClass, VendorClass;
    ULONG IpAddress, Mask;
    LPWSTR SuperScope;
    ULONG MscopeId;
    LPWSTR MscopeLang;
    ULONG Ttl;
    FILETIME ExpiryTime;
    ULONG RangeStart, RangeEnd, RangeMask;
    ULONG BootpAllocated, BootpMax;

    ULONG InfoSize;
    PVOID Buf;
} DBCFG_ENTRY, *PDBCFG_ENTRY;

typedef struct _DBCFG_MAP {
    DWORD Offset, Size;
} DBCFG_MAP;

DBCFG_MAP EntryMap[] = {
    FIELD_OFFSET(DBCFG_ENTRY,Index), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Type), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,SubType), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Flags), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Name), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Comment), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Info), 0,
    FIELD_OFFSET(DBCFG_ENTRY,OptionId), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,UserClass), 0,
    FIELD_OFFSET(DBCFG_ENTRY,VendorClass), 0,
    FIELD_OFFSET(DBCFG_ENTRY,IpAddress), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Mask), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,SuperScope), 0,
    FIELD_OFFSET(DBCFG_ENTRY,MscopeId), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,MscopeLang), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Ttl), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,ExpiryTime), sizeof(FILETIME),
    FIELD_OFFSET(DBCFG_ENTRY,RangeStart), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,RangeEnd), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,RangeMask), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,BootpAllocated), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,BootpMax), sizeof(DWORD)
};

DWORD Bitmasks[] = {
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000,
    0x010000, 0x020000, 0x040000, 0x080000, 0x100000, 0x200000,
    0x400000, 0x80000,
};


LPSTR EntryTypes[] = {
    "Class", "Opt", "OptDef", "Scope", "Mscope", "Range",
    "Excl", "Reservation", "Unknown1", "Unknown2", "Unknown3"
};
    

#ifdef DBG

VOID
DumpEntry(
   PDBCFG_ENTRY Entry 
   ) 
{
    WCHAR Buf[ 256 ], Buf2[ 256 ];
    DWORD BufLen, i;

    DhcpAssert( NULL != Entry );

    Buf[ 0 ] = L'\0';
    i = DBCFG_INDEX;

    DhcpPrint(( DEBUG_TRACE, "Entry---> Bitmask = %x\n", Entry->Bitmasks ));

    if ( Entry->Bitmasks & Bitmasks[ DBCFG_INDEX ] ) {
	wsprintf( Buf2, L"Index : %d ", Entry->Index );
	wcscat( Buf, Buf2 );
    }

    if (Entry->Bitmasks & Bitmasks[ DBCFG_TYPE ]) {
	wsprintf( Buf2, L"Type : %d ", Entry->Type );
        wcscat( Buf, Buf2 );
    } 

    if (Entry->Bitmasks & Bitmasks[ DBCFG_SUBTYPE ]) {
	wsprintf( Buf2, L"SubType : %d ", Entry->SubType );
        wcscat( Buf, Buf2 );
    } 

    if (Entry->Bitmasks & Bitmasks[ DBCFG_FLAGS ]) {
	wsprintf( Buf2, L"Flags : %d ", Entry->Flags );
        wcscat( Buf, Buf2 );
    } 

    DhcpPrint(( DEBUG_TRACE, "\t%ws\n", Buf ));
    Buf[ 0 ] = L'\0';

    if ( Entry->Bitmasks & Bitmasks[ DBCFG_NAME ] ) {
	wsprintf( Buf2, L"Name : %ws ", Entry->Name );
	wcscat( Buf, Buf2 );
    }

    if (Entry->Bitmasks & Bitmasks[ DBCFG_COMMENT ]) {
	wsprintf( Buf2, L"Comment : %ws ", Entry->Comment );
        wcscat( Buf, Buf2 );
    } 

    if (Entry->Bitmasks & Bitmasks[ DBCFG_INFO ]) {
	wsprintf( Buf2, L"InfoSize : %d ", Entry->InfoSize );
        wcscat( Buf, Buf2 );
    } 

    DhcpPrint(( DEBUG_TRACE, "\t%ws\n", Buf ));
    Buf[ 0 ] = L'\0';

    if (Entry->Bitmasks & Bitmasks[ DBCFG_OPTION_ID ]) {
	wsprintf( Buf2, L"OptionId : %d ", Entry->OptionId );
        wcscat( Buf, Buf2 );
    }

    if ( Entry->Bitmasks & Bitmasks[ DBCFG_OPTION_USER ] ) {
	wsprintf( Buf2, L"UserClass : %ws ", Entry->UserClass );
	wcscat( Buf, Buf2 );
    }

    if (Entry->Bitmasks & Bitmasks[ DBCFG_OPTION_VENDOR ]) {
	wsprintf( Buf2, L"VendorClass : %ws ", Entry->VendorClass );
        wcscat( Buf, Buf2 );
    } 

    if (Entry->Bitmasks & Bitmasks[ DBCFG_IPADDRESS ]) {
	wsprintf( Buf2, L"IpAddress : %x ", Entry->IpAddress );
        wcscat( Buf, Buf2 );
    } 

    if (Entry->Bitmasks & Bitmasks[ DBCFG_MASK ]) {
	wsprintf( Buf2, L"Mask : %x ", Entry->Mask );
        wcscat( Buf, Buf2 );
    } 

    DhcpPrint(( DEBUG_TRACE, "\t%ws\n", Buf ));
    Buf[ 0 ] = L'\0';

    if ( Entry->Bitmasks & Bitmasks[ DBCFG_SUPERSCOPE ] ) {
	wsprintf( Buf2, L"SuperScope : %ws ", Entry->SuperScope );
	wcscat( Buf, Buf2 );
    }

    if (Entry->Bitmasks & Bitmasks[ DBCFG_MSCOPEID ]) {
	wsprintf( Buf2, L"MscopeId : %d ", Entry->MscopeId );
        wcscat( Buf, Buf2 );
    } 

    if (Entry->Bitmasks & Bitmasks[ DBCFG_MSCOPELANG ]) {
	wsprintf( Buf2, L"MscopeLang : %ws ", Entry->MscopeLang );
        wcscat( Buf, Buf2 );
    } 

    if (Entry->Bitmasks & Bitmasks[ DBCFG_MSCOPETTL ]) {
	wsprintf( Buf2, L"MscopeTtl : %d ", Entry->Ttl );
        wcscat( Buf, Buf2 );
    }

    DhcpPrint(( DEBUG_TRACE, "\t%ws\n", Buf ));
    Buf[ 0 ] = L'\0';

    if (Entry->Bitmasks & Bitmasks[ DBCFG_RANGE_START ]) {
	wsprintf( Buf2, L"RangeStart : %x ", Entry->RangeStart );
        wcscat( Buf, Buf2 );
    }

    if (Entry->Bitmasks & Bitmasks[ DBCFG_RANGE_END ]) {
	wsprintf( Buf2, L"RangeEnd : %x ", Entry->RangeEnd );
        wcscat( Buf, Buf2 );
    }

    if (Entry->Bitmasks & Bitmasks[ DBCFG_RANGE_MASK ]) {
	wsprintf( Buf2, L"RangeMask : %x ", Entry->RangeMask );
        wcscat( Buf, Buf2 );
    }

    DhcpPrint(( DEBUG_TRACE, "\t%ws\n", Buf ));
    Buf[ 0 ] = L'\0';

    if ( Entry->Bitmasks & Bitmasks[ DBCFG_BOOTP_ALLOCATED ] ) {
	wsprintf( Buf2, L"BootpAllocated : %ld ", Entry->BootpAllocated );
	wcscat( Buf, Buf2 );
    }

    if (Entry->Bitmasks & Bitmasks[ DBCFG_BOOTP_MAX ]) {
	wsprintf( Buf2, L"BootpMax : %d ", Entry->BootpMax );
        wcscat( Buf, Buf2 );
    }

    DhcpPrint(( DEBUG_TRACE, "\t%ws\n", Buf ));
    Buf[ 0 ] = L'\0';


} // DumpEntry()

#else 
#define DumpEntry(x) 
#endif  // DBG


DWORD 
FindRecord(
    IN JET_SESID  SesId,
    IN ULONG UniqId
)

{
    DWORD Error, JetError;

    JetError = JetMakeKey( SesId, DbcfgTbl, &UniqId,
			   sizeof( UniqId ), JET_bitNewKey );
    Error = DhcpMapJetError( JetError, "CheckUniqId:JetMakeKey" );
    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }

    JetError = JetSeek( SesId, DbcfgTbl, JET_bitSeekEQ );
    return DhcpMapJetError( JetError, "FindRecord: JetSeek" );
} // FindRecord()

DWORD 
MakeUniqId(
    IN OUT PULONG pIndex,
    IN JET_SESID   SesId
    )
{
    DWORD Error = ERROR_SUCCESS;
    
    // *pIndex contains Server->LastUniqId
    (*pIndex)++;
    while ( ERROR_SUCCESS == Error ) {
	// Make sure this is unique
	Error = FindRecord( SesId, *pIndex );
	if ( ERROR_SUCCESS == Error ) {
	    // this index is not unique, try another one.
	    (*pIndex)++;
	    if ( INVALID_UNIQ_ID == *pIndex ) {
		(*pIndex)++; // wraps are okay
	    }
	} // if
	else {
	    Error = ERROR_SUCCESS;
	    break;
	}
    } // while
    
    return Error;
} // MakeUniqId()

DWORD
DhcpOpenConfigTable(
    IN JET_SESID SessId,
    IN JET_DBID DbId
    )
{

    JET_ERR JetError;
    DWORD Error = NO_ERROR;
    JET_COLUMNDEF   ColumnDef;
    CHAR *IndexKey;
    DWORD i;

    for( i = 0; i < DBCFG_LAST_COLUMN ; i ++ ) {
        DbcfgTable[i].ColHandle = 0;
    }

    DbcfgTbl = 0;
    
    //
    // Try to create Table.
    //

    JetError = JetOpenTable(
        SessId, DbId, DBCFG_TABLE_NAME, NULL, 0, 0, &DbcfgTbl );

    //
    // if table exist, read the table columns; else create it
    //
    
    if ( JET_errSuccess == JetError) {

        for ( i = 0; i < DBCFG_LAST_COLUMN; i++ ) {

            JetError = JetGetTableColumnInfo(
                SessId, DbcfgTbl, DbcfgTable[i].ColName, 
                &ColumnDef, sizeof(ColumnDef), 0 );

            Error = DhcpMapJetError( JetError, "C:GetTableColumnInfo" );
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            DbcfgTable[i].ColHandle  = ColumnDef.columnid;
        }

    } else if ( JET_errObjectNotFound != JetError ) {
        
        Error = DhcpMapJetError( JetError, "C:OpenTable" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;
        
    } else {

        JetError = JetCreateTable(
            SessId, DbId, DBCFG_TABLE_NAME, DB_TABLE_SIZE,
            DB_TABLE_DENSITY, &DbcfgTbl );

        Error = DhcpMapJetError( JetError, "C:CreateTAble" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        //
        // Now create the columns as well
        //

        ColumnDef.cbStruct  = sizeof(ColumnDef);
        ColumnDef.columnid  = 0;
        ColumnDef.wCountry  = 1;
        ColumnDef.langid    = DB_LANGID;
        ColumnDef.cp        = DB_CP;
        ColumnDef.wCollate  = 0;
        ColumnDef.cbMax     = 0;
        ColumnDef.grbit     = 0;

        for ( i = 0; i < DBCFG_LAST_COLUMN; i++ ) {

            ColumnDef.coltyp   = DbcfgTable[i].ColType;

            JetError = JetAddColumn(
                SessId, DbcfgTbl, DbcfgTable[i].ColName, &ColumnDef,
                NULL, 0, &DbcfgTable[i].ColHandle );

            Error = DhcpMapJetError( JetError, "C:AddColumn" );
            if( Error != ERROR_SUCCESS ) goto Cleanup;
        }

        //
        // Now create the index
        //

        IndexKey =  "+" DBCFG_INDEX_STR "\0";

        JetError = JetCreateIndex(
            SessId, DbcfgTbl, DBCFG_INDEX_STR,
            JET_bitIndexPrimary | JET_bitIndexUnique, 
            // ?? JET_bitIndexClustered will degrade frequent
            // update response time.
            IndexKey, strlen(IndexKey) + 2, 50 );

        Error = DhcpMapJetError( JetError, "C:CreateIndex" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

    }

  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_JET, "Initializing config table: %ld.\n", Error ));

        for( i = 0; i < DBCFG_LAST_COLUMN ; i ++ ) {
            DbcfgTable[i].ColHandle = 0;
        }

        DbcfgTbl = 0;

    } else {

        DhcpPrint(( DEBUG_JET, "Initialized config table\n" ));
    }

    return Error;
} // DhcpOpenConfigTable();

DWORD
ReadDbEntryEx(
    IN JET_SESID SesId,
    IN PDBCFG_ENTRY Entry
    );


DWORD
CreateDbEntry(
    IN JET_SESID SesId,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD Error, Size, i;
    JET_ERR JetError;
    LPVOID Data;

    LOCK_DATABASE();
    // Create a unique Id for this entry 
    Error = MakeUniqId( &Entry->Index, SesId );

    if ( NO_ERROR != Error ) {
	return Error;
    }

    DhcpPrint(( DEBUG_MISC, "Creating entry for : type : %d, %s, index = %d ",
		Entry->Type, EntryTypes[ Entry->Type ], Entry->Index ));

    // Index entry is now valid
    Entry->Bitmasks |= Bitmasks[ DBCFG_INDEX ];
    //
    // First begin a transaction to keep the changes atomic.
    //

    JetError = JetBeginTransaction( SesId );
    Error = DhcpMapJetError( JetError, "C:JetBeginTransaction");
    if( NO_ERROR != Error ) return Error;

    JetError = JetPrepareUpdate(
        SesId, DbcfgTbl, JET_prepInsert );
    Error = DhcpMapJetError( JetError, "C:JetPrepareUpdate");
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetPrepareUpdate: %ld\n", Error ));
        goto Cleanup;
    }

    for( i = 0; i < DBCFG_LAST_COLUMN; i ++ ) {
        if( (Entry->Bitmasks & Bitmasks[i]) == 0 ) {
            continue;
        }

        Size = EntryMap[i].Size;
        Data = EntryMap[i].Offset + (LPBYTE)Entry;

        if( i == DBCFG_INFO ) {
            Data = *(PUCHAR *)Data;

            if( NULL != Data ) Size = Entry->InfoSize;

        } else if( 0 == Size ) {
            //
            // Calculate the size of the string
            //
            Data = *(LPWSTR *)Data;

            if( NULL != Data ) Size = sizeof(WCHAR)*( 1 + wcslen( Data ));
        } // else if

        if( 0 == Size ) continue;

        JetError = JetSetColumn( SesId, DbcfgTbl,
				 DbcfgTable[i].ColHandle, Data, Size,
            0, NULL );

        Error = DhcpMapJetError( JetError, "C:JetSetColumn");
        if( NO_ERROR != Error ) {
            DhcpPrint((
                DEBUG_ERRORS, "JetSetColumn(%s):%ld\n",
                DbcfgTable[i].ColName, Error ));
            goto Cleanup;
        }
    } // for

    if ( NO_ERROR == Error ) {
	JetError = JetUpdate( SesId, DbcfgTbl, NULL, 0, NULL );
	Error = DhcpMapJetError( JetError, "C:CommitUpdate" );
    } // if

 Cleanup:

    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetUpdate: %ld\n", Error ));
        JetError = JetRollback( SesId, 0 );
        ASSERT( 0 == JetError );
    } else {
        JetError = JetCommitTransaction(
            SesId, JET_bitCommitLazyFlush );
        Error = DhcpMapJetError(
            JetError, "C:JetCommitTransaction" );
    }

    UNLOCK_DATABASE();
    DhcpPrint(( DEBUG_MISC, " Error = %d\n", Error ));
    return Error;
} // CreateDbEntry()

DWORD
CreateClassEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN PM_CLASSDEF Class
    )
{
    DBCFG_ENTRY Entry;
    DWORD       Error;

    //
    // IsVendor, Type, Name, Comment, nBytes, ActualBytes
    //

    if ( INVALID_UNIQ_ID != Class->UniqId ) {
	// no need to create
	return ERROR_SUCCESS;
    }

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_TYPE] | Bitmasks[DBCFG_SUBTYPE] |
        Bitmasks[DBCFG_FLAGS] | Bitmasks[DBCFG_SUBTYPE] |
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] |
        Bitmasks[DBCFG_INFO] ); 

    Entry.Type = DBCFG_CLASS;

    Entry.Flags = Class->IsVendor;
    Entry.SubType = Class->Type;
    Entry.Name = Class->Name;
    Entry.Comment = Class->Comment;
    Entry.Info = Class->ActualBytes;
    Entry.InfoSize = Class->nBytes;

    Entry.Index = Ctxt->Server->LastUniqId;
    Error = CreateDbEntry( SesId, &Entry );

    Class->UniqId = Entry.Index;
    Ctxt->Server->LastUniqId = Entry.Index;

    return Error;
} // CreateClassEntry();

DWORD
CreateOptDefEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN PM_OPTDEF OptDef,
    IN PM_CLASSDEF UserClass,
    IN PM_CLASSDEF VendorClass
    )
{
    DBCFG_ENTRY Entry;
    DWORD       Error;

    //
    // OptId, Type, OptName, OptComment, OptVal, OptValLen,
    // User, Vendor
    //

    if ( INVALID_UNIQ_ID != OptDef->UniqId ) {
	// no need to create
	return ERROR_SUCCESS;
    }

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
	Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] | Bitmasks[DBCFG_OPTION_ID] |
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] |
        Bitmasks[DBCFG_INFO] | Bitmasks[DBCFG_OPTION_USER] |
        Bitmasks[DBCFG_OPTION_VENDOR] );  

    Entry.Type = DBCFG_OPTDEF;

    Entry.OptionId = OptDef->OptId;
    Entry.SubType = OptDef->Type;
    Entry.Name = OptDef->OptName;
    Entry.Comment = OptDef->OptComment;
    Entry.Info = OptDef->OptVal;
    Entry.InfoSize = OptDef->OptValLen;
    if( UserClass) Entry.UserClass = UserClass->Name;
    if( VendorClass) Entry.VendorClass = VendorClass->Name;
    Entry.Index = Ctxt->Server->LastUniqId;
    
    Error =  CreateDbEntry( SesId, &Entry );
    Ctxt->Server->LastUniqId = Entry.Index;
    OptDef->UniqId = Entry.Index;
    return Error;
} // CreateOptDefEntry()

DWORD
CreateOptionEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN PM_OPTION Option,
    IN PM_CLASSDEF UserClass,
    IN PM_CLASSDEF VendorClass,
    IN PM_SUBNET Subnet,
    IN PM_RESERVATION Reservation
    )
{
    DBCFG_ENTRY Entry;
    DWORD       Error;
    
    //
    // OptId, Len, Val, User, Vendor
    //

    if ( INVALID_UNIQ_ID != Option->UniqId ) {
	// no need to create
	return ERROR_SUCCESS;
    }


    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_OPTION_ID] | Bitmasks[DBCFG_INFO] |
        Bitmasks[DBCFG_OPTION_USER] |
        Bitmasks[DBCFG_OPTION_VENDOR] ); 

    if( Reservation ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Reservation->Address;
    } else if( Subnet && Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else if( Subnet && !Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Type = DBCFG_OPT;

    Entry.OptionId = Option->OptId;
    Entry.Info = Option->Val;
    Entry.InfoSize = Option->Len;
    if( UserClass) Entry.UserClass = UserClass->Name;
    if( VendorClass) Entry.VendorClass = VendorClass->Name;
    Entry.Index = Ctxt->Server->LastUniqId;

    Error =  CreateDbEntry( SesId, &Entry );
    Ctxt->Server->LastUniqId = Entry.Index;
    Option->UniqId = Entry.Index;

    return NO_ERROR;
} // CreateOptionEntry()
    
DWORD
CreateScopeEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN PM_SUBNET Subnet,
    IN PM_SSCOPE SScope
    )
{
    DBCFG_ENTRY Entry;
    DWORD       Error;
    
    //
    // State, Policy, ExpiryTime, Name, Description
    //
    if ( INVALID_UNIQ_ID != Subnet->UniqId ) {
	// no need to create
	return ERROR_SUCCESS;
    }

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] | Bitmasks[DBCFG_FLAGS] | 
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] );

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= (
            Bitmasks[DBCFG_IPADDRESS] | Bitmasks[DBCFG_MASK] |
            Bitmasks[DBCFG_SUPERSCOPE] );
        Entry.IpAddress = Subnet->Address;
        Entry.Mask = Subnet->Mask;
        if( SScope ) Entry.SuperScope = SScope->Name;
    } else {
        Entry.Bitmasks |= (
            Bitmasks[DBCFG_MSCOPEID] | Bitmasks[DBCFG_MSCOPETTL] |
            Bitmasks[DBCFG_MSCOPELANG] |
            Bitmasks[DBCFG_MSCOPE_EXPIRY] );

        Entry.MscopeId = Subnet->MScopeId;
        Entry.Ttl = Subnet->TTL;
        Entry.MscopeLang = Subnet->LangTag;
        Entry.ExpiryTime = *(FILETIME *)&Subnet->ExpiryTime;
    }
    
    Entry.Type = Subnet->fSubnet ? DBCFG_SCOPE : DBCFG_MSCOPE ;

    Entry.SubType = Subnet->State;
    Entry.Flags = Subnet->Policy;
    Entry.Name = Subnet->Name;
    Entry.Comment = Subnet->Description;
    Entry.Index = Ctxt->Server->LastUniqId;
    
    Error = CreateDbEntry( SesId, &Entry );
    Ctxt->Server->LastUniqId = Entry.Index;
    Subnet->UniqId = Entry.Index;

    return Error;
} // CreateScopeEntry()
    
DWORD
CreateRangeEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN PM_RANGE Range,
    IN PM_SUBNET Subnet
    )
{
    DBCFG_ENTRY Entry;
    DWORD       Error;

    //
    // Start, End, Mask, State, BootpAllocated, MaxBootpAllowed
    //

    if ( INVALID_UNIQ_ID != Range->UniqId ) {
	// no need to create
	return ERROR_SUCCESS;
    }

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[ DBCFG_TYPE ] |
        Bitmasks[DBCFG_RANGE_START] | Bitmasks[DBCFG_RANGE_END] |
        Bitmasks[DBCFG_RANGE_MASK] | Bitmasks[DBCFG_FLAGS] |
        Bitmasks[DBCFG_BOOTP_ALLOCATED] | Bitmasks[DBCFG_BOOTP_MAX] ); 

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Type = DBCFG_RANGE;

    Entry.RangeStart = Range->Start;
    Entry.RangeEnd = Range->End;
    Entry.RangeMask = Range->Mask;
    Entry.Flags = Range->State;
    Entry.BootpAllocated = Range->BootpAllocated;
    Entry.BootpMax = Range->MaxBootpAllowed;
    Entry.Index = Ctxt->Server->LastUniqId;
    
    Error =  CreateDbEntry( SesId, &Entry );
    Range->UniqId = Entry.Index;
    Ctxt->Server->LastUniqId = Entry.Index;

    return Error;
} // CreateRangeEntry()

DWORD
CreateExclEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN PM_EXCL Excl,
    IN PM_SUBNET Subnet
    )
{
    DBCFG_ENTRY Entry;
    DWORD       Error;

    //
    // Start, End
    //

    if ( INVALID_UNIQ_ID != Excl->UniqId ) {
	// no need to create
	return ERROR_SUCCESS;
    }

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_RANGE_START] | Bitmasks[DBCFG_RANGE_END] );

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Type = DBCFG_EXCL;

    Entry.RangeStart = Excl->Start;
    Entry.RangeEnd = Excl->End;
    Entry.Index = Ctxt->Server->LastUniqId;
    
    Error =  CreateDbEntry( SesId, &Entry );
    Excl->UniqId = Entry.Index;
    Ctxt->Server->LastUniqId = Entry.Index;
    return Error;
} // CreateExclEntry()

DWORD
CreateReservationEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN PM_RESERVATION Reservation
    )
{
    DBCFG_ENTRY Entry;
    DWORD       Error;

    //
    // Address, Flags, nBytes, ClientUID
    //

    if ( INVALID_UNIQ_ID != Reservation->UniqId ) {
	// no need to create
	return ERROR_SUCCESS;
    }
    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_IPADDRESS] | Bitmasks[DBCFG_INFO] |
        Bitmasks[DBCFG_FLAGS] );

    Entry.Type = DBCFG_RESERVATION;

    Entry.IpAddress = Reservation->Address;
    Entry.Flags = Reservation->Flags;
    Entry.Info = Reservation->ClientUID;
    Entry.InfoSize = Reservation->nBytes;
    Entry.Index = Ctxt->Server->LastUniqId;
    
    Error = CreateDbEntry( SesId, &Entry );
    Reservation->UniqId = Entry.Index;
    Ctxt->Server->LastUniqId = Entry.Index;    
    return Error;
} // CreateReservationEntry()

DWORD
IterateArrayWithDbCreateRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PARRAY Array,
    IN DWORD (*Routine)(
        IN PDB_CREATE_CONTEXT Ctxt,
        IN PVOID ArrayElement
        )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    PVOID Element;
    
    Error = MemArrayInitLoc( Array, &Loc );
    while( NO_ERROR == Error ) {

        Error = MemArrayGetElement(
            Array, &Loc, &Element );
        ASSERT( NO_ERROR == Error && NULL != Element );

	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}
        Error = Routine( Ctxt, Element );
        if( NO_ERROR != Error ) return Error;

        Error = MemArrayNextLoc( Array, &Loc );
    }

    if( ERROR_FILE_NOT_FOUND == Error ) return NO_ERROR;
    return Error;
} // IterateArrayWithDbCreateRoutine()
    
DWORD
DbCreateClassRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_CLASSDEF Class
    )
{
    if ( INVALID_UNIQ_ID == Class->UniqId ) {
	return CreateClassEntry( Ctxt, Ctxt->SesId, Class );
    }
    return ERROR_SUCCESS;
} // DbCreateClassRoutine()

DWORD
DbCreateOptDefRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTDEF OptDef
    )
{
    if ( INVALID_UNIQ_ID == OptDef->UniqId ) {
	return CreateOptDefEntry( Ctxt, Ctxt->SesId, OptDef,
				  Ctxt->UserClass, Ctxt->VendorClass );
    }
    return ERROR_SUCCESS;
} // DbCreateOptDefRoutine()

DWORD
DbCreateOptClassDefRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTCLASSDEFL_ONE OptClassDef
    )
{
    DWORD Error;
    
    if( 0 == OptClassDef->ClassId ) {
        Ctxt->UserClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptClassDef->ClassId, NULL, 0, NULL,
            &Ctxt->UserClass );
        if( NO_ERROR != Error ) return Error;
    }

    if( 0 == OptClassDef->VendorId ) {
        Ctxt->VendorClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptClassDef->VendorId, NULL, 0, NULL,
            &Ctxt->VendorClass );
        if( NO_ERROR != Error ) return Error;
    }

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &OptClassDef->OptDefList.OptDefArray,
        DbCreateOptDefRoutine );

    return Error;
} // DbCreateOptClassDefRoutine()

DWORD
DbCreateOptionRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTION Option
    )
{
    if ( INVALID_UNIQ_ID == Option->UniqId ) {
	return CreateOptionEntry( Ctxt, Ctxt->SesId, Option, Ctxt->UserClass,
				  Ctxt->VendorClass, Ctxt->Subnet,
				  Ctxt->Reservation );
    }
    return ERROR_SUCCESS;
} // DbCreateOptionRoutine()

DWORD
DbCreateOptListRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_ONECLASS_OPTLIST OptList
    )
{
    DWORD Error;
    
    if( 0 == OptList->ClassId ) {
        Ctxt->UserClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptList->ClassId, NULL, 0, NULL,
            &Ctxt->UserClass );
        if( NO_ERROR != Error ) return Error;
    }

    if( 0 == OptList->VendorId ) {
        Ctxt->VendorClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptList->VendorId, NULL, 0, NULL,
            &Ctxt->VendorClass );
        if( NO_ERROR != Error ) return Error;
    }

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &OptList->OptList, DbCreateOptionRoutine );

    return Error;
}

DWORD
DbCreateRangeRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_RANGE Range
    )
{
    if ( INVALID_UNIQ_ID == Range->UniqId ) {
	return CreateRangeEntry( Ctxt, Ctxt->SesId,
				 Range, Ctxt->Subnet );
    }
    return ERROR_SUCCESS;
} // DbCreateRangeRoutine()

DWORD
DbCreateExclRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_EXCL Excl
    )
{
    if ( INVALID_UNIQ_ID == Excl->UniqId ) {
	return CreateExclEntry( Ctxt, Ctxt->SesId,
				Excl, Ctxt->Subnet );
    }
    return ERROR_SUCCESS;
} // DbCreateExclRoutine()

DWORD
DbCreateReservationRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_RESERVATION Reservation
    )
{
    DWORD Error;
    
    Error = CreateReservationEntry( Ctxt, Ctxt->SesId, Reservation );
    if( NO_ERROR != Error ) return Error;

    Ctxt->Reservation = Reservation;
    
    //
    // Now add the options for this reservation
    //
    
    return IterateArrayWithDbCreateRoutine(
        Ctxt, &Reservation->Options.Array,
        DbCreateOptListRoutine );
} // DbCreateReservationRoutine()

DWORD
DbCreateScopeRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_SUBNET Subnet
    )
{
    PM_SSCOPE SScope = NULL;
    DWORD Error;
    
    if( Subnet->fSubnet && Subnet->SuperScopeId ) {
        Error = MemServerFindSScope(
            Ctxt->Server, Subnet->SuperScopeId, NULL, &SScope );
        if( NO_ERROR != Error ) {
            SScope = NULL;
        }
    }

    if ( INVALID_UNIQ_ID == Subnet->UniqId ) {
	Error = CreateScopeEntry( Ctxt, Ctxt->SesId,
				  Subnet, SScope );
	if( NO_ERROR != Error ) return Error;
    } // if

    //
    // Initialize the two fields that will get used later 
    //
    
    Ctxt->Subnet = Subnet;
    Ctxt->Reservation = NULL;

    //
    // Now add the options for this scope
    //

    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Options.Array,
        DbCreateOptListRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Now add the ranges and exclusions
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Ranges, DbCreateRangeRoutine );
    if( NO_ERROR != Error ) return Error;

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Exclusions, DbCreateExclRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Finally, add the reservations
    //

    return IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Reservations,
        DbCreateReservationRoutine );
} // DbCreateScopeRoutine()


DWORD
DbCreateServerRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_SERVER Server
    )
{
    DWORD Error;
    
    Ctxt->Server = Server;

    //
    // First look through the classes
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->ClassDefs.ClassDefArray,
        DbCreateClassRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Next save the option defs
    //
    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->OptDefs.Array,
        DbCreateOptClassDefRoutine );
    if( NO_ERROR != Error ) return Error;

    // 
    // Next save the options
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->Options.Array,
        DbCreateOptListRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Next save the scopes and mcast scopes
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->Subnets, DbCreateScopeRoutine );
    if( NO_ERROR != Error ) return Error;
    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->MScopes, DbCreateScopeRoutine );
    if( NO_ERROR != Error ) return Error;

    return NO_ERROR;
} // DbCreateServerRoutine()

DWORD
GetNextIndexValue(
    IN OUT PULONG Index,
    IN JET_SESID SesId
    )
{
    DWORD Error, CopiedSize;
    JET_ERR JetError;

    (*Index) = 0;
    
    JetError = JetSetCurrentIndex(
        SesId, DbcfgTbl, NULL );

    Error = DhcpMapJetError( JetError, "C:GetIndex" );
    if( Error != NO_ERROR ) {
        
        DhcpPrint((DEBUG_JET, "JetSetCurrentIndex: %ld\n", Error));
        return Error;
    }

    JetError = JetMove( SesId, DbcfgTbl, JET_MoveLast, 0 );
    Error = DhcpMapJetError( JetError, "C:JetMoveLast");

    if( ERROR_NO_MORE_ITEMS == Error ) return NO_ERROR;
    if( NO_ERROR != Error ) return Error;

    //
    // Read the db entry
    //

    JetError = JetRetrieveColumn(
        SesId, DbcfgTbl, DbcfgTable[DBCFG_INDEX].ColHandle, Index,
        sizeof(*Index), &CopiedSize, 0, NULL );

    ASSERT( NO_ERROR == JetError && CopiedSize == sizeof(*Index));
    Error = DhcpMapJetError( JetError, "C:JetRetrieveIndex");

    return Error;
} // GetNextIndexValue()

DWORD
DeleteRecord(
    IN ULONG UniqId
    )
{
    JET_SESID  SesId;
    JET_ERR    JetError;
    DWORD      Error;


    SesId = DhcpGlobalJetServerSession;

    DhcpPrint(( DEBUG_MISC, "Deleting record: %d ",
		UniqId ));
    LOCK_DATABASE();
    Error = FindRecord( SesId, UniqId );
    DhcpAssert( NO_ERROR == Error );
    JetError = JetDelete( SesId, DbcfgTbl );
    UNLOCK_DATABASE();
    Error = DhcpMapJetError( JetError, "DeleteRecord:JetDelete");
    DhcpPrint(( DEBUG_MISC, "Done\n", Error ));
    return Error;

} // DeleteRecord()

DWORD
DhcpSaveConfigTableEx(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN PM_SERVER Server,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DWORD AffectedSubnet OPTIONAL,
    IN DWORD AffectedMscope OPTIONAL,
    IN DWORD AffectedReservation OPTIONAL
    )
{
    DB_CREATE_CONTEXT Ctxt;
    DWORD Error, Index;
    JET_ERR JetError;
    
    ZeroMemory( &Ctxt, sizeof(Ctxt) );
    Ctxt.SesId = SesId;
    Ctxt.fClassChanged = fClassChanged;
    Ctxt.fOptionsChanged = fOptionsChanged;
    Ctxt.AffectedSubnet = AffectedSubnet;
    Ctxt.AffectedMscope = AffectedMscope;
    Ctxt.AffectedReservation = AffectedReservation;
    
    Error = DbCreateServerRoutine( &Ctxt, Server );
    
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpSaveConfigTable: %ld\n",
                   Error ));
    }

    return Error;
} // DhcpSaveConfigTableEx()

    
DWORD
DhcpSaveConfigTable(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN PM_SERVER Server
    )
{
    return DhcpSaveConfigTableEx(
        SesId, DbId, Server, FALSE, FALSE, 0, 0, 0 );
}

DWORD ReadDbEntry(
    IN JET_SESID    SesId,
    IN PDBCFG_ENTRY Entry,
    IN PVOID        Buffer,
    IN ULONG        BufSize
    )
{

    // 512 bytes should be enough for the column data
    const int COL_MAX_DATA_SIZE = 512;

    // there are 7 var sized entries + 1 for fixed sized fields
    const int NUM_BLOCKS = ( 7 + 1 );

    JET_RETRIEVECOLUMN cols[ DBCFG_LAST_COLUMN ];
    DWORD             i;
    JET_ERR           JetError, Error;
    DWORD             RetVal;
    ULONG             SizeLeft;
    LPBYTE            Ptr;
    LPBYTE            colBuf;

    DhcpAssert( Entry != NULL );
    DhcpAssert(( Buffer != NULL ) &&
	       ( BufSize > 0 ));

    ZeroMemory( Entry, sizeof( *Entry ));

    RetVal = NO_ERROR;
    memset( cols, 0, sizeof( cols ));


    colBuf = DhcpAllocateMemory( NUM_BLOCKS  * COL_MAX_DATA_SIZE );
    if ( NULL == colBuf ) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    
    // Prepare cols for batch retrieve
    Ptr = colBuf;
    for ( i = 0; i < DBCFG_LAST_COLUMN; i++ ) {
	cols[ i ].columnid = DbcfgTable[ i ].ColHandle;

	cols[ i ].pvData = Ptr;
	if ( 0 == EntryMap[ i ].Size ) {
	    cols[ i ].cbData = COL_MAX_DATA_SIZE;
	} 
	else {
	    cols[ i ].cbData = EntryMap[ i ].Size;
	}
	
	Ptr += cols[ i ].cbData;

 	cols[ i ].grbit = JET_bitRetrieveCopy;
	cols[ i ].itagSequence = 1;
    } // for

    Ptr = Buffer;
    SizeLeft = BufSize;
    
    JetError = JetRetrieveColumns( SesId, DbcfgTbl,
				   cols, DBCFG_LAST_COLUMN );
    
    Error = DhcpMapJetError( JetError, "ReadDBEntry:JetRetrieveColumns()" );
    if ( ERROR_NO_MORE_ITEMS == Error ) {
	DhcpFreeMemory( colBuf );
	return Error;
    }

    // Ignore other Jet errors since it returns error if any of the
    // columns are not defined.
    
    for ( i = 0; i < DBCFG_LAST_COLUMN; i++ ) { 
	
	// ignore DBCFG_INFO
	if ( DBCFG_INFO == i ) {
	    continue;
	}
	    
	// if column doesn't exist, continue
	if ( JET_wrnColumnNull == cols[ i ].err ||
	     JET_errColumnNotFound == cols[ i ].err ) {
	    continue;
	}
	    
	    
        if ( cols[ i ].cbActual > SizeLeft ) {
	    RetVal = ERROR_INSUFFICIENT_BUFFER;
	    break;
	}
	
	// copy variable sized data into buffer and non var data into
	// Entry. 
	if ( JET_errSuccess == cols[ i ].err ) {
	    
	    if ( 0 != EntryMap[ i ].Size ) {
		DhcpAssert( cols[ i ].cbActual == EntryMap[ i ].Size );
		memcpy(( LPBYTE ) Entry + EntryMap[ i ].Offset,
		       cols[ i ].pvData, cols[ i ].cbActual );
	    }
	    else { // var sized data
		// Point the corresponding field in Entry to data
		// to be copied.
		memcpy(( LPBYTE ) Entry + EntryMap[ i ].Offset,
		       &Ptr, sizeof( Ptr ));
		    
		// Copy data into buffer.
		memcpy( Ptr, cols[ i ].pvData, cols[ i ].cbActual );
	    } // else
		
	} // if
	else if ( JET_wrnBufferTruncated == cols[ i ].err ) {
	    // If the buffer was too small, read it directly into the 
	    // output buffer
		
	    JetError = JetRetrieveColumn( SesId, DbcfgTbl, cols[ i ].columnid, Ptr,
					  SizeLeft, &cols[ i ].cbActual, 0, NULL );
  	    Error =  DhcpMapJetError( JetError, "C:ReadDbEntry" );

	    // The only failure expected is the insufficient buffer since all
	    // other parameters are okay since we got a buffer truncated error in 
	    // the call to JetRetrieveColumns()
	    if ( NO_ERROR != Error ) {
		RetVal = ERROR_INSUFFICIENT_BUFFER;
		break;
	    }
	}  // else if

	// Indicate that the column was retrieved successfully
	Entry->Bitmasks |= Bitmasks[ i ];

	Ptr += cols[ i ].cbActual;
	SizeLeft -= cols[ i ].cbActual;
		    
    } // for
	
	
    // index is copied at the end
	
    if ( ERROR_INSUFFICIENT_BUFFER != RetVal ) {
	if ( JET_wrnColumnNull == cols[ DBCFG_INFO ].err ||
	     JET_errColumnNotFound == cols[ DBCFG_INFO ].err ) {
	    RetVal = NO_ERROR;
	}
	else if (( SizeLeft >= cols[ DBCFG_INFO ].cbActual ) &&
		 (( JET_errSuccess == cols[ DBCFG_INFO ].err) ||
		  ( JET_wrnBufferTruncated == cols[ DBCFG_INFO ].err ))) {

	    if ( JET_errSuccess == cols[ DBCFG_INFO ].err ) {
		memcpy( Ptr, cols[ DBCFG_INFO ].pvData,
			cols[ DBCFG_INFO ].cbActual );
	    }
	    else {
		JetError = JetRetrieveColumn( SesId, DbcfgTbl,
					      cols[ DBCFG_INFO ].columnid,
					      Ptr, SizeLeft,
					      &cols[ DBCFG_INFO ].cbActual,
					      0, NULL );
		Error = DhcpMapJetError( JetError, "C:ReadDbEntry" );
		
		if ( NO_ERROR != Error ) {
		    RetVal = ERROR_INSUFFICIENT_BUFFER;
		}
	    } // else
	    if ( RetVal == NO_ERROR ) {
		Entry->Info = Ptr;
		Entry->InfoSize = cols[ DBCFG_INFO ].cbActual;
		Entry->Bitmasks |= Bitmasks[ DBCFG_INFO ];
	    }
	} // else if
	else {
	    RetVal = ERROR_INSUFFICIENT_BUFFER;
	}
	
    } // if 

    // clean up the allocated space
    
    if ( NULL != colBuf ) {
	DhcpFreeMemory( colBuf );
    }
    
    return RetVal;
} // ReadDbEntry()

//
// Read an entry from the database
// 
DWORD
ReadDbEntryEx(
    IN JET_SESID SesId,
    IN PDBCFG_ENTRY Entry
    )
{
    PVOID Buffer;
    ULONG BufSize;
    DWORD Error;

    Buffer = NULL;
    BufSize = 512;
    
    do {
        if( NULL != Buffer ) DhcpFreeMemory(Buffer);

        BufSize *= 2;
        Buffer = DhcpAllocateMemory( BufSize );
        if( NULL == Buffer ) return ERROR_NOT_ENOUGH_MEMORY;
        
        Error = ReadDbEntry(SesId, Entry, Buffer, BufSize);

    } while( ERROR_INSUFFICIENT_BUFFER == Error );

    if( !(Entry->Bitmasks & Bitmasks[DBCFG_INDEX]) ||
        !(Entry->Bitmasks & Bitmasks[DBCFG_TYPE]) ) {
        if( NO_ERROR == Error ) {
            ASSERT( FALSE );
            Error = ERROR_INTERNAL_ERROR;
        }
    }
    

    if( NO_ERROR != Error ) {
        DhcpFreeMemory( Buffer );
        return Error;
    }

    Entry->Buf = Buffer;

    DumpEntry( Entry );
    return NO_ERROR;
} // ReadDbEntryEx()

//
// Add a db entry to the in-memory datastructures
//

DWORD
AddDbEntry(
    IN PM_SERVER Server,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD UserId, VendorId, SScopeId, Error;
    PM_SUBNET Subnet;
    PM_OPTCLASS OptClass;
    PM_OPTION Option, DelOpt;
    PM_RANGE DelRange;
    PM_EXCL DelExcl;
    PM_RESERVATION Reservation;
    PM_CLASSDEF ClassDef;
    PM_SSCOPE SScope;
    ULONG  UniqId;
    
    Subnet = NULL;
    OptClass = NULL;
    Option = DelOpt = NULL;
    Reservation = NULL;
    DelRange = NULL;
    DelExcl = NULL;
    UserId = 0;
    VendorId = 0;
    SScopeId = 0;
    
    if( Entry->UserClass ) {
        Error = MemServerGetClassDef(
            Server, 0, Entry->UserClass, 0, NULL, &ClassDef );
        if( NO_ERROR != Error ) return Error;

        ASSERT( ClassDef->IsVendor == FALSE );
        UserId = ClassDef->ClassId;
    }

    if( Entry->VendorClass ) {
        Error = MemServerGetClassDef(
            Server, 0, Entry->VendorClass, 0, NULL, &ClassDef );
        if( NO_ERROR != Error ) return Error;

        ASSERT( ClassDef->IsVendor == TRUE);
        VendorId = ClassDef->ClassId;
    }

    if( Entry->SuperScope ) {
        Error = MemServerFindSScope(
            Server, INVALID_SSCOPE_ID, Entry->SuperScope, &SScope );
        if( NO_ERROR == Error ) {
            SScopeId = SScope->SScopeId;
        } else if( ERROR_FILE_NOT_FOUND != Error ) {
            return Error;
        } else {
            Error = MemSScopeInit( &SScope, 0, Entry->SuperScope );
            if( NO_ERROR != Error ) return Error;

            Error = MemServerAddSScope( Server, SScope );
            if( NO_ERROR != Error ) {
                MemSScopeCleanup( SScope );
                return Error;
            }
            SScopeId = SScope->SScopeId;
        }
    } // if
    

    switch( Entry->Type ) {
    case DBCFG_CLASS :
        //
        // Flags = IsVendor, SubType =Type, Info = ActualBytes
        //

        return MemServerAddClassDef(
            Server, MemNewClassId(), Entry->Flags, Entry->Name,
            Entry->Comment, Entry->InfoSize, Entry->Info, Entry->Index );

    case DBCFG_OPTDEF :
        //
        // OptionId = OptId, SubType = Type, Info = OptVal
        //

        return MemServerAddOptDef(
            Server, UserId, VendorId, Entry->OptionId,
            Entry->Name, Entry->Comment, Entry->SubType,
            Entry->Info, Entry->InfoSize, Entry->Index );

    case DBCFG_OPT:
        //
        // OptionId = OptId, Info = Val
        // If this is a reservation option, address is set to
        // reserved client address. If this is a subnet option,
        // address is set to subnet address. If this is a mscope
        // option, scopeid is set to mscope scopeid.  If it is a
        // global option, neither address not scopeid is set.
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_MSCOPEID] ) {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
            if( NO_ERROR != Error ) return Error;

            OptClass = &Subnet->Options;
        } else if( 0 == (Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] )) {
            OptClass = &Server->Options;
        } else {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                &Reservation );
            if ( NO_ERROR != Error ) return Error;

            if (( NULL == Reservation ) &&
                (( Subnet->Address & Entry->IpAddress) != Entry->IpAddress )) {
                // This is a reservation option, but the reservation entry is not yet
                // added to the list. Save it and add it later.
                return ERROR_FILE_NOT_FOUND;
            } // if

            if( NULL != Reservation ) {
                OptClass = &Reservation->Options;
            } else OptClass = &Subnet->Options;
        }

        Error = MemOptInit(
            &Option, Entry->OptionId, Entry->InfoSize,
            Entry->Info );
        if( NO_ERROR != Error ) return Error;

        Error = MemOptClassAddOption(
            OptClass,  Option, UserId, VendorId, &DelOpt, Entry->Index );

        ASSERT( NULL == DelOpt );
        if( NO_ERROR != Error ) MemFree( Option );

        return Error;

    case DBCFG_SCOPE:
        //
        // IpAddress = Address, Mask = Mask, SubType = State,
        // Flags = Policy
        //

        Error = MemSubnetInit(
            &Subnet, Entry->IpAddress, Entry->Mask, Entry->SubType, 
	    SScopeId, Entry->Name, Entry->Comment );
        if( NO_ERROR != Error ) return Error;

        Error = MemServerAddSubnet( Server, Subnet, Entry->Index );
        if( NO_ERROR != Error ) MemSubnetCleanup( Subnet );

        return Error;

    case DBCFG_MSCOPE :
        //
        // MscopeId = MScopeId, Ttl = TTL, MscopeLang = LangTag,
        // ExpiryTime = ExpiryTime, SubType = State, Flags =
        // Policy..
        //

        Error = MemMScopeInit(
            &Subnet, Entry->MscopeId, Entry->SubType,
            Entry->Flags, (BYTE)Entry->Ttl, Entry->Name,
            Entry->Comment, Entry->MscopeLang,
            *(DATE_TIME *)&Entry->ExpiryTime );
        if( NO_ERROR != Error ) return Error;

        Error = MemServerAddMScope( Server, Subnet, Entry->Index );
        if( NO_ERROR != Error ) MemSubnetCleanup( Subnet );

        return Error;

    case DBCFG_RANGE :

        //
        // RangeStart = Start, RangeEnd = End, RangeMask = Mask,
        // Flags = State, BootpAllocated, BootpMax =
        // MaxBootpAllowed... Also, IpAddress or MscopeId
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] ) {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                NULL );
        } else {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
        }
        if( NO_ERROR != Error ) return Error;

        return MemSubnetAddRange(
            Subnet, Entry->RangeStart, Entry->RangeEnd,
            Entry->Flags, Entry->BootpAllocated, Entry->BootpMax,
            &DelRange, Entry->Index );
        
    case DBCFG_EXCL:
        //
        // RangeStart = Start, RangeEnd = End
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] ) {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                NULL );
        } else {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
        }
        if( NO_ERROR != Error ) return Error;

        return MemSubnetAddExcl(
          Subnet, Entry->RangeStart, Entry->RangeEnd, &DelExcl,
	  Entry->Index );

    case DBCFG_RESERVATION :
        //
        // IpAddress = Address, Flags = Flags, Info = ClientUID
        //

        Error = MemServerGetAddressInfo(
            Server, Entry->IpAddress, &Subnet, NULL, NULL, NULL );
        if( NO_ERROR != Error ) return Error;

        Error = MemReserveAdd(
            &Subnet->Reservations, Entry->IpAddress,
            Entry->Flags, Entry->Info, Entry->InfoSize,
	    Entry->Index );

        if ( NO_ERROR != Error ) return Error;

        Error = MemSubnetRequestAddress( Subnet,
                                         Entry -> IpAddress,
                                         TRUE,
                                         FALSE,
                                         NULL,
                                         NULL );

        //
        // if the reservation cant be marked in the mem bitmask
        // correctly, return NO_ERROR. This happens when a reservation
        // is defined outside the defined IP ranges.
        // eg: ip range 10.0.0.1 - 10.0.0.100 with mask 255.255.255.0
        // a resv can be added for ip address 10.0.0.101
        // this is particularly a problem with upgrades.
        //

	Error = NO_ERROR;

        return Error;

    default:

        return ERROR_INTERNAL_ERROR;
    } // switch
} // AddDbEntry()

DWORD
AddDbEntryEx(
    IN PM_SERVER Server,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD Error;
    Error = AddDbEntry( Server, Entry );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS,
                   "Error adding entry[%ld] %s: 0x%lx\n",
                   Entry->Index, EntryTypes[Entry->Type], Error ));
    }
    else {
	DhcpPrint(( DEBUG_TRACE, "Entry added: index = %ld, Type = %s : 0x%lx\n",
		    Entry->Index, EntryTypes[ Entry->Type ], Error ));
    }

    return Error;
} // AddDbEntryEx()

DWORD
ReadDbEntriesInternal(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN OUT PM_SERVER Server
    )
{
    DBCFG_ENTRY Entry;
    PDBCFG_ENTRY pEntry;
    DWORD       Error;
    JET_ERR     JetError;
    ARRAY       Arr;
    ARRAY_LOCATION Loc;
    BOOL        flag;

    JetError = JetSetCurrentIndex(
        SesId, DbcfgTbl, NULL );

    Error = DhcpMapJetError( JetError, "C:SetIndex2" );
    if( Error != NO_ERROR ) {

        DhcpPrint((DEBUG_JET, "JetSetCurrentIndex2: %ld\n", Error));
        return Error;
    }

    JetError = JetMove( SesId, DbcfgTbl, JET_MoveFirst, 0 );
    Error = DhcpMapJetError( JetError, "C:JetMoveFirst2");

    // Make sure we don't get some crazy value for LastUniqId
    // from Entry.Index
    Entry.Index = 0;


    // 
    // The entries need to be added in a certain order. For example, we cannot
    // add a range entry without adding the corresponding scope entry first. 
    // This order is not guaranteed to be preserved if there are changes to the
    // configuration. So, save the failed entries (FILE_NOT_FOUND errors) and
    // add them later.
    //
    Error = MemArrayInit( &Arr );

    while( Error == NO_ERROR ) {

        Error = ReadDbEntryEx( SesId, &Entry );
        if(( NO_ERROR != Error ) &&
	   ( ERROR_NO_MORE_ITEMS != Error )) {
            DhcpPrint((DEBUG_JET, "ReadDbEntryEx: %ld\n", Error ));
            return Error;
        }

	if ( ERROR_NO_MORE_ITEMS == Error ) {
	    break;
	}

	Error = AddDbEntryEx( Server, &Entry );

	if ( ERROR_FILE_NOT_FOUND == Error ) {
	    // could not add the entry at this time. 
	    // save it for adding later
	    pEntry = ( PDBCFG_ENTRY ) DhcpAllocateMemory( sizeof( DBCFG_ENTRY ));
	    if ( NULL == pEntry ) {
		return ERROR_NOT_ENOUGH_MEMORY;
	    }
	    // Memberwise copy is okay
	    *pEntry = Entry;
	    Error = MemArrayAddElement( &Arr, pEntry );
	    if ( ERROR_SUCCESS != Error ) {
		// failure, will result in server shutdown
		MemArrayCleanup( &Arr );
		return Error;
	    }
	} // if
	else {
	    if( NULL != Entry.Buf ) {
		DhcpFreeMemory( Entry.Buf );
	    }
	}

        JetError = JetMove( SesId, DbcfgTbl, JET_MoveNext, 0 );
        Error = DhcpMapJetError( JetError, "C:JetMove2" );
    } // while

    if( ERROR_NO_MORE_ITEMS == Error ) {
	// Update the LastUniqId in server
	Server->LastUniqId = Entry.Index;
	Error = NO_ERROR;
    }

    // Process any saved entries, if any

    DhcpPrint(( DEBUG_TRACE, "******* Adding %d saved entries *******\n",
		MemArraySize( &Arr )));

    Error = MemArrayInitLoc( &Arr, &Loc );
    flag = FALSE;
    while (( ERROR_FILE_NOT_FOUND != Error ) &&
           ( !flag ) &&
	   ( MemArraySize( &Arr ) > 0 )) {
	DhcpAssert( ERROR_SUCCESS == Error );

        flag = TRUE;

        // automatically cleans up Arr if empty
	Error = MemArrayDelElement( &Arr, &Loc, &pEntry );
	DhcpAssert( ERROR_SUCCESS == Error );

        DhcpPrint(( DEBUG_TRACE, "Adding queued entry : " ));
        DumpEntry( pEntry );

	Error = AddDbEntryEx( Server, pEntry );
	if ( ERROR_SUCCESS == Error ) {
	    DhcpAssert(( ERROR_SUCCESS == Error ) &&
		       ( NULL != pEntry ));
            DhcpFreeMemory( pEntry );
            flag = FALSE;
	} // if 
	else {
	    // Add it back to the pool
	    Error = MemArrayAddElement( &Arr, pEntry );
	    if ( ERROR_SUCCESS != Error ) {
		// failure, will result in server shutdown
		MemArrayCleanup( &Arr );
		return Error;
	    }
	} // else
    } // while

    // Check to see if any entries couldn't be added
    if ( 0 < MemArraySize( &Arr )) {

        // Delete all orphoned entries
        Error = MemArrayInitLoc( &Arr, &Loc );
        while ( MemArraySize( &Arr ) > 0 ) {
            Error = MemArrayDelElement( &Arr, &Loc, &pEntry );
            DhcpAssert(( ERROR_SUCCESS == Error ) &&
                       ( NULL != pEntry ));

            Error = DeleteRecord( pEntry->Index );
            DhcpAssert( ERROR_SUCCESS == Error );
            DhcpFreeMemory( pEntry );
        } // while

        // Log an event saying that there were some 
        // orphaned entries and delete them from the
        // database so they won't cause problems later.

        DhcpReportEventW( DHCP_EVENT_SERVER,
                          EVENT_SERVER_ORPHONED_ENTRIES_DELETED,
                          EVENTLOG_ERROR_TYPE,
                          0, 0, NULL, NULL );

    } // if

    if ( ERROR_FILE_NOT_FOUND == Error ) {
	Error = MemArrayCleanup( &Arr );
	Error = NO_ERROR;
    }

    return Error;
} // ReadDbEntriesInternal()


DWORD
ReadDbEntries(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN OUT PM_SERVER Server
    )
{
    DWORD Error;


    Error = ReadDbEntriesInternal( SesId, DbId, Server );
    
    return Error;
}

DWORD
DhcpReadConfigTable(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN OUT PM_SERVER *Server
    )
{
    DWORD Error;
    PM_SERVER ThisServer;
    
    (*Server) = NULL;
    
    Error = DhcpOpenConfigTable( SesId, DbId );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpOpenConfigTable: 0x%lx\n", Error));
        return Error;
    }

    //
    // Check the registry to see if the config is stored in db or
    // not.  If it is stored in registry, this needs to be
    // migrated to the database 
    //

    if( DhcpCheckIfDatabaseUpgraded(TRUE) ) {
        //
        // Registry has not been converted to database format
        //
        Error = DhcpRegistryInitOld();

        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DhcpRegistryInitOld: 0x%lx\n", Error));
            return Error;
        }

        do { 
            Error = DhcpSaveConfigTable(SesId, DbId, DhcpGlobalThisServer);
            
            if( NO_ERROR != Error ) {
                DhcpPrint((DEBUG_ERRORS, "DhcpSaveConfigTable: 0x%lx\n", Error));
                break;
            }

            //
            // Attempt to record the fact that the registry has been
            // copied over before.
            //
            
            Error = DhcpSetRegistryUpgradedToDatabaseStatus();
            if( NO_ERROR != Error ) {
                DhcpPrint((DEBUG_ERRORS,
                           "DhcpSetRegistryUpgradedToDatabaseStatus: 0x%lx",
                           Error));
                break;
            }
            
            //
            // If we successfully converted the registry, we can
            // safely delete the registry configuration key.
            //
            
            Error = DeleteSoftwareRootKey();
            if( NO_ERROR != Error ) {
                DhcpPrint((DEBUG_ERRORS,
                           "DeleteSoftwareRootKey: %ld\n", Error ));
                break;
            }

        } while( 0 );

        MemServerFree( DhcpGlobalThisServer );
        DhcpGlobalThisServer = NULL;

        if( NO_ERROR != Error ) return Error;
    } // if
    
    //
    // If the table already existed, need to read the entries.
    //

    Error = MemServerInit( &ThisServer, -1, 0, 0, NULL, NULL );
    if( NO_ERROR != Error ) return Error;

    Error = ReadDbEntries(SesId, DbId, ThisServer );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "ReadDbEntries: 0x%lx\n", Error ));
        MemServerCleanup( ThisServer );
        return Error;
    }

    (*Server) = ThisServer;
    return NO_ERROR;
} // DhcpReadConfigTable()


DWORD
DhcpReadConfigInfo(
    IN OUT PM_SERVER *Server
    )
{
    return DhcpReadConfigTable(
        DhcpGlobalJetServerSession, DhcpGlobalDatabaseHandle,
        Server );
}

DWORD
DhcpSaveConfigInfo(
    IN OUT PM_SERVER Server,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DWORD AffectedSubnet, OPTIONAL
    IN DWORD AffectedMscope, OPTIONAL
    IN DWORD AffectedReservation OPTIONAL
    )
{
    return DhcpSaveConfigTableEx(
        DhcpGlobalJetServerSession, DhcpGlobalDatabaseHandle,
        Server, fClassChanged, fOptionsChanged, AffectedSubnet,
        AffectedMscope, AffectedReservation );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcpdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpdef.h

Abstract:

    This file contains manifest constants and internal data structures
    for the DHCP server.

Author:

    Madan Appiah  (madana)  10-Sep-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#ifndef DHCPDEF_H
#define DHCPDEF_H


#if DBG
#define STATIC
#else
#define STATIC static
#endif // DBG

//
// useful macros
//

#define WSTRSIZE( wsz ) (( wcslen( wsz ) + 1 ) * sizeof( WCHAR ))
#define STRSIZE( sz ) (( strlen( sz ) + 1 ) * sizeof( char ))

//
// calculates the size of a field
//

#define GET_SIZEOF_FIELD( struct, field ) ( sizeof(((struct*)0)->field))


//
// Constants
//

#define DHCP_SERVER                                    L"DhcpServer"
#define DHCP_SERVER_FULL_NAME                          L"DHCP Server"
#define DHCP_SERVER_MODULE_NAME                        L"dhcpssvc.dll"

#define DHCP_SERVER_MAJOR_VERSION_NUMBER               5
#define DHCP_SERVER_MINOR_VERSION_NUMBER               6

#define DHCP_SAMSRV_SUITENAME                          L"Small Business(Restricted)"

//
// database table and field names.
//

#define IPADDRESS_INDEX                                0
#define HARDWARE_ADDRESS_INDEX                         1
#define STATE_INDEX                                    2
#define MACHINE_INFO_INDEX                             3
#define MACHINE_NAME_INDEX                             4
#define LEASE_TERMINATE_INDEX                          5
#define SUBNET_MASK_INDEX                              6
#define SERVER_IP_ADDRESS_INDEX                        7
#define SERVER_NAME_INDEX                              8
#define CLIENT_TYPE_INDEX                              9
#define MAX_INDEX                                      10

//
// This is the max size of client comment field.
//
#define MACHINE_INFO_SIZE                              JET_cbColumnMost

//
//  All the access DHCP needs to registry keys.
//

#define  DHCP_KEY_ACCESS_VALUE                         (KEY_QUERY_VALUE|KEY_SET_VALUE)
#define  DHCP_KEY_ACCESS_KEY                           (KEY_CREATE_SUB_KEY|KEY_ENUMERATE_SUB_KEYS)
#define  DHCP_KEY_ACCESS                               (DHCP_KEY_ACCESS_KEY|DHCP_KEY_ACCESS_VALUE)

//
// timeout (in seconds) used when we wait to see if there are
// other dhcp servers on the net (SAM case)
//
#define DHCP_ROGUE_INIT_DELTA                          3
#define DHCP_ROGUE_RUNTIME_DELTA_SAM                   5*60

// timeout (in milliseconds) used before retrying search for other DHCP servers
#define DHCP_ROGUE_RUNTIME_DELTA                       5*60*1000

// timeout (in milliseconds) used before retrying search for other DHCP servers
// this is the extended version, with a longer timeout
#define DHCP_ROGUE_RUNTIME_DELTA_LONG                  10*60*1000

// # times we send out a discover packet before deciding no other dhcp exists
#define DHCP_ROGUE_MAXRETRIES_SAM                      4

// # times we send out a DHCPINFORM packets at each attempt
#define DHCP_ROGUE_MAXRETRIES                          3

//
// IP Address states
//

//
// The address has been offered to the client, and the server is waiting
// for a request.
//

#define  ADDRESS_STATE_OFFERED                         0

//
// The address is in use.  This is the normal state for an address
//

#define  ADDRESS_STATE_ACTIVE                          1

//
// The address was offered, but was declined by a client.
//

#define  ADDRESS_STATE_DECLINED                        2

//
// The lease for this address has expired, but the record is maintained
// for extended period in this state.
//

#define  ADDRESS_STATE_DOOM                            3

// DynDns address state bits
// The mask for ignoring the status bits that follow.
#define  ADDRESS_BIT_MASK_IGN                          0xF0

//
// The lease has expired and has been deleted.  But DynDns registration is
// not done yet.  So, at startup time these will be cleaned up.
//
#define  ADDRESS_BIT_DELETED                           0x80

//
// The lease is as it is, but for some reason it has not yet been successfully
// registered with the Dns Server
//
#define  ADDRESS_BIT_UNREGISTERED                      0x40

//
// Both A and PTR records have to be dealt with for this guy.
//
#define  ADDRESS_BIT_BOTH_REC                          0x20

//
// Cleanup records on expiry of lease (i.e. do DNS-de-registrations)
//
#define  ADDRESS_BIT_CLEANUP                           0x10


// GetAddressState would get the actual state, ignoring bits in ADDRESS_BIT_MASK_IGN
// IsAddressDeleted  would tell if the delete bit above is set
// IsAddressUnRegistered would tell if the unregistered bit is set
// Similarly the set functions would set these..

#define  GetAddressState(st)                           ((st)&~ADDRESS_BIT_MASK_IGN)
#define  SetAddressState(st,NewSt)                     ((st) = ((st)&ADDRESS_BIT_MASK_IGN) | ((NewSt)&~ADDRESS_BIT_MASK_IGN))
#define  IsAddressDeleted(st)                          (((st)&ADDRESS_BIT_DELETED)==ADDRESS_BIT_DELETED)
#define  IsAddressUnRegistered(st)                     (((st)&ADDRESS_BIT_UNREGISTERED)==ADDRESS_BIT_UNREGISTERED)
#define  IsUpdateAPTRRequired(st)                      (((st)&ADDRESS_BIT_BOTH_REC)==ADDRESS_BIT_BOTH_REC)
#define  IsAddressCleanupRequired(st)                  (((st)&ADDRESS_BIT_CLEANUP)==ADDRESS_BIT_CLEANUP)
#define  AddressDeleted(st)                            ((st)|ADDRESS_BIT_DELETED)
#define  AddressUnRegistered(st)                       ((st)|ADDRESS_BIT_UNREGISTERED)
#define  AddressUpdateAPTR(st)                         ((st)|ADDRESS_BIT_BOTH_REC)
#define  AddressCleanupRequired(st)                    ((st)|ADDRESS_BIT_CLEANUP)
#define  IS_ADDRESS_STATE_OFFERED(st)                  (GetAddressState(st) == ADDRESS_STATE_OFFERED)
#define  IS_ADDRESS_STATE_DECLINED(st)                 (GetAddressState(st) == ADDRESS_STATE_DECLINED)
#define  IS_ADDRESS_STATE_ACTIVE(st)                   (GetAddressState(st) == ADDRESS_STATE_ACTIVE)
#define  IS_ADDRESS_STATE_DOOMED(st)                   (GetAddressState(st) == ADDRESS_STATE_DOOM)
#define  SetAddressStateOffered(st)                    SetAddressState((st), ADDRESS_STATE_OFFERED)
#define  SetAddressStateDeclined(st)                   SetAddressState((st), ADDRESS_STATE_DECLINED)
#define  SetAddressStateActive(st)                     SetAddressState((st), ADDRESS_STATE_ACTIVE)
#define  SetAddressStateDoomed(st)                     SetAddressState((st), ADDRESS_STATE_DOOM)

#define  DOWN_LEVEL(st)                                AddressUpdateAPTR(st)
#define  IS_DOWN_LEVEL(st)                             IsUpdateAPTRRequired(st)

#if DBG
// the following number is in 100-MICRO-SECONDS;
// for debug reasons, it is currently 15 minutes.
#define  MAX_RETRY_DNS_REGISTRATION_TIME               (( ULONGLONG) (120*60*1000*10))

#else
// Retail builds it is 3.5 hours = 60*2+30 = 120 minutes
#define  MAX_RETRY_DNS_REGISTRATION_TIME               (( ULONGLONG) (24*120*60*1000*10))
#endif


#define  USE_NO_DNS                                    DhcpGlobalUseNoDns

#define  DHCP_DNS_DEFAULT_TTL                          (15*60)  // 15 minutes


// See \nt\private\inc\dhcpapi.h for meanings of these items..

#define DNS_FLAG_ENABLED               0x01
#define DNS_FLAG_UPDATE_DOWNLEVEL      0x02
#define DNS_FLAG_CLEANUP_EXPIRED       0x04
#define DNS_FLAG_UPDATE_BOTH_ALWAYS    0x10

//
// error value for "subnet not found"
//      added by t-cheny for superscope
//

#define DHCP_ERROR_SUBNET_NOT_FOUND                    (DWORD)(-1)

//
// for IP address detection
//

#define DHCP_ICMP_WAIT_TIME                            1000
#define DHCP_ICMP_RCV_BUF_SIZE                         0x2000
#define DHCP_ICMP_SEND_MESSAGE                         "DhcpAddressCheck"


//
// for audit log
//

#define DHCP_IP_LOG_ASSIGN                             10
#define DHCP_IP_LOG_RENEW                              11
#define DHCP_IP_LOG_RELEASE                            12
#define DHCP_IP_LOG_CONFLICT                           13
#define DHCP_IP_LOG_RANGE_FULL                         14
#define DHCP_IP_LOG_NACK                               15
#define DHCP_IP_LOG_DELETED                            16
#define DHCP_IP_LOG_DNS_NOT_DELETED                    17
#define DHCP_IP_LOG_EXPIRED                            18
#define DHCP_IP_LOG_START                               0
#define DHCP_IP_LOG_STOP                                1
#define DHCP_IP_LOG_DISK_SPACE_LOW                      2
#define DHCP_IP_LOG_BOOTP                              20
#define DHCP_IP_LOG_DYNBOOTP                           21
#define DHCP_IP_BOOTP_LOG_RANGE_FULL                   22
#define DHCP_IP_BOOTP_LOG_DELETED                      23
#define DHCP_IP_LOG_SCAVENGER_BEGIN_CLEANUP            24
#define DHCP_IP_LOG_SCAVENGER_STATS                    25

#define DHCP_CB_MAX_LOG_ENTRY                          320

#define DHCP_IP_DDNS_LOG_REQUEST                       30
#define DHCP_IP_DDNS_LOG_FAILED                        31
#define DHCP_IP_DDNS_LOG_SUCCESSFUL                    32

#define DHCP_IP_LOG_ROGUE_BASE                         50
#define DHCP_IP_LOG_ROGUE_FIRST                        DHCP_ROGUE_LOG_COULDNT_SEE_DS


//
// these manifests are used to indicate the level that a
// dhcp option was obtain from
//

#define DHCP_OPTION_LEVEL_GLOBAL                       1
#define DHCP_OPTION_LEVEL_SCOPE                        2
#define DHCP_OPTION_LEVEL_RESERVATION                  3


//
// Timeouts, make sure WAIT_FOR_MESSAGE_TIMEOUT is less than
// THREAD_TERMINATION_TIMEOUT.
//

#define THREAD_TERMINATION_TIMEOUT                     60000    // in msecs. 60 secs
#define WAIT_FOR_MESSAGE_TIMEOUT                       4        // in secs.  4 secs

#define ZERO_TIME                                      0x0      // in secs.

#if DBG // used for testing
#define DHCP_SCAVENGER_INTERVAL                         1*60*1000       // in msecs. 1 mins
#define DHCP_DATABASE_CLEANUP_INTERVAL                  5*60*1000       // in msecs. 5 mins.
#define DEFAULT_BACKUP_INTERVAL                         5*60*1000       // in msecs. 5 mins
#define DHCP_LEASE_EXTENSION                            10*60           // in secs.  10 mins
#define DHCP_SCAVENGE_IP_ADDRESS                        15*60*1000      // in msecs. 15 mins
#define CLOCK_SKEW_ALLOWANCE                            5*60            // in secs,  5 mins
#else
#define DHCP_SCAVENGER_INTERVAL                         1*60*1000       // in msecs. 1 mins
#define DHCP_DATABASE_CLEANUP_INTERVAL                  3*60*60*1000    // in msecs. 3hrs
#define DEFAULT_BACKUP_INTERVAL                         15*60*1000      // in msecs. 15 mins
#define DHCP_LEASE_EXTENSION                            4*60*60         // in secs.  4hrs
#define DHCP_SCAVENGE_IP_ADDRESS                        60*60*1000      // in msecs. 1 hr.
#define CLOCK_SKEW_ALLOWANCE                            30*60           // in secs,  30 mins
#endif

#define DHCP_CLIENT_REQUESTS_EXPIRE                     10*60           // in secs. 10 mins
#define DHCP_MINIMUM_LEASE_DURATION                     60*60           // in secs. 1hr
#define EXTRA_ALLOCATION_TIME                           60*60           // in secs. 1hr
#define MADCAP_OFFER_HOLD                               60              // in secs. 1mins

#define DEFAULT_LOGGING_FLAG                            TRUE
#define DEFAULT_RESTORE_FLAG                            FALSE

#define DEFAULT_AUDIT_LOG_FLAG                          1
#define DEFAULT_AUDIT_LOG_MAX_SIZE                      (4*1024*1024)   // 4 M bytes
#define DEFAULT_DETECT_CONFLICT_RETRIES                 0
#define MAX_DETECT_CONFLICT_RETRIES                     5
#define MIN_DETECT_CONFLICT_RETRIES                     0

#define MAX_THREADS                                     20

//
// maximum buffer size that DHCP API will return.
//

#define DHCP_ENUM_BUFFER_SIZE_LIMIT                     64 * 1024 // 64 K
#define DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN                 1024 // 1 K

//
// The minumum count and percentage of remaining address before we will
// log a warning event that the scope is running low on addresses.
//

#define DHCP_DEFAULT_ALERT_COUNT                        80
#define DHCP_DEFAULT_ALERT_PERCENTAGE                   80

#define DHCP_DEFAULT_ROGUE_LOG_EVENTS_LEVEL             1

//
// message queue length.
//

#define DHCP_RECV_QUEUE_LENGTH                          50
#define DHCP_MAX_PROCESSING_THREADS                     20
#define DHCP_MAX_ACTIVE_THREADS                         15

#define DHCP_ASYNC_PING_TYPE                            1
#define DHCP_SYNC_PING_TYPE                             0
#define DHCP_DEFAULT_PING_TYPE                          1

//
// pre-defined MSFT class..
//

#define DHCP_MSFT_VENDOR_CLASS_PREFIX_SIZE              4
#define DHCP_MSFT_VENDOR_CLASS_PREFIX                   "MSFT"

//
// macros
//

#define EnterCriticalSectionX(X,Y,Z)                     EnterCriticalSection(X)
#define LeaveCriticalSectionX(X,Y,Z)                     LeaveCriticalSection(X)

#define LOCK_INPROGRESS_LIST()                           EnterCriticalSectionX(&DhcpGlobalInProgressCritSect, __LINE__, __FILE__)
#define UNLOCK_INPROGRESS_LIST()                         LeaveCriticalSectionX(&DhcpGlobalInProgressCritSect, __LINE__, __FILE__)

#define LOCK_DATABASE()                                  EnterCriticalSectionX(&DhcpGlobalJetDatabaseCritSect, __LINE__, __FILE__)
#define UNLOCK_DATABASE()                                LeaveCriticalSectionX(&DhcpGlobalJetDatabaseCritSect, __LINE__, __FILE__)

#define LOCK_MEMORY()                                    EnterCriticalSectionX(&DhcpGlobalMemoryCritSect, __LINE__, __FILE__)
#define UNLOCK_MEMORY()                                  LeaveCriticalSectionX(&DhcpGlobalMemoryCritSect, __LINE__, __FILE__)

#define ADD_EXTENSION( _x_, _y_ ) \
    ((DWORD)_x_ + (DWORD)_y_) < ((DWORD)_x_) ? \
    INFINIT_LEASE : ((DWORD)(_x_) + (DWORD)_y_)

//
// Structures
//

#include <dhcprog.h>

//
// structure used while collecting info about neighboring DHCP servers
//
typedef struct _NEIGHBORINFO
{
    DWORD   NextOffset;     // self-relative form
    DWORD   IpAddress;      // ipaddr of the DHCP server responding
    CHAR    DomainName[1];
} NEIGHBORINFO, *PNEIGHBORINFO;

//
// A request context, one per processing thread.
//

typedef struct _DHCP_REQUEST_CONTEXT {
    LPBYTE                         ReceiveBuffer;      //  The buffer where a message comes in
    LPBYTE                         SendBuffer;         //  This is where the message is sent out thru
    DWORD                          ReceiveMessageSize; //  The # of bytes received
    DWORD                          ReceiveBufferSize;  //  The size of the receive buffer..
    DWORD                          SendMessageSize;    //  The # of while sending buffer out
    DHCP_IP_ADDRESS                EndPointIpAddress;  //  The Address of the endpoint.
    DHCP_IP_ADDRESS                EndPointMask;       //  The mask for the interface.
    SOCKET                         EndPointSocket;     //  Socket this was received on.
    struct sockaddr                SourceName;
    DWORD                          SourceNameLength;   //  length of above field
    DWORD                          TimeArrived;        //  Timestamp
    DWORD                          MessageType;        //  what kind of msg is this?
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RANGE                       Range;
    PM_EXCL                        Excl;
    PM_RESERVATION                 Reservation;
    DWORD                          ClassId;
    DWORD                          VendorId;
    BOOL                           fMSFTClient;
    BOOL                           fMadcap;
    LPBYTE                         BinlClassIdentifier;// hack for binl -- need this here..
    DWORD                          BinlClassIdentifierLength;
    BOOL                           fNak;               // Is this a NAK response?
    LPVOID                         pPacket;            // Packet to which this context belongs to
} DHCP_REQUEST_CONTEXT, *LPDHCP_REQUEST_CONTEXT, *PDHCP_REQUEST_CONTEXT;



//
// The pending context remembers information offered in response
// to a DHCP discover.
//

typedef struct _PENDING_CONTEXT {
    LIST_ENTRY       ListEntry;         //  This is used to string it up in a list?
    DHCP_IP_ADDRESS  IpAddress;         //  The remembered ip address etc
    DHCP_IP_ADDRESS  SubnetMask;
    DWORD            LeaseDuration;
    DWORD            T1;
    DWORD            T2;
    LPSTR            MachineName;
    LPBYTE           HardwareAddress;
    DWORD            HardwareAddressLength;
    DATE_TIME        ExpiresAt;         //  Time stamp it so we can clear it when it stales
    DWORD            HashValue;         //  For quick lookups
} PENDING_CONTEXT, *LPPENDING_CONTEXT;


#include <pendingc.h>                                  // pending context structure and functions

//
// DHCP database table info.
//

typedef struct _TABLE_INFO {
    CHAR           * ColName;
    JET_COLUMNID     ColHandle;
    JET_COLTYP       ColType;
} TABLE_INFO, *LPTABLE_INFO;

//
// DHCP timer block.
//

typedef struct _DHCP_TIMER {
    DWORD           *Period;            // in msecs.
    DATE_TIME        LastFiredTime;     // time when last time this timer was fired.
} DHCP_TIMER, *LPDHCP_TIMER;

//
// TCPIP instance table
//
typedef struct _AddressToInstanceMap {
    DWORD            dwIndex;
    DWORD            dwInstance;
    DWORD            dwIPAddress;
} AddressToInstanceMap;


//
// Exported Jet function from database.c
//

DHCP_IP_ADDRESS
DhcpJetGetSubnetMaskFromIpAddress(
    DHCP_IP_ADDRESS IpAddress
);


//
// perfmon defines
//

#define DhcpGlobalNumDiscovers             (PerfStats->dwNumDiscoversReceived)
#define DhcpGlobalNumOffers                (PerfStats->dwNumOffersSent)
#define DhcpGlobalNumRequests              (PerfStats->dwNumRequestsReceived)
#define DhcpGlobalNumInforms               (PerfStats->dwNumInformsReceived)
#define DhcpGlobalNumAcks                  (PerfStats->dwNumAcksSent)
#define DhcpGlobalNumNaks                  (PerfStats->dwNumNacksSent)
#define DhcpGlobalNumDeclines              (PerfStats->dwNumDeclinesReceived)
#define DhcpGlobalNumReleases              (PerfStats->dwNumReleasesReceived)
#define DhcpGlobalNumPacketsReceived       (PerfStats->dwNumPacketsReceived)
#define DhcpGlobalNumPacketsDuplicate      (PerfStats->dwNumPacketsDuplicate)
#define DhcpGlobalNumPacketsExpired        (PerfStats->dwNumPacketsExpired)
#define DhcpGlobalNumPacketsProcessed      (PerfStats->dwNumPacketsProcessed)
#define DhcpGlobalNumPacketsInPingQueue    (PerfStats->dwNumPacketsInPingQueue)
#define DhcpGlobalNumPacketsInActiveQueue  (PerfStats->dwNumPacketsInActiveQueue)
#define DhcpGlobalNumMilliSecondsProcessed (PerfStats->dwNumMilliSecondsProcessed)

//
// Default class IDs..
//

//
// This is the default class Id for bootp clients, when they don't specify any.
//

#define  DEFAULT_BOOTP_CLASSID        DHCP_BOOTP_CLASS_TXT
#define  DEFAULT_BOOTP_CLASSID_LENGTH (sizeof(DEFAULT_BOOTP_CLASSID)-1)

//
//  This is the signature we look for as a prefix in the hardware
//  address to identify RAS clients.  We need to identify RAS clients
//  currently so that we treat them as low-level clients so far as
//  DNS integration is concerned so that we do not do any registrations
//  for them whatsoever.
//

#define  DHCP_RAS_PREPEND          "RAS "

#define  ERROR_FIRST_DHCP_SERVER_ERROR ERROR_DHCP_REGISTRY_INIT_FAILED
//
// ERROR_LAST_DHCP_SERVER_ERROR already defined in dhcpmsg.mc
//

#define  DHCP_SECRET_PASSWD_KEY    L"_SC_DhcpServer Pass Key"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcpinst.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpinst.c

Abstract:

    Test program to install dhcp server service.

Author:

    Madan Appiah (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <dhcpsrv.h>

DWORD GlobalDebugFlag = 0x8000FFFF;

#define DHCP_NET_KEY    L"Net"

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}

#endif // DBG
//
// utility to install the DHCP Server service.
//

DWORD
InstallService(
    VOID
    )
{
    LPWSTR lpszBinaryPathName = L"%SystemRoot%\\system32\\ntsd -g -G tcpsvcs";
    SC_HANDLE ManagerHandle, ServiceHandle;
    DWORD Error;

    ManagerHandle = OpenSCManager(NULL, NULL, GENERIC_WRITE );
    if ( ManagerHandle == NULL ) {
        Error = GetLastError();
        return( Error );
    }

    ServiceHandle = CreateService(
                        ManagerHandle,             /* SCManager database  */
                        L"DhcpServer",             /* name of service     */
                        L"DhcpServer",             /* display name        */
                        SERVICE_ALL_ACCESS,        /* desired access      */
                        SERVICE_WIN32_SHARE_PROCESS, /* service type        */
                        SERVICE_DEMAND_START,      /* start type          */
                        SERVICE_ERROR_NORMAL,      /* error control type  */
                        lpszBinaryPathName,        /* service's binary    */
                        NULL,                      /* no load order group */
                        NULL,                      /* no tag ID           */
                        NULL,                      /* no dependencies     */
                        NULL,                      /* LocalSystem account */
                        NULL);                     /* no password         */

    if ( ServiceHandle == NULL ) {
        Error = GetLastError();
        return( Error );
    }

    CloseServiceHandle( ServiceHandle );
    CloseServiceHandle( ManagerHandle );

    return( ERROR_SUCCESS );
}

DWORD
InitializeAddresses(
    INT argc,
    LPSTR argv[]
    )
{
    DWORD Error;
    HKEY ParametersHandle = NULL;
    HKEY NetKeyHandle = NULL;
    WCHAR NetKeyBuffer[DHCP_IP_KEY_LEN];
    LPWSTR NetKeyAppend;
    DWORD KeyDisposition;
    DWORD NetNum;

    //
    // open PARAMETER ROOT key.
    //

    Error = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                DHCP_ROOT_KEY DHCP_KEY_CONNECT DHCP_PARAM_KEY, // concat
                0,
                DHCP_CLASS,
                REG_OPTION_NON_VOLATILE,
                DHCP_KEY_ACCESS,
                NULL,
                &ParametersHandle,
                &KeyDisposition );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // create debug flag.
    //

    Error = RegSetValueEx(
                ParametersHandle,
                DHCP_DEBUG_FLAG_VALUE,
                0,
                DHCP_DEBUG_FLAG_VALUE_TYPE,
                (LPBYTE)&GlobalDebugFlag,
                sizeof(DWORD) );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    wcscpy( NetKeyBuffer, DHCP_NET_KEY);
    NetKeyAppend = NetKeyBuffer + wcslen(NetKeyBuffer);

    for( NetNum = 0; NetNum < (DWORD)(argc / 2); NetNum++) {

        DWORD IpAddress;
        DWORD SubnetMask;

        //
        // make net key. DHCP_NET_KEY + NumNet
        //

        DhcpRegOptionIdToKey( (BYTE)NetNum, NetKeyAppend );

        Error = RegCreateKeyEx(
                    ParametersHandle,
                    NetKeyBuffer,
                    0,
                    DHCP_CLASS,
                    REG_OPTION_NON_VOLATILE,
                    DHCP_KEY_ACCESS,
                    NULL,
                    &NetKeyHandle,
                    &KeyDisposition );

        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        IpAddress = DhcpDottedStringToIpAddress(argv[NetNum*2]);
        Error = RegSetValueEx(
                    NetKeyHandle,
                    DHCP_NET_IPADDRESS_VALUE,
                    0,
                    DHCP_NET_IPADDRESS_VALUE_TYPE,
                    (LPBYTE)&IpAddress,
                    sizeof(DHCP_IP_ADDRESS) );

        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        SubnetMask = DhcpDottedStringToIpAddress(argv[NetNum * 2 + 1]);
        Error = RegSetValueEx(
                    NetKeyHandle,
                    DHCP_NET_SUBNET_MASK_VALUE,
                    0,
                    DHCP_NET_SUBNET_MASK_VALUE_TYPE,
                    (LPBYTE)&SubnetMask,
                    sizeof(DHCP_IP_ADDRESS) );

        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        printf("Dhcp Parameter key %ws is successfully created.\n",
                    NetKeyBuffer );
        printf("\tIpAddress = %s, SubnetMask = %s\n",
                    argv[NetNum * 2], argv[NetNum * 2 + 1] );

        RegCloseKey( NetKeyHandle );
        NetKeyHandle = NULL;
    }

Cleanup:

    if( ParametersHandle != NULL ) {
        RegCloseKey( ParametersHandle );
    }

    if( NetKeyHandle != NULL ) {
        RegCloseKey( NetKeyHandle );
    }

    return( Error );
}

VOID
DisplayUsage(
    VOID
    )
{
    printf( "Usage:  dhcpinst address0 subnet0 "
                "[address1 subnet1] ...\n");
    return;
}

VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD Error;

    if( argc < 3 ) {
        DisplayUsage();
        return;
    }


    //
    // Record addresses specified in the Registry.
    //

    Error = InitializeAddresses( argc - 1, &argv[1]);

    if( Error != ERROR_SUCCESS ) {
        printf( "Falied to initialize addresses, %ld.\n", Error );
        return;
    }

    Error = InstallService();

    if( Error != ERROR_SUCCESS ) {
        printf( "Falied to install service, %ld.\n", Error );
        return;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the DHCP server.

Author:

    Madan Appiah  (madana)  10-Sep-1993
    Manny Weiser  (mannyw)  10-Oct-1992

Environment:

    User Mode - Win32

Revision History:


--*/

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\dhcpssvc.log"
#define DEBUG_BAK_FILE      L"\\dhcpssvc.bak"

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//

#define DEBUG_ADDRESS           0x00000001  // subnet address
#define DEBUG_CLIENT            0x00000002  // client API
#define DEBUG_PARAMETERS        0x00000004  // dhcp server parameter
#define DEBUG_OPTIONS           0x00000008  // dhcp option

#define DEBUG_ERRORS            0x00000010  // hard error
#define DEBUG_STOC              0x00000020  // protocol error
#define DEBUG_INIT              0x00000040  // init error
#define DEBUG_SCAVENGER         0x00000080  // sacvenger error

#define DEBUG_TIMESTAMP         0x00000100  // debug message timing
#define DEBUG_APIS              0x00000200  // Dhcp APIs
#define DEBUG_REGISTRY          0x00000400  // Registry operation
#define DEBUG_JET               0x00000800  // JET error

#define DEBUG_THREADPOOL        0x00001000  // thread pool operation
#define DEBUG_AUDITLOG          0x00002000  // audit log operation
// unused flag.
#define DEBUG_MISC              0x00008000  // misc info.

//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_MESSAGE           0x00010000  // dhcp message output.
#define DEBUG_API_VERBOSE       0x00020000  // Dhcp API verbose
#define DEBUG_DNS               0x00040000  // Dns related messages
#define DEBUG_MSTOC             0x00080000  // multicast stoc

#define DEBUG_TRACK             0x00100000  // tracking specific problems
#define DEBUG_ROGUE             0x00200000  // rogue stuff printed out
#define DEBUG_PNP               0x00400000  // pnp interface stuff

#define DEBUG_PERF              0x01000000  // Printfs for performance work.
#define DEBUG_ALLOC             0x02000000  // Print allocations de-allocations..
#define DEBUG_PING              0x04000000  // Asynchronous ping details
#define DEBUG_THREAD            0x08000000  // Thread.c stuff

#define DEBUG_TRACE             0x10000000  // Printfs for tracing throug code.
#define DEBUG_TRACE_CALLS       0x20000000  // Trace through piles of junk
#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.
#define DEBUG_LOG_IN_FILE       0x80000000  // log debug output in a file.


VOID
DhcpOpenDebugFile(
    IN BOOL ReopenFlag
    );



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcpacc.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    access.h

Abstract:

    Private header file to be included by dhcp server service modules
    that need to enforce security.

Author:

    Madan Appiah (madana) 4-Apr-1994

Revision History:

--*/

#ifndef _DHCP_SECURE_INCLUDED_
#define _DHCP_SECURE_INCLUDED_

//-------------------------------------------------------------------//
//                                                                   //
// Object specific access masks                                      //
//                                                                   //
//-------------------------------------------------------------------//

//
// ConfigurationInfo specific access masks
//
#define DHCP_VIEW_ACCESS     (FILE_GENERIC_READ)
#define DHCP_ADMIN_ACCESS    (FILE_GENERIC_WRITE)

#define DHCP_ALL_ACCESS  (FILE_ALL_ACCESS | STANDARD_RIGHTS_REQUIRED |\
                            DHCP_VIEW_ACCESS       |\
                            DHCP_ADMIN_ACCESS )


//
// Object type names for audit alarm tracking
//

#define DHCP_SERVER_SERVICE_OBJECT       TEXT("DhcpServerService")


DWORD
DhcpCreateSecurityObjects(
    VOID
    );

DWORD
DhcpApiAccessCheck(
    ACCESS_MASK DesiredAccess
    );

#endif // ifndef _DHCP_SECURE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcppch.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcppch.h

Abstract:

    This file is the central include file for the DHCP server service.

Author:

    Madan Appiah  (madana)  10-Sep-1993
    Manny Weiser  (mannyw)  11-Aug-1992

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

//#define __DHCP_USE_DEBUG_HEAP__

//#pragma warning(disable : 4115 )
//#pragma warning(disable : 4214 )
//#pragma warning(disable : 4200 )
//#pragma warning(disable : 4213 )
//#pragma warning(disable : 4211 )
//#pragma warning(disable : 4310 )

//
//  NT public header files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <align.h>
#include <activeds.h>
#include <time.h>

//#pragma warning(disable : 4115 )
//#pragma warning(disable : 4214 )
//#pragma warning(disable : 4200 )
//#pragma warning(disable : 4213 )
//#pragma warning(disable : 4211 )
//#pragma warning(disable : 4310 )

#include <lmcons.h>
#include <netlib.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <dnsapi.h>
#include <adsi.h>

#include <winsock2.h>
#include <smbgtpt.h>
#include <excpt.h>

//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>


//
// RPC files
//

#include <rpc.h>

//
// netlib header.
//

#include <lmcons.h>
#include <secobj.h>

//
// database header files.
//

#include <esent.h>
//
// used to include jet.h, but now esent.h
//

//
// tcp services control hander file
//

#include <tcpsvcs.h>

//
// MM header files
//
#include    <mm\mm.h>
#include    <mm\array.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\subnet2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>

//
//  Local header files
//

#include <dhcpapi.h>
#include <dhcpdef.h>
#include <thread.h>
#include <global.h>
#include <debug.h>
#include <proto.h>
#include <dhcpmsg.h>
#include <dhcpreg.h>
#include <dhcpacc.h>
#include <oldstub.h>

//
//  DHCP library header files
//

#include <dhcp.h>
#include <dhcplib.h>
#include <lock.h>

//
//  global macros.
//

#include <gmacros.h>


// missed define in global.h
#ifndef OPTION_DYNDNS_BOTH
#define OPTION_DYNDNS_BOTH    81
#endif

//
// server callouts
//
#include <callout.h>

//
// DHCP to BINL header file
//

#include <dhcpbinl.h>


//
// debug heap support
//

#include <heapx.h>

#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#pragma message ( "*** DHCP Server will use debug heap ***" )

#define DhcpAllocateMemory(x) calloc(1,x)
#define DhcpFreeMemory(x)     free(x)

#endif
#endif

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcprpc2.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    dhcprpc2.c

Abstract:
    This module just includes some rpc files to get
    over pre-compilation woes.

--*/

#include <dhcppch.h>

#include "dhcp2_srv_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcpsrv.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpsrv.h

Abstract:

    This file is the central include file for the DHCP server service.

Author:

    Madan Appiah  (madana)  10-Sep-1993
    Manny Weiser  (mannyw)  11-Aug-1992

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#include <dhcppch.h>
#include <dhcp_srv.h>
#include <dhcp2_srv.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcpwriter.h ===
#ifndef DHCPWRITER_H
#define DHCPWRITER_H

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

#define DHCPWRITER_NAME  TEXT("Dhcp Jet Writer")

DWORD __cdecl DhcpWriterInit();
DWORD __cdecl DhcpWriterTerm();

DWORD
DhcpDeleteFiles(
   LPSTR Path,
   LPSTR Files );

#ifdef __cplusplus
}
#endif //__cplusplus

// this class could be refrerenced only from C++ code
#ifdef __cplusplus

// #include <vs_idl.hxx>
#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>
#include <jetwriter.h>

class CDhcpVssJetWriter : public CVssJetWriter
{
public:
    HRESULT Initialize();
    HRESULT Terminate();
    virtual bool STDMETHODCALLTYPE OnIdentify( IN IVssCreateWriterMetadata *pMetadata );
};

#endif //__cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcpreg.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Dhcpreg.c

Abstract:

    This file contains functions that manipulate dhcp configuration
    info. in and out from system registry.

Author:

    Madan Appiah  (madana)  19-Sep-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

    Cheng Yang (t-cheny)  28-May-1996 superscope
    Cheng Yang (t-cheny)  27-Jun-1996 IP address detection, audit log

--*/

#include <dhcppch.h>

//
//  Local storage
//
DWORD     nQuickBindAddresses = 0;
LPDWORD   QuickBindAddresses = NULL;
LPDWORD   QuickBindMasks = NULL;

DWORD
DhcpUpgradeConfiguration(
    VOID
    );
    
DWORD
DhcpRegQueryInfoKey(
    HKEY KeyHandle,
    LPDHCP_KEY_QUERY_INFO QueryInfo
    )
/*++

Routine Description:

    This function retrieves information about given key.

Arguments:

    KeyHandle - handle to a registry key whose info will be retrieved.

    QueryInfo - pointer to a info structure where the key info will be
                returned.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;

    QueryInfo->ClassSize = DHCP_CLASS_SIZE;
    Error = RegQueryInfoKey(
                KeyHandle,
                QueryInfo->Class,
                &QueryInfo->ClassSize,
                NULL,
                &QueryInfo->NumSubKeys,
                &QueryInfo->MaxSubKeyLen,
                &QueryInfo->MaxClassLen,
                &QueryInfo->NumValues,
                &QueryInfo->MaxValueNameLen,
                &QueryInfo->MaxValueLen,
                &QueryInfo->SecurityDescriptorLen,
                &QueryInfo->LastWriteTime
                );

    return( Error );
} // DhcpRegQueryInfoKey()

DWORD
DhcpRegGetValue(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    LPBYTE BufferPtr
    )
/*++

Routine Description:

    This function retrieves the value of the specified value field. This
    function allocates memory for variable length field such as REG_SZ.
    For REG_DWORD data type, it copies the field value directly into
    BufferPtr. Currently it can handle only the following fields :

    REG_DWORD,
    REG_SZ,
    REG_BINARY

Arguments:

    KeyHandle : handle of the key whose value field is retrieved.

    ValueName : name of the value field.

    ValueType : Expected type of the value field.

    BufferPtr : Pointer to DWORD location where a DWORD datatype value
                is returned or a buffer pointer for REG_SZ or REG_BINARY
                datatype value is returned.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;
    DWORD LocalValueType;
    DWORD ValueSize;
    LPBYTE DataBuffer;
    LPBYTE AllotedBuffer = NULL;
    LPDHCP_BINARY_DATA BinaryData;

    //
    // Query DataType and BufferSize.
    //

    Error = RegQueryValueEx(
                KeyHandle,
                ValueName,
                0,
                &LocalValueType,
                NULL,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        return(Error);
    }

    DhcpAssert( LocalValueType == ValueType );
    switch( ValueType ) {
    case REG_DWORD:
        DhcpAssert( ValueSize == sizeof(DWORD) );

        DataBuffer = BufferPtr;
        break;

    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:

        if( ValueSize == 0 ) {

            //
            // if string no found in the registry,
            // allocate space for null string.
            //

            ValueSize = sizeof(WCHAR);
        }

        //
        // fall through.
        //

    case REG_BINARY:
        AllotedBuffer = DataBuffer = MIDL_user_allocate( ValueSize );

        if( DataBuffer == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        break;

    default:
        DhcpPrint(( DEBUG_REGISTRY, "Unexpected ValueType in"
                        "DhcpRegGetValue function, %ld\n", ValueType ));
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // retrieve data.
    //

    Error = RegQueryValueEx(
                KeyHandle,
                ValueName,
                0,
                &LocalValueType,
                DataBuffer,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        if( NULL != AllotedBuffer ) {
            MIDL_user_free( AllotedBuffer );
            AllotedBuffer = NULL;
        }
        
        *(DWORD *)BufferPtr = 0;
        return(Error);
    }

    switch( ValueType ) {
    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:

        if( ValueSize == 0 ) {

            //
            // if string no found in the registry,
            // return null string.
            //

            *(LPWSTR)DataBuffer = '\0';
        }

        *(LPBYTE *)BufferPtr = DataBuffer;
        break;

    case REG_BINARY:
        BinaryData = MIDL_user_allocate(sizeof(DHCP_BINARY_DATA));

        if( BinaryData == NULL ) {
            MIDL_user_free( AllotedBuffer );
            *(DWORD *)BufferPtr = 0;
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        BinaryData->DataLength = ValueSize;
        BinaryData->Data = DataBuffer;
        *(LPBYTE *)BufferPtr = (LPBYTE)BinaryData;

    default:
        break;
    }

    return(Error);
} // DhcpRegGetValue()

// OLD
DWORD
DhcpRegCreateKey(
    HKEY RootKey,
    LPWSTR KeyName,
    PHKEY KeyHandle,
    LPDWORD KeyDisposition
    )
/*++

Routine Description:

    This function opens a registry key for DHCP service.

Arguments:

    RootKey : Registry handle of the parent key.

    KeyName : Name of the key to be opened.

    KeyHandle : Handle of the open key.

    KeyDisposition : pointer to a location where the disposition value
                        is returned.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;

    //
    // Create/Open Registry keys.
    //

    Error = RegCreateKeyEx(
                RootKey,
                KeyName,
                0,
                DHCP_CLASS,
                REG_OPTION_NON_VOLATILE,
                DHCP_KEY_ACCESS,
                NULL,
                KeyHandle,
                KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_REGISTRY, "RegCreateKeyEx failed to create "
                        "%ws, %ld.\n", KeyName, Error));
        return( Error );
    }

#if DBG
    if( *KeyDisposition == REG_CREATED_NEW_KEY ) {
        DhcpPrint(( DEBUG_REGISTRY,
            "%ws registry key is created.\n",
             KeyName));
    }
#endif // DBG

    return( Error );
}

BOOL
QuickBound(
    DHCP_IP_ADDRESS Address,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress,
    BOOL *fBind
)
/*++

Routine Description:
    This routine tells if the interface is bound or if there is another
    IPAddress in the same subnet to which the interface is bound.

Return Value:
    TRUE --> quick bound or have another quickbound if on subnet..

--*/
{
    ULONG i;
    BOOL fRetVal = FALSE;

    (*fBind) = FALSE;
    for( i = 0; i < nQuickBindAddresses ; i ++ ) {
        if( Address == QuickBindAddresses[i] ) {
            *SubnetMask = QuickBindMasks[i];
            *SubnetAddress = Address & *SubnetMask;
            (*fBind) = TRUE;
            return TRUE;
        }
        if( (Address & QuickBindMasks[i]) ==
            (QuickBindAddresses[i] & QuickBindMasks[i]) ) {
            (*fBind) = FALSE;
            fRetVal = TRUE;
        }
    }
    return fRetVal;
}

DWORD
DhcpRegFillQuickBindInfo(
    VOID
    )
/*++

Routine Description:

    This function initializes EndPoint array from the registry
    information.

    The "parameter" key for DHCP service specifies the QUICK BIND info.
    This is a MULTI_SZ string of ipaddresses followed by the subnet
    masks.  This is read to initialize the endpoints. If this succeeds,
    then the usual BIND info is NOT read. On the other hand, if anything
    fails here, the usual information is read, and this information here
    is totally ignored.

Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error;

    HKEY LinkageKeyHandle = NULL;
    LPWSTR BindString = NULL;
    LPWSTR StringPtr, TmpString;
    DWORD StringLen;
    DWORD Index;
    DWORD NumberOfNets;
    DWORD   i;

    HKEY AdapterKeyHandle = NULL;
    LPWSTR IpAddressString = NULL;
    LPWSTR SubnetMaskString = NULL;

    QuickBindAddresses = QuickBindMasks = NULL;
    nQuickBindAddresses = 0;

    //
    // open linkage key in the to determine the the nets we are bound
    // to.
    //

    Error = RegOpenKeyEx(
                DhcpGlobalRegRoot,
                DHCP_PARAM_KEY,
                0,
                DHCP_KEY_ACCESS,
                &LinkageKeyHandle );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // read BIND value.
    //

    Error =  DhcpRegGetValue(
                LinkageKeyHandle,
                DHCP_QUICK_BIND_VALUE,
                DHCP_QUICK_BIND_VALUE_TYPE,
                (LPBYTE)&BindString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // determine number of string in BindStrings, that many NETs are
    // bound.
    //

    StringPtr = BindString;
    NumberOfNets = 0;
    while( (StringLen = wcslen(StringPtr)) != 0) {

        //
        // found another NET.
        //

        NumberOfNets++;

        TmpString = wcschr(StringPtr, L' ');
        if( NULL != TmpString ) {
            *TmpString = L'\0';
            NumberOfNets ++;
        }

        StringPtr += (StringLen + 1); // move to next string.
    }

    if((NumberOfNets % 2)) { // ODD # is not possible.
        DhcpPrint((DEBUG_ERRORS, "Format of QuickBind value is incorrect. Has Odd subnets.\n"));
        // Some random error... does not matter which.
        Error = ERROR_PATH_NOT_FOUND;
        goto Cleanup;
    }

    NumberOfNets /= 2; // the network has a pair of address: ip addr, subnet mask.

    //
    // allocate memory for the QuickBindAddresses array
    //

    QuickBindAddresses = DhcpAllocateMemory ( NumberOfNets * sizeof(*QuickBindAddresses));
    QuickBindMasks = DhcpAllocateMemory ( NumberOfNets * sizeof(*QuickBindMasks));

    if( NULL == QuickBindAddresses || NULL == QuickBindMasks ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // enum the NETs.
    //

    StringPtr = BindString,
    nQuickBindAddresses = NumberOfNets;

    for(Index = 0, StringPtr = BindString;
            ((StringLen = wcslen(StringPtr)) != 0);
                Index++, StringPtr += (StringLen + 1) ) {

        CHAR OemString[ DHCP_IP_KEY_LEN ];
        LPSTR OemStringPtr;
        DWORD EnableDHCPFlag;

        // read IpAddress and SubnetMask.
        //

        IpAddressString = StringPtr;
        StringPtr += StringLen +1;
        SubnetMaskString = StringPtr;
        StringLen = wcslen(StringPtr);


        //
        // we found another net we can work on.
        //

        OemStringPtr = DhcpUnicodeToOem( IpAddressString, OemString);

        if( 0 == inet_addr( OemStringPtr ) ) {
            Error = ERROR_BAD_FORMAT;
            goto Cleanup;
        }

        QuickBindAddresses[Index] = inet_addr(OemStringPtr);

        OemStringPtr = DhcpUnicodeToOem( SubnetMaskString, OemString);

        if( 0 == inet_addr( OemStringPtr ) ) {
            Error = ERROR_BAD_FORMAT;
            goto Cleanup;
        }

        QuickBindMasks[Index] = inet_addr(OemStringPtr);

        if( 0 == (QuickBindAddresses[Index] & QuickBindMasks[Index]) ) {
            Error = ERROR_BAD_FORMAT;
            goto Cleanup;
        }

        IpAddressString = NULL;
        SubnetMaskString = NULL;
    }

Cleanup:

    if( LinkageKeyHandle != NULL ) {
        RegCloseKey( LinkageKeyHandle );
    }

    if( BindString != NULL ) {
        MIDL_user_free( BindString );
    }

    if( Error != ERROR_SUCCESS ) {

        if( NULL != QuickBindAddresses ) DhcpFreeMemory(QuickBindAddresses);
        if( NULL != QuickBindMasks ) DhcpFreeMemory(QuickBindMasks);
        QuickBindAddresses = QuickBindMasks = NULL;
        nQuickBindAddresses = 0;

        DhcpPrint(( DEBUG_INIT,
            "Couldn't initialize Endpoint List, %ld.\n",
                Error ));
    }

    return( Error );
}

// OLD
DWORD
DhcpRegDeleteKey(
    HKEY ParentKeyHandle,
    LPWSTR KeyName
    )
/*++

Routine Description:

    This function deletes the specified key and all its subkeys.

Arguments:

    ParentKeyHandle : handle of the parent key.

    KeyName : name of the key to be deleted.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;
    HKEY KeyHandle = NULL;
    DHCP_KEY_QUERY_INFO QueryInfo;


    //
    // open key.
    //

    Error = RegOpenKeyEx(
                ParentKeyHandle,
                KeyName,
                0,
                DHCP_KEY_ACCESS,
                &KeyHandle );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // query key info.
    //

    Error = DhcpRegQueryInfoKey(
                KeyHandle,
                &QueryInfo );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // delete all its subkeys if they exist.
    //

    if( QueryInfo.NumSubKeys != 0 ) {
        DWORD Index;
        DWORD KeyLength;
        WCHAR KeyBuffer[100];
        FILETIME KeyLastWrite;

        for(Index = 0;  Index < QueryInfo.NumSubKeys ; Index++ ) {

            //
            // read next subkey name.
            //
            // Note : specify '0' as index each time, since  deleting
            // first element causes the next element as first
            // element after delete.
            //

            KeyLength = sizeof(KeyBuffer)/sizeof(WCHAR);
            Error = RegEnumKeyEx(
                KeyHandle,
                0,                  // index.
                KeyBuffer,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );
            
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            //
            // delete this key recursively.
            //

            Error = DhcpRegDeleteKey(
                KeyHandle,
                KeyBuffer );
            
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }
        }
    }

    //
    // close the key before delete.
    //

    RegCloseKey( KeyHandle );
    KeyHandle = NULL;

    //
    // at last delete this key.
    //

    Error = RegDeleteKey( ParentKeyHandle, KeyName );

Cleanup:

    if( KeyHandle == NULL ) {
        RegCloseKey( KeyHandle );
    }

    return( Error );
}

DWORD
DhcpGetBindingList(
    LPWSTR  *bindingList
    )
/*++

Routine Description:


Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error;

    HKEY LinkageKeyHandle = NULL;

    //
    // open linkage key in the to determine the the nets we are bound
    // to.
    //

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TCPIP_LINKAGE_KEY,
                0,
                DHCP_KEY_ACCESS,
                &LinkageKeyHandle );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // read BIND value.
    //

    Error =  DhcpRegGetValue(
                LinkageKeyHandle,
                DHCP_BIND_VALUE,
                DHCP_BIND_VALUE_TYPE,
                (LPBYTE)bindingList);

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

Cleanup:
    if( LinkageKeyHandle != NULL ) {
        RegCloseKey( LinkageKeyHandle );
    }


    return Error;

}

DWORD
DhcpOpenInterfaceByName(
    IN LPCWSTR InterfaceName,
    OUT HKEY *Key
    )
/*++

Routine Description:
    This routine opens the tcpip\parameters\interfaces\ key for the
    specified interface.

Arguments:
    InterfaceName -- name of interface
    Key -- return value variable to fill with key handle

Return Value:
    Win32 errors

--*/
{
    WCHAR AdapterParamKey[
        sizeof(SERVICES_KEY) + sizeof(ADAPTER_TCPIP_PARMS_KEY)
        + DHCP_IP_KEY_LEN * 8
        ];

    AdapterParamKey[ 0 ] = L'\0';

    if ( ( wcslen( SERVICES_KEY ) + wcslen( ADAPTER_TCPIP_PARMS_KEY ) + wcslen( InterfaceName ) ) < ( sizeof( AdapterParamKey )/sizeof( AdapterParamKey[ 0 ] ) ))
    {
        wcscpy( AdapterParamKey, SERVICES_KEY);
        wcscat( AdapterParamKey, ADAPTER_TCPIP_PARMS_KEY );
        wcscat( AdapterParamKey, InterfaceName);
    }

    return RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        AdapterParamKey,
        0,
        DHCP_KEY_ACCESS,
        Key
        );    
}

DWORD
DhcpOpenAdapterConfigKey(
    LPWSTR  AdapterStr,
    HKEY *AdapterKeyHandle
    )
/*++

Routine Description:
    Opens the registry key handle for the given adapter string.
    (the string is expected to have a prefix given by
    ADAPTER_TCPIP_PREFIX )

Arguments:
    AdapterStr -- string name as found in bindings key.
    AdapterKeyHandle -- the handle to return.
    
Return Value:
    Registry Error.

--*/
{
    return DhcpOpenInterfaceByName(
        AdapterStr + wcslen( ADAPTER_TCPIP_PREFIX ),
        AdapterKeyHandle
        );
}



BOOL
IsAdapterStaticIP(
    HKEY AdapterKeyHandle
    )
/*++

Routine Description:


Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error, EnableDHCPFlag;
    //
    // read DHCPEnableFlag.
    //


    Error =  DhcpRegGetValue(
                AdapterKeyHandle,
                DHCP_NET_DHCP_ENABLE_VALUE,
                DHCP_NET_DHCP_ENABLE_VALUE_TYPE,
                (LPBYTE)&EnableDHCPFlag );

    if( Error == ERROR_SUCCESS ) {

        //
        // if DHCP is enabled on this cord, we can't do DHCP server
        // functionality, so ignore this adapter.
        //

        if( EnableDHCPFlag ) {

            return FALSE;
        }
    }
    return TRUE;
}

BOOL
IsAdapterBoundToDHCPServer(
    HKEY AdapterKeyHandle
    )
/*++

Routine Description:
    This routine checks to see if the given adapter is bound to 
    DHCP Server or not by looking at a registry variable..

Arguments:
    AdapterKeyHandle -- key to search for

Return Value:
    TRUE indicates the adapter is bound, FALSE indicates not bound

--*/
{
    DWORD Error, EnableFlag;

    //
    // read "BindToDHCPServer" flag
    //

    Error =  DhcpRegGetValue(
        AdapterKeyHandle,
        DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE,
        DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE,
        (LPBYTE)&EnableFlag 
        );

    //
    // If this flag is non-zero, then bind.. else don't bind.
    // 
    //

    return (ERROR_SUCCESS == Error && EnableFlag != 0 );
}

DWORD
SetBindingToDHCPServer(
    HKEY AdapterKeyHandle,
    BOOL fBind
    )
/*++

Routine Description:
    This routine sets the binding information for the dhcp server..

Arguments:
    AdapterKeyHandle -- key to use to store bind info
    fBind -- TRUE indicates the adapter is bound, FALSE indicates not bound

Return Values:
    Win32 errors

--*/
{
    DWORD Error, EnableFlag;

    EnableFlag = (fBind)?1:0;

    return RegSetValueEx(
        AdapterKeyHandle,
        DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE,
        0,
        DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE,
        (LPBYTE)&EnableFlag,
        sizeof(EnableFlag)
        );

}


DWORD
DhcpGetAdapterIPAddr(
    HKEY AdapterKeyHandle,
    DHCP_IP_ADDRESS *IpAddress,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress

    )
/*++

Routine Description:


Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error;
    CHAR OemString[ DHCP_IP_KEY_LEN ];
    LPSTR OemStringPtr;
    LPWSTR IpAddressString = NULL;
    LPWSTR SubnetMaskString = NULL;

    //
    // read IpAddress and SubnetMask.
    //

    Error =  DhcpRegGetValue(
        AdapterKeyHandle,
        DHCP_NET_IPADDRESS_VALUE,
        DHCP_NET_IPADDRESS_VALUE_TYPE,
        (LPBYTE)&IpAddressString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    Error =  DhcpRegGetValue(
        AdapterKeyHandle,
        DHCP_NET_SUBNET_MASK_VALUE,
        DHCP_NET_SUBNET_MASK_VALUE_TYPE,
        (LPBYTE)&SubnetMaskString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // we found another net we can work on.
    //

    OemStringPtr = DhcpUnicodeToOem( IpAddressString, OemString);
    *IpAddress = inet_addr( OemStringPtr );

    //
    // add this adpter to the list only if the ip address is
    // non-zero.
    //

    if ( *IpAddress != 0 ) {

        OemStringPtr = DhcpUnicodeToOem( SubnetMaskString, OemString);
        *SubnetMask = inet_addr( OemStringPtr );

        *SubnetAddress = *IpAddress & *SubnetMask;

    }

Cleanup:

    MIDL_user_free( IpAddressString );
    IpAddressString = NULL;

    MIDL_user_free( SubnetMaskString );
    SubnetMaskString = NULL;

    return Error;
} // DhcpGetAdapterIPAddr()

BOOL                                    //  TRUE ==> IpAddress has been matched
QuickBindableAddressExists(             //  Check if one of the qbind addresses is in IpString
    IN      LPWSTR       IpString,      //  MultiSz string of ip addresses
    IN      LPWSTR       MaskString,    //  MultiSZ string of subnet masks
    OUT     LPDWORD      IpAddress,     //  Output ip address chosen
    OUT     LPDWORD      SubnetMask     //  Output subnet mask chosen
)
{
    DWORD                i;
    CHAR                 OemString[ DHCP_IP_KEY_LEN ];
    LPSTR                OemStringPtr;
    DHCP_IP_ADDRESS      Addr;

    if( !nQuickBindAddresses ) {        //  If there are no quick bind addresses
        return FALSE;                   //  Then return FALSE ==> no matches found
    }
    
    while( wcslen(IpString) ) {
        OemStringPtr = DhcpUnicodeToOem( IpString, OemString );
        if( NULL == OemStringPtr ) {
            DhcpPrint((DEBUG_ERRORS, "Could not convert %ws to OEM\n", IpString));
            IpString += wcslen(IpString) + 1;
            MaskString += wcslen(MaskString) + 1;
            continue;
        }
        Addr = inet_addr(OemStringPtr);
        for( i = 0 ; i < nQuickBindAddresses ; i ++ )
            if( Addr == QuickBindAddresses[i] )
                break;
        if( i >= nQuickBindAddresses ) {
            IpString += wcslen(IpString) + 1;
            MaskString += wcslen(MaskString) + 1;
            continue;
        }

        OemStringPtr = DhcpUnicodeToOem(MaskString, OemString);
        if( NULL == OemStringPtr ) {
            DhcpPrint((DEBUG_ERRORS, "Could not convert %ws to OEM\n", MaskString));
            Addr = QuickBindMasks[i];
        } else {
            Addr = inet_addr(OemStringPtr);
        }

        if( Addr != QuickBindMasks[i] ){//  This should not happen: Mis configuration
            DhcpPrint((DEBUG_ERRORS, "Mask mismatch: WSOCK: %x, QBIND: %x\n",
                       Addr, QuickBindMasks[i]));
        }
        *IpAddress = QuickBindAddresses[i];
        *SubnetMask = QuickBindMasks[i];//  Trust the qBind info over wsock? Maybe some hack..
        return TRUE;
    }
    return FALSE;
} // QuickBindableAddressExists()

//  This function chooses either the first ip address of the card, or the quickbind ip
//  address for the card, preferring the latter.
DWORD
DhcpGetAdapterIPAddrQuickBind(
    HKEY             AdapterKeyHandle,
    DHCP_IP_ADDRESS *IpAddress,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress
) {
    DWORD Error;
    CHAR OemString[ DHCP_IP_KEY_LEN ];
    LPSTR OemStringPtr;
    LPWSTR IpAddressString = NULL;
    LPWSTR SubnetMaskString = NULL;
    BOOL             Status;

    //
    // read IpAddress and SubnetMask.
    //

    Error =  DhcpRegGetValue(
                AdapterKeyHandle,
                DHCP_NET_IPADDRESS_VALUE,
                DHCP_NET_IPADDRESS_VALUE_TYPE,
                (LPBYTE)&IpAddressString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    Error =  DhcpRegGetValue(
                AdapterKeyHandle,
                DHCP_NET_SUBNET_MASK_VALUE,
                DHCP_NET_SUBNET_MASK_VALUE_TYPE,
                (LPBYTE)&SubnetMaskString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // we found another net we can work on.
    //

    Status = QuickBindableAddressExists(
        IpAddressString,
        SubnetMaskString,
        IpAddress,
        SubnetMask
    );

    if( Status ) {
        *SubnetAddress = *IpAddress & *SubnetMask ;
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OemStringPtr = DhcpUnicodeToOem( IpAddressString, OemString);
    *IpAddress = inet_addr( OemStringPtr );

    //
    // add this adpter to the list only if the ip address is
    // non-zero.
    //

    if ( *IpAddress != 0 ) {

        OemStringPtr = DhcpUnicodeToOem( SubnetMaskString, OemString);
        *SubnetMask = inet_addr( OemStringPtr );

        *SubnetAddress = *IpAddress & *SubnetMask;

    }

Cleanup:

    MIDL_user_free( IpAddressString );
    IpAddressString = NULL;

    MIDL_user_free( SubnetMaskString );
    SubnetMaskString = NULL;

    return Error;
}


//
//  This function coverts the unicode string (or what ever is stored in
//  the registry) to ASCII. Change it so it is nolonger needed.
//
DWORD
DhcpRegGetExpandValue(
    LPWSTR KeyName,
    DWORD KeyType,
    LPSTR *RetExpandPath
)
{

    DWORD Error;
    LPWSTR Path = NULL;
    LPSTR OemPath = NULL;
    DWORD PathLength;
    DWORD Length;
    LPSTR ExpandPath = NULL;
    LPWSTR ExpandWidePath = NULL;

    *RetExpandPath = NULL;

    Error = DhcpRegGetValue(
                DhcpGlobalRegParam,
                KeyName,
                KeyType,
                (LPBYTE)&Path );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    OemPath = DhcpUnicodeToOem( Path, NULL ); // allocate memory.

    if( OemPath == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    PathLength = strlen( OemPath ) + MAX_PATH + 1;

    ExpandPath = DhcpAllocateMemory( PathLength );
    if( ExpandPath == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( ( wcscmp( KeyName, DHCP_DB_PATH_VALUE ) == 0 ) || 
         ( wcscmp( KeyName, DHCP_BACKUP_PATH_VALUE ) == 0 ) )
    {
        ExpandWidePath = DhcpAllocateMemory( PathLength * sizeof( WCHAR ) );
        if ( ExpandWidePath == NULL )
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        Length = ExpandEnvironmentStringsW( Path, ExpandWidePath, PathLength );
        if ( ( Length == 0 ) || ( Length > PathLength ) )
        {
            if ( Length == 0 )
            {
                Error = GetLastError( );
            }
            else
            {
                Error = ERROR_META_EXPANSION_TOO_LONG;
            }
            goto Cleanup;
        }

        Error = RegSetValueEx( DhcpGlobalRegParam,
                               KeyName,
                               0,
                               KeyType,
                               (LPBYTE)ExpandWidePath,
                               ( wcslen( ExpandWidePath ) + 1 ) * sizeof( WCHAR ) );

        if ( Error != ERROR_SUCCESS )
            goto Cleanup;
   
    }

    Length = ExpandEnvironmentStringsA( OemPath, ExpandPath, PathLength );

    DhcpAssert( Length <= PathLength );
    if( (Length == 0) || (Length > PathLength) ) {

        if( Length == 0 ) {
            Error = GetLastError();
        }
        else {
            Error = ERROR_META_EXPANSION_TOO_LONG;
        }

        goto Cleanup;
    }

    *RetExpandPath = ExpandPath;
    ExpandPath = NULL;

Cleanup:

    if( Path != NULL ) {
        DhcpFreeMemory( Path );
    }

    if( OemPath != NULL ) {
        DhcpFreeMemory( OemPath );
    }

    if( ExpandPath != NULL ) {
        DhcpFreeMemory( ExpandPath );
    }

    if ( ExpandWidePath != NULL ) {
        DhcpFreeMemory( ExpandWidePath );
    }

    return( Error );
}

#define VAL_REQD   0x01
#define VAL_EXPAND 0x02

ULONG DbType, Use351Db, EnableDynBootp;
LPWSTR DatabaseName;

struct {
    LPTSTR ValueName;
    ULONG ValueType;
    PVOID ResultBuf;
    ULONG Flags;
    ULONG dwDefault;
} RegParamsArray[] = {
    // 
    // Flags, Name, Type, ResultPtr, DEFAULT value if DWORD
    //
    DHCP_API_PROTOCOL_VALUE, DHCP_API_PROTOCOL_VALUE_TYPE, 
    &DhcpGlobalRpcProtocols, VAL_REQD, 0,

    DHCP_DB_PATH_VALUE, DHCP_DB_PATH_VALUE_TYPE, 
    &DhcpGlobalOemDatabasePath, VAL_REQD|VAL_EXPAND, 0,

    DHCP_BACKUP_PATH_VALUE, DHCP_BACKUP_PATH_VALUE_TYPE, 
    &DhcpGlobalOemBackupPath, VAL_EXPAND, 0,
    
    DHCP_RESTORE_PATH_VALUE, DHCP_RESTORE_PATH_VALUE_TYPE,  // RestoreDatabasePath
    &DhcpGlobalOemRestorePath, VAL_EXPAND, 0,

    DHCP_DB_NAME_VALUE, DHCP_DB_NAME_VALUE_TYPE, 
    &DatabaseName, VAL_REQD, 0,

    DHCP_DB_DOOM_TIME_VALUE, DHCP_DB_DOOM_TIME_VALUE_TYPE,
    &DhcpLeaseExtension, 0, DHCP_LEASE_EXTENSION,
    
    DHCP_BACKUP_INTERVAL_VALUE, DHCP_BACKUP_INTERVAL_VALUE_TYPE, 
    &DhcpGlobalBackupInterval,0, (DEFAULT_BACKUP_INTERVAL/60000),

    DHCP_DB_LOGGING_FLAG_VALUE, DHCP_DB_LOGGING_FLAG_VALUE_TYPE, 
    &DhcpGlobalDatabaseLoggingFlag, 0, DEFAULT_LOGGING_FLAG,

    DHCP_AUDIT_LOG_FLAG_VALUE, DHCP_AUDIT_LOG_FLAG_VALUE_TYPE,
    &DhcpGlobalAuditLogFlag, 0, DEFAULT_AUDIT_LOG_FLAG,

    DHCP_AUDIT_LOG_MAX_SIZE_VALUE, DHCP_AUDIT_LOG_MAX_SIZE_VALUE_TYPE,
    &DhcpGlobalAuditLogMaxSizeInBytes, 0, DEFAULT_AUDIT_LOG_MAX_SIZE,

    DHCP_DETECT_CONFLICT_RETRIES_VALUE, DHCP_DETECT_CONFLICT_RETRIES_VALUE_TYPE,
    &DhcpGlobalDetectConflictRetries, 0, DEFAULT_DETECT_CONFLICT_RETRIES,

    DHCP_RESTORE_FLAG_VALUE, DHCP_RESTORE_FLAG_VALUE_TYPE, 
    &DhcpGlobalRestoreFlag, 0, DEFAULT_RESTORE_FLAG,

    DHCP_DB_CLEANUP_INTERVAL_VALUE, DHCP_DB_CLEANUP_INTERVAL_VALUE_TYPE,
    &DhcpGlobalCleanupInterval, 0, (DHCP_DATABASE_CLEANUP_INTERVAL/60000),

    DHCP_MESSAGE_QUEUE_LENGTH_VALUE, DHCP_MESSAGE_QUEUE_LENGTH_VALUE_TYPE,
    &DhcpGlobalMessageQueueLength, 0, DHCP_RECV_QUEUE_LENGTH,

#if DBG
    DHCP_DEBUG_FLAG_VALUE, DHCP_DEBUG_FLAG_VALUE_TYPE,
    &DhcpGlobalDebugFlag, 0, 0,

    DHCP_PROCESS_INFORMS_ONLY_FLAG, DHCP_PROCESS_INFORMS_ONLY_FLAG_TYPE,
    &fDhcpGlobalProcessInformsOnlyFlag, 0, FALSE,

    DHCP_GLOBAL_SERVER_PORT, DHCP_GLOBAL_SERVER_PORT_TYPE,
    &DhcpGlobalServerPort, 0, DHCP_SERVR_PORT, 

    DHCP_GLOBAL_CLIENT_PORT, DHCP_GLOBAL_CLIENT_PORT_TYPE,
    &DhcpGlobalClientPort, 0, DHCP_CLIENT_PORT,
    
#endif DBG

    DHCP_USE351DB_FLAG_VALUE, DHCP_USE351DB_FLAG_VALUE_TYPE,
    &Use351Db, 0, 0,

    DHCP_DBTYPE_VALUE, DHCP_DBTYPE_VALUE_TYPE,
    &DbType, 0, 5,

    DHCP_IGNORE_BROADCAST_FLAG_VALUE, DHCP_IGNORE_BROADCAST_VALUE_TYPE,
    &DhcpGlobalIgnoreBroadcastFlag, 0, TRUE,

    DHCP_MAX_PROCESSING_THREADS_VALUE, DHCP_MAX_PROCESSING_THREADS_TYPE,
    &g_cMaxProcessingThreads, 0, 0xFFFFFFFF,

    DHCP_MAX_ACTIVE_THREADS_VALUE, DHCP_MAX_ACTIVE_THREADS_TYPE,
    &g_cMaxActiveThreads, 0, 0xFFFFFFFF,

    DHCP_PING_TYPE_VALUE, DHCP_PING_TYPE_TYPE,
    &DhcpGlobalPingType, 0, DHCP_DEFAULT_PING_TYPE,

    DHCP_ALERT_PERCENTAGE_VALUE, DHCP_ALERT_PERCENTAGE_VALUE_TYPE,
    &DhcpGlobalAlertPercentage, 0, DHCP_DEFAULT_ALERT_PERCENTAGE,

    DHCP_ALERT_COUNT_VALUE, DHCP_ALERT_COUNT_VALUE_TYPE,
    &DhcpGlobalAlertCount, 0, DHCP_DEFAULT_ALERT_COUNT,

    DHCP_ROGUE_LOG_EVENTS, DHCP_ROGUE_LOG_EVENTS_TYPE,
    &DhcpGlobalRogueLogEventsLevel, 0, DHCP_DEFAULT_ROGUE_LOG_EVENTS_LEVEL,

    DHCP_ENABLE_DYNBOOTP, DHCP_ENABLE_DYNBOOTP_TYPE,
    &EnableDynBootp, 0, 1,

    DHCP_CLOCK_SKEW_ALLOWANCE, DHCP_CLOCK_SKEW_ALLOWANCE_TYPE,
    &DhcpGlobalClockSkewAllowance, 0, CLOCK_SKEW_ALLOWANCE,

    DHCP_EXTRA_ALLOCATION_TIME, DHCP_EXTRA_ALLOCATION_TIME_TYPE,
    &DhcpGlobalExtraAllocationTime, 0, EXTRA_ALLOCATION_TIME,

    DHCP_DDNS_TTL, DHCP_DDNS_TTL_TYPE,
    &DynamicDNSTimeToLive, 0, DHCP_DNS_DEFAULT_TTL,

    // S E N T I N E L
    NULL, 0, NULL, 0, 0
};

struct {
    HKEY *KeyBase;
    LPTSTR KeyName;
    HKEY *Key;
} ReadKeyArray[] = {
    NULL, DHCP_ROOT_KEY, &DhcpGlobalRegRoot,
    NULL, DHCP_SWROOT_KEY, &DhcpGlobalRegSoftwareRoot,
    &DhcpGlobalRegSoftwareRoot,  DHCP_CONFIG_KEY, &DhcpGlobalRegConfig,
    &DhcpGlobalRegRoot,  DHCP_PARAM_KEY, &DhcpGlobalRegParam,
    &DhcpGlobalRegConfig, DHCP_SUBNETS_KEY, &DhcpGlobalRegSubnets,
    &DhcpGlobalRegConfig, DHCP_MSCOPES_KEY, &DhcpGlobalRegMScopes,
    &DhcpGlobalRegConfig, DHCP_OPTION_INFO_KEY, &DhcpGlobalRegOptionInfo,
    &DhcpGlobalRegConfig, DHCP_GLOBAL_OPTIONS_KEY, &DhcpGlobalRegGlobalOptions,
    &DhcpGlobalRegConfig, DHCP_SUPERSCOPE_KEY, &DhcpGlobalRegSuperScope,
    
    // S E N T I N E L
    NULL, NULL, NULL
};

ULONG
OpenGlobalRegKeys(
    VOID
)
/*++

Routine Description

    This routine opens the list of keys as specified in the ReadKeyArray
    structure above.  Each key is attempted to be created/opened and if 
    that fails for some reason, then the routine returns the error

    The routine is atomic -- in case of failure all the keys are closed.

Return Value

    Registry Errors

--*/
{
    ULONG i, Error, KeyDisposition;

    Error = ERROR_SUCCESS;
    for( i = 0 ; NULL !=  ReadKeyArray[i].Key ; i ++ ) {
        Error = DhcpRegCreateKey(
            ( (NULL == ReadKeyArray[i].KeyBase) ? 
              HKEY_LOCAL_MACHINE : *(ReadKeyArray[i].KeyBase) ),
            ReadKeyArray[i].KeyName,
            ReadKeyArray[i].Key,
            &KeyDisposition
            );

        if( ERROR_SUCCESS != Error ) break;
    }

    if( ERROR_SUCCESS == Error ) return ERROR_SUCCESS;

    DhcpPrint((DEBUG_ERRORS, "RegCreateKeyEx(%ws): %ld\n", 
               ReadKeyArray[i].KeyName, Error));
    while ( i != 0 ) {
        i --;

        RegCloseKey( *(ReadKeyArray[i].Key) );
        *(ReadKeyArray[i].Key) = NULL;
    }

    return Error;
}

VOID
CloseGlobalRegKeys(
    VOID
)
/*++

Routine Description

   This routine undoes the effect of the previous routine.
   It closes any open key handles in the array.

--*/
{
    ULONG i;

    for(i = 0; NULL != ReadKeyArray[i].Key ; i ++ ) {
        if( NULL != *(ReadKeyArray[i].Key) 
            && INVALID_HANDLE_VALUE != *(ReadKeyArray[i].Key) ) {
            RegCloseKey( *(ReadKeyArray[i].Key) );
            *(ReadKeyArray[i].Key) = NULL;
        }
    }
}

BOOL
InterfaceInBindList(
    IN LPCWSTR If,
    IN LPCWSTR BindList
    )
/*++

Routine Description:
    This routine makes a quick check to see if a given interface
    is present in the BIND list or not..

Return Values:
    TRUE -- yes
    FALSE -- no

--*/
{
    for(; wcslen(BindList) != 0; BindList += wcslen(BindList)+1 ) {
        LPWSTR IfString = wcsrchr(BindList, DHCP_KEY_CONNECT_CHAR);
        if( NULL == IfString ) continue;
        IfString ++;
        
        if( 0 == wcscmp(If, IfString) ) return TRUE;
    }
    return FALSE;
}        

DWORD
DhcpInitializeRegistry(
    VOID
    )
/*++

Routine Description:

    This function initializes DHCP registry information when the
    service boots. 
    
    Also creates the directories specified for various paths if they
    are not already created.

Arguments:

    none.

Return Value:

    Registry Errors.

--*/
{
    ULONG i, Error, Tmp;
    BOOL BoolError;

    DatabaseName = NULL;

    //
    // Create/Open Registry keys.
    //

    Error = OpenGlobalRegKeys();
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    //
    // Read in the quick bind information for Wolfpack
    //

    Error = DhcpRegFillQuickBindInfo();
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Fill QuickBindInfo : %ld\n", Error ));
        Error = ERROR_SUCCESS;
    }

    //
    // Init reg parameters..
    //
    DhcpGlobalOemBackupPath = NULL;
    DhcpGlobalOemRestorePath = NULL;
    
    //
    // read registry parameters.
    //

    for( i = 0 ; NULL != RegParamsArray[i].ValueName ; i ++ ) {
        if( RegParamsArray[i].Flags & VAL_EXPAND ) {
            Error = DhcpRegGetExpandValue(
                RegParamsArray[i].ValueName,
                RegParamsArray[i].ValueType,
                RegParamsArray[i].ResultBuf
                );
            if( ERROR_SUCCESS != Error && ERROR_FILE_NOT_FOUND != Error ) {
                DhcpPrint((DEBUG_ERRORS, "RegGetExpandValue(%ws):%ld\n",
                           RegParamsArray[i].ValueName, Error));
                goto Cleanup;
            }
        } else {
            Error = DhcpRegGetValue(
                DhcpGlobalRegParam,
                RegParamsArray[i].ValueName,
                RegParamsArray[i].ValueType,
                RegParamsArray[i].ResultBuf
                );
        }

        if( ERROR_SUCCESS != Error ) {
            if( VAL_REQD & (RegParamsArray[i].Flags ) ) {
                DhcpPrint((DEBUG_ERRORS, "Value: %ws, Error %ld\n",
                           RegParamsArray[i].ValueName, Error ));
                goto Cleanup;
            } else if( REG_DWORD == RegParamsArray[i].ValueType ) {
                *((PULONG)RegParamsArray[i].ResultBuf) = RegParamsArray[i].dwDefault;
            }
        }
    } // for i

    if( NULL == DhcpGlobalOemBackupPath ) {
        //
        // if the backup path is not specified, use database path +
        // "\backup".
        //
        
        DhcpGlobalOemBackupPath = DhcpAllocateMemory(
            strlen(DhcpGlobalOemDatabasePath) +
            strlen(DHCP_DEFAULT_BACKUP_PATH_NAME) + 1
            );
        
        if( NULL == DhcpGlobalOemBackupPath ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        strcpy( DhcpGlobalOemBackupPath, DhcpGlobalOemDatabasePath );
        strcat( DhcpGlobalOemBackupPath, DHCP_KEY_CONNECT_ANSI );
        strcat( DhcpGlobalOemBackupPath, DHCP_DEFAULT_BACKUP_PATH_NAME );
    }

    //
    // Create database directory if not there..
    //
    BoolError = CreateDirectoryPathOem(
        DhcpGlobalOemDatabasePath, DhcpGlobalSecurityDescriptor
        );
    Error = ( BoolError ? ERROR_SUCCESS : GetLastError() );
    if( ERROR_SUCCESS != Error && ERROR_ALREADY_EXISTS != Error ) {
	DhcpServerEventLog( EVENT_SERVER_DB_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE,
			    Error );
        DhcpPrint((DEBUG_ERRORS,
                   "Can't create database directory, %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // create the backup directory if it is not there.
    //

    BoolError = CreateDirectoryPathOem(
        DhcpGlobalOemBackupPath, DhcpGlobalSecurityDescriptor
        );
    Error = ( BoolError ? ERROR_SUCCESS : GetLastError() );
    if( ERROR_SUCCESS != Error && ERROR_ALREADY_EXISTS != Error ) {

	DhcpServerEventLog( EVENT_SERVER_BACKUP_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE,
			    Error );

        DhcpPrint((DEBUG_ERRORS,
                   "Can't create backup directory, %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // make jet backup path name.
    //

    DhcpGlobalOemJetBackupPath = DhcpAllocateMemory(
        strlen(DhcpGlobalOemBackupPath)
        + strlen(DHCP_KEY_CONNECT_ANSI) + 1
        );

    if( DhcpGlobalOemJetBackupPath == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    strcpy( DhcpGlobalOemJetBackupPath, DhcpGlobalOemBackupPath );
    strcat( DhcpGlobalOemJetBackupPath, DHCP_KEY_CONNECT_ANSI );

    if( NULL != DhcpGlobalOemRestorePath ) {
        DhcpGlobalOemJetRestorePath = DhcpAllocateMemory(
            strlen(DhcpGlobalOemRestorePath)
            + strlen(DHCP_KEY_CONNECT_ANSI) + 1
            );

        if( DhcpGlobalOemJetRestorePath == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        strcpy( DhcpGlobalOemJetRestorePath, DhcpGlobalOemRestorePath );
    } // if 
    
    //
    // create the JET backup directory if it is not there.
    //

    BoolError = CreateDirectoryPathOem(
        DhcpGlobalOemJetBackupPath, DhcpGlobalSecurityDescriptor
        );
    Error = ( BoolError ? ERROR_SUCCESS : GetLastError() );
    if( ERROR_SUCCESS != Error && ERROR_ALREADY_EXISTS != Error ) {
	DhcpServerEventLog( EVENT_SERVER_BACKUP_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE,
			    Error );

        DhcpPrint(( DEBUG_ERRORS,
                    "Can't create JET backup directory, %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // make backup configuration (full) file name.
    //

    DhcpGlobalBackupConfigFileName =  DhcpAllocateMemory(( 
        strlen(DhcpGlobalOemBackupPath)
        + wcslen(DHCP_KEY_CONNECT)
        + wcslen(DHCP_BACKUP_CONFIG_FILE_NAME) + 1  
        ) * sizeof(WCHAR) );

    if( DhcpGlobalBackupConfigFileName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // convert oem path to unicode path.
    //

    DhcpGlobalBackupConfigFileName =  DhcpOemToUnicode(
        DhcpGlobalOemBackupPath,
        DhcpGlobalBackupConfigFileName 
        );

    DhcpAssert( DhcpGlobalBackupConfigFileName != NULL );

    //
    // add file name.
    //

    wcscat( DhcpGlobalBackupConfigFileName, DHCP_KEY_CONNECT );
    wcscat( DhcpGlobalBackupConfigFileName, DHCP_BACKUP_CONFIG_FILE_NAME );

    DhcpGlobalOemDatabaseName = DhcpUnicodeToOem(
        DatabaseName, NULL 
        );

    if( DhcpGlobalOemDatabaseName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Upgrade from old fmt to new fmt..
    //
    CloseGlobalRegKeys();
    
    Error = DhcpUpgradeConfiguration();
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Upgrade registry failed: 0x%lx\n",
                   Error));
        goto Cleanup;
    }

    Error = OpenGlobalRegKeys();
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Registry reopen failed: 0x%lx\n",
                   Error));
        goto Cleanup;
    }

    //
    // convert from mins to msecs.
    //

    Tmp = DhcpGlobalBackupInterval * 60000;
    if( 0 == Tmp || (Tmp / 60000) != DhcpGlobalBackupInterval ) {
        Tmp = DEFAULT_BACKUP_INTERVAL;
    }

    DhcpGlobalBackupInterval = Tmp;

    Tmp = DhcpGlobalCleanupInterval * 60000;
    if( 0 == Tmp || (Tmp / 60000) != DhcpGlobalCleanupInterval ) {
        Tmp = DHCP_DATABASE_CLEANUP_INTERVAL;
    }

    DhcpGlobalCleanupInterval = Tmp;

    //
    // validate
    //
    
    if( DhcpGlobalDetectConflictRetries > MAX_DETECT_CONFLICT_RETRIES ) {
        DhcpGlobalDetectConflictRetries = MAX_DETECT_CONFLICT_RETRIES;
    }

    DhcpGlobalDynamicBOOTPEnabled = (EnableDynBootp)? TRUE: FALSE;

    Error = ERROR_SUCCESS;

Cleanup:

    if( DatabaseName != NULL ) {
        MIDL_user_free( DatabaseName );
    }

    return(Error);
}



VOID
DhcpCleanupRegistry(
    VOID
    )
/*++

Routine Description:

    This function closes DHCP registry information when the service
    shuts down.

Arguments:

    none.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;

    if( DhcpGlobalRegSuperScope != NULL) {              // added by t-cheny:
        Error = RegCloseKey( DhcpGlobalRegSuperScope ); // superscope
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegSuperScope = NULL;
    }

    if( DhcpGlobalRegGlobalOptions != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegGlobalOptions );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegGlobalOptions = NULL;
    }

    if( DhcpGlobalRegOptionInfo != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegOptionInfo );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegOptionInfo = NULL;
    }

    if( DhcpGlobalRegSubnets != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegSubnets );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegSubnets = NULL;
    }

    if( DhcpGlobalRegMScopes != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegMScopes );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegMScopes = NULL;
    }

    if( DhcpGlobalRegParam != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegParam );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegParam = NULL;
    }

    if( DhcpGlobalRegConfig != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegConfig );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegConfig = NULL;
    }

    if( DhcpGlobalRegRoot != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegRoot );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegRoot = NULL;
    }

    if( DhcpGlobalRegSoftwareRoot != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegSoftwareRoot );
        DhcpAssert( ERROR_SUCCESS == Error );
        DhcpGlobalRegSoftwareRoot = NULL;
    }
    
} // DhcpCleanupRegistry()

DWORD
DhcpSaveOrRestoreConfigToFile(
    IN HKEY hKey,
    IN LPWSTR ConfigFileName,
    IN BOOL fRestore
    )
/*++

Routine Description:
    This routine backs up or restores the dhcp configuration between
    the registry and the file.

Arguments:
    hKey -- key to backup or restore onto
    ConfigFileName -- file name to use to backup onto or restore from.
        This must be full path name.
    fRestore -- TRUE ==> do a restore from file; FALSE => do backup to
        file.

Return Values:
    Win32 errors...

--*/
{
    DWORD Error;
    BOOL fError;
    BOOLEAN WasEnable;
    NTSTATUS NtStatus;
    HANDLE ImpersonationToken;

    DhcpPrint((DEBUG_REGISTRY, "DhcpSaveOrRestoreConfigToFile called:"
               " %ws, 0x%lx\n", ConfigFileName, fRestore ));

    if( FALSE == fRestore ) {
        //
        // If backing up, delete the old file.
        //
        fError = DeleteFile( ConfigFileName );
        if(FALSE == fError ) {
            Error = GetLastError();
            if( ERROR_FILE_NOT_FOUND != Error &&
                ERROR_PATH_NOT_FOUND != Error ) {
                DhcpPrint((DEBUG_ERRORS, "Can't delete old "
                           "configuration file: 0x%ld\n", Error));
                DhcpAssert(FALSE);
                return Error;
            }
        }
    } // if not restore

    //
    // Impersonate to self.
    //
    NtStatus = RtlImpersonateSelf( SecurityImpersonation );
    if( !NT_SUCCESS(NtStatus) ) {

        DhcpPrint((DEBUG_ERRORS, "Impersonation failed: 0x%lx\n",
                   NtStatus));
        Error = RtlNtStatusToDosError( NtStatus );
        return Error;
    }
    
    NtStatus = RtlAdjustPrivilege(
        SE_BACKUP_PRIVILEGE,
        TRUE, // enable privilege
        TRUE, // adjust client token
        &WasEnable
        );
    if( !NT_SUCCESS (NtStatus ) ) {
        
        DhcpPrint((DEBUG_ERRORS, "RtlAdjustPrivilege: 0x%lx\n",
                   NtStatus ));
        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    
    NtStatus = RtlAdjustPrivilege(
        SE_RESTORE_PRIVILEGE,
        TRUE, // enable privilege
        TRUE, // adjust client token
        &WasEnable
        );
    if( !NT_SUCCESS (NtStatus ) ) {

        DhcpPrint((DEBUG_ERRORS, "RtlAdjustPrivilege: 0x%lx\n",
                   NtStatus ));
        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    
    //
    // Backup or restore appropriately.
    //
    
    if( FALSE == fRestore ) {
        Error = RegSaveKey( hKey, ConfigFileName, NULL );
    } else {
        Error = RegRestoreKey( hKey, ConfigFileName, REG_FORCE_RESTORE );
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Backup/Restore: 0x%lx\n", Error));
    }
    
    //
    // revert impersonation.
    //

Cleanup:
    
    ImpersonationToken = NULL;
    NtStatus = NtSetInformationThread(
        NtCurrentThread(),
        ThreadImpersonationToken,
        (PVOID)&ImpersonationToken,
        sizeof(ImpersonationToken)
        );
    if( !NT_SUCCESS(NtStatus ) ) {
        DhcpPrint((DEBUG_ERRORS, "NtSetInfo: 0x%lx\n", NtStatus));
        if( ERROR_SUCCESS == Error ) {
            Error = RtlNtStatusToDosError(NtStatus);
        }
    }
    
    return Error;
}

DWORD
DhcpSaveOrRestoreConfigToFileEx(
    IN LPWSTR KeyName,
    IN LPWSTR ConfigFileName,
    IN BOOL fRestore
    )
/*++

Routine Description:
    This is the same as DhcpSaveOrRestoreConfigToFile except that the
    required registry key is opened within this routine.

    See DhcpSaveOrRestoreConfigToFile for details.

--*/
{
    HKEY hKey;
    ULONG Error, KeyDisp;

    if( TRUE == fRestore ) {
        Error = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            KeyName,
            0,
            DHCP_CLASS,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &KeyDisp
            );
    } else {
        Error = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            KeyName,
            0,
            DHCP_KEY_ACCESS,
            &hKey
            );
    }
    
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((
            DEBUG_ERRORS, "DhcpSaveOrRestoreConfigToFileEx: 0x%lx\n",
            Error));
        return Error;
    }

    Error = DhcpSaveOrRestoreConfigToFile(
        hKey, ConfigFileName, fRestore
        );

    RegCloseKey(hKey);
    return Error;
}

DWORD
DhcpRegDeleteKeyByName
(
    IN LPWSTR Parent,
    IN LPWSTR SubKey
)
{
    HKEY hKey;
    ULONG Error;
    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        Parent,
        0,
        DHCP_KEY_ACCESS,
        &hKey
        );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegDeleteKey(hKey, SubKey);
    RegCloseKey(hKey);

    return Error;
}
        
DWORD
DhcpUpgradeConfiguration(
    VOID
    )
/*++

Routine Description:
    This routine attempts to upgrade the registry key from 4.0
    location to Nt 5.0 location by doing the foll steps:
    1.  First attempt to save the current configuration key..
    2.  If key doesn't exist, done.  Else if success delete key.
    3.  If delete failed, restore key and return error. else
        restore key in new location and return error..

--*/
{
    ULONG Error;
    LPWSTR ConfigFileName = DhcpGlobalBackupConfigFileName;

    //
    // First save current configuration..
    //
    Error = DhcpSaveOrRestoreConfigToFileEx(
        DHCP_ROOT_KEY L"\\" DHCP_CONFIG_KEY,
        ConfigFileName,
        /* fRestore */ FALSE
        );
    if( ERROR_SUCCESS != Error ) {
        if( ERROR_FILE_NOT_FOUND == Error ) {
            //
            // No key at all..
            //
            return ERROR_SUCCESS;
        }
        DhcpPrint((DEBUG_ERRORS, "Saving registry: 0x%lx\n", Error));
    }

    //
    // now try to restore onto new location..
    //
    Error = DhcpSaveOrRestoreConfigToFileEx(
        DHCP_SWROOT_KEY L"\\" DHCP_CONFIG_KEY,
        ConfigFileName,
        /* fRestore */ TRUE
        );
    if( ERROR_SUCCESS != Error ) {
        //
        // Aargh. this is a pain.
        //
        DhcpPrint((DEBUG_ERRORS, "Restore registry: 0x%lx\n", Error));
        return Error;
    }

    //
    // Now just delete the old key so that we don't read it next time.
    //
    Error = DhcpRegDeleteKeyByName(
        DHCP_ROOT_KEY,
        DHCP_CONFIG_KEY
        );
    if( ERROR_SUCCESS != Error ) {
        ULONG NextError = DhcpSaveOrRestoreConfigToFileEx(
            DHCP_ROOT_KEY L"\\" DHCP_CONFIG_KEY,
            ConfigFileName,
            /* fRestore */ TRUE
            );

        DhcpPrint((DEBUG_ERRORS, "Delete old registry: 0x%lx\n", Error));
        if( ERROR_SUCCESS == NextError ) return Error;
    }

    return Error;
} // DhcpUpgradeConfiguration()

DWORD
DhcpBackupConfiguration(
    LPWSTR BackupFileName
    )
/*++

Routine Description:

    This function backups/saves the dhcp configuration key and its
    subkeys in the specified file. This file may be used later to
    restore this key.

Arguments:

    BackupFileName : full qualified path name + file name where the key
        is saved.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    BOOL BoolError;
    NTSTATUS NtStatus;
    BOOLEAN WasEnable;
    HANDLE ImpersonationToken;

    DhcpPrint(( DEBUG_REGISTRY, "DhcpBackupConfiguration called.\n" ));

    //
    // Delete old backup configuration file if exits.
    //

    BoolError = DeleteFile( BackupFileName );

    if( BoolError == FALSE ) {

        Error = GetLastError();
        if( ERROR_FILE_NOT_FOUND != Error 
            && ERROR_PATH_NOT_FOUND != Error  ) {
            DhcpPrint(( DEBUG_ERRORS,
                        "Can't delete old backup configuration file %ws, %ld.\n",
                        BackupFileName, Error ));
            DhcpAssert( FALSE );
            goto Cleanup;
        }
    } // if DeleteFile failed

    //
    // impersonate to self.
    //

    NtStatus = RtlImpersonateSelf( SecurityImpersonation );

    if ( !NT_SUCCESS(NtStatus) ) {

        DhcpPrint(( DEBUG_ERRORS,
            "RtlImpersonateSelf failed,%lx.\n",
                NtStatus ));

        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    } // if impersonation failed


    NtStatus = RtlAdjustPrivilege(
        SE_BACKUP_PRIVILEGE,
        TRUE,           // enable privilege.
        TRUE,           // adjust the client token.
        &WasEnable );
    
    if ( !NT_SUCCESS(NtStatus) ) {
        
        DhcpPrint(( DEBUG_ERRORS,
            "RtlAdjustPrivilege failed,%lx.\n",
                NtStatus ));

        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    } // if

    LOCK_REGISTRY();

    //
    // backup configuation key.
    //

    Error = RegSaveKey(
		       DhcpGlobalRegParam,
		       BackupFileName,
		       NULL );
    
    UNLOCK_REGISTRY();

    if( Error != ERROR_SUCCESS ) {
       DhcpPrint(( DEBUG_ERRORS, "RegSaveKey failed for %ws Error: %ld.\n",
		   BackupFileName, Error ));
    }

    //
    // revert impersonation.
    //

    ImpersonationToken = NULL;
    NtStatus = NtSetInformationThread(
        NtCurrentThread(),
        ThreadImpersonationToken,
        (PVOID)&ImpersonationToken,
        sizeof(ImpersonationToken) );

    if ( !NT_SUCCESS(NtStatus) ) {

        DhcpPrint(( DEBUG_ERRORS,
            "RtlAdjustPrivilege failed,%lx.\n",
                NtStatus ));

        goto Cleanup;
    } // if

Cleanup:

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_REGISTRY,
            "DhcpBackupConfiguration failed, %ld.\n",
                Error ));
    }

    return( Error );
} // DhcpBackupConfiguration()

DWORD
DhcpCheckPathForRegKey
(
   LPWSTR RegKey,
   DWORD  Type
)
{
#define UNICODE_MAX_PATH_LEN   1000

    LPWSTR             DirPath;
    DWORD              DirPathLen;
    LPWSTR             ExpandedPath;
    DWORD              ExpPathLen;
    DWORD              Error;
    HKEY               Key;
    HANDLE             fHandle;
    WIN32_FILE_ATTRIBUTE_DATA AttribData;
    BOOL               Success;
    
    DhcpAssert( NULL != RegKey );

    Error = ERROR_SUCCESS;

    // Get a handle for the key
    DhcpPrint(( DEBUG_REGISTRY,
		"Checking %ws....\n", RegKey ));
    
    // Read the contents
    // mem is allocated for DirPath
    Error = DhcpRegGetValue( DhcpGlobalRegParam,
			     RegKey, Type,
			     ( LPBYTE ) &DirPath );

    if ( ERROR_SUCCESS != Error) {
	return Error;
    }

//      DhcpPrint(( DEBUG_REGISTRY,
//  		"Checking DirPathh : %ws\n", DirPath ));

    // Expand DirPath
    
    DirPathLen = ( wcslen( DirPath ) + 1 ) * sizeof( WCHAR );

    ExpandedPath = DhcpAllocateMemory( UNICODE_MAX_PATH_LEN );
    if ( NULL == ExpandedPath ) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    ExpPathLen = ExpandEnvironmentStrings( DirPath, ExpandedPath, wcslen( DirPath ) + 1);
    // ExpPathLen contains # of unicode chars 
    DhcpAssert( ExpPathLen < UNICODE_MAX_PATH_LEN / sizeof( WCHAR ));

    DhcpPrint(( DEBUG_REGISTRY, 
		"Expanded String = %ws\n",
		ExpandedPath ));

    // The path may no longer exist or may not be accessible. In this
    // case, reset the key to the default value.
    // 

    // Search for the path. We are searching for the directory, not the files
    // in that directory.

    Success = GetFileAttributesEx( ExpandedPath,
				   GetFileExInfoStandard,
				   & AttribData );
    if ( Success ) {
	// Search is successful. Check for the attributes.
	// It should be a directory and not read-only
	if ( !( AttribData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ||
	     ( AttribData.dwFileAttributes & FILE_ATTRIBUTE_READONLY )) {
	    
	    Error = ERROR_ACCESS_DENIED;

	    DhcpPrint(( DEBUG_ERRORS,
			"Access denied for %ws\n", ExpandedPath ));
	} // if

	DhcpPrint(( DEBUG_REGISTRY, 
		    "GetFileAttributesEx(%ws) is successful\n",
		    ExpandedPath ));
    } // if found handle
    else {
	DhcpPrint(( DEBUG_ERRORS,
		    "GetFileAttributesEx() failed for %ws\n", ExpandedPath ));
	Error = GetLastError();
    } // else path is invalid

    // Free the allocated memory
    DhcpFreeMemory( ExpandedPath );
    MIDL_user_free( DirPath );

    return Error;
} // DhcpCheckPathForRegKey()

// 
// When the parameters are restored, the backup paths and other
// file related keys may point to non-existant sources or read-only
// shares/drives. In that case reset these keys to point to the
// standard %SystemRoot%\\System32\\dhcp directory.
// 

DWORD
DhcpCheckPaths( VOID )
{
    DWORD Error;
    DWORD RetVal;

    RetVal = ERROR_SUCCESS;

    DhcpPrint(( DEBUG_REGISTRY, "Checking (%ws) .. \n",
		DHCP_BACKUP_PATH_VALUE ));

    Error = DhcpCheckPathForRegKey( DHCP_BACKUP_PATH_VALUE,
				    DHCP_BACKUP_PATH_VALUE_TYPE );    
    if ( ERROR_SUCCESS != Error ) {
	RetVal = Error;

	DhcpServerEventLog( EVENT_SERVER_BACKUP_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE, Error );
    }
    DhcpPrint(( DEBUG_REGISTRY, "Returned %ld\n", Error ));

    DhcpPrint(( DEBUG_REGISTRY, "Checking (%ws) .. \n",
		DHCP_DB_PATH_VALUE ));
    Error = DhcpCheckPathForRegKey( DHCP_DB_PATH_VALUE,
				    DHCP_DB_PATH_VALUE_TYPE );
    if ( ERROR_SUCCESS != Error ) {
	RetVal = Error;

	DhcpServerEventLog( EVENT_SERVER_DB_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE, Error );
    }
    DhcpPrint(( DEBUG_REGISTRY, "Returned %ld\n", Error ));
	
    DhcpPrint(( DEBUG_REGISTRY, "Checking (%ws) .. \n",
		DHCP_LOG_FILE_PATH_VALUE ));
    Error = DhcpCheckPathForRegKey( DHCP_LOG_FILE_PATH_VALUE,
				    DHCP_LOG_FILE_PATH_VALUE_TYPE );
    if ( ERROR_SUCCESS != Error ) {
	RetVal = Error;

	DhcpServerEventLog( EVENT_SERVER_AUDITLOG_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE, Error );
    }
    DhcpPrint(( DEBUG_REGISTRY, "Returned %ld\n", Error ));
	
    return RetVal;
} // DhcpCheckPaths()

BOOL DhcpCloseAllSubKeys( VOID )
{
    DWORD Error;

    if( DhcpGlobalRegSubnets != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegSubnets );

        if( Error != ERROR_SUCCESS ) {
            return FALSE;
        }
        DhcpGlobalRegSubnets = NULL;
    } // if

    if( DhcpGlobalRegMScopes != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegMScopes );

        if( Error != ERROR_SUCCESS ) {
	    return FALSE;
        }
        DhcpGlobalRegMScopes = NULL;
    } // if

    if( DhcpGlobalRegOptionInfo != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegOptionInfo );

        if( Error != ERROR_SUCCESS ) {
            return FALSE;
        }
        DhcpGlobalRegOptionInfo = NULL;
    } // if


    if( DhcpGlobalRegGlobalOptions != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegGlobalOptions );

        if( Error != ERROR_SUCCESS ) {
            return FALSE;
        }
        DhcpGlobalRegGlobalOptions = NULL;
    } // if 

    if( DhcpGlobalRegSuperScope != NULL ) {              // added by t-cheny:
        Error = RegCloseKey( DhcpGlobalRegSuperScope );  // superscope

        if( Error != ERROR_SUCCESS ) {
            return FALSE;
        }
        DhcpGlobalRegSuperScope = NULL;
    } // false

    return TRUE;

} //DhcpCloseAllSubKeys()

DWORD
DhcpReOpenAllSubKeys ( VOID )
{
    DWORD KeyDisposition;
    DWORD Error;

    
    Error = DhcpRegCreateKey(
                DhcpGlobalRegConfig,
                DHCP_SUBNETS_KEY,
                &DhcpGlobalRegSubnets,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
        return Error;
    } 

    Error = DhcpRegCreateKey(
                DhcpGlobalRegConfig,
                DHCP_MSCOPES_KEY,
                &DhcpGlobalRegMScopes,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
	return Error;
    }

    Error = DhcpRegCreateKey(
                DhcpGlobalRegConfig,
                DHCP_OPTION_INFO_KEY,
                &DhcpGlobalRegOptionInfo,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
	return Error;
    }

    Error = DhcpRegCreateKey(
                DhcpGlobalRegConfig,
                DHCP_GLOBAL_OPTIONS_KEY,
                &DhcpGlobalRegGlobalOptions,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
        return Error;
    }

    Error = DhcpRegCreateKey(        // added by t-cheny:  superscope
                DhcpGlobalRegConfig,
                DHCP_SUPERSCOPE_KEY,
                &DhcpGlobalRegSuperScope,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
        return Error;
    }

    return ERROR_SUCCESS;
} // DhcpReOpenAllSubKeys()


DWORD
DhcpRestoreConfiguration(
    LPWSTR BackupFileName
    )
/*++

Routine Description:

    This function restores the dhcp configuration key and its
    subkeys in the specified file.

Arguments:

    BackupFileName : full qualified path name + file name from where the
        key is restored.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    NTSTATUS NtStatus;
    BOOLEAN WasEnable;
    HANDLE ImpersonationToken;
    BOOL RegistryLocked = FALSE;
    BOOL Impersonated = FALSE;


    DhcpPrint(( DEBUG_REGISTRY, "DhcpRestoreConfiguration(%ws) called.\n",
		BackupFileName ));

    do {
	//
	// impersonate to self.
	//

	NtStatus = RtlImpersonateSelf( SecurityImpersonation );
	if ( !NT_SUCCESS(NtStatus) ) {

	    DhcpPrint(( DEBUG_ERRORS,
			"RtlImpersonateSelf failed,%lx.\n",
			NtStatus ));

	    Error = RtlNtStatusToDosError( NtStatus );
	    break;
	} // if 

	Impersonated = TRUE;
	NtStatus = RtlAdjustPrivilege(
				      SE_RESTORE_PRIVILEGE,
				      TRUE,           // enable privilege.
				      TRUE,           // adjust the client token.
				      &WasEnable );

	if ( !NT_SUCCESS(NtStatus) ) {

	    DhcpPrint(( DEBUG_ERRORS,
			"RtlAdjustPrivilege failed,%lx.\n",
			NtStatus ));

	    Error = RtlNtStatusToDosError( NtStatus );
	    break;
	} // if

	LOCK_REGISTRY();
	RegistryLocked = TRUE;

	//
	// Restore configuation key.
	//

	DhcpPrint(( DEBUG_REGISTRY,
		    "DhcpRestoreConfiguration(): Restoring Parameters from (%ls)\n", BackupFileName ));
	DhcpAssert( DhcpGlobalRegParam != NULL );
	Error = RegRestoreKey( DhcpGlobalRegParam,
			       BackupFileName,
			       REG_FORCE_RESTORE );

	if( Error != ERROR_SUCCESS ) {
	    DhcpPrint((DEBUG_ERRORS, "DhcpRestoreConfiguration() failed in RegRestoreKey. Error :%ld (%ld)\n",
		       Error, GetLastError()));
	    break;
	} // if

	//
	// Check for valid log paths. Log into eventlog if they are bad
	//

	Error = DhcpCheckPaths();
	DhcpPrint(( DEBUG_REGISTRY, "DhcpCheckPaths() returned : %ld\n", Error ));

	if ( ERROR_SUCCESS != Error ) {
	    break;
	}
    } // do
    while ( FALSE );

    // Cleanup:
    
    if( RegistryLocked ) {
        UNLOCK_REGISTRY();
    }
    
    if( Impersonated ) {
	
        //
        // revert impersonation.
        //

        ImpersonationToken = NULL;
        NtStatus = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        (PVOID)&ImpersonationToken,
                        sizeof(ImpersonationToken) );

        if ( !NT_SUCCESS(NtStatus) ) {

            DhcpPrint(( DEBUG_ERRORS,
                "RtlAdjustPrivilege failed,%lx.\n",
                    NtStatus ));
        }
    } // if impersonated

    return( Error );
} // DhcpRestoreConfiguration()

DHCP_IP_ADDRESS
DhcpRegGetBcastAddress(
    VOID
    )
/*++

Routine Description:
    This routine reads the broadcast address specified for the
    interface in registry. This is used to fake a different broadcast
    address in case of check builds.  Not really that useful...

--*/
{
    HKEY   LinkageKeyHandle = NULL;
    DWORD  Addr = (DWORD)-1, Error;

    //
    // Try to read the parameters key
    //
    Error = RegOpenKeyEx(
        DhcpGlobalRegRoot,
        DHCP_PARAM_KEY,
        0,
        DHCP_KEY_ACCESS,
        &LinkageKeyHandle
        );
    if( ERROR_SUCCESS != Error) {
        return Addr;
    }

    //
    // Try to get the BCAST value.
    //
    Error =  DhcpRegGetValue(
        LinkageKeyHandle,
        DHCP_BCAST_ADDRESS_VALUE,
        DHCP_BCAST_ADDRESS_VALUE_TYPE,
        (LPBYTE)&Addr
        );
    
    RegCloseKey(LinkageKeyHandle);
    if( ERROR_SUCCESS != Error ) {
        return (DWORD)-1;
    }
    return Addr;
}

BOOL
CheckKeyForBindability(
    IN HKEY Key,
    IN ULONG IpAddress
    )
{
    DWORD fBound, Error;
    LPWSTR IpAddressString;

    Error = DhcpRegGetValue(
        Key,
        DHCP_NET_IPADDRESS_VALUE,
        DHCP_NET_IPADDRESS_VALUE_TYPE,
        (LPBYTE)&IpAddressString
        );

    if( NO_ERROR != Error ) return FALSE;
    if( NULL == IpAddressString ) return FALSE;

    fBound = FALSE;
    do {
        LPSTR OemStringPtr;
        CHAR OemString[500];
        
        if( wcslen(IpAddressString) == 0 ) {
            break;
        }

        OemStringPtr = DhcpUnicodeToOem( IpAddressString, OemString );
        fBound = ( IpAddress == inet_addr( OemStringPtr ) );
        
    } while ( 0 );

    if( IpAddressString ) MIDL_user_free(IpAddressString);
    return fBound;
}    
    
BOOL
CheckKeyForBinding(
    IN HKEY Key,
    IN ULONG IpAddress
    )
/*++

Routine Description:
    This routine attempts to check the given interface key to see
    if there is a binding for the dhcp server.

    It does this in two steps: first sees if there is a
    "BindToDHCPServer" regvalue with zero value. If so, it
    then returns FALSE.

    Secondly, it looks through the IP Address values and tries to
    see if the given IP address is the first in that list.

Arguments:
    Key -- the key to use for reading values
    IpAddress -- the Ip address that is to be checked for binding

Return Values:
    TRUE -- binding does exist.
    FALSE -- no binding exists for this IP address.

--*/
{
    DWORD fBound, Error;
    
    Error = DhcpRegGetValue(
        Key,
        DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE,
        DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE,
        (PVOID)&fBound
        );
    if( NO_ERROR == Error && 0 == fBound ) {
        return FALSE;
    }

    return CheckKeyForBindability(Key, IpAddress);
} // CheckKeyForBinding()

ULONG
SetKeyForBinding(
    IN HKEY Key,
    IN ULONG IpAddress,
    IN BOOL fBind
    )
/*++

Routine Description:
    This routine sets the binding for the given key as per the fBind
    flag.  Currently the IpAddress field is ignored as the binding is
    not per IP address.

    The binding is just per interface.

Arguments:
    Key -- interface key.
    IpAddress -- the ip address to add to binding list.
    fBind -- interface to bind to.

Return Value:
    Registry errors.

--*/
{
    ULONG Error;
    
    if( TRUE == fBind ) {
        //
        // If we are binding, we can just remove the fBind key.
        //
        Error = RegDeleteValue(
            Key,
            DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE
            );
        if( ERROR_FILE_NOT_FOUND == Error
            || ERROR_PATH_NOT_FOUND == Error ) {
            Error = NO_ERROR;
        }
        
    } else {
        DWORD dwBind = fBind;
        //
        // We are _not_ binding. Explicity set the registry flag.
        //
        Error = RegSetValueEx(
            Key,
            DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE,
            0, /* Reserved */
            DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE,
            (PVOID)&dwBind,
            sizeof(dwBind)
        );
    }

    return Error;
}

BOOL
DhcpCheckIfDatabaseUpgraded(
    BOOL fRegUpgrade
    )
/*++

Routine Description:

    This routine tries to check if an upgrade is needed or not.

Arguments:

    fRegUpgrade -- If this is TRUE, the the upgrade check is to
    see if there is need for converting the registry to
    database.  If it is FALSE, then the check is to see if a
    conversion needs to be done for just the database.
    
    Note: The database conversion should always be attempted
    before the registry conversion.

Return Values:

    FALSE -- this is not the required upgrade path.
    TRUE -- yes, the upgrade path must be executed.
    
--*/
{
    HKEY hKey;
    DWORD Error, Type, Value, Size;

    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    if( NO_ERROR != Error ) return FALSE;

    Type = REG_DWORD; Value = 0; Size = sizeof(Value);
    Error = RegQueryValueEx(
        hKey, TEXT("Version"), NULL, &Type, (PVOID)&Value, &Size );

    RegCloseKey( hKey );

    //
    // if this value is not present, then upgrade is needed.  If
    // the value is zero then only a Registry upgrade is needed
    // and the database upgrade has been taken care of
    //

    if( NO_ERROR != Error ) return TRUE;
    if( fRegUpgrade && Value == 0 ) return TRUE;

    //
    // No upgrades needed, all have been taken care of
    //
    
    return FALSE;
} // DhcpCheckIfDatabaseUpgraded()


DWORD
DhcpSetRegistryUpgradedToDatabaseStatus(
    VOID
    )
{
    DWORD Error;
    HKEY hKey;
    
    //
    // Attempt to write the version key
    //
    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_WRITE, &hKey );

    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "OpenKeyEx: %ld\n", Error ));
    } else {
        DWORD Version = GetVersion(), Size = sizeof(Version);

        Error = RegSetValueEx(
            hKey, TEXT("Version"), 0, REG_DWORD, (PVOID)&Version,
            Size );

        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx: %ld\n", Error));
        RegCloseKey( hKey );
    } // else

    return Error;
} // DhcpSetRegistryUpgradedToDatabaseStatus()

DWORD
DeleteSoftwareRootKey(
    VOID
    )
{
    DWORD Error;
    
    DhcpCleanupRegistry();
    Error = DhcpRegDeleteKeyByName( DHCP_SWROOT_KEY, DHCP_CONFIG_KEY );
    if( NO_ERROR != Error ) return Error;
    
    return OpenGlobalRegKeys();
} // DeleteSoftwareRootKey()

//
//  End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcprpc.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    dhcprpc.c

Abstract:
    This module just includes some rpc files to get
    over pre-compilation woes.

--*/

#include <dhcppch.h>

#include "dhcp_srv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcpwriter.cpp ===
// for some reason the compiler is not setting this #def when compiling this file

#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include "dhcp.h"
#include "debug.h"
#include "dhcpwriter.h"


// These defines are here since header file dependencies
// are incorrect for the rest of the files.

#define DHCP_SERVICE_NAME L"DhcpServer"

// These keys are borrowed from dhcpreg.h since it cannot be safely 
// included in this CPP file.

#define DHCP_PARAM_KEY L"System\\CurrentControlSet\\Services\\DhcpServer\\Parameters"

#define DB_PATH_VALUE L"DatabasePath"
#define DB_PATH_VALUE_TYPE  REG_EXPAND_SZ

#define BACKUP_PATH_VALUE L"BackupDatabasePath"
#define BACKUP_PATH_VALUE_TYPE  REG_EXPAND_SZ

// {BE9AC81E-3619-421f-920F-4C6FEA9E93AD}
namespace {
    const GUID g_GuidDhcpWriter = 
        { 0xbe9ac81e, 0x3619, 0x421f, { 0x92, 0xf, 0x4c, 0x6f, 0xea, 0x9e, 0x93, 0xad } };
}; // anonymous


/////////////////////////////////////////////////////////////////
// Implementation of the CDhcpVssJetWriter starts here
//
HRESULT CDhcpVssJetWriter::Initialize()
{

    return  CVssJetWriter::Initialize( g_GuidDhcpWriter, DHCPWRITER_NAME,
                                       TRUE, FALSE, L"", L"" );
}

HRESULT CDhcpVssJetWriter::Terminate()
{
    CVssJetWriter::Uninitialize();

    return S_OK;
}

bool STDMETHODCALLTYPE
CDhcpVssJetWriter::OnIdentify( IN IVssCreateWriterMetadata *pMetadata )
{

    pMetadata->SetRestoreMethod( VSS_RME_RESTORE_AT_REBOOT,
                                 DHCP_SERVICE_NAME, NULL,
                                 VSS_WRE_IF_REPLACE_FAILS, false );
    return true;
} // OnIdentify()

//
// Implementation of the CDhcpVssJetWriter ends here
/////////////////////////////////////////////////////////////////

// writer instance
namespace {
    CDhcpVssJetWriter   g_DhcpWriter;
    HRESULT             g_ComInitResult;
}; // anonymous

DWORD __cdecl DhcpWriterInit()
{
    DhcpPrint(( DEBUG_INIT, "Initializing DHCP writer()\n" ));

    HRESULT hr;

    g_ComInitResult = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED( g_ComInitResult ) &&
         ( RPC_E_CHANGED_MODE != g_ComInitResult ))
    {
        DhcpPrint(( DEBUG_ERRORS,"CoInitializeEx failed with result =%x.\n",
                    g_ComInitResult ));
        return HRESULT_CODE( g_ComInitResult );
    }

    hr = CoInitializeSecurity( NULL,
                               -1,
                               NULL,
                               NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IDENTIFY,
                               NULL,
                               EOAC_NONE,
                               NULL);

    if ( FAILED( hr ) &&
         ( RPC_E_TOO_LATE != hr ))  // If CoInitializeSecurity was not already called
    {
        DhcpPrint(( DEBUG_ERRORS, "CoInitializeSecurity failed with hr=%x.\n", hr ));
        return HRESULT_CODE(hr);
    }

    hr = g_DhcpWriter.Initialize();
    DhcpPrint(( DEBUG_INIT, "DHCP writer Initialized: code hr=0x%08x\n", hr));

    return HRESULT_CODE(hr);
} // DhcpWriterInit()

DWORD __cdecl DhcpWriterTerm()
{

    if (SUCCEEDED( g_ComInitResult )) {
        DhcpPrint(( DEBUG_MISC, "DhcpWriterTerm : Terminating ...\n" ));
        g_DhcpWriter.Terminate();

        DhcpPrint(( DEBUG_MISC, "Calling CoUnIninitialize() ...\n" ));
        CoUninitialize();

    } // if 
    DhcpPrint(( DEBUG_MISC, "DhcpWriterTerm : Done Termination. \n" ));

    return ERROR_SUCCESS;
} // DhcpWriterTerm()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcpreg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Dhcpreg.h

Abstract:

    This file contains registry definitions that are required to hold
    dhcp configuration parameters.

Author:

    Madan Appiah  (madana)  19-Sep-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#define DHCP_SERVER_PRIMARY                       1
#define DHCP_SERVER_SECONDARY                     2

#define SERVICES_KEY                              L"System\\CurrentControlSet\\Services\\"

#define ADAPTER_TCPIP_PARMS_KEY                   L"TCPIP\\Parameters\\Interfaces\\"
#define ADAPTER_TCPIP_PREFIX                      L"\\Device\\"

#define DHCP_SWROOT_KEY                           L"Software\\Microsoft\\DhcpServer"
#define DHCP_ROOT_KEY                             L"System\\CurrentControlSet\\Services\\DhcpServer"
#define DHCP_CLASS                                L"DhcpClass"
#define DHCP_CLASS_SIZE                           sizeof(DHCP_CLASS)
#define DHCP_KEY_CONNECT                          L"\\"
#define DHCP_KEY_CONNECT_ANSI                     "\\"
#define DHCP_KEY_CONNECT_CHAR                     L'\\'
#define DHCP_DEFAULT_BACKUP_PATH_NAME             "Backup"
#define DHCP_BACKUP_CONFIG_FILE_NAME              L"DhcpCfg"

#define DHCP_DEFAULT_BACKUP_DB_PATH               L"%SystemRoot%\\System32\\dhcp\\backup"
#define DHCP_DEFAULT_DB_PATH                      L"%SystemRoot%\\System32\\dhcp"
#define DHCP_DEFAULT_LOG_FILE_PATH                L"%SystemRoot%\\System32\\dhcp\\backup"

//
// DHCP subkey names.
//

#define DHCP_CONFIG_KEY                           L"Configuration"
#define DHCP_PARAM_KEY                            L"Parameters"

//
// Subkeys of configuration
//

#define DHCP_SUBNETS_KEY                          L"Subnets"
#define DHCP_MSCOPES_KEY                          L"MulticastScopes"
#define DHCP_SERVERS_KEY                          L"DHCPServers"
#define DHCP_IPRANGES_KEY                         L"IpRanges"
#define DHCP_RESERVED_IPS_KEY                     L"ReservedIps"
#define DHCP_SUBNET_OPTIONS_KEY                   L"SubnetOptions"

#define DHCP_OPTION_INFO_KEY                      L"OptionInfo"
#define DHCP_GLOBAL_OPTIONS_KEY                   L"GlobalOptionValues"
#define DHCP_RESERVED_OPTIONS_KEY                 L"ReservedOptionValues"
#define DHCP_SUPERSCOPE_KEY                       L"SuperScope"

//
// DHCP value field names.
//

#define DHCP_LAST_DOWNLOAD_TIME_VALUE             L"LastDownloadTime"
#define DHCP_LAST_DOWNLOAD_TIME_TYPE              REG_BINARY

#define DHCP_BOOT_FILE_TABLE                      L"BootFileTable"
#define DHCP_BOOT_FILE_TABLE_TYPE                 REG_MULTI_SZ

//
// Option value field names.
//

#define DHCP_OPTION_ID_VALUE                      L"OptionID"
#define DHCP_OPTION_ID_VALUE_TYPE                 REG_DWORD

#define DHCP_OPTION_NAME_VALUE                    L"OptionName"
#define DHCP_OPTION_NAME_VALUE_TYPE               REG_SZ

#define DHCP_OPTION_COMMENT_VALUE                 L"OptionComment"
#define DHCP_OPTION_COMMENT_VALUE_TYPE            REG_SZ

#define DHCP_OPTION_VALUE_REG                     L"OptionValue"
#define DHCP_OPTION_VALUE_TYPE                    REG_BINARY

#define DHCP_OPTION_TYPE_VALUE                    L"OptionType"
#define DHCP_OPTION_TYPE_VALUE_TYPE               REG_DWORD
//
// subnet value field names.
//

#define DHCP_SUBNET_ADDRESS_VALUE                 L"SubnetAddress"
#define DHCP_SUBNET_ADDRESS_VALUE_TYPE            REG_DWORD

#define DHCP_SUBNET_MASK_VALUE                    L"SubnetMask"
#define DHCP_SUBNET_MASK_VALUE_TYPE               REG_DWORD

#define DHCP_SUBNET_NAME_VALUE                    L"SubnetName"
#define DHCP_SUBNET_NAME_VALUE_TYPE               REG_SZ

#define DHCP_SUBNET_COMMENT_VALUE                 L"SubnetComment"
#define DHCP_SUBNET_COMMENT_VALUE_TYPE            REG_SZ

#define DHCP_SUBNET_EXIP_VALUE                    L"ExcludedIpRanges"
#define DHCP_SUBNET_EXIP_VALUE_TYPE               REG_BINARY

#define DHCP_SUBNET_STATE_VALUE                   L"SubnetState"
#define DHCP_SUBNET_STATE_VALUE_TYPE              REG_DWORD

#define DHCP_SUBNET_SWITCHED_NETWORK_VALUE        L"SwitchedNetworkFlag"
#define DHCP_SUBNET_SWITCHED_NETWORK_VALUE_TYPE   REG_DWORD

//
// DHCP server info fields names.
//

#define DHCP_SRV_ROLE_VALUE                       L"Role"
#define DHCP_SRV_ROLE_VALUE_TYPE                  REG_DWORD

#define DHCP_SRV_IP_ADDRESS_VALUE                 L"ServerIpAddress"
#define DHCP_SRV_IP_ADDRESS_VALUE_TYPE            REG_DWORD

#define DHCP_SRV_HOST_NAME                        L"ServerHostName"
#define DHCP_SRV_HOST_NAME_TYPE                   REG_SZ

#define DHCP_SRV_NB_NAME                          L"ServerNetBiosName"
#define DHCP_SRV_NB_NAME_TYPE                     REG_SZ

//
// IpRange info fields names.
//

#define DHCP_IPRANGE_START_VALUE                  L"StartAddress"
#define DHCP_IPRANGE_START_VALUE_TYPE             REG_DWORD

#define DHCP_IPRANGE_END_VALUE                    L"EndAddress"
#define DHCP_IPRANGE_END_VALUE_TYPE               REG_DWORD

#define DHCP_IP_USED_CLUSTERS_VALUE               L"UsedClusters"
#define DHCP_IP_USED_CLUSTERS_VALUE_TYPE          REG_BINARY

#define DHCP_IP_INUSE_CLUSTERS_VALUE              L"InUseClusters"
#define DHCP_IP_INUSE_CLUSTERS_VALUE_TYPE         REG_BINARY

//
// Reserved IP info field names.
//

#define DHCP_RIP_ADDRESS_VALUE                    L"IpAddress"
#define DHCP_RIP_ADDRESS_VALUE_TYPE               REG_DWORD

#define DHCP_RIP_CLIENT_UID_VALUE                 L"ClientUID"
#define DHCP_RIP_CLIENT_UID_VALUE_TYPE            REG_BINARY

#define DHCP_RIP_ALLOWED_CLIENT_TYPES_VALUE       L"AllowedClientTypes"
#define DHCP_RIP_ALLOWED_CLIENT_TYPES_VALUE_TYPE  REG_BINARY

//
//  Parameter Key, Value fields names.
//

#define DHCP_API_PROTOCOL_VALUE                   L"APIProtocolSupport"
#define DHCP_API_PROTOCOL_VALUE_TYPE              REG_DWORD

#define DHCP_DB_NAME_VALUE                        L"DatabaseName"
#define DHCP_DB_NAME_VALUE_TYPE                   REG_SZ

#define DHCP_DB_PATH_VALUE                        L"DatabasePath"
#define DHCP_DB_PATH_VALUE_TYPE                   REG_EXPAND_SZ

#define DHCP_LOG_FILE_PATH_VALUE                  L"DhcpLogFilePath"
#define DHCP_LOG_FILE_PATH_VALUE_TYPE             REG_SZ

#define DHCP_BACKUP_PATH_VALUE                    L"BackupDatabasePath"
#define DHCP_BACKUP_PATH_VALUE_TYPE               REG_EXPAND_SZ

#define DHCP_RESTORE_PATH_VALUE                   L"RestoreDatabasePath"
#define DHCP_RESTORE_PATH_VALUE_TYPE              REG_SZ

#define DHCP_BACKUP_INTERVAL_VALUE                L"BackupInterval"
#define DHCP_BACKUP_INTERVAL_VALUE_TYPE           REG_DWORD

#define DHCP_DB_LOGGING_FLAG_VALUE                L"DatabaseLoggingFlag"
#define DHCP_DB_LOGGING_FLAG_VALUE_TYPE           REG_DWORD

#define DHCP_DB_DOOM_TIME_VALUE                   L"LeaseExtension"
#define DHCP_DB_DOOM_TIME_VALUE_TYPE              REG_DWORD

#define DHCP_RESTORE_FLAG_VALUE                   L"RestoreFlag"
#define DHCP_RESTORE_FLAG_VALUE_TYPE              REG_DWORD

#define DHCP_DB_CLEANUP_INTERVAL_VALUE            L"DatabaseCleanupInterval"
#define DHCP_DB_CLEANUP_INTERVAL_VALUE_TYPE       REG_DWORD

#define DHCP_MESSAGE_QUEUE_LENGTH_VALUE           L"MessageQueueLength"
#define DHCP_MESSAGE_QUEUE_LENGTH_VALUE_TYPE      REG_DWORD

#define DHCP_DEBUG_FLAG_VALUE                     L"DebugFlag"
#define DHCP_DEBUG_FLAG_VALUE_TYPE                REG_DWORD

#define DHCP_AUDIT_LOG_FLAG_VALUE                 L"ActivityLogFlag"
#define DHCP_AUDIT_LOG_FLAG_VALUE_TYPE            REG_DWORD

#define DHCP_AUDIT_LOG_MAX_SIZE_VALUE             L"ActivityLogMaxSize"
#define DHCP_AUDIT_LOG_MAX_SIZE_VALUE_TYPE        REG_DWORD

#define DHCP_DETECT_CONFLICT_RETRIES_VALUE        L"DetectConflictRetries"
#define DHCP_DETECT_CONFLICT_RETRIES_VALUE_TYPE   REG_DWORD

#define DHCP_USE351DB_FLAG_VALUE                  L"Use351Db"
#define DHCP_USE351DB_FLAG_VALUE_TYPE             REG_DWORD

#define DHCP_DBTYPE_VALUE                         L"DbType"
#define DHCP_DBTYPE_VALUE_TYPE                    REG_DWORD

#define DHCP_IGNORE_BROADCAST_FLAG_VALUE          L"IgnoreBroadcastFlag"
#define DHCP_IGNORE_BROADCAST_VALUE_TYPE          REG_DWORD

#define DHCP_MAX_PROCESSING_THREADS_VALUE         L"MaxProcessingThreads"
#define DHCP_MAX_PROCESSING_THREADS_TYPE          REG_DWORD

#define DHCP_MAX_ACTIVE_THREADS_VALUE             L"MaxActiveThreads"
#define DHCP_MAX_ACTIVE_THREADS_TYPE              REG_DWORD

#define DHCP_BCAST_ADDRESS_VALUE                  L"BroadcastAddress"
#define DHCP_BCAST_ADDRESS_VALUE_TYPE             REG_DWORD

#define DHCP_PING_TYPE_VALUE                      L"DhcpPingType"
#define DHCP_PING_TYPE_TYPE                       REG_DWORD

#define DHCP_CLEAN_BITMASK_FLAG                   L"BitmaskClean"
#define DHCP_CLEAN_BITMASK_FLAG_TYPE              REG_DWORD

#define DHCP_DDNS_TTL                             L"DynamicDNSTimeToLive"
#define DHCP_DDNS_TTL_TYPE                        REG_DWORD

//
// define linkage key values.
//

#define DHCP_LINKAGE_KEY                          L"Linkage"
#define TCPIP_LINKAGE_KEY                         L"System\\CurrentControlSet\\Services\\Tcpip\\Linkage"

#define DHCP_BIND_VALUE                           L"Bind"
#define DHCP_BIND_VALUE_TYPE                      REG_MULTI_SZ

#define DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE       L"BindToDHCPServer"
#define DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE  REG_DWORD

#define DHCP_NET_IPADDRESS_VALUE                  L"IpAddress"
#define DHCP_NET_SUBNET_MASK_VALUE                L"SubnetMask"

#define DHCP_NET_IPADDRESS_VALUE_TYPE             REG_MULTI_SZ
#define DHCP_NET_SUBNET_MASK_VALUE_TYPE           REG_MULTI_SZ

#define DHCP_NET_DHCP_ENABLE_VALUE                L"EnableDHCP"
#define DHCP_NET_DHCP_ENABLE_VALUE_TYPE           REG_DWORD

#define DHCP_QUICK_BIND_VALUE                     L"Bind"
#define DHCP_QUICK_BIND_VALUE_TYPE                REG_MULTI_SZ

#define DHCP_PROCESS_INFORMS_ONLY_FLAG            L"DhcpProcessInformsOnlyFlag"
#define DHCP_PROCESS_INFORMS_ONLY_FLAG_TYPE       REG_DWORD

#define DHCP_ALERT_PERCENTAGE_VALUE               L"DhcpAlertPercentage"
#define DHCP_ALERT_PERCENTAGE_VALUE_TYPE          REG_DWORD

#define DHCP_ALERT_COUNT_VALUE                    L"DhcpAlertCount"
#define DHCP_ALERT_COUNT_VALUE_TYPE               REG_DWORD

#define DHCP_DISABLE_ROGUE_DETECTION              L"DisableRogueDetection"
#define DHCP_DISABLE_ROGUE_DETECTION_TYPE         REG_DWORD

#define DHCP_ROGUE_AUTH_RECHECK_TIME              L"RogueAuthorizationRecheckInterval"
#define DHCP_ROGUE_AUTH_RECHECK_TIME_TYPE         REG_DWORD

#define DHCP_ROGUE_LOG_EVENTS                     L"DhcpRogueLogLevel"
#define DHCP_ROGUE_LOG_EVENTS_TYPE                REG_DWORD

#define DHCP_ENABLE_DYNBOOTP                      L"EnableDynamicBOOTP"
#define DHCP_ENABLE_DYNBOOTP_TYPE                 REG_DWORD

#define DHCP_GLOBAL_SERVER_PORT                   L"ServerPort"
#define DHCP_GLOBAL_SERVER_PORT_TYPE              REG_DWORD

#define DHCP_GLOBAL_CLIENT_PORT                   L"ClientPort"
#define DHCP_GLOBAL_CLIENT_PORT_TYPE              REG_DWORD

#define DHCP_CLOCK_SKEW_ALLOWANCE                 L"ClockSkewAllowance"
#define DHCP_CLOCK_SKEW_ALLOWANCE_TYPE            REG_DWORD

#define DHCP_EXTRA_ALLOCATION_TIME                L"ExtraAllocationTime"
#define DHCP_EXTRA_ALLOCATION_TIME_TYPE           REG_DWORD

//
// macros.
//

#define LOCK_REGISTRY()                           EnterCriticalSection(&DhcpGlobalRegCritSect)
#define UNLOCK_REGISTRY()                         LeaveCriticalSection(&DhcpGlobalRegCritSect)

#define DHCP_IP_OVERLAP(_s_, _e_, _ips_, _ipe_ ) \
    ((((_s_ >= _ips_) && (_s_ <= _ipe_)) || \
            ((_e_ >= _ips_) && (_e_ <= _ipe_)))) || \
    ((((_ips_ >= _s_) && (_ips_ <= _e_)) || \
            ((_ipe_ >= _s_) && (_ipe_ <= _e_))))

//
// binary data structues.
//

//
// Excluded IpRanges.
//

typedef struct _EXCLUDED_IP_RANGES {
    DWORD NumRanges;
    DHCP_IP_RANGE Ranges[0];    // embedded array.
} EXCLUDED_IP_RANGES, *LPEXCLUDED_IP_RANGES;

//
// Used clusters.
//

typedef struct _USED_CLUSTERS {
    DWORD NumUsedClusters;
    DHCP_IP_ADDRESS Clusters[0]; // embedded array.
} USED_CLUSTERS, *LPUSED_CLUSTERS;

//
// in use clusters.
//

#define CLUSTER_SIZE    (1 * sizeof(DWORD) * 8)  // one dword, ie 32 addresses.??

typedef struct _IN_USE_CLUSTER_ENTRY {
    DHCP_IP_ADDRESS ClusterAddress;
    DWORD   ClusterBitMap;
} IN_USE_CLUSTER_ENTRY, *LPIN_USE_CLUSTER_ENTRY;

typedef struct _IN_USE_CLUSTERS {
    DWORD NumInUseClusters;
    IN_USE_CLUSTER_ENTRY Clusters[0];    // embedded array.
} IN_USE_CLUSTERS, *LPIN_USE_CLUSTERS;


//
// Key query Info.
//

typedef struct _DHCP_KEY_QUERY_INFO {
    WCHAR Class[DHCP_CLASS_SIZE];
    DWORD ClassSize;
    DWORD NumSubKeys;
    DWORD MaxSubKeyLen;
    DWORD MaxClassLen;
    DWORD NumValues;
    DWORD MaxValueNameLen;
    DWORD MaxValueLen;
    DWORD SecurityDescriptorLen;
    FILETIME LastWriteTime;
} DHCP_KEY_QUERY_INFO, *LPDHCP_KEY_QUERY_INFO;


//
// protos
//

DWORD
DhcpRegQueryInfoKey(
    HKEY KeyHandle,
    LPDHCP_KEY_QUERY_INFO QueryInfo
    );

DWORD
DhcpRegGetValue(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    LPBYTE BufferPtr
    );

DWORD
DhcpRegCreateKey(
    HKEY RootKey,
    LPWSTR KeyName,
    PHKEY KeyHandle,
    LPDWORD KeyDisposition
    );

DWORD
DhcpRegDeleteKey(
    HKEY ParentKeyHandle,
    LPWSTR KeyName
    );

DWORD
DhcpInitializeRegistry(
    VOID
    );

VOID
DhcpCleanupRegistry(
    VOID
    );

DWORD
DhcpBackupConfiguration(
    LPWSTR BackupFileName
    );

DWORD
DhcpRestoreConfiguration(
    LPWSTR BackupFileName
    );


DWORD
DhcpOpenInterfaceByName(
    IN LPCWSTR InterfaceName,
    OUT HKEY *Key
    );


//
// for superscope  (added by t-cheny)
//

VOID
DhcpCleanUpSuperScopeTable(
    VOID
);

DWORD
DhcpInitializeSuperScopeTable(
    VOID
);

BOOL
CheckKeyForBinding(
    IN HKEY Key,
    IN ULONG IpAddress
    );

BOOL
CheckKeyForBindability(
    IN HKEY Key,
    IN ULONG IpAddress
    );

ULONG
SetKeyForBinding(
    IN HKEY Key,
    IN ULONG IpAddress,
    IN BOOL fBind
    );

DWORD
DhcpSaveOrRestoreConfigToFile(
    IN HKEY hKey,
    IN LPWSTR ConfigFileName,
    IN BOOL fRestore
    );

DWORD
DeleteSoftwareRootKey(
    VOID
    );

//
// end of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dsreg.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This module does the DS downloads in a safe way.
// To do this, first a time check is made between registry and DS to see which
// is the latest... If the DS is latest, it is downloaded onto a DIFFERENT
// key from the standard location.  After a successful download, the key is just
// saved and restored onto the normal configuration key.
// Support for global options is lacking.
//================================================================================

#include    <dhcppch.h>
#include    <dhcpapi.h>
#include    <dhcpds.h>

VOID
GetDNSHostName(                                   // get the DNS FQDN of this machine
    IN OUT  LPWSTR                 Name           // fill in this buffer with the name
)
{
    DWORD                          Err;
    CHAR                           sName[300];    // DNS name shouldn't be longer than this.
    HOSTENT                        *h;

    Err = gethostname(sName, sizeof(sName));
    if( ERROR_SUCCESS != Err ) {                  // oops.. could not get host name?
        wcscpy(Name,L"gethostname error");        // uhm.. should handlE this better.. 
        return;
    }

    h = gethostbyname(sName);                      // try to resolve the name to get FQDN
    if( NULL == h ) {                             // gethostname failed? it shouldnt..?
        wcscpy(Name,L"gethostbyname error");      // should handle this better
        return;
    }

    Err = mbstowcs(Name, h->h_name, strlen(h->h_name)+1);
    if( -1 == Err ) {                             // this is weird, mbstowcs cant fail..
        wcscpy(Name,L"mbstowcs error");           // should fail better than this 
        return;
    }
}

VOID
GetLocalFileTime(                                 // fill in filetime struct w/ current local time
    IN OUT  LPFILETIME             Time           // struct to fill in
)
{
    BOOL                           Status;
    SYSTEMTIME                     SysTime;

    GetSystemTime(&SysTime);                      // get sys time as UTC time.
    Status = SystemTimeToFileTime(&SysTime,Time); // conver system time to file time
    if( FALSE == Status ) {                       // convert failed?
        Time->dwLowDateTime = 0xFFFFFFFF;         // set time to weird value in case of failiure
        Time->dwHighDateTime = 0xFFFFFFFF;
    }
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dsreg.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This module does the DS downloads in a safe way.
// To do this, first a time check is made between registry and DS to see which
// is the latest... If the DS is latest, it is downloaded onto a DIFFERENT
// key from the standard location.  After a successful download, the key is just
// saved and restored onto the normal configuration key.
// Support for global options is lacking.
//================================================================================

VOID
DhcpDownloadDsToRegistry(
    VOID
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\endpoint.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    endpoint.c

Abstract:
    handles endpoints for dhcp server.

Environment:
    dhcpserver NT5+

--*/

#include <dhcppch.h>
#include <guiddef.h>
#include <convguid.h>
#include <iptbl.h>
#include <endpoint.h>
#include <ws2tcpip.h>
#include <mstcpip.h>
#include <nhapi.h>
#include <netconp.h>
#include <mprapi.h>

#define SOCKET_RECEIVE_BUFFER_SIZE      (1024 * 64) // 64K max.

ULONG InitCount = 0;

BOOL
IsIpAddressBound(
    IN GUID *IfGuid,
    IN ULONG IpAddress
    );

DWORD
InitializeSocket(
    OUT SOCKET *Sockp,
    IN DWORD IpAddress,
    IN DWORD Port,
    IN DWORD McastAddress OPTIONAL
    )
/*++

Routine Description:
    Create and initialize a socket for DHCP.

    N.B. This routine also sets the winsock buffers, marks socket to
    allow broadcast and all those good things.

Arguments:
    Sockp -- socket to create and intiialize
    IpAddress -- ip address to bind the socket to
    Port -- the port to bind the socket to
    McastAddress -- if present, join this mcast address group

Return Values:
    winsock errors

--*/
{
    DWORD Error;
    DWORD OptValue, BufLen = 0;
    SOCKET Sock;
    struct sockaddr_in SocketName;
    struct ip_mreq mreq;

    Sock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( Sock == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = TRUE;
    Error = setsockopt(
        Sock,
        SOL_SOCKET,
        SO_REUSEADDR,
        (LPBYTE)&OptValue,
        sizeof(OptValue)
    );

    if ( Error != ERROR_SUCCESS ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = TRUE;
    Error = setsockopt(
        Sock,
        SOL_SOCKET,
        SO_BROADCAST,
        (LPBYTE)&OptValue,
        sizeof(OptValue)
    );

    if ( Error != ERROR_SUCCESS ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = SOCKET_RECEIVE_BUFFER_SIZE;
    Error = setsockopt(
        Sock,
        SOL_SOCKET,
        SO_RCVBUF,
        (LPBYTE)&OptValue,
        sizeof(OptValue)
    );

    if ( Error != ERROR_SUCCESS ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    if( INADDR_ANY != IpAddress ) {
        OptValue = 1;
        Error = WSAIoctl(
            Sock, SIO_LIMIT_BROADCASTS, &OptValue, sizeof(OptValue),
            NULL, 0, &BufLen, NULL, NULL
            );

        if ( Error != ERROR_SUCCESS ) {
            Error = WSAGetLastError();
            goto Cleanup;
        }
    }
    
    SocketName.sin_family = PF_INET;
    SocketName.sin_port = htons( (unsigned short)Port );
    SocketName.sin_addr.s_addr = IpAddress;
    RtlZeroMemory( SocketName.sin_zero, 8);

    Error = bind(
        Sock,
        (struct sockaddr FAR *)&SocketName,
        sizeof( SocketName )
    );

    if ( Error != ERROR_SUCCESS ) {
        Error = WSAGetLastError();
        DhcpPrint((DEBUG_ERRORS,"bind failed with, %ld\n",Error));
        goto Cleanup;
    }

    //
    // If asked, then join mcast group
    //
    if( McastAddress ) {
        mreq.imr_multiaddr.s_addr = McastAddress;
        mreq.imr_interface.s_addr  = IpAddress;

        if ( SOCKET_ERROR == setsockopt(
            Sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(char *)&mreq,sizeof(mreq))
        ) {
            Error = WSAGetLastError();
            DhcpPrint((DEBUG_ERRORS,"could not join multicast group %ld\n",Error ));
            goto Cleanup;
        }
    }

    *Sockp = Sock;
    return ERROR_SUCCESS;

  Cleanup:

    //
    // if we aren't successful, close the socket if it is opened.
    //

    if( Sock != INVALID_SOCKET ) {
        closesocket( Sock );
    }

    return Error;
}


DWORD
DhcpInitializeEndpoint(
    PENDPOINT endpoint
    )
/*++

Routine Description:

    This function initializes an endpoint by creating and binding a
    socket to the local address.

Arguments:

    Socket - Receives a pointer to the newly created socket

    IpAddress - The IP address to initialize to.

    Port - The port to bind to.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;

    DhcpPrint((
        DEBUG_INIT, "Dhcpserver initializing endpoint %s\n",
        inet_ntoa(*(struct in_addr *)&endpoint->IpTblEndPoint.IpAddress)
        ));

    DhcpAssert( !IS_ENDPOINT_BOUND( endpoint ));

    //
    // first open socket for dhcp traffic
    //

    Error = InitializeSocket(
        &endpoint->Socket, endpoint->IpTblEndPoint.IpAddress,
        DhcpGlobalServerPort, 0
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((
            DEBUG_ERRORS,
            "DhcpInitializeEndpoint: %ld (0x%lx)\n", Error, Error
            ));
        return Error;
    }

    //
    // now open socket for mdhcp traffic
    //

    Error = InitializeSocket(
        &endpoint->MadcapSocket, endpoint->IpTblEndPoint.IpAddress,
        MADCAP_SERVER_PORT, MADCAP_SERVER_IP_ADDRESS
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((
            DEBUG_ERRORS, "DhcpInitializeEndpoint:"
            " %ld (0x%lx)\n", Error, Error
            ));
        return Error;
    }

    //
    // Finally open socket for rogue detection receives
    //
    Error = InitializeSocket(
        &endpoint->RogueDetectSocket,
        endpoint->IpTblEndPoint.IpAddress,
        DhcpGlobalClientPort, 0
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((
            DEBUG_ERRORS,
            "InitializeSocket: could not open rogue socket:%ld (0x%lx)\n",
            Error,Error));
        closesocket(endpoint->Socket);
        return Error;
    }

    SET_ENDPOINT_BOUND( endpoint );

    if ( DhcpGlobalNumberOfNetsActive++ == 0 ) {
        //
        // Signal MessageLoop waiting for endpoint to be ready..
        //
        DhcpPrint((
            DEBUG_MISC, "Activated an enpoint.."
            "pulsing the DhcpWaitForMessage thread\n"
            ));
        SetEvent( DhcpGlobalEndpointReadyEvent );
    }


    DhcpGlobalRogueRedoScheduledTime = 0;
    DhcpGlobalRedoRogueStuff = TRUE;
    SetEvent(DhcpGlobalRogueWaitEvent);
    
    return ERROR_SUCCESS;
}

DWORD
DhcpDeinitializeEndpoint(
    PENDPOINT    endpoint
    )
/*++

Routine Description:

    This function deinitializes the endpoint. It just closes the
    sockets and marks this interface unusable.

Arguments:

    endpoint -- clear the endpoint

Return Value:

    The status of the operation.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    DWORD LastError;

    DhcpPrint((
        DEBUG_INIT, "Deinitializing endpoint %s\n",
        inet_ntoa(*(struct in_addr
                    *)&endpoint->IpTblEndPoint.IpAddress)
        ));

    if ( endpoint->Socket != INVALID_SOCKET
         && endpoint->Socket != 0) {

        Error = LastError = closesocket(endpoint->Socket);
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint((
                DEBUG_ERRORS, "Deinitialize endpoint could "
                "not close socket %lx\n", endpoint->Socket
                ));
        }
    }
    if ( endpoint->RogueDetectSocket != INVALID_SOCKET
         && endpoint->RogueDetectSocket != 0) {

        LastError = closesocket(endpoint->RogueDetectSocket);
        if ( LastError != ERROR_SUCCESS ) {
            Error = LastError;
            DhcpPrint((
                DEBUG_ERRORS, "Deinitialize endpoint could "
                "not close socket %lx\n", endpoint->RogueDetectSocket
                ));
        }
    }

    if ( endpoint->MadcapSocket != INVALID_SOCKET
         && endpoint->MadcapSocket != 0) {

        LastError = closesocket(endpoint->MadcapSocket);
        if ( LastError != ERROR_SUCCESS ) {
            Error = LastError;
            DhcpPrint((
                DEBUG_ERRORS, "Deinitialize endpoint could "
                "not close socket %lx\n", endpoint->MadcapSocket
                ));
        }
    }

    endpoint->Socket = INVALID_SOCKET;
    endpoint->MadcapSocket = INVALID_SOCKET;
    endpoint->RogueDetectSocket = INVALID_SOCKET;
    if ( IS_ENDPOINT_BOUND( endpoint ) ) {
        DhcpGlobalNumberOfNetsActive--;
        SET_ENDPOINT_UNBOUND( endpoint );
        if( 0 == DhcpGlobalNumberOfNetsActive ) {
            DhcpPrint((
                DEBUG_MISC, "Closing last active endpoint.. "
                "so resetting event for DhcpWaitForMessage\n"));
            ResetEvent(DhcpGlobalEndpointReadyEvent);
        }
    }

    DhcpGlobalRogueRedoScheduledTime = 0;
    DhcpGlobalRedoRogueStuff = TRUE;
    SetEvent(DhcpGlobalRogueWaitEvent);
    
    return Error;

}

VOID _stdcall
EndPointChangeHandler(
    IN ULONG Reason,
    IN OUT PENDPOINT_ENTRY Entry
    )
{
    PENDPOINT Ep = (PENDPOINT) Entry;

    if( REASON_ENDPOINT_CREATED == Reason ) {
        //
        // If endpoint just created, just mark it unbound.
        // We can check bindings later when the endpoint gets
        // refreshed.
        //
        DhcpPrint((
            DEBUG_PNP, "New EndPoint: %s\n",
            inet_ntoa(*(struct in_addr*)&Entry->IpAddress)
            ));

        SET_ENDPOINT_UNBOUND(Ep);
        return;
    }

    if( REASON_ENDPOINT_DELETED == Reason ) {
        //
        // If the endpoint is getting deleted, we only have
        // to do work if the endpoint is bound.
        //
        DhcpPrint((
            DEBUG_PNP, "EndPoint Deleted: %s\n",
            inet_ntoa(*(struct in_addr*)&Entry->IpAddress)
            ));
        if( !IS_ENDPOINT_BOUND(Ep) ) return;
        DhcpDeinitializeEndpoint(Ep);
        return;
    }

    if( REASON_ENDPOINT_REFRESHED == Reason ) {
        //
        // If the endpoint is getting refreshed, we need to check
        // if it is bound or unbound and if there is a state
        // change, we need to do accordingly.
        //
        BOOL fBound = IsIpAddressBound(
            &Entry->IfGuid, Entry->IpAddress
            );

        DhcpPrint((
            DEBUG_PNP, "EndPoint Refreshed: %s\n",
            inet_ntoa(*(struct in_addr*)&Entry->IpAddress)
            ));
        DhcpPrint((DEBUG_PNP, "Endpoint bound: %d\n", fBound));

        if( fBound ) {
            if( IS_ENDPOINT_BOUND(Ep) ) return;
            DhcpInitializeEndpoint(Ep);
        } else {
            if( !IS_ENDPOINT_BOUND(Ep) ) return;
            DhcpDeinitializeEndpoint(Ep);
        }
        return;
    }
}

DWORD
InitializeEndPoints(
    VOID
    )
{
    ULONG Status;

    InitCount ++;
    if( 1 != InitCount ) return ERROR_SUCCESS;

    Status = IpTblInitialize(
        &DhcpGlobalEndPointCS,
        sizeof(ENDPOINT),
        EndPointChangeHandler,
        GetProcessHeap()
        );
    if( NO_ERROR != Status ) {
        InitCount --;
    }

    return Status;
}

VOID
CleanupEndPoints(
    VOID
    )
{
    if( 0 == InitCount ) return;
    InitCount --;
    if( 0 != InitCount ) return;

    IpTblCleanup();
}

//
// Bindings.
//

#define MAX_GUID_NAME_SIZE 60

BOOL
IsIpAddressBound(
    IN GUID *IfGuid,
    IN ULONG IpAddress
    )
{
    ULONG Status, SubnetMask, SubnetAddr;
    WCHAR KeyName[MAX_GUID_NAME_SIZE];
    HKEY IfKey;
    BOOL fRetVal;

    //
    // Fast check to see if this IP Address is part of
    // DHCPServer\Parameters\Bind key
    //

    fRetVal = FALSE;
    if( QuickBound( IpAddress, &SubnetMask, &SubnetAddr, &fRetVal ) ) {

        DhcpPrint((DEBUG_PNP, "Interface is quick bound: %ld\n", fRetVal));
        return fRetVal;
    }

    if(!ConvertGuidToIfNameString(
        IfGuid, KeyName, sizeof(KeyName)/sizeof(WCHAR))) {
        //
        // Couldn't convert the guid to interface!!!!
        //
        DhcpPrint((DEBUG_PNP, "Couldn't converg guid to string\n"));
        DhcpAssert(FALSE);
        return FALSE;
    }

    //
    // Now open the key required.
    //

    Status = DhcpOpenInterfaceByName(
        KeyName,
        &IfKey
        );
    if( NO_ERROR != Status ) {
        //
        // Hmm... we have an interface which doesn't have a key?
        //
        DhcpPrint((DEBUG_PNP, "Couldnt open reg key: %ws\n", KeyName));
        DhcpAssert(FALSE);
        return FALSE;
    }

    fRetVal = FALSE;
    do {
        //
        // Now check to see if IP address is static or not.
        // If it is dhcp enabled, then we cannot process it.
        //
        if( !IsAdapterStaticIP(IfKey) ) {
            DhcpPrint((DEBUG_PNP, "Adapter %ws has no static IP\n", KeyName));
            break;
        }

        //
        // Now check to see if this is part of the bound or
        // unbound list for this interface.
        //
        fRetVal = CheckKeyForBinding(
            IfKey, IpAddress
            );
    } while ( 0 );

    RegCloseKey(IfKey);
    return fRetVal;
}

BOOL _stdcall
RefreshBinding(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID Ctxt_unused
    )
/*++

Routine Description:
    This routine refreshes the bindings information from
    the registry for the endpoint in question.

    N.B. This is done by faking a EndPointChangeHandler event
    handler with the endpoint.

Arguments:
    Entry -- endpoint entry.
    Ctxt_unused -- unused parameter.

Return Value:
    TRUE always so that the WalkthroughEndpoints routine tries
    to do this on the next endpoint.

--*/
{
    UNREFERENCED_PARAMETER(Ctxt_unused);

    EndPointChangeHandler(
        REASON_ENDPOINT_REFRESHED,
        Entry
        );
    return TRUE;
}

VOID
DhcpUpdateEndpointBindings(
    VOID
    )
/*++

Routine Description:
    This routine udpates all the endpoints to see if they are bound or
    not, by reading the registry.

--*/
{
    WalkthroughEndpoints(
        NULL,
        RefreshBinding
        );
}

LPWSTR
GetFriendlyNameFromGuidStruct(
    IN GUID *pGuid
    )
/*++

Routine Description:
    This routine calls the NHAPI routine to find out if there is a
    friendly name for the given interface guid...
    If this succeeds the routine returns the friendly name string
    allocated via DhcpAllocateMemory (and hence this must be freed
    via the same mechanism).

Arguments:
    pGuid -- the guid for which friendly connection name is needed.

Return Values:
    NULL -- error, or no such connection guid.
    connection name string.

--*/
{
    ULONG Error = 0, Size;
    LPWSTR String;

    String = NULL;
    Size = MAX_INTERFACE_NAME_LEN * sizeof( WCHAR );

    while ( TRUE ) {
        String = DhcpAllocateMemory( Size );
        if ( NULL == String ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Error = NhGetInterfaceNameFromGuid(
            pGuid, String, &Size, FALSE, TRUE
            );

        if (( ERROR_INSUFFICIENT_BUFFER == Error ) ||
            ( ERROR_MORE_DATA == Error )) {
            DhcpFreeMemory( String );
            Size *= 2;
        }
        else {
            break;
        }
    } // while

    SetLastError( Error );
    if( ERROR_SUCCESS != Error ) {
        if( String ) DhcpFreeMemory( String );
        String = NULL;
    }

    return String;
}

LPWSTR
GetFriendlyNameFromGuidString(
    IN LPCWSTR GuidString
    )
/*++

Routine Description:
    This routine tries to get the connection name via the LAN
    connections API.  The returned string is allocated via
    DhcpAllocateMemory  and should be freed using counterpart..

Arguments:
    GuidString -- this string should include the "{}" ...

Return Values:
    valid lan connection name... or NULL

--*/
{
    HRESULT Result;
    LPWSTR RetVal;
    ULONG Size;

    RetVal = NULL; Size = 0;

    Result = HrLanConnectionNameFromGuidOrPath(
        NULL, GuidString, RetVal, &Size
        );
    if( !SUCCEEDED(Result) ) {
        return NULL;
    }

    DhcpAssert( 0 != Size );
    RetVal = DhcpAllocateMemory( (Size+1)*sizeof(WCHAR) );
    if( NULL == RetVal ) return NULL;

    Result = HrLanConnectionNameFromGuidOrPath(
        NULL, GuidString, RetVal, &Size
        );
    if( !SUCCEEDED(Result) ) {
        DhcpFreeMemory(RetVal);
        return NULL;
    }

    return RetVal;
}

LPWSTR
GetFriendlyNameFromGuid(
    IN GUID *pGuid,
    IN LPCWSTR GuidString
    )
{
    LPWSTR RetVal;

    RetVal = GetFriendlyNameFromGuidStruct(pGuid);
    if( NULL != RetVal ) return RetVal;

    return GetFriendlyNameFromGuidString(GuidString);
}

BOOL
IsEndpointQuickBound(
    IN PENDPOINT_ENTRY Entry
    )
/*++

Routine Description:
    This routine checks to see if the endpoint is bound because
    it is a "quick bind".

Return Value:
    TRUE -- yes quick bound
    FALSE -- no, not quickbound

--*/
{
    BOOL fStatus, fRetVal;
    ULONG DummyMask, DummyAddress;

    //
    // First check if it is bound in the first place.
    //
    if( !IS_ENDPOINT_BOUND((PENDPOINT)Entry) ) {
        return FALSE;
    }

    //
    // Now check if the endpoint IP address is present in the
    // quickbind array.
    //

    fStatus = QuickBound(
        Entry->IpAddress, &DummyMask, &DummyAddress,
        &fRetVal
        );

    //
    // If quickbound then return TRUE.
    //
    return  fStatus && fRetVal;
}

typedef struct {
    LPDHCP_BIND_ELEMENT_ARRAY Info;
    ULONG Error;
} BIND_INFO_CTXT;

BOOL
ProcessQuickBoundInterface(
    IN PENDPOINT_ENTRY Entry,
    IN PVOID Context,
    OUT BOOL *fStatus
    )
/*++

Routine Description:
    Check if the entpoint under consideration is bound to
    an interface because it is "QuickBound" -- if so,
    update the Context structure to include info about this
    interface.

Return Value:
    TRUE -- yes interface is quickbound.
    FALSE -- no interface is not quick bound.

    If this routine returns TRUE, then fStatus is also set.
    In this case fStatus would be set to TRUE, unless some
    fatal error occurred.

--*/
{
    BOOL fRetVal;
    BIND_INFO_CTXT *Ctxt = (BIND_INFO_CTXT *)Context;
    LPDHCP_BIND_ELEMENT Elts;
    ULONG Size, i;

    fRetVal = IsEndpointQuickBound(Entry);
    if( FALSE == fRetVal ) return fRetVal;

    (*fStatus) = TRUE;

    do {

        Size = Ctxt->Info->NumElements + 1;
        Elts = MIDL_user_allocate(sizeof(*Elts)*Size);
        if( NULL == Elts ) {
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Elts->IfIdSize = sizeof(Entry->IfGuid);
        Elts->IfId = MIDL_user_allocate(sizeof(Entry->IfGuid));
        if( NULL == Elts->IfId ) {
            MIDL_user_free(Elts);
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        RtlCopyMemory(Elts->IfId, &Entry->IfGuid, sizeof(GUID));

        Elts->IfDescription = MIDL_user_allocate(
            sizeof(WCHAR)*( 1 +
            wcslen(GETSTRING(DHCP_CLUSTER_CONNECTION_NAME)))
            );
        if( NULL == Elts->IfDescription ) {
            MIDL_user_free(Elts->IfId);
            MIDL_user_free(Elts);
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(
            Elts->IfDescription,
            GETSTRING(DHCP_CLUSTER_CONNECTION_NAME)
            );

        Elts->Flags = DHCP_ENDPOINT_FLAG_CANT_MODIFY;
        Elts->fBoundToDHCPServer = TRUE;
        Elts->AdapterPrimaryAddress = Entry->IpAddress;
        Elts->AdapterSubnetAddress = Entry->SubnetMask;

        if( Ctxt->Info->NumElements ) {
            MoveMemory(
                &Elts[1],
                Ctxt->Info->Elements,
                sizeof(*Elts)*Ctxt->Info->NumElements
                );
            MIDL_user_free(Ctxt->Info->Elements);
        }
        Ctxt->Info->Elements = Elts;
        Ctxt->Info->NumElements ++;

        //
        // Cool. return.
        //
        return TRUE;

    } while ( 0 );

    //
    // cleanup and error return.
    //

    (*fStatus) = FALSE;
    //
    // The only reason to come here is if there was an error
    // so, we will free everything up.
    //
    for( i = 0; i < Ctxt->Info->NumElements ; i ++ ) {
        MIDL_user_free(Ctxt->Info->Elements[i].IfId);
        MIDL_user_free(Ctxt->Info->Elements[i].IfDescription);
    }
    MIDL_user_free(Ctxt->Info->Elements);
    Ctxt->Info->Elements = NULL;
    Ctxt->Info->NumElements = 0;

    return TRUE;

}

BOOL _stdcall
AddBindingInfo(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID Context
    )
/*++

Routine Description:
    Add the endpoint to the binding information
    collected so far, reallocating memory if needed.

Return Value:
    FALSE on error (In this case Ctxt.Error is set and
        the array in Info is cleared).
    TRUE if an element was successfully added.

--*/
{
    ULONG i, Size, Error;
    BOOL fStatus;
    BIND_INFO_CTXT *Ctxt = (BIND_INFO_CTXT *)Context;
    LPDHCP_BIND_ELEMENT Elts;
    WCHAR IfString[MAX_GUID_NAME_SIZE];
    LPWSTR FriendlyNameString = NULL, Descr;
    HKEY IfKey;

    //
    // Process QuickBound Interfaces..
    //
    if( ProcessQuickBoundInterface(Entry, Context, &fStatus ) ) {
        return fStatus;
    }

    //
    // First check to see if the adapter is dhcp enabled.
    // then we won't even show it here.
    //
    fStatus = ConvertGuidToIfNameString(
        &Entry->IfGuid,
        IfString,
        MAX_GUID_NAME_SIZE
        );
    DhcpAssert(fStatus);

    //
    // Now open the key required.
    //
    Error = DhcpOpenInterfaceByName(
        IfString,
        &IfKey
        );
    if( NO_ERROR != Error ) {
        DhcpAssert(FALSE);
        //
        // ignore interface.
        //
        return TRUE;
    }

    fStatus = IsAdapterStaticIP(IfKey);

    if( TRUE == fStatus ) {
        //
        // For static, check if this is the first IP address,
        // and hence bindable..
        //
        fStatus = CheckKeyForBindability(
            IfKey,
            Entry->IpAddress
            );
    }

    RegCloseKey( IfKey );

    //
    // Ignore DHCP enabled interfaces or non-bindable interfaces.
    //
    if( FALSE == fStatus ) return TRUE;

    //
    // Get interface friendly name..
    //

    FriendlyNameString = GetFriendlyNameFromGuid(
        &Entry->IfGuid, IfString
        );

    if( NULL == FriendlyNameString ) FriendlyNameString = IfString;

    //
    // Aargh. New interface. Need to allocate more space.
    //

    do {

        Size = Ctxt->Info->NumElements + 1 ;
        Elts = MIDL_user_allocate(sizeof(*Elts)*Size);
        if( NULL == Elts ) {
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        Elts->IfIdSize = sizeof(Entry->IfGuid);
        Elts->IfId = MIDL_user_allocate(sizeof(Entry->IfGuid));
        if( NULL == Elts->IfId ) {
            MIDL_user_free(Elts);
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        RtlCopyMemory(Elts->IfId,&Entry->IfGuid,sizeof(GUID));

        Elts->IfDescription = MIDL_user_allocate(
            sizeof(WCHAR)*(1+wcslen(FriendlyNameString))
            );
        if( NULL == Elts->IfDescription ) {
            MIDL_user_free(Elts->IfId);
            MIDL_user_free(Elts);
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wcscpy( Elts->IfDescription, FriendlyNameString );

        Elts->Flags = 0;
        if( IS_ENDPOINT_BOUND(((PENDPOINT)Entry)) ) {
            Elts->fBoundToDHCPServer = TRUE;
        } else {
            Elts->fBoundToDHCPServer = FALSE;
        }

        Elts->AdapterPrimaryAddress = Entry->IpAddress;
        Elts->AdapterSubnetAddress = Entry->SubnetMask;

        if( Ctxt->Info->NumElements ) {
            MoveMemory(
                &Elts[1],
                Ctxt->Info->Elements,
                sizeof(*Elts)*Ctxt->Info->NumElements
                );
            MIDL_user_free(Ctxt->Info->Elements);
        }
        Ctxt->Info->Elements = Elts;
        Ctxt->Info->NumElements ++;

        if( NULL != FriendlyNameString &&
            IfString != FriendlyNameString ) {
            LocalFree( FriendlyNameString );
            FriendlyNameString = NULL;
        }
        //
        // process the next endpoint entry.
        //

        return TRUE;
    } while ( 0 );

    if( NULL != FriendlyNameString &&
        IfString != FriendlyNameString ) {
        LocalFree( FriendlyNameString );
        FriendlyNameString = NULL;
    }

    //
    // The only reason to come here is if there was an error
    // so, we will free everything up.
    //
    for( i = 0; i < Ctxt->Info->NumElements ; i ++ ) {
        MIDL_user_free(Ctxt->Info->Elements[i].IfId);
        MIDL_user_free(Ctxt->Info->Elements[i].IfDescription);
    }
    MIDL_user_free(Ctxt->Info->Elements);
    Ctxt->Info->Elements = NULL;
    Ctxt->Info->NumElements = 0;

    return FALSE;
}


ULONG
DhcpGetBindingInfo(
    OUT LPDHCP_BIND_ELEMENT_ARRAY *BindInfo
    )
/*++

Routine Description:
    This routine walks the binding information table and converts
    the information into the bindinfo structure.

    N.B. Since this routine is used for RPC, all allocations are
    done using MIDL_user_allocate and free's are done using
    MIDL_user_free.

Return Value:
    Win32 status?

--*/
{
    LPDHCP_BIND_ELEMENT_ARRAY LocalBindInfo;
    BIND_INFO_CTXT Ctxt;

    *BindInfo = NULL;
    LocalBindInfo = MIDL_user_allocate( sizeof(*LocalBindInfo));
    if( NULL == LocalBindInfo ) return ERROR_NOT_ENOUGH_MEMORY;

    LocalBindInfo->NumElements = 0;
    LocalBindInfo->Elements = NULL;
    Ctxt.Info = LocalBindInfo;
    Ctxt.Error = NO_ERROR;

    WalkthroughEndpoints(
        &Ctxt,
        AddBindingInfo
        );

    if( NO_ERROR == Ctxt.Error ) {
        *BindInfo = LocalBindInfo;
        return NO_ERROR;
    }

    MIDL_user_free( LocalBindInfo );
    *BindInfo = NULL;
    return Ctxt.Error;
}


ULONG
DhcpSetBindingInfo(
    IN LPDHCP_BIND_ELEMENT_ARRAY BindInfo
    )
/*++

Routine Description:
    This routine is the counterpart for the previous routine and it
    takes the array of binding information and sets it in the registry
    as well as updating the bindings.

Arguments:
    BindInfo -- the array of bindings information.

Return Value:
    Status.

--*/
{
    ULONG Error = 0, i;
    WCHAR IfString[MAX_GUID_NAME_SIZE];
    HKEY Key;

    //
    // First check if any element which has can't modify
    // is set to something other than bind..
    //
    for( i = 0; i < BindInfo->NumElements ; i ++ ) {
        if( BindInfo->Elements[i].Flags &
            DHCP_ENDPOINT_FLAG_CANT_MODIFY ) {
            if( ! BindInfo->Elements[i].fBoundToDHCPServer ) {
                return ERROR_DHCP_CANNOT_MODIFY_BINDINGS;
            }
        }
    }

    //
    // Now proceed with the rest.
    //
    for( i = 0; i < BindInfo->NumElements ; i ++ ) {
        GUID IfGuid;
        DHCP_IP_ADDRESS IpAddress;

        //
        // Skip entries marked un-modifiable.
        //
        if( BindInfo->Elements[i].Flags &
            DHCP_ENDPOINT_FLAG_CANT_MODIFY ) {
            continue;
        }

        IpAddress = BindInfo->Elements[i].AdapterPrimaryAddress;

        if( BindInfo->Elements[i].IfIdSize != sizeof(GUID)) {
            Error = ERROR_DHCP_NETWORK_CHANGED;
            break;
        }

        RtlCopyMemory(
            &IfGuid,
            BindInfo->Elements[i].IfId,
            BindInfo->Elements[i].IfIdSize
            );

        ConvertGuidToIfNameString(
            &IfGuid,
            IfString,
            MAX_GUID_NAME_SIZE
            );

        Error = DhcpOpenInterfaceByName(
            IfString,
            &Key
            );
        if( NO_ERROR != Error ) {
            RegCloseKey(Key);
            Error = ERROR_DHCP_NETWORK_CHANGED;
            break;
        }

        //
        // Check if this interface is static and bindable.
        //

        if( !IsAdapterStaticIP(Key)
            || FALSE == CheckKeyForBindability(Key, IpAddress) ) {
            //
            // Nope!
            //
            RegCloseKey(Key);
            Error = ERROR_DHCP_NETWORK_CHANGED;
            break;
        }

        //
        // Everything else looks fine. Just turn on the
        // bindings as requested.
        //

        Error = SetKeyForBinding(
            Key,
            IpAddress,
            BindInfo->Elements[i].fBoundToDHCPServer
            );
        RegCloseKey(Key);

        if( ERROR_SUCCESS != Error ) break;
    }

    //
    // Now refresh the bindings.
    //
    DhcpUpdateEndpointBindings();

    return Error;
}


//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\endpoint.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    endpoint.h

Abstract:
    endpoint structure.

Environment:
    NT5 DHCP Server.

--*/

#ifndef ENDPOINT_H_INCLUDED
#define ENDPOINT_H_INCLUDED

typedef struct _ENDPOINT {
    ENDPOINT_ENTRY IpTblEndPoint;
    SOCKET Socket;
    SOCKET RogueDetectSocket;
    SOCKET MadcapSocket;
    ULONG Flags;
} ENDPOINT, *PENDPOINT;

#define ENDPOINT_FLAG_BOUND 0x1
#define ENDPOINT_FLAG_MADCAP 0x2

#define SET_ENDPOINT_BOUND( _endpoint ) ( (_endpoint)->Flags |= ENDPOINT_FLAG_BOUND )
#define SET_ENDPOINT_UNBOUND( _endpoint ) ( (_endpoint)->Flags &= ~ENDPOINT_FLAG_BOUND )
#define IS_ENDPOINT_BOUND( _endpoint )  ( (_endpoint)->Flags & ENDPOINT_FLAG_BOUND )

#define SET_ENDPOINT_MADCAP( _endpoint ) ( (_endpoint)->Flags |= ENDPOINT_FLAG_MADCAP )
#define SET_ENDPOINT_DHCP( _endpoint ) ( (_endpoint)->Flags &= ~ENDPOINT_FLAG_MADCAP )
#define IS_ENDPOINT_MADCAP( _endpoint )  ( (_endpoint)->Flags & ENDPOINT_FLAG_MADCAP )

DWORD
InitializeEndPoints(
    VOID
    );

VOID
CleanupEndPoints(
    VOID
    );

VOID
DhcpUpdateEndpointBindings(
    VOID
    );

ULONG
DhcpSetBindingInfo(
    IN LPDHCP_BIND_ELEMENT_ARRAY BindInfo
    );

ULONG
DhcpGetBindingInfo(
    OUT LPDHCP_BIND_ELEMENT_ARRAY *BindInfo
    );

#endif  ENDPOINT_H_INCLUDED

//
// end of file.
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\global.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    global.c

Abstract:

    This module contains definitions for global server data.

Author:

    Madan Appiah  (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcpmsg.h"

#ifndef GLOBAL_DATA
#define GLOBAL_DATA

//
// main.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#undef EXTERN
#ifdef  GLOBAL_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

//
// process global data passed to this service from tcpsvcs.exe
//

EXTERN PTCPSVCS_GLOBAL_DATA TcpsvcsGlobalData;

//
// Lease extension.
//

EXTERN DWORD DhcpLeaseExtension;

//
// Dhcp Request in progress list.
//

EXTERN LIST_ENTRY DhcpGlobalInProgressWorkList;
EXTERN CRITICAL_SECTION DhcpGlobalInProgressCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalBinlSyncCritSect;
//
// Registry pointers.
//

EXTERN HKEY DhcpGlobalRegSoftwareRoot;
EXTERN HKEY DhcpGlobalRegRoot;
EXTERN HKEY DhcpGlobalRegConfig;
EXTERN HKEY DhcpGlobalRegSubnets;
EXTERN HKEY DhcpGlobalRegMScopes;
EXTERN HKEY DhcpGlobalRegOptionInfo;
EXTERN HKEY DhcpGlobalRegGlobalOptions;
EXTERN HKEY DhcpGlobalRegSuperScope;

EXTERN HKEY DhcpGlobalRegParam;

EXTERN LPDHCP_SUPER_SCOPE_TABLE_ENTRY DhcpGlobalSuperScopeTable;
EXTERN DWORD DhcpGlobalTotalNumSubnets;

EXTERN CRITICAL_SECTION DhcpGlobalRegCritSect;

EXTERN DWORD DhcpGlobalNumberOfNetsActive;

EXTERN BOOL DhcpGlobalSubnetsListModified;
EXTERN BOOL DhcpGlobalSubnetsListEmpty;

//
// rogue dhcp detection data
//

EXTERN PCHAR    DhcpGlobalDSDomainAnsi;
EXTERN BOOL     DhcpGlobalOkToService;
EXTERN BOOL     DhcpGlobalRogueLogEventsLevel;

//
// stoc
//

EXTERN HANDLE               g_hevtProcessMessageComplete;
EXTERN DWORD                g_cMaxProcessingThreads;
EXTERN DWORD                g_cMaxActiveThreads;
EXTERN CRITICAL_SECTION     g_ProcessMessageCritSect;




//
// Database data
//

EXTERN JET_SESID DhcpGlobalJetServerSession;
EXTERN JET_DBID DhcpGlobalDatabaseHandle;
EXTERN JET_TABLEID DhcpGlobalClientTableHandle;

EXTERN TABLE_INFO *DhcpGlobalClientTable;   // point to static memory.
EXTERN CRITICAL_SECTION DhcpGlobalJetDatabaseCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalMemoryCritSect;

EXTERN LPSTR DhcpGlobalOemDatabasePath;
EXTERN LPSTR DhcpGlobalOemBackupPath;
EXTERN LPSTR DhcpGlobalOemRestorePath;
EXTERN LPSTR DhcpGlobalOemJetRestorePath;
EXTERN LPSTR DhcpGlobalOemJetBackupPath;
EXTERN LPSTR DhcpGlobalOemDatabaseName;
EXTERN LPWSTR DhcpGlobalBackupConfigFileName;

EXTERN DWORD DhcpGlobalBackupInterval;
EXTERN BOOL DhcpGlobalDatabaseLoggingFlag;

EXTERN DWORD DhcpGlobalCleanupInterval;

EXTERN BOOL DhcpGlobalRestoreFlag;

EXTERN DWORD DhcpGlobalAuditLogFlag;
EXTERN DWORD DhcpGlobalDetectConflictRetries;
EXTERN DWORD DhcpGlobalPingType;

EXTERN DWORD DhcpGlobalScavengeIpAddressInterval;
EXTERN BOOL DhcpGlobalScavengeIpAddress;

//
// Service variables
//
EXTERN SERVICE_STATUS DhcpGlobalServiceStatus;
EXTERN SERVICE_STATUS_HANDLE DhcpGlobalServiceStatusHandle;

//
// Process data.
//

EXTERN HANDLE DhcpGlobalProcessTerminationEvent;
EXTERN HANDLE DhcpGlobalRogueWaitEvent;
EXTERN BOOL DhcpGlobalRedoRogueStuff;
EXTERN ULONG DhcpGlobalRogueRedoScheduledTime;
EXTERN DWORD DhcpGlobalScavengerTimeout;
EXTERN HANDLE DhcpGlobalProcessorHandle;
EXTERN HANDLE DhcpGlobalMessageHandle;

EXTERN DWORD DhcpGlobalMessageQueueLength;
EXTERN LIST_ENTRY DhcpGlobalFreeRecvList;
EXTERN LIST_ENTRY DhcpGlobalActiveRecvList;
EXTERN CRITICAL_SECTION DhcpGlobalRecvListCritSect;
EXTERN HANDLE DhcpGlobalRecvEvent;
EXTERN HANDLE DhcpGlobalMessageRecvHandle;

EXTERN DWORD DhcpGlobalRpcProtocols;
EXTERN BOOL DhcpGlobalRpcStarted;

EXTERN WCHAR DhcpGlobalServerName[MAX_COMPUTERNAME_LENGTH + 1];
EXTERN DWORD DhcpGlobalServerNameLen; // computer name len in bytes.
EXTERN HANDLE DhcpGlobalRecomputeTimerEvent;

EXTERN BOOL DhcpGlobalSystemShuttingDown;
EXTERN BOOL DhcpGlobalServiceStopping;

#if DBG
#define DEFAULT_MAXIMUM_DEBUGFILE_SIZE 20000000

EXTERN DWORD DhcpGlobalDebugFlag;
EXTERN CRITICAL_SECTION DhcpGlobalDebugFileCritSect;
EXTERN HANDLE DhcpGlobalDebugFileHandle;
EXTERN DWORD DhcpGlobalDebugFileMaxSize;
EXTERN LPWSTR DhcpGlobalDebugSharePath;

#endif // DBG

//
// MIB Counters;
//

DHCP_PERF_STATS *PerfStats;
DATE_TIME DhcpGlobalServerStartTime;

//
// misc
//
EXTERN DWORD DhcpGlobalIgnoreBroadcastFlag;     // whether to ignore the broadcast
                                                // bit in the client requests or not
EXTERN HANDLE g_hAuditLog;                      // audit log file handle
EXTERN DWORD DhcpGlobalAuditLogMaxSizeInBytes;  // max size of audit logging flie..

EXTERN DWORD DynamicDNSTimeToLive;

//
// string table stuff
//

#define  DHCP_FIRST_STRING DHCP_IP_LOG_ASSIGN_NAME
#define  DHCP_LAST_STRING  DHCP_LAST_STRING_DUMMY_MESSAGE
#define  DHCP_CSTRINGS (DHCP_LAST_STRING - DHCP_FIRST_STRING + 1)

#ifdef DBG
#define GETSTRING( dwID ) GetString( dwID )
#else
#define GETSTRING( dwID )  (g_ppszStrings[ dwID - DHCP_FIRST_STRING ])
#endif


EXTERN WCHAR  *g_ppszStrings[ DHCP_CSTRINGS ];

#endif // GLOBAL_DATA

//
// Dynamic jet loading
//

EXTERN AddressToInstanceMap *DhcpGlobalAddrToInstTable;
EXTERN HANDLE                DhcpGlobalTCPHandle;

EXTERN CRITICAL_SECTION    DhcpGlobalCacheCritSect;
EXTERN BOOL  DhcpGlobalUseNoDns;

EXTERN SOCKET   DhcpGlobalPnPNotificationSocket;
EXTERN HANDLE   DhcpGlobalEndpointReadyEvent;

EXTERN ULONG    DhcpGlobalAlertPercentage;
EXTERN ULONG    DhcpGlobalAlertCount;

//
// Debug only flag... dont use it when not in DBG build..
//
EXTERN BOOL fDhcpGlobalProcessInformsOnlyFlag;

//
// Is Dynamic BOOTP Enabled for this server?
//
EXTERN BOOL DhcpGlobalDynamicBOOTPEnabled;

//
// Are we bindings aware? By default we are.
//
EXTERN BOOL DhcpGlobalBindingsAware;

// how much clock skew allowed between madcap client and server
EXTERN DWORD DhcpGlobalClockSkewAllowance;
//how much extra allocation due to clock skew
EXTERN DWORD DhcpGlobalExtraAllocationTime;
//
// SIDs for dhcp users group and dhcp administrators group
//
EXTERN PSID DhcpSid;
EXTERN PSID DhcpAdminSid;

EXTERN ULONG DhcpGlobalMsft2000Class;
EXTERN ULONG DhcpGlobalMsft98Class;
EXTERN ULONG DhcpGlobalMsftClass;

EXTERN CRITICAL_SECTION DhcpGlobalEndPointCS;

//
// Security descriptors of Netlogon Service objects to control user accesses.
//


EXTERN PSECURITY_DESCRIPTOR DhcpGlobalSecurityDescriptor;
//
// Generic mapping for each Netlogon Service object object
//

EXTERN GENERIC_MAPPING DhcpGlobalSecurityInfoMapping
#ifdef GLOBAL_DATA_ALLOCATE
    = {
    STANDARD_RIGHTS_READ,                  // Generic read
    STANDARD_RIGHTS_WRITE,                 // Generic write
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    DHCP_ALL_ACCESS                        // Generic all
    }
#endif // GLOBAL_DATA_ALLOCATE
    ;

//
// Flag to indicate that the WELL known SID are made.
//

EXTERN BOOL DhcpGlobalWellKnownSIDsMade;

EXTERN ULONG DhcpGlobalServerPort, DhcpGlobalClientPort;

EXTERN DWORD DhcpGlobalRestoreStatus;
EXTERN BOOL DhcpGlobalImpersonated;

EXTERN PM_SERVER DhcpGlobalThisServer;

//================================================================================
// end of file
//================================================================================

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dhcp_srv.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for dhcp_srv.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust dhcp_bug_compatibility
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>
#include "dhcp_srv.h"

#define TYPE_FORMAT_STRING_SIZE   1519                              
#define PROC_FORMAT_STRING_SIZE   2359                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: dhcpsrv, ver. 1.0,
   GUID={0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}} */


extern const MIDL_SERVER_INFO dhcpsrv_ServerInfo;

extern RPC_DISPATCH_TABLE dhcpsrv_DispatchTable;

static const RPC_SERVER_INTERFACE dhcpsrv___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &dhcpsrv_DispatchTable,
    0,
    0,
    0,
    &dhcpsrv_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE dhcpsrv_ServerIfHandle = (RPC_IF_HANDLE)& dhcpsrv___RpcServerInterface;

extern const MIDL_STUB_DESC dhcpsrv_StubDesc;

extern const EXPR_EVAL ExprEvalRoutines[];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 Professional or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure R_DhcpCreateSubnet */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 22 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 30 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 32 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 36 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 38 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 42 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 44 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 46 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Return value */

/* 48 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 50 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 52 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSubnetInfo */

/* 54 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 56 */	NdrFcLong( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x1 ),	/* 1 */
#ifndef _ALPHA_
/* 62 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 64 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 66 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 68 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 70 */	NdrFcShort( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8 ),	/* 8 */
/* 74 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 76 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 78 */	NdrFcShort( 0x0 ),	/* 0 */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 84 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 86 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 88 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 90 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 92 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 96 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 98 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 100 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 104 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSubnetInfo */

/* 108 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x2 ),	/* 2 */
#ifndef _ALPHA_
/* 116 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 118 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 120 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 122 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 130 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 138 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 140 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 144 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 146 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 150 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 152 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 154 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 158 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnets */

/* 162 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 164 */	NdrFcLong( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x3 ),	/* 3 */
#ifndef _ALPHA_
/* 170 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 172 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 174 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 176 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 178 */	NdrFcShort( 0x24 ),	/* 36 */
/* 180 */	NdrFcShort( 0x5c ),	/* 92 */
/* 182 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 184 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 186 */	NdrFcShort( 0x1 ),	/* 1 */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 192 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 194 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 196 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 198 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 200 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 202 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 206 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumInfo */

/* 210 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 212 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 214 */	NdrFcShort( 0x50 ),	/* Type Offset=80 */

	/* Parameter ElementsRead */

/* 216 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 218 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 222 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 224 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 230 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElement */

/* 234 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0x4 ),	/* 4 */
#ifndef _ALPHA_
/* 242 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 244 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 246 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 248 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 254 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 256 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x2 ),	/* 2 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 264 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 266 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 268 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 270 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 272 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 276 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 278 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 280 */	NdrFcShort( 0xf6 ),	/* Type Offset=246 */

	/* Return value */

/* 282 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 284 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElements */

/* 288 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 290 */	NdrFcLong( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x5 ),	/* 5 */
#ifndef _ALPHA_
/* 296 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
#else
			NdrFcShort( 0x48 ),	/* Alpha Stack size/offset = 72 */
#endif
/* 298 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 300 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 302 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 304 */	NdrFcShort( 0x32 ),	/* 50 */
/* 306 */	NdrFcShort( 0x5c ),	/* 92 */
/* 308 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 310 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 312 */	NdrFcShort( 0x3 ),	/* 3 */
/* 314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 316 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 318 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 320 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 322 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 324 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 326 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 330 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 332 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 334 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 336 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 338 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 344 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 346 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 348 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 350 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 352 */	NdrFcShort( 0x104 ),	/* Type Offset=260 */

	/* Parameter ElementsRead */

/* 354 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 356 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 360 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 362 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 366 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 368 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElement */

/* 372 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 374 */	NdrFcLong( 0x0 ),	/* 0 */
/* 378 */	NdrFcShort( 0x6 ),	/* 6 */
#ifndef _ALPHA_
/* 380 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 382 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 384 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 386 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 388 */	NdrFcShort( 0xe ),	/* 14 */
/* 390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 392 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 394 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 396 */	NdrFcShort( 0x0 ),	/* 0 */
/* 398 */	NdrFcShort( 0x2 ),	/* 2 */
/* 400 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 402 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 404 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 406 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 410 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 414 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 416 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 418 */	NdrFcShort( 0xf6 ),	/* Type Offset=246 */

	/* Parameter ForceFlag */

/* 420 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 424 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 428 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSubnet */

/* 432 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 440 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 442 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 444 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 446 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 448 */	NdrFcShort( 0xe ),	/* 14 */
/* 450 */	NdrFcShort( 0x8 ),	/* 8 */
/* 452 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 454 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 462 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 464 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 466 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 468 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 470 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 472 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ForceFlag */

/* 474 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 476 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 478 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 480 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 482 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateOption */

/* 486 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 488 */	NdrFcLong( 0x0 ),	/* 0 */
/* 492 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 494 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 496 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 498 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 500 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 502 */	NdrFcShort( 0x8 ),	/* 8 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 508 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x4 ),	/* 4 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 516 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 518 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 520 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 522 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 524 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 528 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 530 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 532 */	NdrFcShort( 0x1b2 ),	/* Type Offset=434 */

	/* Return value */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 536 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionInfo */

/* 540 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 548 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 550 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 552 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 554 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 556 */	NdrFcShort( 0x8 ),	/* 8 */
/* 558 */	NdrFcShort( 0x8 ),	/* 8 */
/* 560 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 562 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x4 ),	/* 4 */
/* 568 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 570 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 572 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 574 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 576 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 578 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 580 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 582 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 584 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 586 */	NdrFcShort( 0x1b2 ),	/* Type Offset=434 */

	/* Return value */

/* 588 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 590 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 592 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionInfo */

/* 594 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 596 */	NdrFcLong( 0x0 ),	/* 0 */
/* 600 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 602 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 604 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 606 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 608 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
/* 612 */	NdrFcShort( 0x8 ),	/* 8 */
/* 614 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 616 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 618 */	NdrFcShort( 0x4 ),	/* 4 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 624 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 626 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 628 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 630 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 632 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 636 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 638 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 640 */	NdrFcShort( 0x1cc ),	/* Type Offset=460 */

	/* Return value */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 644 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOption */

/* 648 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 656 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 658 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 660 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 662 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 664 */	NdrFcShort( 0x8 ),	/* 8 */
/* 666 */	NdrFcShort( 0x8 ),	/* 8 */
/* 668 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 670 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 678 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 680 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 682 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 686 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 690 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 692 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValue */

/* 696 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 698 */	NdrFcLong( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 704 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 706 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 708 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 710 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 712 */	NdrFcShort( 0x8 ),	/* 8 */
/* 714 */	NdrFcShort( 0x8 ),	/* 8 */
/* 716 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 718 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x5 ),	/* 5 */
/* 724 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 726 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 728 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 730 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 732 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 734 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 736 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 738 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 740 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 742 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValue */

/* 744 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 746 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 748 */	NdrFcShort( 0x19e ),	/* Type Offset=414 */

	/* Return value */

/* 750 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 752 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 754 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionValue */

/* 756 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 758 */	NdrFcLong( 0x0 ),	/* 0 */
/* 762 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 764 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 766 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 768 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 770 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 772 */	NdrFcShort( 0x8 ),	/* 8 */
/* 774 */	NdrFcShort( 0x8 ),	/* 8 */
/* 776 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 778 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 780 */	NdrFcShort( 0x4 ),	/* 4 */
/* 782 */	NdrFcShort( 0x1 ),	/* 1 */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 786 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 788 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 790 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 792 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 794 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 798 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 800 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 802 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValue */

/* 804 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 806 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 808 */	NdrFcShort( 0x218 ),	/* Type Offset=536 */

	/* Return value */

/* 810 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 812 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptionValues */

/* 816 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 818 */	NdrFcLong( 0x0 ),	/* 0 */
/* 822 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 824 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 826 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 828 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 830 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 832 */	NdrFcShort( 0x24 ),	/* 36 */
/* 834 */	NdrFcShort( 0x5c ),	/* 92 */
/* 836 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 838 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 840 */	NdrFcShort( 0x5 ),	/* 5 */
/* 842 */	NdrFcShort( 0x1 ),	/* 1 */
/* 844 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 846 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 848 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 850 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 852 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 854 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 856 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter ResumeHandle */

/* 858 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 860 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 864 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 866 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionValues */

/* 870 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 872 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 874 */	NdrFcShort( 0x24c ),	/* Type Offset=588 */

	/* Parameter OptionsRead */

/* 876 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 878 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 880 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 882 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 884 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 888 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 890 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOptionValue */

/* 894 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 896 */	NdrFcLong( 0x0 ),	/* 0 */
/* 900 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 902 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 904 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 906 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 908 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 910 */	NdrFcShort( 0x8 ),	/* 8 */
/* 912 */	NdrFcShort( 0x8 ),	/* 8 */
/* 914 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 916 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 920 */	NdrFcShort( 0x1 ),	/* 1 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 924 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 926 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 928 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 932 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 936 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 938 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 940 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Return value */

/* 942 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 944 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfo */

/* 948 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 950 */	NdrFcLong( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 956 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 958 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 960 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 962 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 966 */	NdrFcShort( 0x8 ),	/* 8 */
/* 968 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 970 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 972 */	NdrFcShort( 0x0 ),	/* 0 */
/* 974 */	NdrFcShort( 0x1 ),	/* 1 */
/* 976 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 978 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 980 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 982 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 984 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 986 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 988 */	NdrFcShort( 0x29a ),	/* Type Offset=666 */

	/* Return value */

/* 990 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 992 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 994 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfo */

/* 996 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 998 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1002 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 1004 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1006 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1008 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1010 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1014 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1016 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1018 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1020 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1022 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1024 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1026 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1028 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1030 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1032 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1034 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1036 */	NdrFcShort( 0x29a ),	/* Type Offset=666 */

	/* Return value */

/* 1038 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1040 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1042 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfo */

/* 1044 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1046 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1050 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 1052 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1054 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1056 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1058 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1064 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1066 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1068 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1070 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1074 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1076 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1078 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 1080 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1082 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1084 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Parameter ClientInfo */

/* 1086 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1088 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1090 */	NdrFcShort( 0x316 ),	/* Type Offset=790 */

	/* Return value */

/* 1092 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1094 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1096 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteClientInfo */

/* 1098 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1100 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0x13 ),	/* 19 */
#ifndef _ALPHA_
/* 1106 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1108 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1110 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1112 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1118 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1120 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1126 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1128 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1130 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1132 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1134 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1136 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1138 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Return value */

/* 1140 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1142 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClients */

/* 1146 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1148 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1152 */	NdrFcShort( 0x14 ),	/* 20 */
#ifndef _ALPHA_
/* 1154 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 1156 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1158 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1160 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1162 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1164 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1166 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1168 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1170 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1174 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1178 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1180 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1182 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1184 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1188 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1190 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1194 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1196 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 1200 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1202 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1204 */	NdrFcShort( 0x31e ),	/* Type Offset=798 */

	/* Parameter ClientsRead */

/* 1206 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1208 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 1212 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1214 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1220 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientOptions */

/* 1224 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x15 ),	/* 21 */
#ifndef _ALPHA_
/* 1232 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1234 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1236 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1238 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1240 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1242 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1244 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1246 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1248 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1252 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1254 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1256 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1258 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientIpAddress */

/* 1260 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientSubnetMask */

/* 1266 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientOptions */

/* 1272 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1274 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1276 */	NdrFcShort( 0x24c ),	/* Type Offset=588 */

	/* Return value */

/* 1278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1280 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetMibInfo */

/* 1284 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1290 */	NdrFcShort( 0x16 ),	/* 22 */
#ifndef _ALPHA_
/* 1292 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1294 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1296 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1298 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1304 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1306 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1308 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1314 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1316 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1318 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MibInfo */

/* 1320 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1322 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1324 */	NdrFcShort( 0x35a ),	/* Type Offset=858 */

	/* Return value */

/* 1326 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1328 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptions */

/* 1332 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1334 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1338 */	NdrFcShort( 0x17 ),	/* 23 */
#ifndef _ALPHA_
/* 1340 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1342 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1344 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1346 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1348 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1350 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1352 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1354 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1356 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1360 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1362 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1364 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1366 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 1368 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1370 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1374 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1376 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Options */

/* 1380 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1382 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1384 */	NdrFcShort( 0x39c ),	/* Type Offset=924 */

	/* Parameter OptionsRead */

/* 1386 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1388 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1390 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 1392 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1394 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1398 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1400 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alp