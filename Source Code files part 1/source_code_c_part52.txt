ttempt to count disk space used by a file tree
//
//  Arguments:  [pwszDir] -- directory name
//              [pllTotalBytes] -- output counter
//              [pfStop] -- TRUE if stop signalled
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD GetFileSize_Recurse (const WCHAR *pwszDir, 
                           INT64 *pllTotalBytes,
                           BOOL *pfStop)
{
    DWORD dwErr = ERROR_SUCCESS;
    WIN32_FIND_DATA fd;
    HANDLE hFile;
    WCHAR wcsPath[MAX_PATH];

    lstrcpy (wcsPath, pwszDir);
    lstrcat (wcsPath, TEXT("\\*.*"));

    hFile = FindFirstFile(wcsPath, &fd);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        return dwErr;
    }

    do
    {
        if (pfStop != NULL && TRUE == *pfStop)
        {
            FindClose (hFile);
            return ERROR_OPERATION_ABORTED;
        }

        if (!lstrcmp(fd.cFileName, L".") || !lstrcmp(fd.cFileName, L".."))
        {
            continue;
        }

        lstrcpy (wcsPath, pwszDir);       // construct the full path name
        lstrcat (wcsPath, TEXT("\\"));
        lstrcat (wcsPath, fd.cFileName);

        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            //
            // Found a directory.  Skip mount points
            //

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            {
                continue;
            }

            dwErr = GetFileSize_Recurse(wcsPath, pllTotalBytes, pfStop);
            if (dwErr != ERROR_SUCCESS)
            {
                FindClose(hFile);
                return dwErr;
            }
        }
        else
        {
            //
            // We found a file.  Update the counter
            //

            ULARGE_INTEGER ulTemp;
            ulTemp.LowPart = fd.nFileSizeLow;
            ulTemp.HighPart = fd.nFileSizeHigh;

#if 0
            ulTemp.LowPart = GetCompressedFileSize (wcsPath, &ulTemp.HighPart);

            dwErr = (ulTemp.LowPart == 0xFFFFFFFF) ? GetLastError() :
                                                     ERROR_SUCCESS;

            if (dwErr != ERROR_SUCCESS)
            {
                FindClose (hFile);
                return dwErr;
            }
#endif

            *pllTotalBytes += ulTemp.QuadPart;

            // The file size does not contain the size of the
            // NTFS alternate data streams
        }

    } while (FindNextFile(hFile, &fd));   // Find the next entry

    FindClose(hFile);  // Close the search handle

    return ERROR_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   CompressFile
//
//  Synopsis:   attempt to compress to decompress an NTFS file
//
//  Arguments:  [pwszPath] -- directory or file name
//              [fCompress] -- TRUE compress, FALSE decompress
//              [fDirectory] -- TRUE if directory, FALSE if file
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CompressFile (const WCHAR *pwszPath, BOOL fCompress, BOOL fDirectory)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwReturned = 0;

    TENTER("CompressFile");

    if (pwszPath == NULL)
        return ERROR_INVALID_PARAMETER;

    DWORD dwFileAttr = GetFileAttributes(pwszPath);

    if (dwFileAttr != 0xFFFFFFFF && (dwFileAttr & FILE_ATTRIBUTE_READONLY))
    {
        dwFileAttr &= ~FILE_ATTRIBUTE_READONLY;
        if (FALSE == SetFileAttributes (pwszPath, dwFileAttr))
        {
            TRACE(0, "SetFileAttributes ignoring %ld", GetLastError());
        }
        else dwFileAttr |= FILE_ATTRIBUTE_READONLY;
    }

    USHORT usFormat = fCompress ? COMPRESSION_FORMAT_DEFAULT :
                                  COMPRESSION_FORMAT_NONE;

    HANDLE hFile = CreateFile( pwszPath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        fDirectory ? FILE_FLAG_BACKUP_SEMANTICS : 0,
                        NULL );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        TRACE(0, "CompressFile: cannot open %ld %ws", dwErr, pwszPath);
        return dwErr;
    }

    if (FALSE == DeviceIoControl (hFile,
                                  FSCTL_SET_COMPRESSION,
                                  &usFormat, sizeof(usFormat),
                                  NULL, 0, &dwReturned, NULL))
    {
        dwErr = GetLastError();
        TRACE(0, "CompressFile: cannot compress/uncompress %ld %ws", dwErr, pwszPath);
    }

    CloseHandle (hFile);

    if (dwFileAttr != 0xFFFFFFFF && (dwFileAttr & FILE_ATTRIBUTE_READONLY))
    {
        if (FALSE == SetFileAttributes (pwszPath, dwFileAttr))
        {
            TRACE(0, "SetFileAttributes failed ignoring %ld", GetLastError());
        }
    }

    TLEAVE();
 
    return dwErr;
}


// returns system drive - as L"C:\\" if C: is the system drive

BOOL
GetSystemDrive(LPWSTR pszDrive)
{
    if (pszDrive)
        return ExpandEnvironmentStrings(L"%SystemDrive%\\", pszDrive, MAX_SYS_DRIVE);
    else
        return FALSE;
}


// BUGBUG - pszDrive should have driveletter in caps, 
// and needs to be of format L"C:\\" if C: is the system drive

BOOL
IsSystemDrive(LPWSTR pszDriveOrGuid)
{
    WCHAR   szSystemDrive[MAX_PATH];
    WCHAR   szSystemGuid[MAX_PATH];

    if (pszDriveOrGuid)
    {
        if (0 == ExpandEnvironmentStrings(L"%SystemDrive%\\", szSystemDrive, sizeof(szSystemDrive)/sizeof(WCHAR)))
        {
            return FALSE;
        }
        
        if (0 == wcsncmp(pszDriveOrGuid, L"\\\\?\\Volume", 10))  // guid
        {
            if (! GetVolumeNameForVolumeMountPoint(szSystemDrive, szSystemGuid, MAX_PATH))
            {
                return FALSE;
            }
        
            return lstrcmpi(pszDriveOrGuid, szSystemGuid) ? FALSE : TRUE;
        }
        else        // drive
        {
            return lstrcmpi(pszDriveOrGuid, szSystemDrive) ? FALSE : TRUE;
        }
    }
    else
    {
        return FALSE;
    }
}


DWORD
RegReadDWORD(HKEY hKey, LPCWSTR pszName, PDWORD pdwValue)
{
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwRc = RegQueryValueEx(hKey, pszName, 0, &dwType, (LPBYTE) pdwValue, &dwSize);
    return dwRc;
 }


DWORD
RegWriteDWORD(HKEY hKey, LPCWSTR pszName, PDWORD pdwValue)
{
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwRc = RegSetValueEx(hKey, pszName, 0, dwType, (LPBYTE) pdwValue, dwSize);
    return dwRc;
 }


// function that returns n where pszStr is of form <someprefix>n

ULONG 
GetID(
    LPCWSTR pszStr)
{
    ULONG    ulID = 0;

    while (*pszStr && (*pszStr < L'0' || *pszStr > L'9')) 
        pszStr++;

    ulID = (ULONG) _wtol(pszStr);
    return ulID;
}

LPWSTR 
GetMachineGuid()
{
    HKEY            hKey = NULL;
    static WCHAR    s_szGuid[GUID_STRLEN] = L"";
    static LPWSTR   s_pszGuid = NULL;

    if (! s_pszGuid) // first time
    {        
        ULONG ulType, ulSize = sizeof(s_szGuid);
        DWORD dwErr;

        dwErr = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              s_cszSRCfgRegKey, 0,
                              KEY_READ, &hKey);
        
        if (dwErr != ERROR_SUCCESS)
            goto Err;
        
        dwErr = RegQueryValueEx (hKey, s_cszSRMachineGuid,
                                 0, &ulType, (BYTE *) &s_szGuid,
                                 &ulSize);
        
        if (dwErr != ERROR_SUCCESS)
            goto Err;

        s_pszGuid = (LPWSTR) s_szGuid;
    }

Err:
    if (hKey)
        RegCloseKey(hKey);

    return s_pszGuid;
}        


// util function to construct <pszDrive>_Restore.{MachineGuid}\\pszSuffix

LPWSTR
MakeRestorePath(LPWSTR pszDest, LPCWSTR pszDrive, LPCWSTR pszSuffix)
{
    LPWSTR pszGuid = GetMachineGuid();   
    
    wsprintf(pszDest, 
             L"%s%s\\%s", 
             pszDrive, 
             s_cszSysVolInfo,
             s_cszRestoreDir);

    if (pszGuid)
    {
//        lstrcat(pszDest, L".");
        lstrcat(pszDest, pszGuid);
    }

    if (pszSuffix && lstrlen(pszSuffix) > 0)
    {
        lstrcat(pszDest, L"\\");
        lstrcat(pszDest, pszSuffix);
    }    

    return pszDest;
}


// set start type of specified service directly in the registry

DWORD
SetServiceStartupRegistry(LPCWSTR pszName, DWORD dwStartType)
{
    DWORD           dwRc;
    HKEY            hKey = NULL;
    WCHAR           szKey[MAX_PATH];

    lstrcpy(szKey, L"System\\CurrentControlSet\\Services\\");
    lstrcat(szKey, pszName);

    dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, KEY_WRITE, NULL, &hKey);
    if (ERROR_SUCCESS != dwRc)
        goto done;

    dwRc = RegWriteDWORD(hKey, L"Start", &dwStartType);

done:
    if (hKey)
        RegCloseKey(hKey);
    return dwRc;
}


// get start type of specified service directly from the registry

DWORD
GetServiceStartupRegistry(LPCWSTR pszName, PDWORD pdwStartType)
{
    DWORD           dwRc;
    HKEY            hKey = NULL;
    WCHAR           szKey[MAX_PATH];

    lstrcpy(szKey, L"System\\CurrentControlSet\\Services\\");
    lstrcat(szKey, pszName);

    dwRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, KEY_QUERY_VALUE, NULL, &hKey);
    if (ERROR_SUCCESS != dwRc)
        goto done;

    dwRc = RegReadDWORD(hKey, L"Start", pdwStartType);

done:
    if (hKey)
        RegCloseKey(hKey);
    return dwRc;
}

DWORD
SetServiceStartup(LPCWSTR pszName, DWORD dwStartType)
{
    TraceFunctEnter("SetServiceStartup");
    
    DWORD           dwError=ERROR_INTERNAL_ERROR;
    SC_HANDLE       hService=NULL;
    SC_HANDLE       hSCManager=NULL;
    
    hSCManager = OpenSCManager(NULL,   // computer name - local machine
                               NULL,//SCM DB name - SERVICES_ACTIVE_DATABASE
                               SC_MANAGER_ALL_ACCESS);    // access type
    if( NULL == hSCManager)
    {
        dwError = GetLastError();
         // file not found
        DebugTrace(TRACEID,"OpenSCManager failed 0x%x", dwError);
        goto done;        
    }
    
    hService = OpenService(hSCManager,  // handle to SCM database
                           pszName, // service name
                           SERVICE_CHANGE_CONFIG);  // access

    if( NULL == hService)
    {
        dwError = GetLastError();
         // file not found
        DebugTrace(TRACEID,"OpenService failed 0x%x", dwError);
        goto done;        
    }


    if (FALSE==ChangeServiceConfig( hService,     // handle to service
                                    SERVICE_NO_CHANGE, // type of service
                                    dwStartType, // when to start service
                                    SERVICE_NO_CHANGE, // severity of start failure
                                    NULL,   // service binary file name
                                    NULL,   // load ordering group name
                                    NULL,          // tag identifier
                                    NULL,     // array of dependency names
                                    NULL, // account name
                                    NULL,         // account password
                                    NULL))       // display name
    {
        dwError = GetLastError();
         // file not found
        DebugTrace(TRACEID,"ChangeServiceConfig failed 0x%x", dwError);
        goto done;
    }

    dwError = ERROR_SUCCESS;

done:
    if (NULL != hService)
    {
        _VERIFY(CloseServiceHandle(hService)); // handle to service or
                                               // SCM object
    }

    if (NULL != hSCManager)
    {
        _VERIFY(CloseServiceHandle(hSCManager)); // handle to service or
                                                 // SCM object
    }
    
    if ((dwError != ERROR_SUCCESS) && (dwError != ERROR_ACCESS_DENIED))
    {
         // service control methods failed. Just update the registry
         // directly
        dwError = SetServiceStartupRegistry(pszName, dwStartType);
    }
    
    TraceFunctLeave();
    return dwError;
}


DWORD
GetServiceStartup(LPCWSTR pszName, PDWORD pdwStartType)
{
    TraceFunctEnter("SetServiceStartup");
    
    DWORD           dwError=ERROR_INTERNAL_ERROR;
    SC_HANDLE       hService=NULL;
    SC_HANDLE       hSCManager=NULL;
    QUERY_SERVICE_CONFIG *pconfig = NULL;
    DWORD           cbBytes = 0, cbBytes2 = 0;


    hSCManager = OpenSCManager(NULL,   // computer name - local machine
                               NULL,//SCM DB name - SERVICES_ACTIVE_DATABASE
                               SC_MANAGER_ALL_ACCESS);    // access type
    if( NULL == hSCManager)
    {
        dwError = GetLastError();
         // file not found
        DebugTrace(TRACEID,"OpenSCManager failed 0x%x", dwError);
        goto done;        
    }
    
    hService = OpenService(hSCManager,  // handle to SCM database
                           pszName, // service name
                           SERVICE_QUERY_CONFIG);  // access

    if( NULL == hService)
    {
        dwError = GetLastError();
         // file not found
        DebugTrace(TRACEID,"OpenService failed 0x%x", dwError);
        goto done;        
    }

    if (FALSE==QueryServiceConfig( hService,     // handle to service
                                   NULL,
                                   0,
                                   &cbBytes ))
    {
        dwError = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == dwError)
        {
            pconfig = (QUERY_SERVICE_CONFIG *) SRMemAlloc(cbBytes);
            if (!pconfig)
            {
                trace(TRACEID, "! SRMemAlloc");
                goto done;
            }
                
            if (FALSE==QueryServiceConfig( hService,     // handle to service
                                           pconfig,
                                           cbBytes,
                                           &cbBytes2 ))
            {
                dwError = GetLastError();
                DebugTrace(TRACEID,"! QueryServiceConfig (second) : %ld", dwError);
                goto done;
            }

            if (pdwStartType)
            {
                *pdwStartType = pconfig->dwStartType;
            }
            
            dwError = ERROR_SUCCESS;
        }
        else
        {
            trace(TRACEID, "! QueryServiceConfig (first) : %ld", dwError);
        }
    }

done:
    SRMemFree(pconfig);
    
    if (NULL != hService)
    {
        _VERIFY(CloseServiceHandle(hService)); // handle to service or
                                               // SCM object
    }

    if (NULL != hSCManager)
    {
        _VERIFY(CloseServiceHandle(hSCManager)); // handle to service or
                                                 // SCM object
    }
            
    TraceFunctLeave();
    return dwError;
}


// this function returns whether the SR service is running
BOOL IsSRServiceRunning()
{
    TraceFunctEnter("IsSRServiceRunning");
    
    BOOL            fReturn;
    DWORD           dwError=ERROR_INTERNAL_ERROR;
    SC_HANDLE       hService=NULL;
    SC_HANDLE       hSCManager=NULL;
    SERVICE_STATUS  ServiceStatus;

     // assume FALSE by default
    fReturn = FALSE;
    
    hSCManager = OpenSCManager(NULL,   // computer name - local machine
                               NULL,//SCM DB name - SERVICES_ACTIVE_DATABASE
                               SC_MANAGER_ALL_ACCESS);    // access type
    if( NULL == hSCManager)
    {
        dwError = GetLastError();
        DebugTrace(TRACEID,"OpenSCManager failed 0x%x", dwError);
        goto done;        
    }
    
    hService = OpenService(hSCManager,  // handle to SCM database
                           s_cszServiceName, // service name
                           SERVICE_QUERY_STATUS);  // access

    if( NULL == hService)
    {
        dwError = GetLastError();
        DebugTrace(TRACEID,"OpenService failed 0x%x", dwError);
        goto done;        
    }

    if (FALSE == QueryServiceStatus(hService, // handle to service
                                    &ServiceStatus)) // service status
    {
        dwError = GetLastError();
        DebugTrace(TRACEID,"QueryServiceStatus failed 0x%x", dwError);
        goto done;
    }

    if (ServiceStatus.dwCurrentState == SERVICE_RUNNING)
    {
        fReturn = TRUE;
    }
    else
    {
        DebugTrace(TRACEID,"SR Service is not running");
        fReturn = FALSE;
    }

done:
    if (NULL != hService)
    {
        _VERIFY(CloseServiceHandle(hService)); // handle to service or
                                               // SCM object
    }

    if (NULL != hSCManager)
    {
        _VERIFY(CloseServiceHandle(hSCManager)); // handle to service or
                                                 // SCM object
    }
    
    TraceFunctLeave();
    return fReturn;
}


// this function returns whether the SR service is running
BOOL IsSRServiceStopped(SC_HANDLE hService)
{
    TraceFunctEnter("IsSRServiceStopped");
    SERVICE_STATUS  ServiceStatus;
    BOOL            fReturn;
    DWORD           dwError;
    
     // assume FALSE by default
    fReturn = FALSE;
    
    if (FALSE == QueryServiceStatus(hService, // handle to service
                                    &ServiceStatus)) // service status
    {
        dwError = GetLastError();
        DebugTrace(TRACEID,"QueryServiceStatus failed 0x%x", dwError);
        goto done;
    }

    if (ServiceStatus.dwCurrentState == SERVICE_STOPPED)
    {
        DebugTrace(TRACEID,"SR Service is not running");        
        fReturn = TRUE;
    }
    else
    {
        DebugTrace(TRACEID,"SR Service is running");
        fReturn = FALSE;
    }

done:
    
    TraceFunctLeave();
    return fReturn;
}




// private function to stop the SR service
// fWait - if TRUE : function is synchronous - waits till service is stopped completely
//        if FALSE : function is asynchronous - does not wait for service to complete stopping

BOOL  StopSRService(BOOL fWait)
{
    TraceFunctEnter("StopSRService");
    
    BOOL  fReturn=FALSE;
    SC_HANDLE   hSCManager;
    SERVICE_STATUS ServiceStatus;
    SC_HANDLE hService=NULL;
    DWORD  dwError;
    
    hSCManager = OpenSCManager(NULL,   // computer name - local machine
                               NULL,//SCM DB name - SERVICES_ACTIVE_DATABASE
                               SC_MANAGER_ALL_ACCESS);    // access type
    if (NULL == hSCManager)
    {
        dwError = GetLastError();
        DebugTrace(TRACEID,"OpenSCManager failed 0x%x", dwError);        
        goto done;        
    }
    
    hService = OpenService(hSCManager,  // handle to SCM database
                           s_cszServiceName, // service name
                           SERVICE_ALL_ACCESS);  // access

    if( NULL == hService)
    {
        dwError = GetLastError();
        DebugTrace(TRACEID,"OpenService failed 0x%x", dwError);
        goto done;        
    }

    fReturn = ControlService(hService,               // handle to service
                             SERVICE_CONTROL_STOP,   // control code
                             &ServiceStatus);  // status information

    if (FALSE == fReturn)
    {
        dwError = GetLastError();
        DebugTrace(TRACEID,"ControlService failed 0x%x", dwError);
        goto done;
    }
    
    if (fWait)                
    {
        DWORD dwCount;
        
         //
         // query the service until it stops
         // try thrice
         //
        Sleep(500);
        for (dwCount=0; dwCount < 3; dwCount++)
        {
            if (TRUE == IsSRServiceStopped(hService))
            {
                break;
            }
            Sleep(2000);
        }
        if (dwCount == 3)
        {
            fReturn=IsSRServiceStopped(hService);
        }
        else
        {
            fReturn=TRUE;
        }
    }

done:

    if (NULL != hService)
    {
        _VERIFY(CloseServiceHandle(hService)); // handle to service or
                                               // SCM object
    }

    if (NULL != hSCManager)
    {
        _VERIFY(CloseServiceHandle(hSCManager)); // handle to service or
                                                 // SCM object
    }
    
    TraceFunctLeave();    
    return fReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetLsaSecret
//
//  Synopsis:   obtains the LSA secret info as Unicode strings
//
//  Arguments:  [hPolicy] -- LSA policy object handle
//              [wszSecret] -- secret name
//              [ppusSecretValue] -- dynamically allocated value
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD GetLsaSecret (LSA_HANDLE hPolicy, const WCHAR *wszSecret,
                    UNICODE_STRING ** ppusSecretValue)
{
    TENTER ("GetLsaSecret");

    LSA_HANDLE hSecret;
    UNICODE_STRING usSecretName;
    DWORD dwErr = ERROR_SUCCESS;

    RtlInitUnicodeString (&usSecretName, wszSecret);
    if (LSA_SUCCESS (LsaOpenSecret (hPolicy,
                                    &usSecretName,
                                    SECRET_QUERY_VALUE,
                                    &hSecret)))
    {
        if (!LSA_SUCCESS (LsaQuerySecret (hSecret,
                                         ppusSecretValue,
                                         NULL,
                                         NULL,
                                         NULL)))
        {
            *ppusSecretValue = NULL;

            TRACE(0, "Cannot query secret %ws", wszSecret);
        }
        LsaClose (hSecret);
    }

    TLEAVE();

    return dwErr;
}
 
//+---------------------------------------------------------------------------
//
//  Function:   SetLsaSecret
//
//  Synopsis:   sets the LSA secret info
//
//  Arguments:  [hPolicy] -- LSA policy object handle
//              [wszSecret] -- secret name
//              [wszSecretValue] -- secret value
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD SetLsaSecret (PVOID hPolicy, const WCHAR *wszSecret,
                    WCHAR * wszSecretValue)
{
    TENTER ("SetLsaSecret");

    LSA_HANDLE hSecret;
    UNICODE_STRING usSecretName;
    UNICODE_STRING usSecretValue;
    DWORD dwErr = ERROR_SUCCESS;

    hPolicy = (LSA_HANDLE) hPolicy;

    RtlInitUnicodeString (&usSecretName, wszSecret);
    RtlInitUnicodeString (&usSecretValue, wszSecretValue);

    if (LSA_SUCCESS (LsaOpenSecret (hPolicy,
                                    &usSecretName,
                                    SECRET_SET_VALUE,
                                    &hSecret)))
    {
        if (!LSA_SUCCESS (LsaSetSecret (hSecret,
                                        &usSecretValue,
                                        NULL)))
        {
            TRACE(0, "Cannot set secret %ws", wszSecret);
        }
        LsaClose (hSecret);
    }

    TLEAVE();

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteNtUnicodeString
//
//  Synopsis:   writes a NT unicode string to disk
//
//  Arguments:  [hFile] -- file handle
//              [pus] -- NT unicode string
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD WriteNtUnicodeString (HANDLE hFile, UNICODE_STRING *pus)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cb = 0;

    if (pus != NULL &&
        FALSE == WriteFile (hFile, (BYTE *)pus->Buffer, pus->Length, &cb, NULL))
    {
        dwErr = GetLastError();
    }
    else if (FALSE == WriteFile (hFile, (BYTE *) L"", sizeof(WCHAR), &cb, NULL))
    {
        dwErr = GetLastError();
    }
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetLsaRestoreState
//
//  Synopsis:   gets the LSA machine and autologon password
//
//  Arguments:  [hKeySoftware] -- Software registry key
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD GetLsaRestoreState (HKEY hKeySoftware)
{
    TENTER ("GetLsaRestoreState");

    HKEY                  hKey = NULL;
    LSA_OBJECT_ATTRIBUTES loa;
    LSA_HANDLE            hLsa = NULL;
    DWORD                 dwErr = ERROR_SUCCESS;

    loa.Length                    = sizeof(LSA_OBJECT_ATTRIBUTES);
    loa.RootDirectory             = NULL;
    loa.ObjectName                = NULL;
    loa.Attributes                = 0;
    loa.SecurityDescriptor        = NULL;
    loa.SecurityQualityOfService  = NULL;

    if (LSA_SUCCESS (LsaOpenPolicy(NULL, &loa,
                     POLICY_VIEW_LOCAL_INFORMATION, &hLsa)))
    {
        UNICODE_STRING * pusSecret = NULL;

        dwErr = RegOpenKeyEx (hKeySoftware,
            hKeySoftware == HKEY_LOCAL_MACHINE ? s_cszSRRegKey :
            L"Microsoft\\Windows NT\\CurrentVersion\\SystemRestore", 0,
            KEY_READ | KEY_WRITE, &hKey);

        if (dwErr != ERROR_SUCCESS)
            goto Err;

        if (ERROR_SUCCESS==GetLsaSecret (hLsa, s_cszMachineSecret, &pusSecret))
        {
            if (pusSecret != NULL && pusSecret->Length > 0)
                dwErr = RegSetValueEx (hKey, s_cszMachineSecret,
                                   0, REG_BINARY, (BYTE *) pusSecret->Buffer, 
                                   pusSecret->Length);

            LsaFreeMemory (pusSecret);
            pusSecret = NULL;
        }

        if (ERROR_SUCCESS==GetLsaSecret(hLsa, s_cszAutologonSecret, &pusSecret))
        {
            if (pusSecret != NULL && pusSecret->Length > 0)
                dwErr = RegSetValueEx (hKey, s_cszAutologonSecret,
                                   0, REG_BINARY, (BYTE *) pusSecret->Buffer,
                                   pusSecret->Length);

            LsaFreeMemory (pusSecret);
            pusSecret = NULL;
        }
    }

Err:
    if (hLsa != NULL)
        LsaClose (hLsa);

    if (hKey != NULL)
        RegCloseKey (hKey);

    TLEAVE();

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDomainMembershipInfo
//
//  Synopsis:   writes current domain and computer name into a file
//
//  Arguments:  [pwszPath] -- file name
//              [pwszzBuffer] -- output multistring buffer
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD GetDomainMembershipInfo (WCHAR *pwszPath, WCHAR *pwszzBuffer)
{
    TENTER("GetDomainMembershipInfo");

    POLICY_PRIMARY_DOMAIN_INFO*  ppdi = NULL;
    LSA_OBJECT_ATTRIBUTES        loa;
    LSA_HANDLE                   hLsa = NULL;
    HANDLE                       hFile = INVALID_HANDLE_VALUE;
    DWORD                        dwComputerLength = MAX_COMPUTERNAME_LENGTH + 1;
    DWORD                        dwRc = ERROR_SUCCESS;
    ULONG                        cbWritten;
    WCHAR                        wszComputer[MAX_COMPUTERNAME_LENGTH+1];

    loa.Length                    = sizeof(LSA_OBJECT_ATTRIBUTES);
    loa.RootDirectory             = NULL;
    loa.ObjectName                = NULL;
    loa.Attributes                = 0;
    loa.SecurityDescriptor        = NULL;
    loa.SecurityQualityOfService  = NULL;

    if (FALSE == GetComputerNameW (wszComputer, &dwComputerLength))
    {
        dwRc = GetLastError();
        trace(0, "! GetComputerNameW : %ld", dwRc);
        return dwRc;
    }

    if (LSA_SUCCESS (LsaOpenPolicy(NULL, &loa, 
                     POLICY_VIEW_LOCAL_INFORMATION, &hLsa)))
    {

        if (pwszPath != NULL)
        {
            hFile = CreateFileW ( pwszPath,   // file name
                          GENERIC_WRITE, // file access
                          0,             // share mode
                          NULL,          // SD
                          CREATE_ALWAYS, // how to create
                          0,             // file attributes
                          NULL);         // handle to template file

            if (INVALID_HANDLE_VALUE == hFile)
            {
                dwRc = GetLastError();
                trace(0, "! CreateFileW : %ld", dwRc);            
                goto Err;
            }

            if (FALSE == WriteFile (hFile, (BYTE *) wszComputer,
                (dwComputerLength+1)*sizeof(WCHAR), &cbWritten, NULL))
            {
                dwRc = GetLastError();
                trace(0, "! WriteFile : %ld", dwRc);              
                goto Err;
            }
        }
        if (pwszzBuffer != NULL)
        {
            lstrcpy (pwszzBuffer, wszComputer);
            pwszzBuffer += dwComputerLength + 1;
        }


        if (LSA_SUCCESS (LsaQueryInformationPolicy( hLsa,
                                              PolicyPrimaryDomainInformation,
                                              (VOID **) &ppdi )))
        {
            const WCHAR *pwszFlag = (ppdi->Sid > 0) ? L"1" : L"0";

            if (pwszPath != NULL)
            {
                dwRc = WriteNtUnicodeString (hFile, &ppdi->Name);
                if (dwRc != ERROR_SUCCESS)
                {
                    trace(0, "! WriteNtUnicodeString : %ld", dwRc);
                }
                if (FALSE == WriteFile (hFile, (BYTE *) pwszFlag,
                    (lstrlenW(pwszFlag)+1)*sizeof(WCHAR), &cbWritten, NULL))
                {
                    dwRc = GetLastError();
                    trace(0, "! WriteFile : %ld", dwRc);
                    goto Err;
                }
            }
            if (pwszzBuffer != NULL)
            {
                ULONG ul = ppdi->Name.Length / sizeof(WCHAR);
                memcpy (pwszzBuffer, ppdi->Name.Buffer, ppdi->Name.Length);
                pwszzBuffer [ul] = L'\0';
                lstrcpy (&pwszzBuffer[ul+1], pwszFlag);
            }
        }
    }

Err:
    if (hLsa != NULL)
        LsaClose (hLsa);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle (hFile);

    TLEAVE();

    return dwRc;
}



//++
//
//    Method:   DoesFileExist
//
//    Synopsis: Checks if a file by the  specified exists  
//
//    Arguments:[pszFileName]  File  name
//
//    Returns:  TRUE if the specified string is a file
//              False otherwise
//
//    History:  AshishS     Created        7/30/96
//
//--

BOOL DoesFileExist(const TCHAR * pszFileName)
{
    DWORD dwFileAttr, dwError;
    TraceFunctEnter("DoesFileExist");
    

    DebugTrace(TRACEID, "Checking for %S", pszFileName);    
    dwFileAttr = GetFileAttributes(pszFileName);

    if  (dwFileAttr == 0xFFFFFFFF ) 
    {
        dwError = GetLastError();
         // file not found
        DebugTrace(TRACEID,"GetFileAttributes failed 0x%x", dwError);
        TraceFunctLeave();        
        return FALSE ;
    }
    
    if  (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY) 
    {
        DebugTrace(TRACEID, "It is a Directory ");            
        TraceFunctLeave();        
        return FALSE;
    }    
    
    DebugTrace(TRACEID, "File  exists");            
    TraceFunctLeave();
    return TRUE;
}

//++
//
//	Method:		DoesDirExist
//
//	Synopsis:	Checks if the specified string is a directory
//
//	Arguments:  [pszFileName]  Directory name
//
//	Returns:	TRUE if the specified string is a directory,
//              False otherwise
//
//	History:	AshishS 	Created		7/30/96
//
//--

BOOL DoesDirExist(const TCHAR * pszFileName )
{
	DWORD dwFileAttr;
	TraceFunctEnter("DoesDirExist");
	

     //DebugTrace(TRACEID, " Checking for %S", pszFileName);	
	dwFileAttr = GetFileAttributes(pszFileName);

	if  (dwFileAttr == 0xFFFFFFFF ) 
	{
		 // file not found
         //DebugTrace(TRACEID,"GetFileAttributes failed 0x%x",
         //GetLastError());
		TraceFunctLeave();		
		return FALSE ;
	}
	
	if  (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY) 
	{
         //DebugTrace(TRACEID, "Directory exists ");			
		TraceFunctLeave();		
		return TRUE ;
	}

     //DebugTrace(TRACEID, "Directory does not exist");
	TraceFunctLeave();
	return FALSE;
}



// sets acl allowing specific access to LocalSystem/Admin 
// and to everyone

DWORD
SetAclInObject(HANDLE hObject, DWORD dwObjectType, DWORD dwSystemMask, DWORD dwEveryoneMask, BOOL fInherit)
{
    tenter("SetAclInObject");
    
    DWORD                   dwRes, dwDisposition;
    PSID                    pEveryoneSID = NULL, pAdminSID = NULL, pSystemSID = NULL;
    PACL                    pACL = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    EXPLICIT_ACCESS         ea[3];
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    LONG                    lRes;
    

    // Create a well-known SID for the Everyone group.

    if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                     SECURITY_WORLD_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pEveryoneSID) )
    {
        dwRes = GetLastError();
        trace(0, "AllocateAndInitializeSid Error %u\n", dwRes);
        goto Cleanup;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ZeroMemory(&ea, 3 * sizeof(EXPLICIT_ACCESS));
    ea[0].grfAccessPermissions = dwEveryoneMask;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance = fInherit ? SUB_CONTAINERS_AND_OBJECTS_INHERIT : NO_INHERITANCE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;


    // Create a SID for the BUILTIN\Administrators group.

    if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0, 0, 0, 0, 0, 0,
                     &pAdminSID) ) 
    {
        dwRes = GetLastError();    
        trace(0, "AllocateAndInitializeSid Error %u\n", dwRes);
        goto Cleanup; 
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the Administrators group full access to the key.

    ea[1].grfAccessPermissions = dwSystemMask;
    ea[1].grfAccessMode = SET_ACCESS;
    ea[1].grfInheritance= fInherit ? SUB_CONTAINERS_AND_OBJECTS_INHERIT : NO_INHERITANCE;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[1].Trustee.ptstrName  = (LPTSTR) pAdminSID;


    // Create a SID for the LocalSystem account
    
    if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pSystemSID) )
    {
        dwRes = GetLastError();    
        trace(0, "AllocateAndInitializeSid Error %u\n", dwRes );
        goto Cleanup; 
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the LocalSystem full access to the key.

    ea[2].grfAccessPermissions = dwSystemMask;
    ea[2].grfAccessMode = SET_ACCESS;
    ea[2].grfInheritance= fInherit ? SUB_CONTAINERS_AND_OBJECTS_INHERIT : NO_INHERITANCE;
    ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[2].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[2].Trustee.ptstrName  = (LPTSTR) pSystemSID;


    
    // Create a new ACL that contains the new ACEs.

    dwRes = SetEntriesInAcl(3, ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes)
    {
        dwRes = GetLastError();
        trace(0, "SetEntriesInAcl Error %u\n", dwRes );
        goto Cleanup;
    }

    // Initialize a security descriptor.  
     
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                             SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL)
    { 
        trace(0, "LocalAlloc Error %u\n", GetLastError() );
        goto Cleanup; 
    } 
     
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {  
        dwRes = GetLastError();        
        trace(0, "InitializeSecurityDescriptor Error %u\n", 
                                dwRes );
        goto Cleanup; 
    } 
     
    // Add the ACL to the security descriptor. 
     
    if (!SetSecurityDescriptorDacl(pSD, 
            TRUE,     // fDaclPresent flag   
            pACL, 
            FALSE))   // not a default DACL 
    {  
        dwRes = GetLastError();    
        trace(0, "SetSecurityDescriptorDacl Error %u\n", dwRes );
        goto Cleanup; 
    } 

    dwRes = SetSecurityInfo(hObject, 
                            (SE_OBJECT_TYPE) dwObjectType, 
                            DACL_SECURITY_INFORMATION |
                            PROTECTED_DACL_SECURITY_INFORMATION, 
                            NULL, 
                            NULL,
                            pACL,
                            NULL);
    if (ERROR_SUCCESS != dwRes)
    {   
        trace(0, "SetSecurityInfo Error %u\n", dwRes );
        goto Cleanup; 
    }  

Cleanup:
    if (pEveryoneSID) 
        FreeSid(pEveryoneSID);
    if (pAdminSID) 
        FreeSid(pAdminSID);
    if (pSystemSID) 
        FreeSid(pSystemSID);        
    if (pACL) 
        LocalFree(pACL);
    if (pSD) 
        LocalFree(pSD);

    tleave();
    return dwRes;    
}

//+---------------------------------------------------------------------------
//
//  Function:   Delnode_Recurse
//
//  Synopsis:   attempt to delete a directory tree
//
//  Arguments:  [pwszDir] -- directory name
//              [fIncludeRoot] -- delete top level directory and files
//              [pfStop] -- TRUE if stop signaled
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD
Delnode_Recurse (const WCHAR *pwszDir, BOOL fDeleteRoot, BOOL *pfStop)
{
    tenter("Delnode_Recurse");

    DWORD dwErr = ERROR_SUCCESS;
    WIN32_FIND_DATA *pfd = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR * pwcsPath = NULL;

    if (lstrlenW (pwszDir) > MAX_PATH-5)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        trace (0, "Delnode_Recurse failed with %d", dwErr);
        goto cleanup;
    }

    if (NULL == (pfd = new WIN32_FIND_DATA))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        trace (0, "Delnode_Recurse failed with %d", dwErr);
        goto cleanup;
    }

    if (NULL == (pwcsPath = new WCHAR[MAX_PATH]))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        trace (0, "Delnode_Recurse failed with %d", dwErr);
        goto cleanup;
    }

    lstrcpy (pwcsPath, pwszDir);
    lstrcat (pwcsPath, TEXT("\\*.*"));

    hFile = FindFirstFileW (pwcsPath, pfd);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        // if the directory does not exist, then return success
        dwErr = ERROR_SUCCESS;
        goto cleanup;
    }

    do
    {
        if (pfStop != NULL && TRUE == *pfStop)
        {
            dwErr = ERROR_OPERATION_ABORTED;
            trace (0, "Delnode_Recurse failed with %d", dwErr);
            goto cleanup;
        }

        if (!lstrcmp(pfd->cFileName, L".") || !lstrcmp(pfd->cFileName, L".."))
        {
            continue;
        }
        lstrcpy (pwcsPath, pwszDir);       // construct the full path name
        lstrcat (pwcsPath, TEXT("\\"));
        lstrcat (pwcsPath, pfd->cFileName);

        if (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            //
            // Found a directory.  Skip mount points
            //

            if (pfd->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            {
                continue;
            }

            dwErr = Delnode_Recurse (pwcsPath, TRUE, pfStop);
            if (dwErr != ERROR_SUCCESS)
            {
                trace (0, "Delnode_Recurse failed with %d, ignoring", dwErr);
                dwErr = ERROR_SUCCESS;  // try to delete more directories
            }
        }
        else if (fDeleteRoot)
        {
            //
            // We found a file.  Set the file attributes,
            // and try to delete it.
            //

            if ((pfd->dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
                (pfd->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM))
            {
                SetFileAttributesW (pwcsPath, FILE_ATTRIBUTE_NORMAL);
            }

            if (FALSE == DeleteFileW (pwcsPath))
            {
                if (ERROR_SUCCESS == (dwErr = TakeOwnership (pwcsPath, TRUE)))
                {
                    if (FALSE == DeleteFileW (pwcsPath))
                    {
                        dwErr = GetLastError();
                    }
                }
                if (dwErr != ERROR_SUCCESS)
                {
                    trace (0, "DeleteFile or TakeOwn failed with %d", dwErr);
                    goto cleanup;
                }
            }
        }

    } while (FindNextFile(hFile, pfd));  // Find the next entry

    FindClose(hFile);  // Close the search handle
    hFile = INVALID_HANDLE_VALUE;

    if (fDeleteRoot)
    {
        DWORD dwAttr = GetFileAttributes(pwszDir);

        if (dwAttr != 0xFFFFFFFF && (dwAttr & FILE_ATTRIBUTE_READONLY))
        {
            dwAttr &= ~FILE_ATTRIBUTE_READONLY;
            if (FALSE == SetFileAttributes (pwszDir, dwAttr))
            {
                TRACE(0, "SetFileAttributes ignoring %ld", GetLastError());
            }
        }

        if (FALSE == RemoveDirectoryW (pwszDir))
        {
            if (ERROR_SUCCESS == (dwErr = TakeOwnership (pwszDir, TRUE)))
            {
                if (FALSE == RemoveDirectoryW (pwszDir))
                {
                    LONG lLast = lstrlenW (pwszDir) - 1;
                    if (lLast < 0) lLast = 0;

                    dwErr = GetLastError();

                    if (pwszDir[lLast] != L')' && // already renamed
                        TRUE == SRGetAltFileName (pwszDir, pwcsPath) &&
                        TRUE == MoveFile (pwszDir, pwcsPath))
                        dwErr = ERROR_SUCCESS;
                    else
                        trace (0, "RemoveDirectory failed with %d", dwErr);
                }
            }
        }
    }

cleanup:
    if (hFile != INVALID_HANDLE_VALUE)
        FindClose (hFile);

    if (NULL != pfd)
        delete pfd;

    if (NULL != pwcsPath)
        delete [] pwcsPath;

    tleave();
    return dwErr;    
}

    
// 
// util function that checks the SR Stop event
// to see if it has been signalled or not
// will return TRUE if the event does not exist
//

BOOL
IsStopSignalled(HANDLE hEvent)
{
    TENTER("IsStopSignalled");
    
    BOOL    fRet, fOpened = FALSE;
    DWORD   dwRc;
    
    if (! hEvent)    
    {    
        hEvent = OpenEvent(SYNCHRONIZE, FALSE, s_cszSRStopEvent);        
        if (! hEvent)
        {
            // if cannot open, then assume that service is not stopped 
            // if client is running on different desktop than service (multiple user magic)
            // then it cannot open the event, though service might be running
            
            dwRc = GetLastError();
            TRACE(0, "! OpenEvent : %ld", dwRc);
            TLEAVE();
            return FALSE;
        }

        fOpened = TRUE;
    }

    fRet = (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, 0));

    if (fOpened)
        CloseHandle(hEvent);

    TLEAVE();
    return fRet;        
}
        

void 
PostTestMessage(UINT msg, WPARAM wp, LPARAM lp)
{
    HWINSTA hwinstaUser; 
    HDESK   hdeskUser = NULL; 
    DWORD   dwThreadId; 
    HWINSTA hwinstaSave; 
    HDESK   hdeskSave; 
    DWORD   dwRc;

    TENTER("PostTestMessage");

    //
    // save current values
    //
    
    GetDesktopWindow(); 
    hwinstaSave = GetProcessWindowStation(); 
    dwThreadId = GetCurrentThreadId(); 
    hdeskSave = GetThreadDesktop(dwThreadId); 

    //
    // change desktop and winstation to interactive user
    //

    hwinstaUser = OpenWindowStation(L"WinSta0", FALSE, MAXIMUM_ALLOWED);

    if (hwinstaUser == NULL) 
    { 
        dwRc = GetLastError();
        trace(0, "! OpenWindowStation : %ld", dwRc);
        goto done;
    } 
    
    SetProcessWindowStation(hwinstaUser); 
    hdeskUser = OpenDesktop(L"Default", 0, FALSE, MAXIMUM_ALLOWED); 
    if (hdeskUser == NULL) 
    { 
        dwRc = GetLastError();
        trace(0, "! OpenDesktop : %ld", dwRc);
        goto done;
    } 
    
    SetThreadDesktop(hdeskUser); 

    if (FALSE == PostMessage(HWND_BROADCAST, msg, wp, lp))
    {
        trace(0, "! PostMessage");
    }

done:
    //
    // restore old values
    //

    if (hdeskSave) 
        SetThreadDesktop(hdeskSave); 

    if (hwinstaSave)    
        SetProcessWindowStation(hwinstaSave); 

    //
    // close opened handles
    //
    
    if (hdeskUser)
        CloseDesktop(hdeskUser); 

    if (hwinstaUser)    
        CloseWindowStation(hwinstaUser);  
        
    TLEAVE();
}


//+-------------------------------------------------------------------------
//
//   Function:   RemoveTrailingFilename
//  
//   Synopsis:   This function takes as input parameter a string which
//               contains a filename. It removes the last filename (or
//               directory ) from the string including the '\' or '/'
//               before the last filename. 
//  
//   Arguments:   IN/OUT pszString - string to be modified. 
//             	  IN     tchSlash  - file name separator - must be '/' or'\'
//
//
//   Returns:     nothing
//
//   History:    AshishS    Created     5/22/96
//
//------------------------------------------------------------------------
void RemoveTrailingFilename(WCHAR * pszString, WCHAR wchSlash)
{
	WCHAR * pszStringStart;
	DWORD   dwStrlen;

	pszStringStart = pszString;
	dwStrlen = lstrlen ( pszString);
	
	 // first go the end of the string
	pszString += dwStrlen ;
	 // now walk backwards till we see the first  '\'
	 // also maintain a count of how many characters we have
	 //	gone back.
	while ( (*pszString != wchSlash) && ( dwStrlen) )
	{
		pszString--;
		dwStrlen --;
	}
	*pszString = TEXT('\0');
}

// this function create the parent directory under the specified file
// name if it already does not exist
BOOL CreateParentDirectory(WCHAR * pszFileName)
{
    TraceFunctEnter("CreateParentDirectory");
    
    BOOL fReturn = FALSE;
    DWORD dwError;
    
    
     // get the parent directory
    RemoveTrailingFilename(pszFileName, L'\\');

    if (FALSE == DoesDirExist(pszFileName))
    {    
        if (FALSE == CreateDirectory(pszFileName, // directory name
                                     NULL))  // SD
        {
            dwError = GetLastError();
            ErrorTrace(TRACEID, "Could not create directory %S ec=%d",
                       pszFileName, dwError);
            goto cleanup;
        }
    }
    
    fReturn = TRUE;
    
cleanup:
    TraceFunctLeave();
    return fReturn;
}


// this function creates all sub directories under the specified file
// name. 
BOOL CreateBaseDirectory(const WCHAR * pszFileName)
{
    BOOL  fRetVal = FALSE;
    DWORD dwCurIndex,dwBufReqd;
    DWORD dwStrlen;
    TraceFunctEnter("CreateBaseDirectory");
    DWORD  dwError;
    WCHAR  * pszFileNameCopy;
    
    dwBufReqd = (lstrlen(pszFileName) + 1) * sizeof(WCHAR);
    
    pszFileNameCopy = (WCHAR *) _alloca(dwBufReqd);
        
    if (NULL == pszFileNameCopy)
    {
        ErrorTrace(0, "alloca for size %d failed", dwBufReqd);
        goto cleanup;
    }
    lstrcpy(pszFileNameCopy, pszFileName);

     // do a fast check to see if the parent directory exists
    if (TRUE == CreateParentDirectory(pszFileNameCopy))
    {
        fRetVal = TRUE;
        goto cleanup;        
    }
    
    lstrcpy(pszFileNameCopy, pszFileName);
    dwStrlen = lstrlen(pszFileNameCopy);
    
     // check to see if this is a filename starting with the GUID
    if (0==wcsncmp( pszFileNameCopy,
                    VOLUMENAME_FORMAT,
                    lstrlen(VOLUMENAME_FORMAT)))
    {
         // this is of the format \\?\Volume
         // skip over the initial part
        dwCurIndex = lstrlen(VOLUMENAME_FORMAT)+1;
         // skip over the GUID part also
        while (dwCurIndex < dwStrlen)
        {
            dwCurIndex++;            
            if (TEXT('\\') == pszFileNameCopy[dwCurIndex-1] )
            {
                break;
            }
        }
    }
    else
    {
         // the filename is of the regular format
         // we start at index 1 and not at 0 because we want to handle
         // path name like \foo\abc.txt
        dwCurIndex = 1;
    }
    


    while (dwCurIndex < dwStrlen)
    {
        if (TEXT('\\') == pszFileNameCopy[dwCurIndex] )
        {
             // NULL terminate at the '\' to get the sub directory
             // name.
            pszFileNameCopy[dwCurIndex] = TEXT('\0');
            if (FALSE == DoesDirExist(pszFileNameCopy))
            {
                if (FALSE == CreateDirectory(pszFileNameCopy, // directory name
                                             NULL))  // SD
                {
                    dwError = GetLastError();
                    ErrorTrace(TRACEID, "Could not create directory %S ec=%d",
                               pszFileNameCopy, dwError);
                    pszFileNameCopy[dwCurIndex] = TEXT('\\');
                    goto cleanup;
                }
                DebugTrace(TRACEID, "Created directory %S", pszFileNameCopy);
            }
             // restore the \ to get the file name again. 
            pszFileNameCopy[dwCurIndex] = TEXT('\\');
        }
        dwCurIndex ++;
    }
    fRetVal = TRUE;
    
cleanup:
    TraceFunctLeave();
    return fRetVal;
}

// The following function logs the name of a file in the DS. The
// problem right now is that the path of the DS is so long that the
// relevant information is thrown away from the trace buffer.
void LogDSFileTrace(DWORD dwTraceID,
                    const WCHAR * pszPrefix, // Initial message to be traced 
                    const WCHAR * pszDSFile)
{
    WCHAR * pszBeginName;
    
    TraceQuietEnter("LogDSFileTrace");
    
     // first see if the file is in the DS
    pszBeginName = wcschr(pszDSFile, L'\\');
    
    if (NULL == pszBeginName)
    {
        goto cleanup;
    }
     // skip over the first \  .
    pszBeginName++;
    
    
     // comapare if the first part is "system volume information"
    if (0!=_wcsnicmp(s_cszSysVolInfo, pszBeginName,
                    lstrlen(s_cszSysVolInfo)))
    {
        goto cleanup;
    }

     // skip over the next \  .
    pszBeginName = wcschr(pszBeginName, L'\\');
    
    if (NULL == pszBeginName)
    {
        goto cleanup;
    }

    pszBeginName++;    

     // now skip over the _restore directory
     // first see if the file is in the DS
    pszBeginName = wcschr(pszBeginName, L'\\');
    
    if (NULL == pszBeginName)
    {
        goto cleanup;
    }

    DebugTrace(dwTraceID, "%S %S", pszPrefix, pszBeginName);
    
cleanup:
     // the file is not in the DS - or we are printing out the initial
     // part for debugging purposes.
    
    DebugTrace(dwTraceID, "%S%S", pszPrefix, pszDSFile);
    return;
    
}


// the following function calls pfnMethod on all the files specified
// by the pszFindFileData filter.
DWORD ProcessGivenFiles(WCHAR * pszBaseDir,
                        PPROCESSFILEMETHOD    pfnMethod,
                        WCHAR  * pszFindFileData) 
{
    TraceFunctEnter("ProcessGivenFiles");
    
    WIN32_FIND_DATA FindFileData;
    HANDLE          hFindFirstFile = INVALID_HANDLE_VALUE;
    DWORD           dwErr, dwReturn = ERROR_INTERNAL_ERROR;
    BOOL            fContinue;
    
    LogDSFileTrace(0, L"FileData is ", pszFindFileData);    
    hFindFirstFile = FindFirstFile(pszFindFileData, &FindFileData);
    DebugTrace(0, "FindFirstFile returned %d", hFindFirstFile);
    if (INVALID_HANDLE_VALUE == hFindFirstFile)
    {
        dwErr = GetLastError();
        DebugTrace(0, "FindFirstFile failed ec=%d. Filename is %S",
                   dwErr, pszFindFileData);

         // what if even one file does not exist
        if ( (ERROR_FILE_NOT_FOUND == dwErr) ||
             (ERROR_PATH_NOT_FOUND == dwErr) ||
             (ERROR_NO_MORE_FILES == dwErr))
        {
             // this is a success condition
            dwReturn = ERROR_SUCCESS;
            goto cleanup;            
        }
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
        }
        goto cleanup;            
    }
    
    fContinue = TRUE;
    while (TRUE==fContinue)
    {
        LogDSFileTrace(0, L"FileName is ", FindFileData.cFileName);
        dwErr = pfnMethod(pszBaseDir, FindFileData.cFileName);
        if (ERROR_SUCCESS != dwErr)
        {
            ErrorTrace(0, "pfnMethod failed. ec=%d.file=%S ",
                       dwErr, FindFileData.cFileName); 
            goto cleanup;
        }
        fContinue = FindNextFile(hFindFirstFile, &FindFileData);
        
    }
    
    dwErr=GetLastError();
    if (ERROR_NO_MORE_FILES != dwErr)
    {
        _ASSERT(0);
        ErrorTrace(0, "dwErr != ERROR_NO_MORE_FILES. It is %d",
                   dwErr);
        goto cleanup;
    }
    
    dwReturn = ERROR_SUCCESS;

cleanup:
    if (INVALID_HANDLE_VALUE != hFindFirstFile)
    {
        _VERIFY(TRUE == FindClose(hFindFirstFile));
    }
    TraceFunctLeave();
    return dwReturn;
}



DWORD DeleteGivenFile(WCHAR * pszBaseDir, // Base Directory
                      const WCHAR * pszFile)
                              // file to delete
{
    TraceFunctEnter("DeleteGivenFile");
    
    DWORD dwErr, dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR    szDataFile[MAX_PATH];

     // construct the path name of the file 
    wsprintf(szDataFile, L"%s\\%s", pszBaseDir, pszFile);

    if (TRUE != DeleteFile(szDataFile))
    {
        dwErr = GetLastError();
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
        }
        
        ErrorTrace(0, "DeleteFile failed ec=%d", dwErr);
        LogDSFileTrace(0,L"File was ", szDataFile);                
        goto cleanup;
    }

    dwReturn = ERROR_SUCCESS;
cleanup:
    TraceFunctLeave();
    return dwReturn;
}



//++-----------------------------------------------------------------------
//
//   Function: WriteRegKey
//
//   Synopsis: This function writes into a registry key. It also creates it
//             if it does not exist.
//
//   Arguments:
//
//   Returns:   TRUE     no error
//              FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------

BOOL WriteRegKey(BYTE  * pbRegValue,
                 DWORD  dwNumBytes,
                 const TCHAR  * pszRegKey,
                 const TCHAR  * pszRegValueName,
                 DWORD  dwRegType)
{
    HKEY   hRegKey;
    LONG lResult;
    DWORD dwDisposition;
    TraceFunctEnter("WriteRegKey");
    
    //read registry to find out name of the file
    if ( (lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                   pszRegKey, // address of subkey name
                                   0,          // reserved
                                   NULL,    // address of class string
                                   0,   // special options flag
                                   KEY_WRITE,   // samDesired
                                   NULL, // address of key security structure
                                   &hRegKey, // address of handle of open key
                                   &dwDisposition   // address of disposition value buffer
        )) != ERROR_SUCCESS )
    {
        ErrorTrace(TRACEID, "RegCreateKeyEx error 0x%x", lResult);
        _ASSERT(0);
        goto cleanup;
    }

    if ( (lResult =RegSetValueEx( hRegKey,
                                  pszRegValueName,
                                  0,        // reserved
                                  dwRegType,// flag for value type
                                  pbRegValue, // address of value data
                                  dwNumBytes // size of value data
                                  )) != ERROR_SUCCESS )
    {
        ErrorTrace(TRACEID, "RegSetValueEx error 0x%x", lResult);
        _ASSERT(0);        
        _VERIFY(RegCloseKey(hRegKey)==ERROR_SUCCESS);        
        goto cleanup;
    }

    _VERIFY(RegCloseKey(hRegKey)==ERROR_SUCCESS);            

    TraceFunctLeave();    
    return TRUE;

cleanup:
    TraceFunctLeave();    
    return FALSE;
}


//++------------------------------------------------------------------------
//
//   Function: ReadRegKey
//  
//   Synopsis: This function reads a registry key and creates it
//   if it does not exist with the default value.
//  
//   Arguments: 
//
//   Returns:   TRUE     no error
//                 FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------
BOOL ReadRegKeyOrCreate(BYTE * pbRegValue, // The value of the reg key will be
                         // stored here
                        DWORD * pdwNumBytes, // Pointer to DWORD conataining
                         // the number of bytes in the above buffer - will be
                         // set to actual bytes stored.
                        const TCHAR  * pszRegKey, // Reg Key to be opened
                        const TCHAR  * pszRegValueName, // Reg Value to query
                        DWORD  dwRegTypeExpected, 
                        BYTE  * pbDefaultValue, // default value
                        DWORD   dwDefaultValueSize) // size of default value
{
    if (!ReadRegKey(pbRegValue,//Buffer to store value
                    pdwNumBytes, // Length of above buffer
                    pszRegKey, // Reg Key name
                    pszRegValueName, // Value name
                    dwRegTypeExpected) ) // Type expected
    {
         // read reg key failed - use default value and create this
         // key
        
        return WriteRegKey(pbDefaultValue,
                           dwDefaultValueSize,
                           pszRegKey,
                           pszRegValueName,
                           dwRegTypeExpected);
    }
    return TRUE;
}

    
//++------------------------------------------------------------------------
//
//   Function: ReadRegKey
//  
//   Synopsis: This function reads a registry key.
//  
//   Arguments: 
//
//   Returns:   TRUE     no error
//                 FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------

BOOL ReadRegKey(BYTE * pbRegValue, // The value of the reg key will be
                 // stored here
                DWORD * pdwNumBytes, // Pointer to DWORD conataining
                 // the number of bytes in the above buffer - will be
                 // set to actual bytes stored.
                const TCHAR  * pszRegKey, // Reg Key to be opened
                const TCHAR  * pszRegValueName, // Reg Value to query
                DWORD  dwRegTypeExpected) // Expected type of Value
{
    HKEY   hRegKey;
    DWORD  dwRegType;
    LONG lResult;
    
    TraceFunctEnter("ReadRegKey");
    
    DebugTrace(TRACEID, "Trying to open %S %S", pszRegKey, pszRegValueName);
    
     //read registry to find out name of the file
    if ( (lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 pszRegKey, // address of subkey name 
                                 0,          // reserved
                                 KEY_READ,   // samDesired
                                 &hRegKey
                                  // address of handle of open key 
        )) != ERROR_SUCCESS )
    {
        ErrorTrace(TRACEID, "RegOpenKeyEx open error 0x%x", lResult);
        goto cleanup;        
    }
    

    if ( (lResult =RegQueryValueEx( hRegKey,
                                    pszRegValueName,
                                    0,           // reserved 
                                    &dwRegType,// address of buffer
                                     // for value type 
                                    pbRegValue,
                                    pdwNumBytes)) != ERROR_SUCCESS )
    {
        _VERIFY(RegCloseKey(hRegKey)==ERROR_SUCCESS);
        ErrorTrace(TRACEID, "RegQueryValueEx failed error 0x%x",
                   lResult);
        goto cleanup;                
    }
    
    _VERIFY(RegCloseKey(hRegKey)==ERROR_SUCCESS);
    
    if ( dwRegType != dwRegTypeExpected )
    {
        ErrorTrace(TRACEID, "RegType is %d, not %d", dwRegType,
                   dwRegTypeExpected);
        goto cleanup;                
    }
    
    TraceFunctLeave();
    return TRUE;
    
cleanup:
    TraceFunctLeave();    
    return FALSE;
    
}

// this function sets the error hit by restore in the registry
BOOL SetRestoreError(DWORD dwRestoreError)
{
    TraceFunctEnter("SetDiskSpaceError");    
    DWORD  dwNumBytes=sizeof(DWORD);
    
    BOOL   fResult=FALSE; // assume FALSE by default

    DebugTrace(TRACEID, "Setting disk space error to %d", dwRestoreError);

    if (FALSE== WriteRegKey((BYTE*)&dwRestoreError, // The value of the
                             // reg key will be set to this value
                            dwNumBytes, // Pointer to DWORD containing
                             // the number of bytes in the above buffer 
                            s_cszSRRegKey, // Reg Key to be opened
                            s_cszRestoreDiskSpaceError, // Reg Value to query
                            REG_DWORD)) // Expected type of Value
    {
        fResult = FALSE;
        goto cleanup;
    }

    fResult= TRUE;
    
cleanup:

    TraceFunctLeave();
    return fResult;
}

// this function checks to see of the restore failed because of disk space
BOOL CheckForDiskSpaceError()
{
    TraceFunctEnter("CheckForDiskSpaceError");
    
    DWORD  dwRestoreError;
    DWORD  dwNumBytes=sizeof(DWORD);
    
    BOOL   fResult=FALSE; // assume FALSE by default
    
    if (FALSE==ReadRegKey((BYTE*)&dwRestoreError, // The value of the
                          // reg key will be stored here
                          &dwNumBytes, // Pointer to DWORD containing
                           // the number of bytes in the above buffer - will be
                           // set to actual bytes stored.
                          s_cszSRRegKey, // Reg Key to be opened
                          s_cszRestoreDiskSpaceError, // Reg Value to query
                          REG_DWORD)) // Expected type of Value
    {
        fResult = FALSE;
    }

    if (dwRestoreError == ERROR_DISK_FULL)
    {
        DebugTrace(TRACEID,"Restore failed because of disk space");
        fResult= TRUE;
    }

    TraceFunctLeave();
    return fResult;
}

// this function sets the status whether restore was done in safe mode
BOOL SetRestoreSafeModeStatus(DWORD dwSafeModeStatus)
{
    TraceFunctEnter("SetRestoreSafeModeStatus");    
    DWORD  dwNumBytes=sizeof(DWORD);
    
    BOOL   fResult=FALSE; // assume FALSE by default

    DebugTrace(TRACEID, "Setting restore safe mode status to %d",
               dwSafeModeStatus);

    if (FALSE== WriteRegKey((BYTE*)&dwSafeModeStatus, // The value of the
                             // reg key will be set to this value
                            dwNumBytes, // Pointer to DWORD containing
                             // the number of bytes in the above buffer 
                            s_cszSRRegKey, // Reg Key to be opened
                            s_cszRestoreSafeModeStatus, // Reg Value to query
                            REG_DWORD)) // Expected type of Value
    {
        fResult = FALSE;
        goto cleanup;
    }

    fResult= TRUE;
    
cleanup:

    TraceFunctLeave();
    return fResult;
}

// this function checks to see is the last restore was done in safe mode
BOOL WasLastRestoreInSafeMode()
{
    TraceFunctEnter("WasLastRestoreInSafeMode");
    
    DWORD  dwRestoreSafeModeStatus;
    DWORD  dwNumBytes=sizeof(DWORD);
    
    BOOL   fResult=FALSE; // assume FALSE by default
    
    if (FALSE==ReadRegKey((BYTE*)&dwRestoreSafeModeStatus, // The value of the
                          // reg key will be stored here
                          &dwNumBytes, // Pointer to DWORD containing
                           // the number of bytes in the above buffer - will be
                           // set to actual bytes stored.
                          s_cszSRRegKey, // Reg Key to be opened
                          s_cszRestoreSafeModeStatus, // Reg Value to query
                          REG_DWORD)) // Expected type of Value
    {
        fResult = FALSE;
    }

    if (dwRestoreSafeModeStatus != 0 )
    {
        DebugTrace(TRACEID,"Last restore was done in safe mode");
        fResult= TRUE;
    }
    else
    {
        DebugTrace(TRACEID,"Last restore was not done in safe mode");        
    }

    TraceFunctLeave();
    return fResult;
}


#define MAX_LEN_SYSERR  1024

LPCWSTR  GetSysErrStr()
{
    LPCWSTR  cszStr = GetSysErrStr( ::GetLastError() );
    return( cszStr );
}

LPCWSTR  GetSysErrStr( DWORD dwErr )
{
    static WCHAR  szErr[MAX_LEN_SYSERR+1];

    ::FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        szErr,
        MAX_LEN_SYSERR,
        NULL );

    return( szErr );
}


/****************************************************************************/

LPWSTR  SRGetRegMultiSz( HKEY hkRoot, LPCWSTR cszSubKey, LPCWSTR cszValue, LPDWORD pdwData )
{
    TraceFunctEnter("SRGetRegMultiSz");
    LPCWSTR  cszErr;
    DWORD    dwRes;
    HKEY     hKey = NULL;
    DWORD    dwType;
    DWORD    cbData = 0;
    LPWSTR   szBuf = NULL;

    dwRes = ::RegOpenKeyEx( hkRoot, cszSubKey, 0, KEY_ALL_ACCESS, &hKey );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegOpenKey() failed - %ls", cszErr);
        goto Exit;
    }

    dwRes = ::RegQueryValueEx( hKey, cszValue, 0, &dwType, NULL, &cbData );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegQueryValueEx(len) failed - %ls", cszErr);
        goto Exit;
    }
    if ( dwType != REG_MULTI_SZ )
    {
        ErrorTrace(0, "Type of '%ls' is %u (not REG_MULTI_SZ)...", cszValue, dwType);
        goto Exit;
    }
    if ( cbData == 0 )
    {
        ErrorTrace(0, "Value '%ls' is empty...", cszValue);
        goto Exit;
    }

    szBuf = new WCHAR[cbData+2];
    if (! szBuf)
    {
        ErrorTrace(0, "Cannot allocate memory");
        goto Exit;
    }
    dwRes = ::RegQueryValueEx( hKey, cszValue, 0, &dwType, (LPBYTE)szBuf, &cbData );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegQueryValueEx(data) failed - %ls", cszErr);
        delete [] szBuf;
        szBuf = NULL;
    }

    if ( pdwData != NULL )
        *pdwData = cbData;

Exit:
    if ( hKey != NULL )
        ::RegCloseKey( hKey );
    TraceFunctLeave();
    return( szBuf );
}

/****************************************************************************/

BOOL  SRSetRegMultiSz( HKEY hkRoot, LPCWSTR cszSubKey, LPCWSTR cszValue, LPCWSTR cszData, DWORD cbData )
{
    TraceFunctEnter("SRSetRegMultiSz");
    BOOL     fRet = FALSE;
    LPCWSTR  cszErr;
    DWORD    dwRes;
    HKEY     hKey = NULL;

    dwRes = ::RegOpenKeyEx( hkRoot, cszSubKey, 0, KEY_ALL_ACCESS, &hKey );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegOpenKey() failed - %ls", cszErr);
        goto Exit;
    }

    dwRes = ::RegSetValueEx( hKey, cszValue, 0, REG_MULTI_SZ, (LPBYTE)cszData, cbData );
    if ( dwRes != ERROR_SUCCESS )
    {
        cszErr = ::GetSysErrStr( dwRes );
        ErrorTrace(0, "::RegSetValueEx() failed - %ls", cszErr);
        goto Exit;
    }

    fRet = TRUE;
Exit:
    if ( hKey != NULL )
        ::RegCloseKey( hKey );
    TraceFunctLeave();
    return( fRet );
}

// this returns the name after the volume name
// For example input: c:\file output: file
//             input \\?\Volume{GUID}\file1  output: file1
WCHAR * ReturnPastVolumeName(const WCHAR * pszFileName)
{
    DWORD dwStrlen, dwCurIndex;
    dwStrlen = lstrlen(pszFileName);
    
     // check to see if this is a filename starting with the GUID
    if (0==wcsncmp( pszFileName,
                    VOLUMENAME_FORMAT,
                    lstrlen(VOLUMENAME_FORMAT)))
    {
         // this is of the format \\?\Volume
         // skip over the initial part
        dwCurIndex = lstrlen(VOLUMENAME_FORMAT)+1;
         // skip over the GUID part also
        while (dwCurIndex < dwStrlen)
        {
            dwCurIndex++;            
            if (TEXT('\\') == pszFileName[dwCurIndex-1] )
            {
                break;
            }
        }
    }
    else
    {
         // the filename is of the regular format
        dwCurIndex = 3;
    }
    return (WCHAR *)pszFileName + dwCurIndex;
}

void SRLogEvent (HANDLE hEventSource,
                 WORD wType,
                 DWORD dwID,
                 void * pRawData,
                 DWORD dwDataSize,
                 const WCHAR * pszS1,
                 const WCHAR * pszS2,
                 const WCHAR * pszS3)
{
     const WCHAR* ps[3];
     ps[0] = pszS1;
     ps[1] = pszS2;
     ps[2] = pszS3;

     WORD iStr = 0;
     for (int i = 0; i < 3; i++)
     {
         if (ps[i] != NULL) iStr++;
     }

     if (hEventSource)
     {
         ::ReportEvent(
             hEventSource,
             wType,
             0,
             dwID,
             NULL, // sid
             iStr,
             dwDataSize,
             ps,
             pRawData);
     }
}

BOOL IsPowerUsers()
{
    BOOL fReturn = FALSE;
    PSID psidPowerUsers;
    DWORD dwErr;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    TENTER("IsPowerUsers");

    if ( AllocateAndInitializeSid (
            &SystemSidAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_POWER_USERS,
            0, 0, 0, 0, 0, 0, &psidPowerUsers))
    {
        if (! CheckTokenMembership(NULL, psidPowerUsers, &fReturn))
        {
            dwErr = GetLastError();
            TRACE(0, "! CheckTokenMembership : %ld", dwErr);
        }

        FreeSid (psidPowerUsers);
    }
    else
    {
        dwErr = GetLastError();
        TRACE(0, "! AllocateAndInitializeSid : %ld", dwErr);
    }

    TLEAVE();
    return fReturn;
}

// function to check if caller is running in admin context

BOOL IsAdminOrSystem()
{
    BOOL   fReturn = FALSE;
    PSID   psidAdmin, psidSystem;
    DWORD  dwErr;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    TENTER("IsAdminOrSystem");

    //
    // check if caller is Admin
    //

    if ( AllocateAndInitializeSid (
            &SystemSidAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        if (! CheckTokenMembership(NULL, psidAdmin, &fReturn))
        {
            dwErr = GetLastError();
            TRACE(0, "! CheckTokenMembership : %ld", dwErr);
        }

        FreeSid (psidAdmin);

        //
        // if so, scoot
        //

        if (fReturn)
        {
            goto done;
        }

        //
        // check if caller is localsystem
        //

        if ( AllocateAndInitializeSid (
                &SystemSidAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,
                0, 0, 0, 0, 0, 0, &psidSystem) )
        {            if (! CheckTokenMembership(NULL, psidSystem, &fReturn))
            {
                dwErr = GetLastError();
                TRACE(0, "! CheckTokenMembership : %ld", dwErr);
            }

            FreeSid(psidSystem);
        }
        else
        {
            dwErr = GetLastError();
            TRACE(0, "! AllocateAndInitializeSid : %ld", dwErr);
        }
    }
    else
    {
        dwErr = GetLastError();
        TRACE(0, "! AllocateAndInitializeSid : %ld", dwErr);
    }

done:
    TLEAVE();
    return (fReturn);
}


DWORD
SRLoadString(LPCWSTR pszModule, DWORD dwStringId, LPWSTR pszString, DWORD cbBytes)
{
    DWORD       dwErr = ERROR_SUCCESS;
    HINSTANCE   hModule = NULL;
    
    if (hModule = LoadLibraryEx(pszModule, 
                                NULL, 
                                DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE))
    {
        if (! LoadString(hModule, dwStringId, pszString, cbBytes))
        {
            dwErr = GetLastError();
        }
        FreeLibrary(hModule);
    }
    else dwErr = GetLastError();

    return dwErr;
}

//
// replace CurrentControlSet in pszString with ControlSetxxx
//
void
ChangeCCS(HKEY hkMount, LPWSTR pszString)
{
    tenter("ChangeCCS");
    int    nCS = lstrlen(L"CurrentControlSet");            

    if (_wcsnicmp(pszString, L"CurrentControlSet", nCS) == 0)
    {
        WCHAR  szCS[20] = L"ControlSet001";
        DWORD  dwCurrent = 0;       
        HKEY   hKey = NULL;
        
        if (ERROR_SUCCESS == RegOpenKeyEx(hkMount, L"Select", 0, KEY_READ, &hKey))
        {
            if (ERROR_SUCCESS == RegReadDWORD(hKey, L"Current", &dwCurrent))
            {
                wsprintf(szCS, L"ControlSet%03d", (int) dwCurrent); 
            }
            RegCloseKey(hKey);
        }
        else
        {
            trace(0, "! RegOpenKeyEx : %ld", GetLastError());
        }
        
        WCHAR szTemp[MAX_PATH];

        lstrcpy(szTemp, &(pszString[nCS]));
        wsprintf(pszString, L"%s%s", szCS, szTemp);
        trace(0, "ChangeCCS: pszString = %S", pszString);
    }
    tleave();
}  

WCHAR * SRPathFindExtension (WCHAR * pwszPath)
{
    WCHAR *pwszDot = NULL;

    if (pwszPath != NULL)
        for (; *pwszPath; pwszPath++)
        {
            switch (*pwszPath)
            {
            case L'.':
                pwszDot = pwszPath;  // remember the last dot
                break;
            case L'\\':
            case L' ':
                pwszDot = NULL;  // extensions can't have spaces
                break;           // forget last dot, it was in a directory
            }
        }

    return pwszDot;
}

// In order to prevent endless loop in case of disk failure, try only up to
// a predefined number.
#define MAX_ALT_INDEX  1000

//
// This function makes an unique alternative name of given file name, keeping
//  path and extension.
//
BOOL  SRGetAltFileName( LPCWSTR cszPath, LPWSTR szAltName )
{
    TraceFunctEnter("SRGetAltFileName");
    BOOL    fRet = FALSE;
    WCHAR   szNewPath[SR_MAX_FILENAME_LENGTH];
    LPWSTR  szExtPos;
    WCHAR   szExtBuf[SR_MAX_FILENAME_LENGTH];
    int     nAltIdx;

    ::lstrcpy( szNewPath, cszPath );
    szExtPos = SRPathFindExtension( szNewPath );
    if ( szExtPos != NULL )
    {
        ::lstrcpy( szExtBuf, szExtPos );
    }
    else
    {
        szExtBuf[0] = L'\0';
        szExtPos = &szNewPath[ lstrlen(szNewPath) ];  // end of string
    }

    for ( nAltIdx = 2;  nAltIdx < MAX_ALT_INDEX;  nAltIdx++ )
    {
        ::wsprintf( szExtPos, L"(%d)%s", nAltIdx, szExtBuf );
        if ( ::GetFileAttributes( szNewPath ) == 0xFFFFFFFF )
            break;
    }
    if ( nAltIdx == MAX_ALT_INDEX )
    {
        ErrorTrace(0, "Couldn't get alternative name.");
        goto Exit;
    }

    ::lstrcpy( szAltName, szNewPath );

    fRet = TRUE;
Exit:
    TraceFunctLeave();
    return( fRet );
}



CSRClientLoader::CSRClientLoader()
{
    m_hSRClient=NULL;
    m_hFrameDyn=NULL;
}

CSRClientLoader::~CSRClientLoader()
{
     // unload library here
    if (m_hFrameDyn != NULL)
    {
        _VERIFY(FreeLibrary(m_hFrameDyn));
    }

    if (m_hSRClient != NULL)
    {
        _VERIFY(FreeLibrary(m_hSRClient));
    }
}


BOOL CSRClientLoader::LoadFrameDyn()
{
    TraceFunctEnter("LoadFrameDyn");
    

    WCHAR     szFrameDynPath[MAX_PATH+100];
    DWORD     dwCharsCopied, dwBufSize,dwError;
    BOOL      fReturn=FALSE;
    

    m_hFrameDyn=LoadLibrary(FRAMEDYN_DLL);    // file name of module
    
    if (m_hFrameDyn != NULL)
    {
         // we are done. 
        fReturn = TRUE;
        goto cleanup;        
    }

     // framedyn.dll could not be loaded. Try to load framedyn.dll
     // from the explicit path. (system32\wbem\framedyn.dll)

    dwError = GetLastError();        
    ErrorTrace(0,"Failed to load framedyn.dll on first attempt. ec=%d",
               dwError);


     // get the windows system32 directory
     // add wbem\framedyn.dll
     // Call LoadLibrary on this path    
    
    dwBufSize = sizeof(szFrameDynPath)/sizeof(WCHAR);
    
    dwCharsCopied=GetSystemDirectory(
        szFrameDynPath, //buffer for system directory
        dwBufSize);        // size of directory buffer

    if (dwCharsCopied == 0)
    {
        dwError = GetLastError();
        ErrorTrace(0,"Failed to load system directory. ec=%d", dwError);
        goto cleanup;
    }

     // check if buffer is big enough.
    if (dwBufSize < dwCharsCopied + sizeof(FRAMEDYN_DLL)/sizeof(WCHAR) +
        sizeof(WBEM_DIRECTORY)/sizeof(WCHAR)+ 3 )
    {
        ErrorTrace(0,"Buffer not big enough. WinSys is %d chars long",
                   dwCharsCopied);
        goto cleanup;        
    }

    lstrcat(szFrameDynPath, L"\\" WBEM_DIRECTORY L"\\" FRAMEDYN_DLL);

    m_hFrameDyn=LoadLibrary(szFrameDynPath);    // file name of module
    
    if (m_hFrameDyn == NULL)
    {
         // we are done. 
        fReturn = FALSE;
        dwError = GetLastError();        
        ErrorTrace(0,"Failed to load framedyn.dll on second attempt. ec=%d",
                   dwError);
        goto cleanup;        
    }


    fReturn=TRUE;
cleanup:
    TraceFunctLeave();
    return fReturn;
}

BOOL CSRClientLoader::LoadSrClient()
{
    TraceFunctEnter("LoadSrClient");
    DWORD  dwError;
    BOOL   fReturn=FALSE;
    
    if (m_hSRClient != NULL)
    {
        fReturn=TRUE;
        goto cleanup;
    }

     // sometimes srclient.dll cannot be loaded because framedyn.dll
     // cannot be loaded because of the PATH variable being messed up.
     // Explicitly load framedyn.dll from %windir%\system32\wbem
     // and then try again.    

    if (FALSE == LoadFrameDyn())
    {
        ErrorTrace(0,"Failed to load framedyn.dll");
         // we can still try to load srclient.dll
    }
    
    
    m_hSRClient=LoadLibrary(L"srclient.dll");    // file name of module

    if (m_hSRClient == NULL)
    {
        dwError = GetLastError();
        ErrorTrace(0,"Failed to load srclient.dll. ec=%d", dwError);
        goto cleanup;        
    }

    fReturn=TRUE;
cleanup:
    
    TraceFunctLeave();
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sr\xmlparser\cxmlparser.cpp ===
//++
// 
// Copyright (c) 1999 Microsoft Corporation
// 
// Module Name:
//     CXMLParser.c
// 
// Abstract:
//     This file contains the functions used by System restore in
//     order to real the XML encoded list of protected files. It
//     also performs translations between symbols like %windir% to 
//     C:\windows
// 
// Revision History:
//       Eugene Mesgar        (eugenem)    6/16/99
//         created
//       Kanwaljit Marok      (kmarok )    6/06/00
//         rewritten for Whistler
//--

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <comdef.h>
#include <crtdbg.h>
#include <dbgtrace.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <winreg.h>
#include <commonlib.h>
#include "msxml.h"
#include "xmlparser.h"
#include "utils.h"


#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


//
// Local Define Section
// 

#define MAX_BUF     1024
#define FILEID      0

//
// SAFERELEASE does a safe release on COM interfaces. 
// Checks to see if not null, if so, calls release
// method on the interface. Then sets the interface to null.
//

#define SAFERELEASE(p) if (p) {(p)->Release(); p = NULL;} else ;

//
// Default string to be assigned to environment variables if 
// cannot assign real folder
//

#define DEFAULT_UNKNOWN _TEXT("C:\\Unknown_")
#define ICW_REGKEY      _TEXT("App Paths\\ICWCONN1.EXE")

// 
// Local Utility functions
// 

void FixInconsistantBlackslash(LPTSTR pszDirectory);

// 
// The constructor
// Desc:   Zero's all memory 
// 

CXMLFileListParser::CXMLFileListParser()
{
    LONG lLoop;
    m_pDoc = NULL;

    for(lLoop = 0;lLoop < NUM_FILE_TYPES;lLoop++)
    {
        m_pDir[lLoop] = m_pExt[lLoop] = m_pFiles[lLoop] = NULL;
    }

    m_chDefaultType     = _TEXT('i');
    m_clComInitialized  = 0;
}

CXMLFileListParser::~CXMLFileListParser()
{
    LONG lLoop;
        
    for(lLoop = 0;lLoop < NUM_FILE_TYPES;lLoop++)
    {
    
        SAFERELEASE( m_pDir[lLoop] ); 
        SAFERELEASE( m_pExt[lLoop] );
        SAFERELEASE( m_pFiles[lLoop] );
    }

    SAFERELEASE( m_pDoc );

    //
    // we need to do this in a loop
    // so we don't leek resources with refcounting
    //

    for( lLoop = 0; lLoop < m_clComInitialized ;lLoop++)
    {
        CoUninitialize( ); // lets kill COM!
    }
}

//
// Init overloaded
//
// Main intialization sequence
//
// 1) Initializes The Com Space and Creates an XML document
// 2) Loads in the specified file into the XML document object
// 3) Takes the document loads all the collections to populate 
//    our sub collections ( each list gets its own heading)
// 4) Sets up our Search->Replace settings
//

BOOL CXMLFileListParser::Init(LPCTSTR pszFile)
{
    if(!Init()) 
    {
        return FALSE;
    }

    if(!ParseFile(pszFile))
    {
        return FALSE;
    }

    if(!LoadCollections())
    {
        return FALSE;
    }

    if( !PopulateReplaceEntries() )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLFileListParser::Init()
{
    HRESULT hr;
    LONG    clLoop;

    TraceFunctEnter("Init");
        
    //
    // If we are reinitializing, make sure we free up old 
    // resources and clean up our internal variables
    //

    for( clLoop = 0; clLoop < NUM_FILE_TYPES; clLoop++)
    {
        SAFERELEASE( m_pDir[clLoop] );
        SAFERELEASE( m_pExt[clLoop] );
        SAFERELEASE( m_pFiles[clLoop] );
    }

    memset(m_adwVersion,0,sizeof(DWORD) * 4);

    //
    // Initialize our COM apartment space
    //

    hr = CoInitialize(NULL);
    m_clComInitialized++;

    //
    // S_FALSE means the COM apartment space has been initliazed 
    // for this procss already
    //

    if( (hr != S_OK) && (hr != S_FALSE) )
    {
        ErrorTrace(FILEID,"CoInitialize Failed 0x%x", hr);
        m_clComInitialized--;
        goto cleanup;
    }

    //
    //  Create an instance of our XML document object
    //

    hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                                IID_IXMLDocument, (void**)&m_pDoc);

    if( !m_pDoc || !SUCCEEDED(hr) )
    {
        ErrorTrace(FILEID,"CoCreateInstance Failed 0x%x", GetLastError());
        goto cleanup;
    }
    
    TraceFunctLeave();
    return(TRUE);

cleanup:

    SAFERELEASE( m_pDoc );

    TraceFunctLeave();
    return(FALSE);
}

//
// Method: LoadCollections()
//
// Desc:  
// This method goes through the XML file and finds the 
// <FILES>, <DIRECTORIES>, <EXTENSIONS>, <DEFTYPE>, <VERSION>
// high level tags and then runs LoadOneCollection() on each of
// them in order to
// populate the high level m_pDir, m_pFiles, m_pExt arrays ( which 
// have collections for
// include, exclude, sfp, etc )..
//

BOOL CXMLFileListParser::LoadCollections()
{
    IXMLElement             *pRoot = NULL, *pTempElement = NULL;
    IXMLElementCollection   *pChildren = NULL;
    IDispatch               *pDispatch = NULL;

    
    BSTR                    stTagName;
    HRESULT                 hr;

    BSTR                    stTagValue;
    TCHAR                   szBuf[MAX_BUFFER];

    LONG                    clLoop, lCollectionSize;

    TraceFunctEnter("CXMLFileListParser::LoadCollections");
  
     _ASSERT(m_pDoc);
 
    if( ( hr = m_pDoc->get_root( &pRoot) ) != S_OK )
    {
        ErrorTrace(FILEID, "IXMLDocument::GetRoot failed 0x%x",GetLastError());
        goto cleanup;
    }

    if( ( hr = pRoot->get_tagName( &stTagName ) ) != S_OK  )
    {
        ErrorTrace(FILEID, "IXMLElement::get_tagName failed 0x%x", hr );
        goto cleanup;
    }

    if( ConvertAndFreeBSTR( stTagName, szBuf,  MAX_BUFFER ) > MAX_BUFFER )
    {
        ErrorTrace(FILEID, "BSTR too large for buffer", 0);
        goto cleanup;
    }

    //
    // compare filesLPCT
    //

    if( _tcsicmp( _TEXT("PCHealthProtect"), szBuf )  ) 
    {
        ErrorTrace(FILEID, "Malformed XML file",0);
        goto cleanup;
    }

    if( ( hr = pRoot->get_children( &pChildren ) ) != S_OK )
    {
        ErrorTrace(FILEID,"IXMLElement::get_children failed 0x%x", hr);
        goto cleanup;
    }

    //
    // we no longer need the root;
    //

    SAFERELEASE(pRoot);

    if( (hr = pChildren->get_length(&lCollectionSize) ) !=  S_OK ) 
    {
        DebugTrace(FILEID,"Error Finding Length 0x%x",  hr ); 
        goto cleanup; 
    }

    //
    // lets get references to all the sub collections
    //

    for( clLoop = 0; clLoop < lCollectionSize; clLoop++)
    {
        VARIANT v1, v2;

        v1.vt = VT_I4;
        v2.vt = VT_EMPTY;

        v1.lVal = clLoop;

        //
        // get a item from the collection
        //

        if( (hr = pChildren->item(v1,v2, &pDispatch) ) != S_OK )
        {
            ErrorTrace(FILEID, "Error pChildren->item 0x%x", hr);
            goto cleanup;
        }

        if( ( hr = pDispatch->QueryInterface(IID_IXMLElement, 
                                            (void **) &pTempElement) ) != S_OK )
        {
            ErrorTrace(FILEID, "Error IDispatch::QueryInterface 0x%d", hr);
            goto cleanup;
        }

        //
        // lets see which collection it is
        //

        if( (hr =  pTempElement->get_tagName( &stTagName ) ) !=  S_OK ) 
        {
            DebugTrace(FILEID,  "Error in get_tagName 0x%x",  hr ); 
            goto cleanup; 
        }

        if( ConvertAndFreeBSTR( stTagName, szBuf,  MAX_BUFFER ) > MAX_BUFFER )
        {
            ErrorTrace(FILEID, "BSTR too large for buffer", 0);
            goto cleanup;
        }
                            
        if( !_tcsicmp( _TEXT("DIRECTORIES"), szBuf ) )
        {
            if( !LoadOneCollection(pTempElement, m_pDir ) )
            {
                ErrorTrace(FILEID,"Error Loading Collection",0);
                goto cleanup;
            }
        } 
        else if( !_tcsicmp( _TEXT( "FILES"), szBuf ) )
        {
            if( !LoadOneCollection(pTempElement, m_pFiles ) )
            {
                ErrorTrace(FILEID,"Error Loading Collection",0);
                goto cleanup;
            }
        } 
        else if( !_tcsicmp( _TEXT( "EXTENSIONS"), szBuf ) )
        {
            if( !LoadOneCollection(pTempElement, m_pExt ) )
            {
                ErrorTrace(FILEID,"Error Loading Collection",0);
                goto cleanup;
            }
        } 
        else if( !_tcsicmp( _TEXT( "VERSION"), szBuf ) )
        {
            if( ParseVersion(pTempElement) == FALSE ) 
            {
                goto cleanup;
            }
        } 
        else if( !_tcsicmp( _TEXT( "DEFTYPE"), szBuf ) ) 
        {
            if( ( hr = pTempElement->get_text( &stTagValue ) ) != S_OK )
            {
                ErrorTrace(FILEID, "Error in IXMLElement::get_text 0x%x", hr);
                goto cleanup;
            }

            if( ConvertAndFreeBSTR( stTagValue, 
                                    szBuf, 
                                    MAX_BUFFER ) > MAX_BUFFER )
            {
                ErrorTrace(FILEID, "Less space in BSTR to string buffer", 0);
                goto cleanup;
            }
 
            //
            // make sure trail, leaing spaces don't get us messed up;
            //

            TrimString(szBuf);

            //
            // empty string?
            //

            if( szBuf[0] == 0 )
            {
                ErrorTrace(FILEID, "Empty string passed to default type.",0);
                goto cleanup;
            }

            m_chDefaultType = szBuf[0];
        }
        else
        {
            ErrorTrace(FILEID, "Undefiend XML tag in file.",0);
            goto cleanup;
        }

        SAFERELEASE( pTempElement);
        SAFERELEASE( pDispatch );
    }

    SAFERELEASE( pChildren );

    TraceFunctLeave();
    return TRUE;

cleanup:

    SAFERELEASE( pTempElement ); 
    SAFERELEASE( pDispatch );
    SAFERELEASE( pRoot );
    SAFERELEASE( pChildren );

    TraceFunctLeave();

    return FALSE;
}

//
// Method: LoadOneCollection(IXMLElement *, IXMLElementCollection **)
//
// Desc:  Takes a high level node (like <FILES>) and then gets all 
// the sub include,exclude,sfp collections and sets them up in the 
// pCol array (usually passed a member variable like m_pDir, m_pFiles, 
// etc).
//

BOOL CXMLFileListParser::LoadOneCollection(
        IXMLElement *pColHead, 
        IXMLElementCollection **pCol )
{

    HRESULT                         hr;

    IXMLElementCollection           *pChildren = NULL;
    IXMLElement                     *pTempElement = NULL;
    IDispatch                       *pDispatch = NULL;
    LONG                            lCollectionSize, clLoop;
    
    BSTR                            stTagName;
    TCHAR                           szBuf[MAX_BUFFER];

    _ASSERT( pColHead );

    TraceFunctEnter("CXMLFileListParser::LoadOneCollection");

    // 
    // Lets make sure we don't have a section called <FILES></FILES>
    // 

    if( (hr = pColHead->get_children( &pChildren )) != S_OK )
    {
        ErrorTrace(FILEID,"Empty <FILES,EXT,DIRECTORY,etc section",0);
        TraceFunctLeave();
        return(TRUE);
    }

    if( (hr =  pChildren->get_length( &lCollectionSize ) ) !=  S_OK ) 
    {
        DebugTrace(FILEID,  "Error getting collection size. 0x%x",  hr ); 
        goto cleanup; 
    }

    for( clLoop = 0; clLoop < lCollectionSize; clLoop++)
    {
        //
        // Set up OLE style variant varaibles to loop through all the entires
        //

        VARIANT v1, v2;

        v1.vt = VT_I4;
        v2.vt = VT_EMPTY;

        v1.lVal = clLoop;

        //
        // get a item from the collection
        //

        if( (hr = pChildren->item(v1,v2, &pDispatch) ) != S_OK )
        {
            ErrorTrace(FILEID, "Error pChildren->item 0x%x", hr);
            goto cleanup;
        }

        if( ( hr = pDispatch->QueryInterface(IID_IXMLElement, 
                                            (void **) &pTempElement) ) != S_OK )
        {
            ErrorTrace(FILEID, "Error IDispatch::QueryInterface 0x%d", hr);
            goto cleanup;
        }
        
        SAFERELEASE( pDispatch );

        //
        // lets see which collection it is
        //
        if( (hr = pTempElement->get_tagName( &stTagName ) ) != S_OK )
        {   
            ErrorTrace(FILEID, "Error in get_tagName 0x%x", hr);
            goto cleanup;
        }
        
        if( ConvertAndFreeBSTR( stTagName, szBuf, MAX_BUFFER) > MAX_BUFFER )
        {
            ErrorTrace(FILEID, "Not enough space to convert BString.",0);
            goto cleanup;
        }
                            
        if( !_tcsicmp( _TEXT("INCLUDE"), szBuf ) )
        {
            if( (hr =  pTempElement->get_children( & pCol[INCLUDE_COLL] ) ) 
                 !=  S_OK ) 
            {
                DebugTrace(FILEID,"Error in IXMLElement::get_children 0x%x",hr);
                goto cleanup; 
            }
        } 
        else if( !_tcsicmp( _TEXT( "EXCLUDE"), szBuf ) )
        {
            if( (hr =  pTempElement->get_children( & pCol[EXCLUDE_COLL] ) ) 
                 !=  S_OK ) 
            {
                DebugTrace(FILEID,"Error in IXMLElement::get_children 0x%x",hr);
                goto cleanup; 
            }
        } 
        else if( !_tcsicmp( _TEXT( "SNAPSHOT"), szBuf ) )
        {
            if( (hr =  pTempElement->get_children( & pCol[SNAPSHOT_COLL] ) ) 
                 !=  S_OK ) 
            {
                DebugTrace(FILEID,"Error in IXMLElement::get_children 0x%x",hr);
                goto cleanup; 
            }
        }
        else
        {
            ErrorTrace(FILEID, "Undefiend XML tag in file.",0);
            goto cleanup;
        }

        SAFERELEASE( pTempElement);
    }

    SAFERELEASE( pChildren );

    TraceFunctLeave();
    return TRUE;

cleanup:

    SAFERELEASE( pTempElement );
    SAFERELEASE( pDispatch );
    SAFERELEASE( pChildren );

    TraceFunctLeave();
    return FALSE;
}

//
//  Function: ParseFile(LPCTSR pszFile)
//  Desc: Loads a file into the member variable m_pDoc.
//

BOOL CXMLFileListParser::ParseFile(LPCTSTR pszFile)
{
    BSTR                   pBURL=NULL;    
    _bstr_t                FileBuffer( pszFile );
    HRESULT                hr;
    
    TraceFunctEnter("ParseFile");
    
    pBURL = FileBuffer.copy();

    if( !pBURL ) 
    {
        ErrorTrace(FILEID, "Error allocating space for a BSTR", 0);
        goto cleanup;
    }
    
    if(  (hr =  m_pDoc->put_URL( pBURL ) ) !=  S_OK ) 
    {
        DebugTrace(FILEID,  "Error m_pDoc->putUrl %0x%x",  hr ); 
        goto cleanup; 
    }

    if( pBURL )
    {
        SysFreeString( pBURL );
    }

    TraceFunctLeave();
    return(TRUE);

cleanup:
    
    if( pBURL )
    {
        SysFreeString( pBURL );
    }

    TraceFunctLeave();
    return(FALSE);
}

//
// Function: ParseVersion(IXMLElement *pVerElement)
//
//
// Desc: This funciton is called from LoadCollections() when it hits the element
// containing the XML files version. It takes an IXMLElement
// object and extracts the version into the m_adwVersion array
//
// 

BOOL CXMLFileListParser::ParseVersion(IXMLElement *pVerElement)
{
    HRESULT             hr;
    BSTR                stTagValue;
    TCHAR               szTagValue[MAX_BUFFER];
    TCHAR               szBuf[256];
    LONG                clElement;
    
    TraceFunctEnter("CXMLFileListParser::ParseVersionElement");
    
    if( (hr =  pVerElement->get_text( & stTagValue ) ) !=  S_OK ) 
    {
        DebugTrace(FILEID,  "Error in IXMLElement::get_text 0x%x",  hr ); 
        goto cleanup; 
    }

    if( ConvertAndFreeBSTR( stTagValue, szTagValue, MAX_BUFFER ) > MAX_BUFFER )
    {
        ErrorTrace(FILEID, "Error conveting the Bstring. Not enough buffer.",0);
        goto cleanup;
    }
    
    for( clElement = 0; clElement < 4; clElement++ )
    {
        if( GetField(szTagValue,szBuf,clElement,_TEXT('.') ) == 0 )
            break;
        
        m_adwVersion[clElement] = _ttoi( szBuf );
    }
            
    TraceFunctLeave();
    return(TRUE);

cleanup:

    TraceFunctLeave();
    return FALSE;
}

//
// XML Tree traversal and general accessor functions
// Exposed Wrappers:  GetDirectory, GetFile, GetExt
//                     GetDirectoryCount, GetFileCount, GetExtCount
//  

//
// RETURN VALUES FOR THE GET FUNCTIONS:
//          lBufMax -- filename was copied OK
//          0 -- serious error occoured
//          > lBufMax -- the number of TCHARs you really need
//

// 
// BOOL *pfDisable is for the special 
// "protected directory" feature in the VxD.
// 

LONG 
CXMLFileListParser::GetDirectory(
    LONG ilElement, 
    LPTSTR pszBuf, 
    LONG lBufMax, 
    TCHAR chType, 
    BOOL *pfDisable)
{
    LONG lReturnValue=0;
    LONG lType;

    TraceFunctEnter("CXMLFileListParser::GetDirectory");

    //
    // get the array index of this file type
    //

    lType = TranslateType( chType );

    if( !m_pDoc ||  !m_pDir[lType] )
    {
        TraceFunctLeave();
        return 0;
    }

    if( (lReturnValue = GetFileInfo(
                            m_pDir[lType],  
                            ilElement, 
                            pszBuf, 
                            lBufMax, 
                            pfDisable)) != lBufMax)
    {
        goto cleanup;
    }

    if( (lReturnValue = SearchAndReplace(pszBuf, lBufMax) ) != lBufMax )
    {
        goto cleanup;
    }

    CharUpper( pszBuf );

    //
    // make sure there are no (lead/trail spaces/tabs)
    //

    TrimString( pszBuf );

cleanup:

    TraceFunctLeave();
    return( lReturnValue );
}

LONG 
CXMLFileListParser::GetDirectory(
    LONG ilElement, 
    LPTSTR pszBuf, 
    LONG lBufMax, 
    TCHAR chType)
{
    return( GetDirectory( ilElement, pszBuf, lBufMax, chType, NULL ) );
}

LONG 
CXMLFileListParser::GetExt(
    LONG ilElement, 
    LPTSTR pszBuf, 
    LONG lBufMax, 
    TCHAR chType)
{
    LONG lReturnValue=0;
    LONG lType;

    TraceFunctEnter("CXMLFileListParser::GetExt");

    lType = TranslateType( chType );

    if( !m_pDoc ||  !m_pExt[lType] )
    {
        TraceFunctLeave();
        return 0;
    }

    if( (lReturnValue = GetFileInfo(m_pExt[lType],  
                                    ilElement, 
                                    pszBuf, 
                                    lBufMax, 
                                    NULL)) != lBufMax)
    {
        goto cleanup;
    }

    if( (lReturnValue = SearchAndReplace(pszBuf, lBufMax) ) != lBufMax )
    {
        goto cleanup;
    }
    
    CharUpper( pszBuf );

    //
    // make sure there are no (lead/trail spaces/tabs)
    //

    TrimString( pszBuf );

cleanup:

    TraceFunctLeave();
    return( lReturnValue );
}

LONG 
CXMLFileListParser::GetFile(
    LONG ilElement, 
    LPTSTR pszBuf, 
    LONG lBufMax, 
    TCHAR chType)
{
    LONG lReturnValue=0;
    LONG lType;

    TraceFunctEnter("CXMLFileListParser::GetFile");

    lType = TranslateType( chType );

    if( !m_pDoc ||  !m_pFiles[lType] )
    {
        TraceFunctLeave();
        return 0;
    }

    if( (lReturnValue = GetFileInfo(m_pFiles[lType],  
                                    ilElement, 
                                    pszBuf, 
                                    lBufMax, 
                                    NULL)) != lBufMax)
    {
        goto cleanup;
    }

    if( (lReturnValue = SearchAndReplace(pszBuf, lBufMax) ) != lBufMax )
    {
        goto cleanup;
    }

    CharUpper( pszBuf );

    //
    // make sure there are no (lead/trail spaces/tabs)
    //

    TrimString( pszBuf );

cleanup:

    TraceFunctLeave();
    return( lReturnValue );
}

//
//  GetDirectory/File/ExtCount functions.
//  These functions give you the number of entries in a specific collection.
//  For example: GetFileCount(SNAPSHOT_TYPE) will return the numbert
//  of entries in the FILES main heading, which are under the SNAPSHOT
//  subheading in the XML file.
//

LONG 
CXMLFileListParser::GetDirectoryCount(
    TCHAR chType)
{
    LONG lReturnValue;

    TraceFunctEnter("CXMLFileListParser::GetDirectoryCount");

    lReturnValue = GetCollectionSize( m_pDir[TranslateType(chType)] );

    TraceFunctLeave();
    return( lReturnValue );
}

LONG 
CXMLFileListParser::GetExtCount(
    TCHAR chType)
{
    LONG lReturnValue;

    TraceFunctEnter("CXMLFileListParser::GetExtCount");

    lReturnValue = GetCollectionSize( m_pExt[TranslateType(chType)] );

    TraceFunctLeave();
    return( lReturnValue );
}


LONG 
CXMLFileListParser::GetFileCount(
    TCHAR chType)
{
    LONG lReturnValue;

    TraceFunctEnter("CXMLFileListParser::GetFileCount");

    lReturnValue = GetCollectionSize( m_pFiles[TranslateType(chType)] );

    TraceFunctLeave();
    return( lReturnValue );
}

//
//  Main internal functions used to get by the wrappers.
//  
//  GetCollectionSize, GetFileInfo
//
//

LONG 
CXMLFileListParser::GetCollectionSize(
    IXMLElementCollection *pCol)
{
    LONG lCollectionSize;
    HRESULT hr;

    TraceFunctEnter("CXMLFileListParser::GetCollectionSize");

    if( pCol == NULL ) {
        TraceFunctLeave();
        return 0;
    }

    if( (hr =  pCol->get_length(&lCollectionSize) ) !=  S_OK ) 
    {
        DebugTrace(FILEID,  "Error Finding Length 0x%x",  hr ); 
        goto cleanup; 
    }

    TraceFunctLeave();
    return(lCollectionSize);

cleanup:

    TraceFunctLeave();
    return 0;       
}

//
// RETURN VALUES:
//          lBufMax -- filename was copied OK
//          0 -- serious error occoured
//          > lBufMax -- the number in TCHAR's that you need.
//

LONG 
CXMLFileListParser::GetFileInfo(
    IXMLElementCollection *pCol, 
    LONG ilElement, 
    LPTSTR pszBuf, 
    LONG lBufMax, 
    BOOL *pfDisable)
{

    HRESULT                 hr;
    LONG                    lLen, lCollectionSize=0, clLoop, lReturnValue=0;
    VARIANT                 v1, v2; 

    // OLE/COM BSTR variables and helper classes

    BSTR                    stTagValue;
    TCHAR                   szValueBuffer[MAX_BUFFER];
    
    // COM interfaces
    IDispatch               *pDispatch = NULL;
    IXMLElement             *pTempElement = NULL;
    IXMLElementCollection   *pChildren = NULL;

    TraceFunctEnter("CXMLFileListParser::GetFileInfo");

    //
    // Basic assumptions of the code.
    //

    _ASSERT(pCol);
    _ASSERT(pszBuf || !lBufMax);
    _ASSERT(pchType);

    //
    // Set up to make sure protection code is clean
    // Test to see if we have an in-range request.
    //

    if( (hr =  pCol->get_length(&lCollectionSize) ) !=  S_OK ) 
    {
        DebugTrace(FILEID,  "Error Finding Length 0x%x",  hr ); 
        goto cleanup; 
    }
    
    if( ilElement >= lCollectionSize )
    {
        ErrorTrace(FILEID, 
                   "CXMLFileListParser::GetFileInfo (Element out of range)",
                   0);

        goto cleanup;
    }

    v1.vt = VT_I4;
    v1.lVal = ilElement;
    v2.vt = VT_EMPTY;

    //
    // get a item from the collection
    //

    if( (hr = pCol->item(v1,v2, &pDispatch) ) != S_OK )
    {
        ErrorTrace(FILEID, "Error pChildren->item 0x%x", hr);
        goto cleanup;
    }

    if( ( hr = pDispatch->QueryInterface(IID_IXMLElement, 
                                         (void **) &pTempElement) ) != S_OK )
    {
        ErrorTrace(FILEID, "Error IDispatch::QueryInterface 0x%d", hr);
        goto cleanup;
    }

    SAFERELEASE( pDispatch );
   
    if( (hr =  pTempElement->get_text( & stTagValue ) ) !=  S_OK ) 
    {
        DebugTrace(FILEID,  "Error in IXMLElement::get_text 0x%x",  hr ); 
        goto cleanup; 
    }

    if( ( lLen = ConvertAndFreeBSTR( stTagValue, szValueBuffer, MAX_BUFFER ) ) >
                 MAX_BUFFER ) 
    {
        lReturnValue =  lLen + 1;
        goto cleanup;
    }

     _tcscpy( pszBuf, szValueBuffer );

    if( pfDisable )
    {
        _bstr_t    AttrName( _TEXT("DISABLE")  );
        VARIANT    AttrValue;

        *pfDisable = FALSE;

        //
        // clear the variant
        //

        VariantInit( &AttrValue );

        hr = pTempElement->getAttribute( AttrName, &AttrValue );
     
        //
        // who cares what the property name is
        //

        if( hr == S_OK )
        {
            *pfDisable = TRUE;
            VariantClear( &AttrValue );
        }
    }

    SAFERELEASE( pTempElement );

    lReturnValue = lBufMax;

    TraceFunctLeave();
    return(lReturnValue);
      
cleanup:

    SAFERELEASE( pTempElement );
    SAFERELEASE( pDispatch );

    // what about BSTR's?    

    TraceFunctLeave();
    return(lReturnValue);
}

BOOL 
CXMLFileListParser::GetVersion(
    LPDWORD pdwVersion)
{

    TraceFunctEnter("CXMLFileListParser::GetVersion");

    _ASSERT( pdwVersion );

    memcpy( pdwVersion, m_adwVersion, sizeof(DWORD) * 4 );

    TraceFunctLeave();
    return(TRUE);
}

TCHAR 
CXMLFileListParser::GetDefaultType()
{
    return( (TCHAR) CharUpper( (LPTSTR) m_chDefaultType) );
}

LONG 
CXMLFileListParser::SearchAndReplace(
    LPTSTR szBuf, 
    LONG   lMaxBuf)
{
    TCHAR  szTempBuf[MAX_BUFFER];
    DWORD  dwResult;
    LONG   lReturn = 0;

    TraceFunctEnter("CXMLFileListParser::SearchAndReplace");

    dwResult = ExpandEnvironmentStrings( szBuf, szTempBuf, lMaxBuf);

    if( 0 == dwResult )
    {
        DWORD   dwError;
        dwError = GetLastError();
        ErrorTrace(FILEID, "Error in search and replace ec-%d", dwError);
        lReturn = 0;
        goto cleanup;
    }

    if( dwResult > (lMaxBuf*sizeof(TCHAR) ) )
    {
        ErrorTrace(FILEID, "Buffer too small in Search and replace.",0);
        lReturn = dwResult;
        goto cleanup;
    }

    _tcscpy( szBuf, szTempBuf );
    lReturn = lMaxBuf;

cleanup:
    TraceFunctLeave();
    return lReturn;
}

BOOL 
CXMLFileListParser::DepopulateReplaceEntries()
{
    LONG clLoop;

    TraceFunctEnter("CXMLFileListParser::DepopulateReplaceEntries");

    // This code shouldn't do anything anymore in the new system

    TraceFunctLeave();

    return TRUE;
}

BOOL 
GetDSRoot( TCHAR ** pszStr )
{
	static WCHAR str[MAX_PATH];

    *pszStr = str;

	*str = 0;

#ifdef UNICODE
    _stprintf( *pszStr, _TEXT("*:\\_restore.%s"), GetMachineGuid());
#else
    _stprintf( *pszStr, _TEXT("*:\\_restore") );
#endif

    return TRUE;
}

BOOL 
GetArchiveDir( TCHAR ** pszStr )
{
    static TCHAR str[MAX_PATH];
#if 0
    *pszStr = str;
    _tcscpy( *pszStr, _TEXT("c:\\_restore\\archive") );
#endif
    return TRUE;
}

BOOL 
GetDSTemp( TCHAR ** pszStr )
{
    static TCHAR str[MAX_PATH];
#if 0
    *pszStr = str;
    _tcscpy( *pszStr, _TEXT("c:\\_restore\\temp") );
#endif
    return TRUE;
}

//
//  CODEWORK:       REMOVE NO ERROR DETECTION HACK.
//

BOOL CXMLFileListParser::PopulateReplaceEntries()
{
    TCHAR       szBuf[MAX_BUFFER];
    DWORD       dwSize;
    HKEY        hCurrentSettings=NULL;
    HKEY        hICWKey = NULL;
    HRESULT     hr=0;    
	BOOL		fChgLogOpen=FALSE;
    LPTSTR      pszDSInfo=NULL;
    TCHAR       szLPN[MAX_BUFFER];
    DWORD       cbLPN;
    
    TraceFunctEnter("CXMLFileListParser::PopulateReplaceEntries()");

   
    // windows directory

    if( GetWindowsDirectory( szBuf,MAX_BUFFER ) > MAX_BUFFER )
    {   
        ErrorTrace(FILEID, "Error getting windir",0);
        goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("WinDir"), szBuf );

    // windows system directory

    if( GetSystemDirectory( szBuf,MAX_BUFFER ) > MAX_BUFFER )
    {   
        ErrorTrace(FILEID, "Error getting windir",0);
        goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("WinSys"), szBuf );

    // Alt Startup folder  

    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_ALTSTARTUP ,FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: AltStartUp, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("AltStartUp"));
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("AltStartup"), szBuf );

    //App data
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_APPDATA ,FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: AppData, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("AppData"));        
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("AppData"), szBuf );


    // Recycle Bin ( BITBUCKET )
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_BITBUCKET ,FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();           
        ErrorTrace(FILEID, "Error getting special folder: RecycleBin, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("RecycleBin"));
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("RecycleBin"), szBuf );

    // Common Desktop

    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_COMMON_DESKTOPDIRECTORY ,FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: CommonDesktop, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("CommonDesktop"));
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("CommonDesktop"), szBuf );

    // Common Favorite
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_COMMON_FAVORITES ,FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: CommonFavorites, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("CommonFavorites"));
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("CommonFavorites"), szBuf );


    // Common Program groups
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_COMMON_PROGRAMS,FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: CommonProgramGroups, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("CommonProgramGroups"));
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("CommonProgramGroups"), szBuf );

   // Common start menu directory
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_COMMON_STARTMENU, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: CommonStartMenu, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("CommonStartMenu"));
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("CommonStartMenu"), szBuf );

    // Common Startup Folder
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_COMMON_STARTUP, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: CommonStartUp, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("CommonStartUp"));
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("CommonStartUp"), szBuf );

    // cookies folder
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_COOKIES, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: Cookies, error 0x%x", dwError);
        GetWindowsDirectory(szBuf, MAX_BUFFER);
        lstrcat(szBuf, _TEXT("\\Cookies"));
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("Cookies"), szBuf );

    // desktop directory
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_DESKTOPDIRECTORY, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: DesktopDirectory, error 0x%x", dwError);
        GetWindowsDirectory(szBuf, MAX_BUFFER);
        lstrcat(szBuf, _TEXT("\\Desktop"));
        //goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("DesktopDirectory"), szBuf );

     // favorites
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_FAVORITES, FALSE) != TRUE )
    {
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: Favorites, error 0x%x", dwError);
        GetWindowsDirectory(szBuf, MAX_BUFFER);
        lstrcat(szBuf, _TEXT("\\Favorites"));
        //goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("Favorites"), szBuf );

    // favorites
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_INTERNET_CACHE, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: InternetCache, error 0x%x", dwError);
        GetWindowsDirectory(szBuf, MAX_BUFFER);
        lstrcat(szBuf, _TEXT("\\Temporary Internet Files"));
        //goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("InternetCache"), szBuf );

    // network neightbors
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_NETHOOD, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: Nethood, error 0x%x", dwError);
        GetWindowsDirectory(szBuf, MAX_BUFFER);
        lstrcat(szBuf, _TEXT("\\Nethood"));
        //goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("NetHood"), szBuf );

    // favorites
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_PERSONAL, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: PersonalDocuments, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("PersonalDocuments"));
        //goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("PersonalDocuments"), szBuf );

    // favorites
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_STARTMENU, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: StartMenu, error 0x%x", dwError);
        GetWindowsDirectory(szBuf, MAX_BUFFER);
        lstrcat(szBuf, _TEXT("\\Start Menu"));
        //goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("StartMenu"), szBuf );

    // favorites
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_TEMPLATES, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: Templates, error 0x%x", dwError);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("Templates"));
        //goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("Templates"), szBuf );

        // favorites
    if( SHGetSpecialFolderPath(NULL,szBuf, CSIDL_HISTORY, FALSE) != TRUE )
    {   
        DWORD dwError = GetLastError();
        ErrorTrace(FILEID, "Error getting special folder: History, error 0x%x", dwError);
        GetWindowsDirectory(szBuf, MAX_BUFFER);
        lstrcat(szBuf, _TEXT("\\History"));
        //goto cleanup;
    }
	FixInconsistantBlackslash(szBuf);
    SetEnvironmentVariable( _TEXT("History"), szBuf );

    //hack
    if( RegOpenKey( HKEY_LOCAL_MACHINE, _TEXT("Software\\Microsoft\\Windows\\CurrentVersion"), &hCurrentSettings) != ERROR_SUCCESS)
    {
       ErrorTrace(FILEID,"Error opening registry key to retrieve program files",0);
       goto cleanup;
    }

    dwSize = MAX_BUFFER * sizeof(TCHAR);
    if( RegQueryValueEx( hCurrentSettings, _TEXT("ProgramFilesDir"), NULL, NULL, (LPBYTE) szBuf, &dwSize) != ERROR_SUCCESS )
    {
        ErrorTrace(FILEID,"Error querying program files registry key.",0);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("ProgramFilesDir"));
        // goto cleanup;
    }

	FixInconsistantBlackslash(szBuf); 
    SetEnvironmentVariable( _TEXT("ProgramFiles"), szBuf );


    dwSize = MAX_BUFFER * sizeof(TCHAR);
    if( RegQueryValueEx( hCurrentSettings, _TEXT("CommonFilesDir"), NULL, NULL, (LPBYTE) szBuf, &dwSize) != ERROR_SUCCESS )
    {
        ErrorTrace(FILEID,"Error querying common files registry key.",0);
        lstrcpy(szBuf, DEFAULT_UNKNOWN);
        lstrcat(szBuf, _TEXT("CommonFilesDir"));
        // goto cleanup;
    }

	FixInconsistantBlackslash(szBuf); 
    SetEnvironmentVariable( _TEXT("CommonFiles"), szBuf );

    
    // get the ICW dir path from the registry
    if (ERROR_SUCCESS == RegOpenKeyEx(hCurrentSettings, ICW_REGKEY, 0, KEY_QUERY_VALUE, &hICWKey))
    {
        dwSize = MAX_BUFFER * sizeof(TCHAR);
        if (ERROR_SUCCESS == RegQueryValueEx(hICWKey, _TEXT("Path"), NULL, NULL, (LPBYTE) szBuf, &dwSize))
        {   
            // remove the extra ; in the path if it is there
            dwSize = lstrlen(szBuf);
            if (dwSize > 0)
            {
                if (szBuf[dwSize - 1] == TCHAR(';'))
                {
                    szBuf[dwSize - 1] = TCHAR('\0');
                }
            }

            // convert sfn to lfn
            cbLPN = sizeof(szLPN)/sizeof(TCHAR);
            if (cbLPN <= GetLongPathName(szBuf, szLPN, cbLPN))  // error
            {
                ErrorTrace(FILEID, "Error getting LPN for %s; error=%ld", szBuf, GetLastError());
                lstrcpy(szLPN, DEFAULT_UNKNOWN);
                lstrcat(szLPN, TEXT("ConnectionWizardDir"));
            }
        }
        else
        {
            lstrcpy(szLPN, DEFAULT_UNKNOWN);  
            lstrcat(szLPN, TEXT("ConnectionWizardDir"));
        }        
    }
    else
    {
        lstrcpy(szLPN, DEFAULT_UNKNOWN);
        lstrcat(szLPN, TEXT("ConnectionWizardDir"));        
    }

    SetEnvironmentVariable(_TEXT("ConnectionWizard"), szLPN);
    DebugTrace(FILEID, "ICW Path = %s", szLPN);

    if (hICWKey)
    {
        RegCloseKey(hICWKey);
    }

    RegCloseKey( hCurrentSettings );
    hCurrentSettings = NULL;

    //
    //  System restore file stuff
    //

    if( GetDSRoot( &pszDSInfo ) == TRUE )
    {
        SetEnvironmentVariable( _TEXT("SRDataStoreRoot"), pszDSInfo );
    } 
    else
    {
        DebugTrace(FILEID, "Error getting system restore root directory",0);
    }

    if( GetArchiveDir( &pszDSInfo ) == TRUE )
    {
        SetEnvironmentVariable( _TEXT("SRArchiveDir"), pszDSInfo );
    }
    else
    {
        DebugTrace(FILEID, "Error getting system restore archive directory",0);
    }

    if( GetDSTemp( &pszDSInfo ) == TRUE )
    {
        SetEnvironmentVariable( _TEXT("SRTempDir"), pszDSInfo );
    }
    else
    {
        DebugTrace(FILEID, "Error getting system restore temp directory",0);
    }
    

    // CODEWORK: Do this for real    
    SetEnvironmentVariable( _TEXT("DocAndSettingRoot"), _TEXT("C:\\Documents And Settings") );

   TraceFunctLeave();
   return TRUE;
cleanup:
   if( hCurrentSettings )
   {
        RegCloseKey( hCurrentSettings );
   }
   // leave it, will be taken care of in the destructor

   TraceFunctLeave();
   return (FALSE);
}

//
//  Misc utility functions
//

//
// We are assuming the buffer is big enough to fit the bstr. 
// if it is not, we still
// free it but return false. 
//

LONG 
CXMLFileListParser::ConvertAndFreeBSTR(
    BSTR bstrIn, 
    LPTSTR szpOut, 
    LONG lMaxBuf)
{

    LONG        lLen;

    TraceFunctEnter("CXMLFileListParser::ConvertAndFreeBSTR");

    //
    // Initialize the output buffer
    //

    if (szpOut)
    {
        *szpOut = 0;
    }

    //
    // make a copy and put it in our object.
    //

    _ASSERT( bstrIn );
    _bstr_t     BSTRBuffer( bstrIn, TRUE );

    lLen = BSTRBuffer.length();

    //
    // not enough buffer space.
    //

    if( lLen > (lMaxBuf+1) )
    {
        // copy what we can out.
        _tcsncpy( szpOut, BSTRBuffer.operator LPTSTR(), lMaxBuf );
        szpOut[lMaxBuf] = 0;
        SysFreeString( bstrIn );
        TraceFunctLeave();
        return( lLen + 1 );

    }

    _tcscpy( szpOut, BSTRBuffer.operator LPTSTR() );
    
    //
    // remove our BSTR
    //

    SysFreeString( bstrIn );

    return( lMaxBuf );
}

LONG 
CXMLFileListParser::TranslateType(TCHAR chType)
{
    if( ( chType == _TEXT('i') ) || ( chType == _TEXT('I') ) )
    {
        return( INCLUDE_COLL );
    } 
    else if( ( chType == _TEXT('e') ) || ( chType == _TEXT('E') ) )
    {
        return( EXCLUDE_COLL );
    }
    else if( ( chType == _TEXT('s') )  || ( chType == _TEXT('S') ) )
    {
        return( SNAPSHOT_COLL );
    }

    return( 0 );
}

void 
CXMLFileListParser::DebugPrintTranslations()
{
    LONG cl;
    LPTSTR  pszStr=NULL;
    LPVOID  pszBlock;

    printf("File Name Translation Values ... \n");

    pszBlock = GetEnvironmentStrings();
    pszStr = (LPTSTR) pszBlock;

    while( pszStr && *pszStr )
    {
        _tprintf(_TEXT("%s\n"), pszStr);
        pszStr += (DWORD) StringLengthBytes(pszStr)/sizeof(TCHAR);
    }

    FreeEnvironmentStrings( (LPTSTR) pszBlock );
}

//
//	A fix to the inconsistent blackslash behavior in the 
//	shell API.
//

void 
FixInconsistantBlackslash(
    LPTSTR pszDirectory)
{
	LONG lLen;

	_ASSERT( pszDirectory );

	lLen = _tcslen( pszDirectory );

	if( lLen <= 0 )
	{
		return;
	}

	if( pszDirectory[ lLen - 1 ] == _TEXT('\\') )
	{
		pszDirectory[lLen - 1] = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\cabfunc.cpp ===
#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include "cabfunc.h"
#include "resource.h"
#include "filestuff.h"
#include "fdi.h"
#include "setupapi.h"




CString g_strExpandToDirectory;


LRESULT    WINAPI CabinetCallbackToExpand ( IN PVOID pMyInstallData, IN UINT Notification,  IN UINT_PTR Param1,  IN UINT_PTR Param2 )
   {
      LRESULT lRetVal = NO_ERROR;
      
      FILE_IN_CABINET_INFO *pInfo = NULL; 
	  CString strTargetName = g_strExpandToDirectory;
	  strTargetName += '\\';
	  switch(Notification)
      {
		 
         case SPFILENOTIFY_FILEINCABINET:

	        pInfo = (FILE_IN_CABINET_INFO *) Param1;
			lRetVal = FILEOP_DOIT;  // Extract the file.
			strTargetName += pInfo->NameInCabinet;
			//pInfo->FullTargetName is define as  TCHAR  FullTargetName[MAX_PATH];
			_tcsncpy(pInfo->FullTargetName,strTargetName.GetBuffer(strTargetName.GetLength()),MAX_PATH);
	                    
         break;
		 case SPFILENOTIFY_FILEEXTRACTED:

            lRetVal = NO_ERROR;
         break;
		 case SPFILENOTIFY_NEEDNEWCABINET: // Cab file in the cab file we're looking at.  Ignore it.
            lRetVal = NO_ERROR;
         break;
      }      
	  return lRetVal;
   }  

BOOL OpenCABFile(const CString& strCabPath,const CString& strExpandToDirectory)
{

	g_strExpandToDirectory = strExpandToDirectory;
	if (!SetupIterateCabinet(strCabPath,0,(PSP_FILE_CALLBACK)CabinetCallbackToExpand,0))
	{
		return FALSE;
	}
	else 
	{
		return TRUE;
	}

}



//---------------------------------------------------------------------------
// This function looks in the specified directory for an NFO file. If it
// finds one, it assigns it to filename and returns TRUE. This function 
// will only find the first NFO file in a directory.
//
// If an NFO file cannot be found, then we'll look for another file type
// to open. Grab the string entry in the registry = "cabdefaultopen". An
// example value would be "*.nfo|hwinfo.dat|*.dat|*.txt" which would be 
// interpreted as follows:
//
//		1. First look for any NFO file to open.
//		2. Then try to open a file called "hwinfo.dat".
//		3. Then try to open any file with a DAT extension.
//		4. Then try for any TXT file.
//		5. Finally, if none of these can be found, present an open dialog
//		   to the user.
//---------------------------------------------------------------------------

LPCTSTR VAL_CABDEFAULTOPEN = _T("cabdefaultopen");
LPCTSTR cszDirSeparator = _T("\\");

BOOL IsDataspecFilePresent(CString strCabExplodedDir)
{
	CStringList	filesfound;
	DirectorySearch(_T("dataspec.xml"), strCabExplodedDir, filesfound);
	if (filesfound.GetHeadPosition() != NULL)
	{
		return TRUE;
	}
	return FALSE;
}

BOOL IsIncidentXMLFilePresent(CString strCabExplodedDir, CString strIncidentFileName)
{
	CStringList			filesfound;
	DirectorySearch(strIncidentFileName, strCabExplodedDir, filesfound);
	if (filesfound.GetHeadPosition() != NULL)
	{
		return TRUE;
	}
	return FALSE;

}

BOOL FindFileToOpen(const CString & destination, CString & filename)
{
	CString strCABDefaultOpen, strRegBase, strDirectory;
	HKEY	hkey;

	filename.Empty();
	strDirectory = destination;
	if (strDirectory.Right(1) != CString(cszDirSeparator))
		strDirectory += CString(cszDirSeparator);

	// Set up a fallback string of the NFO file type, in case we can't
	// find the registry entry.

	strCABDefaultOpen.LoadString(IDS_DEFAULTEXTENSION);
    strCABDefaultOpen = CString("*.") + strCABDefaultOpen;

	// Load the string of files and file types to open from the registry.

	strRegBase.LoadString(IDS_MSI_REG_BASE);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, strRegBase, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
	{
		char	szData[MAX_PATH];
		DWORD	dwType, dwSize = MAX_PATH;

		if (RegQueryValueEx(hkey, VAL_CABDEFAULTOPEN, NULL, &dwType, (LPBYTE) szData, &dwSize) == ERROR_SUCCESS)
			if (dwType == REG_SZ)
				strCABDefaultOpen = szData;
		RegCloseKey(hkey);
	}

	// Look through each of the potential files and file types. If we find
	// a match, return TRUE after setting filename appropriately. Note that
	// we need to recurse down through directories.

	CString				strFileSpec;
	CStringList			filesfound;
	POSITION			pos;

	while (!strCABDefaultOpen.IsEmpty())
	{
		if (strCABDefaultOpen.Find('|') == -1)
			strFileSpec = strCABDefaultOpen;
		else
			strFileSpec = strCABDefaultOpen.Left(strCABDefaultOpen.Find('|'));

		filesfound.RemoveAll();
		DirectorySearch(strFileSpec, strDirectory, filesfound);
		pos = filesfound.GetHeadPosition();

		if (pos != NULL)
		{
			filename = filesfound.GetNext(pos);
			return TRUE;
		}

		strCABDefaultOpen = strCABDefaultOpen.Right(strCABDefaultOpen.GetLength() - strFileSpec.GetLength());
		if (strCABDefaultOpen.Find('|') == 0)
			strCABDefaultOpen = strCABDefaultOpen.Right(strCABDefaultOpen.GetLength() - 1);
	}



//a-kjaw
////Look for incident.xml file. It has to be an unicode file.
		strCABDefaultOpen = _T("*.XML");

		TCHAR	pBuf[MAX_PATH];
		WCHAR	pwBuf[MAX_PATH];
		HANDLE	handle;
		DWORD	dw;
	

	while (!strCABDefaultOpen.IsEmpty())
	{
		if (strCABDefaultOpen.Find('|') == -1)
			strFileSpec = strCABDefaultOpen;
		else
			strFileSpec = strCABDefaultOpen.Left(strCABDefaultOpen.Find('|'));

		filesfound.RemoveAll();
		DirectorySearch(strFileSpec, strDirectory, filesfound);
		pos = filesfound.GetHeadPosition();

		while (pos != NULL)
		{
			filename = filesfound.GetNext(pos);
			
			handle = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if (INVALID_HANDLE_VALUE == handle)
				continue;

			ReadFile(handle , pBuf , 1 , &dw , NULL);
			
			if( pBuf[0] == _T('<'))
			{
				do
				{
					ReadFile(handle , pBuf , _tcslen(_T("MachineID")) * sizeof(TCHAR) , &dw , NULL);
					if(_tcsicmp(pBuf , _T("MachineID")) == 0)
					{
						CloseHandle( handle );
						return TRUE;
					}
					else
					{
						SetFilePointer(handle , (1 - _tcslen(_T("MachineID")) )* sizeof(TCHAR) , 0 , FILE_CURRENT );
					}
				}while( dw == _tcslen(_T("MachineID")) );

			}
			else //Unicode?
			{
									
				ReadFile(handle , pwBuf , 1 , &dw , NULL);
				do
				{

					ReadFile(handle , pwBuf , lstrlenW(L"MachineID") * sizeof(WCHAR) , &dw , NULL);
					pwBuf[ lstrlenW(L"MachineID") ] = L'\0';
					if(lstrcmpiW(pwBuf , L"MachineID") == 0)
					{
						CloseHandle( handle );
						return TRUE;
					}
					else
					{
						SetFilePointer(handle , (1 - lstrlenW(L"MachineID"))* sizeof(WCHAR) , 0 , FILE_CURRENT );
					}				
				}while( dw == _tcslen(_T("MachineID")) * sizeof(WCHAR) );
			}
				CloseHandle( handle );
		}

		strCABDefaultOpen = strCABDefaultOpen.Right(strCABDefaultOpen.GetLength() - strFileSpec.GetLength());
		if (strCABDefaultOpen.Find('|') == 0)
			strCABDefaultOpen = strCABDefaultOpen.Right(strCABDefaultOpen.GetLength() - 1);
	}


	
	return FALSE;
}


//---------------------------------------------------------------------------
// DirectorySearch is used to locate all of the files in a directory or
// one of its subdirectories which match a file spec.
//---------------------------------------------------------------------------

void DirectorySearch(const CString & strSpec, const CString & strDir, CStringList &results)
{
	// Look for all of the files which match the file spec in the directory
	// specified by strDir.

	WIN32_FIND_DATA	finddata;
	CString			strSearch, strDirectory;

	strDirectory = strDir;
	if (strDirectory.Right(1) != CString(cszDirSeparator)) strDirectory += CString(cszDirSeparator);

	strSearch = strDirectory + strSpec;
	HANDLE hFind = FindFirstFile(strSearch, &finddata);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			results.AddHead(strDirectory + CString(finddata.cFileName));
		} while (FindNextFile(hFind, &finddata));
		FindClose(hFind);
	}

	// Now call this function recursively, with each of the subdirectories.

	strSearch = strDirectory + CString(_T("*"));
	hFind = FindFirstFile(strSearch, &finddata);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				if (::_tcscmp(finddata.cFileName, _T(".")) != 0 && ::_tcscmp(finddata.cFileName, _T("..")) != 0)
					DirectorySearch(strSpec, strDirectory + CString(finddata.cFileName), results);
		} while (FindNextFile(hFind, &finddata));
		FindClose(hFind);
	}
}

//---------------------------------------------------------------------------
// This function gets the directory in which to put exploded CAB files.
// This will be the same directory each time, so this function will create
// the directory (if necessary) and delete any files in the directory.
//---------------------------------------------------------------------------

BOOL GetCABExplodeDir(CString &destination, BOOL fDeleteFiles, const CString & strDontDelete)
{
	CString strMSInfoDir, strExplodeTo, strSubDirName;

	// Determine the temporary path and add on a subdir name.

	TCHAR szTempDir[MAX_PATH];

	if (::GetTempPath(MAX_PATH, szTempDir) > MAX_PATH)
	{
		destination = _T("");
		return FALSE;
	}

	strSubDirName.LoadString(IDS_CAB_DIR_NAME);
	strExplodeTo = szTempDir;
	if (strExplodeTo.Right(1) == CString(cszDirSeparator))
		strExplodeTo = strExplodeTo + strSubDirName;
	else
		strExplodeTo = strExplodeTo + CString(cszDirSeparator) + strSubDirName;

	// Kill the directory if it already exists.

	if (fDeleteFiles)
		KillDirectory(strExplodeTo, strDontDelete);

	// Create the subdirectory.

	if (!CreateDirectoryEx(szTempDir, strExplodeTo, NULL))
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
//			MSIError(IDS_GENERAL_ERROR, "couldn't create the target directory");
			destination = "";
			return FALSE;
		}
	}

	destination = strExplodeTo;
	return TRUE;
}

//---------------------------------------------------------------------------
// This functions kills a directory by recursively deleting files and
// subdirectories.
//---------------------------------------------------------------------------

void KillDirectory(const CString & strDir, const CString & strDontDelete)
{
	CString				strDirectory = strDir;

	if (strDirectory.Right(1) == CString(cszDirSeparator))
		strDirectory = strDirectory.Left(strDirectory.GetLength() - 1);

	// Delete any files in directory.

	CString				strFilesToDelete = strDirectory + CString(_T("\\*.*"));
	CString				strDeleteFile;
	WIN32_FIND_DATA		filedata;
	BOOL				bFound = TRUE;

	HANDLE hFindFile = FindFirstFile(strFilesToDelete, &filedata);
	while (hFindFile != INVALID_HANDLE_VALUE && bFound)
	{
		if ((filedata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0L)
		{
			strDeleteFile = strDirectory + CString(cszDirSeparator) + filedata.cFileName;
			
			if (strDontDelete.CompareNoCase(strDeleteFile) != 0)
			{
				::SetFileAttributes(strDeleteFile, FILE_ATTRIBUTE_NORMAL);
				::DeleteFile(strDeleteFile);
			}
		}
		
		bFound = FindNextFile(hFindFile, &filedata);
	}
	FindClose(hFindFile);

	// Now call this function on any subdirectories in this directory.

	CString strSearch = strDirectory + CString(_T("\\*"));
	hFindFile = FindFirstFile(strSearch, &filedata);
	if (hFindFile != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (filedata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				if (::_tcscmp(filedata.cFileName, _T(".")) != 0 && ::_tcscmp(filedata.cFileName, _T("..")) != 0)
					KillDirectory(strDirectory + CString(cszDirSeparator) + CString(filedata.cFileName));
		} while (FindNextFile(hFindFile, &filedata));
		FindClose(hFindFile);
	}

	// Finally, remove this directory.

	::RemoveDirectory(strDirectory);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\cabfunc.h ===
static char dest_dir[MAX_PATH];

//Functions to open CAB files
BOOL IsDataspecFilePresent(CString strCabExplodedDir);
BOOL IsIncidentXMLFilePresent(CString strCabExplodedDir, CString strIncidentFileName);
void DirectorySearch(const CString & strSpec, const CString & strDir, CStringList &results);
BOOL GetCABExplodeDir(CString &destination, BOOL fDeleteFiles = TRUE, const CString & strDontDelete = CString(""));
BOOL OpenCABFile(const CString &filename, const CString &destination);
BOOL FindFileToOpen(const CString & destination, CString & filename);
void KillDirectory(const CString & strDir, const CString & strDontDelete = CString(""));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\chkdev.cpp ===
#include "stdafx.h"
#include <chkdev.h>

BOOL testCatAPIs(LPWSTR lpwzCatName, HCATADMIN hCatAdmin, HCATINFO hCatInfo);

HCATADMIN hCatAdmin = 0;         
extern Classes_Provided	eClasses;

#define NumberTestCerts 7
BYTE TestCertHashes[NumberTestCerts][20] = 
{ 
   {0xBB, 0x11, 0x81, 0xF2, 0xB0, 0xC5, 0xE3, 0x2F, 0x7F, 0x2D, 0x62, 0x3B, 0x9C, 0x87, 0xE8, 0x55, 0x26, 0xF9, 0xCF, 0x2F},
   {0xBA, 0x9E, 0x3C, 0x32, 0x56, 0x2A, 0x67, 0x12, 0x8C, 0xAA, 0xBD, 0x4A, 0xB0, 0xC5, 0x00, 0xBE, 0xE1, 0xD0, 0xC2, 0x56},
   {0xA4, 0x34, 0x89, 0x15, 0x9A, 0x52, 0x0F, 0x0D, 0x93, 0xD0, 0x32, 0xCC, 0xAF, 0x37, 0xE7, 0xFE, 0x20, 0xA8, 0xB4, 0x19},
   {0x73, 0xA9, 0x01, 0x93, 0x83, 0x4C, 0x5B, 0x16, 0xB4, 0x3F, 0x0C, 0xE0, 0x5E, 0xB4, 0xA3, 0xEF, 0x6F, 0x2C, 0x08, 0x2F},
   {0xD2, 0xC3, 0x78, 0xCE, 0x42, 0xBC, 0x93, 0xA0, 0x3D, 0xD5, 0xA4, 0x2E, 0x8E, 0x08, 0xB1, 0x71, 0xB6, 0x27, 0x90, 0x1D},
   {0xFC, 0x94, 0x4A, 0x1F, 0xA0, 0xDC, 0x8A, 0xC7, 0x78, 0x4A, 0xAC, 0x36, 0x9D, 0x14, 0x46, 0x02, 0x24, 0x08, 0xFF, 0x5D},
   {0x92, 0x6A, 0xF1, 0x27, 0x25, 0x37, 0xE0, 0x73, 0x32, 0x6F, 0x12, 0xF7, 0xA7, 0x11, 0xE7, 0x55, 0xE6, 0x4E, 0x78, 0x4C}
};

CheckDevice::CheckDevice()
{
   m_FileList = NULL;
   lpszServiceName = NULL;
   lpszServiceImage = NULL;
   m_hDevInfo = SetupDiCreateDeviceInfoListEx(NULL, NULL, NULL, NULL);
}

CheckDevice::~CheckDevice(void)
{
   if ( m_FileList )
   {
      delete m_FileList;
   }
   if ( lpszServiceName )
   {
      delete [] lpszServiceName;
      lpszServiceName = NULL;
   }
   if ( lpszServiceImage )
   {
      delete [] lpszServiceImage;
      lpszServiceImage = NULL;
   }
   m_FileList = NULL;
   if (m_hDevInfo)
   {
		SetupDiDestroyDeviceInfoList(m_hDevInfo);
		m_hDevInfo = NULL;
   }



}

CheckDevice::CheckDevice(DEVNODE hDevice, DEVNODE hParent) : InfnodeClass (hDevice, hParent)
{
   m_FileList = NULL;
   lpszServiceName = NULL;
   lpszServiceImage = NULL;

   m_hDevInfo = SetupDiCreateDeviceInfoListEx(NULL, NULL, NULL, NULL);
   
   if(eClasses == Class_Win32_PnPSignedDriverCIMDataFile)
		CreateFileNode();
}

BOOL CheckDevice::AddFileNode(TCHAR *szFileName , UINT uiWin32Error /*= 0 */, LPCTSTR szSigner /*= NULL*/)
{
   FileNode *pThisFile;
   

   if ( !szFileName || !strlen(szFileName) )
   {
      return(FALSE);
   }

   _strlwr(szFileName);

   // need to check that this file exists, if it doesn't, need to munge it so that it does
   HANDLE hFile;
   CString strMungedName;
   TCHAR *pStrPos;
   hFile =  CreateFile(szFileName, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);

   if (BADHANDLE(hFile))
   {
       // file does not exist, need to search for it
       if (pStrPos = strstr(szFileName, _T("\\system\\")))
       {
           // this may have been placed in the system32 dir instead
           *pStrPos = '\0';
           pStrPos++;
           pStrPos = strchr(pStrPos, '\\');
		   if (!pStrPos)
			   return FALSE;
		   strMungedName.Format(_T("%s\\system32%s"), szFileName, pStrPos);
           hFile =  CreateFile(strMungedName, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);
           if (BADHANDLE(hFile))
           {
               return FALSE;
           }                
       }
       else if (pStrPos = strstr(szFileName, _T(".inf")))
       {
           // might be that an inf got caught in the other directory
           pStrPos = _tcsrchr(szFileName, '\\');
		   //a-kjaw. to fix prefix bug# 259380.
		   if(NULL == pStrPos)
			   return FALSE;

           *pStrPos = '\0';
           pStrPos++;
		   strMungedName.Format(_T("%s\\other\\%s"),szFileName,  pStrPos);
           hFile =  CreateFile(strMungedName, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);
           if (BADHANDLE(hFile))
           {
               return FALSE;
           } 
       }
       else
           return FALSE;

   }
   
   CloseHandle(hFile);
      




   // first scan the file list for duplicates
   pThisFile = m_FileList;
   while ( pThisFile )
   {
      if ( !strcmp(pThisFile->FilePath(), szFileName) )
      {
         return(TRUE); // no copy, no add
      }
      pThisFile = pThisFile->pNext;
   }
   pThisFile = NULL;

   pThisFile = new FileNode;
   if ( !pThisFile )
   {
      return(FALSE);
   }

   pThisFile->pDevnode = this;

   pThisFile->lpszFilePath = new TCHAR[strlen(szFileName) + 1];
   if ( !pThisFile->lpszFilePath )
   {
      delete pThisFile;
      return(FALSE);
   }

   pThisFile->lpszFilePath = szFileName;

   // copyed the data

   pThisFile->lpszFileName = _tcsrchr(pThisFile->lpszFilePath, '\\');
   pThisFile->lpszFileName++;

   pThisFile->lpszFileExt  = _tcsrchr(pThisFile->lpszFilePath, '.');
   pThisFile->lpszFileExt++;

   // get the version information
   //pThisFile->GetFileInformation();

   	if(uiWin32Error == NO_ERROR)
		pThisFile->bSigned = TRUE;
	else
		pThisFile->bSigned = FALSE;

	if(szSigner != NULL)
	{
		pThisFile->lpszSignedBy =  szSigner;
	}		
	//else
	//	pThisFile->bSigned = FALSE;

   // now perform the LL patch
   pThisFile->pNext = m_FileList;
   m_FileList = pThisFile;
   return(TRUE);
}

BOOL CheckDevice::GetServiceNameAndDriver(void)
{
   /**********
    Get service Name
***********/
   ULONG ulSize;
   CONFIGRET retval;

   ulSize = 0;
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_SERVICE,
                                              NULL,
                                              NULL,
                                              &ulSize,
                                              0);

   if ( retval )
      if ( (retval == CR_BUFFER_SMALL) )
      {
         if ( !ulSize )
            ulSize = 511;
      }
      else
         return(retval);

   lpszServiceName = new TCHAR [ulSize+1];
   if ( !lpszServiceName ) return(CR_OUT_OF_MEMORY);
   ZeroMemory(lpszServiceName,sizeof(lpszServiceName));
   //Now get value
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_SERVICE,
                                              NULL,
                                              lpszServiceName,
                                              &ulSize,
                                              0);
   if ( retval )
      return(retval);

   CString strKeyName;
   TCHAR KeyValue[BUFFSIZE];
   HKEY SrvcKey;

   strKeyName.Format(_T("SYSTEM\\CurrentControlSet\\Services\\%s"), lpszServiceName);

   if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     strKeyName,
                     0,
                     KEY_READ,
                     &SrvcKey) != ERROR_SUCCESS )
      return(FALSE);

   if ( RegQueryValueEx(SrvcKey,
                        _T("ImagePath"),
                        0,
                        NULL,
                        NULL,
                        &ulSize) != ERROR_SUCCESS )
   {
      RegCloseKey(SrvcKey);
      return(FALSE);
   }
   if (ulSize > BUFFSIZE)
   {
      RegCloseKey(SrvcKey);
      return(FALSE);
   }
   if ( RegQueryValueEx(SrvcKey,
                        _T("ImagePath"),
                        0,
                        NULL,
                        (PBYTE)KeyValue,
                        &ulSize) != ERROR_SUCCESS )
   {
      RegCloseKey(SrvcKey);
      return(FALSE);
   }
   else
   {
      // sometimes the service path is assumed 
      // z.b. system32\foo
      // or %system32%\foo
      if ( !_tcsncmp(KeyValue, _T("System32\\"), _tcslen(_T("System32\\"))) )
      {
		 strKeyName.Format(_T("%%WINDIR%%\\%s"), KeyValue);
         ExpandEnvironmentStrings(strKeyName, KeyValue, BUFFSIZE);
         lpszServiceImage = new TCHAR[strlen(KeyValue) + 1];
         if ( lpszServiceImage )
            strncpy(lpszServiceImage, KeyValue,sizeof(lpszServiceImage)/sizeof(TCHAR));
      }
   }



   // should be everything
   RegCloseKey(SrvcKey);
   return(TRUE);

}

BOOL CheckDevice::CreateFileNode(void)
{

   // also going to add the inf as a file
   TCHAR infname[512];
   ZeroMemory(infname,sizeof(infname));
   //TCHAR tempname[512];
   CString strtempname;

   if ( InfName() )
   {
      // BUGBUG is this correct, or in some subdir??
	   strtempname.Format(_T("%%WINDIR%%\\inf\\%s"), InfName());

      DWORD dwStatus = ExpandEnvironmentStrings(strtempname, infname, 512);
	  //check to makesure we get a valid name back
	  if (0 == dwStatus || dwStatus > 512)
	  {
		return FALSE;
	  }
      AddFileNode(infname);
   }
   else
      return(FALSE);

   if ( GetServiceNameAndDriver() && lpszServiceImage)
      AddFileNode(lpszServiceImage);   

   //CreateFileNode_Class();
   CreateFileNode_Driver();

   return(TRUE);


}
BOOL CheckDevice::CreateFileNode_Class(void)
{
   SP_DEVINSTALL_PARAMS DevInstallParams, DevTemp;
   SP_DEVINFO_DATA DevInfoData;
   SP_DRVINFO_DATA DrvInfoData;
   DWORD dwScanResult;
   HDEVINFO hDevInfo;
   HSPFILEQ hFileQueue;
   BOOL bProceed = TRUE;


   // Reset all structures to empty
   memset(&DevInstallParams, 0, sizeof(DevInstallParams));
   memset(&DevInfoData, 0, sizeof(DevInfoData));
   memset(&DrvInfoData, 0, sizeof(DrvInfoData));
   memset(&DevTemp, 0, sizeof(DevInstallParams));

   DrvInfoData.cbSize = sizeof(DrvInfoData);
   DevInfoData.cbSize = sizeof(DevInfoData);
   DevInstallParams.cbSize = sizeof(DevInstallParams);

   hFileQueue = SetupOpenFileQueue();

   // We need to build a driver node for the devnode
   hDevInfo = m_hDevInfo;
   if ( INVALID_HANDLE_VALUE == hDevInfo )
      return(0);

   DevInfoData.Reserved = 0;
   if ( !SetupDiOpenDeviceInfo(hDevInfo, DeviceID(), NULL, NULL , &DevInfoData) )
   {
      SetupDiDestroyDeviceInfoList(hDevInfo);
      return(FALSE);
   }
/*
   if (SetupDiGetDeviceInstallParams(hDevInfo,
                                          &DevInfoData,
                                          &DevInstallParams
                                          )) 
   {
            
            DevInstallParams.FlagsEx = (DI_FLAGSEX_INSTALLEDDRIVER |
                                           DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

            SetupDiSetDeviceInstallParams(hDevInfo,
                                              &DevInfoData,
                                              &DevInstallParams
                                              );
   }
*/

   if ( !SetupDiBuildDriverInfoList(hDevInfo, &DevInfoData, SPDIT_CLASSDRIVER) )
   {
      SetupDiDestroyDeviceInfoList(hDevInfo);
      return(FALSE);
   }

    // select a driver
   if ( DeviceName() )
      strncpy(DrvInfoData.Description, DeviceName(),LINE_LEN);
   if ( MFG() )
      strncpy(DrvInfoData.MfgName, MFG(),LINE_LEN);
   if ( InfProvider() )
      strncpy(DrvInfoData.ProviderName, InfProvider(),LINE_LEN);
   
   DrvInfoData.DriverType = SPDIT_CLASSDRIVER;
   if ( !SetupDiSetSelectedDriver(hDevInfo,
                                  &DevInfoData,
                                  &DrvInfoData) )
   {
      //BUGBUG put goo here
      DWORD err = GetLastError();  
      return(FALSE);

   }

   if ( SetupDiGetDeviceInstallParams(hDevInfo, &DevInfoData, &DevInstallParams) )
   {
      //memcpy(&DevTemp, &DevInfoData, sizeof(DevInfoData));
	   memcpy(&DevTemp, &DevInfoData, sizeof(DevTemp));
   }

   DevInstallParams.FileQueue = hFileQueue;
   DevInstallParams.Flags |= (DI_NOVCP | DI_ENUMSINGLEINF | DI_DONOTCALLCONFIGMG | DI_NOFILECOPY | DI_NOWRITE_IDS) ;
   DevInstallParams.Flags &= ~(DI_NODI_DEFAULTACTION);
   DevInstallParams.FlagsEx |= DI_FLAGSEX_NO_DRVREG_MODIFY;
   DevInstallParams.InstallMsgHandler = ScanQueueCallback;
   DevInstallParams.InstallMsgHandlerContext = this;
   strncpy(DevInstallParams.DriverPath, InfName(),MAX_PATH);


   SetLastError(0);
   SetupDiSetDeviceInstallParams(hDevInfo, &DevInfoData, &DevInstallParams);

   if ( !SetupDiCallClassInstaller(DIF_INSTALLCLASSDRIVERS, hDevInfo, &DevInfoData) )
   {
      DWORD err = GetLastError();

   }

   SetupScanFileQueue(hFileQueue, 
                      SPQ_SCAN_USE_CALLBACKEX,
                      NULL,
                      ScanQueueCallback,
                      this,
                      &dwScanResult);


   if ( DevTemp.cbSize )
   {
      SetupDiSetDeviceInstallParams(hDevInfo, &DevInfoData, &DevTemp);
   }

   return(FALSE);
   
}
BOOL CheckDevice::CreateFileNode_Driver(void)
{
   SP_DEVINSTALL_PARAMS DevInstallParams, DevTemp;
   SP_DEVINFO_DATA DevInfoData;
   SP_DRVINFO_DATA DrvInfoData;
   DWORD dwScanResult;
   HDEVINFO hDevInfo;
   HSPFILEQ hFileQueue;
   BOOL bProceed = TRUE;


   // Reset all structures to empty
   memset(&DevInstallParams, 0, sizeof(DevInstallParams));
   memset(&DevInfoData, 0, sizeof(DevInfoData));
   memset(&DrvInfoData, 0, sizeof(DrvInfoData));
   memset(&DevTemp, 0, sizeof(DevInstallParams));

   DrvInfoData.cbSize = sizeof(DrvInfoData);
   DevInfoData.cbSize = sizeof(DevInfoData);
   DevInstallParams.cbSize = sizeof(DevInstallParams);

   hFileQueue = SetupOpenFileQueue();//and where does SetupCloseFileQueue get called?

   // We need to build a driver node for the devnode
   hDevInfo = m_hDevInfo;
   if ( INVALID_HANDLE_VALUE == hDevInfo )
      return(0);

   DevInfoData.Reserved = 0;
   if ( !SetupDiOpenDeviceInfo(hDevInfo, DeviceID(), NULL, NULL , &DevInfoData) )
   {
      SetupDiDestroyDeviceInfoList(hDevInfo);
      return(FALSE);
   }

   if ( !SetupDiBuildDriverInfoList(hDevInfo, &DevInfoData, SPDIT_COMPATDRIVER) )
   {
      SetupDiDestroyDeviceInfoList(hDevInfo);
      return(FALSE);
   }

   // select a driver
   if ( DeviceName() )
      strncpy(DrvInfoData.Description, DeviceName(),LINE_LEN);
   if ( MFG() )
      strncpy(DrvInfoData.MfgName, MFG(),LINE_LEN);
   if ( InfProvider() )
      strncpy(DrvInfoData.ProviderName, InfProvider(),LINE_LEN);

   
   DrvInfoData.DriverType = SPDIT_COMPATDRIVER;
   if ( !SetupDiSetSelectedDriver(hDevInfo,
                                  &DevInfoData,
                                  &DrvInfoData) )
   {
      DWORD err = GetLastError();
      return(FALSE);

   }

   if ( SetupDiGetDeviceInstallParams(hDevInfo, &DevInfoData, &DevInstallParams) )
   {
      memcpy(&DevTemp, &DevInfoData, sizeof(DevInfoData));
   }

   DevInstallParams.FileQueue = hFileQueue;
   DevInstallParams.Flags |= (DI_NOVCP /*| DI_ENUMSINGLEINF | DI_DONOTCALLCONFIGMG | DI_NOFILECOPY | DI_NOWRITE_IDS*/) ;
   //DevInstallParams.Flags &= ~(DI_NODI_DEFAULTACTION);
   //DevInstallParams.FlagsEx |= DI_FLAGSEX_NO_DRVREG_MODIFY;
   //DevInstallParams.InstallMsgHandler = ScanQueueCallback;
   //DevInstallParams.InstallMsgHandlerContext = this;
   strncpy(DevInstallParams.DriverPath, InfName(),MAX_PATH);


   SetLastError(0);
   SetupDiSetDeviceInstallParams(hDevInfo, &DevInfoData, &DevInstallParams);

   if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, hDevInfo, &DevInfoData) )
   {
      DWORD err = GetLastError();
   }

   SetupScanFileQueue(hFileQueue, 
                      SPQ_SCAN_USE_CALLBACKEX,
                      NULL,
                      ScanQueueCallback,
                      this,
                      &dwScanResult);


   if ( DevTemp.cbSize )
   {
      SetupDiSetDeviceInstallParams(hDevInfo, &DevInfoData, &DevTemp);
   }
	SetupDiDestroyDeviceInfoList(hDevInfo);
	SetupCloseFileQueue(hFileQueue);
   return(FALSE);
}




FileNode * CheckDevice::GetFileList(void)
{
   return(m_FileList);
}


FileNode::FileNode()
{
   lpszFileName = NULL;
   lpszFileExt = NULL; 
   baHashValue = NULL;
   dwHashSize = 0;
   pNext  = NULL;
   FileSize = 0;
   lpszCatalogPath = NULL;
   m_pCatAttrib = NULL;
   bSigned = FALSE;
}

FileNode::~FileNode()
{
   /*if ( lpszFilePath )
   {
      delete [] lpszFilePath;
   }*/
   lpszFileName = NULL;
   lpszFileExt = NULL;

   if ( baHashValue )
   {
      delete [] baHashValue;
   }
   baHashValue = NULL;
   dwHashSize = 0;

   if ( lpszCatalogPath )
   {
      delete lpszCatalogPath;
   }
   lpszCatalogPath = NULL;

   if ( pNext )
   {
      delete pNext;
   }
   pNext = NULL;

   if ( m_pCatAttrib )
   {
      delete m_pCatAttrib;
   }
   m_pCatAttrib = NULL;
}

BOOL FileNode::GetFileInformation(void)
{
   UINT            dwSize;
   DWORD           dwHandle;
   BYTE             *pBuf;
   VS_FIXEDFILEINFO *lpVerData;
   HANDLE         hFile;
   BY_HANDLE_FILE_INFORMATION FileInfo;


   // get version of the file
   dwSize = GetFileVersionInfoSize((LPTSTR)(LPCTSTR) lpszFilePath, &dwHandle);
   pBuf = new BYTE[dwSize];

   if ( GetFileVersionInfo((LPTSTR)(LPCTSTR) lpszFilePath, dwHandle, dwSize, pBuf) )
   {
      if ( VerQueryValue(pBuf, _T("\\"), (void **)&lpVerData, &dwSize) )
      {
         Version.dwProductVersionLS = lpVerData->dwProductVersionLS;
         Version.dwProductVersionMS = lpVerData->dwProductVersionMS;
         Version.dwFileVersionLS = lpVerData->dwFileVersionLS;
         Version.dwFileVersionMS = lpVerData->dwFileVersionMS;

         // while we're here get the file time as well)
         TimeStamp.dwLowDateTime = lpVerData->dwFileDateLS;
         TimeStamp.dwHighDateTime = lpVerData->dwFileDateMS;
      }
   }
   delete [] pBuf;

   // get file hash
   if ( BADHANDLE(hCatAdmin) )
   {
      CryptCATAdminAcquireContext(&hCatAdmin, NULL, 0);
   }

   hFile = CreateFile(lpszFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, NULL);

   // BUGBUG: on for win9x inf.s, they might be in the inf\other directory
   // BUGBUG: for whatever reason, sometimes setupapi will give c:\windows\system\driver dir, and not the sytem32\drivers

   if ( BADHANDLE(hFile) )
   {
	   int foo = GetLastError();
      return(FALSE);
   }

   if ( CryptCATAdminCalcHashFromFileHandle(hFile, &dwHashSize, NULL, 0) )
   {
      baHashValue = new BYTE[dwHashSize];
      ZeroMemory(baHashValue, dwHashSize);
      CryptCATAdminCalcHashFromFileHandle(hFile, &dwHashSize, baHashValue, 0);
   }
   else
   {
	   baHashValue = 0;
   }


   // get file size
   FileSize = GetFileSize(hFile, NULL);


   // get time stamp
   if ( GetFileInformationByHandle(hFile, &FileInfo) )
   {
      TimeStamp = FileInfo.ftCreationTime;
   }

   CloseHandle(hFile);


   return(TRUE);
}

BOOL FileNode::VerifyFile(void)
{
   USES_CONVERSION;  
   BOOL                  bRet;
   HCATINFO              hCatInfo              = NULL;
   HCATINFO              PrevCat;
   WINTRUST_DATA         WinTrustData;
   WINTRUST_CATALOG_INFO WinTrustCatalogInfo;
   DRIVER_VER_INFO       VerInfo;
   GUID                  gSubSystemDriver      = DRIVER_ACTION_VERIFY;
   //GUID                  gSubSystemDriver      = WINTRUST_ACTION_GENERIC_VERIFY_V2;
   HRESULT               hRes = E_FAIL;
   CATALOG_INFO          CatInfo;
   LPTSTR                lpFilePart;
   WCHAR                 UnicodeKey[MAX_PATH];
   TCHAR                 szBuffer[MAX_PATH];


   // make sure that we can find the file
   if ( !baHashValue || !dwHashSize || !FileSize )
   {
      // seems that there is no file to check, or couldn't find it
      return(FALSE);
   }


   //
   // Need to lower case file tag for old-style catalog files
   //
   lstrcpyn(szBuffer, lpszFilePath,MAX_PATH);
   CharLowerBuff(szBuffer, lstrlen(szBuffer));
   #ifdef _UNICODE
     CopyMemory(UnicodeKey, szBuffer, MAX_PATH * sizeof(WCHAR));
   #else
     MultiByteToWideChar(CP_ACP, 0, szBuffer, -1, UnicodeKey, MAX_PATH);   
   #endif
   
   ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
   VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);



   //
   // Now we have the file's hash.  Initialize the structures that
   // will be used later on in calls to WinVerifyTrust.
   //
   ZeroMemory(&WinTrustData,                   sizeof(WINTRUST_DATA));
   WinTrustData.cbStruct                     = sizeof(WINTRUST_DATA);
   WinTrustData.dwUIChoice                   = WTD_UI_NONE;
   WinTrustData.fdwRevocationChecks          = WTD_REVOKE_NONE;
   WinTrustData.dwUnionChoice                = WTD_CHOICE_CATALOG;
   WinTrustData.dwStateAction                = WTD_STATEACTION_VERIFY;
   WinTrustData.pPolicyCallbackData          = (LPVOID)&VerInfo;
   WinTrustData.dwProvFlags                  = WTD_REVOCATION_CHECK_NONE;
   WinTrustData.pCatalog                     = &WinTrustCatalogInfo;

   ZeroMemory(&WinTrustCatalogInfo,            sizeof(WINTRUST_CATALOG_INFO));
   WinTrustCatalogInfo.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);
   WinTrustCatalogInfo.pbCalculatedFileHash  = baHashValue;
   WinTrustCatalogInfo.cbCalculatedFileHash  = dwHashSize;
   WinTrustCatalogInfo.pcwszMemberTag        = UnicodeKey;
   WinTrustCatalogInfo.pcwszMemberFilePath   = UnicodeKey;

   //
   // Now we try to find the file hash in the catalog list, via CryptCATAdminEnumCatalogFromHash
   //
   PrevCat = NULL;
   hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, baHashValue, dwHashSize, 0, &PrevCat);

   //
   // We want to cycle through the matching catalogs until we find one that matches both hash and member tag
   //
   bRet = FALSE;
   while ( hCatInfo && !bRet )
   {
	  hRes = E_FAIL;
      ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
      CatInfo.cbStruct = sizeof(CATALOG_INFO);
      if ( CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0) )
      {
         WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

         // Now verify that the file is an actual member of the catalog.
         hRes = WinVerifyTrust(NULL, &gSubSystemDriver, &WinTrustData);
         if ( hRes == ERROR_SUCCESS )
         {
            #ifdef _UNICODE
              CopyMemory(szBuffer, CatInfo.wszCatalogFile, MAX_PATH * sizeof(TCHAR));
            #else
              WideCharToMultiByte(CP_ACP, 0, CatInfo.wszCatalogFile, -1, szBuffer, MAX_PATH, NULL, NULL);
            #endif
            
             
			 //Commented because of some weird prob!! 
			 //GetFullPathName(szBuffer, MAX_PATH, szBuffer, &lpFilePart);

			CString strCatalogPath(szBuffer);
			//strCatalogPath = strCatalogPath.Right(strCatalogPath.GetLength() - strCatalogPath.ReverseFind(_T('\\')));
			strCatalogPath =  _tcsrchr(lpszCatalogPath, '\\');
			lpszCatalogName = strCatalogPath;


            bRet = TRUE;

            if ( VerInfo.pcSignerCertContext != NULL )
            {
               CertFreeCertificateContext(VerInfo.pcSignerCertContext);
               VerInfo.pcSignerCertContext = NULL;
            }

            // file is signed, so need to walk the cert chain to see who signed it
            bSigned = WalkCertChain(WinTrustData.hWVTStateData);
			CloseHandle(WinTrustData.hWVTStateData);

         }
      }

      if ( !bRet )
      {
         // The hash was in this catalog, but the file wasn't a member... so off to the next catalog
         PrevCat = hCatInfo;
         hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, baHashValue, dwHashSize, 0, &PrevCat);
      }
   }

   if ( !hCatInfo )
   {
      //
      // If it wasn't found in the catalogs, check if the file is individually signed.
      //
      bRet = VerifyIsFileSigned((LPTSTR)(LPCTSTR) lpszFilePath, (PDRIVER_VER_INFO) &VerInfo);
      if ( bRet )
      {
         // If so, mark the file as being signed.
         bSigned = TRUE;
      }
   }
   else
   {
      GetCatalogInfo(CatInfo.wszCatalogFile, hCatAdmin, hCatInfo); 
      // The file was verified in the catalogs, so mark it as signed and free the catalog context.
      CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
   }

   if ( hRes == ERROR_SUCCESS )
   {
      #ifdef _UNICODE
        CopyMemory(szBuffer, VerInfo.wszSignedBy, MAX_PATH * sizeof(TCHAR));
      #else
        WideCharToMultiByte(CP_ACP, 0, VerInfo.wszSignedBy, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
      #endif 
	  lpszSignedBy = szBuffer;	

   }

   //
   // close wintrust state
   //
   WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;
   WinVerifyTrust(NULL,
                  &gSubSystemDriver,
                  &WinTrustData);


   return(bSigned);
}



/*************************************************************************
*   Function : VerifyIsFileSigned
*   Purpose : Calls WinVerifyTrust with Policy Provider GUID to
*   verify if an individual file is signed.
**************************************************************************/
BOOL FileNode::VerifyIsFileSigned(LPTSTR pcszMatchFile, PDRIVER_VER_INFO lpVerInfo)
{
   USES_CONVERSION;  
   INT                 iRet;
   HRESULT             hRes;
   WINTRUST_DATA       WinTrustData;
   WINTRUST_FILE_INFO  WinTrustFile;
   GUID                gOSVerCheck = DRIVER_ACTION_VERIFY;
   GUID                gPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;
   WCHAR               wszFileName[MAX_PATH];


   ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
   WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
   WinTrustData.dwUIChoice = WTD_UI_NONE;
   WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
   WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
   WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
   WinTrustData.pFile = &WinTrustFile;
   WinTrustData.pPolicyCallbackData = (LPVOID)lpVerInfo;

   ZeroMemory(lpVerInfo, sizeof(DRIVER_VER_INFO));
   lpVerInfo->cbStruct = sizeof(DRIVER_VER_INFO);

   ZeroMemory(&WinTrustFile, sizeof(WINTRUST_FILE_INFO));
   WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);

   
   #ifdef _UNICODE
     CopyMemory(wszFileName, pcszMatchFile, MAX_PATH * sizeof(WCHAR));
   #else
     iRet = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcszMatchFile, -1, (LPWSTR)&wszFileName, wcslen(wszFileName));
   #endif
   
   WinTrustFile.pcwszFilePath = wszFileName;

   hRes = WinVerifyTrust((HWND__ *)INVALID_HANDLE_VALUE, &gOSVerCheck, &WinTrustData);
   if ( hRes != ERROR_SUCCESS )
      hRes = WinVerifyTrust((HWND__ *)INVALID_HANDLE_VALUE, &gPublishedSoftware, &WinTrustData);

   return(hRes == ERROR_SUCCESS);
}



LogoFileVersion::LogoFileVersion()
{
   dwProductVersionLS   = 0;
   dwProductVersionMS   = 0;
   dwFileVersionLS      = 0;
   dwFileVersionMS      = 0;  
}

CatalogAttribute::CatalogAttribute()
{
   Attrib = NULL;
   Value = NULL;
   pNext = NULL;
}

CatalogAttribute::~CatalogAttribute()
{
   if ( Attrib ) delete [] Attrib;
   if ( Value )  delete [] Value;
   if ( pNext )  delete pNext;

   Attrib = NULL;
   Value = NULL;
   pNext = NULL;

}



// Function: ScanQueueCallback
// Parameters:
//	pvContext:	Pointer to a context that contains any data needed
//	Notify:		The type of message received
//	Param1:		The pointer to the string containing the filename
//	Param2:		Not used
// Purpose: This function gets called when you tell the setup environment to scan
//			through the file queue.  Basically it receives the filenames and copies
//			them into a string.
// Returns:	NO_ERROR if nothing went wrong and ERROR_NOT_ENOUGH_MEMORY if their is no
//			free memory
UINT __stdcall ScanQueueCallback(PVOID pvContext, UINT Notify, UINT_PTR Param1, UINT_PTR Param2)
{
   CheckDevice *pDevice = (CheckDevice *)pvContext;
   PFILEPATHS pfilepaths;

   if ( (SPFILENOTIFY_QUEUESCAN == Notify) && Param1 )
   {
      pDevice->AddFileNode((TCHAR *)Param1);
   }

   if ( (SPFILENOTIFY_QUEUESCAN_EX == Notify) && Param1 )
   {
	  pfilepaths = (PFILEPATHS)Param1;
	  ////////////////Put Signer in the 3rd param whenever its available!
	  pDevice->AddFileNode((LPTSTR)pfilepaths->Target , pfilepaths->Win32Error , /*pfilepaths->csSigner*/ NULL);
  
   }

   return(NO_ERROR);
}

BOOL FileNode::GetCatalogInfo(LPWSTR lpwzCatName, HCATADMIN hCatAdmin, HCATINFO hCatInfo)
{
   USES_CONVERSION;
   HANDLE hCat;
   CRYPTCATATTRIBUTE *pCatAttrib;
   TCHAR szBuffer[512];
   CRYPTCATMEMBER *pMember = NULL;
   PSIP_INDIRECT_DATA pSipData;
   CatalogAttribute *CatAttribute;

   hCat = CryptCATOpen(lpwzCatName, CRYPTCAT_OPEN_EXISTING, NULL, 0, 0);

   if ( BADHANDLE(hCat) )
   {
      return(FALSE);
   }

   pCatAttrib = NULL;

   while ( pCatAttrib = CryptCATEnumerateCatAttr(hCat, pCatAttrib) )
   {
      if ( pCatAttrib->dwAttrTypeAndAction | CRYPTCAT_ATTR_NAMEASCII )
      {
         #ifdef _UNICODE
           CopyMemory(szBuffer, pCatAttrib->pwszReferenceTag, 511 * sizeof(TCHAR));
         #else
           WideCharToMultiByte(CP_ACP, 0, pCatAttrib->pwszReferenceTag, -1, szBuffer, 511, NULL, NULL);
         #endif  
        
         CatAttribute = new CatalogAttribute;

         if ( !CatAttribute )
         {
            return(FALSE);
         }

         CatAttribute->Attrib = new TCHAR[strlen(szBuffer) +1];
         if ( !CatAttribute->Attrib )
         {
            delete CatAttribute;
            return(FALSE);
         }
         _tcscpy(CatAttribute->Attrib, szBuffer);

         #ifdef _UNICODE
           CopyMemory(szBuffer, (PUSHORT)pCatAttrib->pbValue, 511 * sizeof(TCHAR));
         #else
           WideCharToMultiByte(CP_ACP, 0, (PUSHORT)pCatAttrib->pbValue, -1, szBuffer, 511, NULL, NULL);
         #endif  
         
         CatAttribute->Value = new TCHAR[strlen(szBuffer) + 1];
         if ( !CatAttribute->Value )
         {
            delete CatAttribute;
            return(FALSE);
         }

         _tcscpy(CatAttribute->Value, szBuffer);

         // add to node
         CatAttribute->pNext = (void *)m_pCatAttrib;
         m_pCatAttrib = CatAttribute;
      }

   }

   while ( pMember = CryptCATEnumerateMember(hCat, pMember) )
   {
      pSipData = pMember->pIndirectData;

   }



   CryptCATClose(hCat);


   return(TRUE); 
}

BOOL CheckFile (TCHAR *szFileName)
{
	FileNode *pThisFile = NULL;
	BOOL bRet = FALSE;	// v-jammar; fix prefix bug 427999
	
	try  //v-stlowe: 3/20/2001: to fix prefix bug where memory was leaking on out-of-mem throw
	{
		pThisFile = new FileNode;
   
		if ( !pThisFile )
		{
		  return(FALSE);
		}

	   pThisFile->lpszFilePath = new TCHAR[strlen(szFileName) + 1];
	   if ( !pThisFile->lpszFilePath )
	   {
		  delete pThisFile;
		  return(FALSE);
	   }

	   pThisFile->lpszFilePath =  szFileName;

	   // copyed the data

	   pThisFile->lpszFileName = _tcsrchr(pThisFile->lpszFilePath, '\\');
	   pThisFile->lpszFileName++;

	   pThisFile->lpszFileExt  = _tcsrchr(pThisFile->lpszFilePath, '.');
	   pThisFile->lpszFileExt++;

	   // get the version information
	   pThisFile->GetFileInformation();

	   bRet = pThisFile->VerifyFile();
	}
	catch(...)
	{

	}
	   // BUGBUG, need to check out the signer of this file to determine
   // who actually signed it.
	if(pThisFile)
	{
		delete pThisFile;
		pThisFile = NULL;
	}

	return(bRet);
}

BOOL Share_CloseHandle(void)
{
   if ( !BADHANDLE(hCatAdmin) )
   {
      CryptCATAdminReleaseContext(hCatAdmin, 0);
      hCatAdmin = 0;
   }
   return(TRUE);

}


//BOOL FileNode::GetCertInfo(PCCERT_CONTEXT pCertContext)
//{
 //  DWORD Size = 200;
 //  #if 0
//
//   Size = 200;
 //  if ( CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, pArray, &Size) )
 //  {
//      printf("\nSH1 Hash (%u):", Size);
 //     for ( UINT index = 0; index < Size; index++ )
 //     {
 //        printf("%s0x%02X", index == 0 ? " " : ", ", pArray[index]);
//      }
//      printf("\n");
//   }
//
//
//
//   Size = 200;
//   if ( CertGetCertificateContextProperty(pCertContext, CERT_SIGNATURE_HASH_PROP_ID, pArray, &Size) )
//   {
 //     printf("\nCert Hash (%u):", Size);
//      for ( UINT index = 0; index < Size; index++ )
//      {
//         printf("%s0x%02X", index == 0 ? " " : ", ", pArray[index]);
//      }
 //     printf("\n");
//   }

   // Get Chain information
//   CERT_CHAIN_PARA ChainPara; 
//   PCCERT_CHAIN_CONTEXT pChainContext = NULL;

//   memset (&CharinPara, 0, sizeof (CERT_CHAIN_PARA));
//   ChainPara.cbSize = sizeof (CERT_CHAIN_PARA);
//   ChainPara.RequestedUsage.

//   if ( CertGetCertificateChain(NULL, pCertContext, NULL, NULL, ) )
//   {
 //  }
//   #endif

//  return(TRUE);
//}

BOOL WalkCertChain(HANDLE hWVTStateData)
{
   CRYPT_PROVIDER_DATA * pProvData;
   CRYPT_PROVIDER_SGNR * pProvSigner = NULL;
   CRYPT_PROVIDER_CERT     *      pCryptProviderCert;

   BYTE pArray[21];
   UINT i;
   DWORD size;

   pProvData = WTHelperProvDataFromStateData(hWVTStateData);

   // did it work?
   if ( !pProvData )
   {
      return(FALSE);
   }

   pProvSigner = WTHelperGetProvSignerFromChain(
                                               (PCRYPT_PROVIDER_DATA) pProvData, 
                                               0, // first signer
                                               FALSE, //not counter signature 
                                               0); // index of counter sig, obviously not used

   if ( pProvSigner == NULL )
   {
      return(FALSE); 
   }
   //
   // walk all certs, the leaf cert is index 0, the root is the last index
   //
   pCryptProviderCert = NULL;
   for ( i = 0; i < pProvSigner->csCertChain; i++ )
   {
      pCryptProviderCert = WTHelperGetProvCertFromChain(pProvSigner, i);
      if ( pCryptProviderCert == NULL )
      {
         // error 
      }

      size = 20;
      if ( CertGetCertificateContextProperty(
                                            pCryptProviderCert->pCert,
                                            CERT_SHA1_HASH_PROP_ID,
                                            pArray,
                                            &size) )
      {
         /*
         printf("\nSH1 Hash (%u):{", size);
         for ( UINT index = 0; index < size; index++ )
         {
            printf("%s0x%02X", index == 0 ? " " : ", ", pArray[index]);
         }
         printf("}\n");
         */

         for ( UINT j = 0; j < NumberTestCerts; j++ )
         {
            if ( !memcmp(pArray, TestCertHashes[j], 20) )
            {
               // This cert is a test cert, not a real one, fail
               //printf("This file is signed by the testcert, and is therefor not trusted\n");
               //pritnf("please check the certification for this device");
               return (TRUE);
            }
         }
      }



   }

   return(FALSE);



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\category.cpp ===
//=============================================================================
// This file contains code to implement the CMSInfoCategory and 
// CMSInfoColumn classes.
//=============================================================================

#include "stdafx.h"
#include "category.h"

//=============================================================================
// CMSInfoCategory
//=============================================================================

//-----------------------------------------------------------------------------
// Get the name and/or caption for the category (loading the name from the
// string resources if necessary).
//-----------------------------------------------------------------------------

void CMSInfoCategory::GetNames(CString * pstrCaption, CString * pstrName)
{
	if (pstrName)
		*pstrName = m_strName;

	if (pstrCaption)
	{
		if (m_uiCaption)
		{
			TCHAR szCaption[MAX_PATH];
			::LoadString(_Module.GetResourceInstance(), m_uiCaption, szCaption, MAX_PATH);
			m_strCaption = szCaption;
			m_uiCaption = 0;
		}

		*pstrCaption = m_strCaption;
	}
}

//-----------------------------------------------------------------------------
// Get the number of rows and/or columns.
//-----------------------------------------------------------------------------

BOOL CMSInfoCategory::GetCategoryDimensions(int * piColumnCount, int * piRowCount)
{
	if (piColumnCount)
	{
		if (SUCCEEDED(m_hrError))
			*piColumnCount = m_iColCount;
		else
			*piColumnCount = 1;
	}

	if (piRowCount)
	{
		if (SUCCEEDED(m_hrError))
			*piRowCount = m_iRowCount;
		else
			*piRowCount = 1;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Is the specified row advanced?
//-----------------------------------------------------------------------------

BOOL CMSInfoCategory::IsRowAdvanced(int iRow)
{
	if (FAILED(m_hrError) && iRow == 0)
		return FALSE;

	ASSERT(iRow < m_iRowCount);
	if (iRow >= m_iRowCount)
		return FALSE;

	return m_afRowAdvanced[iRow];
}

//-----------------------------------------------------------------------------
// Is the specified column advanced?
//-----------------------------------------------------------------------------

BOOL CMSInfoCategory::IsColumnAdvanced(int iColumn)
{
	if (FAILED(m_hrError) && iColumn == 0)
		return FALSE;

	ASSERT(iColumn < m_iColCount);
	if (m_acolumns == NULL || iColumn >= m_iColCount)
		return FALSE;

	return m_acolumns[iColumn].m_fAdvanced;
}

//-----------------------------------------------------------------------------
// Get information about the specified column.
//-----------------------------------------------------------------------------

BOOL CMSInfoCategory::GetColumnInfo(int iColumn, CString * pstrCaption, UINT * puiWidth, BOOL * pfSorts, BOOL * pfLexical)
{
	ASSERT(iColumn < m_iColCount);
	if (iColumn >= m_iColCount)
		return FALSE;

	CMSInfoColumn * pCol = &m_acolumns[iColumn];

	if (FAILED(m_hrError) && iColumn == 0)
	{
		if (pstrCaption)
			pstrCaption->Empty();

		if (puiWidth)
			*puiWidth = 240;
		
		if (pfSorts)
			*pfSorts = FALSE;

		return TRUE;
	}

	if (pstrCaption)
	{
		if (pCol->m_uiCaption)
		{
			TCHAR szCaption[MAX_PATH];
			::LoadString(_Module.GetResourceInstance(), pCol->m_uiCaption, szCaption, MAX_PATH);
			pCol->m_strCaption = szCaption;
			pCol->m_uiCaption = 0;
		}

		*pstrCaption = pCol->m_strCaption;
	}
	
	if (puiWidth)
		*puiWidth = pCol->m_uiWidth;

	if (pfSorts)
		*pfSorts = pCol->m_fSorts;

	if (pfLexical)
		*pfLexical = pCol->m_fLexical;

	return TRUE;
}

//-----------------------------------------------------------------------------
// Save the width of the specified column.
//-----------------------------------------------------------------------------

void CMSInfoCategory::SetColumnWidth(int iCol, int iWidth)
{
	ASSERT(iCol < m_iColCount && iCol >= 0);
	if (iCol >= m_iColCount || iCol < 0)
		return;

	m_acolumns[iCol].m_uiWidth = (UINT) iWidth;
}

//-----------------------------------------------------------------------------
// Get data for the specified row and column.
//-----------------------------------------------------------------------------

static CString strErrorMessage;
BOOL CMSInfoCategory::GetData(int iRow, int iCol, CString ** ppstrData, DWORD * pdwData)
{
	if (FAILED(m_hrError) && iCol == 0 && iRow == 0)
	{
		if (ppstrData)
		{
			GetErrorText(&strErrorMessage, NULL);
			*ppstrData = &strErrorMessage;
		}

		if (pdwData)
			*pdwData = 0;

		return TRUE;
	}

	ASSERT(iRow < m_iRowCount && iCol < m_iColCount);
	if (iRow >= m_iRowCount || iCol >= m_iColCount)
		return FALSE;

	if (ppstrData)
		*ppstrData = &m_astrData[iRow * m_iColCount + iCol];

	if (pdwData)
		*pdwData = m_adwData[iRow * m_iColCount + iCol];

	return TRUE;
}

//-----------------------------------------------------------------------------
// Get the error strings for this category (subclasses should override this).
//-----------------------------------------------------------------------------

void CMSInfoCategory::GetErrorText(CString * pstrTitle, CString * pstrMessage)
{
	if (pstrTitle)
		pstrTitle->Empty();

	if (pstrMessage)
		pstrMessage->Empty();
}

//=============================================================================
// Helper functions for managing the arrays of data.
//=============================================================================

#ifndef SAFE_DELETE_ARRAY
#define SAFE_DELETE_ARRAY(x) { if (x) { delete [] x; x = NULL; } }
#endif

//-----------------------------------------------------------------------------
// Deletes all the content (except the array of columns if m_fDynamicColumns
// is false). Generally, this will be used when the category is destructing.
//-----------------------------------------------------------------------------

void CMSInfoCategory::DeleteAllContent()
{
	DeleteContent();
	if (m_fDynamicColumns)
	{
		SAFE_DELETE_ARRAY(m_acolumns);
		m_iColCount = 0;
	}
}

//-----------------------------------------------------------------------------
// Deletes all of the refreshed data (strings and DWORDs) and sets the number
// of rows to zero. It leaves the column information alone. This will be called
// when the data for a category is being refreshed.
//-----------------------------------------------------------------------------

void CMSInfoCategory::DeleteContent()
{
	SAFE_DELETE_ARRAY(m_astrData);
	SAFE_DELETE_ARRAY(m_adwData);
	SAFE_DELETE_ARRAY(m_afRowAdvanced);

	m_iRowCount = 0;
}

//-----------------------------------------------------------------------------
// Allocates space for the specified number of rows and columns, including
// the column array. Automatically sets the m_fDynamicColumns to TRUE.
// This will be called when the CMSInfoCategory is being created for the
// first time, and the columns are going to be dynamically set.
//-----------------------------------------------------------------------------

void CMSInfoCategory::AllocateAllContent(int iRowCount, int iColCount)
{
	ASSERT(iColCount);

	DeleteAllContent();
	
	m_iColCount = iColCount;
	m_fDynamicColumns = TRUE;
	m_acolumns = new CMSInfoColumn[m_iColCount];

	// TBD - memory errors?

	AllocateContent(iRowCount);
}

//-----------------------------------------------------------------------------
// Allocates the space for the specified number of rows. Leaves the column
// information alone. This would typically be called when new data is 
// available from a refresh and the arrays need to be set for the new row
// size.
//-----------------------------------------------------------------------------

void CMSInfoCategory::AllocateContent(int iRowCount)
{
	ASSERT(iRowCount);

	DeleteContent();

	m_iRowCount = iRowCount;

	m_astrData		= new CString[m_iColCount * m_iRowCount];
	m_adwData		= new DWORD[m_iColCount * m_iRowCount];
	m_afRowAdvanced = new BOOL[m_iRowCount];

	if (m_astrData == NULL || m_adwData == NULL || m_afRowAdvanced == NULL)
		return; // TBD what to do?

	for (int iRow = 0; iRow < m_iRowCount; iRow++)
	{
		m_afRowAdvanced[iRow] = FALSE;

		for (int iCol = 0; iCol < m_iColCount; iCol++)
			m_adwData[iRow * m_iColCount + iCol] = 0;
	}
}

//-----------------------------------------------------------------------------
// Put the specified string and DWORD into the arrays of data.
//-----------------------------------------------------------------------------

void CMSInfoCategory::SetData(int iRow, int iCol, const CString & strData, DWORD dwData)
{
	ASSERT(iRow < m_iRowCount && iCol < m_iColCount);

	if (m_astrData)
		m_astrData[iRow * m_iColCount + iCol] = strData;

	if (m_adwData)
		m_adwData[iRow * m_iColCount + iCol] = dwData;
}

//-----------------------------------------------------------------------------
// Set the specified row's advanced flag.
//-----------------------------------------------------------------------------

void CMSInfoCategory::SetAdvancedFlag(int iRow, BOOL fAdvanced)
{
	ASSERT(iRow < m_iRowCount);

	if (m_afRowAdvanced)
		m_afRowAdvanced[iRow] = fAdvanced;
}

//=============================================================================
// CMSInfoColumn
//=============================================================================

CMSInfoColumn::CMSInfoColumn(UINT uiCaption, UINT uiWidth, BOOL fSorts, BOOL fLexical, BOOL fAdvanced) : 
 m_uiCaption(uiCaption),
 m_strCaption(_T("")),
 m_uiWidth(uiWidth),
 m_fSorts(fSorts),
 m_fLexical(fLexical),
 m_fAdvanced(fAdvanced)
{
}

CMSInfoColumn::CMSInfoColumn() : 
 m_uiCaption(0),
 m_strCaption(_T("")),
 m_uiWidth(0),
 m_fSorts(FALSE),
 m_fLexical(FALSE),
 m_fAdvanced(FALSE)
{
}

CMSInfoColumn::~CMSInfoColumn()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\category.h ===
//=============================================================================
// This include file contains definitions of structures and classes used to
// implement the categories, as well as the rows and columns of information
// displayed and saved in MSInfo (regardless of the data source).
//=============================================================================

#pragma once

#include "version5extension.h"

//-----------------------------------------------------------------------------
// A prototype for a function used for sorting the contents of the list.
//-----------------------------------------------------------------------------

extern int CALLBACK ListSortFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

//-----------------------------------------------------------------------------
// An enumeration for all the available places we might get data. Also an
// enumeration for environments a category supports.
//-----------------------------------------------------------------------------

typedef enum { LIVE_DATA, NFO_410, NFO_500, XML_SNAPSHOT, XML_DELTA, NFO_700 } DataSourceType;
typedef enum { ALL_ENVIRONMENTS, NT_ONLY, MILLENNIUM_ONLY } CategoryEnvironment;

//-----------------------------------------------------------------------------
// A column description - this is used internally to the CMSInfoCategory
// category, and won't concern the calling code.
//-----------------------------------------------------------------------------

class CMSInfoColumn
{
public:
	CMSInfoColumn();
	CMSInfoColumn(UINT uiCaption, UINT uiWidth, BOOL fSorts = TRUE, BOOL fLexical = TRUE, BOOL fAdvanced = FALSE);
	virtual ~CMSInfoColumn();

	UINT		m_uiCaption;
	CString		m_strCaption;
	UINT		m_uiWidth;
	BOOL		m_fSorts;
	BOOL		m_fLexical;
	BOOL		m_fAdvanced;

	CMSInfoColumn(LPCTSTR szCaption, UINT uiWidth, BOOL fSorts = TRUE, BOOL fLexical = TRUE, BOOL fAdvanced = FALSE) : 
	 m_uiCaption(0),
	 m_strCaption(szCaption),
	 m_uiWidth(uiWidth),
	 m_fSorts(fSorts),
	 m_fLexical(fLexical),
	 m_fAdvanced(fAdvanced)
	{
	}
};

//-----------------------------------------------------------------------------
// The CMSInfoCategory class corresponds to a category in the tree view. This
// is an abstract base class for subclasses which implement categories for
// various situations (such as live WMI data, XML Snapshot, XML Delta, etc.).
//
// Note - the view functionality (BASIC/ADVANCED) is included in this base
// class because it's used by so many of the subclasses. Subclasses which
// don't use the view (XML Delta, for example) should make all of their
// columns basic.
//-----------------------------------------------------------------------------

class CMSInfoFile;
class CMSInfoTextFile;
class CMSInfoPrintHelper;

class CMSInfoCategory
{
	friend class CDataSource;  // TBD fix this
	friend class CManageExtensionCategories;
	
public:
	CMSInfoCategory() :
	 m_uiCaption(0),
	 m_pParent(NULL),
	 m_pPrevSibling(NULL),
	 m_pFirstChild(NULL),
	 m_pNextSibling(NULL),
	 m_acolumns(NULL),
	 m_astrData(NULL),
	 m_adwData(NULL),
	 m_afRowAdvanced(NULL),
	 m_hrError(S_OK),
	 m_fDynamicColumns(TRUE),
	 m_iSortColumn(-1),
	 m_hti(NULL),
	 m_fSkipCategory(FALSE),
	 m_fShowCategory(TRUE)
	{
	}

	CMSInfoCategory(UINT uiCaption, LPCTSTR szName, CMSInfoCategory * pParent, CMSInfoCategory * pPrevious, CMSInfoColumn * pColumns = NULL, BOOL fDynamicColumns = TRUE, CategoryEnvironment environment = ALL_ENVIRONMENTS) :
	 m_uiCaption(uiCaption),
	 m_pParent(pParent),
	 m_pPrevSibling(pPrevious),
	 m_pFirstChild(NULL),
	 m_pNextSibling(NULL),
	 m_acolumns(pColumns),
	 m_astrData(NULL),
	 m_adwData(NULL),
	 m_afRowAdvanced(NULL),
	 m_strName(szName),
	 m_hrError(S_OK),
	 m_fDynamicColumns(fDynamicColumns),
	 m_iRowCount(0),
	 m_iColCount(0),
	 m_iSortColumn(-1), 
	 m_hti(NULL),
	 m_fSkipCategory(FALSE),
 	 m_fShowCategory(TRUE)
	{
		 for (CMSInfoColumn * pColumn = m_acolumns; (pColumn && (pColumn->m_uiCaption || !pColumn->m_strCaption.IsEmpty())); m_iColCount++, pColumn++);

		 if (m_acolumns && m_acolumns->m_fSorts)
		 {
			  m_iSortColumn = 0;
			  m_fSortAscending = TRUE;
			  m_fSortLexical = m_acolumns->m_fLexical;
		 }

		 // Check to see if this category belongs in this environment.

		 if (environment != ALL_ENVIRONMENTS)
		 {
			 OSVERSIONINFO osv;
			 osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
			 if (GetVersionEx(&osv))
			 {
				 if (environment == NT_ONLY)
					 m_fSkipCategory = (osv.dwPlatformId != VER_PLATFORM_WIN32_NT);
				 else
					 m_fSkipCategory = (osv.dwPlatformId == VER_PLATFORM_WIN32_NT);
			 }
		 }
	}

	virtual ~CMSInfoCategory()
	{
		DeleteAllContent();
	};

	// Navigation functions for moving around in the category tree. Note, these
	// are included for convenience (and for cases with no UI), since you should
	// be able to do all of this using the actual tree control.

	virtual CMSInfoCategory * GetParent() { return m_pParent; };
	
	virtual CMSInfoCategory * GetFirstChild()  
	{ 
		CMSInfoCategory * pChild = m_pFirstChild;
		while (pChild && (pChild->m_fSkipCategory || !pChild->m_fShowCategory))
			pChild = pChild->m_pNextSibling;
		return pChild;
	};

	virtual CMSInfoCategory * GetNextSibling()
	{
		CMSInfoCategory * pNext = m_pNextSibling;
		while (pNext && (pNext->m_fSkipCategory || !pNext->m_fShowCategory))
			pNext = pNext->m_pNextSibling;
		return pNext;
	};

	virtual CMSInfoCategory * GetPrevSibling()
	{
		CMSInfoCategory * pPrev = m_pPrevSibling;
		while (pPrev && (pPrev->m_fSkipCategory || !pPrev->m_fShowCategory))
			pPrev = pPrev->m_pPrevSibling;
		return pPrev;
	};

	// Return the count of categories in the subtree with this category as the root.

	int GetCategoryCount()
	{
		int nCount = 1;

		CMSInfoCategory * pChild = GetFirstChild();
		while (pChild)
		{
			nCount += pChild->GetCategoryCount();
			pChild = pChild->GetNextSibling();
		}

		return nCount;
	}

	// This function is used to control whether or not this category (and all
	// of its children) are shown or not. This will be called by the code which
	// processes the "/categories" command line flag.

	void SetShowCategory(BOOL fShow, BOOL fSetParent = TRUE)
	{
		// If we are supposed to show this category, then we had better
		// make sure all the parents are shown too.

		if (fShow && fSetParent)
			for (CMSInfoCategory * pParent = m_pParent; pParent; pParent = pParent->m_pParent)
				pParent->m_fShowCategory = TRUE;

		// Set the new flag for this category and each of this category's children.

		m_fShowCategory = fShow;

		for (CMSInfoCategory * pChild = m_pFirstChild; pChild; pChild = pChild->m_pNextSibling)
			pChild->SetShowCategory(fShow, FALSE);
	}

	// These functions are useful for associating a HTREEITEM with the
	// given category (very useful in find operations).

protected:
	HTREEITEM	m_hti;
public:
	void		SetHTREEITEM(HTREEITEM hti) { m_hti = hti; };
	HTREEITEM	GetHTREEITEM()				{ return m_hti; };

	// Functions to get information for the data stored in this category.

	virtual void				GetNames(CString * pstrCaption, CString * pstrName);
	virtual BOOL				GetCategoryDimensions(int * piColumnCount, int * piRowCount);
	virtual BOOL				IsRowAdvanced(int iRow);
	virtual BOOL				IsColumnAdvanced(int iColumn);
	virtual BOOL				GetColumnInfo(int iColumn, CString * pstrCaption, UINT * puiWidth, BOOL * pfSorts, BOOL * pfLexical);
	virtual BOOL				GetData(int iRow, int iCol, CString ** ppstrData, DWORD * pdwData);
	virtual void				SetColumnWidth(int iCol, int iWidth);

	// Return from where this category is getting its data. Also a function
	// to reset the state of the category (in case it's going to be reused,
	// and it's static).

	virtual DataSourceType		GetDataSourceType() = 0;
	virtual void				ResetCategory() { };

	// Get the current HRESULT for this category (set during refresh, for instance).

	virtual HRESULT				GetHRESULT() { return m_hrError; };
	virtual void				GetErrorText(CString * pstrTitle, CString * pstrMessage);
	virtual CString				GetHelpTopic() { return CString(_T("")); };

    // Saving to disk and printing Functions a-stephl
    // Functions that take as parameters file HANDLES or HDC's are the ones that will normally be
    // called by the shell; the functions that take CMSInfo objects as parameters are used for 
    // recursing the operation over the category's children
public:
    static  BOOL SaveNFO(HANDLE hFile,CMSInfoCategory* pCategory, BOOL fRecursive);
    virtual void Print(HDC hDC, BOOL bRecursive,int nStartPage = 0, int nEndPage = 0, LPTSTR lpMachineName = NULL);
    virtual BOOL SaveAsText(HANDLE hFile, BOOL bRecursive, LPTSTR lpMachineName = NULL);
	//virtual BOOL SaveAsXml(HANDLE hFile, BOOL bRecursive);
    virtual BOOL SaveXML(HANDLE hFile);
protected:
    virtual BOOL SaveToNFO(CMSInfoFile* pFile);
    virtual void SaveElements(CMSInfoFile *pFile);
    virtual BOOL SaveAsText(CMSInfoTextFile* pTxtFile, BOOL bRecursive);
	//virtual BOOL SaveAsXml(CMSInfoTextFile* pTxtFile, BOOL bRecursive);
    virtual void Print(CMSInfoPrintHelper* pPrintHelper, BOOL bRecursive);
    virtual BOOL SaveXML(CMSInfoTextFile* pTxtFile);

public:
	CMSInfoCategory *			m_pParent;
	CMSInfoCategory *			m_pFirstChild;
	CMSInfoCategory *			m_pNextSibling;
	CMSInfoCategory *			m_pPrevSibling;

	int							m_iSortColumn;				// currently sorting by this column
	BOOL						m_fSortLexical;				// sort the current column lexically
	BOOL						m_fSortAscending;			// sort the current column ascending

protected:
	BOOL						m_fSkipCategory;			// skip this category (wrong environment)
	BOOL						m_fShowCategory;			// show this category (defaults to true)
	int							m_iRowCount, m_iColCount;	// dimensions of the data
	CMSInfoColumn *				m_acolumns;					// should be [m_iColCount]
	BOOL						m_fDynamicColumns;			// true if m_acolumns should be deleted
	CString *					m_astrData;					// should be [m_iRowCount * m_iColCount]
	DWORD *						m_adwData;					// should be [m_iRowCount * m_iColCount]
	BOOL *						m_afRowAdvanced;			// should be [m_iRowCount]
	UINT						m_uiCaption;				// resource ID for the caption string, used to load...
	CString						m_strCaption;				// the caption (display) string
	CString						m_strName;					// internal category name (non-localized)
	HRESULT						m_hrError;					// HRESULT for a possible category-wide error

	void DeleteAllContent();
	void DeleteContent();
	void AllocateAllContent(int iRowCount, int iColCount);
	void AllocateContent(int iRowCount);
	void SetData(int iRow, int iCol, const CString & strData, DWORD dwData);
	void SetAdvancedFlag(int iRow, BOOL fAdvanced);
};

//-----------------------------------------------------------------------------
// The CMSInfoLiveCategory class implements categories for live data view.
// This is done primarily by adding a Refresh() function and a constructor
// which takes a function pointer for refreshing the category and pointers
// to category relatives.
//
// This class has a member variable which is a pointer to a refresh function.
// This function returns an HRESULT, and takes the following values:
//
// pWMI			a CWMIHelper object, which abstracts data access
// dwIndex		a category specific value which the refresh function can
//				use to determine which of multiple categories to refresh
// pfCancel		a flag indicating that the refresh should be cancelled
//				which should be checked frequently during the refresh
// aColValues	an array of CPtrList objects, which should contain the
//				results of the refresh, in the form of a list of CMSIValue
//				instances (each list is for a given column, and should contain
//				entries equal to the number of rows)
// iColCount	the number of entries in the aColValues array
// ppCache		a pointer to a void pointer which the function can use to save
//				cached information - changes to this pointer will be saved
//				through multiple calls to the refresh function (note: if the
//				refresh function is called with a NULL value for pWMI, the
//				function should free whatever's been allocated into the
//				ppCache pointer)
//-----------------------------------------------------------------------------

struct CMSIValue
{
	CMSIValue(LPCTSTR szValue, DWORD dwValue, BOOL fAdvanced = FALSE) : 
		m_strValue(szValue), 
		m_dwValue(dwValue),
		m_fAdvanced(fAdvanced)
	{
	}

	CString		m_strValue;
	DWORD		m_dwValue;
	BOOL		m_fAdvanced;
};

class CLiveDataSource;
class CWMIHelper;

typedef HRESULT (*RefreshFunction)(CWMIHelper * pWMI, 
								   DWORD dwIndex, 
								   volatile BOOL * pfCancel, 
								   CPtrList * aColValues, 
								   int iColCount, 
								   void ** ppCache);

class CMSInfoLiveCategory : public CMSInfoCategory
{
	friend DWORD WINAPI ThreadRefresh(void * pArg);
	friend class CXMLDataSource;
	friend class CXMLSnapshotCategory;
public:
	// Functions overridden from the base class:

	virtual ~CMSInfoLiveCategory();
	virtual DataSourceType GetDataSourceType() { return LIVE_DATA; };
	void GetErrorText(CString * pstrTitle, CString * pstrMessage);

	// Functions specific to the subclass:

	CMSInfoLiveCategory(UINT uiCaption, LPCTSTR szName, RefreshFunction pFunction, DWORD dwRefreshIndex, CMSInfoCategory * pParent, CMSInfoCategory * pPrevious, const CString & strHelpTopic = _T(""), CMSInfoColumn * pColumns = NULL, BOOL fDynamicColumns = TRUE, CategoryEnvironment environment = ALL_ENVIRONMENTS);
	CMSInfoLiveCategory(CMSInfoLiveCategory & copyfrom);
	CMSInfoLiveCategory(INTERNAL_CATEGORY * pinternalcat);
	virtual BOOL Refresh(CLiveDataSource * pSource, BOOL fRecursive);
	BOOL RefreshSynchronous(CLiveDataSource * pSource, BOOL fRecursive);
	BOOL RefreshSynchronousUI(CLiveDataSource * pSource, BOOL fRecursive, UINT uiMessage, HWND hwnd);
	BOOL EverBeenRefreshed() { return (m_dwLastRefresh != 0); }
	void ResetCategory() { m_dwLastRefresh = 0; };
	void SetMachine(LPCTSTR szMachine) { m_strMachine = szMachine; m_hrError = S_OK; };
	CString GetHelpTopic() { return m_strHelpTopic; };

protected:
	DWORD				m_dwLastRefresh;
	DWORD				m_dwRefreshIndex;
	RefreshFunction		m_pRefreshFunction;
	CString				m_strMachine;
	CString				m_strHelpTopic;
};

//-----------------------------------------------------------------------------
// The CMSInfoHistoryCategory class implements categories for the view
// of history data.
//-----------------------------------------------------------------------------

class CMSInfoHistoryCategory : public CMSInfoLiveCategory
{
public:
	CMSInfoHistoryCategory(UINT uiCaption, LPCTSTR szName, CMSInfoCategory * pParent, CMSInfoCategory * pPrevious, CMSInfoColumn * pColumns = NULL, BOOL fDynamicColumns = TRUE) :
		CMSInfoLiveCategory(uiCaption, szName, NULL, 0, pParent, pPrevious, _T(""), pColumns, fDynamicColumns, ALL_ENVIRONMENTS),
		m_iDeltaIndex(-1)
	{
	}

	void UpdateDeltaIndex(int iIndex)
	{

		m_dwLastRefresh = 0;
		

		CMSInfoHistoryCategory * pChild = (CMSInfoHistoryCategory *)GetFirstChild();
		while (pChild)
		{
			pChild->UpdateDeltaIndex(iIndex);
			pChild = (CMSInfoHistoryCategory *)pChild->GetNextSibling();
		}
		m_iDeltaIndex = iIndex;
	}

	BOOL Refresh(CLiveDataSource * pSource, BOOL fRecursive);

public:
	CPtrList	m_aValList[5];

	void ClearLines();
	/*void InsertChangeLine(int nDays, LPCTSTR szType, LPCTSTR szName, LPCTSTR szProperty, LPCTSTR szFromVal, LPCTSTR szToVal);
	void InsertAddLine(int nDays, LPCTSTR szType, LPCTSTR szName);
	void InsertRemoveLine(int nDays, LPCTSTR szType, LPCTSTR szName);
	void InsertLine(int nDays, LPCTSTR szType, LPCTSTR szName, LPCTSTR szProperty, LPCTSTR szDetails = NULL);*/
	void InsertChangeLine(CTime tm, LPCTSTR szType, LPCTSTR szName, LPCTSTR szProperty, LPCTSTR szFromVal, LPCTSTR szToVal);
	void InsertAddLine(CTime tm, LPCTSTR szType, LPCTSTR szName);
	void InsertRemoveLine(CTime tm, LPCTSTR szType, LPCTSTR szName);
	void InsertLine(CTime tm, LPCTSTR szType, LPCTSTR szName, LPCTSTR szProperty, LPCTSTR szDetails = NULL);

	void CommitLines();
	int	m_iDeltaIndex;
private:
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\chkdrv.h ===
#include <stdio.h>
#include <windows.h>
#include "chkdev.h"
#include <stdlib.h>
#include "resource.h"
#include "WbemCli.h"

extern enum Classes_Provided;

// nonstandard array size 
#pragma warning(disable:4200)

#ifdef DLLENTRY
#define DllExport __declspec( dllexport ) 
#else
#define DllExport
#endif


// define flags
#define   FLAGS_RUN_CHKDRV 0x00001
#define   FLAGS_IGNORE_STORAGE 0x00002
#define   STORAGE_BASE_KEY    "STORAGE\\VOLUME\\"

//
// Error return codes
//

#define SUCCESS                 0
#define COULD_NOT_OPEN_FILE     1          // get last error still should be valid from CreateFile
#define FILE_TOO_BIG            2          // greater than 4 gig
#define BAD_PARAMITER           3          // paramiter is wrong
#define MEMORY_ALLOCATION_ERROR 4
#define FILE_CHECK_FAILED       5
#define CREATE_HASH_ERROR       6
#define WRONG_VERSION           7
#define SOME_RANDOM_XCPT        8
#define NO_MATCH_FOUND          9
#define BADERROR                ((0xE0 << 24) | (FACILITY_ITF << 16))

#define RETURN_COMRESULT(x)       _HRESULT_TYPEDEF_(x ? (BADERROR | x) : x)





typedef struct tag_DeviceElement
{
   CHAR NAME[_MAX_PATH];
   CHAR HWID[_MAX_PATH];
   CHAR DeviceID[_MAX_PATH];
   ULONG ulProblem;
   ULONG ulStatus;
   ULONG dwHandle;
   CHAR INIFILE[_MAX_FNAME + _MAX_EXT +1];
   UINT IsPresent;
} DeviceElement;

typedef struct tag_BIOS_Version
{
   CHAR BIOSString [100];
   CHAR BIOSDate   [100];
} BIOSVERSION;

typedef struct tag_InfoFileHeader
{
    char  FileVersionName[32];
    DWORD FileVersion[4];
    DWORD TimeStamp;
} InfoFileHeader;


                 

typedef struct tag_FileHash
{
   CHAR FileName[_MAX_PATH];
   DWORD ulHashSize;
   BYTE Hash[_MAX_PATH];
} FileHash;


typedef struct tag_FileListHeader
{
   DWORD TAG;
   DWORD CountFiles;
   FileHash Files[];
} FileListHeader;


typedef struct tag_FileHeader
{
   InfoFileHeader FileInfo;
   DWORD ThisFileSize;
   DWORD CountStructs;
   DWORD CountFiles;
   BIOSVERSION BiosVersion ;
   FileListHeader *pFileList;
   DeviceElement DeviceArray[];
} FileHeader;

#pragma warning(default:4200)

BOOL _cdecl logprintf(TCHAR *lpszFormat, ...);
DWORD WINAPI ScanDeviceList(void *pVoid);
DWORD WINAPI ScanFileList(void *pVoid);
BOOL CompareDevice (InfnodeClass *pDevice, DeviceElement *pElement);
BOOL CompareFiles(char *FileName, ULONG HashSize, PBYTE Hash);
int ScanTreeHelper(DEVNODE hDevnode, DEVNODE hParent);
DWORD WINAPI ScanDeviceList(void *pVoid);
DWORD WINAPI ScanFileList(void *pVoid);

int CreateList(IWbemContext *pCtx , Classes_Provided eClasses);
int WalkTree(void);
int WalkTreeHelper(DEVNODE hDevnode, DEVNODE hParent);
int WriteDeviceToBuffer(DeviceElement *pElement, CheckDevice *pDevice);
int WriteFileListToBuffer(FileHash *pHash, FileNode *pFile);
int ScanList (TCHAR *szFileName, UINT uFlags);

BOOL GetList (TCHAR **pErrorString);

BOOL IsExcludedDriver (TCHAR *DeviceID);
BOOL IsExcludedClass (TCHAR *DeviceID);

BOOL WriteBiosDateAndVersion (BIOSVERSION *BVer);
BOOL GetBiosDateAndVersion(BIOSVERSION *BVer);

// cmplist.cpp
BOOL CryptFile (ULONG key, WORD *buffer, ULONG size /* in bytes */);
BOOL bVerifyVersion(DWORD *pVersion);
BOOL MatchPCI_ID(PCHAR pHwid, DeviceElement *pElement, ULONG count);
BOOL MatchUSB_ID(PCHAR pHwid, DeviceElement *pElement, ULONG count);
BOOL MatchHID_ID(PCHAR pHwid, DeviceElement *pElement, ULONG count);
BOOL MatchACPI_ID(PCHAR pHwid, DeviceElement *pElement, ULONG count);
BOOL MatchXxx_ID(PCHAR pHwid, DeviceElement *pElement, ULONG count);




extern "C" BOOL DllExport WINAPI Chkdrv_IsFileAMatch (ULONG pFileHandle, char *lpszFileName);
extern "C" BOOL DllExport WINAPI Chkdrv_IsHWIDAMatch (ULONG pFileHandle, char *lpszHWIDName);
extern "C" DWORD DllExport WINAPI  Chkdrv_CloseListFile (ULONG pFileHandle);
extern "C" DWORD DllExport WINAPI  Chkdrv_OpenListFile(char *szFileName);
extern "C" ULONG DllExport WINAPI Chkdrv_CompareListFiles(ULONG handle1, ULONG handle2, TCHAR **LogFile, UINT *cbResult);


extern "C" DWORD DllExport WINAPI CreateEnvCheckFile (PCHAR lpszFileName, HWND  hParent);
extern "C" DWORD DllExport WINAPI ScanDevicesForChanges(PCHAR lpszFileName, CHAR **lppszResults, UINT *cbResults, DWORD dwFlags);
extern "C" BOOL bIgnoreStorage;

BOOL ProgBoxStep(char *text);
int WalkTreeDevnode(DEVNODE hDevnode, DEVNODE hParent);
extern "C" INT_PTR WINAPI ProgBoxProcedure(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
);
extern HANDLE hMutex;


#ifdef DEBUG
#ifndef ASSERT
#define ASSERT(x) \
if (!x) _asm int 3;

//void *::operator new(SIZE_T size);

#endif
#else
#ifndef ASSERT
#define ASSERT(x)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\components.cpp ===
//=============================================================================
// Contains the refresh functions for the resource categories.
//=============================================================================

#include "stdafx.h"
#include "category.h"
#include "dataset.h"
#include "wmiabstraction.h"

//-----------------------------------------------------------------------------
// This function gathers CODEC (audio and video) information.
//-----------------------------------------------------------------------------

HRESULT CODECs(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	if (pWMI == NULL)
		return S_OK;

	HRESULT hr = S_OK;

	CWMIObjectCollection *	pCollection = NULL;
	CString					strGroup = (dwIndex == CODEC_AUDIO) ? _T("Audio") : _T("Video");
	LPCTSTR					szProperties = _T("EightDotThreeFileName, Manufacturer, Description, Status, Name, Version, FileSize, CreationDate, Group");

	hr = pWMI->Enumerate(_T("Win32_CODECFile"), &pCollection, szProperties);
	if (SUCCEEDED(hr))
	{
		CWMIObject * pObject = NULL;
		
		while (S_OK == pCollection->GetNext(&pObject))
			if (strGroup.CompareNoCase(pObject->GetString(_T("Group"))) == 0)
				pWMI->AddObjectToOutput(aColValues, iColCount, pObject, szProperties, IDS_CODEC1);

		delete pObject;
		delete pCollection;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// This function gathers Drive information.
//-----------------------------------------------------------------------------

HRESULT ComponentDrives(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	if (pWMI == NULL)
		return S_OK;

	HRESULT hr = S_OK;

	// Get all of the logical drives. There should be at most 26 of them, since they're limited
	// by drive letter assignments.

	CWMIObject * apDriveObjects[26];
	::ZeroMemory(apDriveObjects, sizeof(CWMIObject *) * 26);
	
	CWMIObjectCollection * pCollection = NULL;
	hr = pWMI->Enumerate(_T("Win32_LogicalDisk"), &pCollection, _T("DriveType, DeviceID, Description, Compressed, FileSystem, Size, FreeSpace, VolumeName, VolumeSerialNumber, PNPDeviceID, ProviderName"));
	if (SUCCEEDED(hr))
	{
		CWMIObject * pObject = NULL;
		while (S_OK == pCollection->GetNext(&pObject))
		{
			CString strDeviceID = pObject->GetString(_T("DeviceID"));
			if (!strDeviceID.IsEmpty())
			{
				strDeviceID.MakeUpper();
				TCHAR chDriveLetter = strDeviceID[0];
				if (chDriveLetter >= _T('A') && chDriveLetter <= _T('Z'))
					apDriveObjects[chDriveLetter - _T('A')] = pObject;
				else
					delete pObject;
			}
			else
				delete pObject;
			pObject = NULL;
		}
		delete pCollection;
	}

	for (int index = 0; index < 26; index++)
		if (apDriveObjects[index])
		{
			DWORD dwType;
			if (SUCCEEDED(apDriveObjects[index]->GetValueDWORD(_T("DriveType"), &dwType)))
			{
				// Depending on the type of the drive, display different information.

				switch (dwType)
				{
				case 2:
					pWMI->AppendBlankLine(aColValues, iColCount);
					pWMI->AddObjectToOutput(aColValues, iColCount, apDriveObjects[index], _T("DeviceID, Description"), IDS_DRIVESTYPE2);
					break;

				case 3:
					pWMI->AppendBlankLine(aColValues, iColCount);
					pWMI->AddObjectToOutput(aColValues, iColCount, apDriveObjects[index], _T("DeviceID, Description, Compressed, MSIAdvancedFileSystem, Size, FreeSpace, MSIAdvancedVolumeName, MSIAdvancedVolumeSerialNumber, MSIAdvancedPNPDeviceID"), IDS_DRIVESTYPE3);
					break;

				case 4:
					pWMI->AppendBlankLine(aColValues, iColCount);
					pWMI->AddObjectToOutput(aColValues, iColCount, apDriveObjects[index], _T("DeviceID, Description, ProviderName"), IDS_DRIVESTYPE4);
					break;

				case 5:
					pWMI->AppendBlankLine(aColValues, iColCount);
					pWMI->AddObjectToOutput(aColValues, iColCount, apDriveObjects[index], _T("DeviceID, Description"), IDS_DRIVESTYPE2);
					break;
				}
			}

			delete apDriveObjects[index];
		}

	return hr;
}

//-----------------------------------------------------------------------------
// This function gathers WinSock information.
//-----------------------------------------------------------------------------

HRESULT Winsock(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	if (pWMI == NULL)
		return S_OK;

	// Get the system directory.

	CWMIObjectCollection * pCollection = NULL;
	CWMIObject * pOSObject = NULL;

	HRESULT hr = pWMI->Enumerate(_T("Win32_OperatingSystem"), &pCollection);
	if (SUCCEEDED(hr))
	{
		hr = pCollection->GetNext(&pOSObject);
		if (FAILED(hr))
			pOSObject = NULL;
		delete pCollection;
	}
	if (pOSObject == NULL)
		return hr;

	CString strSystemDirectory = pOSObject->GetString(_T("SystemDirectory"));
	delete pOSObject;
	if (strSystemDirectory.IsEmpty())
		return S_OK;

	// This is the set of WINSOCK files we'll be looking at.

	CString astrFiles[] = { _T("winsock.dll"), _T("wsock32.dll"), _T("wsock32n.dll"), _T("") };

	for (int index = 0; !astrFiles[index].IsEmpty(); index++)
	{
		// Get the object for the CIM_DataFile for this specific file.

		CString strPath;
		strPath.Format(_T("CIM_DataFile.Name='%s\\%s'"), strSystemDirectory, astrFiles[index]);

		CWMIObject * pObject;
		if (SUCCEEDED(pWMI->GetObject(strPath, &pObject)))
		{
			pWMI->AppendBlankLine(aColValues, iColCount);
			pWMI->AddObjectToOutput(aColValues, iColCount, pObject, _T("Name, FileSize, Version"), IDS_WINSOCK1);
			delete pObject;
		}
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// This function gathers Disk information.
//
// TBD - might be nice to get the partition drive letter from
//		 Win32_LogicalDiskToPartition.
//-----------------------------------------------------------------------------

HRESULT Disks(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	if (pWMI == NULL)
		return S_OK;

	LPCTSTR szDiskProperties = _T("Description, Manufacturer, Model, MSIAdvancedBytesPerSector, MediaLoaded, MediaType, Partitions, MSIAdvancedSCSIBus, MSIAdvancedSCSILogicalUnit, MSIAdvancedSCSIPort, MSIAdvancedSCSITargetId, MSIAdvancedSectorsPerTrack, Size, MSIAdvancedTotalCylinders, MSIAdvancedTotalSectors, MSIAdvancedTotalTracks, MSIAdvancedTracksPerCylinder, MSIAdvancedPNPDeviceID, MSIAdvancedIndex");
	LPCTSTR szPartitionProperties = _T("Caption, Size, MSIAdvancedStartingOffset, MSIAdvancedDiskIndex");

	CWMIObjectCollection * pDiskCollection = NULL;
	HRESULT hr = pWMI->Enumerate(_T("Win32_DiskDrive"), &pDiskCollection, szDiskProperties);
	if (SUCCEEDED(hr))
	{
		CWMIObject * pDiskObject = NULL;
		while (S_OK == pDiskCollection->GetNext(&pDiskObject))
		{
			pWMI->AppendBlankLine(aColValues, iColCount);
			pWMI->AddObjectToOutput(aColValues, iColCount, pDiskObject, szDiskProperties, IDS_DISKS1);

			DWORD dwIndex;
			if (FAILED(pDiskObject->GetValueDWORD(_T("Index"), &dwIndex)))
				continue;

			CWMIObjectCollection * pPartitionCollection = NULL;
			if (SUCCEEDED(pWMI->Enumerate(_T("Win32_DiskPartition"), &pPartitionCollection, szPartitionProperties)))
			{
				CWMIObject * pPartitionObject = NULL;
				while (S_OK == pPartitionCollection->GetNext(&pPartitionObject))
				{
					DWORD dwDiskIndex;
					if (FAILED(pPartitionObject->GetValueDWORD(_T("DiskIndex"), &dwDiskIndex)) || dwIndex != dwDiskIndex)
						continue;

					pWMI->AddObjectToOutput(aColValues, iColCount, pPartitionObject, szPartitionProperties, IDS_DISKS2);
				}
				delete pPartitionObject;
				delete pPartitionCollection;
			}
		}
		delete pDiskObject;
		delete pDiskCollection;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// This function gathers Problem Device information.
//-----------------------------------------------------------------------------

HRESULT ProblemDevices(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	if (pWMI == NULL)
		return S_OK;

	CWMIObjectCollection * pCollection = NULL;
	HRESULT hr = pWMI->Enumerate(_T("Win32_PnPEntity"), &pCollection, _T("Caption, PNPDeviceID, ConfigManagerErrorCode"));
	if (SUCCEEDED(hr))
	{
		CWMIObject * pObject = NULL;
		while (S_OK == pCollection->GetNext(&pObject))
		{
			DWORD dwError;
			if (SUCCEEDED(pObject->GetValueDWORD(_T("ConfigManagerErrorCode"), &dwError)))
				if (dwError)
					pWMI->AddObjectToOutput(aColValues, iColCount, pObject, _T("Caption, PNPDeviceID, ConfigManagerErrorCode"), IDS_PROBLEMDEVICE1);
		}
		delete pObject;
		delete pCollection;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// This function gathers USB information.
//-----------------------------------------------------------------------------

HRESULT ComponentsUSB(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	if (pWMI == NULL)
		return S_OK;

	CWMIObjectCollection * pUSBControllerCollection = NULL;
	HRESULT hr = pWMI->Enumerate(_T("Win32_USBController"), &pUSBControllerCollection, _T("Caption, PNPDeviceID, __PATH"));
	if (SUCCEEDED(hr))
	{
		CWMIObject * pUSBControllerObject = NULL;
		while (S_OK == pUSBControllerCollection->GetNext(&pUSBControllerObject))
		{
			pWMI->AddObjectToOutput(aColValues, iColCount, pUSBControllerObject, _T("Caption, PNPDeviceID"), IDS_USB1);

			// For each USB controller, look for devices connected to it (through
			// the Win32_USBControllerDevice class).

			CString strUSBControllerPath = pUSBControllerObject->GetString(_T("__PATH"));
			if (!strUSBControllerPath.IsEmpty())
			{
				CWMIObjectCollection * pAssocCollection = NULL;
				if (SUCCEEDED(pWMI->Enumerate(_T("Win32_USBControllerDevice"), &pAssocCollection)))
				{
					CWMIObject * pAssocObject = NULL;
					while (S_OK == pAssocCollection->GetNext(&pAssocObject))
					{
						CString strAntecedent, strDependent;
						
						if (SUCCEEDED(pAssocObject->GetValueString(_T("Antecedent"), &strAntecedent)))
						{
							if (strAntecedent.CompareNoCase(strUSBControllerPath) == 0)
							{
								if (SUCCEEDED(pAssocObject->GetValueString(_T("Dependent"), &strDependent)))
								{
									CWMIObject * pDeviceObject;
									if (SUCCEEDED(pWMI->GetObject(strDependent, &pDeviceObject)))
									{
										pWMI->AddObjectToOutput(aColValues, iColCount, pDeviceObject, _T("Caption, PNPDeviceID"), IDS_USB1);
										delete pDeviceObject;
									}
								}
							}
						}
					}
					delete pAssocObject;
					delete pAssocCollection;
				}
			}
		}
		delete pUSBControllerObject;
		delete pUSBControllerCollection;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\chkdev.h ===
#ifndef _CHECK_DEVICE_H_
#define _CHECK_DEVICE_H_

#include <windows.h>
#include <infnode.h>
#include <setupapi.h>
#include <regstr.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <mscat.h>
#include <softpub.h>

//#define  HASH_SIZE 40 // TODO: is this correct???

int __stdcall FindDriverFiles(LPCSTR szDeviceID, LPSTR szBuffer, DWORD dwLength);
UINT __stdcall ScanQueueCallback(PVOID pvContext, UINT Notify, UINT_PTR Param1, UINT_PTR Param2);
BOOL CheckFile (TCHAR *szFileName);




#define WINDOWS_2000_BETA_AUTHORITY "Microsoft Windows 2000 Beta"
#define WINDOWS_2000_REAL_AUTHORITY "Microsoft Windows 2000 Publisher"
#define WINDOWS_ME_REAL_AUTHORITY "Microsoft Consumer Windows Publisher"

   
struct LogoFileVersion
{
   DWORD dwProductVersionLS;
   DWORD dwProductVersionMS;
   DWORD dwFileVersionLS;
   DWORD dwFileVersionMS;

   LogoFileVersion();

};

#define pFileVersion *FileVersion



struct CatalogAttribute
{
   TCHAR *Attrib;
   TCHAR *Value;
   void *pNext;

   CatalogAttribute();
   ~CatalogAttribute();
};

class CheckDevice; //forward declaration


class FileNode
{
   friend class CheckDevice;
public:
   LogoFileVersion Version;
   FILETIME TimeStamp;
   ULONG FileSize;   // hope no-one makes a driver that is greater in size than 4-gig
   BYTE  *baHashValue;
   DWORD dwHashSize;
   BOOL  bSigned;

   FileNode *pNext;

   FileNode();
   ~FileNode();

   BOOL         GetCatalogInfo(LPWSTR lpwzCatName, HCATADMIN hCatAdmin, HCATINFO hCatInfo);

   
   BOOL         GetFileInformation(void);
   BOOL         VerifyFile(void);
   BOOL         VerifyIsFileSigned(LPTSTR pcszMatchFile, PDRIVER_VER_INFO lpVerInfo);
   
   TCHAR        *FileName(void)           {return lpszFileName;};
   TCHAR        *FileExt(void)            {return lpszFileExt;};
   //TCHAR        *FilePath(void)           {return lpszFilePath;};
   CString		FilePath() {return lpszFilePath;};
   //TCHAR        *CatalogName(void)        {return lpszCatalogName;};
   CString CatalogName() {return lpszCatalogName;};
   TCHAR        *CatalogPath(void)        {return lpszCatalogPath;};
   
   //TCHAR        *SignedBy(void)           {return lpszSignedBy;};
   CString SignedBy(void)           {return lpszSignedBy;};
//   BOOL         GetCertInfo(PCCERT_CONTEXT pCertContext);


   CatalogAttribute *m_pCatAttrib;
   CheckDevice *pDevnode;


//protected:
   TCHAR *lpszFileName;   // pointer into lpszFilePath which just contains the filename
   TCHAR *lpszFileExt;    // pointer into lpszFilePath which just contains the extention
//   TCHAR *lpszFilePath;
   CString lpszFilePath;
   TCHAR *lpszCatalogPath;     // name of the catalog which has signed this file (if exitst)
   //TCHAR *lpszCatalogName;
   CString lpszCatalogName;
   //TCHAR *lpszSignedBy;    // name of the signer
   CString lpszSignedBy;


};
#define pFileNode *FileNode

class CheckDevice : public InfnodeClass
{
public:
   CheckDevice();
   CheckDevice(DEVNODE hDevice, DEVNODE hParent);
   ~CheckDevice();

   BOOL CreateFileNode(void);
   BOOL CreateFileNode_Class(void);
   BOOL CreateFileNode_Driver(void);
   FileNode * GetFileList (void);
   BOOL AddFileNode(TCHAR *szFileName , UINT uiWin32Error = 0 , LPCTSTR szSigner = NULL);
   BOOL GetServiceNameAndDriver(void);

   TCHAR        *ServiceName(void)        {return lpszServiceName;};
   TCHAR        *ServiceImage(void)       {return lpszServiceImage;};


protected:
   FileNode *m_FileList;
   HANDLE m_hDevInfo;      // this is just to keep the setupapi dll's from coming and going
   TCHAR *lpszServiceName;
   TCHAR *lpszServiceImage;


private:

};

#define pCheckDevice *CheckDevice

BOOL WalkCertChain(HANDLE hWVTStateData);

















#endif // _CHECK_DEVICE_H_


// these lines required by cl.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\dataset.h ===
//=============================================================================
// This file contains the defines useful for defining the dataset of default
// system info to be collected (primarily resource IDs).
//=============================================================================

#pragma once

enum { RESOURCE_DMA = 0, RESOURCE_IRQ, RESOURCE_IO, RESOURCE_MEM, RESOURCE_CONFLICTS, RESOURCE_FORCED };
enum { CODEC_AUDIO = 0, CODEC_VIDEO };

enum {	QUERY_CDROM = 1,
		QUERY_SERVICES,
		QUERY_PROGRAMGROUP,
		QUERY_STARTUP,
		QUERY_KEYBOARD,
		QUERY_POINTDEV,
		QUERY_MODEM,
		QUERY_NETPROT,
		QUERY_ENVVAR,
		QUERY_SOUNDDEV,
		QUERY_DISPLAY,
		QUERY_INFRARED,
		QUERY_PARALLEL,
		QUERY_PRINTER,
		QUERY_NETCONNECTION,
		QUERY_DRIVER,
		QUERY_SIGNEDDRIVER,
		QUERY_IDE,
		QUERY_SCSI,
		QUERY_PRINTJOBS,
		QUERY_NETADAPTER,
		QUERY_SERIALPORT };

extern HRESULT SystemSummary(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT ResourceCategories(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT CODECs(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT SimpleQuery(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT ComponentDrives(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT Winsock(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT Disks(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT ProblemDevices(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT RunningTasks(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT LoadedModules(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT OLERegistration(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT ComponentsUSB(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
extern HRESULT WindowsErrorReporting(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);

#define FIRST_COLUMN_CAPTION_ID		400

#define IDS_VALUE					FIRST_COLUMN_CAPTION_ID + 0
#define IDS_ITEM					FIRST_COLUMN_CAPTION_ID + 1
#define IDS_CREATIONDATE			FIRST_COLUMN_CAPTION_ID + 2
#define IDS_SIZE					FIRST_COLUMN_CAPTION_ID + 3
#define IDS_VERSION					FIRST_COLUMN_CAPTION_ID + 4
#define IDS_FILE					FIRST_COLUMN_CAPTION_ID + 5
#define IDS_STATUS					FIRST_COLUMN_CAPTION_ID + 6
#define IDS_DESCRIPTION				FIRST_COLUMN_CAPTION_ID + 7
#define IDS_MANUFACTURER			FIRST_COLUMN_CAPTION_ID + 8
#define IDS_CODEC					FIRST_COLUMN_CAPTION_ID + 9
#define IDS_DEVICE					FIRST_COLUMN_CAPTION_ID + 10
#define IDS_RESOURCE				FIRST_COLUMN_CAPTION_ID + 12
#define IDS_DISPLAYNAME				FIRST_COLUMN_CAPTION_ID + 13
#define IDS_NAME					FIRST_COLUMN_CAPTION_ID + 14
#define IDS_STATE					FIRST_COLUMN_CAPTION_ID + 15
#define IDS_STARTMODE				FIRST_COLUMN_CAPTION_ID + 16
#define IDS_SERVICETYPE				FIRST_COLUMN_CAPTION_ID + 17
#define IDS_PATH					FIRST_COLUMN_CAPTION_ID + 18
#define IDS_ERRORCONTROL			FIRST_COLUMN_CAPTION_ID + 19
#define IDS_STARTNAME				FIRST_COLUMN_CAPTION_ID + 20
#define IDS_TAGID					FIRST_COLUMN_CAPTION_ID + 21
#define IDS_IRQCHANNEL				FIRST_COLUMN_CAPTION_ID + 22
#define IDS_IOPORT					FIRST_COLUMN_CAPTION_ID + 23
#define IDS_DMACHANNEL				FIRST_COLUMN_CAPTION_ID + 24
#define IDS_MEMORYADDRESS			FIRST_COLUMN_CAPTION_ID + 25
#define IDS_GROUPNAME				FIRST_COLUMN_CAPTION_ID + 26
#define IDS_USERNAME				FIRST_COLUMN_CAPTION_ID + 27
#define IDS_PROGRAM					FIRST_COLUMN_CAPTION_ID + 28
#define IDS_COMMAND					FIRST_COLUMN_CAPTION_ID + 29
#define IDS_LOCATION				FIRST_COLUMN_CAPTION_ID + 30
#define IDS_PNPDEVICEID				FIRST_COLUMN_CAPTION_ID + 31
#define IDS_YES						FIRST_COLUMN_CAPTION_ID + 32
#define IDS_NO						FIRST_COLUMN_CAPTION_ID + 33
#define IDS_VARIABLE				FIRST_COLUMN_CAPTION_ID + 34
#define IDS_PORTNAME				FIRST_COLUMN_CAPTION_ID + 35
#define IDS_SERVERNAME				FIRST_COLUMN_CAPTION_ID + 36
#define IDS_LOCALNAME				FIRST_COLUMN_CAPTION_ID + 37
#define IDS_REMOTENAME				FIRST_COLUMN_CAPTION_ID + 38
#define IDS_TYPE					FIRST_COLUMN_CAPTION_ID + 39
#define IDS_STARTED					FIRST_COLUMN_CAPTION_ID + 40
#define IDS_ACCEPTPAUSE				FIRST_COLUMN_CAPTION_ID + 41
#define IDS_ACCEPTSTOP				FIRST_COLUMN_CAPTION_ID + 42
#define IDS_DRIVER					FIRST_COLUMN_CAPTION_ID + 43
#define IDS_ERRORCODE				FIRST_COLUMN_CAPTION_ID + 44
#define IDS_DOCUMENT				FIRST_COLUMN_CAPTION_ID + 45
#define IDS_OWNER					FIRST_COLUMN_CAPTION_ID + 46
#define IDS_NOTIFY					FIRST_COLUMN_CAPTION_ID + 47
#define IDS_TIMESUBMITTED			FIRST_COLUMN_CAPTION_ID + 49
#define IDS_STARTTIME				FIRST_COLUMN_CAPTION_ID + 50
#define IDS_UNTILTIME				FIRST_COLUMN_CAPTION_ID + 51
#define IDS_ELAPSEDTIME				FIRST_COLUMN_CAPTION_ID + 52
#define IDS_PAGESPRINTED			FIRST_COLUMN_CAPTION_ID + 53
#define IDS_JOBID					FIRST_COLUMN_CAPTION_ID + 54
#define IDS_PRIORITY				FIRST_COLUMN_CAPTION_ID + 55
#define IDS_PARAMETERS				FIRST_COLUMN_CAPTION_ID + 56
#define IDS_PRINTPROCESSOR			FIRST_COLUMN_CAPTION_ID + 57
#define IDS_HOSTPRINTQUEUE			FIRST_COLUMN_CAPTION_ID + 58
#define IDS_DATATYPE				FIRST_COLUMN_CAPTION_ID + 59
#define IDS_PROCESSID				FIRST_COLUMN_CAPTION_ID + 60
#define IDS_MINWORKINGSET			FIRST_COLUMN_CAPTION_ID + 61
#define IDS_MAXWORKINGSET			FIRST_COLUMN_CAPTION_ID + 62
#define IDS_FILEDATE				FIRST_COLUMN_CAPTION_ID + 63
#define IDS_OBJECT					FIRST_COLUMN_CAPTION_ID + 64
#define IDS_LOCALSERVER				FIRST_COLUMN_CAPTION_ID + 65
#define IDS_RESOURCETYPE			FIRST_COLUMN_CAPTION_ID + 66
#define IDS_DEVICETYPE				FIRST_COLUMN_CAPTION_ID + 67
#define IDS_TIME					FIRST_COLUMN_CAPTION_ID + 68
#define IDS_CHANGE					FIRST_COLUMN_CAPTION_ID + 69
#define IDS_DETAILS					FIRST_COLUMN_CAPTION_ID + 70

#define FIRST_QUERY_CAPTION_ID		475

#define IDS_SYSSUMM1				FIRST_QUERY_CAPTION_ID + 1
#define IDS_SYSSUMM2				FIRST_QUERY_CAPTION_ID + 2
#define IDS_SYSSUMM3				FIRST_QUERY_CAPTION_ID + 3
#define IDS_SYSSUMM4				FIRST_QUERY_CAPTION_ID + 4
#define IDS_SYSSUMM5				FIRST_QUERY_CAPTION_ID + 5
#define IDS_SYSSUMM6				FIRST_QUERY_CAPTION_ID + 6
#define IDS_SYSSUMM7				FIRST_QUERY_CAPTION_ID + 7
#define IDS_SYSSUMM8				FIRST_QUERY_CAPTION_ID + 8
#define IDS_SYSSUMM9				FIRST_QUERY_CAPTION_ID + 9
#define IDS_SYSSUMM10				FIRST_QUERY_CAPTION_ID + 10
#define IDS_SYSSUMM11				FIRST_QUERY_CAPTION_ID + 11
#define IDS_SYSSUMM12				FIRST_QUERY_CAPTION_ID + 12
#define IDS_SYSSUMM13				FIRST_QUERY_CAPTION_ID + 13

#define FIRST_CAT_CAPTION_ID		500

#define IDS_SYSTEMSUMMARY0					FIRST_CAT_CAPTION_ID + 0
#define IDS_RESOURCES0						FIRST_CAT_CAPTION_ID + 1
#define IDS_RESOURCESCONFLICTS0				FIRST_CAT_CAPTION_ID + 2
#define IDS_RESOURCESDMA0					FIRST_CAT_CAPTION_ID + 3
#define IDS_RESOURCESFORCEDHARDWARE0		FIRST_CAT_CAPTION_ID + 4
#define IDS_RESOURCESIO0					FIRST_CAT_CAPTION_ID + 5
#define IDS_RESOURCESIRQS0					FIRST_CAT_CAPTION_ID + 6
#define IDS_RESOURCESMEMORY0				FIRST_CAT_CAPTION_ID + 7
#define IDS_COMPONENTS0						FIRST_CAT_CAPTION_ID + 8
#define IDS_COMPONENTSMULTIMEDIA0			FIRST_CAT_CAPTION_ID + 9
#define IDS_COMPONENTSMULTIMEDIAAUDIO0		FIRST_CAT_CAPTION_ID + 10
#define IDS_COMPONENTSMULTIMEDIAVIDEO0		FIRST_CAT_CAPTION_ID + 11
#define IDS_COMPONENTSMULTIMEDIACDROM0		FIRST_CAT_CAPTION_ID + 12
#define IDS_COMPONENTSMULTIMEDIASOUND0		FIRST_CAT_CAPTION_ID + 13
#define IDS_COMPONENTSDISPLAY0				FIRST_CAT_CAPTION_ID + 14
#define IDS_COMPONENTSINFRARED0				FIRST_CAT_CAPTION_ID + 15
#define IDS_COMPONENTSINPUT0				FIRST_CAT_CAPTION_ID + 16
#define IDS_COMPONENTSKEYBOARD0				FIRST_CAT_CAPTION_ID + 17
#define IDS_COMPONENTSPOINTDEV0				FIRST_CAT_CAPTION_ID + 18
#define IDS_COMPONENTSMODEM0				FIRST_CAT_CAPTION_ID + 19
#define IDS_COMPONENTSNETWORK0				FIRST_CAT_CAPTION_ID + 20
#define IDS_COMPONENTSNETADAPTER0			FIRST_CAT_CAPTION_ID + 21
#define IDS_COMPONENTSNETWORKPROTOCOL0		FIRST_CAT_CAPTION_ID + 22
#define IDS_COMPONENTSNETWORKWINSOCK0		FIRST_CAT_CAPTION_ID + 23
#define IDS_COMPONENTSPORTS0				FIRST_CAT_CAPTION_ID + 24
#define IDS_COMPONENTSSERIALPORTS0			FIRST_CAT_CAPTION_ID + 25
#define IDS_COMPONENTSPARALLELPORTS0		FIRST_CAT_CAPTION_ID + 26
#define IDS_COMPONENTSSTORAGE0				FIRST_CAT_CAPTION_ID + 27
#define IDS_COMPONENTSSTORAGEDRIVES0		FIRST_CAT_CAPTION_ID + 28
#define IDS_COMPONENTSSTORAGESCSI0			FIRST_CAT_CAPTION_ID + 29
#define IDS_COMPONENTSPRINTING0				FIRST_CAT_CAPTION_ID + 30
#define IDS_COMPONENTSPROBLEMDEVICES0		FIRST_CAT_CAPTION_ID + 31
#define IDS_COMPONENTSUSB0					FIRST_CAT_CAPTION_ID + 32
#define IDS_SWENV0							FIRST_CAT_CAPTION_ID + 33
#define IDS_SWENVDRIVERS0					FIRST_CAT_CAPTION_ID + 34
#define IDS_SWENVENVVARS0					FIRST_CAT_CAPTION_ID + 35
#define IDS_SWENVJOBS0						FIRST_CAT_CAPTION_ID + 36
#define IDS_SWENVPRINT0						FIRST_CAT_CAPTION_ID + 37
#define IDS_SWENVNETCONN0					FIRST_CAT_CAPTION_ID + 38
#define IDS_SWENVRUNNINGTASKS0				FIRST_CAT_CAPTION_ID + 39
#define IDS_SWENVLOADEDMODULES0				FIRST_CAT_CAPTION_ID + 40
#define IDS_SWENVSERVICES0					FIRST_CAT_CAPTION_ID + 41
#define IDS_SWENVPROGRAMGROUP0				FIRST_CAT_CAPTION_ID + 42
#define IDS_SWENVSTARTUPPROGRAMS0			FIRST_CAT_CAPTION_ID + 43
#define IDS_SWENVOLEREG0					FIRST_CAT_CAPTION_ID + 44
#define IDS_COMPONENTSSTORAGEIDE0			FIRST_CAT_CAPTION_ID + 45
#define IDS_COMPONENTSSTORAGEDISKS0			FIRST_CAT_CAPTION_ID + 46
#define IDS_SWENVSIGNEDDRIVERS0				FIRST_CAT_CAPTION_ID + 47
#define IDS_SWWINERR0						FIRST_CAT_CAPTION_ID + 48
#define IDS_SYSTEMSUMMARYMACHINENAME				FIRST_CAT_CAPTION_ID + 49

#define FIRST_QUERY_ID						550

#define IDS_CDROMCOLUMNS					FIRST_QUERY_ID + 0
#define IDS_SERVICES1						FIRST_QUERY_ID + 1
#define IDS_PROGRAMGROUP1					FIRST_QUERY_ID + 2
#define IDS_STARTUP1						FIRST_QUERY_ID + 3
#define IDS_KEYBOARD1						FIRST_QUERY_ID + 4
#define IDS_POINTDEV1						FIRST_QUERY_ID + 5
#define IDS_MODEM1							FIRST_QUERY_ID + 6
#define IDS_NETPROT1						FIRST_QUERY_ID + 7
#define IDS_ENVVAR1							FIRST_QUERY_ID + 8
#define IDS_SOUNDDEV1						FIRST_QUERY_ID + 9
#define IDS_DISPLAY1						FIRST_QUERY_ID + 10
#define IDS_INFRARED1						FIRST_QUERY_ID + 11
#define IDS_PARALLEL1						FIRST_QUERY_ID + 12
#define IDS_PRINTER1						FIRST_QUERY_ID + 13
#define IDS_NETCONNECTION1					FIRST_QUERY_ID + 14
#define IDS_DRIVER1							FIRST_QUERY_ID + 15
#define IDS_IDE1							FIRST_QUERY_ID + 16
#define IDS_SCSI1							FIRST_QUERY_ID + 17
#define IDS_PRINTJOBS1						FIRST_QUERY_ID + 18
#define IDS_OLE1							FIRST_QUERY_ID + 19
#define IDS_DISKS1							FIRST_QUERY_ID + 20
#define IDS_NETWORKADAPTER1					FIRST_QUERY_ID + 21
#define IDS_NETWORKADAPTER2					FIRST_QUERY_ID + 22
#define IDS_SERIALPORT1						FIRST_QUERY_ID + 23
#define IDS_SERIALPORT2						FIRST_QUERY_ID + 24
#define IDS_DRIVESTYPE2						FIRST_QUERY_ID + 25
#define IDS_DRIVESTYPE3						FIRST_QUERY_ID + 26
#define IDS_DRIVESTYPE4						FIRST_QUERY_ID + 27
#define IDS_WINSOCK1						FIRST_QUERY_ID + 28
#define IDS_DISKS2							FIRST_QUERY_ID + 30
#define IDS_PROBLEMDEVICE1					FIRST_QUERY_ID + 31
#define IDS_LOADEDMODULE1					FIRST_QUERY_ID + 32
#define IDS_OLEREG1							FIRST_QUERY_ID + 33
#define IDS_USB1							FIRST_QUERY_ID + 34
#define IDS_CODEC1							FIRST_QUERY_ID + 35
#define IDS_SIGNEDDRIVER1					FIRST_QUERY_ID + 36

#define IDS_DEVICENAME						FIRST_QUERY_ID + 37
#define IDS_SIGNED							FIRST_QUERY_ID + 38
#define IDS_DEVICECLASS						FIRST_QUERY_ID + 39
#define IDS_DRIVERVERSION					FIRST_QUERY_ID + 40
#define IDS_DRIVERDATE						FIRST_QUERY_ID + 41
#define IDS_INFNAME							FIRST_QUERY_ID + 42
#define IDS_DRIVERNAME						FIRST_QUERY_ID + 43
#define IDS_DEVICEID						FIRST_QUERY_ID + 44

#define IDS_SWWINERR1						FIRST_QUERY_ID + 45
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\dataset.cpp ===
//=============================================================================
// DataSet.cpp contains a declaration of the tree of default data which is
// displayed for the current system information.
//=============================================================================

#include "stdafx.h"
#include "category.h"
#include "dataset.h"

//=============================================================================
// Column Arrays
//=============================================================================

CMSInfoColumn colResource[] = 
{
	CMSInfoColumn(IDS_RESOURCE, 150, TRUE, FALSE),
	CMSInfoColumn(IDS_DEVICE, 300, TRUE, TRUE),
	CMSInfoColumn(IDS_STATUS, 100, TRUE, TRUE),
	CMSInfoColumn()
};

CMSInfoColumn colConflictsSharing[] = 
{
	CMSInfoColumn(IDS_RESOURCE, 250, FALSE, FALSE),
	CMSInfoColumn(IDS_DEVICE, 400, FALSE, FALSE),
	CMSInfoColumn()
};

CMSInfoColumn colRunningTasks[] = 
{
	CMSInfoColumn(IDS_NAME, 120),
	CMSInfoColumn(IDS_PATH, 200),
	CMSInfoColumn(IDS_PROCESSID, 80, TRUE, FALSE, TRUE),
	CMSInfoColumn(IDS_PRIORITY, 60, TRUE, FALSE, TRUE),
	CMSInfoColumn(IDS_MINWORKINGSET, 80, TRUE, FALSE, TRUE),
	CMSInfoColumn(IDS_MAXWORKINGSET, 80, TRUE, FALSE, TRUE),
	CMSInfoColumn(IDS_STARTTIME, 120, TRUE, FALSE, TRUE),
	CMSInfoColumn(IDS_VERSION, 100),
	CMSInfoColumn(IDS_SIZE, 85, TRUE, FALSE),
	CMSInfoColumn(IDS_FILEDATE, 120, TRUE, FALSE),
	CMSInfoColumn()
};

CMSInfoColumn colLoadedModules[] = 
{
	CMSInfoColumn(IDS_NAME, 120),
	CMSInfoColumn(IDS_VERSION, 100),
	CMSInfoColumn(IDS_SIZE, 85, TRUE, FALSE),
	CMSInfoColumn(IDS_FILEDATE, 120, TRUE, FALSE),
	CMSInfoColumn(IDS_MANUFACTURER, 100),
	CMSInfoColumn(IDS_PATH, 200),
	CMSInfoColumn()
};

CMSInfoColumn colItemValue[] = 
{
	CMSInfoColumn(IDS_ITEM, 150, FALSE, FALSE),
	CMSInfoColumn(IDS_VALUE, 450, FALSE, FALSE),
	CMSInfoColumn()
};

CMSInfoColumn colCODEC[] = 
{
	CMSInfoColumn(IDS_CODEC, 200),
	CMSInfoColumn(IDS_MANUFACTURER, 50),
	CMSInfoColumn(IDS_DESCRIPTION, 50),
	CMSInfoColumn(IDS_STATUS, 50),
	CMSInfoColumn(IDS_FILE, 50),
	CMSInfoColumn(IDS_VERSION, 50),
	CMSInfoColumn(IDS_SIZE, 50, TRUE, FALSE),
	CMSInfoColumn(IDS_CREATIONDATE, 50, TRUE, FALSE),
	CMSInfoColumn()
};

CMSInfoColumn colServices[] = 
{
	CMSInfoColumn(IDS_DISPLAYNAME, 150),
	CMSInfoColumn(IDS_NAME, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_STATE, 50),
	CMSInfoColumn(IDS_STARTMODE, 80),
	CMSInfoColumn(IDS_SERVICETYPE, 80),
	CMSInfoColumn(IDS_PATH, 150, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_ERRORCONTROL, 80, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_STARTNAME, 80, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_TAGID, 50, TRUE, TRUE, TRUE),
	CMSInfoColumn()
};

CMSInfoColumn colProgramGroups[] = 
{
	CMSInfoColumn(IDS_GROUPNAME, 200),
	CMSInfoColumn(IDS_NAME, 200),
	CMSInfoColumn(IDS_USERNAME, 150),
	CMSInfoColumn()
};

CMSInfoColumn colStartupPrograms[] = 
{
	CMSInfoColumn(IDS_PROGRAM, 150),
	CMSInfoColumn(IDS_COMMAND, 200),
	CMSInfoColumn(IDS_USERNAME, 100),
	CMSInfoColumn(IDS_LOCATION, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn()
};

CMSInfoColumn colForcedHardware[] = 
{
	CMSInfoColumn(IDS_DEVICE, 200, FALSE),
	CMSInfoColumn(IDS_PNPDEVICEID, 300, FALSE),
	CMSInfoColumn()
};


CMSInfoColumn colEnvVar[] = 
{
	CMSInfoColumn(IDS_VARIABLE, 150),
	CMSInfoColumn(IDS_VALUE, 300),
	CMSInfoColumn(IDS_USERNAME, 100),
	CMSInfoColumn()
};

CMSInfoColumn colPrinting[] = 
{
	CMSInfoColumn(IDS_NAME, 150),
	CMSInfoColumn(IDS_DRIVER, 150),
	CMSInfoColumn(IDS_PORTNAME, 100),
	CMSInfoColumn(IDS_SERVERNAME, 150),
	CMSInfoColumn()
};

CMSInfoColumn colNetConnections[] = 
{
	CMSInfoColumn(IDS_LOCALNAME, 150),
	CMSInfoColumn(IDS_REMOTENAME, 200),
	CMSInfoColumn(IDS_TYPE, 100),
	CMSInfoColumn(IDS_STATUS, 100),
	CMSInfoColumn(IDS_USERNAME, 100),
	CMSInfoColumn()
};

CMSInfoColumn colDrivers[] = 
{
	CMSInfoColumn(IDS_NAME, 150),
	CMSInfoColumn(IDS_DESCRIPTION, 200),
	CMSInfoColumn(IDS_FILE, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_TYPE, 100),
	CMSInfoColumn(IDS_STARTED, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_STARTMODE, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_STATE, 100),
	CMSInfoColumn(IDS_STATUS, 100),
	CMSInfoColumn(IDS_ERRORCONTROL, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_ACCEPTPAUSE, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_ACCEPTSTOP, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn()
};

CMSInfoColumn colSignedDrivers[] = 
{
	CMSInfoColumn(IDS_DEVICENAME, 150),
	CMSInfoColumn(IDS_SIGNED, 50),
	CMSInfoColumn(IDS_DEVICECLASS, 75),
	CMSInfoColumn(IDS_DRIVERVERSION, 80),
	CMSInfoColumn(IDS_DRIVERDATE, 80),
	CMSInfoColumn(IDS_MANUFACTURER, 150),
	CMSInfoColumn(IDS_INFNAME, 75),
	CMSInfoColumn(IDS_DRIVERNAME, 80),
	CMSInfoColumn(IDS_DEVICEID, 150),
	CMSInfoColumn()
};

CMSInfoColumn colProblemDevices[] = 
{
	CMSInfoColumn(IDS_DEVICE, 150),
	CMSInfoColumn(IDS_PNPDEVICEID, 200),
	CMSInfoColumn(IDS_ERRORCODE, 100),
	CMSInfoColumn()
};

CMSInfoColumn colPrintJobs[] = 
{
	CMSInfoColumn(IDS_DOCUMENT, 120),
	CMSInfoColumn(IDS_SIZE, 60),
	CMSInfoColumn(IDS_OWNER, 60),
	CMSInfoColumn(IDS_NOTIFY, 60, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_STATUS, 60),
	CMSInfoColumn(IDS_TIMESUBMITTED, 60),
	CMSInfoColumn(IDS_STARTTIME, 60, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_UNTILTIME, 60, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_ELAPSEDTIME, 60, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_PAGESPRINTED, 60),
	CMSInfoColumn(IDS_JOBID, 40, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_PRIORITY, 40, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_PARAMETERS, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_DRIVER, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_PRINTPROCESSOR, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_HOSTPRINTQUEUE, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_DATATYPE, 80, TRUE, TRUE, TRUE),
	CMSInfoColumn(IDS_NAME, 100, TRUE, TRUE, TRUE),
	CMSInfoColumn()
};

CMSInfoColumn colComponentsUSB[] = 
{
	CMSInfoColumn(IDS_DEVICE, 200),
	CMSInfoColumn(IDS_PNPDEVICEID, 300),
	CMSInfoColumn()
};

CMSInfoColumn colOLE[] = 
{
	CMSInfoColumn(IDS_OBJECT, 200),
	CMSInfoColumn(IDS_LOCALSERVER, 300),
	CMSInfoColumn()
};

CMSInfoColumn colWinErr[] = 
{
	CMSInfoColumn(IDS_TIME, 130),
	CMSInfoColumn(IDS_TYPE, 100),
	CMSInfoColumn(IDS_DETAILS, 350),
	CMSInfoColumn()
};

//=============================================================================
// Categories
//=============================================================================

#define REFRESHFUNC		NULL
#define EMPTYCATEGORY	0
#define DOESNTMATTER	0
#define REFRESHINDEX	0
#define COLUMNPTR		NULL

CMSInfoLiveCategory catSystemSummary(IDS_SYSTEMSUMMARY0, _T("SystemSummary"), &SystemSummary, DOESNTMATTER, NULL, NULL, _T("msinfo_system_summary.htm"), colItemValue, FALSE);
CMSInfoLiveCategory catResources(IDS_RESOURCES0, _T("Resources"), EMPTYCATEGORY, EMPTYCATEGORY, &catSystemSummary, NULL, _T("msinfo_hardware_resources.htm"), COLUMNPTR, FALSE);
CMSInfoLiveCategory catResourcesConflicts(IDS_RESOURCESCONFLICTS0, _T("ResourcesConflicts"), &ResourceCategories, RESOURCE_CONFLICTS, &catResources, NULL, _T("msinfo_conflicts_sharing.htm"), colConflictsSharing, FALSE);
CMSInfoLiveCategory catResourcesDMA(IDS_RESOURCESDMA0, _T("ResourcesDMA"), &ResourceCategories, RESOURCE_DMA, &catResources, &catResourcesConflicts, _T("msinfo_DMA.htm"), colResource, FALSE);
CMSInfoLiveCategory catResourcesForcedHardware(IDS_RESOURCESFORCEDHARDWARE0, _T("ResourcesForcedHardware"), &ResourceCategories, RESOURCE_FORCED, &catResources, &catResourcesDMA, _T("msinfo_forced_hardware.htm"), colForcedHardware, FALSE);
CMSInfoLiveCategory catResourcesIO(IDS_RESOURCESIO0, _T("ResourcesIO"), &ResourceCategories, RESOURCE_IO, &catResources, &catResourcesForcedHardware, _T("msinfo_IO.htm"), colResource, FALSE);
CMSInfoLiveCategory catResourcesIRQs(IDS_RESOURCESIRQS0, _T("ResourcesIRQs"), &ResourceCategories, RESOURCE_IRQ, &catResources, &catResourcesIO, _T("msinfo_irqs.htm"), colResource, FALSE);
CMSInfoLiveCategory catResourcesMemory(IDS_RESOURCESMEMORY0, _T("ResourcesMemory"), &ResourceCategories, RESOURCE_MEM, &catResources, &catResourcesIRQs, _T("msinfo_memory.htm"), colResource, FALSE);
CMSInfoLiveCategory catComponents(IDS_COMPONENTS0, _T("Components"), EMPTYCATEGORY, EMPTYCATEGORY, &catSystemSummary, &catResources, _T("msinfo_components.htm"), COLUMNPTR, FALSE);
CMSInfoLiveCategory catComponentsMultimedia(IDS_COMPONENTSMULTIMEDIA0, _T("ComponentsMultimedia"), EMPTYCATEGORY, EMPTYCATEGORY, &catComponents, NULL, _T("msinfo_multimedia.htm"), COLUMNPTR, FALSE);
CMSInfoLiveCategory catComponentsMultimediaAudio(IDS_COMPONENTSMULTIMEDIAAUDIO0, _T("ComponentsMultimediaAudio"), &CODECs, CODEC_AUDIO, &catComponentsMultimedia, NULL, _T(""), colCODEC, FALSE);
CMSInfoLiveCategory catComponentsMultimediaVideo(IDS_COMPONENTSMULTIMEDIAVIDEO0, _T("ComponentsMultimediaVideo"), &CODECs, CODEC_VIDEO, &catComponentsMultimedia, &catComponentsMultimediaAudio, _T(""), colCODEC, FALSE);
CMSInfoLiveCategory catComponentsMultimediaCDROM(IDS_COMPONENTSMULTIMEDIACDROM0, _T("ComponentsMultimediaCDROM"), &SimpleQuery, QUERY_CDROM, &catComponents, &catComponentsMultimedia, _T("msinfo_cdrom.htm"), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsMultimediaSound(IDS_COMPONENTSMULTIMEDIASOUND0, _T("ComponentsMultimediaSound"), &SimpleQuery, QUERY_SOUNDDEV, &catComponents, &catComponentsMultimediaCDROM, _T("msinfo_sound_device.htm"), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsDisplay(IDS_COMPONENTSDISPLAY0, _T("ComponentsDisplay"), &SimpleQuery, QUERY_DISPLAY, &catComponents, &catComponentsMultimediaSound, _T("msinfo_display.htm"), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsInfrared(IDS_COMPONENTSINFRARED0, _T("ComponentsInfrared"), &SimpleQuery, QUERY_INFRARED, &catComponents, &catComponentsDisplay, _T("msinfo_infrared.htm"), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsInput(IDS_COMPONENTSINPUT0, _T("ComponentsInput"), EMPTYCATEGORY, EMPTYCATEGORY, &catComponents, &catComponentsInfrared, _T("msinfo_input.htm"), COLUMNPTR, FALSE);
CMSInfoLiveCategory catComponentsKeyboard(IDS_COMPONENTSKEYBOARD0, _T("ComponentsKeyboard"), &SimpleQuery, QUERY_KEYBOARD, &catComponentsInput, NULL, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsPointDev(IDS_COMPONENTSPOINTDEV0, _T("ComponentsPointDev"), &SimpleQuery, QUERY_POINTDEV, &catComponentsInput, &catComponentsKeyboard, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsModem(IDS_COMPONENTSMODEM0, _T("ComponentsModem"), &SimpleQuery, QUERY_MODEM, &catComponents, &catComponentsInput, _T("msinfo_modem.htm"), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsNetwork(IDS_COMPONENTSNETWORK0, _T("ComponentsNetwork"), EMPTYCATEGORY, EMPTYCATEGORY, &catComponents, &catComponentsModem, _T("msinfo_network.htm"), COLUMNPTR, FALSE);
CMSInfoLiveCategory catComponentsNetAdapter(IDS_COMPONENTSNETADAPTER0, _T("ComponentsNetAdapter"), &SimpleQuery, QUERY_NETADAPTER, &catComponentsNetwork, NULL, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsNetworkProtocol(IDS_COMPONENTSNETWORKPROTOCOL0, _T("ComponentsNetworkProtocol"), &SimpleQuery, QUERY_NETPROT, &catComponentsNetwork, &catComponentsNetAdapter, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsNetworkWinSock(IDS_COMPONENTSNETWORKWINSOCK0, _T("ComponentsNetworkWinSock"), &Winsock, DOESNTMATTER, &catComponentsNetwork, &catComponentsNetworkProtocol, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsPorts(IDS_COMPONENTSPORTS0, _T("ComponentsPorts"), EMPTYCATEGORY, EMPTYCATEGORY, &catComponents, &catComponentsNetwork, _T("msinfo_ports.htm"), COLUMNPTR, FALSE);
CMSInfoLiveCategory catComponentsSerialPorts(IDS_COMPONENTSSERIALPORTS0, _T("ComponentsSerialPorts"), &SimpleQuery, QUERY_SERIALPORT, &catComponentsPorts, NULL, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsParallelPorts(IDS_COMPONENTSPARALLELPORTS0, _T("ComponentsParallelPorts"), &SimpleQuery, QUERY_PARALLEL, &catComponentsPorts, &catComponentsSerialPorts, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsStorage(IDS_COMPONENTSSTORAGE0, _T("ComponentsStorage"), EMPTYCATEGORY, EMPTYCATEGORY, &catComponents, &catComponentsPorts, _T("msinfo_storage.htm"), COLUMNPTR, FALSE);
CMSInfoLiveCategory catComponentsStorageDrives(IDS_COMPONENTSSTORAGEDRIVES0, _T("ComponentsStorageDrives"), &ComponentDrives, DOESNTMATTER, &catComponentsStorage, NULL, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsStorageDisks(IDS_COMPONENTSSTORAGEDISKS0, _T("ComponentsStorageDisks"), &Disks, DOESNTMATTER, &catComponentsStorage, &catComponentsStorageDrives, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsStorageSCSI(IDS_COMPONENTSSTORAGESCSI0, _T("ComponentsStorageSCSI"), &SimpleQuery, QUERY_SCSI, &catComponentsStorage, &catComponentsStorageDisks, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsStorageIDE(IDS_COMPONENTSSTORAGEIDE0, _T("ComponentsStorageIDE"), &SimpleQuery, QUERY_IDE, &catComponentsStorage, &catComponentsStorageSCSI, _T(""), colItemValue, FALSE);
CMSInfoLiveCategory catComponentsPrinting(IDS_COMPONENTSPRINTING0, _T("ComponentsPrinting"), &SimpleQuery, QUERY_PRINTER, &catComponents, &catComponentsStorage, _T("msinfo_printing.htm"), colPrinting, FALSE);
CMSInfoLiveCategory catComponentsProblemDevices(IDS_COMPONENTSPROBLEMDEVICES0, _T("ComponentsProblemDevices"), &ProblemDevices, DOESNTMATTER, &catComponents, &catComponentsPrinting, _T("msinfo_problem_devices.htm"), colProblemDevices, FALSE);
CMSInfoLiveCategory catComponentsUSB(IDS_COMPONENTSUSB0, _T("ComponentsUSB"), &ComponentsUSB, DOESNTMATTER, &catComponents, &catComponentsProblemDevices, _T("msinfo_usb.htm"), colComponentsUSB, FALSE);
CMSInfoLiveCategory catSWEnv(IDS_SWENV0, _T("SWEnv"), EMPTYCATEGORY, EMPTYCATEGORY, &catSystemSummary, &catComponents, _T("msinfo_software_environment.htm"), COLUMNPTR, FALSE);
CMSInfoLiveCategory catSWEnvDrivers(IDS_SWENVDRIVERS0, _T("SWEnvDrivers"), &SimpleQuery, QUERY_DRIVER, &catSWEnv, NULL, _T("msinfo_drivers.htm"), colDrivers, FALSE);
CMSInfoLiveCategory catSWEnvSignedDrivers(IDS_SWENVSIGNEDDRIVERS0, _T("SWEnvSignedDrivers"), &SimpleQuery, QUERY_SIGNEDDRIVER, &catSWEnv, &catSWEnvDrivers, _T("msinfo_cert_drivers.htm"), colSignedDrivers, FALSE);
CMSInfoLiveCategory catSWEnvEnvVars(IDS_SWENVENVVARS0, _T("SWEnvEnvVars"), &SimpleQuery, QUERY_ENVVAR, &catSWEnv, &catSWEnvSignedDrivers, _T("msinfo_environment_variables.htm"), colEnvVar, FALSE);
CMSInfoLiveCategory catSWEnvPrint(IDS_SWENVPRINT0, _T("SWEnvPrint"), &SimpleQuery, QUERY_PRINTJOBS, &catSWEnv, &catSWEnvEnvVars, _T("msinfo_print_jobs.htm"), colPrintJobs, FALSE);
CMSInfoLiveCategory catSWEnvNetConn(IDS_SWENVNETCONN0, _T("SWEnvNetConn"), &SimpleQuery, QUERY_NETCONNECTION, &catSWEnv, &catSWEnvPrint, _T("msinfo_network_connections.htm"), colNetConnections, FALSE);
CMSInfoLiveCategory catSWEnvRunningTasks(IDS_SWENVRUNNINGTASKS0, _T("SWEnvRunningTasks"), &RunningTasks, DOESNTMATTER, &catSWEnv, &catSWEnvNetConn, _T("msinfo_running_tasks.htm"), colRunningTasks, FALSE);
CMSInfoLiveCategory catSWEnvLoadedModules(IDS_SWENVLOADEDMODULES0, _T("SWEnvLoadedModules"), &LoadedModules, DOESNTMATTER, &catSWEnv, &catSWEnvRunningTasks, _T("msinfo_loaded_modules.htm"), colLoadedModules, FALSE);
CMSInfoLiveCategory catSWEnvServices(IDS_SWENVSERVICES0, _T("SWEnvServices"), &SimpleQuery, QUERY_SERVICES, &catSWEnv, &catSWEnvLoadedModules, _T("msinfo_services.htm"), colServices, FALSE, NT_ONLY);
CMSInfoLiveCategory catSWEnvProgramGroup(IDS_SWENVPROGRAMGROUP0, _T("SWEnvProgramGroup"), &SimpleQuery, QUERY_PROGRAMGROUP, &catSWEnv, &catSWEnvServices, _T("msinfo_program_groups.htm"), colProgramGroups, FALSE);
CMSInfoLiveCategory catSWEnvStartupPrograms(IDS_SWENVSTARTUPPROGRAMS0, _T("SWEnvStartupPrograms"), &SimpleQuery, QUERY_STARTUP, &catSWEnv, &catSWEnvProgramGroup, _T("msinfo_startup_programs.htm"), colStartupPrograms, FALSE);
CMSInfoLiveCategory catSWEnvOLEReg(IDS_SWENVOLEREG0, _T("SWEnvOLEReg"), &OLERegistration, DOESNTMATTER, &catSWEnv, &catSWEnvStartupPrograms, _T("msinfo_ole_registration.htm"), colOLE, FALSE);
CMSInfoLiveCategory catSWEnvWinErr(IDS_SWWINERR0, _T("SWEnvWindowsError"), &WindowsErrorReporting, DOESNTMATTER, &catSWEnv, &catSWEnvOLEReg, _T("msinfo_error_reporting.htm"), colWinErr, FALSE);

//=============================================================================
// History Categories and Columns
//=============================================================================

CMSInfoColumn colHistorySystemSummary[] = 
{
	CMSInfoColumn(IDS_TIME, 75, TRUE, FALSE),
	CMSInfoColumn(IDS_CHANGE, 75, TRUE, TRUE),
	CMSInfoColumn(IDS_NAME, 100, TRUE, TRUE),
	CMSInfoColumn(IDS_DETAILS, 300, TRUE, TRUE),
	CMSInfoColumn()
};

CMSInfoColumn colHistoryResources[] = 
{
	CMSInfoColumn(IDS_TIME, 75, TRUE, FALSE),
	CMSInfoColumn(IDS_CHANGE, 75, TRUE, TRUE),
	CMSInfoColumn(IDS_NAME, 100, TRUE, TRUE),
	CMSInfoColumn(IDS_DETAILS, 300, TRUE, TRUE),
	CMSInfoColumn(IDS_RESOURCETYPE, 100, TRUE, TRUE),
	CMSInfoColumn()
};

CMSInfoColumn colHistoryComponents[] = 
{
	CMSInfoColumn(IDS_TIME, 75, TRUE, FALSE),
	CMSInfoColumn(IDS_CHANGE, 75, TRUE, TRUE),
	CMSInfoColumn(IDS_NAME, 100, TRUE, TRUE),
	CMSInfoColumn(IDS_DETAILS, 300, TRUE, TRUE),
	CMSInfoColumn(IDS_DEVICETYPE, 100, TRUE, TRUE),
	CMSInfoColumn()
};

CMSInfoColumn colHistorySWEnv[] = 
{
	CMSInfoColumn(IDS_TIME, 75, TRUE, FALSE),
	CMSInfoColumn(IDS_CHANGE, 75, TRUE, TRUE),
	CMSInfoColumn(IDS_NAME, 100, TRUE, TRUE),
	CMSInfoColumn(IDS_DETAILS, 300, TRUE, TRUE),
	CMSInfoColumn(IDS_TYPE, 100, TRUE, TRUE),
	CMSInfoColumn()
};

CMSInfoHistoryCategory catHistorySystemSummary(IDS_SYSTEMSUMMARY0, _T("SystemSummary"), NULL, NULL, colHistorySystemSummary, FALSE);
CMSInfoHistoryCategory catHistoryResources(IDS_RESOURCES0, _T("Resources"), &catHistorySystemSummary, NULL, colHistoryResources, FALSE);
CMSInfoHistoryCategory catHistoryComponents(IDS_COMPONENTS0, _T("Components"), &catHistorySystemSummary, &catHistoryResources, colHistoryComponents, FALSE);
CMSInfoHistoryCategory catHistorySWEnv(IDS_SWENV0, _T("SWEnv"), &catHistorySystemSummary, &catHistoryComponents, colHistorySWEnv, FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\datasource.h ===
//=============================================================================
// The CDataSource class encapsulates a data source, which might be live data
// from WMI, data saved in an NFO file, or data from XML.
//=============================================================================

#pragma once

#include "category.h"
#include "refreshthread.h"
#include "xmlobject.h"
extern CMSInfoHistoryCategory catHistorySystemSummary;
//-----------------------------------------------------------------------------
// CDataSource is a base class for the actual data sources.
//-----------------------------------------------------------------------------

class CDataSource
{
public:
	CDataSource() : m_pRoot(NULL), m_fStaticTree(FALSE) {};
	
	virtual ~CDataSource() 
	{ 
		if (m_pRoot)
		{
			RemoveTree(m_pRoot);
			m_pRoot = NULL;
		}

	};
	
	virtual CMSInfoCategory * GetRootCategory() 
	{ 
		return m_pRoot; 
	};

	virtual HTREEITEM GetNodeByName(LPCTSTR szName, CMSInfoCategory * pLookFrom = NULL)
	{
		CMSInfoCategory * pRoot = pLookFrom;

		if (pRoot == NULL)
			pRoot = GetRootCategory();

		if (pRoot)
		{
			CString strName;
			pRoot->GetNames(NULL, &strName);
			if (strName.CompareNoCase(CString(szName)) == 0)
				return pRoot->GetHTREEITEM();
		}

		for (CMSInfoCategory * pChild = pRoot->GetFirstChild(); pChild;)
		{
			HTREEITEM hti = GetNodeByName(szName, pChild);

			if (hti)
				return hti;

			pChild = pChild->GetNextSibling();
		}

		return NULL;
	};

protected:
	void RemoveTree(CMSInfoCategory * pCategory)
	{
		if (pCategory)
		{
			for (CMSInfoCategory * pChild = pCategory->GetFirstChild(); pChild;)
			{
				CMSInfoCategory * pNext = pChild->GetNextSibling();
				RemoveTree(pChild);
				pChild = pNext;
			}

			// If the tree is static, then don't actually delete, just reset
			// some state variables (possibly).

			if (m_fStaticTree)
				pCategory->ResetCategory();
			else
				delete pCategory;
		}
	}

	CMSInfoCategory *	m_pRoot;			// root of the category tree
	BOOL				m_fStaticTree;		// the tree shouldn't be deleted
};

//-----------------------------------------------------------------------------
// CLiveDataSource provides current system information from WMI.
//-----------------------------------------------------------------------------

class CLiveDataSource : public CDataSource
{
public:
	CLiveDataSource();
	virtual ~CLiveDataSource();

	virtual HRESULT Create(LPCTSTR szMachine, HWND hwnd, LPCTSTR szFilter = NULL);
	virtual void	LockData()   { if (m_pThread) m_pThread->EnterCriticalSection(); };
	virtual void	UnlockData() { if (m_pThread) m_pThread->LeaveCriticalSection(); };
	virtual void	WaitForRefresh() { if (m_pThread) m_pThread->WaitForRefresh(); };
	virtual BOOL	InRefresh() { if (m_pThread) return m_pThread->IsRefreshing(); return FALSE; };
	void			SetMachineForCategories(CMSInfoLiveCategory * pCategory);

	virtual CMSInfoCategory * GetRootCategory() { return ((m_iDeltaIndex == -1) ? m_pRoot : m_pHistoryRoot); };
	virtual BOOL	GetDeltaList(CStringList * pstrlist);
	virtual BOOL	ShowDeltas(int iDeltaIndex);
	virtual HRESULT ValidDataSource();

private:
	void					AddExtensions();
	void					GetExtensionSet(CStringList & strlistExtensions);
	void					ConvertVersion5Categories(CMapWordToPtr & mapVersion5Categories, DWORD dwRootID, CMSInfoLiveCategory * m_pRoot);
	CMSInfoLiveCategory *	GetNodeByName(const CString & strSearch, CMSInfoLiveCategory * pRoot);
	CMSInfoLiveCategory *	MakeVersion6Category(INTERNAL_CATEGORY * pCategory5);
	void					ApplyCategoryFilter(LPCTSTR szFilter);

	
public:
	CComPtr<IStream>			m_pHistoryStream;
//protected:
	CComPtr<IXMLDOMDocument>	m_pXMLDoc;
	CComPtr<IXMLDOMDocument>	m_pXMLFileDoc;
	CComPtr<IXMLDOMDocument>	m_pXMLLiveDoc;
public:

	//-------------------------------------------------------------------------
	// Get the XML document (this will be requested by the nodes displaying
	// history). In a test build, this may be loaded from a file; in release
	// builds this will be created from the history stream
	// if szpathName is not null (it's default value is null), use it to create BSTR argument for m_pXMLDoc->load
	// (to open XML file); otherwise open from DCO stream
	//-------------------------------------------------------------------------

	CComPtr<IXMLDOMDocument> GetXMLDoc()
	{
		return m_pXMLDoc;
	}

	HRESULT LoadXMLDoc(LPCTSTR szpathName) 
	{
		m_pXMLFileDoc = CreateXMLDoc(szpathName);
		if (m_pXMLFileDoc)
		{
			m_pXMLDoc = m_pXMLFileDoc;
			return S_OK;
		}
		else
		{
			return E_FAIL;
		}

	}
	CComPtr<IXMLDOMDocument> CreateXMLDoc(LPCTSTR szpathName = NULL) 
	{
		CComPtr<IXMLDOMDocument> pXMLDoc;
		if ((m_pHistoryStream || szpathName))
		{
			HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&pXMLDoc);
			if (SUCCEEDED(hr))
			{
				if (szpathName != NULL)
				{
					VARIANT_BOOL varBSuccess;
					COleVariant bstrPath = szpathName;
					if (FAILED(pXMLDoc->load(bstrPath, &varBSuccess)) || varBSuccess == FALSE)
					{
						pXMLDoc.Release();
						pXMLDoc = NULL;
					}
				}
				else
				{
					VARIANT_BOOL varBSuccess;		
					CComVariant varStream(m_pHistoryStream);
					if (FAILED(pXMLDoc->load(varStream, &varBSuccess)) || !varBSuccess)
					{
						ASSERT(0 && "Failed to load xml doc from stream");
						pXMLDoc.Release();
						pXMLDoc = NULL;
					}	
				}
			}
		}

		return pXMLDoc; 
	}

	//-------------------------------------------------------------------------
	//switch from XML doc loaded from file to doc created from DCO stream
	//-------------------------------------------------------------------------
	void RevertToLiveXML()
	{
		m_pXMLDoc = m_pXMLLiveDoc;
	}
	//-------------------------------------------------------------------------
	// Sets the history stream (which is generated by the DCO and is used to
	// show deltas).
	//-------------------------------------------------------------------------

	void SetHistoryStream(CComPtr<IStream> pHistoryStream)
	{
		m_pHistoryStream = pHistoryStream;
		try
		{
			m_pXMLLiveDoc = this->CreateXMLDoc();
		}
		catch(COleException * pException)
		{
			pException->ReportError();
			pException->Delete();
		}
		catch(...)
		{

		}
		m_pXMLDoc = m_pXMLLiveDoc;
		
	}

public:
	CRefreshThread *			m_pThread;
	int							m_iDeltaIndex;
protected:
	CMSInfoHistoryCategory *	m_pHistoryRoot;
private:
	CString						m_strMachine;
	

public:
	HWND						m_hwnd;
};

//-----------------------------------------------------------------------------
// CXMLDataSource provides system information from an XML snapshot. It derives
// from CLiveDataSource because much of the functionality is the same (the
// same categories, refresh functions, delta display, etc.).
//-----------------------------------------------------------------------------
class CXMLSnapshotCategory;
class CXMLDataSource : public CLiveDataSource
{
private:
//	CComPtr<IXMLDOMDocument> m_pXMLDoc; CLiveDataSource has m_pXMLDoc member
	//CComPtr<IXMLDOMNode>	m_pSnapshotNode;
public:
	CXMLDataSource() {};
	~CXMLDataSource() {};
	HRESULT Create(LPCTSTR szMachine) { return S_OK; };
	HRESULT Create(CString strFileName, CMSInfoLiveCategory* pRootLiveCat, HWND hwnd);
	HRESULT Refresh(CXMLSnapshotCategory* pCat);
	
};

//-----------------------------------------------------------------------------
// CNFO6DataSource provides information from a 5.0/6.0 NFO file.
//-----------------------------------------------------------------------------

class CNFO6DataSource : public CDataSource
{
public:
	CNFO6DataSource();
	~CNFO6DataSource();

	HRESULT Create(HANDLE h, LPCTSTR szFilename = NULL);
};

//-----------------------------------------------------------------------------
// CNFO7DataSource provides information from a 7.0 NFO file.
//-----------------------------------------------------------------------------

class CNFO7DataSource : public CDataSource
{
public:
	CNFO7DataSource();
	~CNFO7DataSource();

	HRESULT Create(LPCTSTR szFilename = NULL);
};

class CMSIControl;
class CMSInfo4Category;
class CNFO4DataSource : public CDataSource
{
public:
    
	CNFO4DataSource();
	~CNFO4DataSource();
   // HRESULT RecurseLoad410Tree(CMSInfo4Category** ppRoot, CComPtr<IStream> pStream,CComPtr<IStorage> pStorage,CMapStringToString&	mapStreams);
    //HRESULT ReadMSI4NFO(CString strFileName/*HANDLE hFile*/,CMSInfo4Category** ppRootCat);

	HRESULT Create(CString strFileName);
    void AddControlMapping(CString strCLSID, CMSIControl* pControl)
    {
        m_mapCLSIDToControl.SetAt(strCLSID, pControl);
    }
    BOOL GetControlFromCLSID(CString strCLSID,CMSIControl*& pControl)
    {
        return m_mapCLSIDToControl.Lookup(strCLSID,(void*&)pControl);
    }
    void UpdateCurrentControl(CMSIControl* pControl);
protected:
    CMapStringToPtr m_mapCLSIDToControl;
    CMSIControl* m_pCurrentControl;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\devnode.cpp ===
// devnode.cpp0
#include "stdafx.h"
#include "devnode.h"

// globals from alcclass
AutoListClass *pALCHead          = NULL;
AutoListClass *pALCTail          = NULL;
int           AutoListClassCount = NULL;


/*******************************************************************
   Constructiors
*******************************************************************/


DevnodeClass::DevnodeClass(DEVNODE hDevice, DEVNODE l_hParent)
{
   pDeviceID       = NULL;
   hDevnode        = hDevice;
   hParent         = l_hParent;
   pszDescription = NULL;
   ulProblemCode   = (ULONG)    -1;
   ulStatus        = 0;
   pszClass        = NULL;
   bDNHasMark      = (BOOL)-1;
   bCanDisable     = FALSE;
   bCanTest        = FALSE;
   bDidPass        = FALSE;
   pHardwareID     = NULL;
   pCompatID       = NULL;
   pszGUID         = NULL;
   pszLocation     = NULL;
   pszPDO          = NULL; 
   pszFriendlyName = NULL;
   pszMFG          = NULL;
   InterfaceBusType = InterfaceTypeUndefined;
   GetDeviceInformation();

}

DevnodeClass::DevnodeClass(void)
{
   pDeviceID       = NULL;
   hDevnode        = 0;
   hParent         = 0;
   pszDescription = NULL;
   ulProblemCode   = (ULONG)   -1;
   ulStatus        = 0;
   pszClass        = NULL;
   bDNHasMark      = (BOOL)-1;
   bCanDisable     = FALSE;
   bCanTest        = FALSE;
   bDidPass        = FALSE;
   pHardwareID     = NULL;
   pCompatID       = NULL;
   pszGUID         = NULL;
   pszLocation     = NULL;
   pszPDO          = NULL;
   pszFriendlyName = NULL;
   pszMFG          = NULL;
   InterfaceBusType = InterfaceTypeUndefined;

}

DevnodeClass::~DevnodeClass()
{
   hDevnode = -1;
   ulProblemCode = (ULONG) -1;
   ulStatus = (ULONG)-1;
   bDNHasMark = (BOOL)-1;
   InterfaceBusType = InterfaceTypeUndefined;
   bCanDisable     = FALSE;
   bCanTest        = FALSE;
   bDidPass        = FALSE;


   if ( pDeviceID )
   {
      delete pDeviceID;
      pDeviceID = NULL;
   }
   if ( pszClass )
   {
      delete pszClass;
      pszClass = NULL;
   }
   if ( pszDescription )
   {
      delete pszDescription;
      pszDescription = NULL;
   }
   if ( pszFriendlyName )
   {
      delete pszFriendlyName;
      pszFriendlyName = NULL;
   }
   if ( pszGUID )
   {
      delete pszGUID;
      pszGUID = NULL;
   }
   if ( pszLocation )
   {
      delete pszLocation;
      pszLocation = NULL;
   }
   if ( pszPDO )
   {
      delete pszPDO;
      pszPDO = NULL;
   }
   if ( pszMFG )
   {
      delete pszMFG;
      pszMFG = NULL;
   }
   if ( pHardwareID )
   {
      delete pHardwareID;
      pHardwareID = NULL;
   }

   if ( pCompatID )
   {
      delete pCompatID;
      pCompatID = NULL;
   }

}

/*******************************************************************
   Member Functions
*******************************************************************/

BOOL DevnodeClass::SetHandle(DEVNODE Devnode, DEVNODE Parent)
{
   hDevnode = -1;
   ulProblemCode = (ULONG) -1;
   ulStatus = (ULONG)-1;
   bDNHasMark = (BOOL)-1;
   InterfaceBusType = InterfaceTypeUndefined;
   bCanDisable     = FALSE;
   bCanTest        = FALSE;
   bDidPass        = FALSE;


   if ( pDeviceID )
   {
      delete pDeviceID;
      pDeviceID = NULL;
   }
   if ( pszClass )
   {
      delete pszClass;
      pszClass = NULL;
   }
   if ( pszDescription )
   {
      delete pszDescription;
      pszDescription = NULL;
   }
   if ( pszFriendlyName )
   {
      delete pszFriendlyName;
      pszFriendlyName = NULL;
   }
   if ( pszGUID )
   {
      delete pszGUID;
      pszGUID = NULL;
   }
   if ( pszLocation )
   {
      delete pszLocation;
      pszLocation = NULL;
   }
   if ( pszPDO )
   {
      delete pszPDO;
      pszPDO = NULL;
   }
   if ( pszMFG )
   {
      delete pszMFG;
      pszMFG = NULL;
   }
   if ( pHardwareID )
   {
      delete pHardwareID;
      pHardwareID = NULL;
   }

   if ( pCompatID )
   {
      delete pCompatID;
      pCompatID = NULL;
   }


   hDevnode = Devnode;
   hParent = Parent;
   return (GetDeviceInformation());
}

/****************************************************************************
GetDeviceInformation

  find information about devnode
  modifies this, members in DevnodeClass
*****************************************************************************/
CONFIGRET DevnodeClass::GetDeviceInformation (void)
{
   CONFIGRET retval;
   ULONG ulSize;

   // check to see that we have a devnode handle

   if ( !hDevnode )
   {
      return (CR_NO_SUCH_DEVNODE);
   }
   if ( !hParent )
   {
      DEVNODE hParentDevnode;
      if ( !GetParent(&hParentDevnode) )
      {
         hParent = hParentDevnode;
      }
   }

/**********
    Get Device ID
***********/
   retval = CM_Get_Device_ID_Size (&ulSize, hDevnode, 0L);
   if ( retval )  return(retval);

   pDeviceID = new TCHAR [++ulSize]; // add one for terminating NULL
   if ( !pDeviceID )  return(CR_OUT_OF_MEMORY);

   retval = CM_Get_Device_ID (hDevnode, 
                              pDeviceID,
                              ulSize, //is null terminated?!?
                              0L);
   if ( retval )  return(retval);




/**********
    Get device description/friendly name
***********/

   ulSize = 0;
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_DEVICEDESC,
                                              NULL,
                                              NULL,
                                              &ulSize,
                                              0);

   if ( retval )
      if ( (retval == CR_BUFFER_SMALL) )
      {
         //if ( bVerbose )
         //   logprintf ("Still Having trouble with  CM_Get_DevNode_Registry_Property returning CR_BUFFER_TOO_SMALL\r\n"
         //              "When trying to get the size of the Device description\r\n");
         ulSize = 511;
      }
      else
         return(retval);

   pszDescription = new TCHAR [ulSize+1];
   if ( !pszDescription ) return(CR_OUT_OF_MEMORY);

   //Now get value
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_DEVICEDESC,
                                              NULL,
                                              pszDescription,
                                              &ulSize,
                                              0);
   if ( retval )
      return(retval);

   /**********
    Get device description/friendly name
***********/

   ulSize = 0;
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_FRIENDLYNAME,
                                              NULL,
                                              NULL,
                                              &ulSize,
                                              0);


   if ( ulSize )
   {
      pszFriendlyName = new TCHAR [ulSize+1];
      if ( !pszFriendlyName ) return(CR_OUT_OF_MEMORY);

      //Now get value
      retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                                 CM_DRP_FRIENDLYNAME,
                                                 NULL,
                                                 pszFriendlyName,
                                                 &ulSize,
                                                 0);
      if ( retval )
         return(retval);
   }

/**********
    Get device class
***********/
   ulSize = 0;
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_CLASS,
                                              NULL,
                                              NULL,
                                              &ulSize,
                                              0);

   if ( retval )
   {
      if ( (retval == CR_BUFFER_SMALL) )
      {
         //if ( bVerbose )
         //   logprintf ("Still Having trouble with  CM_Get_DevNode_Registry_Property returning CR_BUFFER_TOO_SMALL\r\n"
         //              "When trying to get the size of the class\r\n");
         ulSize = 511;
      }
      else if ( retval == CR_NO_SUCH_VALUE )
      {
         //if ( bVerbose )
         //{
         //   logprintf("This device does not have a class associated with it\r\n");
         //}
         ulSize = 511;
      }
      else
         ulSize = 0;
   }


   if (ulSize)
   {
      
      pszClass = new TCHAR [ulSize+1];
      if ( !pszClass )
         return(CR_OUT_OF_MEMORY);
   
      //Now get value
      retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                                 CM_DRP_CLASS,
                                                 NULL,
                                                 pszClass,
                                                 &ulSize,
                                                 0);
      if ( retval )
      {
         if (pszClass)
             delete pszClass;
         pszClass = NULL;
      }
	  else   
		_strupr(pszClass);
   }
   

/**********
    Get Hardware ID information
***********/

   ulSize = 0;
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_HARDWAREID,
                                              NULL,
                                              NULL,
                                              &ulSize,
                                              0);

   if ( retval  && !ulSize )
      if ( (retval == CR_BUFFER_SMALL) )
      {
         //if ( bVerbose )
         //   logprintf ("Still Having trouble with  CM_Get_DevNode_Registry_Property returning CR_BUFFER_TOO_SMALL\r\n"
         //              "When trying to get the size of the Device description\r\n");
         ulSize = 511;
      }
      else
         return(retval);

   pHardwareID = new TCHAR [++ulSize+1];
   if ( !pHardwareID ) return(CR_OUT_OF_MEMORY);

   //Now get value
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_HARDWAREID,
                                              NULL,
                                              pHardwareID,
                                              &ulSize,
                                              0);
   if ( retval )
      return(retval);

   /**********
       Get Compat ID information
   ***********/

      ulSize = 0;
      retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                                 CM_DRP_COMPATIBLEIDS,
                                                 NULL,
                                                 NULL,
                                                 &ulSize,
                                                 0);

      if ( retval  && !ulSize )
         if ( (retval == CR_BUFFER_SMALL) )
         {
            //if ( bVerbose )
            //   logprintf ("Still Having trouble with  CM_Get_DevNode_Registry_Property returning CR_BUFFER_TOO_SMALL\r\n"
            //              "When trying to get the size of the Device description\r\n");
            ulSize = 511;
         }
         else
            ulSize = 0;

		 if (ulSize)
		 {

      pCompatID = new TCHAR [++ulSize+1];
      if ( !pCompatID ) return(CR_OUT_OF_MEMORY);

      //Now get value
      retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                                 CM_DRP_COMPATIBLEIDS,
                                                 NULL,
                                                 pCompatID,
                                                 &ulSize,
                                                 0);
      if ( retval )
         return(retval);
		 }


/**********
    Get ClassGUID
***********/

   ulSize = 0;
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_CLASSGUID,
                                              NULL,
                                              NULL,
                                              &ulSize,
                                              0);

   if ( ulSize )
   {

      pszGUID = new TCHAR [ulSize+1];
      if ( !pszGUID ) return(CR_OUT_OF_MEMORY);

      //Now get value
      retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                                 CM_DRP_CLASSGUID,
                                                 NULL,
                                                 pszGUID,
                                                 &ulSize,
                                                 0);
   }

   /**********
    Get PDO Name
***********/

   ulSize = 0;
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                              NULL,
                                              NULL,
                                              &ulSize,
                                              0);

   if ( ulSize )
   {

      pszPDO = new TCHAR [ulSize+1];
      if ( !pszPDO ) return(CR_OUT_OF_MEMORY);

      //Now get value
      retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                                 CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                                 NULL,
                                                 pszPDO,
                                                 &ulSize,
                                                 0);
   }

   /**********
    Get MFG Name
***********/

   ulSize = 0;
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_MFG,
                                              NULL,
                                              NULL,
                                              &ulSize,
                                              0);

   if ( ulSize )
   {

      pszMFG = new TCHAR [ulSize+1];
      if ( !pszMFG ) return(CR_OUT_OF_MEMORY);

      //Now get value
      retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                                 CM_DRP_MFG,
                                                 NULL,
                                                 pszMFG,
                                                 &ulSize,
                                                 0);
   }



   /**********
    Get LocationInformation
    ***********/

   ulSize = 0;
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_LOCATION_INFORMATION,
                                              NULL,
                                              NULL,
                                              &ulSize,
                                              0);

   if ( ulSize )
   {
      pszLocation = new TCHAR [ulSize+1];
      if ( !pszLocation ) return(CR_OUT_OF_MEMORY);

      //Now get value
      retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                                 CM_DRP_LOCATION_INFORMATION,
                                                 NULL,
                                                 pszLocation,
                                                 &ulSize,
                                                 0);
   }


/**********
    Get interface/bus type
***********/

   //Now get value
   ulSize = sizeof(INTERFACE_TYPE);
   retval = CM_Get_DevNode_Registry_Property (hDevnode,
                                              CM_DRP_LEGACYBUSTYPE,
                                              NULL,
                                              &InterfaceBusType,
                                              &ulSize,
                                              0);
//   if (!retval)
   //  {
   //     InterfaceBusType= InterfaceTypeUndefined;
   //  }

/**********
    Get Problem and status code
***********/
   retval = CM_Get_DevNode_Status (&ulStatus,
                                   &ulProblemCode,
                                   hDevnode,
                                   0L);
   if ( retval ) return(retval);

/**********
    set bCanDisable
***********/
   // If we get here, let's assume that the device is testable, and filter from there
   bCanDisable = TRUE;
   bCanTest    = TRUE;


   return(CR_SUCCESS);
}


/*****************************************************************************
   GetXxxx fuctions
*****************************************************************************/

CONFIGRET DevnodeClass::GetChild(DEVNODE *pChildDevnode)
{
   return (CM_Get_Child(pChildDevnode, hDevnode, 0l));
}

CONFIGRET DevnodeClass::GetParent(DEVNODE *pParentDevnode)
{
   return (CM_Get_Parent(pParentDevnode, hDevnode, 0l));
}

CONFIGRET DevnodeClass::GetSibling(DEVNODE *pSiblingDevnode)
{
   return (CM_Get_Sibling(pSiblingDevnode, hDevnode, 0l));
}


/*****************************************************************************
   Disabler Funcitons
*****************************************************************************/


/*
CONFIGRET DevnodeClass::Remove(ULONG uFlags)
{
   //return (CM_Query_And_Remove_SubTree(hDevnode, NULL, NULL, 0, uFlags));
   return (CM_Remove_SubTree(hDevnode, uFlags));
} */

typedef CONFIGRET (WINAPI *pCM_Query_And_Remove_SubTree)(DEVNODE, PPNP_VETO_TYPE, LPSTR, ULONG, ULONG);

CONFIGRET DevnodeClass::Remove(ULONG uFlags)
{
   static pCM_Query_And_Remove_SubTree fpCM_Query_And_Remove_SubTree = NULL;

   if (!fpCM_Query_And_Remove_SubTree)
   {
      OSVERSIONINFO ver;
      memset(&ver, 0, sizeof(OSVERSIONINFO));
      ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

      GetVersionEx(&ver);

      if (ver.dwPlatformId  == VER_PLATFORM_WIN32_NT)
      {
         // is windows NT
         HINSTANCE hinst;
         hinst = LoadLibrary(_T("cfgmgr32.dll"));
         fpCM_Query_And_Remove_SubTree = (pCM_Query_And_Remove_SubTree)GetProcAddress(hinst, "CM_Query_And_Remove_SubTreeA");
		 //a-kjaw to fix prefix bug 259378.
		 if(NULL == fpCM_Query_And_Remove_SubTree)
			 return CR_FAILURE;
      }
      else
      {
         //else is not winnt
         fpCM_Query_And_Remove_SubTree = (pCM_Query_And_Remove_SubTree)-1;
      }
   }

   if (fpCM_Query_And_Remove_SubTree == (pCM_Query_And_Remove_SubTree)-1)
   {
      // is win9x
      return (CM_Remove_SubTree(hDevnode, uFlags));
   }
   else
   {
      return (fpCM_Query_And_Remove_SubTree(hDevnode, NULL, NULL, 0, uFlags));
   }
}

CONFIGRET DevnodeClass::Refresh(ULONG uFlags)
{
   CONFIGRET retval;

   retval = CM_Reenumerate_DevNode(hParent, uFlags);

   if ( retval ) return (retval);

   retval = FindDevnode();

   GetProblemCode();
   return(retval);
}


CONFIGRET DevnodeClass::Disable(ULONG uFlags)
{
   return (CM_Disable_DevNode(hDevnode, uFlags));
}

CONFIGRET DevnodeClass::Enable(ULONG uFlags)
{
   CONFIGRET retval;

   retval = CM_Enable_DevNode(hDevnode, uFlags);

   if ( retval ) return (retval);

   return (FindDevnode());
}

CONFIGRET DevnodeClass::GetProblemCode(ULONG *Status, ULONG *Problem)
{
   CONFIGRET retval;
   
   retval = CM_Get_DevNode_Status (&ulStatus,
                                   &ulProblemCode,
                                   hDevnode,
                                   0L);
   if ( retval ) return(retval);

   if (Status) *Status = ulStatus;
   if (Problem) *Problem = ulProblemCode;

   return (retval);
}

/**************
FindDevnode

This function just updates the hDevnode, refreshed the device,
and updates the status and problem code

**************/

CONFIGRET DevnodeClass::FindDevnode(void)
{
   CONFIGRET retval;

   retval = CM_Locate_DevNode (&hDevnode, pDeviceID, CM_LOCATE_DEVNODE_NORMAL);

   if ( retval )
   {
      hDevnode = NULL;
      ulProblemCode = (ULONG)-1;
      ulStatus = (ULONG)-1;
      return (retval);
   }

   return (CM_Reenumerate_DevNode (hDevnode, CM_REENUMERATE_SYNCHRONOUS));
}


/***************

operator==

*************/

int DevnodeClass::operator==(const DevnodeClass &OtherDevnode)
{

   if ( strcmp(pDeviceID, OtherDevnode.pDeviceID) )
      return (FALSE);

   if ( ulProblemCode != OtherDevnode.ulProblemCode )
   {
      return (FALSE);
   }
   if ( (ulStatus ^ OtherDevnode.ulStatus) & ~IGNORE_ME_BITS )
   {
      return (FALSE);
   }
   return (TRUE);

}



ULONG ReadRegKeyInformationSZ (HKEY RootKey, TCHAR *KeyName, TCHAR **Value)
{
   TCHAR * szBuffer;
   LONG    retval;
   DWORD   dwSize = 0;
   DWORD   dwType = 0;

   // make sure the buffer is clear

   //assert (Value);   // make sure that we actually got a value
   //assert (!*Value); // and also make sure that the buffer is already empty

   // for non debug versions
   *Value = NULL;

   //a-kjaw. Prefix bug no. 259379. if dwSize if not NULL &lpData is Null
   // func returns the size reqd to store the string which helps string allocation.
   retval = RegQueryValueEx(RootKey, 
                            KeyName,
                            0, // reserved
                            &dwType,
                            NULL,
                            &dwSize);

   if ( retval != ERROR_SUCCESS )
   {
      return (retval); // cant continue
   }

   if ( (dwType != REG_SZ) || !dwSize )
   {
      return (ERROR_FILE_NOT_FOUND);
   }

   szBuffer = new TCHAR[++dwSize];

   if ( !szBuffer )
   {
      return (ERROR_NOT_ENOUGH_MEMORY);
   }

   retval = RegQueryValueEx(RootKey, 
                            KeyName,
                            0, // reserved
                            &dwType,
                            (UCHAR *)szBuffer,
                            &dwSize);

   if ( retval )
   {
      delete szBuffer;
      return (retval);
   }

   *Value = szBuffer;
   return (ERROR_SUCCESS);

}

BOOL Enumerate_WalkTree_Devnode(DEVNODE hDevnode, DEVNODE hParent)
{
   CONFIGRET retval;
   DevnodeClass *pNewDevice;
   DEVNODE hSib;

   pNewDevice = new DevnodeClass(hDevnode, hParent);
   
   retval = pNewDevice->GetChild(&hSib);
   if ( !retval )
   {
      Enumerate_WalkTree_Devnode(hSib, hDevnode);
   }
   retval = pNewDevice->GetSibling(&hSib);
   if ( !retval )
   {
      Enumerate_WalkTree_Devnode(hSib, hParent);
   }

   return (retval);


}


ULONG EnumerateTree_Devnode(void)
{

   DEVNODE hDevnode;

   CM_Locate_DevNode(&hDevnode, NULL, CM_LOCATE_DEVNODE_NORMAL);
   Enumerate_WalkTree_Devnode(hDevnode, NULL);

   return (DevnodeClass::ALCCount());

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\devnode.h ===
/******************************************************************

devnode.h


Generic class for tracking CM32 Devnodes


first created (as such) by jeffth


Revision history


    3-99             jeffth            created                                                                    


*******************************************************************/

#ifndef _INCLUDE_DEVNODE_H_
#define _INCLUDE_DEVNODE_H_

/*******************************************************************
   INCLUDES
*******************************************************************/
#include <windows.h>
//#include <stl.h>
#include <cfgmgr32.h>
#include <alclass.h>
#include <stdio.h>
#include <stdlib.h>



// if we are ever compliled against win9x version of cfgmgr32.h
#ifndef CM_DISABLE_UI_NOT_OK
#define CM_DISABLE_UI_NOT_OK        (0x00000004) 
#endif




/*******************************************************************
   DEFINES
*******************************************************************/

                                    
// UNICODE conversions
#ifdef UNICODE
#define sprintf      swprintf
#define strstr       wcsstr
#define strlen       wcslen
#define strcmp       wcscmp
#define _strupr      _wcsupr
#define strcpy       wcscpy
#define _strlwr      _wcslwr
#define strncpy      wcsncpy
#define atoi         _wtoi
#define strchr       wcschr
#define _fullpath    _wfullpath
#define system       _wsystem
#endif

#define CAN_DISABLE_BITS			(DN_DISABLEABLE)
#define IGNORE_ME_BITS				(DN_STOP_FREE_RES | DN_NEED_TO_ENUM | DN_ARM_WAKEUP)


// I had to copy this from ntioapi.h
// did not want to , but if i included all of teh goo that ntioapi.h wanted me to include, 
// would break everyting else

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;





#define BADHANDLE(x) ((x == 0 ) || ((HANDLE)x == INVALID_HANDLE_VALUE))
#define BUFFSIZE  1024
/*******************************************************************
   CLASSES and STRUCTS
*******************************************************************/

class DevnodeClass : public AutoListClass
{
public:
   DevnodeClass(void);
   DevnodeClass(DEVNODE hDevnode, DEVNODE hParent = NULL);
   ~DevnodeClass(void);

   virtual BOOL SetHandle(DEVNODE hDevnode, DEVNODE hParent = NULL);


   // Disable funcions
   CONFIGRET Remove(ULONG uFlags    = CM_REMOVE_UI_NOT_OK);
   CONFIGRET Refresh(ULONG uFlags   = CM_REENUMERATE_SYNCHRONOUS);   
   CONFIGRET Enable(ULONG uFlags    = CM_SETUP_DEVNODE_READY);     // enables the devnode, returns CM_ERROR code
   CONFIGRET Disable(ULONG uFlags   = (CM_DISABLE_POLITE | CM_DISABLE_UI_NOT_OK));    // disables the devnode, returns CM_ERROR code
   CONFIGRET GetProblemCode(ULONG *Status = NULL, ULONG *Problem = NULL);

   // getrelations
   CONFIGRET GetChild   (DEVNODE *pChildDevnode);
   CONFIGRET GetParent  (DEVNODE *pParentDevnode);
   CONFIGRET GetSibling (DEVNODE *pSiblingDevnode);

   int operator==(const DevnodeClass &OtherDevnode);

   // refresh devnode funcitons
   CONFIGRET GetDeviceInformation (void); // gets information about the devnode
   CONFIGRET FindDevnode(void);


   // acessor funcitons
   ULONG  ProblemCode(void)   {return ulProblemCode;};
   ULONG  StatusCode(void)    {return ulStatus;};
   TCHAR *DeviceName(void)    {return pszDescription;};
   TCHAR *DeviceClass(void)   {return pszClass;};
   TCHAR *HardwareID(void)    {return pHardwareID;};
   TCHAR *CompatID(void)      {return pCompatID;};
   BOOL   GetMark(void)       {return bDNHasMark;};
   TCHAR *DeviceID(void)      {return pDeviceID;};
   void   SetMark(BOOL bMark = TRUE) {bDNHasMark = bMark;};
   void   SetPass(BOOL bPass = TRUE) {bDidPass = bPass;};
   DEVNODE Devnode(void)      {return hDevnode;};
   DEVNODE Parent(void)       {return hParent;};
   BOOL   BCanTest(void)      {return bCanTest;};
   TCHAR *GUID(void)          {return pszGUID;};
   TCHAR *Location(void)      {return pszLocation;};
   TCHAR *PDO(void)           {return pszPDO;};
   TCHAR *MFG(void)           {return pszMFG;};
   TCHAR *FriendlyName(void)  {return pszFriendlyName;};
   INTERFACE_TYPE BusType(void) {return InterfaceBusType;};

   

   
protected:
   TCHAR    *  pDeviceID;
   TCHAR    *  pHardwareID;
   TCHAR    *  pCompatID;
   DEVNODE     hDevnode;
   DEVNODE     hParent;
   TCHAR    *  pszDescription;
   TCHAR    *  pszFriendlyName;
   ULONG       ulProblemCode;
   ULONG       ulStatus;
   TCHAR    *  pszClass;
   TCHAR    *  pszGUID;
   TCHAR    *  pszLocation;
   BOOL        bDNHasMark;
   BOOL			bCanDisable;
   BOOL			bCanTest;
   BOOL        bDidPass;
   TCHAR    *  pszPDO;
   TCHAR    *  pszMFG;
   INTERFACE_TYPE InterfaceBusType;
   

private:

};


/*******************************************************************
   GLOBALS
*******************************************************************/


/*******************************************************************
   PROTOTYPES
*******************************************************************/


ULONG ReadRegKeyInformationSZ (HKEY RootKey, TCHAR *KeyName, TCHAR **Value);

// from the new disabler classes
// error string reporting

TCHAR * CM_ErrToStr(ULONG);
TCHAR * DN_ErrStr(ULONG *);
TCHAR * CM_ProbToStr(ULONG ErrorCode);

ULONG EnumerateTree_Devnode(void);

template <class T>
BOOL Enumerate_WalkTree_Template( T type, DEVNODE hDevnode, DEVNODE hParent)
{
  CONFIGRET retval;
  T *pNewDevice;
  DEVNODE hSib;

  pNewDevice = new T(hDevnode, hParent);

  retval = pNewDevice->GetChild(&hSib);
  if ( !retval )
  {
     Enumerate_WalkTree_Template(type, hSib, hDevnode);
  }
  retval = pNewDevice->GetSibling(&hSib);
  if ( !retval )
  {
     Enumerate_WalkTree_Template(type, hSib, hParent);
  }

  return (retval);      
}

template <class T>   
ULONG EnumerateTree_Template(T type)
{

   DEVNODE hDevnode;

   CM_Locate_DevNode(&hDevnode, NULL, CM_LOCATE_DEVNODE_NORMAL);
   Enumerate_WalkTree_Template(type, hDevnode, NULL);

   return (DevnodeClass::ALCCount());   
}




#endif //_INCLUDE_DEVNODE_H_


// cause compiler demands this anyway
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\fileio.h ===
//	FileIO.h
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#pragma once		// MSINFO_FILEIO_H

#include <afx.h>

//	Advanced declaration of this class so we can use the pointer.
class CDataSource;

/*
 * CFileFormatException - Home-brew exception to reflect an error in a
 *		data file.
 *
 * History:	a-jsari		10/20/97		Initial version.
 */
class CFileFormatException : public CException {
};

void ThrowFileFormatException();

/*
 * CMSInfoFile - A file class which provides extended functions for
 *		reading from a file.  Provides binary versions of the files.
 *
 * History: a-jsari		10/20/97		Initial version
 */
class CMSInfoFile {
	friend void			ThrowFileFormatException();
	friend class		CBufferDataSource;

public:
	CMSInfoFile(LPCTSTR szFileName, UINT wFlags = CFile::shareDenyWrite
		| CFile::modeCreate | CFile::modeWrite | CFile::typeBinary);
	virtual ~CMSInfoFile();

	enum FileType { BINARY, REVERSE_ENDIAN, TEXT, MEMORY };
    //a-stephl 11/23/99
    void                ReadCategoryHeader();
    
	virtual FileType	GetType() { return BINARY; }
	const CString		&GetFileName() { return m_strFileName; }
	virtual void		ReadLong(long &lValue);
	virtual void		ReadUnsignedInt(unsigned &uValue);
	virtual void		ReadString(CString &szValue);
	virtual void		ReadTchar(TCHAR &tcValue);
	void				ReadByte(BYTE &bValue)		{ ReadByteFromCFile(m_pFile, bValue); }
	void				ReadUnsignedLong(DWORD &dwValue);

	virtual void		WriteHeader(CDataSource *pDataSource);
	virtual void		WriteLong(long lValue);
	virtual void		WriteUnsignedInt(unsigned uValue);
	virtual void		WriteString(CString szValue);
	void				WriteByte(BYTE bValue);
	void				WriteUnsignedLong(DWORD dwValue);

	virtual void		WriteTitle(CString szName)	{ WriteString(szName); }
	virtual void		WriteChildMark();
	virtual void		WriteEndMark();
	virtual void		WriteNextMark();
	virtual void		WriteParentMark(unsigned cIterations);

	static void			ReadLongFromCFile(CFile *pFile, long &lValue);
	static void			ReadUnsignedFromCFile(CFile *pFile, unsigned &uValue);
	static void			ReadTcharFromCFile(CFile *pFile, TCHAR &tcValue);
	static void			ReadByteFromCFile(CFile *pFile, BYTE &bValue)	{ ASSERT(pFile);
		if (pFile->Read(&bValue, sizeof(bValue)) != sizeof(bValue)) ThrowFileFormatException(); }

	static void			GetDefaultMSInfoDirectory(LPTSTR szDefaultDirectory, DWORD dwSize);

	void				SeekToBegin()	{ m_pFile->SeekToBegin(); }
	int				    FileHandle()	{ return (int)m_pFile->m_hFile; }
	void				Close()			{ m_pFile->Close(); delete m_pFile; m_pFile = NULL; }

//protected:
    time_t			m_tsSaveTime;
	enum MagicNumber {
		VERSION_500_MAGIC_NUMBER	= 0x00011970,
		VERSION_500_REVERSE_ENDIAN	= 0x70190100,
		VERSION_410_REVERSE_ENDIAN	= 0x20000000,	//	FIX: Place holders.
		VERSION_410_MAGIC_NUMBER	= 0x20
	};

	CMSInfoFile(CFile *pFile = NULL);

	static const unsigned		DefaultReadBufferSize;
	static CFileFormatException	xptFileFormat;

	void	ReadSignedInt(int &wValue);

	CFile		*m_pFile;
	CString		m_strFileName;
};

/*
 * CMSInfoTextFile - Write-methods version for text file.  No read methods
 *		are required.
 *
 * History:	a-jsari		10/23/97		Initial version.
 */
class CMSInfoTextFile : public CMSInfoFile {
public:
	CMSInfoTextFile(LPCTSTR szName, UINT nFlags = CFile::shareDenyWrite
		| CFile::modeWrite | CFile::modeCreate | CFile::typeText);
	~CMSInfoTextFile() { }

	FileType	GetType()	{ return TEXT; }

	void	WriteTitle(CString szString);
	void	WriteHeader(CDataSource *pDataSource);
	void	WriteLong(long lValue);
	void	WriteUnsignedInt(unsigned uValue);

	virtual void	WriteString(CString szValue);

	void	WriteChildMark()	{ }
	void	WriteEndMark()		{ }
	void	WriteNextMark()		{ }
	void	WriteParentMark(unsigned)	{ }
    CMSInfoTextFile(CFile *pFile = NULL);
protected:
	
};

/*
 * CMSInfoMemoryFile - Just like a text report, but saved to a memory file.
 *		Inherits the text write functions.
 *
 * History:	a-jsari		12/26/97		Initial version
 */
class CMSInfoMemoryFile : public CMSInfoTextFile {
public:
	CMSInfoMemoryFile() :CMSInfoTextFile(new CMemFile)	{ }
	~CMSInfoMemoryFile()	{ }

	FileType	GetType()	{ return MEMORY; }

	void		WriteTitle(CString szString)			{ CMSInfoTextFile::WriteTitle(szString); }
	void		WriteHeader(CDataSource *pDataSource)	{ CMSInfoTextFile::WriteHeader(pDataSource); }
	void		WriteLong(long lValue)					{ CMSInfoTextFile::WriteLong(lValue); }
	void		WriteUnsignedInt(unsigned uValue)		{ CMSInfoTextFile::WriteUnsignedInt(uValue); }

	void		WriteString(CString szString);
};

#if 0
/*
 * CMSInfoReverseEndianFile - Read-methods version for opposite endian binary file.
 *
 * History:	a-jsari		10/20/97		Initial version
 */
class CMSInfoReverseEndianFile : public CMSInfoFile {
public:
	CMSInfoReverseEndianFile(CFile *pFile);
	~CMSInfoReverseEndianFile() {}

	FileType	GetType()	{ return REVERSE_ENDIAN; }

	void		ReadLong(long &lValue);
	void		ReadUnsignedInt(unsigned &uValue);
	void		ReadString(CString &szValue);

	static void	ReadLongFromCFile(CFile *pFile, long &lValue);
	static void	ReadUnsignedFromCFile(CFile *pFile, unsigned &uValue);
};
#endif

/*
 * ThrowFileFormatException -
 *
 * History:	a-jsari		10/24/97
 */
inline void	ThrowFileFormatException()
{
	throw &CMSInfoFile::xptFileFormat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\fileio.cpp ===
//	FileIO.cpp	Implementation of MSInfoFile classes.
//
//  Copyright (c) 1998-1999 Microsoft Corporation
#include "stdafx.h"
#include "FileIO.h"
//#include "DataSrc.h"
#include "category.h"
#include "MSInfo5Category.h"
//#include "Resource.h"

CFileFormatException	CMSInfoFile::xptFileFormat;
const unsigned			CMSInfoFile::DefaultReadBufferSize = 512; // 256;

/*
 * CMSInfoFile - Construct an MSInfoFile, setting the CFile to the pointer passed
 *
 * History:	a-jsari		10/20/97		Initial version
 */


void CMSInfoFile::ReadCategoryHeader()
{
        LONG  l;
	ASSERT(this->m_pFile != NULL);
	ReadLong(l);	//	Save time.
        m_tsSaveTime = (ULONG) l;
#ifdef _WIN64
	ReadLong(l);	//	Save time.
        m_tsSaveTime |= ((time_t) l) << 32;
#endif
	CString		szDummy;
	ReadString(szDummy);		//	Network machine name
	ReadString(szDummy);		//	Network user name
}


CMSInfoFile::CMSInfoFile(CFile *pFile)
{
	if (pFile != NULL)
		m_pFile = pFile;
}

/*
 * CMSInfoFile - Construct an MSInfoFile, opening the CFile
 *
 * History:	a-jsari		11/13/97		Initial version
 */
CMSInfoFile::CMSInfoFile(LPCTSTR szFileName, UINT nFlags)
:m_strFileName(szFileName)
{
	m_pFile = new CFile(szFileName, nFlags);
	if (m_pFile == NULL) ::AfxThrowMemoryException();
}

/*
 * ~CMSInfoFile - Destroy an MSInfoFile, closing the CFile pointer
 *
 * History:	a-jsari		10/20/97		Initial version
 */
CMSInfoFile::~CMSInfoFile()
{
	if (m_pFile)
	{
		//m_pFile->Close();
		delete m_pFile;
	}
}

/*
 * ReadUnsignedInt - Read an int from a file with the same byte-order
 *		as our current implementation.
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoFile::ReadUnsignedInt(unsigned &uValue)
{
	ReadUnsignedFromCFile(m_pFile, uValue);
}

/*
 * ReadUnsignedLong - Read a long from a file with the same byte-order
 *		as our current implementation.
 *
 * History:	a-jsari		12/1/97		Initial version
 */
void CMSInfoFile::ReadUnsignedLong(unsigned long &dwValue)
{
	long	lValue;

	ReadLongFromCFile(m_pFile, lValue);
	::memcpy(&dwValue, &lValue, sizeof(unsigned long));
}

/*
 * ReadLong - Read a long from a file written with our current byte-order
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoFile::ReadLong(long &lValue)
{
	ReadLongFromCFile(m_pFile, lValue);
}

/*
 * ReadSignedInt - Read a signed integer value.
 *
 * History:	a-jsari		10/20/97		Initial version
 */
void CMSInfoFile::ReadSignedInt(int &wValue)
{
	unsigned	uValue;

	ReadUnsignedInt(uValue);
	::memcpy(&wValue, &uValue, sizeof(int));
}

/*
 * ReadTchar - Read a tchar.
 *
 * History:	a-jsari		12/26/97		Initial version.
 */
void CMSInfoFile::ReadTchar(TCHAR &tcValue)
{
	ReadTcharFromCFile(m_pFile, tcValue);
}

/*
 * ReadString - Read a string.
 *
 * History:	a-jsari		10/20/97		Initial version.
 */
void CMSInfoFile::ReadString(CString &szString)
{
	unsigned	wStringLength;
//	WCHAR		szBuffer[DefaultReadBufferSize];	//	Maximum string length = sizeof(szBuffer)
//	LPWSTR		pszBuffer		= szBuffer;

	ASSERT(m_pFile);
	ReadUnsignedInt(wStringLength);
	LPWSTR pszBuffer = new WCHAR[wStringLength + 1];
	m_pFile->Read(pszBuffer,wStringLength*sizeof(WCHAR));
	pszBuffer[wStringLength] = (WCHAR)'\0';
//	if (wStringLength > sizeof(szBuffer))
//		ThrowFileFormatException();
//	szBuffer[wStringLength] = (WCHAR)'\0';
	//wStringLength *= sizeof(WCHAR);
//	if (m_pFile->Read(reinterpret_cast<void *>(pszBuffer), wStringLength) != wStringLength)
//		ThrowFileFormatException();
	szString = pszBuffer;
	delete [] pszBuffer;
}




/*
 * WriteHeader - Write the header for the current version (currently
 *		Version 5.00).
 *
 * History:	a-jsari		10/31/97		Initial version
 */
void CMSInfoFile::WriteHeader(CDataSource *)
{
	time_t	tNow;
	WriteUnsignedInt(VERSION_500_MAGIC_NUMBER);	//	File magic number.
	WriteUnsignedInt(0x500);					//	Version number
	time(&tNow);
	WriteLong((LONG)tNow);							//	Current time.
#ifdef _WIN64
        WriteLong((LONG) (tNow>>32));
#endif
    WriteString("");							//	Network machine
	WriteString("");							//	Network user name.
/*	msiFile.WriteString("");
	msiFile.WriteUnsignedInt(1);
	msiFile.WriteUnsignedInt(0);
	msiFile.WriteString("");
	msiFile.WriteUnsignedInt(0);
	msiFile.WriteByte(0x00);
	msiFile.WriteUnsignedInt(0);
	msiFile.WriteUnsignedInt(CMSInfo5Category::CHILD);*/
}

/*
 * WriteChildMark - Write the special integer which specifies that the
 *		following folder will be the child of the previous folder.
 *
 * History:	a-jsari		11/5/97			Initial version.
 */
void CMSInfoFile::WriteChildMark()
{
	WriteUnsignedInt(CMSInfo5Category::CHILD);
}

/*
 * WriteEndMark - Write the special integer which specifies that the
 *		end of data has been reached.
 *
 * History:	a-jsari		11/5/97		Initial version.
 */
void CMSInfoFile::WriteEndMark()
{
	WriteUnsignedInt(CMSInfo5Category::END);
}

/*
 * WriteNextMark - Write the special integer which specifies that the
 *		following folder will be the next folder in the list.
 *
 * History:	a-jsari		11/5/97		Initial version.
 */
void CMSInfoFile::WriteNextMark()
{
	WriteUnsignedInt(CMSInfo5Category::NEXT);
}

/*
 * WriteParentMark - Write the special mark specifying a parent node, with
 *		the number of times the reading function should go up.
 *
 * History:	a-jsari		11/5/97		Initial version.
 */
void CMSInfoFile::WriteParentMark(unsigned cIterations)
{
	WriteUnsignedInt(CMSInfo5Category::PARENT | cIterations);
}

/*
 * WriteByte - Write a byte to our internal file.
 *
 * History:	a-jsari		10/22/97		Initial version
 */
void CMSInfoFile::WriteByte(BYTE bValue)
{
	m_pFile->Write(reinterpret_cast<void *>(&bValue), sizeof(bValue));
}

/*
 * WriteString - Write szValue as a string of wide characters, prefixed by
 *		the string length.
 *
 * History:	a-jsari		10/22/97		Initial version
 */
void CMSInfoFile::WriteString(CString szValue)
{
	LPWSTR		pszString;

	USES_CONVERSION;
	WriteUnsignedInt(szValue.GetLength());
	pszString = T2W(const_cast<LPTSTR>((LPCTSTR)szValue));
	m_pFile->Write(reinterpret_cast<void *>(pszString),
			szValue.GetLength() * sizeof(WCHAR));
}

/*
 * WriteLong - Write a long value to our internal file.
 *
 * History:	a-jsari		10/22/97		Initial version
 */
void CMSInfoFile::WriteLong(long lValue)
{
	m_pFile->Write(reinterpret_cast<void *>(&lValue), sizeof(lValue));
}

/*
 * WriteUnsignedInt - Write an unsigned integer value to our internal file.
 *
 * History:	a-jsari		10/22/97		Initial version
 */
void CMSInfoFile::WriteUnsignedInt(unsigned uValue)
{
  //  unsigned* utest = (unsigned*) (reinterpret_cast<void *>(&uValue));
   // UINT utest2 = (UINT) *utest;
	m_pFile->Write(reinterpret_cast<void *>(&uValue), sizeof(uValue));
}

/*
 * WriteUnsignedLong - Write an unsigned long value to our internal file.
 *
 * History:	a-jsari		12/1/97		Initial version
 */
void CMSInfoFile::WriteUnsignedLong(unsigned long dwValue)
{
	long	lValue;

	::memcpy(&lValue, &dwValue, sizeof(dwValue));
	WriteLong(lValue);
}

/*
 * ReadTcharFromCFile - Read a TCHAR value from the file specified.
 *
 * History:	a-jsari		12/26/97		Initial version
 */
void CMSInfoFile::ReadTcharFromCFile(CFile *pFile, TCHAR &tcValue)
{
	ASSERT(pFile != NULL);
	if (pFile->Read(reinterpret_cast<void *>(&tcValue), sizeof(tcValue)) != sizeof(tcValue))
		ThrowFileFormatException();
}

/*
 * ReadUnsignedFromCFile - Read an unsigned value from the file specified.
 *
 * History:	a-jsari		10/20/97		Initial version
 */
void CMSInfoFile::ReadUnsignedFromCFile(CFile *pFile, unsigned &uValue)
{
	ASSERT(pFile);
	if (pFile->Read(reinterpret_cast<void *>(&uValue), sizeof(uValue)) != sizeof(uValue))
		ThrowFileFormatException();
}

/*
 * ReadLongFromCFile - Read a long from the file specified.
 *
 * History:	a-jsari		10/20/97		Initial version.
 */
void CMSInfoFile::ReadLongFromCFile(CFile *pFile, long &lValue)
{
	ASSERT(pFile);
	if (pFile->Read(reinterpret_cast<void *>(&lValue), sizeof(lValue)) != sizeof(lValue))
    {
		ThrowFileFormatException();
    }
}

/*
 * CMSInfoTextFile - Constructor
 *
 * History:	a-jsari		11/13/97		Initial version
 */
CMSInfoTextFile::CMSInfoTextFile(LPCTSTR szFileName, UINT nFlags)
{
	try
	{
		m_pFile = new CFile(szFileName, nFlags);
	}
	catch (CFileException * e)
	{
		e->ReportError();
		throw;
	}
}

/*
 * CMSInfoTextFile - Constructor
 *
 * History:	a-jsari		12/26/97		Initial version
 */
CMSInfoTextFile::CMSInfoTextFile(CFile *pFile)
:CMSInfoFile(pFile)
{

}

/*
 * WriteHeader - Write the special header for the text file.
 *
 * History:	a-jsari		10/31/97		Initial version
 */
void CMSInfoTextFile::WriteHeader(CDataSource *pSource)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	// mark file as unicode
	WCHAR wHeader = 0xFEFF;
	m_pFile->Write( &wHeader, 2);

	//	FIX:	Make this point to the right time.
	CTime		tNow = CTime::GetCurrentTime();
	CString		strTimeFormat;
//	strTimeFormat.LoadString(IDS_TIME_FORMAT);
	CString		strHeaderText = tNow.Format(strTimeFormat);
	WriteString(strHeaderText);
//	WriteString(pSource->MachineName());
}

/*
 * WriteTitle - Write the title of a folder.
 *
 * History:	a-jsari		11/5/97			Initial version
 */
void CMSInfoTextFile::WriteTitle(CString szName)
{
	CString		szWriteString = _T("[");

	szWriteString += szName + _T("]\n\n");
	WriteString(szWriteString);
}

/*
 * WriteLong - Write a long value in the text file.
 *
 * History:	a-jsari		10/23/97		Initial version
 */
void CMSInfoTextFile::WriteLong(long lValue)
{
	CString		szTextValue;

	szTextValue.Format(_T("%ld"), lValue);
	WriteString(szTextValue);
}

/*
 * WriteUnsignedInt - Write an unsigned value in the text file.
 *
 * History:	a-jsari		10/23/97		Initial version
 */
void CMSInfoTextFile::WriteUnsignedInt(unsigned uValue)
{
	CString		szTextValue;

	szTextValue.Format(_T("%ud"), uValue);
	WriteString(szTextValue);
}

/*
 * WriteString - Write a string to a text file.
 *
 * History:	a-jsari		10/23/97		Initial version
 */
void CMSInfoTextFile::WriteString(CString szValue)
{
	if (szValue.GetLength() == 0)
		return;
    
	//a-stephl dynamic_cast<CFile *>(m_pFile)->Write((LPCTSTR)szValue, szValue.GetLength() * sizeof(TCHAR));
    m_pFile->Write((LPCTSTR)szValue, szValue.GetLength() * sizeof(TCHAR));
}

/*
 * WriteString - Write a string to a memory file.
 *
 * History:	a-jsari		1/5/98		Initial version
 */
void CMSInfoMemoryFile::WriteString(CString szValue)
{
	if (szValue.GetLength() == 0)
		return;
	m_pFile->Write((LPCTSTR)szValue, szValue.GetLength() * sizeof(TCHAR));
}

#if 0
/*
 * ReadUnsignedInt -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadUnsignedInt(unsigned &uValue)
{
	CMSInfoReverseEndianFile::ReadUnsignedFromCFile(m_pFile, uValue);
}


/*
 * ReadLong -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadLong(long &lValue)
{
	CMSInfoReverseEndianFile::ReadLongFromCFile(m_pFile, lValue);
}

/*
 * ReadString -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadString(CString &szValue)
{
	unsigned	uStringLength;
	WCHAR		szBuffer[DefaultReadBufferSize];
	LPWSTR		pszBuffer = szBuffer;

	ReadUnsignedInt(uStringLength);
	for (unsigned i = uStringLength ; i > 0 ; --i) {
		szBuffer[i] = 0;
		for (unsigned j = sizeof(WCHAR) ; j > 0 ; --j) {
			BYTE		bRead;

			ReadByte(bRead);
			szBuffer[i] >>= 8;
			szBuffer[i] |= bRead;
		}
	}
}

/*
 * ReadIntegerFromCFile - Template class to read an arbitrarily sized int
 *		from a CFile pointer.
 *
 * History:	a-jsari		10/21/97		Initial version
 */
template <class T> void ReadIntegerFromCFile(CFile *pFile, T &tValue)
{
	union ReverseBuffer { BYTE bytes[sizeof(T)]; T tVal; };

	union ReverseBuffer rbReverse;
	union ReverseBuffer rbSwap;

	if (pFile->Read(reinterpret_cast<void *>(&tValue), sizeof(T)) != sizeof(T))
		ThrowFileFormatException();
	unsigned j = 0;
	for (unsigned i = sizeof(union ReverseBuffer) ; i > 0 ; --i, ++j) {
		rbSwap.bytes[i] = rbReverse.bytes[j];
	}
	tValue = rbReverse.tVal;
}

/*
 * ReadUnsignedFromCFile -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadUnsignedFromCFile(CFile *pFile, unsigned &uValue)
{
	ReadIntegerFromCFile<unsigned>(pFile, uValue);
}

/*
 * ReadLongFromCFile -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadLongFromCFile(CFile *pFile, long &lValue)
{
	ReadIntegerFromCFile<long>(pFile, lValue);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\filestuff.h ===
//=============================================================================
// This file contains the defines of string resources used by CMSInfo5Category and 
// CMSInfo6Category
//=============================================================================

#pragma once


#define FIRST_FILESTUFF_ID		            1200

#define IDS_TIME_FORMAT 					FIRST_FILESTUFF_ID + 0
#define IDS_RIGHTBRACKET 					FIRST_FILESTUFF_ID + 1
#define IDS_LEFTBRACKET 					FIRST_FILESTUFF_ID + 2
#define IDS_CATEGORYHEADING                 FIRST_FILESTUFF_ID + 3
#define IDS_PRINT_LINESPACING               FIRST_FILESTUFF_ID + 4
#define IDS_MSI_REG_BASE                    FIRST_FILESTUFF_ID + 5
#define IDS_CAB_DIR_NAME                    FIRST_FILESTUFF_ID + 6
#define IDS_HEADER_MARGIN                   FIRST_FILESTUFF_ID + 7
#define IDS_FOOTER_MARGIN                   FIRST_FILESTUFF_ID + 8
#define IDS_PRINT_FTR_CTR                   FIRST_FILESTUFF_ID + 9
#define IDS_PRINTING_DOCNAME                FIRST_FILESTUFF_ID + 10
#define IDS_PRINT_FONT_HEIGHT               FIRST_FILESTUFF_ID + 11
#define IDS_PRINT_FONT_WEIGHT               FIRST_FILESTUFF_ID + 12
#define IDS_PRINT_FONT_CHARSET              FIRST_FILESTUFF_ID + 13
#define IDS_PRINT_FONT_PITCHANDFAMILY       FIRST_FILESTUFF_ID + 14
#define IDS_PRINT_FONT_FACENAME             FIRST_FILESTUFF_ID + 15
#define IDS_PRINT_HDR_LEFT                  FIRST_FILESTUFF_ID + 16

#define IDS_PRINT_HDR_RIGHT_CURRENT         FIRST_FILESTUFF_ID + 17
#define IDS_PRINT_GENERIC                   FIRST_FILESTUFF_ID + 18
#define IDS_PRINT_NOMEMORY                  FIRST_FILESTUFF_ID + 19
#define IDS_PRINT_NODISK                    FIRST_FILESTUFF_ID + 20
#define IDS_PRINT_APPABORTED                FIRST_FILESTUFF_ID + 21
#define IDS_PRINT_USERABORTED               FIRST_FILESTUFF_ID + 22
#define IDS_FILESAVEERROR_UNKNOWN			FIRST_FILESTUFF_ID + 23

#define IDS_CODEC_DESC						FIRST_FILESTUFF_ID + 24
#define IDS_COMPUTERSYSTEM_DESC				FIRST_FILESTUFF_ID + 25
#define IDS_LOGICALMEMEORY_DESC				FIRST_FILESTUFF_ID + 26
#define IDS_LOGICALDISK_DESC				FIRST_FILESTUFF_ID + 27
#define IDS_IRQRESOURCE_DESC				FIRST_FILESTUFF_ID + 28
#define IDS_DRIVERVXD_DESC					FIRST_FILESTUFF_ID + 29
#define IDS_DMACHANNEL_DESC					FIRST_FILESTUFF_ID + 30
#define IDS_DEVICEMEMORYADDRESS_DESC		FIRST_FILESTUFF_ID + 31
#define IDS_NETWORKPROTOCOL_DESC			FIRST_FILESTUFF_ID + 32
#define IDS_OPERATINGSYSTEM_DESC			FIRST_FILESTUFF_ID + 33
#define IDS_PNPALLOCATEDRESOURCE_DESC		FIRST_FILESTUFF_ID + 34
#define IDS_PNPENTITY_DESC					FIRST_FILESTUFF_ID + 35
#define IDS_PORTRESOURCE_DESC				FIRST_FILESTUFF_ID + 36
#define IDS_PRINTER_DESC					FIRST_FILESTUFF_ID + 37
#define IDS_PROGRAMGROUP_DESC				FIRST_FILESTUFF_ID + 38
#define IDS_STARTUPCOMMAND_DESC				FIRST_FILESTUFF_ID + 39
#define IDS_BADNFOFILE						FIRST_FILESTUFF_ID + 40
#define IDS_NOHISTORY_AVAILABLE				FIRST_FILESTUFF_ID + 41
#define IDS_SYSTEMNAME                      FIRST_FILESTUFF_ID + 42
#define IDS_OLDNFOSHARINGVIOLATION			FIRST_FILESTUFF_ID + 43



/**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\historyparser.cpp ===
// HistoryParser.cpp: implementation of the CHistoryParser class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "HistoryParser.h"
#include "Filestuff.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif



extern CMSInfoHistoryCategory catHistorySystemSummary;
extern CMSInfoHistoryCategory catHistoryResources;
extern CMSInfoHistoryCategory catHistoryComponents;
extern CMSInfoHistoryCategory catHistorySWEnv;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHistoryParser::CHistoryParser(CComPtr<IXMLDOMDocument> pDoc) : m_pDoc(pDoc)
{

}

void CHistoryParser::DeleteAllInstances()
{
	for(POSITION pos = this->m_listInstances.GetHeadPosition();pos;)
	{
		if (!pos)
		{
			return;
		}
		CInstance* pInci = (CInstance*) m_listInstances.GetNext(pos);
		delete pInci;
	}
	m_listInstances.RemoveAll();
}

CHistoryParser::~CHistoryParser()
{
	DeleteAllInstances();
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
// takes a CTime, which comes from timestamp element of the Delta or Snaphot
// node of which pInstanceNode is a child;  an Instance node, and a string 
// containing the WMI class of the Instance
//////////////////////////////////////////////////////////////////////

CInstance::CInstance(CTime tmstmp, CComPtr<IXMLDOMNode> pInstanceNode,CString strClass) : m_tmstamp(tmstmp), m_strClassName(strClass)
{
	CComPtr<IXMLDOMNodeList> pPropList;
	HRESULT hr;
	//Get node data, add each PROPERTY name and VALUE to m_mapNameValue
	if (strClass.CompareNoCase(_T("Win32_PNPAllocatedResource")) == 0)
	{
		hr = ProcessPNPAllocatedResource(pInstanceNode);
		ASSERT(SUCCEEDED(hr) && "failed to process Win32_PNPAllocatedResource");
		return;
	}
	hr = pInstanceNode->selectNodes(CComBSTR("PROPERTY"),&pPropList);
	if (FAILED(hr) || !pPropList)
	{
		ASSERT(0 && "could not get property list from Instance node");
		return;
	}
	long lListLen;
	hr = pPropList->get_length(&lListLen);
	CComPtr<IXMLDOMNode> pVNode;
	CComBSTR bstrValue;
	CComVariant varName;
	for(long i = 0; i < lListLen; i++)
	{
		hr = pPropList->nextNode(&pVNode);
		if (FAILED(hr) || !pVNode)
		{
			return;
		}
		CComPtr<IXMLDOMElement> pElement;
		hr = pVNode->QueryInterface(IID_IXMLDOMElement,(void**) &pElement);
		if (FAILED(hr) || !pElement)
		{
			return;
		}
		hr = pElement->getAttribute(L"NAME",&varName);
		ASSERT(SUCCEEDED(hr));
		hr = pVNode->get_text(&bstrValue);
		ASSERT(SUCCEEDED(hr));
		USES_CONVERSION;
		m_mapNameValue.SetAt(OLE2T(varName.bstrVal)  ,OLE2T(bstrValue));
		pVNode.Release();
	}
	pPropList.Release();
	return;

}

//////////////////////////////////////////////////////////////////////////////////////////
//Refresh is called for selected category when category selection or delta range changes
//////////////////////////////////////////////////////////////////////////////////////////

HRESULT CHistoryParser::Refresh(CMSInfoHistoryCategory* pHistCat,int nDeltasBack)
{
	nDeltasBack++;
	this->m_fChangeLines = FALSE;// v-stlowe 2/28/2001
	DeleteAllInstances();
	m_pHistCat = pHistCat;
	CComPtr<IXMLDOMNodeList> pDeltaList;
	HRESULT hr;
	hr = this->GetDeltaAndSnapshotNodes(pDeltaList);
	if (FAILED(hr) || !pDeltaList)
	{
		return E_FAIL;
	}

	if (pHistCat == &catHistoryComponents)
	{
		DeleteAllInstances();
		
		hr = ProcessDeltas(pDeltaList,"Win32_DriverVXD",nDeltasBack);
		ASSERT(SUCCEEDED(hr));
		DeleteAllInstances();
		pDeltaList->reset();
		hr = ProcessDeltas(pDeltaList,"Win32_CodecFile",nDeltasBack);
		ASSERT(SUCCEEDED(hr));
		DeleteAllInstances();
		pDeltaList->reset();
		hr = ProcessDeltas(pDeltaList,"Win32_LogicalDisk",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		ASSERT(SUCCEEDED(hr));
		hr = ProcessDeltas(pDeltaList,"Win32_NetworkProtocol",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		ASSERT(SUCCEEDED(hr));
		hr = ProcessDeltas(pDeltaList,"Win32_Printer",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		ASSERT(SUCCEEDED(hr));
		hr = ProcessDeltas(pDeltaList,"Win32_PortResource",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		ASSERT(SUCCEEDED(hr));
		hr = ProcessDeltas(pDeltaList,"Win32_PnPEntity",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		ASSERT(SUCCEEDED(hr));
	}
	else if (pHistCat == &catHistorySystemSummary)
	{
		DeleteAllInstances();
		hr = ProcessDeltas(pDeltaList,"Win32_ComputerSystem",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		ASSERT(SUCCEEDED(hr));
		hr = ProcessDeltas(pDeltaList,"Win32_OperatingSystem",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		ASSERT(SUCCEEDED(hr));
		//hr = ProcessDeltas(pDeltaList,"Win32_Win32_LogicalMemoryConfiguration",nDeltasBack);
		hr = ProcessDeltas(pDeltaList,"Win32_LogicalMemoryConfiguration",nDeltasBack); //v-stlowe 2/28/2001
		DeleteAllInstances();
		pDeltaList->reset();
		ASSERT(SUCCEEDED(hr));
	}
	else if(pHistCat == &catHistoryResources)
	{
		DeleteAllInstances();
		hr = ProcessDeltas(pDeltaList,"Win32_PNPAllocatedResource",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		ASSERT(SUCCEEDED(hr));
	}
	else if (pHistCat == &catHistorySWEnv)
	{
		DeleteAllInstances();
		hr = ProcessDeltas(pDeltaList,"Win32_ProgramGroup",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		hr = ProcessDeltas(pDeltaList,"Win32_StartupCommand",nDeltasBack);
		DeleteAllInstances();
		pDeltaList->reset();
		
	}
	if (!m_fChangeLines)
	{
#ifdef A_STEPHL2
		::MessageBox(NULL,"!m_fChangeLines)","",MB_OK);
#endif
		m_fChangeLines = TRUE;
		CString strMSG;
		strMSG.LoadString(IDS_DELTANOCHANGES);//this would be the place to change messaging for situation where summary has no changes
		m_pHistCat->InsertLine(-1, strMSG, _T(""), _T(""), _T(""));
	}
	pDeltaList.Release();
	return hr;
}



//////////////////////////////////////////////////////////////////////////////////////////
//Gets the value appropriate to use as a description for the class
//////////////////////////////////////////////////////////////////////////////////////////
CString CInstance::GetInstanceDescription()
{
	CString strDescName = GetDescriptionForClass(m_strClassName);
	CString strInstDesc;
	VERIFY(m_mapNameValue.Lookup(strDescName,strInstDesc));
	return strInstDesc;

}

//////////////////////////////////////////////////////////////////////////////////////////
//Gets the value that can be used to uniquely identify a specific instance of a class
//////////////////////////////////////////////////////////////////////////////////////////
CString CInstance::GetInstanceID()
{
	CString strIDName = GetIDForClass(m_strClassName);
	CString strInstID;
	VERIFY(m_mapNameValue.Lookup(strIDName,strInstID));
	return strInstID;

}

//////////////////////////////////////////////////////////////////////////////////////////
//used to deal with antecedent\dependant relationship classes in Win32_PNPAllocatedResource classes
//////////////////////////////////////////////////////////////////////////////////////////

HRESULT CInstance::ProcessPropertyDotReferenceNodes(CComPtr<IXMLDOMNode> pInstanceNameNode,CString* pstrClassName, CString* pstrKeyName,CString* pstrKeyValue)
{
	USES_CONVERSION;
	HRESULT hr;
	CComPtr<IXMLDOMElement> pNameElement;
	hr = pInstanceNameNode->QueryInterface(IID_IXMLDOMElement,(void**) &pNameElement);
	if (FAILED(hr) | !pNameElement)
	{
		ASSERT(0 && "could not QI pNode for Element");
		return E_FAIL;
	}
	CComVariant varClassName;
	hr = pNameElement->getAttribute(L"CLASSNAME",&varClassName);
	pNameElement.Release();
	if (FAILED(hr))
	{
		ASSERT(0 && "could not get CLASSNAME element");
	}
	*pstrClassName = OLE2T(varClassName.bstrVal);
	CComPtr<IXMLDOMNode> pKeybindingNode;
	hr = pInstanceNameNode->selectSingleNode(CComBSTR("KEYBINDING"),&pKeybindingNode);
	if (FAILED(hr) || !pKeybindingNode)
	{
		ASSERT(0 && "could not get antecedent node");
	}
	CComBSTR bstrKeyValue;
	hr = pKeybindingNode->get_text(&bstrKeyValue);
	ASSERT(SUCCEEDED(hr) && "failed to get keybinding value");
	*pstrKeyValue = OLE2T(bstrKeyValue);
	hr = pKeybindingNode->QueryInterface(IID_IXMLDOMElement,(void**) &pNameElement);
	if (FAILED(hr) | !pNameElement)
	{
		ASSERT(0 && "could not QI pNode for Element");
		return E_FAIL;
	}
	CComVariant varKeybindingName;
	hr = pNameElement->getAttribute(CComBSTR("NAME"),&varKeybindingName);
	if (FAILED(hr))
	{
		ASSERT(0 && "could not get NAME attribute from pNameElement");
	}

	*pstrKeyName = OLE2T(varKeybindingName.bstrVal);
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////
//used to deal with antecedent\dependant relationship classes in Win32_PNPAllocatedResource classes
//////////////////////////////////////////////////////////////////////////////////////////

HRESULT CInstance::ProcessPNPAllocatedResource(CComPtr<IXMLDOMNode> pInstanceNode)
{

	HRESULT hr;
	CComPtr<IXMLDOMNodeList> pPropDotRefList;
	hr = pInstanceNode->selectNodes(CComBSTR("PROPERTY.REFERENCE/VALUE.REFERENCE/INSTANCEPATH/INSTANCENAME"),&pPropDotRefList);
	if (FAILED(hr) || !pPropDotRefList)
	{
		ASSERT(0 && "PROPERTY.REFERENCE nodes not found");
		return E_FAIL;
	}

	//get antecedent node
	CComPtr<IXMLDOMNode> pInstanceNameNode;
	hr = pPropDotRefList->nextNode(&pInstanceNameNode);
	if (FAILED(hr) || !pInstanceNameNode)
	{
		ASSERT(0 && "could not get antecedent node");
	}
	CString strAntecedentName,strResourceName,strResourceValue;
	hr = ProcessPropertyDotReferenceNodes(pInstanceNameNode,&strAntecedentName,&strResourceName,&strResourceValue);
	m_mapNameValue.SetAt(_T("ANTECEDENT"),strAntecedentName);
	m_mapNameValue.SetAt(strResourceName,strResourceValue);
	if (FAILED(hr))
	{
		return hr;
	}
	CString strPNPEntity,strKeyname,strDeviceIDval;
	pInstanceNameNode.Release();
	hr = pPropDotRefList->nextNode(&pInstanceNameNode);
	if (FAILED(hr) || !pInstanceNameNode)
	{
		return hr;
	}
	hr = ProcessPropertyDotReferenceNodes(pInstanceNameNode,&strPNPEntity,&strKeyname,&strDeviceIDval);
	CComPtr<IXMLDOMDocument> pDoc;
	hr = pInstanceNode->get_ownerDocument(&pDoc);
	if (FAILED(hr) || !pDoc)
	{
		ASSERT(0 && "could not get owner doc from pInstanceNode");
		return E_FAIL;
	}
	CString strPNPDeviceName = GetPNPNameByID(pDoc,CComBSTR(strDeviceIDval));
	if (FAILED(hr))
	{
		return hr;
	}
	ASSERT(strPNPEntity.CompareNoCase("Win32_PnPEntity") == 0 && "unexpected value for Dependent classname");
	ASSERT(strKeyname.CompareNoCase("DeviceID") == 0 && "unexpected value for Dependent Keybinding name");
	//we will create an arificial attribute "ASSOCNAME", which will be used to identify this device.
	m_mapNameValue.SetAt(_T("ASSOCNAME"),strAntecedentName + ":" + strDeviceIDval);
	m_mapNameValue.SetAt(_T("DeviceID"),strDeviceIDval);
	m_mapNameValue.SetAt(_T("DeviceName"),strPNPDeviceName);

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////////
//Retrives a value used to select appropriate description value for the class
//////////////////////////////////////////////////////////////////////////////////////////
CString CInstance::GetDescriptionForClass(CString strClass)
{
	//lookup a key which can uniquely identify an instance of a given class
	//for example, DeviceID for Printers
	if (strClass.CompareNoCase(_T("Win32_LogicalDisk")) == 0)
	{
		return "DeviceID";
	}
	if (strClass.CompareNoCase(_T("Win32_CodecFile")) == 0)
	{
		return "Description";
	}
	if (strClass.CompareNoCase(_T("Win32_ComputerSystem")) == 0)
	{
		return "Name";
	}
	if (strClass.CompareNoCase(_T("Win32_OperatingSystem")) == 0)
	{
		return "Caption";
	}
	if (strClass.CompareNoCase(_T("Win32_LogicalMemoryConfiguration")) == 0)
	{
		return "TotalPhysicalMemory";
	}
	if (strClass.CompareNoCase(_T("Win32_PortResource")) == 0)
	{
		return "Name";
	}
	if (strClass.CompareNoCase(_T("Win32_NetworkProtocol")) == 0)
	{
		return "Name";
	}
	if (strClass.CompareNoCase(_T("Win32_Printer")) == 0)
	{
		return "DeviceID";
	}
	if (strClass.CompareNoCase(_T("Win32_PnPEntity")) == 0)
	{
		return "Description";
	}
	if (strClass.CompareNoCase(_T("Win32_StartupCommand")) == 0)
	{
		return "Command";
	}
	if (strClass.CompareNoCase(_T("Win32_ProgramGroup")) == 0)
	{
		return "GroupName";
	}
	if (strClass.CompareNoCase(_T("Win32_PNPAllocatedResource")) == 0)
	{
		//this is an artificial string created in CInstance::ProcessPNPAllocatedResource
		return "DeviceName";
	}
	if (strClass.CompareNoCase(_T("Win32_DriverVXD")) == 0)
	{
		return "Name";
	}

	return "";
}


//////////////////////////////////////////////////////////////////////////////////////////
//used to determine which mapped value to use to ID instances of the clas
//////////////////////////////////////////////////////////////////////////////////////////
CString CInstance::GetIDForClass(CString strClass)
{
	//lookup a key which can uniquely identify an instance of a given class
	//for example, DeviceID for Printers
	if (strClass.CompareNoCase(_T("Win32_LogicalDisk")) == 0)
	{
		return "DeviceID";
	}
	if (strClass.CompareNoCase(_T("Win32_CodecFile")) == 0)
	{
		return "Description";
	}
	if (strClass.CompareNoCase(_T("Win32_OperatingSystem")) == 0)
	{
		return "Caption";
	}
	if (strClass.CompareNoCase(_T("Win32_LogicalMemoryConfiguration")) == 0)
	{
		return "TotalPhysicalMemory";
	}
	if (strClass.CompareNoCase(_T("Win32_ComputerSystem")) == 0)
	{
		return "Name";
	}
	if (strClass.CompareNoCase(_T("Win32_PortResource")) == 0)
	{
		return "Name";
	}
	if (strClass.CompareNoCase(_T("Win32_NetworkProtocol")) == 0)
	{
		return "Name";
	}
	if (strClass.CompareNoCase(_T("Win32_Printer")) == 0)
	{
		return "DeviceID";
	}
	if (strClass.CompareNoCase(_T("Win32_PnPEntity")) == 0)
	{
		return "DeviceID";
	}
	if (strClass.CompareNoCase(_T("Win32_PNPAllocatedResource")) == 0)
	{
		//this is an artificial string created in CInstance::ProcessPNPAllocatedResource
		return "ASSOCNAME";
	}

	if (strClass.CompareNoCase(_T("Win32_ProgramGroup")) == 0)
	{
		return "GroupName";
	}
	if (strClass.CompareNoCase(_T("Win32_StartupCommand")) == 0)
	{
		return "Command";
	}
	if (strClass.CompareNoCase(_T("Win32_DriverVXD")) == 0)
	{
		return "Name";
	}

	return "";
}




//////////////////////////////////////////////////////////////////////////////////////////
//used when rolling back through history list, to find previous instance of a given class
//////////////////////////////////////////////////////////////////////////////////////////
CInstance* CHistoryParser::FindPreviousInstance(CInstance* pNewInstance)
{
	//for each existing instance pOld
	for(POSITION pos = m_listInstances.GetHeadPosition( );;)
	{
		if (!pos)
		{
			return NULL;
		}
		CInstance* pOld = (CInstance*) m_listInstances.GetNext(pos);
		if (pOld->GetClassName() == pNewInstance->GetClassName())
		{
			if (pOld->GetInstanceID() == pNewInstance->GetInstanceID())
			{
				return pOld;
			}
		}
		
	}
	return NULL;
}


void CHistoryParser::CreateChangeStrings(CInstance* pOld, CInstance* pNew)
{
	CTimeSpan tmsDelta;
	COleDateTime olTime(pNew->m_tmstamp.GetTime());
	if (!pOld )
	{
		ASSERT(pNew );
		tmsDelta = CTime::GetCurrentTime() - pNew->m_tmstamp;
		//change string should be "Delete"
		m_pHistCat->InsertRemoveLine(pNew->m_tmstamp ,pNew->GetClassFriendlyName(),pNew->GetInstanceDescription());

		m_fChangeLines = TRUE;
		return;
	}
	else if (!pNew)
	{
		ASSERT(pOld);
		tmsDelta = CTime::GetCurrentTime() - pOld->m_tmstamp;
		//change string should be "New"
		m_pHistCat->InsertAddLine(pNew->m_tmstamp,pOld->GetClassFriendlyName(),pOld->GetInstanceDescription());
		//v-stlowe 3/12/2001
		m_fChangeLines = TRUE;
		return;
	}
	else
	{

		ASSERT(pOld && pNew && "both pointers can't be null");
		tmsDelta = CTime::GetCurrentTime() - pNew->m_tmstamp;
		//for each Name&Value pair, get the name, and then use it to examine 
		//the associated value in pCompare's map
		CString strName, strValue,strCompareValue;

		if (pNew->GetChangeType().CompareNoCase(_T("New")) == 0)
		{
			tmsDelta = CTime::GetCurrentTime() - pNew->m_tmstamp;
			//change string should be "added"
			m_pHistCat->InsertAddLine(pNew->m_tmstamp ,pNew->GetClassFriendlyName(),pNew->GetInstanceDescription());
			m_fChangeLines = TRUE;
			return;
		}
		else if (pNew->GetChangeType().CompareNoCase(_T("Delete")) == 0)
		{
			tmsDelta = CTime::GetCurrentTime() - pNew->m_tmstamp;
			//change string should be "Deleted"
			m_pHistCat->InsertRemoveLine(pNew->m_tmstamp,pNew->GetClassFriendlyName(),pNew->GetInstanceDescription());
			m_fChangeLines = TRUE;
			return;
		}

		for(POSITION pos = pNew->m_mapNameValue.GetStartPosition();;pNew->m_mapNameValue.GetNextAssoc(pos,strName, strValue))
		{
			strCompareValue = _T("");
			if (!pOld->m_mapNameValue.Lookup(strName,strCompareValue))
			{
				//ASSERT(0 && "value not found in delta");
				//return E_FAIL;
				if (strName.CompareNoCase(_T("Change")) == 0)
				{
					VERIFY(pNew->m_mapNameValue.Lookup(strName,strCompareValue));
					if (strCompareValue.CompareNoCase(_T("New")) == 0)
					{
						m_pHistCat->InsertAddLine(pNew->m_tmstamp,pNew->GetClassFriendlyName(),pNew->GetInstanceDescription());
						m_fChangeLines = TRUE;
					}
					ASSERT(1);
				}
				continue;
			}
			else
			{
				pOld->m_mapNameValue.RemoveKey(strName);
			}
			
			if (strValue != strCompareValue)
			{

				m_pHistCat->InsertChangeLine(pNew->m_tmstamp,pNew->GetClassFriendlyName(),pNew->GetInstanceDescription(),strName,strValue,strCompareValue);
				m_fChangeLines = TRUE;

			}
			if(!pos)
			{
				break;
			}
		}
		//handle values that are mapOldInstance, and not the other map
		if (!pOld->m_mapNameValue.IsEmpty())
		{
			for(pos = pOld->m_mapNameValue.GetStartPosition();;pOld->m_mapNameValue.GetNextAssoc(pos,strName, strValue))
			{
				pOld->m_mapNameValue.GetNextAssoc(pos,strName, strValue);
				pNew->m_mapNameValue.SetAt(strName,strValue);
				if (!pos)
				{
					break;
				}
			}
		}


	}
}


//////////////////////////////////////////////////////////////////////////////////////////
//once the previous instance has been processed, previous instance should be removed and this instance should be added to list
//////////////////////////////////////////////////////////////////////////////////////////
void CHistoryParser::ResetInstance(CInstance* pOld, CInstance* pNew)
{
	POSITION pos = this->m_listInstances.Find(pOld);
	m_listInstances.SetAt(pos,pNew);
	delete pOld;

}


//////////////////////////////////////////////////////////////////////////////////////////
//Used to process a single instance from either history or snapshot
//////////////////////////////////////////////////////////////////////////////////////////
void CHistoryParser::ProcessInstance(CInstance* pNewInstance)
{
	//see if instance is in list of instances
	CInstance* pOld = FindPreviousInstance(pNewInstance);
	if (pOld)
	{
		CreateChangeStrings(pOld,pNewInstance);
		ResetInstance(pOld,pNewInstance);
	}
	//if this is from a Snapshot, just add it
	//if it is from a Delta, it should have a change type of "add", and we 
	//want to create a change string for it.
	else
	{
		CString strChange;
		if (pNewInstance->GetValueFromMap(_T("Change"),strChange))
		{
			//we have new Delta instance
			CreateChangeStrings(NULL,pNewInstance);
			m_listInstances.AddTail(pNewInstance);
		}
		else
		{
			//Instance is in snapshot, so we don't generate change lines
			m_listInstances.AddTail(pNewInstance);
		}
	}
}

/**************************************************************************
returns list of deltas and the snapshot node
/**************************************************************************/
HRESULT CHistoryParser::GetDeltaAndSnapshotNodes(CComPtr<IXMLDOMNodeList>& pDeltaList)
{
	CComPtr<IXMLDOMNode> pDataCollNode;
	HRESULT hr;
	hr = GetDataCollectionNode(m_pDoc,pDataCollNode);
	if (FAILED(hr) || !pDataCollNode)
	{
		//ASSERT(0 && "could not get datacollection node");
		return E_FAIL;
	}
	//all nodes directly under DATACOLLECTION should be either deltas or the snapshot
	hr = pDataCollNode->selectNodes(CComBSTR("*"),&pDeltaList);
	if (FAILED(hr) || !pDeltaList)
	{
		ASSERT(0 && "could not get pDeltaList");
		return E_FAIL;
	}
#ifndef _DEBUG
	return hr;
#endif
	long ll;
	hr = pDeltaList->get_length(&ll);
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////
//gets IXMLDOMNodeList of instances from a specific delta or snapshot node
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT CHistoryParser::GetInstanceNodeList(CString strClass,CComPtr<IXMLDOMNode> pDeltaNode, CComPtr<IXMLDOMNodeList>& pInstanceList)
{
	HRESULT hr;
	//CComBSTR bstrQuery;
	// the query will have to be in the form:
	// CIM/DECLARATION/DECLGROUP.WITHPATH/VALUE.OBJECTWITHPATH/INSTANCE[@CLASSNAME $ieq$ "WIN32_CODECFILE"]
	// or
	// CIM/DECLARATION/DECLGROUP.WITHPATH/VALUE.OBJECTWITHPATH/INSTANCE[@CLASSNAME $ieq$ "Win32_ComputerSystem"]
	// because we are querying a node, rather than a document (with which we could get
	// away with specifying only INSTANCE in the query

	//v-stlowe 1/29/2001 to fix Prefix whistler bug #279519
	//bstrQuery += "CIM/DECLARATION/DECLGROUP.WITHPATH/VALUE.OBJECTWITHPATH/INSTANCE[@CLASSNAME $ieq$ ";
	CComBSTR bstrQuery("CIM/DECLARATION/DECLGROUP.WITHPATH/VALUE.OBJECTWITHPATH/INSTANCE[@CLASSNAME $ieq$ ");
	
	//end v-stlowe
	bstrQuery += "\"";
	bstrQuery += CComBSTR(strClass);
	bstrQuery += "\"]";
	hr = pDeltaNode->selectNodes(bstrQuery,&pInstanceList);
	if (FAILED(hr) || !pInstanceList)
	{
		ASSERT(0 && "Could not get node list");
		return E_FAIL;
	}

	if (FAILED(hr))
	{
		ASSERT(0 && "Could not get node list length");
		
	}
	
	return hr;
}



//for a given Snapshot or Delta node, get all instances of a given class
HRESULT CHistoryParser::ProcessDeltaNode(CComPtr<IXMLDOMNode> pDeltaNode,CString strClass)
{
	CString strTime;
	HRESULT hr;
	int nTimeZone;
	hr = GetTimeStampFromFromD_or_SNodeNode(pDeltaNode, &strTime,nTimeZone);
	ASSERT(SUCCEEDED(hr) && "error getting timestamp for node");
	CTime tmDelta = GetDateFromString(strTime,nTimeZone);
	//TD: check for valid time range...
	//get list of all nodes of given class
	CComPtr<IXMLDOMNodeList> pInstanceNodeList;
	hr = GetInstanceNodeList(strClass,pDeltaNode,pInstanceNodeList);
	if (FAILED(hr) | ! pInstanceNodeList)
	{
		ASSERT(0 && "could not get instance list from Delta node");
		return E_FAIL;
	}
	//step through list, getting each instance
	long lListLen;
	hr = pInstanceNodeList->get_length(&lListLen);
	for(long i = 0;i < lListLen;i++)
	{
		CComPtr<IXMLDOMNode> pInstanceNode;
		hr = pInstanceNodeList->nextNode(&pInstanceNode);
		if (FAILED(hr) || ! pInstanceNode)
		{
			ASSERT(0 && "could not get node from instance list");
			return E_FAIL;
		}
		CInstance * pInstance = new CInstance(tmDelta,pInstanceNode,strClass);
		ProcessInstance(pInstance);
	}
	return hr;
}


//*************************************************************************
//Takes a list of delta nodes, and the name of a class
//**************************************************************************

HRESULT CHistoryParser::ProcessDeltas(CComPtr<IXMLDOMNodeList> pDeltaList,CString strClassName,int nDeltasBack)
{
	//for each node in list pNode
	long lListLen;
	HRESULT hr;
	hr = pDeltaList->get_length(&lListLen);
	if (FAILED(hr))
	{
		ASSERT(0 && "couldn't get list length");
	}
	if (0 == lListLen)
	{
		pDeltaList.Release();
		return S_FALSE;
	}
	
	for (long i = 0;i  < lListLen && i <= nDeltasBack;i++)
	{
		CComPtr<IXMLDOMNode> pNode;
		hr= pDeltaList->nextNode(&pNode);
		if (FAILED(hr) || !pNode)
		{ 
			ASSERT(0 && "could not get next delta node");
			pDeltaList.Release();
			return E_FAIL;
		}

		
//	here's problem  If we're using nDeltasBack method, do we need to compare dates?
/*		CTime tmDelta = GetDeltaTime(pNode);
		if (GetDeltaTime(pNode) >= this->m_tmBack)
		{
*/
			hr = ProcessDeltaNode(pNode,strClassName);
			if (FAILED(hr))
			{
				pDeltaList.Release();
				return hr;
			}
//		}
	}
	pDeltaList.Release();
	return S_OK;

}


//*************************************************************************
//Gets the DATACOLLECTION node, beneath which both the SNAPSHOT and the DELTA nodes reside
//**************************************************************************


HRESULT GetDataCollectionNode(CComPtr<IXMLDOMDocument> pXMLDoc,CComPtr<IXMLDOMNode>& pDCNode)
{
	//TD: find a way to do case-insensitive queries.
	HRESULT hr;
	if (!pXMLDoc)
	{
		return S_FALSE;
	}
	CComPtr<IXMLDOMNodeList> pNodeList;
	
	//find a change property; that way we know we have a delta
	hr = pXMLDoc->getElementsByTagName(CComBSTR("PROPERTY[@NAME $ieq$ \"CHANGE\"]"),&pNodeList);
	if (FAILED(hr) || !pNodeList)
	{
		ASSERT(0 && "Could not get node list");
		return E_FAIL;
	}
	CComPtr<IXMLDOMNode> pNode;
	hr = pNodeList->nextNode(&pNode);
	if (FAILED(hr) || !pNode)
	{
//		ASSERT(0 && "Could not get node from node list");
		return E_FAIL;
	}
	//loop till we get a node called "DATACOLLECTION"
	CComPtr<IXMLDOMNode> pParentNode;
	for(int i = 0;;i++)
	{
		hr = pNode->get_parentNode(&pParentNode);
		if (FAILED(hr) || !pParentNode)
		{
			ASSERT(0 && "Could not find DATACOLLECTION node");
			pDCNode = NULL;
			return E_FAIL;
		}
		pNode.Release();
		CComBSTR bstrName;
		pParentNode->get_nodeName(&bstrName);
		USES_CONVERSION;
		if (CString(bstrName).CompareNoCase(_T("DATACOLLECTION")) == 0)
		{
			pDCNode = pParentNode;
			return S_OK;
		}
		pNode = pParentNode;
		pParentNode.Release();
	}
	
	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////
//get timestamp of a delta or snapshot node
//////////////////////////////////////////////////////////////////////////////////////////
CTime GetDeltaTime(CComPtr<IXMLDOMNode> pDorSNode)
{
	CString strTime;
	int nTimeZone;
	GetTimeStampFromFromD_or_SNodeNode(pDorSNode,&strTime,nTimeZone);
	return GetDateFromString(strTime,nTimeZone);
}

//////////////////////////////////////////////////////////////////////////////////////////
//takes string format used in XML blob, creates a CTime
//////////////////////////////////////////////////////////////////////////////////////////



HRESULT GetTimeStampFromFromD_or_SNodeNode(CComPtr<IXMLDOMNode> pDorSNode,CString* pString, int& nTimeZone)
{
	HRESULT hr;
	CComVariant varTS;
	CComPtr<IXMLDOMElement> pTimestampElement;
	hr = pDorSNode->QueryInterface(IID_IXMLDOMElement,(void**) &pTimestampElement);
	if (FAILED(hr) || !pTimestampElement)
	{
		ASSERT(0 && "could not get attribute element");
	}
	hr = pTimestampElement->getAttribute(L"Timestamp_T0",&varTS);
	if (FAILED(hr) )
	{
		ASSERT(0 && "could not get timestamp value from attribute");
	}
	if (1 == hr)
	{
		//this may be snapshot node...try "Timestamp"
		hr = pTimestampElement->getAttribute(L"Timestamp",&varTS);
		if (FAILED(hr) )
		{
			ASSERT(0 && "could not get timestamp value from attribute");
		}
	}
	CComVariant varTzoneDeltaSeconds;
	hr = pTimestampElement->getAttribute(L"TimeZone",&varTzoneDeltaSeconds);
	if (FAILED(hr) ) //this will happen when loading WinME xml, which has no timezone info
	{
		varTzoneDeltaSeconds = 0;
	}
	//make sure we have an integer type
	hr = varTzoneDeltaSeconds.ChangeType(VT_INT);
	if (FAILED(hr) ) 
	{
		varTzoneDeltaSeconds = 0;
	}
	nTimeZone = varTzoneDeltaSeconds.intVal;
	USES_CONVERSION;
	pTimestampElement.Release();
	*pString = OLE2T(varTS.bstrVal);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// utility functions
//////////////////////////////////////////////////////////////////////
CTime GetDateFromString(const CString& strDate, int nTimeZone)
{
	//requires linking to Shlwapi.lib
	CString strDateCopy(strDate);
	CString strDateSegment;

	//year is the 4 leftmost digits of date string
	strDateSegment = strDateCopy.Left(4);
	int nYear;
	VERIFY(StrToIntEx(strDateSegment,STIF_DEFAULT ,&nYear));
//	ASSERT(nYear == 1999 || nYear == 2000);
	strDateCopy = strDateCopy.Right(strDateCopy.GetLength() - 4);
	
    //month is now the 2 leftmost digits of remaining date string
	int nMonth;
	strDateSegment = strDateCopy.Left(2);
	VERIFY(StrToIntEx(strDateSegment,STIF_DEFAULT ,&nMonth));
	ASSERT(nMonth >= 1 && nMonth <= 12);
	strDateCopy = strDateCopy.Right(strDateCopy.GetLength() - 2);


	//day is now the 2 leftmost digits of remaining date string
	int nDay;
	strDateSegment = strDateCopy.Left(2);
	VERIFY(StrToIntEx(strDateSegment,STIF_DEFAULT ,&nDay));
	ASSERT(nDay >= 1 && nDay <= 31);
	strDateCopy = strDateCopy.Right(strDateCopy.GetLength() - 2);

	//hour is now the 2 leftmost digits of remaining date string
	int nHour;
	strDateSegment = strDateCopy.Left(2);
	VERIFY(StrToIntEx(strDateSegment,STIF_DEFAULT ,&nHour));
	ASSERT(nHour >= 0 && nHour <= 24);
	strDateCopy = strDateCopy.Right(strDateCopy.GetLength() - 2); 
	
	//Minute is now the 2 leftmost digits of remaining date string
	int nMin;
	strDateSegment = strDateCopy.Left(2);
	VERIFY(StrToIntEx(strDateSegment,STIF_DEFAULT ,&nMin));
	ASSERT(nMin >= 0 && nMin <= 59);
	strDateCopy = strDateCopy.Right(strDateCopy.GetLength() - 2); 
	 

		//Minute is now the 2 leftmost digits of remaining date string
	int nSec;
	strDateSegment = strDateCopy.Left(2);
	VERIFY(StrToIntEx(strDateSegment,STIF_DEFAULT ,&nSec));
	ASSERT(nSec >= 0 && nSec <= 59);
	strDateCopy = strDateCopy.Right(strDateCopy.GetLength() - 2); 
	

	CTime tmTime(nYear,nMonth,nDay,nHour,nMin,nSec);
#ifdef _V_STLOWE
	CString strFMT;
	CString strTime;
	strFMT.LoadString(IDS_TIME_FORMAT);
	strTime =tmTime.FormatGmt("%A, %B %d, %Y");

#endif
	//Adjust for time zone
	CTimeSpan tspan(0,0,nTimeZone,0);
	tmTime -= tspan;

#ifdef _V_STLOWE
	strFMT.LoadString(IDS_TIME_FORMAT);
	strTime =tmTime.FormatGmt("%A, %B %d, %Y");

#endif
	return  tmTime;
}



//////////////////////////////////////////////////////////////////////////////////////////
//finds timestamp string for a given delta or snapshot node
//////////////////////////////////////////////////////////////////////////////////////////

CString GetPNPNameByID(CComPtr<IXMLDOMDocument> pDoc,CComBSTR bstrPNPID)
{
	HRESULT hr;
	CComPtr<IXMLDOMNodeList> pNodeList;
	CComBSTR bstrQuery("INSTANCE[@CLASSNAME $ieq$ \"WIN32_PNPeNTITY\"] /PROPERTY[@NAME $ieq$ \"Description\"]");
	hr = pDoc->getElementsByTagName(bstrQuery,&pNodeList);
	if (FAILED(hr) || !pNodeList)
	{
		ASSERT(0 && "WIN32_PNPeNTITY error getting node list");
		return "";
	}
	
	long lListLen;
	hr = pNodeList->get_length(&lListLen);
	ASSERT(lListLen > 0 && "No WIN32_PNPeNTITY nodes found to match query");
	for(long i = 0; i < lListLen;i++)
	{
		CComPtr<IXMLDOMNode> pNode;
		hr = pNodeList->nextNode(&pNode);
		if (FAILED(hr) || !pNode)
		{
			ASSERT(0 && "could not get next node from list");
			return "";
		}

		USES_CONVERSION;
		CComPtr<IXMLDOMNode> pIDNode;
		hr = pNode->get_nextSibling(&pIDNode);
		if (FAILED(hr) || !pNode)
		{
			ASSERT(0 && "could not get next node from list");
			return "";
		}
		//see if node's DeviceID subnode matches bstrPNPID
		CComBSTR bstrDeviceID;
		hr = pIDNode->get_text(&bstrDeviceID);
		ASSERT(SUCCEEDED(hr) && "could not get text from ID node");
		if (bstrDeviceID == bstrPNPID)
		{
			CComBSTR bstrDeviceDesc;
			hr = pNode->get_text(&bstrDeviceDesc);
			ASSERT(SUCCEEDED(hr) && "could not get text from Desc node");
			return OLE2T(bstrDeviceDesc);
		}
	}
	



	return "";
}

//////////////////////////////////////////////////////////////////////////////////////////
//returns true if any changes have been entered into CMSInfocategory data
//////////////////////////////////////////////////////////////////////////////////////////
BOOL CHistoryParser::AreThereChangeLines()
{
	return this->m_fChangeLines;
}

//////////////////////////////////////////////////////////////////////////////////////////
//gets (from resources strings) a human-readable name for a the class wrapped the the instance
//////////////////////////////////////////////////////////////////////////////////////////

CString CInstance::GetClassFriendlyName()
{
	CString strClassName = GetClassName();
	if (strClassName.CompareNoCase(_T("Win32_PNPAllocatedResource")) == 0)
	{
		VERIFY(m_mapNameValue.Lookup(_T("ANTECEDENT"),strClassName) && _T("Could not find antecedent"));
	}
	CString strFriendlyName;
	if (strClassName.CompareNoCase(_T("Win32_CodecFile")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_CODEC_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_ComputerSystem")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_COMPUTERSYSTEM_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_LogicalMemoryConfiguration")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_LOGICALMEMEORY_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_LogicalDisk")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_LOGICALDISK_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_IRQResource")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_IRQRESOURCE_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_DriverVXD")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_DRIVERVXD_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_DMAChannel")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_DMACHANNEL_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_DeviceMemoryAddress")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_DEVICEMEMORYADDRESS_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_NetworkProtocol")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_NETWORKPROTOCOL_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_OperatingSystem")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_OPERATINGSYSTEM_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_PNPAllocatedResource")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_PNPALLOCATEDRESOURCE_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_PNPEntity")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_PNPENTITY_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_PortResource")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_PORTRESOURCE_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_Printer")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_PRINTER_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_ProgramGroup")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_PROGRAMGROUP_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	if (strClassName.CompareNoCase(_T("Win32_StartupCommand")) == 0)
	{			
		VERIFY(strFriendlyName.LoadString(IDS_STARTUPCOMMAND_DESC) && _T("could not find string resource"));
		return strFriendlyName;
	}
	ASSERT(0 && "Unknown strClassName");
	return "";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\historyparser.h ===
// HistoryParser.h: interface for the CHistoryParser class.
//
//////////////////////////////////////////////////////////////////////
//hcp://system/sysinfo/msinfo.htm
#if !defined(AFX_HISTORYPARSER_H__3ECAF67C_3080_4166_A5FB_BF98C0BD9588__INCLUDED_)
#define AFX_HISTORYPARSER_H__3ECAF67C_3080_4166_A5FB_BF98C0BD9588__INCLUDED_

#include "fdi.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "datasource.h"
#include "category.h"
extern CTime GetDateFromString(const CString& strDate, int nTimeZone);
extern CString GetIDForClass(CString strClass);
extern CTime GetDeltaTime(CComPtr<IXMLDOMNode> pDorSNode);
extern 	HRESULT GetTimeStampFromFromD_or_SNodeNode(CComPtr<IXMLDOMNode> pDorSNode,CString* pString, int& nTimeZone);
extern 	HRESULT GetDataCollectionNode(CComPtr<IXMLDOMDocument> pXMLDoc,CComPtr<IXMLDOMNode>& pDCNode);
extern CString GetPNPNameByID(CComPtr<IXMLDOMDocument> pDoc,CComBSTR bstrPNPID);



//-----------------------------------------------------------------------------
// Encapsulates data from a single Instance node in the XML blob
// Has methods for comparing identical instances across time slices
//-----------------------------------------------------------------------------

class CInstance : public CObject
{
	
	CString m_strClassName;
public:
	CString GetChangeType()
	{
		//Note:there will be no change if data is from snapshot
		CString strChange;
		m_mapNameValue.Lookup(_T("Change"),strChange);
		return strChange;
	}
	CString GetClassFriendlyName();
	HRESULT ProcessPNPAllocatedResource(CComPtr<IXMLDOMNode> pInstanceNode);
	HRESULT ProcessPropertyDotReferenceNodes(CComPtr<IXMLDOMNode> pInstanceNameNode,CString* pstrClassName, CString* pstrKeyName,CString* pstrKeyValue);
	CString GetInstanceDescription();
	CString GetDescriptionForClass(CString strClass);
	CString GetIDForClass(CString strClass);
	CInstance(CTime tmstmp, CComPtr<IXMLDOMNode> pInstanceNode,CString strClass);
	CMapStringToString m_mapNameValue;
	CTime m_tmstamp;
	CString GetClassName(){return m_strClassName;};
	BOOL GetValueFromMap(CString strKey,CString& strVal)
	{
		return m_mapNameValue.Lookup(strKey, strVal);
	};

	CString GetInstanceID();
};


//-----------------------------------------------------------------------------
// Encapsulates the parsing of history data (deltas) from the history XML blob
//-----------------------------------------------------------------------------

class CHistoryParser : public CObject  
{
private:
	CTime m_tmBack;
	CObList m_listInstances;
	CComPtr<IXMLDOMDocument> m_pDoc;
	CMSInfoHistoryCategory* m_pHistCat;
	void DeleteAllInstances();
public:
	int m_nDeltasBack;

	BOOL AreThereChangeLines();
	BOOL m_fChangeLines;
	HRESULT Refresh(CMSInfoHistoryCategory* pHistCat,int nDeltasBack);
	HRESULT GetDeltaAndSnapshotNodes(CComPtr<IXMLDOMNodeList>& pDeltaList);
	CHistoryParser(CComPtr<IXMLDOMDocument> pDoc);
	virtual ~CHistoryParser();
	CInstance* FindPreviousInstance(CInstance* pNewInstance);
	CString GetIDForClass(CString strClass);
	void CreateChangeStrings(CInstance* pOld, CInstance* pNew);
	void ResetInstance(CInstance* pOld, CInstance* pNew);
	void ProcessInstance(CInstance* pNewInstance);
	HRESULT GetInstanceNodeList(CString strClass,CComPtr<IXMLDOMNode> pDeltaNode, CComPtr<IXMLDOMNodeList>& pInstanceList);
	HRESULT ProcessDeltaNode(CComPtr<IXMLDOMNode> pDeltaNode,CString strClass);
	HRESULT ProcessDeltas(CComPtr<IXMLDOMNodeList> pDeltaList,CString strClassName,int nDeltasBack);

};
#endif // !defined(AFX_HISTORYPARSER_H__3ECAF67C_3080_4166_A5FB_BF98C0BD9588__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\infnode.h ===
/******************************************************************

infnode.h


Generic class for tracking CM32 Devnodes' INF's


first created (as such) by jeffth


Revision history


    3-99             jeffth            created                                                                    


*******************************************************************/

#ifndef _INCUDED_INFNODE_H_
#define _INCUDED_INFNODE_H_

/*******************************************************************
   INCLUDES
*******************************************************************/
#include "devnode.h"
#include <ASSERT.H>

/*******************************************************************
   DEFINES
*******************************************************************/


/*******************************************************************
   CLASSES and STRUCTS
*******************************************************************/

class InfnodeClass  : public DevnodeClass
{
public:
   ~InfnodeClass(void);
   InfnodeClass(void);
   InfnodeClass(DEVNODE dev, DEVNODE parent);

   ULONG GetInfInformation(void);
   virtual BOOL SetHandle(DEVNODE hDevnode, DEVNODE hParent = NULL);  

   // accessors:

   TCHAR * InfName(void)      {return szInfName ;};
   TCHAR * InfProvider(void)  {return szInfProvider ;};
   TCHAR * DevLoader(void)    {return szDevLoader ;};
   TCHAR * DriverName(void)   {return szDriverName ;};
   TCHAR * DriverDate(void)   {return szDriverDate ;};
   TCHAR * DriverDesc(void)   {return szDriverDesc ;};
   TCHAR * DriverVersion(void) {return szDriverVersion ;};
   TCHAR * InfSection(void)   {return szInfSection ;};


protected:
   TCHAR * szInfName;
   TCHAR * szInfProvider;
   TCHAR * szDevLoader;
   TCHAR * szDriverName;
   TCHAR * szDriverDate;
   TCHAR * szDriverDesc;
   TCHAR * szDriverVersion;
   TCHAR * szInfSection;
   
private:
};


/*******************************************************************
   GLOBALS
*******************************************************************/


/*******************************************************************
   PROTOTYPES
*******************************************************************/

ULONG ReadRegKeyInformationSZ (HKEY RootKey, TCHAR *KeyName, TCHAR **Value);

ULONG EnumerateTree_Infnode(void);



#endif //_INCUDED_INFNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\infnode.cpp ===
#include "stdafx.h"
#include <infnode.h>

           
InfnodeClass::InfnodeClass(void)
{
   szInfName      = NULL;
   szInfProvider  = NULL;
   szDevLoader    = NULL;
   szDriverName   = NULL;
   szDriverDate   = NULL;
   szDriverDesc   = NULL;
   szDriverVersion= NULL;
   szInfSection   = NULL;   
}

InfnodeClass::InfnodeClass(DEVNODE hDevice, DEVNODE hParent) : DevnodeClass(hDevice, hParent)
{
   szInfName      = NULL;
   szInfProvider  = NULL;
   szDevLoader    = NULL;
   szDriverName   = NULL;
   szDriverDate   = NULL;
   szDriverDesc   = NULL;
   szDriverVersion= NULL;
   szInfSection   = NULL;   

	GetInfInformation();
}

InfnodeClass::~InfnodeClass()
{
   if (szInfName)
   {
      delete szInfName;
      szInfName = NULL;
   }
   
   if (szInfProvider)
   {
      delete szInfProvider;
      szInfProvider = NULL;
   }
   
   if (szDevLoader)
   {
      delete szDevLoader;
      szDevLoader = NULL;
   }
   
   if (szDriverName)
   {
      delete szDriverName;
      szDriverName = NULL;
   }
   
   if (szDriverDate)
   {
      delete szDriverDate;
      szDriverDate = NULL;
   }
   
   if (szDriverDesc)
   {
      delete szDriverDesc;
      szDriverDesc = NULL;
   }
   
   if (szDriverVersion)
   {
      delete szDriverVersion;
      szDriverVersion = NULL;
   }
   if (szInfSection)
   {
      delete szInfSection;
      szInfSection = NULL;
   }

   
   
}


BOOL InfnodeClass::SetHandle(DEVNODE hDevnode, DEVNODE hParent)
{
   this->DevnodeClass::SetHandle(hDevnode, hParent);
   if (szInfName)
   {
      delete szInfName;
      szInfName = NULL;
   }
   
   if (szInfProvider)
   {
      delete szInfProvider;
      szInfProvider = NULL;
   }
   
   if (szDevLoader)
   {
      delete szDevLoader;
      szDevLoader = NULL;
   }
   
   if (szDriverName)
   {
      delete szDriverName;
      szDriverName = NULL;
   }
   
   if (szDriverDate)
   {
      delete szDriverDate;
      szDriverDate = NULL;
   }
   
   if (szDriverDesc)
   {
      delete szDriverDesc;
      szDriverDesc = NULL;
   }
   
   if (szDriverVersion)
   {
      delete szDriverVersion;
      szDriverVersion = NULL;
   }
   if (szInfSection)
   {
      delete szInfSection;
      szInfSection = NULL;
   }
   return  GetInfInformation();

}




ULONG InfnodeClass::GetInfInformation(void)
{
   if (!hDevnode)
   {
      return CR_NO_SUCH_DEVNODE;
   }
   
   CONFIGRET  retval;
   HKEY       DriverKey;
   
   // open the device key
   retval = CM_Open_DevNode_Key(hDevnode,
                              KEY_READ,
                              0, // current Profile
                              RegDisposition_OpenExisting,
                              &DriverKey,
                              CM_REGISTRY_SOFTWARE);
   
   if (retval || !DriverKey || (DriverKey == INVALID_HANDLE_VALUE)) return retval;
   
   // read the szInfName
   retval = ReadRegKeyInformationSZ(DriverKey, TEXT("InfPath"), &szInfName );
      
   // read the szInfProvider
   retval = ReadRegKeyInformationSZ(DriverKey, TEXT("ProviderName"), &szInfProvider );
      
   // read the szDevLoader
   retval = ReadRegKeyInformationSZ(DriverKey, TEXT("DevLoader"), &szDevLoader );
      
   // read the szDriverName
   retval = ReadRegKeyInformationSZ(DriverKey, TEXT("Driver"), &szDriverName );
      
   // read the szDriverDate
   retval = ReadRegKeyInformationSZ(DriverKey, TEXT("DriverDate"), &szDriverDate );
      
   // read the driver description
   retval = ReadRegKeyInformationSZ(DriverKey, TEXT("DriverDesc"), &szDriverDesc );
      
   // read the driver version
   retval = ReadRegKeyInformationSZ(DriverKey, TEXT("DriverVersion"), &szDriverVersion );
      
   // read the section name
   retval = ReadRegKeyInformationSZ(DriverKey, TEXT("InfSection"), &szInfSection );

   if (!pszClass)
   {
      //TCHAR text[512];
	  CString strPath;
	  TCHAR InfNameAndPath[_MAX_PATH];
		
	  // find windows inf dir
	  //sprintf(text, _T("%%windir%%\\inf\\%s"), szInfName);
	  strPath.Format(_T("%%windir%%\\inf\\%s"), szInfName);
	  ExpandEnvironmentStrings(strPath, InfNameAndPath, _MAX_PATH);

      TCHAR text[512];
      if (GetPrivateProfileString(_T("Version"), _T("Class"), _T("Unknown"), text, 511, InfNameAndPath))
      {
         pszClass = new TCHAR[strlen(text) + 1];
         strcpy(pszClass, text);
		 _strupr(pszClass);
      }
	  
   }
   
   return retval;
 }


BOOL Enumerate_WalkTree_Infnode(DEVNODE hDevnode, DEVNODE hParent)
{
   CONFIGRET retval;
   DevnodeClass *pNewDevice;
   DEVNODE hSib;

   pNewDevice = new InfnodeClass(hDevnode, hParent);
   
   retval = pNewDevice->GetChild(&hSib);
   if ( !retval )
   {
      Enumerate_WalkTree_Infnode(hSib, hDevnode);
   }
   retval = pNewDevice->GetSibling(&hSib);
   if ( !retval )
   {
      Enumerate_WalkTree_Infnode(hSib, hParent);
   }

   return (retval);


}


ULONG EnumerateTree_Infnode(void)
{

   DEVNODE hDevnode;

   CM_Locate_DevNode(&hDevnode, NULL, CM_LOCATE_DEVNODE_NORMAL);
   Enumerate_WalkTree_Infnode(hDevnode, NULL);

   return (DevnodeClass::ALCCount());

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\livedata.cpp ===
//=============================================================================
// This file contains code to implement the CMSInfoCategory derived class for
// showing live WMI data.
//=============================================================================

#include "stdafx.h"
#include "resource.h"
#include "category.h"
#include "datasource.h"
#include "dataset.h"
#include "refreshthread.h"
#include "refreshdialog.h"
#include "wbemcli.h"
#include "version5extension.h"
#include "filestuff.h"
#include "historyparser.h"
//=============================================================================
// CLiveDataSource
//
// TBD - need methods to look at deltas. How will this work?
//=============================================================================

CLiveDataSource::CLiveDataSource() : m_hwnd(NULL), m_pThread(NULL), m_strMachine(_T("")), m_pHistoryRoot(NULL), m_iDeltaIndex(-1)
{
}

//-----------------------------------------------------------------------------
// The default constructor will take care of deleting the tree.
//-----------------------------------------------------------------------------

CLiveDataSource::~CLiveDataSource()
{
	if (m_pThread)
		delete m_pThread;
}

//-----------------------------------------------------------------------------
// Creating a live data source consists of making the WMI connection to the
// appropriate machine (most likely this one). We'll also need to load the
// tree with default categories.
//
// TBD - also load extensions
//-----------------------------------------------------------------------------

extern CMSInfoLiveCategory catSystemSummary;
extern CMSInfoHistoryCategory catHistorySystemSummary;

HRESULT CLiveDataSource::Create(LPCTSTR szMachine, HWND hwnd, LPCTSTR szFilter)
{
	// Build the tree. The default categories are stored in a static
	// set of structures - the base of which is catSystemSummary.

	m_pHistoryRoot = &catHistorySystemSummary;
	m_pRoot = &catSystemSummary;
	m_fStaticTree = TRUE;

	// Load any extensions to the live data.

	AddExtensions();

	// If there is a string containing a filter of what categories
	// to show, apply that filter.

	if (szFilter && szFilter[0])
		ApplyCategoryFilter(szFilter);

	// Save the machine name we are remoting to.

	m_strMachine = szMachine;
	SetMachineForCategories((CMSInfoLiveCategory *) m_pRoot);

	// Create the refresh thread for the live data source.

	m_pThread = new CRefreshThread(hwnd);
	if (m_pThread)
		m_pThread->m_strMachine = szMachine;

	m_hwnd = hwnd;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Apply the set of filters to the categories. If the filter string is not
// empty, we should start out showing none of the categories, and only add in
// the ones specified by the filter (this is to match a feature in 5.0).
//-----------------------------------------------------------------------------

void CLiveDataSource::ApplyCategoryFilter(LPCTSTR szFilter)
{
	m_pRoot->SetShowCategory(FALSE);

	CString strNode, strFilter(szFilter);
	strFilter.TrimLeft(_T(" \"=:"));
	strFilter.TrimRight(_T(" \"=:"));

	while (!strFilter.IsEmpty())
	{
		BOOL fAdd = (strFilter[0] == _T('+'));
		strFilter = strFilter.Mid(1);

		if (!strFilter.IsEmpty())
		{
			strNode = strFilter.SpanExcluding(_T("+-"));
			strFilter = strFilter.Mid(strNode.GetLength());

			if (!strNode.IsEmpty())
			{
				CMSInfoLiveCategory * pNode;

				if (strNode.CompareNoCase(_T("all")) == 0)
					pNode = (CMSInfoLiveCategory *) m_pRoot;
				else
					pNode = GetNodeByName(strNode, (CMSInfoLiveCategory *) m_pRoot);

				if (pNode)
					pNode->SetShowCategory(fAdd);
			}
		}
	}
}

//-----------------------------------------------------------------------------
// Add version 5.0 extensions to the m_pRoot category tree.
//
// Note - we only want to do this once. And we only want to delete the nodes
// we added once (when we're unloading). So we'll create a simple class to
// manage this lifetime.
//
// THIS CLASS IS DANGEROUS (and this should probably be redesigned). It should
// only be used to add extensions to a static tree, that won't be deleted
// any time before the app exits. This class assumes the responsibility for
// deleting the dynamic nodes inserted into the tree.
//-----------------------------------------------------------------------------

class CManageExtensionCategories
{
public:
	CManageExtensionCategories() : m_pRoot(NULL) {};
	~CManageExtensionCategories() { DeleteTree(m_pRoot); };
	BOOL ExtensionsAdded(CMSInfoLiveCategory * pRoot) 
	{ 
		if (m_pRoot) 
			return TRUE;
		m_pRoot = pRoot;
		return FALSE;
	}

private:
	CMSInfoLiveCategory * m_pRoot;

	void DeleteTree(CMSInfoLiveCategory * pRoot)
	{
		if (pRoot == NULL)
			return;

		for (CMSInfoLiveCategory * pChild = (CMSInfoLiveCategory *) pRoot->GetFirstChild(); pChild;)
		{
			CMSInfoLiveCategory * pNext = (CMSInfoLiveCategory *) pChild->GetNextSibling();
			DeleteTree(pChild);
			pChild = pNext;
		}

		// If the tree is static, then don't actually delete, just reset
		// some state variables (possibly).

		if (pRoot->m_fDynamicColumns)
			delete pRoot;
	}
};
CManageExtensionCategories gManageExtensionCategories;

extern BOOL FileExists(const CString & strFile);
void CLiveDataSource::AddExtensions()
{
	if (gManageExtensionCategories.ExtensionsAdded((CMSInfoLiveCategory *) m_pRoot))
		return;

	CStringList strlistExtensions;

	GetExtensionSet(strlistExtensions);
	while (!strlistExtensions.IsEmpty())
	{
		CString strExtension = strlistExtensions.RemoveHead();
		if (FileExists(strExtension))
		{
			CMapWordToPtr	mapVersion5Categories;

			DWORD dwRootID = CTemplateFileFunctions::ParseTemplateIntoVersion5Categories(strExtension, mapVersion5Categories);
			ConvertVersion5Categories(mapVersion5Categories, dwRootID, (CMSInfoLiveCategory *) m_pRoot);
		}
	}
}

//-----------------------------------------------------------------------------
// Look for all of the version 5.0 style extension. These will be located as
// values under the msinfo\templates registry key.
//-----------------------------------------------------------------------------

void CLiveDataSource::GetExtensionSet(CStringList & strlistExtensions)
{
	strlistExtensions.RemoveAll();

	TCHAR	szBaseKey[] = _T("SOFTWARE\\Microsoft\\Shared Tools\\MSInfo\\templates");
	HKEY	hkeyBase;

	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBaseKey, 0, KEY_READ, &hkeyBase))
	{
		TCHAR szName[64], szValue[MAX_PATH];
		DWORD dwIndex = 0;
		DWORD dwLength = sizeof(szName) / sizeof(TCHAR);
		
		while (ERROR_SUCCESS == RegEnumKeyEx(hkeyBase, dwIndex++, szName, &dwLength, NULL, NULL, NULL, NULL))
		{
			dwLength = sizeof(szValue) / sizeof(TCHAR);
			if (ERROR_SUCCESS == RegQueryValue(hkeyBase, szName, szValue, (long *)&dwLength))
				if (*szValue)
					strlistExtensions.AddTail(szValue);
				
			dwLength = sizeof(szName) / sizeof(TCHAR);
		}

		RegCloseKey(hkeyBase);
	}
}

//-----------------------------------------------------------------------------
// Convert the categories from version 5.0 format (in the map) to our
// format in the tree structure.
//-----------------------------------------------------------------------------

extern CMSInfoLiveCategory catSystemSummary;

void CLiveDataSource::ConvertVersion5Categories(CMapWordToPtr & mapVersion5Categories, DWORD dwRootID, CMSInfoLiveCategory * m_pRoot)
{
	WORD					wMapID;
	INTERNAL_CATEGORY *		pCategory;
	POSITION				pos;
	DWORD					dwID = dwRootID;
	CMSInfoLiveCategory *	pInsertCat;

	while ((pCategory = CTemplateFileFunctions::GetInternalRep(mapVersion5Categories, dwID)) != NULL)
	{
		INTERNAL_CATEGORY * pPrev = CTemplateFileFunctions::GetInternalRep(mapVersion5Categories, pCategory->m_dwPrevID);
		if (pPrev && (pInsertCat = GetNodeByName(pPrev->m_strIdentifier, m_pRoot)))
		{
			CMSInfoLiveCategory * pNewCat = MakeVersion6Category(pCategory);
			pNewCat->m_pPrevSibling = pInsertCat;
			pNewCat->m_pNextSibling = pInsertCat->m_pNextSibling;
			pNewCat->m_pParent = pInsertCat->m_pParent;
			pInsertCat->m_pNextSibling = pNewCat;
			if (pNewCat->m_pNextSibling)
				pNewCat->m_pNextSibling->m_pPrevSibling = pNewCat;
		}
		else
		{
			INTERNAL_CATEGORY * pParent = CTemplateFileFunctions::GetInternalRep(mapVersion5Categories, pCategory->m_dwParentID);
			
			CString strIdentifier;
			if (pParent)
				strIdentifier = pParent->m_strIdentifier;
			else
				catSystemSummary.GetNames(NULL, &strIdentifier);

			if ((pInsertCat = GetNodeByName(strIdentifier, m_pRoot)) != NULL)
			{
				CMSInfoLiveCategory * pNewCat = MakeVersion6Category(pCategory);

				if (pInsertCat->m_pFirstChild == NULL)
				{
					pNewCat->m_pPrevSibling = NULL;
					pNewCat->m_pNextSibling = NULL;
					pNewCat->m_pParent = pInsertCat;
					pInsertCat->m_pFirstChild = pNewCat;
				}
				else
				{
					CMSInfoLiveCategory * pInsertAfter = (CMSInfoLiveCategory *) pInsertCat->m_pFirstChild;
					while (pInsertAfter->m_pNextSibling)
						pInsertAfter = (CMSInfoLiveCategory *) pInsertAfter->m_pNextSibling;

					pNewCat->m_pPrevSibling = pInsertAfter;
					pNewCat->m_pNextSibling = NULL;
					pNewCat->m_pParent = pInsertAfter->m_pParent;
					pInsertAfter->m_pNextSibling = pNewCat;
				}
			}
		}

		dwID += 1;
	}

	for (pos = mapVersion5Categories.GetStartPosition(); pos != NULL;)
	{
		mapVersion5Categories.GetNextAssoc(pos, wMapID, (void * &) pCategory);
		if (pCategory)
			delete pCategory;
	}

	mapVersion5Categories.RemoveAll();
}

//-----------------------------------------------------------------------------
// Look for a node in the tree with the specified name.
//-----------------------------------------------------------------------------

CMSInfoLiveCategory * CLiveDataSource::GetNodeByName(const CString & strSearch, CMSInfoLiveCategory * pRoot)
{
	if (pRoot == NULL)
		return NULL;

	CString strName;
	pRoot->GetNames(NULL, &strName);

	if (strName.CompareNoCase(strSearch) == 0)
		return pRoot;

	CMSInfoLiveCategory * pSearch = GetNodeByName(strSearch, (CMSInfoLiveCategory *) pRoot->m_pNextSibling);
	if (pSearch)
		return pSearch;

	pSearch = GetNodeByName(strSearch, (CMSInfoLiveCategory *) pRoot->m_pFirstChild);
	if (pSearch)
		return pSearch;

	return NULL;
}

//-----------------------------------------------------------------------------
// Create a version 6.0 category structure out of a version 5.0 category
// structure.
//-----------------------------------------------------------------------------

CMSInfoLiveCategory * CLiveDataSource::MakeVersion6Category(INTERNAL_CATEGORY * pCategory5)
{
	CMSInfoLiveCategory * pCategory6 = new CMSInfoLiveCategory(pCategory5);
	return pCategory6;
}

//-----------------------------------------------------------------------------
// Propagate the machine name through the entire category tree.
//-----------------------------------------------------------------------------

void CLiveDataSource::SetMachineForCategories(CMSInfoLiveCategory * pCategory)
{
	if (pCategory)
	{
		for (CMSInfoLiveCategory * pChild = (CMSInfoLiveCategory *) pCategory->GetFirstChild(); pChild;)
		{
			CMSInfoLiveCategory * pNext = (CMSInfoLiveCategory *) pChild->GetNextSibling();
			SetMachineForCategories(pChild);
			pChild = pNext;
		}

		pCategory->SetMachine(m_strMachine);
	}
}

//-----------------------------------------------------------------------------
// Update the category tree to show delta information. Also changes which
// tree should be returned.
// 
// An index of -1 means show current system information.
//
// If the function returns TRUE, then the tree doesn't need to be rebuild
// (although the selected category needs to be refreshed).
//-----------------------------------------------------------------------------

BOOL CLiveDataSource::ShowDeltas(int iDeltaIndex)
{
	BOOL fUpdateTree = FALSE;

	if (m_iDeltaIndex != iDeltaIndex)
	{

		if (m_iDeltaIndex == -1 || iDeltaIndex == -1)
		fUpdateTree = TRUE;
#ifdef A_STEPHL
		/*CString strMSG;
		strMSG.Format("iDeltaIndex= %d, m_iDeltaIndex =%d \n",iDeltaIndex,m_iDeltaIndex);
		::MessageBox(NULL,strMSG,"",MB_OK);*/
#endif

		m_iDeltaIndex = iDeltaIndex;
		if (m_iDeltaIndex != -1)
		{
			// The user has selected a new delta period, and it's different
			// than the last one. We need to mark the categories in the tree
			// as not refreshed, and set the delta index.

			if (m_pHistoryRoot)
				m_pHistoryRoot->UpdateDeltaIndex(m_iDeltaIndex);
		}
	}
	else
	{
#ifdef A_STEPHL2
		::MessageBox(NULL,"m_iDeltaIndex == iDeltaIndex","",MB_OK);
#endif	
		return TRUE;
	}

	return !fUpdateTree;
}

//-----------------------------------------------------------------------------
// Populate the list of available deltas.
//-----------------------------------------------------------------------------

BOOL CLiveDataSource::GetDeltaList(CStringList * pstrlist)
{
	ASSERT(pstrlist);
	if (pstrlist == NULL)
		return FALSE;

	pstrlist->RemoveAll();

	if (m_pHistoryRoot == NULL)
	{
		ASSERT(0 && "Root node is not yet created");	
	}

	CComPtr<IXMLDOMDocument> pXMLDoc = GetXMLDoc();
	CComPtr<IXMLDOMNode> pDCNode;
	HRESULT hr = GetDataCollectionNode( pXMLDoc,pDCNode);
	if (FAILED(hr) || !pDCNode)
	{
		return FALSE;
	}
	CComPtr<IXMLDOMNodeList> pList;
	hr = pDCNode->selectNodes(L"Delta",&pList);
	if (FAILED(hr) || !pList)
	{
		ASSERT(0 && "could not get list of delta nodes");
		return FALSE;
	}
	long lListLen;
	hr = pList->get_length(&lListLen);
	if (lListLen == 0)
	{
		//we may have an incident file, which capitalizes "DELTA"
		pList.Release();
		hr = pDCNode->selectNodes(L"DELTA",&pList);
		if (FAILED(hr) || !pList)
		{
			ASSERT(0 && "could not get list of delta nodes");
			return FALSE;
		}
		hr = pList->get_length(&lListLen);
	}
	if (lListLen > 0)
	{
		CComPtr<IXMLDOMNode> pDeltaNode;
		CString strDate(_T(""));
		TCHAR szBuffer[MAX_PATH];	// seems plenty big
		for(long i = 0 ;i < lListLen;i++)
		{
			hr = pList->nextNode(&pDeltaNode);
			if (FAILED(hr) || !pDeltaNode)
			{
				ASSERT(0 && "could not get next node from list");
				break;
			}
			CComVariant varTS;
			CComPtr<IXMLDOMElement> pTimestampElement;
			hr = pDeltaNode->QueryInterface(IID_IXMLDOMElement,(void**) &pTimestampElement);
			pDeltaNode.Release();
			if (FAILED(hr) || !pTimestampElement)
			{
				ASSERT(0 && "could not get attribute element");
				break;
			}
			hr = pTimestampElement->getAttribute(L"Timestamp_T0",&varTS);
			if (FAILED(hr) )
			{
				ASSERT(0 && "could not get timestamp value from attribute");
			}
			//now get time zone (number of seconds difference between local time and UTC)
			CComVariant varTzoneDeltaSeconds;
			hr = pTimestampElement->getAttribute(L"TimeZone",&varTzoneDeltaSeconds);
			if (FAILED(hr) ) //this will happen when loading WinME xml, which has no timezone info
			{
				varTzoneDeltaSeconds = 0;
			}
			//make sure we have an integer type
			hr = varTzoneDeltaSeconds.ChangeType(VT_INT);
			if (FAILED(hr) ) 
			{
				varTzoneDeltaSeconds = 0;
			}
			USES_CONVERSION;

			pTimestampElement.Release();
			CString strTimestamp = OLE2A(varTS.bstrVal);
			CTime tm1 = GetDateFromString(strTimestamp,varTzoneDeltaSeconds.intVal);
			COleDateTime olDate(tm1.GetTime());	

			// Try to get the date in the localized format.

			strDate.Empty();
			SYSTEMTIME systime;
			if (olDate.GetAsSystemTime(systime))
			{
				DWORD dwLayout = 0;
				::GetProcessDefaultLayout(&dwLayout);

				// For some reason, in HEB we don't want to use the DATE_RTLREADING flag. Bug 434802.

				if (LANG_HEBREW == PRIMARYLANGID(::GetUserDefaultUILanguage()))
					dwLayout &= ~LAYOUT_RTL; // force the non-use of DATE_RTLREADING

				if (::GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE | (((dwLayout & LAYOUT_RTL) != 0) ? DATE_RTLREADING : 0), &systime, NULL, szBuffer, MAX_PATH))
				{
					strDate = szBuffer;
					if (::GetTimeFormat(LOCALE_USER_DEFAULT, 0, &systime, NULL, szBuffer, MAX_PATH))
						strDate += CString(_T(" ")) + CString(szBuffer);
				}
			}

			// Fall back on our old (partially incorrect) method.

			if (strDate.IsEmpty())
				strDate = olDate.Format(0, LOCALE_USER_DEFAULT);

			pstrlist->AddTail(strDate);
		}
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Return an HRESULT indicating whether or not this is a valid data source.
// This is primarily useful when we're remoting to a machine and we want to
// determine if the network name is accessible.
//-----------------------------------------------------------------------------

HRESULT CLiveDataSource::ValidDataSource()
{
	if (m_pThread == NULL)
		return E_FAIL;

	return (m_pThread->CheckWMIConnection());
}

//=============================================================================
// CMSInfoLiveCategory
//=============================================================================

//-----------------------------------------------------------------------------
// The constructor needs to initialize some member variables, and make sure
// that the category is inserted into the tree correctly.
//-----------------------------------------------------------------------------

CMSInfoLiveCategory::CMSInfoLiveCategory(UINT uiCaption, LPCTSTR szName, RefreshFunction pFunction, DWORD dwRefreshIndex, CMSInfoCategory * pParent, CMSInfoCategory * pPrevious, const CString & strHelpTopic, CMSInfoColumn * pColumns, BOOL fDynamicColumns, CategoryEnvironment environment) :
 CMSInfoCategory(uiCaption, szName, pParent, pPrevious, pColumns, fDynamicColumns, environment),
 m_pRefreshFunction(pFunction),
 m_dwLastRefresh(0),
 m_dwRefreshIndex(dwRefreshIndex),
 m_strMachine(_T("")),
 m_strHelpTopic(strHelpTopic)
{
	// Insert ourselves into the category tree. This means making sure that
	// our parent and previous sibling point to us.

	if (m_pParent && m_pParent->m_pFirstChild == NULL)
		m_pParent->m_pFirstChild = this;

	if (m_pPrevSibling)
	{
		if (m_pPrevSibling->m_pNextSibling == NULL)
			m_pPrevSibling->m_pNextSibling = this;
		else
		{
			CMSInfoCategory * pScan = m_pPrevSibling->m_pNextSibling;
			while (pScan->m_pNextSibling)
				pScan = pScan->m_pNextSibling;
			pScan->m_pNextSibling = this;
		}
	}
}

CMSInfoLiveCategory::~CMSInfoLiveCategory()
{
}

//-----------------------------------------------------------------------------
// The copy constructor will copy the members, but not allocate a new sub-tree
// (the new category has the same children and siblings as the original).
//-----------------------------------------------------------------------------

CMSInfoLiveCategory::CMSInfoLiveCategory(CMSInfoLiveCategory & copyfrom) : 
 m_dwLastRefresh(0),
 m_dwRefreshIndex(copyfrom.m_dwRefreshIndex),
 m_pRefreshFunction(copyfrom.m_pRefreshFunction)
{
	m_strMachine	= copyfrom.m_strMachine;
	m_strHelpTopic	= copyfrom.m_strHelpTopic;
	m_uiCaption		= copyfrom.m_uiCaption;
	m_pParent		= copyfrom.m_pParent;
	m_pPrevSibling	= copyfrom.m_pPrevSibling;
	m_pFirstChild	= copyfrom.m_pFirstChild;
	m_pNextSibling	= copyfrom.m_pNextSibling;

	m_astrData		= NULL;
	m_adwData		= NULL;
	m_afRowAdvanced = NULL;

	m_strName		= copyfrom.m_strName;
	m_hrError		= S_OK;
	
	m_acolumns			= copyfrom.m_acolumns;
	m_fDynamicColumns	= FALSE;

	m_iRowCount = 0;
	m_iColCount = copyfrom.m_iColCount;

	m_iSortColumn	= copyfrom.m_iSortColumn;
	m_hti			= NULL;

	m_fSkipCategory = copyfrom.m_fSkipCategory;
}

//-----------------------------------------------------------------------------
// Constructs a category from an old (version 5.0) category structure.
//-----------------------------------------------------------------------------

extern HRESULT RefreshExtensions(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache);
CMSInfoLiveCategory::CMSInfoLiveCategory(INTERNAL_CATEGORY * pinternalcat)
{
	ASSERT(pinternalcat);
	if (pinternalcat == NULL)
		return;

	m_dwLastRefresh = 0;
	m_strMachine = CString(_T(""));
	m_strHelpTopic = CString(_T(""));
	
	// Graft on a help topic for the IE extension (bug 479839).

	if (pinternalcat->m_strIdentifier.CompareNoCase(_T("InternetSettings")) == 0)
		m_strHelpTopic = _T("msinfo_internet_settings.htm");

	m_strCaption	= pinternalcat->m_fieldName.m_strFormat;
	m_strName		= pinternalcat->m_strIdentifier;

	m_iRowCount = 0;
	m_iColCount = 0;

	GATH_FIELD * pField = pinternalcat->m_pColSpec;
	while (pField)
	{
		m_iColCount += 1;
		pField = pField->m_pNext;
	}

	if (m_iColCount)
	{
		m_acolumns = new CMSInfoColumn[m_iColCount];
		if (m_acolumns && pinternalcat->m_pColSpec)
		{
			m_fDynamicColumns = TRUE;
			pField = pinternalcat->m_pColSpec;

			for (int iCol = 0; iCol < m_iColCount && pField != NULL; iCol++)
			{
				m_acolumns[iCol].m_fAdvanced = (pField->m_datacomplexity == ADVANCED);
				m_acolumns[iCol].m_strCaption = pField->m_strFormat;
				m_acolumns[iCol].m_uiWidth = pField->m_usWidth;
				m_acolumns[iCol].m_fSorts = (pField->m_sort != NOSORT);
				m_acolumns[iCol].m_fLexical = (pField->m_sort == LEXICAL);

				pField = pField->m_pNext;
			}
		}
	}

	// Insert the information needed to refresh the extension category (such
	// as line specs) into a map, indexed by a DWORD. That DWORD will be saved
	// for the category, so we can look up the refresh data later.

	if (pinternalcat->m_pLineSpec)
	{
		m_dwRefreshIndex = gmapExtensionRefreshData.Insert(pinternalcat->m_pLineSpec);
		pinternalcat->m_pLineSpec = NULL; // keep this from being deleted
		m_pRefreshFunction = &RefreshExtensions;
	}
	else
	{
		m_dwRefreshIndex = 0;
		m_pRefreshFunction = NULL;
	}

	if (m_dwRefreshIndex)
		gmapExtensionRefreshData.InsertString(m_dwRefreshIndex, pinternalcat->m_strNoInstances);
}

//-----------------------------------------------------------------------------
// Start a refresh (starts the thread, which will send a message when it's
// done).
//-----------------------------------------------------------------------------

BOOL CMSInfoLiveCategory::Refresh(CLiveDataSource * pSource, BOOL fRecursive)
{
	if (pSource && pSource->m_pThread)
		pSource->m_pThread->StartRefresh(this, fRecursive);

	return TRUE;
}

//-----------------------------------------------------------------------------
// Start a synchronous refresh. This function won't return until the refresh
// has been completed.
//-----------------------------------------------------------------------------

BOOL CMSInfoLiveCategory::RefreshSynchronous(CLiveDataSource * pSource, BOOL fRecursive)
{
	if (pSource && pSource->m_pThread)
	{
		pSource->m_pThread->StartRefresh(this, fRecursive);
		pSource->m_pThread->WaitForRefresh();
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Refreshes the current category (and possibly the children) while presenting
// the user with a UI. A dialog box is presented to the user with the specified
// mesage. If the user clicks cancel, the refresh is cancelled and this
// function returns false. Otherwise, when the refresh is done the dialog box
// will be removed, and this funcion returns true.
//-----------------------------------------------------------------------------

BOOL CMSInfoLiveCategory::RefreshSynchronousUI(CLiveDataSource * pSource, BOOL fRecursive, UINT uiMessage, HWND hwnd)
{
	if (pSource && pSource->m_pThread)
	{
		pSource->m_pThread->StartRefresh(this, fRecursive);

		::AfxSetResourceHandle(_Module.GetResourceInstance());
		CWnd * pWnd = CWnd::FromHandle(hwnd);
//		CRefreshDialog refreshdialog(pWnd);
//		refreshdialog.DoModal();

		if (pSource->m_pThread->IsRefreshing())
		{
			pSource->m_pThread->CancelRefresh();
			return FALSE;
		}
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Get the error strings for this category (subclasses should override this).
//-----------------------------------------------------------------------------

void CMSInfoLiveCategory::GetErrorText(CString * pstrTitle, CString * pstrMessage)
{
	if (SUCCEEDED(m_hrError))
	{
		ASSERT(0 && "why call GetErrorText for no error?");
		CMSInfoCategory::GetErrorText(pstrTitle, pstrMessage);
		return;
	}

	if (pstrTitle)
		pstrTitle->LoadString(IDS_CANTCOLLECT);

	if (pstrMessage)
	{
		switch (m_hrError)
		{
		case WBEM_E_OUT_OF_MEMORY:
			pstrMessage->LoadString(IDS_OUTOFMEMERROR);
			break;

		case WBEM_E_ACCESS_DENIED:
			if (m_strMachine.IsEmpty())
				pstrMessage->LoadString(IDS_GATHERACCESS_LOCAL);
			else
				pstrMessage->Format(IDS_GATHERACCESS, m_strMachine);
			break;

		case WBEM_E_INVALID_NAMESPACE:
			if (m_strMachine.IsEmpty())
				pstrMessage->LoadString(IDS_BADSERVER_LOCAL);
			else
				pstrMessage->Format(IDS_BADSERVER, m_strMachine);
			break;

		case 0x800706BA:	// RPC Server Unavailable
		case WBEM_E_TRANSPORT_FAILURE:
			if (m_strMachine.IsEmpty())
				pstrMessage->LoadString(IDS_NETWORKERROR_LOCAL);
			else
				pstrMessage->Format(IDS_NETWORKERROR, m_strMachine);
			break;

		case WBEM_E_FAILED:
		case WBEM_E_INVALID_PARAMETER:
		default:
			pstrMessage->LoadString(IDS_UNEXPECTED);
		}

#ifdef _DEBUG
		{
			CString strTemp;
			strTemp.Format(_T("\n\r\n\rDebug Version Only: [HRESULT = 0x%08X]"), m_hrError);
			*pstrMessage += strTemp;
		}
#endif
	}
}

//=============================================================================
// CMSInfoHistoryCategory
//=============================================================================

//-----------------------------------------------------------------------------
// This refresh overrides the live category refresh (which starts a WMI refresh
// using another thread). This version just fills in the variables from the
// base classes (like m_astrData) based on which category we're view in
// history mode.
//-----------------------------------------------------------------------------

extern CMSInfoHistoryCategory catHistorySystemSummary;
extern CMSInfoHistoryCategory catHistoryResources;
extern CMSInfoHistoryCategory catHistoryComponents;
extern CMSInfoHistoryCategory catHistorySWEnv;

BOOL CMSInfoHistoryCategory::Refresh(CLiveDataSource * pSource, BOOL fRecursive)
{
	HCURSOR hc = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
	if (pSource->GetXMLDoc())
	{
		CHistoryParser HParser(pSource->GetXMLDoc());
		
		HRESULT hr = HParser.Refresh(this, pSource->m_iDeltaIndex );
		if (HParser.AreThereChangeLines() == TRUE)
		{
			//commitlines doesn't like it if there are no change lines
			this->CommitLines();
		}

		if (pSource->m_hwnd)
			::PostMessage(pSource->m_hwnd, WM_MSINFODATAREADY, 0, (LPARAM)this);
		m_dwLastRefresh = ::GetTickCount();
		if (fRecursive)
		{
			for(CMSInfoCategory* pChildCat = (CMSInfoCategory*) this->GetFirstChild();pChildCat != NULL;pChildCat = (CMSInfoCategory*) pChildCat->GetNextSibling())
			{
				if(pChildCat->GetDataSourceType() == LIVE_DATA)
				{
					if (!((CMSInfoHistoryCategory*)pChildCat)->Refresh(pSource,fRecursive))
					{
						::SetCursor(hc);				
						return FALSE;
					}
				}
			}

		}
	}
	::SetCursor(hc);
	return TRUE;
}

//-----------------------------------------------------------------------------
// Call ClearLines before lines are inserted in the output.
//-----------------------------------------------------------------------------

void CMSInfoHistoryCategory::ClearLines()
{
	DeleteContent();
	
	for (int iCol = 0; iCol < 5; iCol++)
		while (!m_aValList[iCol].IsEmpty())
			delete (CMSIValue *) m_aValList[iCol].RemoveHead();
}

//-----------------------------------------------------------------------------
// Call CommitLines after all of the Insert operations are completed. This will
// transfer the values from the lists of CMSIValues to the data arrays.
//-----------------------------------------------------------------------------

void CMSInfoHistoryCategory::CommitLines()
{
	int iRowCount = (int)m_aValList[0].GetCount();

#ifdef _DEBUG
	for (int i = 0; i < 5; i++)
		ASSERT(iRowCount == m_aValList[i].GetCount());
#endif

	if (iRowCount)
		AllocateContent(iRowCount);

	for (int j = 0; j < 5; j++)
		for (int i = 0; i < m_iRowCount; i++)
		{
			CMSIValue * pValue = (CMSIValue *) m_aValList[j].RemoveHead();
			
			if (j < 4 || this != &catHistorySystemSummary)
				SetData(i, j, pValue->m_strValue, pValue->m_dwValue);
			
			// Set the advanced flag for either the first column, or
			// for any column which is advanced (any cell in a row
			// being advanced makes the whole row advanced).

			if (j == 0 || pValue->m_fAdvanced)
				SetAdvancedFlag(i, pValue->m_fAdvanced);

			delete pValue;
		}
}

//-----------------------------------------------------------------------------
// Various functions to insert different types of events in the history.
//-----------------------------------------------------------------------------

void CMSInfoHistoryCategory::InsertChangeLine(CTime tm, LPCTSTR szType, LPCTSTR szName, LPCTSTR szProperty, LPCTSTR szFromVal, LPCTSTR szToVal)
{
	CString strDetails;

	strDetails.Format(IDS_DELTACHANGE, szProperty, szFromVal, szToVal);
	CString strCaption;
	strCaption.LoadString(IDS_HISTORYCHANGE);
	InsertLine(tm, strCaption, szType, szName, strDetails);
}

void CMSInfoHistoryCategory::InsertAddLine(CTime tm, LPCTSTR szType, LPCTSTR szName)
{
	CString strCaption;
	strCaption.LoadString(IDS_HISTORYADDED);
	InsertLine(tm, strCaption, szType, szName);
}

void CMSInfoHistoryCategory::InsertRemoveLine(CTime tm, LPCTSTR szType, LPCTSTR szName)
{
	CString strCaption;
	strCaption.LoadString(IDS_HISTORYREMOVED);
	InsertLine(tm, strCaption, szType, szName);
}

void CMSInfoHistoryCategory::InsertLine(CTime tm, LPCTSTR szOperation, LPCTSTR szType, LPCTSTR szName, LPCTSTR szDetails)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	/*CString strTime;
	if (nDays >= 0)
	{
		strTime.Format(IDS_DAYSAGO, nDays + 1);
	}
	else
	{
		//-1 indicates no changes
		strTime = "";
	}*/
	COleDateTime olTime;
	CString strTime;
	if (-1 == (int) tm.GetTime())
	{

		strTime.LoadString(IDS_NOHISTORY_AVAILABLE);
	}
	else
	{
		olTime = tm.GetTime();
		strTime = olTime.Format();

	}
	CMSIValue * pValue = new CMSIValue(strTime, (DWORD)olTime.m_dt);
	m_aValList[0].AddTail((void *) pValue);

	pValue = new CMSIValue(szOperation, 0);
	m_aValList[1].AddTail((void *) pValue);

	pValue = new CMSIValue(szName, 0);
	m_aValList[2].AddTail((void *) pValue);

	if (szDetails)
		pValue = new CMSIValue(szDetails, 0);
	else
		pValue = new CMSIValue(_T(""), 0);
	m_aValList[3].AddTail((void *) pValue);

	pValue = new CMSIValue(szType, 0);
	m_aValList[4].AddTail((void *) pValue);
}


/*void CMSInfoHistoryCategory::InsertChangeLine(int nDays, LPCTSTR szType, LPCTSTR szName, LPCTSTR szProperty, LPCTSTR szFromVal, LPCTSTR szToVal)
{
	CString strDetails;

	strDetails.Format(IDS_DELTACHANGE, szProperty, szFromVal, szToVal);
	InsertLine(nDays, _T("CHANGED"), szType, szName, strDetails);
}

void CMSInfoHistoryCategory::InsertAddLine(int nDays, LPCTSTR szType, LPCTSTR szName)
{
	InsertLine(nDays, _T("ADDED"), szType, szName);
}

void CMSInfoHistoryCategory::InsertRemoveLine(int nDays, LPCTSTR szType, LPCTSTR szName)
{
	InsertLine(nDays, _T("REMOVED"), szType, szName);
}

void CMSInfoHistoryCategory::InsertLine(int nDays, LPCTSTR szOperation, LPCTSTR szType, LPCTSTR szName, LPCTSTR szDetails)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	CString strTime;
	if (nDays >= 0)
	{
		strTime.Format(IDS_DAYSAGO, nDays + 1);
	}
	else
	{
		//-1 indicates no changes
		strTime = "";
	}

	CMSIValue * pValue = new CMSIValue(strTime, (DWORD)nDays);
	m_aValList[0].AddTail((void *) pValue);

	pValue = new CMSIValue(szOperation, 0);
	m_aValList[1].AddTail((void *) pValue);

	pValue = new CMSIValue(szName, 0);
	m_aValList[2].AddTail((void *) pValue);

	if (szDetails)
		pValue = new CMSIValue(szDetails, 0);
	else
		pValue = new CMSIValue(_T(""), 0);
	m_aValList[3].AddTail((void *) pValue);

	pValue = new CMSIValue(szType, 0);
	m_aValList[4].AddTail((void *) pValue);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\makefile.inc ===
..\html\SIhtml01.htm: ..\html\msinfo.htm
	copy /v $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msictrl.cpp ===
#include "stdafx.h"
#include "msictrl.h"
//#include "ctrlref.h"
//#include "msishell.h"

/////////////////////////////////////////////////////////////////////////////
// CMSIControl

IMPLEMENT_DYNCREATE(CMSIControl, CWnd)

CMSIControl::~CMSIControl()
{
	/*if (m_fInRefresh && m_pRefresh)
		delete m_pRefresh;*/
    ASSERT(1);
}

/////////////////////////////////////////////////////////////////////////////
// CHWDiag properties

long CMSIControl::GetMSInfoView()
{
	long	result = -1;
	DISPID	dispid;

	if (GetDISPID("MSInfoView", &dispid))
		GetProperty(dispid, VT_I4, (void*)&result);
	return result;
}

void CMSIControl::SetMSInfoView(long propVal)
{
	DISPID dispid;

	if (GetDISPID("MSInfoView", &dispid))
		SetProperty(dispid, VT_I4, propVal);
}

void CMSIControl::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

//---------------------------------------------------------------------------
// MSInfoRefresh instructs the control to refresh itself. Rather than just
// calling the method, we create a thread which calls the method.
//---------------------------------------------------------------------------

//extern CMSIShellApp theApp;
void CMSIControl::MSInfoRefresh()
{
	/*if (m_fInRefresh)
	{
		if (m_pRefresh->IsDone())
			delete m_pRefresh;
		else
		{
			MessageBeep(MB_OK);
			return;
		}
	}

	m_pRefresh = new CCtrlRefresh;
	if (m_pRefresh)
	{
		if (m_pRefresh->Create(this, THREAD_PRIORITY_NORMAL, FALSE))
		{
			m_fInRefresh = TRUE;
//			theApp.m_pCtrlInRefresh = this;
		}
		else
			delete m_pRefresh;
	}*/
}

//---------------------------------------------------------------------------
// This method returns a boolean indicating if this control is currently
// in an MSInfoRefresh operation.
//---------------------------------------------------------------------------

BOOL CMSIControl::InRefresh()
{
	return (m_fInRefresh /*&& !m_pRefresh->IsDone()*/);
}

//---------------------------------------------------------------------------
// This method cancels a refresh in progress. Note that this method does not
// call a method in the OLE control, but instead manipulate the refresh
// object (if there is one).
//---------------------------------------------------------------------------

void CMSIControl::CancelMSInfoRefresh()
{
	if (!m_fInRefresh)
		return;
	
/*	if (m_pRefresh)
	{
		delete m_pRefresh;
		m_pRefresh = NULL;
	}*/

	m_fInRefresh = FALSE;
}

void CMSIControl::MSInfoSelectAll()
{
	DISPID			dispid;

	if (GetDISPID("MSInfoSelectAll", &dispid))
		InvokeHelper(dispid, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMSIControl::MSInfoCopy()
{
	DISPID			dispid;

	if (GetDISPID("MSInfoCopy", &dispid))
		InvokeHelper(dispid, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

BOOL CMSIControl::MSInfoLoadFile(LPCTSTR strFileName)
{
	BOOL			result = FALSE;
	static BYTE		parms[] = VTS_BSTR;
	DISPID			dispid;

	if (GetDISPID("MSInfoLoadFile", &dispid))
		InvokeHelper(dispid, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms, strFileName);

	return result;
}

void CMSIControl::MSInfoUpdateView()
{
	DISPID dispid;
	if (GetDISPID("MSInfoUpdateView", &dispid))
		InvokeHelper(dispid, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CMSIControl::MSInfoGetData(long dwMSInfoView, long* pBuffer, long dwLength)
{
	long		result = -1;
	static BYTE parms[] = VTS_I4 VTS_PI4 VTS_I4;
	DISPID		dispid;

	if (GetDISPID("MSInfoGetData", &dispid))
		InvokeHelper(dispid, DISPATCH_METHOD, VT_I4, (void*)&result, parms, dwMSInfoView, pBuffer, dwLength);
	return result;
}

void CMSIControl::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

//---------------------------------------------------------------------------
// GetDISPID returns the DISPID for a given string, by looking it up using
// IDispatch->GetIDsOfNames. This avoids hardcoding DISPIDs in this class.
//---------------------------------------------------------------------------

BOOL CMSIControl::GetDISPID(char *szName, DISPID *pID)
{
	USES_CONVERSION;
	BOOL			result = FALSE;
	DISPID			dispid;
	OLECHAR FAR*	szMember = A2OLE(szName);//T2OLE(szName);
	LPDISPATCH		pDispatch;
	LPUNKNOWN		pUnknown;

	pUnknown = GetControlUnknown();
	if (pUnknown)
	{
		if (SUCCEEDED(pUnknown->QueryInterface(IID_IDispatch, (void FAR* FAR*) &pDispatch)))
		{
			if (SUCCEEDED(pDispatch->GetIDsOfNames(IID_NULL, &szMember, 1, LOCALE_SYSTEM_DEFAULT, &dispid)))
			{
				*pID = dispid;
				result = TRUE;
			}
			else
				TRACE0("+++ couldn't find method for MSInfoLoadFile\n");
			pDispatch->Release();
		}
		else
			TRACE0("+++ could not get IDispatch interface\n");
	}
	else
		TRACE0("+++ could not get IUnknown interface\n");

	return result;
}

//---------------------------------------------------------------------------
// Save the contents of the control to a stream.
//---------------------------------------------------------------------------

BOOL CMSIControl::SaveToStream(IStream *pStream)
{
	BOOL				result = FALSE;
	LPUNKNOWN			pUnknown;
	IPersistStreamInit *pPersist;

	pUnknown = GetControlUnknown();
	if (pUnknown)
	{
		if (SUCCEEDED(pUnknown->QueryInterface(IID_IPersistStreamInit, (void FAR* FAR*) &pPersist)))
		{
			result = SUCCEEDED(pPersist->Save(pStream, FALSE));
			pPersist->Release();
		}
		else
			TRACE0("+++ could not get IPersistStreamInit interface\n");
	}
	else
		TRACE0("+++ could not get IUnknown interface\n");

	return result;
}



//---------------------------------------------------------------------------
// The following code isn't used now, but might be useful later.
//---------------------------------------------------------------------------

#if FALSE
	//---------------------------------------------------------------------------
	// RefreshForSave calls the MSInfoRefresh method, but waits for it to
	// complete.
	//---------------------------------------------------------------------------

	void CMSIControl::RefreshForSave()
	{
		USES_CONVERSION;
		OLECHAR FAR*		szMember = T2OLE("MSInfoRefresh");
		DISPID				dispid;
		LPDISPATCH			pDispatch;
		DISPPARAMS			dispparamsNoArgs;
		VARIANTARG			variantargs[2];
		LPUNKNOWN			pUnknown;
		DWORD				dwCancel = 0;

		pUnknown = GetControlUnknown();
		if (pUnknown)
			if (SUCCEEDED(pUnknown->QueryInterface(IID_IDispatch, (void FAR* FAR*) &pDispatch)))
			{
				if (SUCCEEDED(pDispatch->GetIDsOfNames(IID_NULL, &szMember, 1, LOCALE_SYSTEM_DEFAULT, &dispid)))
				{
					variantargs[0].vt		= VT_I4 | VT_BYREF;
					variantargs[0].plVal	= (long *) &dwCancel;
					variantargs[1].vt		= VT_BOOL;
					variantargs[1].iVal		= (short) -1;

					dispparamsNoArgs.cNamedArgs			= 0;
					dispparamsNoArgs.rgdispidNamedArgs	= NULL;
					dispparamsNoArgs.cArgs				= 2;
					dispparamsNoArgs.rgvarg				= variantargs;

					pDispatch->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, &dispparamsNoArgs, NULL, NULL, NULL);
				}
				pDispatch->Release();
			}
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msictrl.h ===
//---------------------------------------------------------------------------
// The CMSIControl class is used to encapsulate a control which can be used
// by MSInfo to show information. This class was originally generated from
// an actual control (inserted using the component gallery). It was then
// modified to create controls with an arbitrary CLSID.
//
// Further modifications were necessary to make MSInfo truly support OLE
// controls for information categories. Specifically, we need to get the
// DISPIDs for methods and properties at runtime, rather than when the
// component was added.
//---------------------------------------------------------------------------

#ifndef __MSICTRL_H__
	#define __MSICTRL_H__

//	class CCtrlRefresh;
	class CMSIControl : public CWnd
	{
	protected:
		DECLARE_DYNCREATE(CMSIControl)

	private:
		CLSID			m_clsidCtrl;
		BOOL			m_fInRefresh;
//		CCtrlRefresh *	m_pRefresh;
	public:
		BOOL			m_fLoadFailed;

		// The control can be constructed with or without a CLSID. If none
		// is supplied to the constructor, SetCLSID must be called before
		// the control is created.

		CMSIControl()				{ /*m_pRefresh = NULL;*/ m_fInRefresh = m_fLoadFailed = FALSE; };
		CMSIControl(CLSID clsid)	{ /*m_pRefresh = NULL;*/  m_fInRefresh = m_fLoadFailed = FALSE; m_clsidCtrl = clsid; };
		~CMSIControl();
		void SetCLSID(CLSID clsid)	{ m_clsidCtrl = clsid; };
		
		// Two Create functions are supplied (in the orginal generated class).

		virtual BOOL Create(LPCTSTR /* lpszClassName */, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* /* pContext */ = NULL)
		{ return CreateControl(m_clsidCtrl, lpszWindowName, dwStyle, rect, pParentWnd, nID); };

		BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CFile* pPersist = NULL, BOOL bStorage = FALSE, BSTR bstrLicKey = NULL)
		{ return CreateControl(m_clsidCtrl, lpszWindowName, dwStyle, rect, pParentWnd, nID, pPersist, bStorage, bstrLicKey); };

		// Attributes
	public:
		long GetMSInfoView();
		void SetMSInfoView(long);

		// Operations
	public:
		void Refresh();
		void MSInfoRefresh();
		void MSInfoSelectAll();
		void MSInfoCopy();
		BOOL MSInfoLoadFile(LPCTSTR strFileName);
		void MSInfoUpdateView();
		long MSInfoGetData(long dwMSInfoView, long* pBuffer, long dwLength);
		void AboutBox();
		void CancelMSInfoRefresh();
		BOOL InRefresh();

		// Methods (which don't correspond to OLE control methods)

		BOOL GetDISPID(char *szName, DISPID *pID);
		BOOL SaveToStream(IStream *pStream);
	};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msinfo.cpp ===
//=============================================================================
// MSInfo.cpp : Implementation of CMSInfo
// 
// Contains implementation for some of the functions in the CMSInfo class
// (the ones which aren't inline).
//=============================================================================

#include "stdafx.h"
#include "Msinfo32.h"
#include "MSInfo.h"
#include "cabfunc.h"
#include "msictrl.h"
#include "MSInfo4Category.h"
#include "remotedialog.h"
#include "filestuff.h"
#include <afxole.h>
//a-kjaw
#include "dataset.h"
//a-kjaw

WNDPROC CMSInfo::m_wndprocParent = NULL;
CMSInfo * CMSInfo::m_pControl = NULL;

extern CMSInfoHistoryCategory catHistorySystemSummary;
extern CMSInfoHistoryCategory catHistoryResources;
extern CMSInfoHistoryCategory catHistoryComponents;
extern CMSInfoHistoryCategory catHistorySWEnv;

//=========================================================================
// Here's a very simple class to show a message when the data is
// being refreshed.
//=========================================================================

class CWaitForRefreshDialog : public CDialogImpl<CWaitForRefreshDialog>
{
public:
	enum { IDD = IDD_WAITFORREFRESHDIALOG };

	//-------------------------------------------------------------------------
	// Refresh the specified category using the specified source.
	//-------------------------------------------------------------------------

	int DoRefresh(CLiveDataSource * pSource, CMSInfoLiveCategory * pLiveCategory)
	{
		m_pSource = pSource;
		m_pLiveCategory = pLiveCategory;
		m_nCategories = pLiveCategory->GetCategoryCount();
		if (m_nCategories == 0) m_nCategories = 1;	// should never happen
		return (int)DoModal();
	};

	//-------------------------------------------------------------------------
	// When the dialog initializes, the source and category pointers should
	// have already been set. Start the refresh and create a timer to control
	// the update of information on the dialog. The timer is set to 500ms.
	//-------------------------------------------------------------------------

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (m_pSource && m_pSource->m_pThread && m_pLiveCategory)
			m_pSource->m_pThread->StartRefresh(m_pLiveCategory, TRUE);
		m_iTimer = (UINT)SetTimer(1, 500);
		return 0;
	}

	//-------------------------------------------------------------------------
	// Every time the timer fires, check to see if the refresh is done. If
	// it is, close the dialog. Otherwise, update the progress bar and
	// refreshing category string.
	//-------------------------------------------------------------------------

	LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (m_pSource == NULL)
			return 0;

		if (!m_pSource->m_pThread->IsRefreshing())
		{
			KillTimer(m_iTimer);
			EndDialog(0);
			return 0;
		}

		CString strCurrent;
		LONG	nCount;

		m_pSource->m_pThread->GetRefreshStatus(&nCount, &strCurrent);
		if (nCount > 0) nCount -= 1; // this number is incremented before the refresh is complete
		UpdateProgress((nCount * 100) / m_nCategories, strCurrent);
		return 0;
	}

	//-------------------------------------------------------------------------
	// Update the percentage complete and the refreshing category name.
	//-------------------------------------------------------------------------

	void UpdateProgress(int iPercent, const CString & strCurrent = _T(""))
	{
	   HWND hwnd = GetDlgItem(IDC_REFRESHPROGRESS);
	   if (hwnd != NULL)
	   {
		   if (iPercent < 0)
			   iPercent = 0;
		   if (iPercent > 100)
			   iPercent = 100;

		   ::SendMessage(hwnd, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
		   ::SendMessage(hwnd, PBM_SETPOS, iPercent, 0);
	   }

	   if (!strCurrent.IsEmpty())
	   {
		   hwnd = GetDlgItem(IDC_REFRESHCAT);
		   if (hwnd != NULL)
			   ::SetWindowText(hwnd, strCurrent);
	   }
	}

private:
	CLiveDataSource *		m_pSource;
	CMSInfoLiveCategory *	m_pLiveCategory;
	int						m_nCategories;
	UINT					m_iTimer;

	BEGIN_MSG_MAP(CWaitForRefreshDialog)
		MESSAGE_HANDLER(WM_TIMER, OnTimer)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	END_MSG_MAP()
};

UINT HistoryRefreshDlgThreadProc( LPVOID pParam )
{
	CMSInfo* pInfo = (CMSInfo*) pParam;
	if (WAIT_OBJECT_0 != WaitForSingleObject(pInfo->m_hEvtHistoryComplete,60*60*10/*10 minutes*/))
	{
		ASSERT(0 && "Wait Abandoned or timed out");
	}
	pInfo->m_HistoryProgressDlg.EndDialog(MB_OK);//use if dlg was create with DoModal()
	return 0;
}

//=========================================================================
// A function to check if a file is a version 4.x (compound document) file
// (for bug 582973). It checks this by opening the file, opening the
// "MSInfo" stream and checking the version number.
//=========================================================================

BOOL IsVersion4File(const CString & strFilename)
{
	BOOL				fReturn = FALSE;
	DWORD				grfMode = STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE;
    CComBSTR			bstrFileName(strFilename);
    CComPtr<IStorage>	pStorage;

 	if (SUCCEEDED(StgOpenStorage(bstrFileName, NULL, grfMode, NULL, 0, &pStorage)))
	{
	    CComPtr<IStream>	pStream;
		CComBSTR			bstrMSIStream(_T("MSInfo"));

		if (SUCCEEDED(pStorage->OpenStream(bstrMSIStream, NULL, grfMode, 0, &pStream)))
		{
			const DWORD			MSI_FILE_VER = 0x03000000;
			COleStreamFile *	pOStream;
			DWORD				dwVersion;
			ULONG				ulCount;

			pOStream = new COleStreamFile(pStream);
		    if (pOStream->Read((void *) &dwVersion, sizeof(DWORD)) == sizeof(DWORD))
				fReturn = (dwVersion == MSI_FILE_VER);
		    delete pOStream;
		}
	}
	return fReturn;
}

//=========================================================================
// Dispatch a command from the user (such as a menu bar selection).
//=========================================================================
			
BOOL CMSInfo::DispatchCommand(int iCommand)
{
	BOOL fHandledCommand = TRUE;

	// Can't do any command while the find is in progress.

	if (m_fInFind)
	{
		CancelFind();
		SelectCategory(GetCurrentCategory());
	}

	// Before we execute a command, make sure that any refreshes currently
	// in progress are finished.

	CMSInfoCategory * pCategory = GetCurrentCategory();
	if (pCategory && pCategory->GetDataSourceType() == LIVE_DATA)
	{
		CLiveDataSource * pLiveDataSource = (CLiveDataSource *) m_pCurrData;
		HCURSOR hc = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
		pLiveDataSource->WaitForRefresh();
		::SetCursor(hc);
	}

	// Check to see if the selected command is a tool that we added to the
	// tools menu.

	CMSInfoTool * pTool;
	if (m_mapIDToTool.Lookup((WORD) iCommand, (void * &) pTool))
	{
		ASSERT(pTool);
		if (pTool)
			pTool->Execute();
		return TRUE;
	}

	switch (iCommand)
	{
	case ID_FILE_OPENNFO:
		if (m_fFindVisible)
			DispatchCommand(ID_EDIT_FIND);
		OpenNFO();
		break;

	case ID_FILE_SAVENFO:
		SaveNFO();
		break;
	
	case ID_FILE_CLOSE:
		if (m_fFindVisible)
			DispatchCommand(ID_EDIT_FIND);
		CloseFile();
		break;

	case ID_FILE_EXPORT:
		Export();
		break;

	case ID_FILE_PRINT:
		DoPrint();
		break;

	case ID_FILE_EXIT:
		if (NULL != m_hwndParent)
			::PostMessage(m_hwndParent, WM_CLOSE, 0, 0);
		break;

	case ID_EDIT_COPY:
		EditCopy();
		break;

	case ID_EDIT_PASTE:
		if (GetFocus() == m_wndFindWhat.m_hWnd && m_wndFindWhat.IsWindowVisible() && m_wndFindWhat.IsWindowEnabled())
		{
			BOOL fHandled = FALSE;
			if (::OpenClipboard(m_hWnd))
			{
				if (::IsClipboardFormatAvailable(CF_UNICODETEXT))
				{
					HANDLE h = ::GetClipboardData(CF_UNICODETEXT);
					if (h != NULL) 
					{ 
						LPWSTR szData = (LPWSTR)GlobalLock(h); 
						if (szData != NULL) 
						{
							// If the user tries to paste a tab character, replace it with spaces.

							CString strTemp(szData);
							if (strTemp.Find(_T('\t')) != -1)
								strTemp.Replace(_T('\t'), _T(' '));

							SETTEXTEX st;
							st.flags = ST_SELECTION;
							st.codepage = 1200; // Unicode
							m_wndFindWhat.SendMessage(EM_SETTEXTEX, (WPARAM)&st, (LPARAM)(LPCTSTR)strTemp);
							fHandled = TRUE;
							GlobalUnlock(h);
						}
					}
				}

				::CloseClipboard();
			}

			if (!fHandled)
				m_wndFindWhat.SendMessage(WM_PASTE);
		}
		break;

	case ID_EDIT_SELECTALL:
		EditSelectAll();
		break;

	case ID_EDIT_FIND:
		m_fFindVisible = !m_fFindVisible;

		m_fFindNext = FALSE;
		m_pcatFind = NULL;
		m_fCancelFind = FALSE;
		m_fInFind = FALSE;
		
		ShowFindControls();
		LayoutControl();
		SetMenuItems();
		UpdateFindControls();
		
		if (m_fFindVisible)
			GotoDlgCtrl(m_wndFindWhat.m_hWnd);
		
		break;

	case ID_VIEW_REFRESH:
		MSInfoRefresh();
		break;

	case ID_VIEW_BASIC:
		if (m_fAdvanced)
		{
			m_fAdvanced = FALSE;
			RefillListView(FALSE);
			SetMenuItems();
		}
		break;

	case ID_VIEW_ADVANCED:
		if (!m_fAdvanced)
		{
			m_fAdvanced = TRUE;
			RefillListView(FALSE);
			SetMenuItems();
		}
		break;

	case ID_VIEW_REMOTE_COMPUTER:
		ShowRemoteDialog();
		break;

	case ID_VIEW_CURRENT:
	case ID_VIEW_HISTORY:
		{
			int iShow = (iCommand == ID_VIEW_HISTORY) ? SW_SHOW : SW_HIDE;
			
			/* v-stlowe 2/27/2001:
			problem: if history was loaded from file after combo has been populated,
			combo doesn't get updated.  So update each time we switch to history view
			
			  if (iCommand == ID_VIEW_HISTORY && m_history.SendMessage(CB_GETCURSEL, 0, 0) == CB_ERR)
			*/
			if (iCommand == ID_VIEW_HISTORY)
				FillHistoryCombo();


			//v-stlowe 3/04/2001
			//if (!this->m_pHistoryStream)
			//{
			if (this->m_pDCO && !((CLiveDataSource *)m_pLiveData)->GetXMLDoc() && ID_VIEW_HISTORY == iCommand)
			{
				VERIFY(m_pDCO && "NULL datacollection object");
				if (m_pDCO)
				{
					HRESULT hr;
					HWND hWnd = m_HistoryProgressDlg.GetDlgItem(IDC_PROGRESS1);
					if(::IsWindow(hWnd))
					{
						::SendMessage(hWnd, PBM_SETRANGE, 0, MAKELPARAM(0, 100)); 
						::SendMessage(hWnd,PBM_SETPOS,0,0);
						::SendMessage(hWnd, PBM_DELTAPOS, 0, 0L);
					}
					m_pDCO->ExecuteAsync();
					
					//m_HistoryProgressDlg.Create(m_hWnd);
					ResetEvent(m_hEvtHistoryComplete);
					AfxBeginThread((AFX_THREADPROC) HistoryRefreshDlgThreadProc,this);
					m_HistoryProgressDlg.DoModal(m_hWnd);
					

				}   
			}
			else
			{

			}
			//end v-stlowe 12/17/00
			m_history.ShowWindow(iShow);
			m_historylabel.ShowWindow(iShow);
			LayoutControl();

			HTREEITEM htiToSelect = NULL;

			if (iCommand == ID_VIEW_HISTORY)
			{
				m_pLastCurrentCategory = GetCurrentCategory();

				int iIndex = (int)m_history.SendMessage(CB_GETCURSEL, 0, 0);
				if (iIndex == CB_ERR)
				{
					iIndex = 0;
					m_history.SendMessage(CB_SETCURSEL, (WPARAM)iIndex, 0);
				}
				ChangeHistoryView(iIndex);

				// Select the appropriate history category based on the current info category.

				CMSInfoHistoryCategory *	pHistoryCat = NULL;
				CString						strName;

				m_pLastCurrentCategory->GetNames(NULL, &strName);
				if (!strName.IsEmpty())
				{
					// This is a little kludgy:
					//todo: append file name if XML stream was opened from a file
					if (strName.Left(13) == CString(_T("SystemSummary")))
						pHistoryCat = &catHistorySystemSummary;
					else if (strName.Left(9) == CString(_T("Resources")))
						pHistoryCat = &catHistoryResources;
					else if (strName.Left(10) == CString(_T("Components")))
						pHistoryCat = &catHistoryComponents;
					else if (strName.Left(5) == CString(_T("SWEnv")))
						pHistoryCat = &catHistorySWEnv;
				}

				if (pHistoryCat)
					htiToSelect = pHistoryCat->GetHTREEITEM();
			}
			else
			{
				ChangeHistoryView(-1);

				// Changing to always select the system summary category when
				// switching back from history view.
				//
				//	if (m_pLastCurrentCategory)
				//		htiToSelect = m_pLastCurrentCategory->GetHTREEITEM();

				htiToSelect = TreeView_GetRoot(m_tree.m_hWnd);
			}

			if (htiToSelect != NULL)
			{
				TreeView_EnsureVisible(m_tree.m_hWnd, htiToSelect);
				TreeView_SelectItem(m_tree.m_hWnd, htiToSelect);
			}

			SetMenuItems();
		}
		break;

	case ID_TOOLS_PLACEHOLDER:
		break;

	case ID_HELP_ABOUT:
		{
			CSimpleDialog<IDD_ABOUTBOX> dlg;
			dlg.DoModal();
		}
		break;

	case ID_HELP_CONTENTS:
		//::HtmlHelp(m_hWnd, _T("msinfo32.chm"), HH_DISPLAY_TOPIC, 0);
		ShowHSCHelp(_T("msinfo_overview.htm"));
		break;

	case ID_HELP_TOPIC:
		ShowCategoryHelp(GetCurrentCategory());
		break;

	default:
		fHandledCommand = FALSE;
		break;
	}

	return fHandledCommand;
}

//=========================================================================
// Called to allow the user to remote to a different computer.
//=========================================================================

void CMSInfo::ShowRemoteDialog()
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	CRemoteDialog dlg;
	dlg.SetRemoteDialogValues(m_hWnd, !m_strMachine.IsEmpty(), m_strMachine);
	if (dlg.DoModal() == IDOK)
	{
		HCURSOR hc = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
		CString strMachine;
		BOOL	fRemote;

		dlg.GetRemoteDialogValues(&fRemote, &strMachine);
		if (!fRemote)
			strMachine.Empty();

		if (strMachine.CompareNoCase(m_strMachine) != 0)
			DoRemote(strMachine);

		::SetCursor(hc);
	}
}

void CMSInfo::DoRemote(LPCTSTR szMachine)
{
	CString strMachine(szMachine);

	// The user has changed the machine name. We need to recreate the
	// current data source object with the new machine name. Also, make
	// sure we aren't showing history data.

	if (m_history.IsWindowVisible())
		DispatchCommand(ID_VIEW_CURRENT);

	CLiveDataSource * pLiveData = new CLiveDataSource;
	if (pLiveData)
	{
		HRESULT hr = pLiveData->Create(strMachine, m_hWnd, m_strCategories);
		if (FAILED(hr))
		{
			// bad news, report an error
			delete pLiveData;
		}
		else
		{
			// Check to see if the pLiveData works. If it doesn't (for example,
			// if it's to a non-existent machine), don't change the data source.

			HRESULT hr = pLiveData->ValidDataSource();
			if (SUCCEEDED(hr))
			{
				pLiveData->m_pHistoryStream = ((CLiveDataSource *)m_pLiveData)->m_pHistoryStream;
				pLiveData->m_pXMLDoc = ((CLiveDataSource *)m_pLiveData)->m_pXMLDoc;

				if (m_pLiveData)
					delete m_pLiveData;
				m_pLiveData = pLiveData;
				m_strMachine = strMachine;
				SelectDataSource(m_pLiveData);
			}
			else
			{
				// Report the error for the bad connection.

				CString strMessage;

				if (strMachine.IsEmpty())
					strMessage.LoadString(IDS_REMOTEERRORLOCAL);
				else
					strMessage.Format(IDS_REMOTEERRORREMOTE, strMachine);

				MSInfoMessageBox(strMessage);
				delete pLiveData;
			}
		}
	}
	else
	{
		// bad news - no memory
	}
}

//=========================================================================
// Functions for managing the displayed data.
//=========================================================================

void CMSInfo::SelectDataSource(CDataSource * pDataSource)
{
	ASSERT(pDataSource);
	if (pDataSource == NULL || m_pCurrData == pDataSource)
		return;
	m_pCurrData = pDataSource;
	m_pCategory = NULL;

	// Clear the existing categories in the tree.

	TreeClearItems();

	// Load the contents of the tree from the data source.

	CMSInfoCategory * pRoot = m_pCurrData->GetRootCategory();
	if (pRoot)
	{
		BuildTree(TVI_ROOT, TVI_LAST, pRoot);
		TreeView_Expand(m_tree.m_hWnd, TreeView_GetRoot(m_tree.m_hWnd), TVE_EXPAND);
		TreeView_SelectItem(m_tree.m_hWnd, TreeView_GetRoot(m_tree.m_hWnd));
	}

	SetMenuItems();
}

//-------------------------------------------------------------------------
// Select the specified category.
//
// TBD - better to check columns for being the same
//-------------------------------------------------------------------------

void CMSInfo::SelectCategory(CMSInfoCategory * pCategory, BOOL fRefreshDataOnly)
{
	ASSERT(pCategory);
	if (pCategory == NULL) return;

	// If there's a currently selected category, save some information
	// for it (such as the widths of the columns that the user might
	// have changed).

	if (m_pCategory && !fRefreshDataOnly && m_pCategory->GetDataSourceType() != NFO_410)
	{
		int iWidth;

		ASSERT(m_iCategoryColNumberLen <= 64);
		for (int iListViewCol = 0; iListViewCol < m_iCategoryColNumberLen; iListViewCol++)
		{
			iWidth = ListView_GetColumnWidth(m_list.m_hWnd, iListViewCol);
			m_pCategory->SetColumnWidth(m_aiCategoryColNumber[iListViewCol], iWidth);
		}
	}

	ListClearItems();
	if (!fRefreshDataOnly && pCategory && pCategory->GetDataSourceType() != NFO_410)
	{
		ListClearColumns();
		m_iCategoryColNumberLen = 0;
		int iColCount;
		if (pCategory->GetCategoryDimensions(&iColCount, NULL))
		{
			CString		strCaption;
			UINT		uiWidth;
			int			iListViewCol = 0;

			for (int iCategoryCol = 0; iCategoryCol < iColCount; iCategoryCol++)
			{
				if (!m_fAdvanced && pCategory->IsColumnAdvanced(iCategoryCol))
					continue;

				if (pCategory->GetColumnInfo(iCategoryCol, &strCaption, &uiWidth, NULL, NULL))	// TBD - faster to return reference to string
				{
					// Save what the actual column number (for the category) was.

					ASSERT(iListViewCol < 64);
					m_aiCategoryColNumber[iListViewCol] = iCategoryCol;
					ListInsertColumn(iListViewCol++, (int)uiWidth, strCaption);
					m_iCategoryColNumberLen = iListViewCol;
				}
			}
		}
	}

	// If the currently displayed category is from a 4.10 NFO file, and we're showing a
	// new category, then hide the existing category.

	if (m_pCategory && m_pCategory != pCategory && m_pCategory->GetDataSourceType() == NFO_410)
		((CMSInfo4Category *) m_pCategory)->ShowControl(m_hWnd, this->GetOCXRect(), FALSE);

	// Save the currently displayed category.

	m_pCategory = pCategory;

	// If this is live data and has never been refreshed, refresh and return.
	// Refresh will send a message causing this function to be executed again.

	if (pCategory->GetDataSourceType() == LIVE_DATA)
	{
		CMSInfoLiveCategory * pLiveCategory = (CMSInfoLiveCategory *) pCategory;
		if (!pLiveCategory->EverBeenRefreshed())
		{
			SetMessage((m_history.IsWindowVisible()) ? IDS_REFRESHHISTORYMESSAGE : IDS_REFRESHMESSAGE, 0, TRUE);

			CLiveDataSource * pLiveDataSource = (CLiveDataSource *) m_pCurrData;
			if (pLiveDataSource->InRefresh())
			{
				HCURSOR hc = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
				pLiveCategory->Refresh((CLiveDataSource *) m_pCurrData, FALSE);
				::SetCursor(hc);
			}
			else
				pLiveCategory->Refresh((CLiveDataSource *) m_pCurrData, FALSE);
			return;
		}
	}
	else if (pCategory->GetDataSourceType() == NFO_410)
	{
		this->m_list.ShowWindow(SW_HIDE);

		CMSInfo4Category * p4Cat = (CMSInfo4Category *) pCategory;
		if (!p4Cat->IsDisplayableCategory())
			SetMessage(IDS_SELECTCATEGORY, 0, TRUE);
		else if (FAILED(p4Cat->ShowControl(m_hWnd,this->GetOCXRect())))
			SetMessage(IDS_NOOCX, IDS_NOOCXDETAIL, TRUE);
		
		return;
	}
	else if (pCategory->GetDataSourceType() == XML_SNAPSHOT)
	{
		((CXMLSnapshotCategory*)pCategory)->Refresh((CXMLDataSource*) m_pCurrData, FALSE);
		CMSInfoLiveCategory * pLiveCategory = (CMSInfoLiveCategory *) pCategory;
		// Any category that has children (besides the root category) doesn't display
		// information. So put up a message to that effect.

		if (pLiveCategory->GetFirstChild() != NULL && pLiveCategory->GetParent() != NULL)
		{
			SetMessage(IDS_SELECTCATEGORY, 0, TRUE);
			return;
		}
		else if (!pLiveCategory->EverBeenRefreshed())
		{
			SetMessage((m_history.IsWindowVisible()) ? IDS_REFRESHHISTORYMESSAGE : IDS_REFRESHMESSAGE, 0, TRUE);
			return;
		}

	}
	// Set the columns and fill the rows with the data for this category.
	// Note, if this is live data we need to lock it (so we don't have
	// a threading problem with the refresh).

	CLiveDataSource * pLiveDataSource = NULL;
	if (pCategory->GetDataSourceType() == LIVE_DATA)
		pLiveDataSource = (CLiveDataSource *) m_pCurrData;
	
	if (pLiveDataSource)
		pLiveDataSource->LockData();

	if (SUCCEEDED(pCategory->GetHRESULT()))
	{
		int iColCount, iRowCount;
		if (pCategory->GetCategoryDimensions(&iColCount, &iRowCount))
		{
			CString *	pstrData , strCaption , cstring;
			DWORD		dwData;
			int			iListViewCol, iListViewRow = 0;

			for (int iCategoryRow = 0; iCategoryRow < iRowCount; iCategoryRow++)
			{
				if (!m_fAdvanced && pCategory->IsRowAdvanced(iCategoryRow))
					continue;

				iListViewCol = 0;
				for (int iCategoryCol = 0; iCategoryCol < iColCount; iCategoryCol++)
				{
					if (!m_fAdvanced && pCategory->IsColumnAdvanced(iCategoryCol))
						continue;

					if (pCategory->GetData(iCategoryRow, iCategoryCol, &pstrData, &dwData))
					{
//a-kjaw
						if(pstrData->IsEmpty())						
						{
							pCategory->GetColumnInfo(iCategoryCol, &strCaption, NULL , NULL, NULL);							
							cstring.LoadString(IDS_SERVERNAME);
							if( strCaption == cstring )
								pstrData->LoadString(IDS_LOCALSERVER);

						}
//a-kjaw
						ListInsertItem(iListViewRow, iListViewCol++, *pstrData, iCategoryRow);
					}
				}

				iListViewRow += 1;
			}
		}

		// Return the sorting to how it was last set.

		if (pCategory->m_iSortColumn != -1)
			ListView_SortItems(m_list.m_hWnd, (PFNLVCOMPARE) ListSortFunc, (LPARAM) pCategory);

		if (iColCount == 0 || (iRowCount == 0 && pCategory->GetFirstChild() != NULL))
			SetMessage(IDS_SELECTCATEGORY, 0, TRUE);
		else
			SetMessage(0);
	}
	else
	{
		// The HRESULT for this category indicates some sort of failure. We should display
		// an error message instead of the list view.

		CString strTitle, strMessage;
		pCategory->GetErrorText(&strTitle, &strMessage);
		SetMessage(strTitle, strMessage, TRUE);
	}

	if (pLiveDataSource)
		pLiveDataSource->UnlockData();

	SetMenuItems();
}

//-------------------------------------------------------------------------
// Get the currently selected category.
//-------------------------------------------------------------------------

CMSInfoCategory * CMSInfo::GetCurrentCategory()
{
	HTREEITEM hti = TreeView_GetSelection(m_tree.m_hWnd);
	if (hti)
	{
		TVITEM tvi;
		tvi.mask = TVIF_PARAM;
		tvi.hItem = hti;

		if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
		{
			ASSERT(tvi.lParam);
			ASSERT(tvi.lParam == (LPARAM)m_pCategory);
			return (CMSInfoCategory *) tvi.lParam;
		}
	}

	return NULL;
}

//-------------------------------------------------------------------------
// Refresh the displayed data.
//-------------------------------------------------------------------------

void CMSInfo::MSInfoRefresh()
{
	CMSInfoCategory * pCategory = GetCurrentCategory();
	if (pCategory && pCategory->GetDataSourceType() == LIVE_DATA)
	{
		CMSInfoLiveCategory * pLiveCategory = (CMSInfoLiveCategory *)pCategory;
		ListClearItems();
		SetMessage(IDS_REFRESHMESSAGE);
		pLiveCategory->Refresh((CLiveDataSource *) m_pCurrData, FALSE);
	}
    else if (pCategory && pCategory->GetDataSourceType() == NFO_410)
    {
        CMSInfo4Category* p4Category = (CMSInfo4Category*) pCategory;
        p4Category->Refresh();
    }
}

//-------------------------------------------------------------------------
// Present the user with a dialog box to select a file to open.
//-------------------------------------------------------------------------

void CMSInfo::OpenNFO()
{
	// Display the dialog box and let the user select a file.

	TCHAR	szBuffer[MAX_PATH] = _T("");
	TCHAR	szFilter[MAX_PATH];
	TCHAR	szDefaultExtension[4];

	::LoadString(_Module.GetResourceInstance(), IDS_OPENFILTER, szFilter, MAX_PATH);
	::LoadString(_Module.GetResourceInstance(), IDS_DEFAULTEXTENSION, szDefaultExtension, 4);
	
	for (int i = 0; szFilter[i]; i++)
		if (szFilter[i] == _T('|'))
			szFilter[i] = _T('\0');

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize			= sizeof(OPENFILENAME);
	ofn.hwndOwner			= m_hWnd; 
	ofn.lpstrFilter			= szFilter;
	ofn.nFilterIndex		= 1;
	ofn.lpstrCustomFilter	= NULL;
	ofn.lpstrFile			= szBuffer;
	ofn.nMaxFile			= MAX_PATH; 
	ofn.lpstrFileTitle		= NULL; // maybe use later?
	ofn.nMaxFileTitle		= 0;
	ofn.lpstrInitialDir		= NULL; 
	ofn.lpstrTitle			= NULL; 
	ofn.Flags				= OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
	ofn.lpstrDefExt			= szDefaultExtension; 

	if (!::GetOpenFileName(&ofn))
		return;	// user cancelled

	OpenMSInfoFile(ofn.lpstrFile, ofn.nFileExtension);
}

//-------------------------------------------------------------------------
// SaveNFO allows the user to select a filename, and saves the current
// data to an NFO file.
//-------------------------------------------------------------------------

void CMSInfo::SaveNFO()
{
	// Present the user with a dialog box to select a name for saving.

	TCHAR	szBuffer[MAX_PATH] = _T("");
	TCHAR	szFilter[MAX_PATH];
	TCHAR	szDefaultExtension[4];

	//v-stlowe 3/19/2001 if (m_fHistoryAvailable && m_strMachine.IsEmpty())
	if (m_fHistorySaveAvailable && m_strMachine.IsEmpty())
		::LoadString(_Module.GetResourceInstance(), IDS_SAVEBOTHFILTER, szFilter, MAX_PATH);
	else
		::LoadString(_Module.GetResourceInstance(), IDS_SAVENFOFILTER, szFilter, MAX_PATH);

	::LoadString(_Module.GetResourceInstance(), IDS_DEFAULTEXTENSION, szDefaultExtension, 4);

	for (int i = 0; szFilter[i]; i++)
		if (szFilter[i] == _T('|'))
			szFilter[i] = _T('\0');

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize			= sizeof(OPENFILENAME);
	ofn.hwndOwner			= m_hWnd; 
	ofn.lpstrFilter			= szFilter;
	ofn.nFilterIndex		= 0;
	ofn.lpstrCustomFilter	= NULL;
	ofn.lpstrFile			= szBuffer;
	ofn.nMaxFile			= MAX_PATH; 
	ofn.lpstrFileTitle		= NULL; // maybe use later?
	ofn.nMaxFileTitle		= 0;
	ofn.lpstrInitialDir		= NULL; 
	ofn.lpstrTitle			= NULL; 
	ofn.Flags				= OFN_OVERWRITEPROMPT;
	ofn.lpstrDefExt			= szDefaultExtension; 

	if (!::GetSaveFileName(&ofn))
		return; // user cancelled

	HCURSOR hc = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

	CString strFileName(ofn.lpstrFile);
	
	if (strFileName.Right(4).CompareNoCase(_T(".xml")) == 0)
		SaveXML(strFileName);
	else
		SaveMSInfoFile(strFileName, ofn.nFilterIndex);

	::SetCursor(hc);
}

//-------------------------------------------------------------------------
// Actually saves the current information to an NFO file.
//-------------------------------------------------------------------------

void CMSInfo::SaveMSInfoFile(LPCTSTR szFilename, DWORD dwFilterIndex)
{
	ASSERT(m_pCurrData);

	if (m_history.IsWindowVisible())
		DispatchCommand(ID_VIEW_CURRENT);

	if (m_pCurrData)
	{
		CMSInfoCategory * pCategory = m_pCurrData->GetRootCategory();
		if (pCategory)
		{
			HANDLE hFile = ::CreateFile(szFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				if (pCategory->GetDataSourceType() == LIVE_DATA)
				{
					CMSInfoLiveCategory * pLiveCategory = (CMSInfoLiveCategory *) pCategory;

					if (m_fNoUI)
						pLiveCategory->RefreshSynchronous((CLiveDataSource *) m_pCurrData, TRUE);
					else
						RefreshData((CLiveDataSource *)m_pCurrData, pLiveCategory);
				}
				else if (pCategory->GetDataSourceType() == XML_SNAPSHOT)
					((CXMLSnapshotCategory *)pCategory)->Refresh((CXMLDataSource *)m_pCurrData, TRUE);

				//PENDING dependence on filter order. Always add new filters to the end.
                if (dwFilterIndex == 1)//NFO_700 
                    pCategory->SaveXML(hFile);
                else
                    pCategory->SaveNFO(hFile, pCategory, TRUE);
				::CloseHandle(hFile);
			}
			else
			{
				DWORD dwError = ::GetLastError();

				LPVOID lpMsgBuf;
				::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
								FORMAT_MESSAGE_FROM_SYSTEM | 
								FORMAT_MESSAGE_IGNORE_INSERTS,
								NULL,
								dwError,
								MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
								(LPTSTR) &lpMsgBuf,
								0,
								NULL);

				// TBD Process any inserts in lpMsgBuf.

				CString strCaption;
				::AfxSetResourceHandle(_Module.GetResourceInstance());
				strCaption.LoadString(IDS_SYSTEMINFO);
				::MessageBox(m_hWnd, (LPCTSTR) lpMsgBuf, strCaption, MB_ICONEXCLAMATION | MB_OK);
				::LocalFree(lpMsgBuf);
			}
		}
	}
}

//-------------------------------------------------------------------------
// Save an XML file containing the history information.
//-------------------------------------------------------------------------

void CMSInfo::SaveXML(const CString & strFileName)
{
	if (m_pHistoryStream == NULL)
	{
		MSInfoMessageBox(IDS_XMLSAVEERR);
		return;
	}

	// get the stream status, so we can determine the size of the stream

	STATSTG streamStat;
	HRESULT hr = m_pHistoryStream->Stat(&streamStat,STATFLAG_NONAME );
	if (FAILED(hr))
	{
		ASSERT(0 && "couldn't get stream statistics");
		MSInfoMessageBox(IDS_XMLSAVEERR);
		return;
	}
	
	// allocate buffer of appropriate size

	BYTE* pBuffer = new BYTE[streamStat.cbSize.LowPart];
	ULONG ulRead;

	// seek to beginning of stream

	ULARGE_INTEGER uliSeekPtr;
	LARGE_INTEGER liSeekLoc;
	liSeekLoc.QuadPart = 0;
	hr = m_pHistoryStream->Seek(liSeekLoc,0,&uliSeekPtr);
	if (FAILED(hr))
	{
		MSInfoMessageBox(IDS_XMLSAVEERR);
		if (pBuffer)
			delete [] pBuffer;
		return;
	}
	hr = m_pHistoryStream->Read(pBuffer,streamStat.cbSize.LowPart,&ulRead);
	if (FAILED(hr) || !pBuffer)
	{
		MSInfoMessageBox(IDS_XMLSAVEERR);
		if (pBuffer)
			delete [] pBuffer;
		return;
	}
	if(ulRead != streamStat.cbSize.LowPart)
	{
		ASSERT(0 && "Not enough bytes read from stream");
		MSInfoMessageBox(IDS_XMLSAVEERR);
		if (pBuffer)
			delete [] pBuffer;
		return;
	}
	
	CFile file;
	try
	{
		
		file.Open(strFileName, CFile::modeCreate | CFile::modeWrite);
		file.Write(pBuffer,ulRead);
		
	}
	catch (CFileException * pException)
	{
		pException->ReportError();
		pException->Delete();
	}
	catch (...)
	{
		::AfxSetResourceHandle(_Module.GetResourceInstance());
		CString strCaption, strMessage;
		strCaption.LoadString(IDS_SYSTEMINFO);
		strMessage.LoadString(IDS_XMLSAVEERR);
		::MessageBox(NULL,strMessage, strCaption,MB_OK);
	}
	delete [] pBuffer;
}

//-------------------------------------------------------------------------
// Export allows the user to select a filename, and saves the current
// data to a text or XML file.
//-------------------------------------------------------------------------

void CMSInfo::Export()
{
	// Present the user with a dialog box to select a name for saving.

	TCHAR	szBuffer[MAX_PATH] = _T("");
	TCHAR	szFilter[MAX_PATH];
	TCHAR	szTitle[MAX_PATH] = _T("");
	TCHAR	szDefaultExtension[4];

	::LoadString(_Module.GetResourceInstance(), IDS_EXPORTFILTER, szFilter, MAX_PATH);	// TBD - add XML
	::LoadString(_Module.GetResourceInstance(), IDS_DEFAULTEXPORTEXTENSION, szDefaultExtension, 4);
	::LoadString(_Module.GetResourceInstance(), IDS_EXPORTDIALOGTITLE, szTitle, MAX_PATH);

	for (int i = 0; szFilter[i]; i++)
		if (szFilter[i] == _T('|'))
			szFilter[i] = _T('\0');

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize			= sizeof(OPENFILENAME);
	ofn.hwndOwner			= m_hWnd; 
	ofn.lpstrFilter			= szFilter;
	ofn.nFilterIndex		= 0;
	ofn.lpstrCustomFilter	= NULL;
	ofn.lpstrFile			= szBuffer;
	ofn.nMaxFile			= MAX_PATH; 
	ofn.lpstrFileTitle		= NULL; // maybe use later?
	ofn.nMaxFileTitle		= 0;
	ofn.lpstrInitialDir		= NULL; 
	ofn.lpstrTitle			= (szTitle[0] == _T('\0')) ? NULL : szTitle; 
	ofn.Flags				= OFN_OVERWRITEPROMPT;
	ofn.lpstrDefExt			= szDefaultExtension; 

	if (!::GetSaveFileName(&ofn))
		return; // user cancelled

	HCURSOR hc = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
	ExportFile(ofn.lpstrFile, ofn.nFileExtension);
	::SetCursor(hc);
}

//-------------------------------------------------------------------------
// Open the specified file (it might be XML, NFO, CAB, etc.). If the open
// succeeds, we should show the contents of the file.
//-------------------------------------------------------------------------

HRESULT CMSInfo::OpenMSInfoFile(LPCTSTR szFilename, int nFileExtension)
{
	if (m_pFileData != NULL && m_strFileName.Right(4).CompareNoCase(_T(".xml")) == 0)
		CloseFile();

	HRESULT hr = S_OK;
	CDataSource * pOldOpenFile = m_pFileData;

	::AfxSetResourceHandle(_Module.GetResourceInstance());
	/* v-stlowe 3/04/2001...we don't want to automatically switch from history 
	   in the event we're opening XML.
	if (m_history.IsWindowVisible())
		DispatchCommand(ID_VIEW_CURRENT);*/

	// Open the file.

	LPCTSTR szExtension = szFilename + nFileExtension;

	if (_tcsicmp(szExtension, _T("NFO")) == 0)
	{
		// If this is a version 4 NFO, check to see if that's enabled. Bug 582973.

		if (IsVersion4File(szFilename))
		{
			HKEY	hkey;
			BOOL	fDisabled = TRUE;

			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools\\MSInfo"), 0, KEY_READ, &hkey))
			{
				DWORD dwType = REG_DWORD, dwValue, dwSize = sizeof(DWORD);
				if (ERROR_SUCCESS == RegQueryValueEx(hkey, _T("AllowVersion4NFO"), NULL, &dwType, (LPBYTE)&dwValue, &dwSize))
					fDisabled = (dwValue == 0);
				RegCloseKey(hkey);
			}

			if (fDisabled)
			{
				MSInfoMessageBox(IDS_VER4NFODISABLED);
				return E_FAIL;
			}
		}

		// First, try opening it as a 4.x file.

        CNFO4DataSource* pMSI4Source = new CNFO4DataSource();
        hr = pMSI4Source->Create(szFilename);
        if (SUCCEEDED(hr))
        {
            m_pFileData = pMSI4Source;
        }
		else
		{
			delete pMSI4Source;

			if (STG_E_ACCESSDENIED == hr || STG_E_SHAREVIOLATION == hr || STG_E_LOCKVIOLATION == hr)
			{
				MSInfoMessageBox(IDS_OLDNFOSHARINGVIOLATION);
				return E_FAIL;

			}
		}

		// If that failed, then try opening it as a 5.0/6.0 file.
        
		if (FAILED(hr))
		{ 
           	HANDLE h = ::CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
            if (INVALID_HANDLE_VALUE == h)
	        {
		        MSInfoMessageBox(IDS_BADNFOFILE);
		        return E_FAIL;
	        }
       	    CNFO6DataSource * p60Source = new CNFO6DataSource;
		    if (p60Source)
		    {
			    hr = p60Source->Create(h, szFilename);
			    if (FAILED(hr))
				{
				    delete p60Source;
			        //MSInfoMessageBox(IDS_BADNFOFILE);
				}
			    else
				    m_pFileData = p60Source;
		    }
		    else
			    hr = E_FAIL; // TBD no memory    
            ::CloseHandle(h);
		}

        //Try 7.0
        if (FAILED(hr))
        {
            CNFO7DataSource * p70Source = new CNFO7DataSource;
            if (!p70Source)
                hr = E_FAIL;
            else
            {
                hr = p70Source->Create(szFilename);//blocks while parsing
                if (FAILED(hr))
                {
                    delete p70Source;
                    MSInfoMessageBox(IDS_BADNFOFILE);
                }
                else
                    m_pFileData = p70Source;    
            }
        }

	}
	else if (_tcsicmp(szExtension, _T("CAB")) == 0)
	{
		CString strDest;

		GetCABExplodeDir(strDest, TRUE, _T(""));
		if (!strDest.IsEmpty())
		{
			if (OpenCABFile(szFilename, strDest))
			{
				LoadGlobalToolsetWithOpenCAB(m_mapIDToTool, strDest);
				UpdateToolsMenu();
				CString strFileInCAB;
				//first, look for xml files (the incident file specified in the registry, and (possibly) dataspec.xml

				//Get default incident file name from registry (create it if it's not there)
				CString strIncidentFileName;
				HKEY hkey;
				if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools\\MSInfo"), 0, KEY_ALL_ACCESS, &hkey))
				{
					TCHAR szBuffer[MAX_PATH];
					DWORD dwType, dwSize = MAX_PATH * sizeof(TCHAR);
					long lErr =  RegQueryValueEx(hkey, _T("incidentfilename"), NULL, &dwType, (LPBYTE)szBuffer, &dwSize);
					if (ERROR_SUCCESS == lErr)
					{
						if (dwType == REG_SZ)
						{

							strIncidentFileName = szBuffer;
						}
						else
						{
							ASSERT(0 && "invalid incidentfilename reg key");
							return E_FAIL;
						}
					}
					//check lErr to make sure it's appropriate error for value not existing
					else if (2 == lErr)
					{
						//create registry key.
						CString strDefaultValue = _T("Incident.xml");
						lErr =  RegSetValueEx(hkey,_T("incidentfilename"),NULL,REG_SZ,(BYTE*) strDefaultValue.GetBuffer(strDefaultValue.GetLength()),strDefaultValue.GetLength() * sizeof(TCHAR));
						strIncidentFileName = strDefaultValue;
					}
					
				}			
				if (IsIncidentXMLFilePresent(strDest,strIncidentFileName))
				{
					strFileInCAB = strDest + "\\";
					strFileInCAB += strIncidentFileName;
					OpenMSInfoFile(strFileInCAB,strFileInCAB.Find(_T(".xml")) +1);
					return S_OK;
				}
				//if there are no xml incident files 
				
				FindFileToOpen(strDest, strFileInCAB);

				if (!strFileInCAB.IsEmpty())
				{
					int iExtension = strFileInCAB.GetLength() - 1;
					while (iExtension && strFileInCAB[iExtension] != _T('.'))
						iExtension--;
					if (iExtension)
						return OpenMSInfoFile(strFileInCAB, iExtension + 1 /* skip the dot */);
					else
					{
						ASSERT(0 && "couldn't find dot in file name");
					}
				}
			}
		}
		else
		{
			// TBD - do something about the error.
			ASSERT(0 && "could get not CAB destination directory");
		}
		MSInfoMessageBox(IDS_BADCABFILE);
		return E_FAIL;
	}
	else if (_tcsicmp(szExtension, _T("XML")) == 0)
	{
		/* v-stlowe 3/04/2001
		CXMLDataSource* pSSDataSource = new CXMLDataSource();
		
		hr = pSSDataSource->Create(szFilename,(CMSInfoLiveCategory *) this->m_pLiveData->GetRootCategory(),m_hWnd);
		CXMLSnapshotCategory* pRootXML = (CXMLSnapshotCategory*) pSSDataSource->GetRootCategory();
		pRootXML->AppendFilenameToCaption(szFilename);
		if (SUCCEEDED(hr))
		{
			m_pFileData = pSSDataSource;
		}
		else
		{
			delete pSSDataSource;
		}*/
		try
		{
			hr = ((CLiveDataSource *)m_pLiveData)->LoadXMLDoc(szFilename);
			m_pFileData = m_pLiveData;
			this->m_strFileName = szFilename;
			//trigger refresh
			CMSInfoCategory * pCategory = GetCurrentCategory();
			if (pCategory)
				ChangeHistoryView(((CMSInfoHistoryCategory*) pCategory)->m_iDeltaIndex);
			if (FAILED(hr))//v-stlowe 3/9/2001 || !varBSuccess)
			{
				ASSERT(0 && "unable to load xml document");
				return E_FAIL;
			}
		}
		catch(...)
		{
			return E_FAIL;
		}

		DispatchCommand(ID_VIEW_HISTORY);

	}
	else
	{
		// Report that we can't open this kind of file.

		MSInfoMessageBox(IDS_UNKNOWNFILETYPE);
		hr = E_FAIL;
	}

	// It succeeded, so we should show the new data and update the menu
	// for the new state.
	
	if (SUCCEEDED(hr))
	{
		if (pOldOpenFile && pOldOpenFile != m_pFileData)
			delete pOldOpenFile;

		SelectDataSource(m_pFileData);
	}
	else
		; // report the error

	return hr;
}

//-------------------------------------------------------------------------
// Export to the specified file. This will be either a TXT or an XML file.
//-------------------------------------------------------------------------

void CMSInfo::ExportFile(LPCTSTR szFilename, int nFileExtension)
{
	ASSERT(m_pCurrData);

	if (m_pCurrData)
	{
		// If there is a selected category, export that node only (bug 185305).

		CMSInfoCategory * pCategory = (m_pCategory) ? m_pCategory : m_pCurrData->GetRootCategory();
		if (pCategory)
		{
			if (pCategory->GetDataSourceType() == LIVE_DATA)
			{
				if (m_history.IsWindowVisible() == TRUE)
				{
					((CMSInfoHistoryCategory*)pCategory)->Refresh((CLiveDataSource*)m_pCurrData,TRUE);
				}
				else
				{
					CMSInfoLiveCategory * pLiveCategory = (CMSInfoLiveCategory *) pCategory;

					if (m_fNoUI)
						pLiveCategory->RefreshSynchronous((CLiveDataSource *) m_pCurrData, TRUE);
					else
						RefreshData((CLiveDataSource *)m_pCurrData, pLiveCategory);
				}
			}
			else if (pCategory->GetDataSourceType() == NFO_410)
			{
				 ((CMSInfo4Category *) pCategory)->RefreshAllForPrint(m_hWnd,this->GetOCXRect());
			}
			else if (pCategory->GetDataSourceType() == XML_SNAPSHOT)
			{
				 ((CXMLSnapshotCategory *) pCategory)->Refresh((CXMLDataSource *)m_pCurrData,TRUE);
			}

			/*HANDLE hFile = ::CreateFile(szFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				pCategory->SaveAsText(hFile, TRUE);
				::CloseHandle(hFile);
			}
			else
			{
				// TBD - handle the error
			}*/
			//a-stephl: Fixing OSR4.1 bug #133823, not displaying message when saving to write-protected diskette
			try
			{
				HANDLE hFile = ::CreateFile(szFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
					LPTSTR lpMachineName = new TCHAR[dwSize];
					GetMachineName(lpMachineName, &dwSize);

/*a-kjaw To implement save as XML
					if( _tcsicmp(szFilename + nFileExtension , _T("XML")) == 0)
					{
						pCategory->SaveAsXml(hFile, TRUE);
					}
//a-kjaw */
		//			else
		//			{
						pCategory->SaveAsText(hFile, TRUE, lpMachineName);
		//			}
					
					delete [] lpMachineName;
					::CloseHandle(hFile);
				}
				else
				{
					DWORD dwError = ::GetLastError();

					LPVOID lpMsgBuf;
					::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
									FORMAT_MESSAGE_FROM_SYSTEM | 
									FORMAT_MESSAGE_IGNORE_INSERTS,
									NULL,
									dwError,
									MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
									(LPTSTR) &lpMsgBuf,
									0,
									NULL);

					// TBD Process any inserts in lpMsgBuf.

					CString strCaption;
					::AfxSetResourceHandle(_Module.GetResourceInstance());
					strCaption.LoadString(IDS_SYSTEMINFO);
					::MessageBox(m_hWnd, (LPCTSTR) lpMsgBuf, strCaption, MB_ICONEXCLAMATION | MB_OK);
					::LocalFree(lpMsgBuf);
				}
			}
			catch (CFileException * pException)
			{	
				pException->ReportError();
				pException->Delete();
			}
			catch (CException * pException)
			{	
				pException->ReportError();
				pException->Delete();
			}
			catch (...)
			{
				DWORD dwError = ::GetLastError();

				LPVOID lpMsgBuf;
				::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
								FORMAT_MESSAGE_FROM_SYSTEM | 
								FORMAT_MESSAGE_IGNORE_INSERTS,
								NULL,
								dwError,
								MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
								(LPTSTR) &lpMsgBuf,
								0,
								NULL);

				// TBD Process any inserts in lpMsgBuf.

				CString strCaption;
				::AfxSetResourceHandle(_Module.GetResourceInstance());
				strCaption.LoadString(IDS_SYSTEMINFO);
				::MessageBox(m_hWnd, (LPCTSTR) lpMsgBuf, strCaption, MB_ICONEXCLAMATION | MB_OK);
				::LocalFree(lpMsgBuf);
			}
		}
		//end a-stephl: Fixing OSR4.1 bug #133823, not displaying message when saving to write-protected diskette
	}
}

//-------------------------------------------------------------------------
// Close the currently open file (if there is one). Displays the current
// system information.
//-------------------------------------------------------------------------

void CMSInfo::CloseFile()
{
	ASSERT(m_pFileData);
//v-stlowe 3/12/2001
	
	SelectDataSource(m_pLiveData);
	if (m_strFileName.Right(4).CompareNoCase(_T(".xml")) == 0)
	{
		((CLiveDataSource *)m_pLiveData)->RevertToLiveXML();
	}
	if (m_pFileData)
	{
		//v-stlowe: so we can use livedata as filedata when opening history xml
		if (m_pFileData != this->m_pLiveData)
		{
			delete m_pFileData;
		}
		m_pFileData = NULL;
	}
	if (!m_history.IsWindowVisible())
	{
		DispatchCommand(ID_VIEW_CURRENT);
	}
	else
	{
		DispatchCommand(ID_VIEW_HISTORY);
	}
	SetMenuItems();
}

//-------------------------------------------------------------------------
// Enable or disable menu items based on the current state.
//-------------------------------------------------------------------------

void CMSInfo::SetMenuItems()
{
	if (NULL == m_hmenu || NULL == m_hwndParent)
		return;

	// This struct will be used a bunch in this function to set menu item states.

	MENUITEMINFO mii;
	mii.cbSize = sizeof(MENUITEMINFO);

	// The type of data being displayed will also be used frequently.

	DataSourceType datatype = LIVE_DATA;
	if (m_pCurrData)
	{
		CMSInfoCategory * pCategory = m_pCurrData->GetRootCategory();
		if (pCategory)
			datatype = pCategory->GetDataSourceType();
	}

	// Enable or disable items in the File menu.

	HMENU hmenuFile = ::GetSubMenu(m_hmenu, 0);
	if (hmenuFile)
	{
		mii.fMask = MIIM_STATE;
		mii.fState = (m_pFileData == m_pCurrData) ? MFS_ENABLED : MFS_GRAYED;
		::SetMenuItemInfo(hmenuFile, ID_FILE_CLOSE, FALSE, &mii);

		mii.fState = MFS_ENABLED; // Was: (m_pFileData != m_pCurrData) ? MFS_ENABLED : MFS_GRAYED;
		::SetMenuItemInfo(hmenuFile, ID_FILE_OPENNFO, FALSE, &mii);

		mii.fState = (datatype == LIVE_DATA || datatype == XML_SNAPSHOT) ? MFS_ENABLED : MFS_GRAYED;
		::SetMenuItemInfo(hmenuFile, ID_FILE_SAVENFO, FALSE, &mii);

		//mii.fState = MFS_ENABLED;
		mii.fState = (datatype != NFO_410) ? MFS_ENABLED : MFS_GRAYED;;
		::SetMenuItemInfo(hmenuFile, ID_FILE_EXPORT, FALSE, &mii);

		mii.fState = MFS_ENABLED;
		::SetMenuItemInfo(hmenuFile, ID_FILE_PRINT, FALSE, &mii);

		if (NULL == m_hwndParent)
		{
			// Remove the last two items (the exit command and the divider).

			int nItems = ::GetMenuItemCount(hmenuFile);
			if (ID_FILE_EXIT == ::GetMenuItemID(hmenuFile, nItems - 1))
			{
				::RemoveMenu(hmenuFile, nItems - 1, MF_BYPOSITION);
				::RemoveMenu(hmenuFile, nItems - 2, MF_BYPOSITION);
			}
		}
	}

	// Enable or disable items in the Edit menu.

	HMENU hmenuEdit = ::GetSubMenu(m_hmenu, 1);
	if (hmenuEdit)
	{
		mii.fMask = MIIM_STATE;

		if (datatype == NFO_410 || ListView_GetNextItem(m_list.m_hWnd, -1, LVNI_SELECTED) != -1)
			mii.fState = MFS_ENABLED;
		else
			mii.fState = MFS_GRAYED;

		// Disable copy if the list view is not visible.

		if (!m_list.IsWindowVisible())
			mii.fState = MFS_GRAYED;

		// If the find control has focus, enable copy based on that control.
		
		if (GetFocus() == m_wndFindWhat.m_hWnd && m_wndFindWhat.IsWindowVisible() && m_wndFindWhat.IsWindowEnabled())
			mii.fState = MFS_ENABLED;

		::SetMenuItemInfo(hmenuEdit, ID_EDIT_COPY, FALSE, &mii);

		mii.fState = (m_list.IsWindowVisible()) ? MFS_ENABLED : MFS_GRAYED;
		::SetMenuItemInfo(hmenuEdit, ID_EDIT_SELECTALL, FALSE, &mii);

		mii.fState = (datatype != NFO_410) ? MFS_ENABLED : MFS_GRAYED;
		mii.fState |= ((!m_fFindVisible) ? MFS_CHECKED : MFS_UNCHECKED);
		::SetMenuItemInfo(hmenuEdit, ID_EDIT_FIND, FALSE, &mii);
	}

	// Enable or disable items in the View menu.

	HMENU hmenuView = ::GetSubMenu(m_hmenu, 2);
	if (hmenuView)
	{
		mii.fMask = MIIM_STATE;
		mii.fState = (datatype == LIVE_DATA && !m_history.IsWindowVisible()) ? MFS_ENABLED : MFS_GRAYED;
		::SetMenuItemInfo(hmenuView, ID_VIEW_REFRESH, FALSE, &mii);

		mii.fState = MFS_ENABLED | ((!m_fAdvanced) ? MFS_CHECKED : MFS_UNCHECKED);
		::SetMenuItemInfo(hmenuView, ID_VIEW_BASIC, FALSE, &mii);

		mii.fState = MFS_ENABLED | ((m_fAdvanced) ? MFS_CHECKED : MFS_UNCHECKED);
		::SetMenuItemInfo(hmenuView, ID_VIEW_ADVANCED, FALSE, &mii);

		// Set the menu item for the current system view or snapshot, depending on whether
		// or not there is an XML file open.

		BOOL fEnableHistoryLive = FALSE;
		if (datatype == LIVE_DATA && m_fHistoryAvailable && m_strMachine.IsEmpty())
			fEnableHistoryLive = TRUE;

		BOOL fEnableHistoryXML = FALSE;
		if (m_pFileData)
		{
			CMSInfoCategory * pCategory = m_pFileData->GetRootCategory();
			if (pCategory && (pCategory->GetDataSourceType() == XML_SNAPSHOT || pCategory == &catHistorySystemSummary))
				fEnableHistoryXML = TRUE;
		}

		BOOL fShowingHistory = FALSE;
		if (m_pCurrData)
		{
			CMSInfoCategory * pCategory = m_pCurrData->GetRootCategory();
			if (pCategory == &catHistorySystemSummary)
				fShowingHistory = TRUE;
		}

		// Whether or not you can remote depends on if you are showing live data.

		mii.fState = (datatype == LIVE_DATA && !fEnableHistoryXML) ? MFS_ENABLED : MFS_GRAYED;
		::SetMenuItemInfo(hmenuView, ID_VIEW_REMOTE_COMPUTER, FALSE, &mii);

		// Enabling the menu items to switch between current (or snapshot) and history
		// are based on whether history is available.

		mii.fState = (fEnableHistoryLive || fEnableHistoryXML) ? MFS_ENABLED : MFS_GRAYED;
		mii.fState |= (!m_history.IsWindowVisible()) ? MFS_CHECKED : MFS_UNCHECKED;
		::SetMenuItemInfo(hmenuView, ID_VIEW_CURRENT, FALSE, &mii);
	
		mii.fState = (fEnableHistoryLive || fEnableHistoryXML) ? MFS_ENABLED : MFS_GRAYED;
		mii.fState |= (m_history.IsWindowVisible()) ? MFS_CHECKED : MFS_UNCHECKED;
		::SetMenuItemInfo(hmenuView, ID_VIEW_HISTORY, FALSE, &mii);

		// Set the menu item text (for system snapshot/current system information) based on
		// whether or not we have an XML file open.

		UINT uiMenuCaption = IDS_VIEWCURRENTSYSTEMINFO;
		if (m_pFileData)
		{
			CMSInfoCategory * pCategory = m_pCurrData->GetRootCategory();
			// v-stlowe 6/26/2001...pCategory && (pCategory->GetDataSourceType() == XML_SNAPSHOT no longer possible... if (pCategory && (pCategory->GetDataSourceType() == XML_SNAPSHOT || pCategory == &catHistorySystemSummary))
			if (pCategory && (pCategory == &catHistorySystemSummary))
			{
				//v-stlowe 6/26/2001: we need to remove "snapshot" uiMenuCaption = IDS_VIEWSYSTEMSNAPSHOT;
				 uiMenuCaption = IDS_VIEWCURRENTSYSTEMINFO;
			}
		}

		CString strMenuItem;
		strMenuItem.LoadString(uiMenuCaption);

		MENUITEMINFO miiName;
		miiName.cbSize		= sizeof(MENUITEMINFO);
		miiName.fMask		= MIIM_TYPE;
		miiName.fType		= MFT_STRING;
		miiName.dwTypeData	= (LPTSTR)(LPCTSTR)strMenuItem; 
		::SetMenuItemInfo(hmenuView, ID_VIEW_CURRENT, FALSE, &miiName);
	}

	// Enable or disable items in the Help menu.

	HMENU hmenuHelp = ::GetSubMenu(m_hmenu, 4);
	if (hmenuHelp)
	{
		mii.fMask = MIIM_STATE;
		mii.fState = MFS_ENABLED;
		::SetMenuItemInfo(hmenuHelp, ID_HELP_ABOUT, FALSE, &mii);
	}
}

//-------------------------------------------------------------------------
// Set a message in the right hand pane (hiding the list view).
//-------------------------------------------------------------------------

void CMSInfo::SetMessage(const CString & strTitle, const CString & strMessage, BOOL fRedraw)
{
	m_strMessTitle = strTitle;
	m_strMessText = strMessage;

	if (strTitle.IsEmpty() && strMessage.IsEmpty())
	{
		m_list.ShowWindow(SW_SHOW);
		return;
	}

	m_list.ShowWindow(SW_HIDE);

	if (fRedraw)
	{
		RECT rectList;
		m_list.GetWindowRect(&rectList);
		ScreenToClient(&rectList);
		InvalidateRect(&rectList, TRUE);
		UpdateWindow();
	}
}

void CMSInfo::SetMessage(UINT uiTitle, UINT uiMessage, BOOL fRedraw)
{
	CString strTitle(_T(""));
	CString strMessage(_T(""));

	::AfxSetResourceHandle(_Module.GetResourceInstance());

	if (uiTitle)
		strTitle.LoadString(uiTitle);

	if (uiMessage)
		strMessage.LoadString(uiMessage);

	SetMessage(strTitle, strMessage, fRedraw);
}

//---------------------------------------------------------------------------
// This function is used to sort the list by a specified column.
//---------------------------------------------------------------------------

int CALLBACK ListSortFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	int iReturn = 0;
	CMSInfoCategory * pCategory = (CMSInfoCategory *) lParamSort;

	if (pCategory)
	{
		CString *	pstrFirst;
		CString *	pstrSecond;
		DWORD		dwFirst = 0, dwSecond = 0;

		pCategory->GetData((int)lParam1, pCategory->m_iSortColumn, &pstrFirst, &dwFirst);
		pCategory->GetData((int)lParam2, pCategory->m_iSortColumn, &pstrSecond, &dwSecond);

//a-kjaw . To fix bug "Sort order style for an nfo file differs from that of live data."
		if(pCategory->GetDataSourceType() == NFO_500/*|| pCategory->GetDataSourceType() == NFO_410 */) //BugBug
		if(pstrFirst->Left(3) == _T("IRQ"))//Very weird fix. Need Loc?
		{
			LPTSTR strIrq = pstrFirst->GetBuffer(pstrFirst->GetLength() + 1);
			dwFirst = _ttoi(strIrq + 4 );
			pstrFirst->ReleaseBuffer();

			strIrq = pstrSecond->GetBuffer(pstrSecond->GetLength() + 1);
			dwSecond = _ttoi(strIrq + 4 );
			pstrSecond->ReleaseBuffer();			

		}
//a-kjaw

		if (pCategory->m_fSortLexical)
			iReturn = pstrFirst->Collate(*pstrSecond);
		else
			iReturn = (dwFirst < dwSecond) ? -1 : (dwFirst == dwSecond) ? 0 : 1;

		if (!pCategory->m_fSortAscending)
			iReturn *= -1;
	}

	return iReturn;
}

//---------------------------------------------------------------------------
// Copy selected text from the list view into the clipboard.
//---------------------------------------------------------------------------

void CMSInfo::EditCopy()
{
	if (GetFocus() == m_wndFindWhat.m_hWnd && m_wndFindWhat.IsWindowVisible() && m_wndFindWhat.IsWindowEnabled())
	{
		m_wndFindWhat.SendMessage(WM_COPY);
		return;
	}

	CString strClipboardText(_T(""));

	CMSInfoCategory * pCategory = GetCurrentCategory();
	if (pCategory == NULL)
		return;

	if (pCategory && pCategory->GetDataSourceType() == NFO_410)
	{
		CMSInfo4Category *	pCategory4 = (CMSInfo4Category *) pCategory;
		CMSIControl *		p4Ctrl = NULL;

        if (CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(pCategory4->m_strCLSID, p4Ctrl) && p4Ctrl)
			p4Ctrl->MSInfoCopy();

		return;
	}

	int iRowCount, iColCount;
	pCategory->GetCategoryDimensions(&iColCount, &iRowCount);

	// Build the string to put in the clipboard by finding all of the
	// selected lines in the list view.

	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	CString * pstrCell;
	int iSelected = ListView_GetNextItem(m_list.m_hWnd, -1, LVNI_SELECTED);
	while (iSelected != -1)
	{
		lvi.iItem = iSelected;
		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			ASSERT(lvi.lParam < iRowCount);
			if (lvi.lParam < iRowCount)
				for (int iCol = 0; iCol < iColCount; iCol++)
					if (SUCCEEDED(pCategory->GetData((int)lvi.lParam, iCol, &pstrCell, NULL)))
					{
						if (iCol)
							strClipboardText += _T("\t");
						strClipboardText += *pstrCell;
					}
			strClipboardText += _T("\r\n");
		}

		iSelected = ListView_GetNextItem(m_list.m_hWnd, iSelected, LVNI_SELECTED);
	}

	// Put the string in the clipboard.

	if (OpenClipboard())
	{
		if (EmptyClipboard())
		{
			DWORD	dwSize = (strClipboardText.GetLength() + 1) * sizeof(TCHAR);
			HGLOBAL hMem = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize);

			if (hMem)
			{
				LPVOID lpvoid = ::GlobalLock(hMem);
				if (lpvoid)
				{
					memcpy(lpvoid, (LPCTSTR) strClipboardText, dwSize);
					::GlobalUnlock(hMem);
					SetClipboardData(CF_UNICODETEXT, hMem);
				}
			}
		}
		CloseClipboard();
	}
}

//---------------------------------------------------------------------------
// Select all of the text in the list view.
//---------------------------------------------------------------------------

void CMSInfo::EditSelectAll()
{
	CMSInfoCategory * pCategory = GetCurrentCategory();

	if (pCategory && pCategory->GetDataSourceType() == NFO_410)
	{
		CMSInfo4Category *	pCategory4 = (CMSInfo4Category *) pCategory;
		CMSIControl *		p4Ctrl = NULL;

        if (CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(pCategory4->m_strCLSID, p4Ctrl) && p4Ctrl)
			p4Ctrl->MSInfoSelectAll();
	}
	else
	{
		int iCount = ListView_GetItemCount(m_list.m_hWnd);
		for (int i = 0; i < iCount; i++)
			ListView_SetItemState(m_list.m_hWnd, i, LVIS_SELECTED, LVIS_SELECTED);
	}
}

void CMSInfo::GetMachineName(LPTSTR lpBuffer, LPDWORD lpnSize)
{
  if (_tcslen(m_strMachine) == 0)
    GetComputerName(lpBuffer, lpnSize);
  else
    _tcsncpy(lpBuffer, m_strMachine, *lpnSize);
}

//---------------------------------------------------------------------------
// Print the currently displayed information.
//---------------------------------------------------------------------------

void CMSInfo::DoPrint(BOOL fNoUI)
{
	if (m_pCurrData == NULL)
		return;

	CMSInfoCategory * pRootCategory = m_pCurrData->GetRootCategory();
	CMSInfoCategory * pSelectedCategory = GetCurrentCategory();
	
	if (pRootCategory == NULL)
		return;

	DWORD dwFlags = PD_CURRENTPAGE | PD_NOPAGENUMS | PD_RETURNDC | PD_HIDEPRINTTOFILE | PD_USEDEVMODECOPIESANDCOLLATE;
	if (pSelectedCategory == NULL)
		dwFlags |= PD_NOCURRENTPAGE | PD_NOSELECTION | PD_ALLPAGES;

	PRINTDLGEX pd;
	::ZeroMemory(&pd, sizeof(PRINTDLGEX));
	pd.Flags = dwFlags;
	pd.lStructSize = sizeof(PRINTDLGEX);
	pd.hwndOwner = this->m_hWnd;
	pd.ExclusionFlags = PD_EXCL_COPIESANDCOLLATE;
	pd.nStartPage = START_PAGE_GENERAL;

	if (fNoUI)
		pd.Flags |= PD_RETURNDEFAULT;
	
	if (SUCCEEDED(::PrintDlgEx(&pd)) && pd.dwResultAction == PD_RESULT_PRINT)
	{
		BOOL fPrintCategory = ((pd.Flags & PD_SELECTION) != 0) || ((pd.Flags & PD_CURRENTPAGE) != 0);
		BOOL fPrintRecursive = ((pd.Flags & PD_CURRENTPAGE) == 0);

		CMSInfoCategory * pPrintCategory = (fPrintCategory) ? pSelectedCategory : pRootCategory;
		if (pPrintCategory)
		{
			if (pPrintCategory->GetDataSourceType() == LIVE_DATA)
			{
				RefreshData((CLiveDataSource *)m_pCurrData, (CMSInfoLiveCategory *)pPrintCategory);
			}
			else if (pPrintCategory->GetDataSourceType() == NFO_410)
			{
				((CMSInfo4Category *) pPrintCategory)->RefreshAllForPrint(m_hWnd,this->GetOCXRect());
			}
			else if (pPrintCategory->GetDataSourceType() == XML_SNAPSHOT)
			{
				((CXMLSnapshotCategory*) pPrintCategory)->Refresh((CXMLDataSource*) m_pCurrData, TRUE);
			}
			
			DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
			LPTSTR lpMachineName = new TCHAR[dwSize];
			GetMachineName(lpMachineName, &dwSize);
			pPrintCategory->Print(pd.hDC, fPrintRecursive, -1, -1, lpMachineName); // -1's to include all pages
			delete [] lpMachineName;
		}
	}
}

//---------------------------------------------------------------------------
// Update the tools menu to match the contents of the tools map.
//---------------------------------------------------------------------------

void CMSInfo::UpdateToolsMenu()
{
	if (NULL == m_hmenu)
		return;

	HMENU hmenuTool = ::GetSubMenu(m_hmenu, 3);
	if (hmenuTool)
	{
		// Remove all the current tools in the menu.

		while (DeleteMenu(hmenuTool, 0, MF_BYPOSITION));

		// Add the tools from the map. This will add the top level tools.

		WORD			wCommand;
		CMSInfoTool *	pTool;

		for (POSITION pos = m_mapIDToTool.GetStartPosition(); pos != NULL; )
		{
			m_mapIDToTool.GetNextAssoc(pos, wCommand, (void * &) pTool);
			if (pTool && pTool->GetParentID() == 0)
			{
				if (!pTool->HasSubitems())
					InsertMenu(hmenuTool, 0xFFFFFFFF, MF_BYPOSITION | MF_STRING, (UINT) pTool->GetID(), pTool->GetName());
				else
				{
					HMENU hmenuNew = CreatePopupMenu();
					InsertMenu(hmenuTool, 0xFFFFFFFF, MF_BYPOSITION | MF_STRING | MF_POPUP, (UINT_PTR) hmenuNew, pTool->GetName());
					pTool->SetHMENU(hmenuNew);
				}
			}
		}

		// Now add the second level tools (the subitems).

		for (pos = m_mapIDToTool.GetStartPosition(); pos != NULL; )
		{
			m_mapIDToTool.GetNextAssoc(pos, wCommand, (void * &) pTool);
			if (pTool && pTool->GetParentID())
			{
				CMSInfoTool * pParentTool;

				if (m_mapIDToTool.Lookup((WORD) pTool->GetParentID(), (void * &) pParentTool))
					InsertMenu(pParentTool->GetHMENU(), 0xFFFFFFFF, MF_BYPOSITION | MF_STRING, (UINT) pTool->GetID(), pTool->GetName());
			}
		}
	}
}

//---------------------------------------------------------------------------
// Gets the right pane rect in which to display a MSInfo 4.x OCX.
//---------------------------------------------------------------------------

CRect CMSInfo::GetOCXRect()
{
	CRect rectList;

	m_list.GetWindowRect(&rectList);
	ScreenToClient(&rectList);
	rectList.DeflateRect(1, 1, 2, 2);

	return rectList;
}

//=============================================================================
// Find Functionality
//=============================================================================

//-------------------------------------------------------------------------
// CancelFind does what is says. It also waits until the find is done
// before returning.
//-------------------------------------------------------------------------

void CMSInfo::CancelFind()
{
	if (m_fInFind)
	{
		m_fCancelFind = TRUE;
		m_fFindNext = FALSE;
		GotoDlgCtrl(m_wndStopFind.m_hWnd);
		UpdateFindControls();

		if (m_pcatFind && m_pcatFind->GetDataSourceType() == LIVE_DATA)
		{
			CLiveDataSource * pLiveDataSource = (CLiveDataSource *) m_pCurrData;
			HCURSOR hc = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
			pLiveDataSource->WaitForRefresh();
			::SetCursor(hc);
		}
	}
}

//-------------------------------------------------------------------------
// When the user clicks on Stop Find, it will either cancel the current
// find operation (if there is one in progress) or hide the find controls
// (if there is no find in progress).
//-------------------------------------------------------------------------

LRESULT CMSInfo::OnStopFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	if (m_fInFind)
	{
		m_fCancelFind = TRUE;
		m_fFindNext = FALSE;
		GotoDlgCtrl(m_wndStopFind.m_hWnd);
		UpdateFindControls();
	}
	else
	{
		m_fFindNext = FALSE;
		DispatchCommand(ID_EDIT_FIND);
	}
	return 0;
}

//-------------------------------------------------------------------------
// UpdateFindControls updates the state of the controls (the text and
// enabling/disabling) based on the settings of the find member vars.
//-------------------------------------------------------------------------

void CMSInfo::UpdateFindControls()
{
	if (!m_fFindVisible)
		return;

	::AfxSetResourceHandle(_Module.GetResourceInstance());

	m_wndCancelFind.ShowWindow(m_fInFind ? SW_SHOW : SW_HIDE);
	m_wndStopFind.ShowWindow(m_fInFind ? SW_HIDE : SW_SHOW);
	m_wndFindNext.ShowWindow(m_fFindNext ? SW_SHOW : SW_HIDE);
	m_wndStartFind.ShowWindow(m_fFindNext ? SW_HIDE : SW_SHOW);

	m_wndStopFind.EnableWindow(!m_fInFind && ((m_fInFind && !m_fCancelFind) || !m_fInFind));
	m_wndCancelFind.EnableWindow(m_fInFind && ((m_fInFind && !m_fCancelFind) || !m_fInFind));
	m_wndStartFind.EnableWindow(!m_fFindNext && (!m_fInFind && !m_strFind.IsEmpty()));
	m_wndFindNext.EnableWindow(m_fFindNext && (!m_fInFind && !m_strFind.IsEmpty()));

	m_wndFindWhatLabel.EnableWindow(!m_fInFind);
	m_wndFindWhat.EnableWindow(!m_fInFind);
	m_wndSearchSelected.EnableWindow(!m_fInFind);
	m_wndSearchCategories.EnableWindow(!m_fInFind);
}

//-------------------------------------------------------------------------
// When the user changes the text in the find what edit box, we need to
// make sure we keep track of the string, and that we are in "find" (rather
// than "find next") mode.
//-------------------------------------------------------------------------

LRESULT CMSInfo::OnChangeFindWhat(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_fFindNext = FALSE;

	// Get the find text from the rich edit control (use EM_GETTEXTEX
	// to preserve its Unicode-ness).

	TCHAR		szBuffer[MAX_PATH];
	GETTEXTEX	gte;

	gte.cb				= MAX_PATH;
	gte.flags			= GT_DEFAULT;
	gte.codepage		= 1200; // Unicode
	gte.lpDefaultChar	= NULL;
	gte.lpUsedDefChar	= NULL;
	m_wndFindWhat.SendMessage(EM_GETTEXTEX, (WPARAM)&gte, (LPARAM)szBuffer);
	m_strFind = szBuffer;

	UpdateFindControls();
	SetMenuItems();
	return 0;
}

//-------------------------------------------------------------------------
// When the user clicks on Find, it will either be for a "Find" or a 
// "Find Next". 
//-------------------------------------------------------------------------

LRESULT CMSInfo::OnFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_fSearchCatNamesOnly = IsDlgButtonChecked(IDC_CHECKSEARCHCATSONLY);
	m_fSearchSelectedCatOnly = IsDlgButtonChecked(IDC_CHECKSEARCHSELECTED);

	if (!m_fFindNext)
	{
		m_fInFind = TRUE;
		m_fCancelFind = FALSE;
		m_fFindNext = TRUE;
		m_iFindLine = -2;

		// Based on the user's setting of "Search selected category only", start
		// with either the selected category or the root category.

		if (m_fSearchSelectedCatOnly)
			m_pcatFind = GetCurrentCategory();
		else
			m_pcatFind = m_pCurrData->GetRootCategory();

		UpdateFindControls();
		::SetFocus(m_wndCancelFind.m_hWnd);
	}
	else
	{
		if (FindInCurrentCategory())
			return 0;

		m_fInFind = TRUE;
		m_fCancelFind = FALSE;
		UpdateFindControls();
		::SetFocus(m_wndCancelFind.m_hWnd);
	}

	// The refresh will post a message that data is ready, so we can search the
	// specified category. If we aren't going to refresh the category, we'll just
	// post the message ourselves.

	if (m_pcatFind)
	{
		SetMessage(IDS_SEARCHMESSAGE, 0, TRUE);
		if (m_pcatFind->GetDataSourceType() == LIVE_DATA && !m_fSearchCatNamesOnly)
			((CMSInfoLiveCategory *) m_pcatFind)->Refresh((CLiveDataSource *) m_pCurrData, FALSE);
		else
			PostMessage(WM_MSINFODATAREADY, 0, (LPARAM)m_pcatFind);
	}

	return 0;
}

//-------------------------------------------------------------------------
// This is the function that's called when the data ready message is
// received by the window. Look for the data in the current find category.
// If there is a match, it will be shown and the find operation stopped.
// Otherwise (unless the option's been selected to search only the current
// category) continue the find operation with the next category.
//-------------------------------------------------------------------------

void CMSInfo::FindRefreshComplete()
{
	if (m_fCancelFind)
	{
		m_fInFind = FALSE;
		m_fFindNext = FALSE;
		GotoDlgCtrl(m_wndStopFind.m_hWnd);
//		SetMessage(0);
		SelectCategory(GetCurrentCategory());
		UpdateFindControls();
		::SetFocus(m_wndStartFind.m_hWnd);
		return;
	}

	if (FindInCurrentCategory())
		return;

	// If the user checked "Search selected category only", then we should
	// not look through any additional categories.

	if (m_fSearchSelectedCatOnly)
		m_pcatFind = NULL;
	else
	{
		m_iFindLine = -2;

		CMSInfoCategory * pNextCategory;
		pNextCategory = m_pcatFind->GetFirstChild();
		if (pNextCategory == NULL)
			while (m_pcatFind)
			{
				pNextCategory = m_pcatFind->GetNextSibling();
				if (pNextCategory)
					break;

				m_pcatFind = m_pcatFind->GetParent();
			}

		m_pcatFind = pNextCategory;
	}

	// If the category is NULL, there are no more matches. Return the
	// controls to a normal state and notify the user.

	if (m_pcatFind == NULL)
	{
		m_fInFind = FALSE;
		m_fFindNext = FALSE;
		UpdateFindControls();
		MSInfoMessageBox(IDS_NOMOREMATCHES);
		SelectCategory(GetCurrentCategory());
		GotoDlgCtrl(m_wndStopFind.m_hWnd);

		return;
	}

	SetMessage(IDS_SEARCHMESSAGE);
	if (m_pcatFind->GetDataSourceType() == LIVE_DATA && !m_fSearchCatNamesOnly)
		((CMSInfoLiveCategory *) m_pcatFind)->Refresh((CLiveDataSource *) m_pCurrData, FALSE);
	else
		PostMessage(WM_MSINFODATAREADY, 0, (LPARAM)m_pcatFind);
}

//-------------------------------------------------------------------------
// Look for the string in the current category. This function will be 
// called when data is avaible for the category. If there is a match, show
// it and return TRUE, otherwise return FALSE.
//
// m_iFindLine contains the list view row number of the last match. If it
// is -1, it means we are just starting on this category (since we would
// start looking at row 0). If it is -2, then we should look for the string
// in the category name. (Note - this might be all we do, depending on the
// setting for m_fSearchCatNamesOnly.)
//-------------------------------------------------------------------------

BOOL CMSInfo::FindInCurrentCategory()
{
	if (m_pcatFind == NULL)
		return FALSE;

	// The search is case insensitive, so convert our search string to lower case.

	CString strLookFor(m_strFind);
	strLookFor.TrimLeft(_T("\t\r\n "));
	strLookFor.TrimRight(_T("\t\r\n "));
	strLookFor.MakeLower();

	// If m_iFindLine is -2, then we should look at the category name for a match.

	if (m_iFindLine == -2)
	{
		m_iFindLine += 1;

		CString strCatName;
		m_pcatFind->GetNames(&strCatName, NULL);
		strCatName.MakeLower();
		if (strCatName.Find(strLookFor) != -1)
		{
			// There was a match. Get the HTREEITEM for the category and select it.

			HTREEITEM hti = m_pcatFind->GetHTREEITEM();
			if (hti)
			{
				m_fInFind = FALSE;
				m_fFindNext = TRUE;
				TreeView_EnsureVisible(m_tree.m_hWnd, hti);
				TreeView_SelectItem(m_tree.m_hWnd, hti);
				SetMessage(0);
				UpdateFindControls();
				GotoDlgCtrl(m_wndFindNext.m_hWnd);
				return TRUE;
			}
		}
	}

	// If we are search category names only, then we stop here (before looking
	// through the data for this category).

	if (m_fSearchCatNamesOnly)
		return FALSE;

	// If m_iFindLine is -1, then we need to look in the data for this category
	// to see if there is a match. If there is, then we select the category and
	// start looking through the lines of the list view (we can't use the index
	// we found looking through the data directly, because if the list view is
	// sorted we would be searching out of order).

	int iRow, iCol, iRowCount, iColCount;
	if (!m_pcatFind->GetCategoryDimensions(&iColCount, &iRowCount))
		return FALSE;

	if (m_iFindLine == -1)
	{
		CString	* pstrCell, strCell;
		BOOL fFound = FALSE;
		
		for (iRow = 0; iRow < iRowCount && !fFound; iRow++)
			if (m_fAdvanced || !m_pcatFind->IsRowAdvanced(iRow))
				for (iCol = 0; iCol < iColCount && !fFound; iCol++)
					if (m_fAdvanced || !m_pcatFind->IsColumnAdvanced(iCol))
						if (m_pcatFind->GetData(iRow, iCol, &pstrCell, NULL))
						{
							strCell = *pstrCell;
							strCell.MakeLower();
							if (strCell.Find(strLookFor) != -1)
								fFound = TRUE;
						}

		if (!fFound)
			return FALSE;

		// We found data in this category. Select it so it populates the list view.

		HTREEITEM hti = m_pcatFind->GetHTREEITEM();
		if (hti)
		{
			TreeView_EnsureVisible(m_tree.m_hWnd, hti);
			TreeView_SelectItem(m_tree.m_hWnd, hti);
			SetMessage(0);
		}
	}

	// If we get here, m_iFindLine will be >= -1, and represents the line in the
	// list view after which we should start searching.

	m_iFindLine += 1;

	CString strData;
	int		iListRowCount = ListView_GetItemCount(m_list.m_hWnd);
	int		iListColCount = 0;

	// Determine the number of columns in the list view.

	for (iCol = 0; iCol < iColCount; iCol++)
		if (m_fAdvanced || !m_pcatFind->IsColumnAdvanced(iCol))
			iListColCount += 1;

	while (m_iFindLine < iListRowCount)
	{
		for (iCol = 0; iCol < iListColCount; iCol++)
		{
			ListView_GetItemText(m_list.m_hWnd, m_iFindLine, iCol, strData.GetBuffer(MAX_PATH), MAX_PATH);
			strData.ReleaseBuffer();
			if (strData.GetLength())
			{
				strData.MakeLower();
				if (strData.Find(strLookFor) != -1)
				{
					// We found a match. The category should already be selected,
					// so all we need to do is select the line (and make sure
					// all the other lines are not selected).

					for (int iRow = 0; iRow < iListRowCount; iRow++)
						if (iRow == m_iFindLine)
						{
							ListView_EnsureVisible(m_list.m_hWnd, iRow, TRUE);
							ListView_SetItemState(m_list.m_hWnd, iRow, LVIS_SELECTED, LVIS_SELECTED);
						}
						else
						{
							ListView_SetItemState(m_list.m_hWnd, iRow, 0, LVIS_SELECTED);
						}

					m_fInFind = FALSE;
					m_fFindNext = TRUE;
					SetMessage(0);
					UpdateFindControls();
					GotoDlgCtrl(m_wndFindNext.m_hWnd);
					return TRUE;
				}
			}
		}
		m_iFindLine += 1;
	}

	// If we fall through to here, then there were no more matches in the 
	// list view. Return FALSE.

	return FALSE;
}

//-------------------------------------------------------------------------
// ShowFindControls is called to show or hide the dialog controls used
// for find.
//-------------------------------------------------------------------------

void CMSInfo::ShowFindControls()
{
	int iShowCommand = (m_fFindVisible) ? SW_SHOW : SW_HIDE;

	if (m_fFindVisible)
		PositionFindControls();

	m_wndFindWhatLabel.ShowWindow(iShowCommand);
	m_wndFindWhat.ShowWindow(iShowCommand);
	m_wndSearchSelected.ShowWindow(iShowCommand);
	m_wndSearchCategories.ShowWindow(iShowCommand);
	m_wndStartFind.ShowWindow(iShowCommand);
	m_wndStopFind.ShowWindow(iShowCommand);
	m_wndFindNext.ShowWindow(iShowCommand);
	m_wndCancelFind.ShowWindow(iShowCommand);

	if (iShowCommand == SW_HIDE)
	{
		m_wndFindWhatLabel.EnableWindow(FALSE);
		m_wndFindWhat.EnableWindow(FALSE);
		m_wndSearchSelected.EnableWindow(FALSE);
		m_wndSearchCategories.EnableWindow(FALSE);
		m_wndStartFind.EnableWindow(FALSE);
		m_wndStopFind.EnableWindow(FALSE);
		m_wndFindNext.EnableWindow(FALSE);
		m_wndCancelFind.EnableWindow(FALSE);
	}

	if (!m_fFindVisible)
		return;
}

//-------------------------------------------------------------------------
// Position the find controls on the control surface. This will be called
// when the find controls are shown, or when the control is resized.
//-------------------------------------------------------------------------

int CMSInfo::PositionFindControls()
{
	if (!m_fFindVisible)
		return 0;

	// Get some useful sizes of the various controls we need to move around
	// the window.

	CRect rectFindWhatLabel, rectFindWhat, rectSearchSelected, rectSearchCategories;
	CRect rectStartFind, rectStopFind, rectClient;

	GetClientRect(&rectClient);
	m_wndFindWhatLabel.GetWindowRect(&rectFindWhatLabel);
	m_wndFindWhat.GetWindowRect(&rectFindWhat);
	m_wndStartFind.GetWindowRect(&rectStartFind);
	m_wndStopFind.GetWindowRect(&rectStopFind);
	m_wndSearchSelected.GetWindowRect(&rectSearchSelected);
	m_wndSearchCategories.GetWindowRect(&rectSearchCategories);
	
	int iSpacer = 5;

	// The control rect is the space we have to work with for placing the controls.

	CRect rectControl(rectClient);
	rectControl.DeflateRect(iSpacer, iSpacer);

	// Determine if we have enough room to lay out the controls
	// horizontally, or if we need to stack them. Horizontally, it looks like:
	//
	//  <spacer><Find What label><spacer><Find What edit><spacer><Start Find><spacer><Stop Find><spacer>
	//	<spacer><Search Selected check><spacer><Search Cats check><spacer>

	int  cxTopLine = iSpacer * 5 + rectFindWhatLabel.Width() * 2 + rectStartFind.Width() + rectStopFind.Width();
	int  cxBottomLine = iSpacer * 3 + rectSearchSelected.Width() + rectSearchCategories.Width();
	BOOL fHorizontal = (cxTopLine <= rectClient.Width() && cxBottomLine <= rectClient.Width());

	// If it get's wider than a certain size, it becomes less usable. So put a reasonable
	// limit on the width:

	int cxMaxWidth = iSpacer * 5 + rectFindWhatLabel.Width() + rectSearchSelected.Width() + rectSearchCategories.Width() + rectStartFind.Width() + rectStopFind.Width();
	if (fHorizontal && rectControl.Width() > cxMaxWidth)
		rectControl.DeflateRect((rectControl.Width() - cxMaxWidth) / 2, 0);

	// Figure the height of the control rectangle.

	int cyControlRectHeight = rectStartFind.Height() + ((fHorizontal) ? 0 : rectStopFind.Height() + iSpacer);
	int cyLeftSideHeight;

	if (fHorizontal)
		cyLeftSideHeight = rectFindWhat.Height() + iSpacer + rectSearchSelected.Height();
	else
		cyLeftSideHeight = rectFindWhat.Height() + iSpacer * 2 + rectSearchSelected.Height() * 2;

	if (cyControlRectHeight < cyLeftSideHeight)
		cyControlRectHeight = cyLeftSideHeight;

	rectControl.top = rectControl.bottom - cyControlRectHeight;

	// Position the buttons appropriately.

	if (fHorizontal)
	{
		rectStopFind.OffsetRect(rectControl.right - rectStopFind.right, rectControl.top - rectStopFind.top);
		rectStartFind.OffsetRect(rectStopFind.left - rectStartFind.right - iSpacer, rectControl.top - rectStartFind.top);
	}
	else
	{
		rectStartFind.OffsetRect(rectControl.right - rectStartFind.right, rectControl.top - rectStartFind.top);
		rectStopFind.OffsetRect(rectControl.right - rectStopFind.right, rectStartFind.bottom + iSpacer - rectStopFind.top);
	}

	// Position the find label and the find edit box.

	rectFindWhatLabel.OffsetRect(rectControl.left - rectFindWhatLabel.left, rectControl.top - rectFindWhatLabel.top + (rectFindWhat.Height() - rectFindWhatLabel.Height()) / 2);
	rectFindWhat.OffsetRect(rectFindWhatLabel.right - rectFindWhat.left + iSpacer, rectControl.top - rectFindWhat.top);
	rectFindWhat.right = rectStartFind.left - iSpacer;

	// Position the check boxes.

	rectSearchSelected.OffsetRect(rectControl.left - rectSearchSelected.left, rectFindWhat.bottom - rectSearchSelected.top + iSpacer);

	if (fHorizontal)
		rectSearchCategories.OffsetRect(rectSearchSelected.right - rectSearchCategories.left + iSpacer, rectSearchSelected.top - rectSearchCategories.top);
	else
		rectSearchCategories.OffsetRect(rectControl.left - rectSearchCategories.left, rectSearchSelected.bottom - rectSearchCategories.top + iSpacer);

	// If the check boxes are going to overlap the buttons (we'd be very narrow), adjust the button
	// position (which might end up off the control, but what're ya gonna do?).

	int iRightMostCheckboxEdge = rectSearchCategories.right;
	if (iRightMostCheckboxEdge < rectSearchSelected.right)
		iRightMostCheckboxEdge = rectSearchSelected.right;
	iRightMostCheckboxEdge += iSpacer;

	if (!fHorizontal && rectStopFind.left < iRightMostCheckboxEdge)
	{
		rectStopFind.OffsetRect(iRightMostCheckboxEdge - rectStopFind.left, 0);
		rectStartFind.OffsetRect(rectStopFind.left - rectStartFind.left, 0);
		rectFindWhat.right = rectStartFind.left - iSpacer;
	}

	m_wndStopFind.MoveWindow(&rectStopFind);
	m_wndStartFind.MoveWindow(&rectStartFind);
	m_wndFindNext.MoveWindow(&rectStartFind);
	m_wndCancelFind.MoveWindow(&rectStopFind);
	m_wndFindWhatLabel.MoveWindow(&rectFindWhatLabel);
	m_wndFindWhat.MoveWindow(&rectFindWhat);
	m_wndSearchSelected.MoveWindow(&rectSearchSelected);
	m_wndSearchCategories.MoveWindow(&rectSearchCategories);

	return (rectControl.Height() + iSpacer * 2);
}

//-------------------------------------------------------------------------
// Refresh all of the data prior to saving, exporting, printing. This will
// present a dialog box with the refresh message and a progress bar, but
// will not return until the refresh is completed.
//-------------------------------------------------------------------------

void CMSInfo::RefreshData(CLiveDataSource * pSource, CMSInfoLiveCategory * pLiveCategory)
{
	if (pSource == NULL || pSource->m_pThread == NULL)
		return;

	// Create the dialog with the refresh message and progress
	// bar, and display it.

	CWaitForRefreshDialog dlg;
	dlg.DoRefresh(pSource, pLiveCategory);
}

//=============================================================================
// Functions for managing the DCO (the object providing history).
//=============================================================================

STDMETHODIMP CMSInfo::UpdateDCOProgress(VARIANT varPctDone)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	//V-stlowe 1/30/2001
	VERIFY(SUCCEEDED(VariantChangeType(&varPctDone,&varPctDone,0,VT_INT))); 
	if (this->m_HistoryProgressDlg.IsWindow())//todo: is there a better state function to determine if dlg is modal?
	{
		HWND hWnd = m_HistoryProgressDlg.GetDlgItem(IDC_PROGRESS1);
		if(::IsWindow(hWnd))
		{
			//int nOffset = varPctDone.iVal -  (int) ::SendMessage(m_hWnd, PBM_GETPOS, 0, 0);
			//To do: don't rely on 3 (current SAF progress step); find way to get offset.
			::SendMessage(hWnd, PBM_DELTAPOS,3, 0L);
		}
	}
	return S_OK;
}

STDMETHODIMP CMSInfo::SetHistoryStream(IStream *pStream)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	#ifdef A_STEPHL
		ASSERT(0);
	#endif
	//v-stlowe 2/23/2001 shut down progress bar dialog
	SetEvent(m_hEvtHistoryComplete);
	HRESULT hr = pStream->QueryInterface(IID_IStream,(void**) &m_pHistoryStream);
	if (FAILED(hr) || !m_pHistoryStream)
	{	
		m_pHistoryStream = NULL;
		return E_FAIL;
	}

	if (m_pLiveData)
		((CLiveDataSource *)m_pLiveData)->SetHistoryStream(m_pHistoryStream);

	// When the history stream is available, we need to modify the UI to allow
	// the user to select the history.

	if (!m_fHistoryAvailable)
	{
		m_fHistoryAvailable = TRUE;//actually this should already be true...
		
		SetMenuItems();
	}
	m_fHistorySaveAvailable = TRUE;
	FillHistoryCombo();
	//if history window is current view, refresh
	if (m_history.IsWindowVisible())
	{
		CMSInfoCategory * pCategory = GetCurrentCategory();
		if (pCategory != NULL && pCategory->GetDataSourceType() == LIVE_DATA)
		{	
			m_pLastCurrentCategory = GetCurrentCategory();

			int iIndex = (int)m_history.SendMessage(CB_GETCURSEL, 0, 0);
			if (iIndex == CB_ERR)
			{
				iIndex = 0;
				m_history.SendMessage(CB_SETCURSEL, (WPARAM)iIndex, 0);
			}
			ChangeHistoryView(iIndex);

		}
	}
	else if (m_fShowPCH && !m_history.IsWindowVisible() && m_strMachine.IsEmpty())
	{
		// If m_fShowPCH is set, then the command line option to launch into
		// the history view was selected.
	
		DispatchCommand(ID_VIEW_HISTORY);
	}
	
#ifdef A_STEPHL
	//STATSTG streamStat;
	//hr = m_pHistoryStream->Stat(&streamStat,STATFLAG_NONAME );
	//ASSERT(SUCCEEDED(hr) && "couldn't get stream statistics");
	//BYTE* pBuffer = new BYTE[streamStat.cbSize.LowPart];
	//ULONG ulRead;
	//m_pHistoryStream->Read(pBuffer,streamStat.cbSize.LowPart,&ulRead);
//	CFile file;
	//file.Open("c:\\history.xml", CFile::modeCreate | CFile::modeWrite);
//	file.Write(pBuffer,ulRead);
//	delete pBuffer;
#endif

	return S_OK;
}

STDMETHODIMP CMSInfo::get_DCO_IUnknown(IUnknown **pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_pDCO == NULL)
		return E_FAIL;

	return (m_pDCO->QueryInterface(IID_IUnknown,(void**) pVal));
}

STDMETHODIMP CMSInfo::put_DCO_IUnknown(IUnknown *newVal)
{
	//v-stlowe 2/23/2001
	//beware situation where put_DCO_IUnknown gets called before control is finished initializing.
	WaitForSingleObject(m_evtControlInit,INFINITE);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = newVal->QueryInterface( __uuidof(ISAFDataCollection), (void**)&m_pDCO );
	if (FAILED(hr))
		return E_FAIL;
	//end v-stlowe 2/23/2001

	TCHAR szDataspecPath[MAX_PATH];
	if (ExpandEnvironmentStrings(_T("%windir%\\pchealth\\helpctr\\config\\dataspec.xml"), szDataspecPath, MAX_PATH))
	{
		CComBSTR bstrPath(szDataspecPath);

		if (m_pDCO != NULL && (BSTR)bstrPath != NULL)
		{
			hr = m_pDCO->put_MachineData_DataSpec(bstrPath);
			hr = m_pDCO->put_History_DataSpec(bstrPath);
		}
		// This is done by the script now: m_pDCO->ExecuteAsync();
	}

	// Have to put this after the calls made using the DCO, so that the /pch
	// flag (which is to start MSInfo with history showing) works.

	if (!m_fHistoryAvailable)
	{
		m_fHistoryAvailable = TRUE;
		if (m_fShowPCH && !m_history.IsWindowVisible() && m_strMachine.IsEmpty())
			DispatchCommand(ID_VIEW_HISTORY);
		SetMenuItems();
	}

	return S_OK;
}

//=============================================================================
// Interface methods to do a silent save of a file.
//=============================================================================

STDMETHODIMP CMSInfo::SaveFile(BSTR filename, BSTR computer, BSTR category)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString strFilename(filename);
	CString strComputer(computer);
	CString strCategory(category);

	HRESULT hr = E_FAIL;

	::AfxSetResourceHandle(_Module.GetResourceInstance());
	CLiveDataSource * pSilentSource = new CLiveDataSource;
	if (pSilentSource)
		hr = pSilentSource->Create(strComputer, NULL, strCategory);

	if (SUCCEEDED(hr))
	{
		m_fNoUI = TRUE;

		CDataSource * pOldSource = m_pCurrData;
		m_pCurrData = pSilentSource;
		if (strFilename.Right(4).CompareNoCase(CString(_T(".nfo"))) == 0)
			SaveMSInfoFile(strFilename);
		else
			ExportFile(strFilename, 0);
		m_pCurrData = pOldSource;

		delete pSilentSource;

		m_fNoUI = FALSE;
	}

	return hr;
}

LRESULT CHistoryRefreshDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msinfo.h ===
// MSInfo.h : Declaration of the CMSInfo

#ifndef __MSINFO_H_
#define __MSINFO_H_

#include <commdlg.h>
#include "resource.h"       // main symbols
#include <atlctl.h>
#include "pseudomenu.h"
#include "datasource.h"
#include "category.h"
#include "msinfotool.h"
#include "msinfo4category.h"
#include "htmlhelp.h"
#include <afxdlgs.h>
#include "dataset.h"

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

extern BOOL FileExists(const CString & strFile);
extern void StringReplace(CString & str, LPCTSTR szLookFor, LPCTSTR szReplaceWith);
extern BOOL gfEndingSession;

//v-stlowe History progress dialog
//member variable of CMSInfo so it can be updated by CMSInfo::UpdateDCOProgress
// CHistoryRefreshDlg dialog
//=========================================================================
// 
//=========================================================================
#include "HistoryParser.h"	// Added by ClassView
#include <afxcmn.h>
#include <afxmt.h>


class CHistoryRefreshDlg : public CDialogImpl<CHistoryRefreshDlg>
{
public:
   enum { IDD = IDD_HISTORYREFRESHPROGRESS };
   CWindow		m_wndProgressBar;
   BEGIN_MSG_MAP(CWaitForRefreshDialog)
	   MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
   END_MSG_MAP()

   LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	
};

/////////////////////////////////////////////////////////////////////////////
// CMSInfo

class ATL_NO_VTABLE CMSInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CMSInfo, IMSInfo, &IID_IMSInfo, &LIBID_MSINFO32Lib>,
	public CComCompositeControl<CMSInfo>,
	public IPersistStreamInitImpl<CMSInfo>,
	public IOleControlImpl<CMSInfo>,
	public IOleObjectImpl<CMSInfo>,
	public IOleInPlaceActiveObjectImpl<CMSInfo>,
	public IViewObjectExImpl<CMSInfo>,
	public IOleInPlaceObjectWindowlessImpl<CMSInfo>,
	public IPersistStorageImpl<CMSInfo>,
	public ISpecifyPropertyPagesImpl<CMSInfo>,
	public IQuickActivateImpl<CMSInfo>,
	public IDataObjectImpl<CMSInfo>,
	public IProvideClassInfo2Impl<&CLSID_MSInfo, NULL, &LIBID_MSINFO32Lib>,
	public CComCoClass<CMSInfo, &CLSID_MSInfo>
{
public:
	CMSInfo() :m_fHistoryAvailable(FALSE),m_pCurrData(NULL),m_fHistorySaveAvailable(FALSE)
	{
		m_bWindowOnly = TRUE;
		CalcExtent(m_sizeExtent);
		//v-stlowe 2/23/01 synchronization for put_DCO_IUnknown
		m_evtControlInit = CreateEvent(NULL,TRUE,FALSE,CString(_T("MSInfoControlInitialized")));
		//create history event, to signal when DCO has finished.
		m_hEvtHistoryComplete = CreateEvent(NULL,TRUE,FALSE,CString(_T("MSInfoHistoryDone")));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MSINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSInfo)
	COM_INTERFACE_ENTRY(IMSInfo)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CMSInfo)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("Appearance", DISPID_APPEARANCE, CLSID_NULL)
	PROP_ENTRY("AutoSize", DISPID_AUTOSIZE, CLSID_NULL)
	PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
	PROP_ENTRY("BackStyle", DISPID_BACKSTYLE, CLSID_NULL)
	PROP_ENTRY("BorderColor", DISPID_BORDERCOLOR, CLSID_StockColorPage)
	PROP_ENTRY("BorderStyle", DISPID_BORDERSTYLE, CLSID_NULL)
	PROP_ENTRY("BorderVisible", DISPID_BORDERVISIBLE, CLSID_NULL)
	PROP_ENTRY("BorderWidth", DISPID_BORDERWIDTH, CLSID_NULL)
	PROP_ENTRY("Font", DISPID_FONT, CLSID_StockFontPage)
	PROP_ENTRY("ForeColor", DISPID_FORECOLOR, CLSID_StockColorPage)
	PROP_ENTRY("HWND", DISPID_HWND, CLSID_NULL)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CMSInfo)
	MESSAGE_HANDLER(WM_CTLCOLORDLG, OnDialogColor)
	MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnDialogColor)
	CHAIN_MSG_MAP(CComCompositeControl<CMSInfo>)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUP)
	MESSAGE_HANDLER(WM_MSINFODATAREADY, OnMSInfoDataReady)
	NOTIFY_HANDLER(IDC_TREE, TVN_SELCHANGED, OnSelChangedTree)
	NOTIFY_HANDLER(IDC_LIST, LVN_COLUMNCLICK, OnColumnClick)
	NOTIFY_HANDLER(IDC_LIST, LVN_ITEMCHANGED, OnListItemChanged)
	NOTIFY_HANDLER(IDC_TREE, TVN_ITEMEXPANDING, OnItemExpandingTree)
	COMMAND_HANDLER(IDSTOPFIND, BN_CLICKED, OnStopFind)
	COMMAND_HANDLER(IDCANCELFIND, BN_CLICKED, OnStopFind)
	COMMAND_HANDLER(IDC_EDITFINDWHAT, EN_CHANGE, OnChangeFindWhat)
	COMMAND_HANDLER(IDSTARTFIND, BN_CLICKED, OnFind)
	COMMAND_HANDLER(IDFINDNEXT, BN_CLICKED, OnFind)
	COMMAND_HANDLER(IDC_HISTORYCOMBO, CBN_SELCHANGE, OnHistorySelection)
    COMMAND_HANDLER(IDC_CHECKSEARCHSELECTED, BN_CLICKED, OnClickedSearchSelected)
    COMMAND_HANDLER(IDC_CHECKSEARCHCATSONLY, BN_CLICKED, OnClickedSearchCatsOnly)
	MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
	NOTIFY_HANDLER(IDC_LIST, NM_SETFOCUS, OnSetFocusList)
    NOTIFY_HANDLER(IDC_LIST, LVN_GETINFOTIP, OnInfoTipList)
    NOTIFY_HANDLER(IDC_TREE, NM_RCLICK, OnRClickTree)
    COMMAND_HANDLER(IDC_EDITFINDWHAT, EN_SETFOCUS, OnSetFocusEditFindWhat)
    COMMAND_HANDLER(IDC_EDITFINDWHAT, EN_KILLFOCUS, OnKillFocusEditFindWhat)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

BEGIN_SINK_MAP(CMSInfo)
	//Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		if (dispid == DISPID_AMBIENT_BACKCOLOR)
		{
			// Don't respond to ambient color changes (yet).
			//
			// SetBackgroundColorFromAmbient();
			// FireViewChange();
		}
		return IOleControlImpl<CMSInfo>::OnAmbientPropertyChange(dispid);
	}

// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

// IMSInfo

public:
	STDMETHOD(SaveFile)(BSTR filename, BSTR computer, BSTR category);
	STDMETHOD(get_DCO_IUnknown)(/*[out, retval]*/ IUnknown* *pVal);
	STDMETHOD(put_DCO_IUnknown)(/*[in]*/ IUnknown* newVal);
	STDMETHOD(SetHistoryStream)(IStream * pStream);
	STDMETHOD(UpdateDCOProgress)(VARIANT nPctDone);

	//=========================================================================
	// Member variables generated by the wizard.
	//=========================================================================

	//v-stlowe 2/23/2001
	CHistoryRefreshDlg m_HistoryProgressDlg;

	//v-stlowe 2/27/2001 - filename needed when loading XML files, 
	//and switching between snapshot and history view
	CString m_strFileName;
	short				m_nAppearance;
	OLE_COLOR			m_clrBackColor;
	LONG				m_nBackStyle;
	OLE_COLOR			m_clrBorderColor;
	LONG				m_nBorderStyle;
	BOOL				m_bBorderVisible;
	LONG				m_nBorderWidth;
	CComPtr<IFontDisp>	m_pFont;
	OLE_COLOR			m_clrForeColor;

	//v-stlowe 2/23/01 synchronization for put_DCO_IUnknown
	HANDLE				m_evtControlInit;
	//v-stlowe 2/24/01 synchronization for History DCO progress dlg, so it can be destroyed
	//even if DCO never returns from collecting history
	HANDLE				m_hEvtHistoryComplete;
	UINT  HistoryRefreshDlgDlgThreadProc(LPVOID pParamNotUsed );

	enum { IDD = IDD_MSINFO };

	//=========================================================================
	// MSInfo member variables (initialized in OnInitDialog()).
	//=========================================================================

	BOOL				m_fDoNotRun;	// if this is TRUE, don't allow the control to do anything
	CString				m_strDoNotRun;	// message to display if we don't run

	CString				m_strMachine;	// if empty, local machine, otherwise network name

	CWindow				m_tree;			// set to refer to the tree view
	CWindow				m_list;			// set to refer to the list view
	int					m_iTreeRatio;	// the tree is x% the size of the list view
	BOOL				m_fFirstPaint;	// flag so we can initialize some paint things, once

	CDataSource *		m_pLiveData;	// data source for current data from WMI
	CDataSource *		m_pFileData;	// data source for an open NFO, XML snapshot
	CDataSource *		m_pCurrData;	// copy of one of the previous two (don't need to delete this)
	CMSInfoCategory *	m_pCategory;	// currently selected category

	BOOL				m_fMouseCapturedForSplitter;	// mouse currently being looked at by splitter
	BOOL				m_fTrackingSplitter;			// does the user have the LBUTTON down, resizing panes
	RECT				m_rectSplitter;					// current splitter rect (for hit tests)
	RECT				m_rectLastSplitter;				// last rect in DrawFocusRect
	int					m_cxOffset;						// offset from mouse position to left side of splitter

	BOOL				m_fAdvanced;	// currently showing advanced data?
	CString				m_strMessTitle;	// title for message to display in results
	CString				m_strMessText;	// text for message to display in results

	BOOL				m_fNoUI;		// true if doing a silent save

	int					m_aiCategoryColNumber[64]; // contains category column for each list view column
	int					m_iCategoryColNumberLen;

	CMapWordToPtr		m_mapIDToTool;	// a map from menu ID to a CMSInfoTool pointer

	TCHAR				m_szCurrentDir[MAX_PATH];	// current directory when control starts (should restore)

	// Find member variables.

	BOOL				m_fFindVisible;			// are the find controls visible?
	CWindow				m_wndFindWhatLabel;		// windows for the various find controls
	CWindow				m_wndFindWhat;
	CWindow				m_wndSearchSelected;
	CWindow				m_wndSearchCategories;
	CWindow				m_wndStartFind;
	CWindow				m_wndStopFind;
	CWindow				m_wndFindNext;
	CWindow				m_wndCancelFind;
	BOOL				m_fInFind;
	BOOL				m_fCancelFind;
	BOOL				m_fFindNext;
	BOOL				m_fSearchCatNamesOnly;
	BOOL				m_fSearchSelectedCatOnly;
	CString				m_strFind;
	CMSInfoCategory *	m_pcatFind;
	int					m_iFindLine;

	// History member variables.

	CWindow						m_history;
	CWindow						m_historylabel;
	BOOL						m_fHistoryAvailable;
	BOOL						m_fHistorySaveAvailable;
	CMSInfoCategory *			m_pLastCurrentCategory;
	CComPtr<ISAFDataCollection> m_pDCO;
	CComPtr<IStream>			m_pHistoryStream;

	// Member variables set from the command line parameters.

	CString	m_strOpenFile;
	CString	m_strPrintFile;
	CString	m_strCategory;
	CString	m_strCategories;
	CString	m_strComputer;
	BOOL	m_fShowPCH;
	BOOL	m_fShowCategories;

	//=========================================================================
	// A member variable and a function to hook into the windows procedure
	// of the parent window of the control (so we can put a menu on it).
	//=========================================================================

	HMENU				m_hmenu;
	HWND				m_hwndParent;
	static CMSInfo *	m_pControl;
	static WNDPROC		m_wndprocParent;

	static LRESULT CALLBACK MenuWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		if (uMsg == WM_COMMAND && m_pControl && m_pControl->DispatchCommand(LOWORD(wParam)))
			return 0;

		// We want to know if the session is ending (so we can set the timeout for
		// waiting for WMI to finish to something smaller).

		if (uMsg == WM_ENDSESSION || uMsg == WM_QUERYENDSESSION)
			gfEndingSession = TRUE;

		return CallWindowProc(m_wndprocParent, hwnd, uMsg, wParam, lParam);
	}

	//=========================================================================
	// Functions for initializing and destroying the dialog. A good place to
	// initialize variables and free memory.
	//=========================================================================

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		m_list.Attach(GetDlgItem(IDC_LIST));
		m_tree.Attach(GetDlgItem(IDC_TREE));

		m_history.Attach(GetDlgItem(IDC_HISTORYCOMBO));
		m_historylabel.Attach(GetDlgItem(IDC_HISTORYLABEL));

		// Determine if we are being loaded from within Help Center. Do this
		// by getting IOleContainer, which gives us IHTMLDocument2, which will
		// give us the URL loading us.

		m_fDoNotRun = TRUE;
		m_strDoNotRun.Empty();

		CString strParams;
		CComPtr<IOleContainer> spContainer;
		m_spClientSite->GetContainer(&spContainer); 
		CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> spHTMLDocument(spContainer);
		if (spHTMLDocument)
		{
			CComBSTR bstrURL;
			if (SUCCEEDED(spHTMLDocument->get_URL(&bstrURL)))
			{
				CComBSTR bstrEscapedUrl(bstrURL);
				USES_CONVERSION;
				if(SUCCEEDED(UrlUnescape(OLE2T(bstrEscapedUrl), NULL, NULL, URL_UNESCAPE_INPLACE)))
					bstrURL = bstrEscapedUrl;
				bstrEscapedUrl.Empty();
				
				CString strURL(bstrURL);

				int iQuestionMark = strURL.Find(_T("?"));
				if (iQuestionMark != -1)
					strParams = strURL.Mid(iQuestionMark + 1);

				strURL.MakeLower();
				if (strURL.Left(4) == CString(_T("hcp:")))
					m_fDoNotRun = FALSE;

				// Include the following when we want to test the control
				// using a local URL.

#ifdef MSINFO_TEST_WORKFROMLOCALURLS
				if (strURL.Left(5) == CString(_T("file:")))
					m_fDoNotRun = FALSE;
#endif
			}
		}
		
		if (m_fDoNotRun)
		{
			m_list.ShowWindow(SW_HIDE);
			m_tree.ShowWindow(SW_HIDE);
			return 0;
		}

		::GetCurrentDirectory(MAX_PATH, m_szCurrentDir);
 
		m_strMachine.Empty();

		m_fNoUI = FALSE;

		// Find the parent window for MSInfo. We want to add a menu bar to it.
		// We find the window by walking up the chain of parents until we get
		// to one with a caption. That window must also be top level (no parent),
		// and must not already have a menu.

		TCHAR	szBuff[MAX_PATH];
		HWND	hwnd = this->m_hWnd;

		m_hmenu = NULL;
		m_hwndParent = NULL;
		m_wndprocParent = NULL;
		while (hwnd != NULL)
		{
			if (::GetWindowText(hwnd, szBuff, MAX_PATH) && NULL == ::GetParent(hwnd) && NULL == ::GetMenu(hwnd))
			{
				// Update the window title. [This is done by the msinfo.xml file now.]
				//
				//	CString strNewCaption;
				//	::AfxSetResourceHandle(_Module.GetResourceInstance());
				//	strNewCaption.LoadString(IDS_SYSTEMINFO);
				//	::SetWindowText(hwnd, strNewCaption);

				// We've found the window. Load the menu bar for it.

				m_hmenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_MENUBAR));
				if (m_hmenu)
				{
					::SetMenu(hwnd, m_hmenu);

					// To catch the commands from the menu, we need to replace that
					// window's WndProc with our own. Ours will catch and menu command
					// that we implement, and pass the rest of the messages along.

					m_wndprocParent = (WNDPROC)::GetWindowLongPtr(hwnd, GWLP_WNDPROC);
					::SetWindowLongPtr(hwnd, GWLP_WNDPROC, (ULONG_PTR)(WNDPROC)&MenuWndProc);
					m_pControl = this; // set a static member variable so the MenuWndProc can access it
					m_hwndParent = hwnd;
				}
				break;
			}
			hwnd = ::GetParent(hwnd);
		}

		m_fFirstPaint = TRUE;

		ListView_SetExtendedListViewStyle(m_list.m_hWnd, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

		m_strMessTitle.Empty();
		m_strMessText.Empty();

		m_fMouseCapturedForSplitter = FALSE;
		m_fTrackingSplitter = FALSE;
		::SetRect(&m_rectSplitter, 0, 0, 0, 0);
		m_iTreeRatio = 33;

		// Set the history state variables (including whether or not history is available,
		// based on the presence of the DCO).

#ifdef MSINFO_TEST_HISTORYFROMFILE
			m_fHistoryAvailable = TRUE;
#else
		//	m_fHistoryAvailable = (m_pDCO != NULL);
#endif
		m_pLastCurrentCategory = NULL;

		// Removing the Advanced/Basic view menu items (Whistler 207638). Should
		// always default to Advanced now.

		m_fAdvanced = TRUE; // was FALSE;

		m_fFindVisible = TRUE; // used to be FALSE, before we decided to show find on startup
		m_wndFindWhatLabel.Attach(GetDlgItem(IDC_FINDWHATLABEL));
		m_wndFindWhat.Attach(GetDlgItem(IDC_EDITFINDWHAT));
		m_wndSearchSelected.Attach(GetDlgItem(IDC_CHECKSEARCHSELECTED));
		m_wndSearchCategories.Attach(GetDlgItem(IDC_CHECKSEARCHCATSONLY));

		// We need to set the event mask for the rich edit control
		// so we get EN_CHANGE notifications.

		m_wndFindWhat.SendMessage(EM_SETEVENTMASK, 0, (LPARAM)ENM_CHANGE);
		m_wndFindWhat.SendMessage(EM_SETTEXTMODE, TM_PLAINTEXT, 0);

		m_wndStartFind.Attach(GetDlgItem(IDSTARTFIND));
		m_wndStopFind.Attach(GetDlgItem(IDSTOPFIND));
		m_wndFindNext.Attach(GetDlgItem(IDFINDNEXT));
		m_wndCancelFind.Attach(GetDlgItem(IDCANCELFIND));

		// The pairs (start & find next, stop & cancel find) need to be matched
		// in size. The heights should already be the same.

		CRect rectStart, rectNext, rectStop, rectCancel;

		m_wndStartFind.GetWindowRect(&rectStart);
		m_wndFindNext.GetWindowRect(&rectNext);
		m_wndStopFind.GetWindowRect(&rectStop);
		m_wndCancelFind.GetWindowRect(&rectCancel);

		if (rectStart.Width() > rectNext.Width())
			rectNext = rectStart;
		else
			rectStart = rectNext;

		if (rectStop.Width() > rectCancel.Width())
			rectCancel = rectStop;
		else
			rectStop = rectCancel;

		m_wndStartFind.MoveWindow(&rectStart);
		m_wndFindNext.MoveWindow(&rectNext);
		m_wndStopFind.MoveWindow(&rectStop);
		m_wndCancelFind.MoveWindow(&rectCancel);

		// Initialize the find function member variables.

		m_fInFind					= FALSE;
		m_fCancelFind				= FALSE;
		m_fFindNext					= FALSE;
		m_strFind					= CString(_T(""));
		m_pcatFind					= NULL;
		m_fSearchCatNamesOnly		= FALSE;
		m_fSearchSelectedCatOnly	= FALSE;

		// Show the appropriate find controls.

		ShowFindControls();
		UpdateFindControls();

		m_iCategoryColNumberLen = 0;

		// Parse the parameters out of the URL.

		m_strOpenFile		= _T("");
		m_strPrintFile		= _T("");
		m_strCategory		= _T("");
		m_strComputer		= _T("");
		m_strCategories		= _T("");
		m_fShowCategories	= FALSE;
		m_fShowPCH			= FALSE;

		CString strTemp;
		while (!strParams.IsEmpty())
		{
			while (strParams[0] == _T(','))
				strParams = strParams.Mid(1);

			strTemp = strParams.SpanExcluding(_T(",="));

			if (strTemp.CompareNoCase(CString(_T("pch"))) == 0)
			{
				m_fShowPCH = TRUE;
				strParams = strParams.Mid(strTemp.GetLength());
			}
			else if (strTemp.CompareNoCase(CString(_T("showcategories"))) == 0)
			{
				m_fShowCategories = TRUE;
				strParams = strParams.Mid(strTemp.GetLength());
			}
			else if (strTemp.CompareNoCase(CString(_T("open"))) == 0)
			{
				strParams = strParams.Mid(strTemp.GetLength());
				if (strParams[0] == _T('='))
					strParams = strParams.Mid(1);

				m_strOpenFile = strParams.SpanExcluding(_T(","));
				strParams = strParams.Mid(m_strOpenFile.GetLength());
			}
			else if (strTemp.CompareNoCase(CString(_T("print"))) == 0)
			{
				strParams = strParams.Mid(strTemp.GetLength());
				if (strParams[0] == _T('='))
					strParams = strParams.Mid(1);

				m_strPrintFile = strParams.SpanExcluding(_T(","));
				strParams = strParams.Mid(m_strPrintFile.GetLength());
			}
			else if (strTemp.CompareNoCase(CString(_T("computer"))) == 0)
			{
				strParams = strParams.Mid(strTemp.GetLength());
				if (strParams[0] == _T('='))
					strParams = strParams.Mid(1);

				m_strComputer = strParams.SpanExcluding(_T(","));
				strParams = strParams.Mid(m_strComputer.GetLength());
			}
			else if (strTemp.CompareNoCase(CString(_T("category"))) == 0)
			{
				strParams = strParams.Mid(strTemp.GetLength());
				if (strParams[0] == _T('='))
					strParams = strParams.Mid(1);

				m_strCategory = strParams.SpanExcluding(_T(","));
				strParams = strParams.Mid(m_strCategory.GetLength());
			}
			else if (strTemp.CompareNoCase(CString(_T("categories"))) == 0)
			{
				strParams = strParams.Mid(strTemp.GetLength());
				if (strParams[0] == _T('='))
					strParams = strParams.Mid(1);

				m_strCategories = strParams.SpanExcluding(_T(","));
				strParams = strParams.Mid(m_strCategories.GetLength());
			}
			else
				strParams = strParams.Mid(strTemp.GetLength());
		}

		// Initialize the data sources.

		m_pLiveData = NULL;
		CLiveDataSource * pLiveData = new CLiveDataSource;
		if (pLiveData)
		{
			HRESULT hr = pLiveData->Create(_T(""), m_hWnd, m_strCategories);	// create a data source for this machine
			if (FAILED(hr))
			{
				// bad news, report an error
				delete pLiveData;
			}
			else
				m_pLiveData = pLiveData;
		}
		else
		{
			// bad news - no memory
		}

		m_pFileData = NULL;
		m_pCategory = NULL;

		// Load the initial tool set.

		LoadGlobalToolset(m_mapIDToTool);
		UpdateToolsMenu();

		//a-sanka 03/29/01 Moved here before any model MessageBox. 
		//v-stlowe 2/23/01 synchronization for put_DCO_IUnknown
		SetEvent(m_evtControlInit);

		// Handle the command line parameters.

		if (!m_strPrintFile.IsEmpty())
			m_strOpenFile = m_strPrintFile;

		HRESULT hrOpen = E_FAIL;
		if (!m_strOpenFile.IsEmpty())
		{
			LPCTSTR	szBuffer = m_strOpenFile;
			int		nFileExtension = _tcsclen(szBuffer) - 1;

			while (nFileExtension >= 0 && szBuffer[nFileExtension] != _T('.'))
				nFileExtension -= 1;

			if (nFileExtension >= 0)
				hrOpen = OpenMSInfoFile(szBuffer, nFileExtension + 1);
		}

		// Check to see if we should initially display a file as we open. Also look up whether
		// the user was showing advanced data last time.
		//
		// This code is outdated - removing it (bug 577659),
		//	
		//	HKEY hkey;
		//	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools\\MSInfo"), 0, KEY_ALL_ACCESS, &hkey))
		//	{
		//		TCHAR szBuffer[MAX_PATH];
		//		DWORD dwType, dwSize = MAX_PATH * sizeof(TCHAR);
		//
		//		if (ERROR_SUCCESS == RegQueryValueEx(hkey, _T("openfile"), NULL, &dwType, (LPBYTE)szBuffer, &dwSize))
		//			if (dwType == REG_SZ)
		//			{
		//				RegDeleteValue(hkey, _T("openfile"));
		//
		//				int nFileExtension = _tcsclen(szBuffer) - 1;
		//
		//				while (nFileExtension >= 0 && szBuffer[nFileExtension] != _T('.'))
		//					nFileExtension -= 1;
		//
		//				if (nFileExtension >= 0)
		//					hrOpen = OpenMSInfoFile(szBuffer, nFileExtension + 1);
		//			}
		//
		//		// Removing the Advanced/Basic view menu items (Whistler 207638)
		//		//
		//		// dwSize = MAX_PATH * sizeof(TCHAR);
		//		// if (ERROR_SUCCESS == RegQueryValueEx(hkey, _T("advanced"), NULL, &dwType, (LPBYTE)szBuffer, &dwSize))
		//		// 	if (dwType == REG_SZ && szBuffer[0] == _T('1'))
		//		//		m_fAdvanced = TRUE;
		//
		//		RegCloseKey(hkey);
		//	}

		if (FAILED(hrOpen) && m_pLiveData)
			SelectDataSource(m_pLiveData);


		if (FAILED(hrOpen) && m_pLiveData)
			SelectDataSource(m_pLiveData);

		if (!m_strPrintFile.IsEmpty())
			DoPrint(TRUE);

		if (!m_strComputer.IsEmpty())
			DoRemote(m_strComputer);

		if (!m_strCategory.IsEmpty() && m_pCurrData)
		{
			HTREEITEM hti = m_pCurrData->GetNodeByName(m_strCategory);
			if (hti != NULL)
			{
				TreeView_EnsureVisible(m_tree.m_hWnd, hti);
				TreeView_SelectItem(m_tree.m_hWnd, hti);
			}
		}

		if (m_fShowPCH && m_fHistoryAvailable && m_strMachine.IsEmpty())
		{
			DispatchCommand(ID_VIEW_HISTORY);
			SetMenuItems();
		}

		// Load the table of accelerator keys (used in our override of TranslateAccelerator).

		m_hAccTable = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_ACCELERATOR1));

		// Set the focus to the control, so we can process keystrokes immediately.

		::SetFocus(m_hWnd);
		
		return 0;
	}

	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (m_fDoNotRun)
			return 0;

		// Restore the window's wndproc.

		if (m_wndprocParent && m_hwndParent)
		{
			::SetWindowLongPtr(m_hwndParent, GWLP_WNDPROC, (ULONG_PTR)m_wndprocParent);
			m_wndprocParent = NULL;
			m_hwndParent = NULL;
		}

		// When the window is closing, make sure we don't send any more messages 
		// from the refresh thread.
		
		/* THIS HASN'T BEEN TESTED ENOUGH FOR THIS CHECKIN
		if (m_pCurrData)
		{
			CMSInfoCategory * pCat = m_pCurrData->GetRootCategory();

			if (pCat && pCat->GetDataSourceType() == LIVE_DATA)
			{
				CLiveDataSource * pLiveDataSource = (CLiveDataSource *) m_pCurrData;
				if (pLiveDataSource->m_pThread)
					pLiveDataSource->m_pThread->AbortMessaging();
			}
		}
		*/

		::SetCurrentDirectory(m_szCurrentDir);

		if (m_pLiveData)
		{
			if (m_pFileData == m_pLiveData)
			    m_pFileData = NULL;
   			delete m_pLiveData;
			m_pLiveData = NULL;
		}
		
		if (m_pFileData)
		{
			delete m_pFileData;
			m_pFileData = NULL;
		}

		RemoveToolset(m_mapIDToTool);

		// Save the complexity of the view to the registry (so we can default to
		// it next time).
		//
		// Removing the Advanced/Basic view menu items (Whistler 207638). Should
		// always default to Advanced now.

		// HKEY hkey;
		// if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools\\MSInfo"), 0, KEY_ALL_ACCESS, &hkey))
		// {
		// 	TCHAR szBuffer[] = _T("0");
		// 	
		// 	if (m_fAdvanced)
		// 		szBuffer[0] = _T('1');
		// 
		// 	RegSetValueEx(hkey, _T("advanced"), 0, REG_SZ, (LPBYTE)szBuffer, 2 * sizeof(TCHAR));
		// 	RegCloseKey(hkey);
		// }
   
		if (m_pDCO)
			m_pDCO->Abort();

		m_fDoNotRun = TRUE;
		return 0;
	}

	//=========================================================================
	// These functions process mouse movements, which we may respond to in
	// different ways. For instance, if the mouse is over the menu bar, then
	// we may want to highlight a menu. If the mouse is over the splitter,
	// we'll want to change the cursor into a resizer.
	//
	// This is complicated by the fact that we need to capture the mouse,
	// to make sure we know when it leaves so we can update appropriately.
	//=========================================================================

	LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (m_fDoNotRun)
			return 0;

		int xPos = LOWORD(lParam); int yPos = HIWORD(lParam);

		if (m_fTrackingSplitter)
			UpdateSplitterPosition(xPos, yPos);
		else
			CheckHover(xPos, yPos);

		return 0;
	}

	void CheckHover(int xPos, int yPos)
	{
		// Check to see if the mouse is hover over the splitter.

		if (::PtInRect(&m_rectSplitter, CPoint(xPos, yPos)))
		{
			if (!m_fMouseCapturedForSplitter)
			{
				SetCapture();
				m_fMouseCapturedForSplitter = TRUE;
			}

			::SetCursor(::LoadCursor(NULL, IDC_SIZEWE));
			return;
		}
		else if (m_fMouseCapturedForSplitter)
		{
			ReleaseCapture();
			m_fMouseCapturedForSplitter = FALSE;

			::SetCursor(::LoadCursor(NULL, IDC_ARROW));

			CheckHover(xPos, yPos); // give the other areas a chance
			return;
		}
	}

	//=========================================================================
	// These functions process mouse clicks and releases. This might entail
	// showing a menu, or resizing the panes using the splitter.
	//=========================================================================

	LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (m_fDoNotRun)
			return 0;

		int xPos = LOWORD(lParam); int yPos = HIWORD(lParam);

		SetFocus();
		CheckSplitterClick(xPos, yPos);
		return 0;
	}

	LRESULT OnLButtonUP(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (m_fDoNotRun)
			return 0;

		if (m_fTrackingSplitter)
			EndSplitterDrag();
		return 0;
	}

	//-------------------------------------------------------------------------
	// If the user clicked on the splitter (the area between the list view and
	// the tree view), start tracking the movement of it. Use the DrawFocusRect
	// API to give feedback.
	//-------------------------------------------------------------------------

	void CheckSplitterClick(int xPos, int yPos)
	{
		if (::PtInRect(&m_rectSplitter, CPoint(xPos, yPos)))
		{
			ASSERT(!m_fTrackingSplitter);
			m_fTrackingSplitter = TRUE;

			::CopyRect(&m_rectLastSplitter, &m_rectSplitter);
			DrawSplitter();
			m_cxOffset = xPos -  m_rectLastSplitter.left;
			ASSERT(m_cxOffset >= 0);
		}
	}

	//=========================================================================
	// Functions for handling the user interaction with the splitter control.
	// 
	// TBD - bug if you drag splitter and release button with the cursor over
	// a menu.
	//=========================================================================

	void DrawSplitter()
	{
		InvalidateRect(&m_rectLastSplitter, FALSE);
		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(&ps);
		::DrawFocusRect(hdc, &m_rectLastSplitter);
		EndPaint(&ps);
	}

	void UpdateSplitterPosition(int xPos, int yPos)
	{
		// If the user attempts to drag the splitter outside of the window, don't
		// allow it.

		RECT rectClient;
		GetClientRect(&rectClient);
		if (!::PtInRect(&rectClient, CPoint(xPos, yPos)))
			return;

		DrawSplitter();		// remove the current focus rect
		int cxDelta = xPos - (m_rectLastSplitter.left + m_cxOffset);
		m_rectLastSplitter.left += cxDelta;
		m_rectLastSplitter.right += cxDelta;
		DrawSplitter();
	}

	void EndSplitterDrag()
	{
		DrawSplitter();		// remove the focus rect

		// Compute the new tree and list rectangles based on the last splitter position.

		RECT rectTree, rectList;

		m_tree.GetWindowRect(&rectTree);
		m_list.GetWindowRect(&rectList);

		ScreenToClient(&rectTree);
		ScreenToClient(&rectList);

		// First, check to see if the coordinates are reversed (possibly on a bi-directional locale). The
		// first case is that standard, left to right case.

		if (rectTree.right > rectTree.left || (rectTree.right == rectTree.left && rectList.right > rectList.left))
		{
			rectTree.right = m_rectLastSplitter.left;
			rectList.left = m_rectLastSplitter.right;

			// Move the tree and list controls based on the new rects.

			m_tree.MoveWindow(rectTree.left, rectTree.top, rectTree.right - rectTree.left, rectTree.bottom - rectTree.top, TRUE);
			m_list.MoveWindow(rectList.left, rectList.top, rectList.right - rectList.left, rectList.bottom - rectList.top, TRUE);
		}
		else
		{
			// Here's the case where the coordinates are right to left.

			rectList.right = m_rectLastSplitter.right;
			rectTree.left = m_rectLastSplitter.left;

			// Move the tree and list controls based on the new rects.

			m_tree.MoveWindow(rectTree.right, rectTree.top, rectTree.left - rectTree.right, rectTree.bottom - rectTree.top, TRUE);
			m_list.MoveWindow(rectList.right, rectList.top, rectList.left - rectList.right, rectList.bottom - rectList.top, TRUE);
		}

		// If we're currently showing a category from a 4.10 NFO file, resize the OCX.

		CMSInfoCategory * pCategory = GetCurrentCategory();
		if (pCategory && pCategory->GetDataSourceType() == NFO_410)
		{
			CMSInfo4Category * p4Cat = (CMSInfo4Category*) pCategory;
			p4Cat->ResizeControl(this->GetOCXRect());
		}

		// If nothing data is showing and there is a message string, invalidate the window so
		// that it redraws based on the new rect.

		if (!m_list.IsWindowVisible() && (!m_strMessTitle.IsEmpty() || !m_strMessText.IsEmpty()))
		{
			RECT rectNewList;
			m_list.GetWindowRect(&rectNewList);
			ScreenToClient(&rectNewList);
			InvalidateRect(&rectNewList, TRUE);
		}

		// Figure the size ratio between the list view and tree view, and save it. Take into account
		// that the left coordinate might be greater than the right coordinate on a rect (if the
		// coordinates are from a RTL locale).

		RECT rectClient;
		GetClientRect(&rectClient);
		if (rectTree.right > rectTree.left)
			m_iTreeRatio = ((rectTree.right - rectTree.left) * 100) / (rectClient.right - rectClient.left);
		else if (rectTree.right < rectTree.left)
			m_iTreeRatio = ((rectTree.left - rectTree.right) * 100) / (rectClient.right - rectClient.left);
		else
			m_iTreeRatio = 100;

		// Update the splitter tracking variables.

		m_fTrackingSplitter = FALSE;
		::CopyRect(&m_rectSplitter, &m_rectLastSplitter);

		// Invalidate the splitter itself (so that it will repaint).

		InvalidateRect(&m_rectSplitter);

		// Release the mouse capture and restore the cursor.

		ReleaseCapture();
		m_fMouseCapturedForSplitter = FALSE;
		::SetCursor(::LoadCursor(NULL, IDC_ARROW));
	}

	//=========================================================================
	// Rendering functions, including handling the WM_PAINT message.
	//=========================================================================

	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		// We're having some redraw issues when brought back from a locked
		// system. It seems that even though the updated rect is the same
		// as the client rect, it doesn't include all the necessary regions
		// to repaint.

		RECT rectUpdate, rectClient;
		if (GetClientRect(&rectClient) && GetUpdateRect(&rectUpdate) && ::EqualRect(&rectClient, &rectUpdate))
			Invalidate(FALSE);

		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(&ps);
		
		GetClientRect(&rectClient);
		::SetTextColor(hdc, ::GetSysColor(COLOR_BTNFACE));

		if (m_fFirstPaint)
		{
			m_hbrBackground = CreateSolidBrush(::GetSysColor(COLOR_BTNFACE /* COLOR_MENU */));
			if (!m_fDoNotRun)
				SetMenuItems();
			m_fFirstPaint = FALSE;
		}

		FillRect(hdc, &rectClient, m_hbrBackground);

		if (m_fDoNotRun)
		{
			if (m_strDoNotRun.IsEmpty())
			{
				::AfxSetResourceHandle(_Module.GetResourceInstance());
				m_strDoNotRun.LoadString(IDS_ONLYINHELPCTR);
			}

			CDC dc;
			dc.Attach(hdc);
			dc.SetBkMode(TRANSPARENT);
			dc.DrawText(m_strDoNotRun, &rectClient, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
			dc.Detach();
			EndPaint(&ps);
			return 0;
		}

		if (!m_list.IsWindowVisible())
		{
			RECT rectList;
			m_list.GetWindowRect(&rectList);
			ScreenToClient(&rectList);

			// If the list window is hidden, we should probably be displaying a message. First,
			// draw the 3D rectangle.

			CDC dc;
			dc.Attach(hdc);
			dc.Draw3dRect(&rectList, ::GetSysColor(COLOR_3DSHADOW), ::GetSysColor(COLOR_3DHILIGHT));

			// For some reason, DrawText wants left < right (even on RTL systems, like ARA).

			if (rectList.left > rectList.right)
			{
				int iSwap = rectList.left;
				rectList.left = rectList.right;
				rectList.right = iSwap;
			}

			// Next, if there is text, draw it.

			if (!m_strMessTitle.IsEmpty() || !m_strMessText.IsEmpty())
			{
				::InflateRect(&rectList, -10, -10);
				CGdiObject * pFontOld = dc.SelectStockObject(DEFAULT_GUI_FONT);
				COLORREF crTextOld = dc.SetTextColor(::GetSysColor(COLOR_MENUTEXT));
				int nBkModeOld = dc.SetBkMode(TRANSPARENT);

				if (!m_strMessTitle.IsEmpty())
				{
					// We want to make a bigger version of the same font. Select the font
					// again (to get a pointer to the original font). Get it's LOGFONT,
					// make it bigger, and create a new font for selection.

					CFont * pNormalFont = (CFont *) dc.SelectStockObject(DEFAULT_GUI_FONT);
					LOGFONT lf; 
					pNormalFont->GetLogFont(&lf); 
					lf.lfHeight = (lf.lfHeight * 3) / 2;
					lf.lfWeight = FW_BOLD;
					CFont fontDoubleSize;
					fontDoubleSize.CreateFontIndirect(&lf);
					dc.SelectObject(&fontDoubleSize);
					RECT rectTemp;
					::CopyRect(&rectTemp, &rectList);
					int iHeight = dc.DrawText(m_strMessTitle, &rectTemp, DT_LEFT | DT_TOP | DT_WORDBREAK | DT_CALCRECT);
					dc.DrawText(m_strMessTitle, &rectList, DT_LEFT | DT_TOP | DT_WORDBREAK);
					rectList.top += iHeight + 5;
					dc.SelectObject(pNormalFont);
				}

				if (!m_strMessText.IsEmpty())
				{
					dc.DrawText(m_strMessText, &rectList, DT_LEFT | DT_TOP | DT_WORDBREAK);
				}

				dc.SelectObject(pFontOld);
				dc.SetTextColor(crTextOld);
				dc.SetBkMode(nBkModeOld);
			}

			dc.Detach();
		}

		EndPaint(&ps);
		return 0;
	}

	LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		m_fFirstPaint = TRUE;
		Invalidate();
		UpdateWindow();
		return 0;
	}

	LRESULT OnDialogColor(UINT, WPARAM w, LPARAM, BOOL&)
	{
		HDC dc = (HDC) w;

		LOGBRUSH lb;
		::GetObject(m_hbrBackground, sizeof(lb), (void*)&lb);
		::SetBkColor(dc, lb.lbColor);
		::SetTextColor(dc, ::GetSysColor(COLOR_BTNTEXT));
		::SetBkMode(dc, TRANSPARENT);

		return (LRESULT)m_hbrBackground;
	}

	//=========================================================================
	// Handle the WM_SIZE message. This involves a bit of cleverness to avoid
	// ugly updates: if the user has moved the splitter bar, preserve
	// the ratio of sizes to the two windows.
	//=========================================================================

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (m_fDoNotRun)
		{
			RECT rectClient;
			GetClientRect(&rectClient);
			InvalidateRect(&rectClient, FALSE);
			return 0;
		}

		LayoutControl();
		return 0;
	}

	void LayoutControl()
	{
		const int cBorder = 3;
		const int cxSplitter = 3;

		RECT rectClient;
		GetClientRect(&rectClient);

		int cyMenuHeight = cBorder;
		int cyFindControlHeight = PositionFindControls();

		if (m_history.IsWindowVisible())
		{
			CRect rectHistory, rectHistorylabel;
			m_history.GetWindowRect(&rectHistory);
			m_historylabel.GetWindowRect(&rectHistorylabel);
			rectHistory.OffsetRect(rectClient.right - cBorder - rectHistory.right, rectClient.top + cBorder - rectHistory.top);
			rectHistorylabel.OffsetRect(rectHistory.left - cBorder / 2 - rectHistorylabel.right, rectClient.top + cBorder + ((rectHistory.Height() - rectHistorylabel.Height()) / 2) - rectHistorylabel.top);

			if (rectHistorylabel.left < 0) // TBD
			{
				rectHistory += CPoint(0 - rectHistorylabel.left, 0);
				rectHistorylabel += CPoint(0 - rectHistorylabel.left, 0);
			}

			m_history.MoveWindow(&rectHistory);
			m_historylabel.MoveWindow(&rectHistorylabel);

			if (rectHistory.Height() + cBorder * 2 > cyMenuHeight)
			{
				cyMenuHeight = rectHistory.Height() + cBorder * 2 - 1;
				CPoint ptMenu(cBorder, (cyMenuHeight - 0) / 2 + 2);
			}
		}
		else
		{
			CPoint ptMenu(5, 5);
		}

		RECT rectTree;
		::CopyRect(&rectTree, &rectClient);
		rectTree.left += cBorder;
		rectTree.top += cyMenuHeight + cxSplitter / 2;
		rectTree.bottom -= ((cyFindControlHeight) ? cyFindControlHeight : cBorder);
		rectTree.right = ((rectClient.right - rectClient.left) * m_iTreeRatio) / 100 + rectClient.left;
		m_tree.MoveWindow(rectTree.left, rectTree.top, rectTree.right - rectTree.left, rectTree.bottom - rectTree.top, FALSE);

		RECT rectList;
		::CopyRect(&rectList, &rectClient);
		rectList.left = rectTree.right + cxSplitter;
		rectList.top  = rectTree.top;
		rectList.bottom = rectTree.bottom;
		rectList.right -= cBorder;
		m_list.MoveWindow(rectList.left, rectList.top, rectList.right - rectList.left, rectList.bottom - rectList.top, FALSE);

		// Get the rectangle for the splitter, and save it.

		m_tree.GetWindowRect(&rectTree);
		m_list.GetWindowRect(&rectList);

		ScreenToClient(&rectTree);
		ScreenToClient(&rectList);

		// Check whether the coordinate system is LTR (eg. English) or RTL.

		if (rectTree.left < rectTree.right || (rectTree.left == rectTree.right && rectList.left < rectList.right))
		{
			// Nominal (LTR) case.

			int cxLeft = (rectTree.right < rectList.left) ? rectTree.right : rectList.left - cxSplitter;
			::SetRect(&m_rectSplitter, cxLeft, rectTree.top, cxLeft + cxSplitter, rectTree.bottom);
		}
		else
		{
			// Special case for RTL locales.

			int cxLeft = (rectTree.left < rectList.right) ? rectList.right : rectTree.left - cxSplitter;
			::SetRect(&m_rectSplitter, cxLeft - cxSplitter, rectTree.top, cxLeft, rectTree.bottom);
		}
		
		CMSInfoCategory * pCategory = GetCurrentCategory();
		if (pCategory && pCategory->GetDataSourceType() == NFO_410)
		{
			CMSInfo4Category * p4Cat = (CMSInfo4Category*) pCategory;
			p4Cat->ResizeControl(this->GetOCXRect());
		}

		InvalidateRect(&rectClient, FALSE);
	}

	//=========================================================================
	// Respond to the user clicking the tree or list.
	//=========================================================================

	LRESULT OnSelChangedTree(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		if (m_fDoNotRun)
			return 0;

		LPNMTREEVIEW lpnmtv = (LPNMTREEVIEW) pnmh;
		if (lpnmtv)
		{
			CMSInfoCategory * pCategory = (CMSInfoCategory *) lpnmtv->itemNew.lParam;
			ASSERT(pCategory);
			if (pCategory)
			{
				CancelFind();
				SelectCategory(pCategory);
			}
		}

		return 0;
	}

	LRESULT OnColumnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		if (m_fDoNotRun)
			return 0;

		LPNMLISTVIEW pnmv = (LPNMLISTVIEW) pnmh; 
		CMSInfoCategory * pCategory = GetCurrentCategory();

		if (pnmv && pCategory)
		{
			BOOL fSorts, fLexical;

			// Get the internal column number (in BASIC view, this might be different
			// than the column indicated.

			int iCol;
			if (m_fAdvanced)
				iCol = pnmv->iSubItem;
			else
			{
				ASSERT(pnmv->iSubItem < m_iCategoryColNumberLen);
				if (pnmv->iSubItem >= m_iCategoryColNumberLen)
					return 0;
				iCol = m_aiCategoryColNumber[pnmv->iSubItem];
			}

			if (pCategory->GetColumnInfo(iCol, NULL, NULL, &fSorts, &fLexical))
			{
				if (!fSorts)
					return 0;

				if (iCol == pCategory->m_iSortColumn)
					pCategory->m_fSortAscending = !pCategory->m_fSortAscending;
				else
					pCategory->m_fSortAscending = TRUE;

				pCategory->m_iSortColumn = iCol;
				pCategory->m_fSortLexical = fLexical;

				CLiveDataSource * pLiveDataSource = NULL;
				if (pCategory->GetDataSourceType() == LIVE_DATA)
					pLiveDataSource = (CLiveDataSource *) m_pCurrData;
				
				if (pLiveDataSource)
					pLiveDataSource->LockData();

				ListView_SortItems(m_list.m_hWnd, (PFNLVCOMPARE) ListSortFunc, (LPARAM) pCategory);

				if (pLiveDataSource)
					pLiveDataSource->UnlockData();
			}
		}

		return 0;
	}

	LRESULT OnListItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		if (m_fDoNotRun)
			return 0;

		SetMenuItems();
		return 0;
	}

	//-------------------------------------------------------------------------
	// Don't allow the user to collapse the root node of the tree.
	//-------------------------------------------------------------------------

	LRESULT OnItemExpandingTree(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		LPNMTREEVIEW lpnmtv = (LPNMTREEVIEW) pnmh;
		if (lpnmtv && (lpnmtv->action & TVE_COLLAPSE))
		{
			CMSInfoCategory * pCategory = (CMSInfoCategory *) lpnmtv->itemNew.lParam;
			if (pCategory && pCategory->GetParent() == NULL)
				return 1;
		}

		return 0;
	}

	//=========================================================================
	// Called when we're being notified by the worker thread that a refresh
	// is complete and data should be displayed.
	//
	// TBD - check whether is category is still selected
	//=========================================================================

	LRESULT OnMSInfoDataReady(UINT /* uMsg */, WPARAM /* wParam */, LPARAM lParam, BOOL& /* bHandled */)
	{
		if (m_fDoNotRun)
			return 0;

		ASSERT(lParam);
		if (lParam == 0)
			return 0;

		if (m_fInFind && lParam == (LPARAM)m_pcatFind)
		{
			FindRefreshComplete();
			return 0;
		}

		HTREEITEM hti = TreeView_GetSelection(m_tree.m_hWnd);
		if (hti)
		{
			TVITEM tvi;
			tvi.mask = TVIF_PARAM;
			tvi.hItem = hti;

			if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
				if (tvi.lParam == lParam)
				{
					CMSInfoCategory * pCategory = (CMSInfoCategory *) lParam;
					ASSERT(pCategory->GetDataSourceType() == LIVE_DATA);
					SelectCategory(pCategory, TRUE);
				}
		}

		return 0;
	}

	//=========================================================================
	// Functions for managing the list view and the tree view. Note - the
	// dwItem can only be set for the row (when iCol == 0).
	//=========================================================================

	void ListInsertItem(int iRow, int iCol, LPCTSTR szItem, DWORD dwItem)
	{
		LVITEM lvi;

		lvi.mask = LVIF_TEXT | ((iCol == 0) ? LVIF_PARAM : 0);
		lvi.iItem = iRow;
		lvi.iSubItem = iCol;
		lvi.pszText = (LPTSTR) szItem;
		lvi.lParam = (LPARAM) dwItem;

		if (iCol == 0)
			ListView_InsertItem(m_list.m_hWnd, &lvi);
		else
			ListView_SetItem(m_list.m_hWnd, &lvi);
	}

	void ListInsertColumn(int iCol, int cxWidth, LPCTSTR szCaption)
	{
		LVCOLUMN lvc;

		lvc.mask = LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
		lvc.cx = cxWidth;
		lvc.pszText = (LPTSTR) szCaption;
		lvc.iOrder = iCol;

		ListView_InsertColumn(m_list.m_hWnd, iCol, &lvc);
	}

	void ListClearItems()
	{
		ListView_DeleteAllItems(m_list.m_hWnd);
	}

	void ListClearColumns()
	{
		while (ListView_DeleteColumn(m_list.m_hWnd, 0));
	}

	void TreeClearItems()
	{
		TreeView_DeleteAllItems(m_tree.m_hWnd);
	}

	HTREEITEM TreeInsertItem(HTREEITEM hParent, HTREEITEM hInsertAfter, LPTSTR szName, LPARAM lParam)
	{
		TVINSERTSTRUCT tvis;

		tvis.hParent		= hParent;
		tvis.hInsertAfter	= hInsertAfter;
		tvis.item.mask		= TVIF_TEXT | TVIF_PARAM;
		tvis.item.pszText	= szName;
		tvis.item.lParam	= lParam;

		return TreeView_InsertItem(m_tree.m_hWnd, &tvis);
	}

	void BuildTree(HTREEITEM htiParent, HTREEITEM htiPrevious, CMSInfoCategory * pCategory)
	{
		ASSERT(pCategory);

		CString strCaption(_T(""));

		// If the user specified the /showcategories flag, we should show the name of
		// each category in the tree (which is unlocalized). Otherwise show the caption.

		if (!m_fShowCategories)
			pCategory->GetNames(&strCaption, NULL);
		else
			pCategory->GetNames(NULL, &strCaption);

		if (pCategory->GetDataSourceType() == LIVE_DATA && htiParent == TVI_ROOT && !m_strMachine.IsEmpty() && pCategory != &catHistorySystemSummary)
		{
			CString strMachine(m_strMachine);
			strMachine.MakeLower();
			strMachine.TrimLeft(_T("\\"));

			// Changed this to use a Format() with a string resource, instead of
			// appending the machine name to the string. This should solve some
			// problems with oddities on RTL languages.

			strCaption.Format(IDS_SYSTEMSUMMARYMACHINENAME, strMachine);
		}

		HTREEITEM htiCategory = TreeInsertItem(htiParent, htiPrevious, (LPTSTR)(LPCTSTR)strCaption, (LPARAM)pCategory);
		pCategory->SetHTREEITEM(htiCategory);
		for (CMSInfoCategory * pChild = pCategory->GetFirstChild(); pChild; pChild = pChild->GetNextSibling())
			BuildTree(htiCategory, TVI_LAST, pChild);
	}

	void RefillListView(BOOL fRefreshDataOnly = TRUE)
	{
		HTREEITEM hti = TreeView_GetSelection(m_tree.m_hWnd);
		if (hti)
		{
			TVITEM tvi;
			tvi.mask = TVIF_PARAM;
			tvi.hItem = hti;

			if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
				if (tvi.lParam)
				{
					CMSInfoCategory * pCategory = (CMSInfoCategory *) tvi.lParam;
					SelectCategory(pCategory, fRefreshDataOnly);
				}
		}
	}

	//=========================================================================
	// If the user presses a key, we should check to see if it's something
	// we need to deal with (accelerators, ALT-?, etc.).
	//=========================================================================

	HACCEL m_hAccTable;
	STDMETHODIMP TranslateAccelerator(MSG * pMsg)
	{
		if (m_hwndParent && m_hAccTable && (GetAsyncKeyState(VK_CONTROL) < 0 || (WORD)pMsg->wParam == VK_F1) && ::TranslateAccelerator(m_hwndParent, m_hAccTable, pMsg))
			return S_OK;

		if (m_fFindVisible && (WORD)pMsg->wParam == VK_RETURN && pMsg->message != WM_KEYUP)
		{
			// If the focus is on the stop find button, do so.

			if (GetFocus() == m_wndStopFind.m_hWnd || GetFocus() == m_wndCancelFind.m_hWnd)
			{
				BOOL bHandled;
				OnStopFind(0, 0, NULL, bHandled);
				return S_OK;
			}

			// Otherwise, if the find or find next button is showing, execute
			// that command.

			if (m_wndStartFind.IsWindowEnabled() || m_wndFindNext.IsWindowEnabled())
			{
				BOOL bHandled;
				OnFind(0, 0, NULL, bHandled);
				return S_OK;
			}
		}

		return IOleInPlaceActiveObjectImpl<CMSInfo>::TranslateAccelerator(pMsg);
	}

	void MSInfoMessageBox(UINT uiMessageID, UINT uiTitleID = IDS_SYSTEMINFO)
	{
		CString strCaption, strMessage;

		::AfxSetResourceHandle(_Module.GetResourceInstance());
		strCaption.LoadString(uiTitleID);
		strMessage.LoadString(uiMessageID);
		MessageBox(strMessage, strCaption);
	}

	void MSInfoMessageBox(const CString & strMessage, UINT uiTitleID = IDS_SYSTEMINFO)
	{
		CString strCaption;

		::AfxSetResourceHandle(_Module.GetResourceInstance());
		strCaption.LoadString(uiTitleID);
		MessageBox(strMessage, strCaption);
	}

	//=========================================================================
	// Functions implemented in the CPP file.
	//=========================================================================
				
	BOOL				DispatchCommand(int iCommand);
	void				SelectDataSource(CDataSource * pDataSource);
	void				SelectCategory(CMSInfoCategory * pCategory, BOOL fRefreshDataOnly = FALSE);
	void				MSInfoRefresh();
	void				OpenNFO();
	void				SaveNFO();
	void				Export();
	void				CloseFile();
    void				SaveMSInfoFile(LPCTSTR szFilename, DWORD dwFilterIndex = 1);//new format by default
	HRESULT				OpenMSInfoFile(LPCTSTR szFilename, int nFileExtension);
	void				ExportFile(LPCTSTR szFilename, int nFileExtension);
	CMSInfoCategory *	GetCurrentCategory();
	void				SetMenuItems();
	void				SetMessage(const CString & strTitle, const CString & strMessage = CString(_T("")), BOOL fRedraw = FALSE);
	void				SetMessage(UINT uiTitle, UINT uiMessage = 0, BOOL fRedraw = FALSE);
	void				EditCopy();
	void				EditSelectAll();
	void				DoPrint(BOOL fNoUI = FALSE);
	void				UpdateToolsMenu();
	CRect				GetOCXRect();
	void				CancelFind();
	LRESULT				OnStopFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	void				UpdateFindControls();
	LRESULT				OnChangeFindWhat(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT				OnFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	void				FindRefreshComplete();
	BOOL				FindInCurrentCategory();
	void				ShowFindControls();
	int					PositionFindControls();
	void				ShowRemoteDialog();
	void				DoRemote(LPCTSTR szMachine);
	void				SaveXML(const CString & strFileName);
	void        GetMachineName(LPTSTR lpBuffer, LPDWORD lpnSize);
	void				RefreshData(CLiveDataSource * pSource, CMSInfoLiveCategory * pLiveCategory);

	//-------------------------------------------------------------------------
	// Fill our combo box with the available history deltas.
	//-------------------------------------------------------------------------

	void FillHistoryCombo()
	{
		m_history.SendMessage(CB_RESETCONTENT, 0, 0);

		CMSInfoCategory * pCategory = GetCurrentCategory();
		if (pCategory == NULL || (pCategory->GetDataSourceType() != LIVE_DATA && pCategory->GetDataSourceType() != XML_SNAPSHOT))
			return;

		CLiveDataSource *	pLiveSource = (CLiveDataSource *) m_pCurrData;
		CStringList			strlistDeltas;
		CString				strItem;
		CDC					dc;
		CSize				size;
		int					cxMaxWidth = 0;

		HDC hdc = GetDC();
		dc.Attach(hdc);
		dc.SelectObject(CFont::FromHandle((HFONT)m_history.SendMessage(WM_GETFONT, 0, 0)));

		if (pLiveSource->GetDeltaList(&strlistDeltas))
			while (!strlistDeltas.IsEmpty())
			{
				strItem = strlistDeltas.RemoveHead();
				m_history.SendMessage(CB_INSERTSTRING, -1, (LPARAM)(LPCTSTR)strItem);

				size = dc.GetTextExtent(strItem);
				if (size.cx > cxMaxWidth)
					cxMaxWidth = size.cx;
			}
		//else
	//TD: what if no history is available?
		CRect rectClient, rectHistory;
		GetClientRect(&rectClient);
		m_history.GetWindowRect(&rectHistory);
		if (cxMaxWidth > rectHistory.Width() && cxMaxWidth < rectClient.Width())
		{
			rectHistory.InflateRect((cxMaxWidth - (rectHistory.Width() - GetSystemMetrics(SM_CXHSCROLL))) / 2 + 5, 0);
			m_history.MoveWindow(&rectHistory);
			LayoutControl();
		}

		dc.Detach();
		ReleaseDC(hdc);
	}

	//-------------------------------------------------------------------------
	// If the user selects a history delta to view, we need to mark all of the
	// categories as unrefreshed (so the new data will be generated).
	//-------------------------------------------------------------------------

	LRESULT OnHistorySelection(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		int iSelection = (int)m_history.SendMessage(CB_GETCURSEL, 0, 0);
#ifdef A_STEPHL
	/*	CString strMSG;
		strMSG.Format("iSelection= %d",iSelection);
		::MessageBox(NULL,strMSG,"",MB_OK);*/
#endif
		if (iSelection == CB_ERR)
		{

			return 0;
		}
		ChangeHistoryView(iSelection);
		return 0;
	}

	void ChangeHistoryView(int iIndex)
	{
		CMSInfoCategory * pCategory = GetCurrentCategory();
		if (pCategory == NULL)
		{
			ASSERT(FALSE && "NULL pCategory");
			return;
		}
		else if (pCategory->GetDataSourceType() == LIVE_DATA || pCategory->GetDataSourceType() == XML_SNAPSHOT)
		{
			pCategory->ResetCategory();
			if (((CMSInfoHistoryCategory*) pCategory)->m_iDeltaIndex == iIndex)
			{
				// return;
			}
		
			CLiveDataSource * pLiveSource = (CLiveDataSource *) m_pCurrData;

			if (pLiveSource->ShowDeltas(iIndex))
			{
				SetMessage(IDS_REFRESHHISTORYMESSAGE, 0, TRUE);
				MSInfoRefresh();
#ifdef A_STEPHL
			/*	CString strMSG;
				strMSG.Format("niIndex= %d",iIndex);
				::MessageBox(NULL,strMSG,"",MB_OK);*/
#endif
			}
			else
			{
				// Clear the existing categories in the tree.

				TreeClearItems();

				// Load the contents of the tree from the data source.

				CMSInfoCategory * pRoot = m_pCurrData->GetRootCategory();
				if (pRoot)
				{
					BuildTree(TVI_ROOT, TVI_LAST, pRoot);
					TreeView_Expand(m_tree.m_hWnd, TreeView_GetRoot(m_tree.m_hWnd), TVE_EXPAND);
					TreeView_SelectItem(m_tree.m_hWnd, TreeView_GetRoot(m_tree.m_hWnd));
				}
			}
		}
		else
		{
			ASSERT(FALSE && "shouldn't be showing history dropdown with this data source");
			return;

		}
	}

	//-------------------------------------------------------------------------
	// If the user sets the focus to the list, and there is no previously
	// selected item, then select the first item in the list (so the user can
	// see the focus).
	//-------------------------------------------------------------------------

	LRESULT OnSetFocusList(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		if (ListView_GetSelectedCount(m_list.m_hWnd) == 0)
			ListView_SetItemState(m_list.m_hWnd, 0, LVIS_SELECTED, LVIS_SELECTED);

		return 0;
	}

	//-------------------------------------------------------------------------
	// If the hovers on a cell in the list view, show the contents
	// of that cell as an infotip. This is helpful for extremely long items.
	//-------------------------------------------------------------------------

	LRESULT OnInfoTipList(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		TCHAR szBuf[MAX_PATH * 3] = _T("");
		LPNMLVGETINFOTIP pGetInfoTip = (LPNMLVGETINFOTIP)pnmh;
		
		if(NULL != pGetInfoTip)
		{
			ListView_GetItemText(m_list.m_hWnd, pGetInfoTip->iItem, pGetInfoTip->iSubItem, szBuf, MAX_PATH * 3);
			pGetInfoTip->cchTextMax = _tcslen(szBuf);
			pGetInfoTip->pszText = szBuf;
		}
		return 0;
	}

	//-------------------------------------------------------------------------
	// Is the user right clicks on the tree, we should show a context menu
	// with the "What's This?" item in it. If the user selects the menu
	// item, we should launch help with the topic for the category.
	//-------------------------------------------------------------------------

	LRESULT OnRClickTree(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		// Determine if the right click was on a category in the tree view.

		CMSInfoCategory * pCategory = NULL;

		DWORD dwPoint = GetMessagePos();
		TVHITTESTINFO tvhti;
		tvhti.pt.x = ((int)(short)LOWORD(dwPoint));
		tvhti.pt.y = ((int)(short)HIWORD(dwPoint));
		::ScreenToClient(m_tree.m_hWnd, &tvhti.pt);
		
		// If it's on a tree view item, get the category pointer.

		HTREEITEM hti = TreeView_HitTest(m_tree.m_hWnd, &tvhti);
		if (hti != NULL)
		{
			TVITEM tvi;
			tvi.mask = TVIF_PARAM;
			tvi.hItem = hti;

			if (TreeView_GetItem(m_tree.m_hWnd, &tvi) && tvi.lParam)
				pCategory = (CMSInfoCategory *) tvi.lParam;
		}

		if (pCategory != NULL)
		{
			const UINT uFlags = TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD | TPM_RIGHTBUTTON;

			::AfxSetResourceHandle(_Module.GetResourceInstance());
			HMENU hmenu = ::LoadMenu(_Module.GetResourceInstance(), _T("IDR_WHAT_IS_THIS_MENU"));
			HMENU hmenuSub = ::GetSubMenu(hmenu, 0);

			if (hmenuSub)
				if (::TrackPopupMenu(hmenuSub, uFlags, ((int)(short)LOWORD(dwPoint)), ((int)(short)HIWORD(dwPoint)), 0, m_hWnd, NULL))
					ShowCategoryHelp(pCategory);
			
			::DestroyMenu(hmenu);
		}

		return 0;
	}

    LRESULT OnClickedSearchSelected(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (IsDlgButtonChecked(IDC_CHECKSEARCHSELECTED) == BST_CHECKED)
        	CheckDlgButton(IDC_CHECKSEARCHCATSONLY, BST_UNCHECKED);
		return 0;
	}
    
    LRESULT OnClickedSearchCatsOnly(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (IsDlgButtonChecked(IDC_CHECKSEARCHCATSONLY) == BST_CHECKED)
        	CheckDlgButton(IDC_CHECKSEARCHSELECTED, BST_UNCHECKED);
		return 0;
	}

	//-------------------------------------------------------------------------
	//Display the help file with the topic using HelpCtr.exe
	//-------------------------------------------------------------------------

	void ShowHSCHelp(CString strTopic)
	{
		TCHAR szCommandLine[2000];
		PROCESS_INFORMATION ProcessInfo;
		STARTUPINFO StartUpInfo;

		TCHAR szWinDir[2048];
		GetWindowsDirectory(szWinDir, 2048);

		ZeroMemory((LPVOID)&StartUpInfo, sizeof(STARTUPINFO));
		StartUpInfo.cb = sizeof(STARTUPINFO);    
		
		CString strCommandLine(szWinDir);
		strCommandLine = CString(_T("\"")) + strCommandLine;
		strCommandLine += _T("\\pchealth\\helpctr\\binaries\\helpctr.exe\" -FromStartHelp -url \"hcp:");
		strCommandLine += _T("//mk:@MSITStore:");

		// Try to find a localized help file to open (bug 463878). It should be
		// located in %windir%\help\mui\<LANGID>.

		TCHAR szHelpPath[MAX_PATH] = _T("");
		CString strLanguageIDPath;
		if (::ExpandEnvironmentStrings(_T("%SystemRoot%\\help\\mui"), szHelpPath, MAX_PATH))
		{
			LANGID langid = GetUserDefaultUILanguage();
			strLanguageIDPath.Format(_T("%s\\%04x\\msinfo32.chm"), szHelpPath, langid);

			if (!FileExists(strLanguageIDPath))
			{
				::ExpandEnvironmentStrings(_T("%windir%\\help\\msinfo32.chm"), szHelpPath, MAX_PATH);
				strLanguageIDPath = szHelpPath;
			}
		}
		strCommandLine += strLanguageIDPath;

		if (strTopic.IsEmpty())
		{
			strTopic = _T("msinfo_overview.htm");
		}
		strCommandLine += _T("::/");
		strCommandLine += strTopic;
		strCommandLine += _T("\"");

		// Replaces: wsprintf(szCommandLine,strCommandLine);
		::ZeroMemory(szCommandLine, sizeof(szCommandLine));
		_tcsncpy(szCommandLine, (LPCTSTR)strCommandLine, (sizeof(szCommandLine) / sizeof(TCHAR)) - 1);
		CreateProcess(NULL, szCommandLine,NULL,NULL,TRUE,CREATE_NEW_PROCESS_GROUP,NULL,&szWinDir[0],&StartUpInfo,&ProcessInfo);
	}



    //-------------------------------------------------------------------------
	// Display the help file with the topic for the specified category shown.
	// If the category doesn't have a topic, check its parent categories. If
	// There are no topics all the way to the root, just show the help without
	// a specific topic.
	//-------------------------------------------------------------------------



	void ShowCategoryHelp(CMSInfoCategory * pCategory)
	{

		
		
		CString strTopic(_T(""));

		while (pCategory != NULL && strTopic.IsEmpty())
		{
			strTopic = pCategory->GetHelpTopic();
			pCategory = pCategory->GetParent();
		}
		ShowHSCHelp(strTopic);
		
	}

	//-------------------------------------------------------------------------
	// If the user sets the focus to the edit control, we should turn on the
	// copy command in the menu.
	//-------------------------------------------------------------------------

	LRESULT OnSetFocusEditFindWhat(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (m_fDoNotRun)
			return 0;
		SetMenuItems();
		return 0;
	}

	LRESULT OnKillFocusEditFindWhat(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (m_fDoNotRun)
			return 0;
		SetMenuItems();
		return 0;
	}
};

#endif //__MSINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msinfo4category.h ===
// MSInfo4Category.h: interface for the CMSInfo4Category class.
//
//=============================================================================
// This include file contains definitions of structures and classes used to
// load and display MSInfo 4.x files, which are OLE Compound Document files.
// This code requires that the MSInfo 4.x ocxs (eyedog.ocx, msisys.ocx, and others)
// be registered on the system before the code will execute
//=============================================================================

#if !defined(AFX_MSINFO4CATEGORY_H__B47023B3_6038_4168_86A2_475C4986CEAF__INCLUDED_)
#define AFX_MSINFO4CATEGORY_H__B47023B3_6038_4168_86A2_475C4986CEAF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//structure used as a header in a 4.x NFO file to 
//indicate which ocx can serialize the stream
typedef struct
{
	char	szCLSID[40];
	char	szStreamName[12];
	char	szName[_MAX_PATH];
	char	szVersion[20];
	DWORD	dwSize;
} SAVED_CONTROL_INFO;

#include "msictrl.h"

class CMSInfo4Category : public CMSInfoCategory
{
    
public:

	BOOL IsDisplayableCategory();
	HRESULT RefreshAllForPrint(HWND hWnd, CRect rctList);
	HRESULT ShowControl(HWND hWnd, CRect rctList, BOOL fShow = TRUE);
	CMSInfo4Category();
	virtual ~CMSInfo4Category();
    HRESULT	CreateControl(HWND hWnd,CRect& rct);
    static HRESULT ReadMSI4NFO(CString strFileName/*HANDLE hFile*/,CMSInfo4Category** ppRootCat);
    static HRESULT RecurseLoad410Tree(CMSInfo4Category** ppRoot, CComPtr<IStream> pStream,CComPtr<IStorage> pStorage,CMapStringToString& mapStreams);
    HRESULT LoadFromStream(CComPtr<IStream> pStream,CComPtr<IStorage> pStorage);
    HRESULT	Refresh();
    BOOL GetColumnInfo(int iColumn, CString * pstrCaption, UINT * puiWidth, BOOL * pfSorts, BOOL * pfLexical)
    {
        Refresh();
        return TRUE;
    }
    CLSID GetClsid(){return m_clsid;};
    void static SetDataSource(CNFO4DataSource* pnfo4DataSource){s_pNfo4DataSource = pnfo4DataSource;};

	void ResizeControl(const CRect & rect)
	{
        CMSIControl * p4Ctrl = NULL;
		//CString strCLSID(m_bstrCLSID);
        if (CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(m_strCLSID, p4Ctrl) && p4Ctrl)
			p4Ctrl->MoveWindow(&rect);
	}
    virtual void Print(CMSInfoPrintHelper* pPrintHelper, BOOL bRecursive);
    static CNFO4DataSource* s_pNfo4DataSource;
protected:
	virtual BOOL SaveAsText(CMSInfoTextFile* pTxtFile, BOOL bRecursive);
    virtual void Print(HDC hDC, BOOL bRecursive,int nStartPage = 0, int nEndPage = 0);


    BOOL GetDISPID(IDispatch * pDispatch, LPOLESTR szMember, DISPID *pID);
    CString m_strStream; //used when creating the control from IStream
    CLSID	m_clsid;
	DWORD	m_dwView;
	//CComBSTR m_bstrCLSID;
public:
	CString m_strCLSID;
//a-kjaw
	static	BOOL	m_bIsControlInstalled;
//a-kjaw
protected:
    CComPtr<IStorage> m_pStorage;
    CComPtr<IUnknown> m_pUnknown;
    DataSourceType GetDataSourceType() 
    {
        return NFO_410; 
    };
};


#endif // !defined(AFX_MSINFO4CATEGORY_H__B47023B3_6038_4168_86A2_475C4986CEAF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msinfo32.cpp ===
// msinfo32.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f msinfo32ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "msinfo32.h"

#include "msinfo32_i.c"
#include "MSInfo.h"
//#include "WhqlProv.h"
//#ifdef	MSINFO_INCLUDE_PROVIDER
#include "WhqlObj.h"
//#endif
#include "MSPID.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MSInfo, CMSInfo)
//#ifdef	MSINFO_INCLUDE_PROVIDER
OBJECT_ENTRY(CLSID_WhqlObj, CWhqlObj)
//#endif
OBJECT_ENTRY(CLSID_MSPID, CMSPID)
END_OBJECT_MAP()

class CMsinfo32App : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsinfo32App)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CMsinfo32App)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMsinfo32App, CWinApp)
	//{{AFX_MSG_MAP(CMsinfo32App)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMsinfo32App theApp;

BOOL CMsinfo32App::InitInstance()
{
	AfxInitRichEdit();
    _Module.Init(ObjectMap, m_hInstance, &LIBID_MSINFO32Lib);
    return CWinApp::InitInstance();
}

int CMsinfo32App::ExitInstance()
{
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// Whistler bug 301288
	//
	// We need to add an entry under the HKCR\msinfo.document registry key
	// to enable MUI retrieval of the file description. The entry is a 
	// value, and should have the form:
	//
	//		"FriendlyTypeName"="@<dllpath\dllname>, -<resID>"
	//
	// Note - since the resource for the string is in this DLL, it seems
	// appropriate to create this value here. The overall key for 
	// msinfo.document is created (for now) by registering msinfo32.dll.
	// The important point is that we shouldn't assume it exists.

	CRegKey regkey;
	if (ERROR_SUCCESS == regkey.Create(HKEY_CLASSES_ROOT, _T("msinfo.document")))
	{
		TCHAR szModule[MAX_PATH + 1];
		::ZeroMemory((PVOID)szModule, sizeof(szModule));
		if (::GetModuleFileName(::GetModuleHandle(_T("msinfo.dll")), szModule, MAX_PATH))
		{
			CString strValue;
			strValue.Format(_T("@%s,-%d"), szModule, IDS_DOCDESCRIPTION);
			regkey.SetValue(strValue, _T("FriendlyTypeName"));
		}
	}

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);	
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msinfo5category.cpp ===
#include "stdafx.h"
#include "category.h"
#include "MSInfo5Category.h"
#include "FileIO.h"
#include "filestuff.h"
#include <afxtempl.h>
#include "fdi.h"
#include "cabfunc.h"
#include "dataset.h"
#include "resource.h"
#include "msxml.h"
#include "wbemcli.h"

///////////////
//CMSInfo7Category

CMSInfo7Category::CMSInfo7Category()
{
    this->m_iColCount = 0;
    this->m_iRowCount = 0;
    this->m_pFirstChild = NULL;
    this->m_pNextSibling = NULL;
    this->m_pParent = NULL;
    this->m_pPrevSibling = NULL;
}

CMSInfo7Category::~CMSInfo7Category()
{
   this->DeleteAllContent();
}


//-----------------------------------------------------------------------------
// Static member of CMSInfo7Category
// Starts the process of reading a file, creating a new CMSInfo7Category object
// for each category found, and returning a pointer to the root node
//-----------------------------------------------------------------------------

HRESULT CMSInfo7Category::ReadMSI7NFO(CMSInfo7Category** ppRootCat, LPCTSTR szFilename)
{
    HRESULT hr = E_FAIL;
    CMSInfo7Category* pRootCat = new CMSInfo7Category();
    
    do
    {
        if (!pRootCat)
            break;
        
        if (!pRootCat->LoadFromXML(szFilename))
        {
            delete pRootCat;
            pRootCat = NULL;
            break;
        }
        
        if (szFilename)
	    {
            CString strAppend;
            strAppend.Format(_T(" (%s)"), szFilename);
            pRootCat->m_strCaption += strAppend;
	    }

        hr = S_OK;
    }
    while (false);
    
    *ppRootCat = pRootCat;
    return hr;
}

BOOL CMSInfo7Category::LoadFromXML(LPCTSTR szFilename)
{
    CComPtr<IXMLDOMDocument> pDoc;
    CComPtr<IXMLDOMNode> pNode;
    HRESULT hr;
    VARIANT_BOOL vb;
    BOOL retVal = FALSE;

    CoInitialize(NULL);
    
    do
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&pDoc);
        if (FAILED(hr) || !pDoc)
            break;

        pDoc->put_async(VARIANT_FALSE);
        
        hr = pDoc->load(CComVariant(szFilename), &vb);
        if (FAILED(hr) || !vb)
            break;
        
        hr = pDoc->QueryInterface(IID_IXMLDOMNode, (void**)&pNode);
        if (FAILED(hr) || !pNode)
            break;
        
        if (FAILED(WalkTree(pNode, FALSE)))
            break;

        retVal = TRUE;

    }while (false);

    CoUninitialize();

    return retVal;  
}


HRESULT CMSInfo7Category::WalkTree(IXMLDOMNode* node, BOOL bCreateCategory)
{
    CComPtr<IXMLDOMNodeList> childList, rowList;
    IXMLDOMNodeList* columnList = NULL;
    CComPtr<IXMLDOMNamedNodeMap> attributeMap;
    IXMLDOMNode* pNextChild = NULL, *pNextAttribute = NULL, *pNextColumn = NULL;
    
    //CComBSTR xmlStr;
    //node->get_xml(&xmlStr);
    
    //read attributes, data & recurse for child categories.
  
    //attributes
    if (SUCCEEDED(node->get_attributes(&attributeMap)) && attributeMap != NULL)      
    {
        attributeMap->nextNode(&pNextAttribute);
        while (pNextAttribute)
        {
            CComBSTR bstrName, bstrValue;
            pNextAttribute->get_nodeName(&bstrName);
            pNextAttribute->get_text(&bstrValue);

            if (lstrcmpiW(bstrName, L"Name") == 0)
            {
                m_strName = bstrValue;
                m_strCaption = m_strName;
                
                pNextAttribute->Release();        
                break;
            }
            
            pNextAttribute->Release();
            attributeMap->nextNode(&pNextAttribute);
        }
    }    

    m_iColCount = 0;
    m_iRowCount = 0;
    
    //count number of rows
    if (SUCCEEDED(node->selectNodes(CComBSTR("Data"), &rowList)) && rowList != NULL)      
    {
        long len = 0;
        rowList->get_length(&len);
        m_iRowCount = len;        
    }
    
    if (m_iRowCount > 0)
        m_afRowAdvanced = new BOOL[m_iRowCount];
    
    int iRow = 0;
    CMSInfo7Category* pPrevCat = NULL;

    //children
    if (SUCCEEDED(node->get_childNodes(&childList)) && childList != NULL)
    {
        childList->nextNode(&pNextChild);
        while (pNextChild)
        {
            CComBSTR bstrName;
            pNextChild->get_nodeName(&bstrName);

            if ((lstrcmpiW(bstrName, L"Data") == 0) && (m_iRowCount > 0))
            {
                //for each data(row), read column name & value
                if (SUCCEEDED(pNextChild->get_childNodes(&columnList)) && columnList != NULL)
                {
                    BOOL bColumnsInitialized = m_acolumns ? TRUE : FALSE;
                    if (!bColumnsInitialized)//column static data. do once
                    {
                        long len = 0;
                        columnList->get_length(&len);
                        m_iColCount = len;
                        m_fDynamicColumns = TRUE;//for correct deletion.
                        if (m_iColCount > 0)
                          m_acolumns = new CMSInfoColumn[m_iColCount];
                        else
                          m_acolumns = NULL;

                        if (m_iColCount > 0 && m_iRowCount > 0)
                        {
                          m_astrData = new CString[m_iColCount * m_iRowCount];
                          m_adwData = new DWORD[m_iColCount * m_iRowCount];
                        }
                        else
                        {
                          m_astrData = NULL;
                          m_adwData = NULL;
                        }
                    }
                    
                    int iColumn = 0;
                    
                    columnList->nextNode(&pNextColumn);
                    while (pNextColumn)
                    {
                        CComBSTR bstrColHdr, bstrRowVal;
                        if (!bColumnsInitialized)//column static data. do once
                        {
                            pNextColumn->get_nodeName(&bstrColHdr);//column hdr
                            m_acolumns[iColumn].m_strCaption = bstrColHdr;
                            m_acolumns[iColumn].m_uiWidth = 150;//PENDING
                            m_acolumns[iColumn].m_fSorts = FALSE;//PENDING
                            m_acolumns[iColumn].m_fLexical = FALSE;//PENDING
                            m_acolumns[iColumn].m_fAdvanced = FALSE;//PENDING
                            m_acolumns[iColumn].m_uiCaption = 0;
                        }
                        
                        pNextColumn->get_text(&bstrRowVal);//row value for the column
                        if(lstrcmpiW(bstrColHdr, L"MSINFOERROR") == 0)
                            m_hrError = _ttoi(bstrRowVal);
                        m_astrData[iRow * m_iColCount + iColumn] = bstrRowVal;
                        
                        m_afRowAdvanced[iRow] = FALSE;//PENDING

                        if (m_acolumns[iColumn].m_fSorts && !m_acolumns[iColumn].m_fLexical)
                        {
                            //m_adwData[iRow * m_iColCount + iColumn] = uiSortOrder;//PENDING
                        }
                        
                        iColumn++;
                        pNextColumn->Release();
                        columnList->nextNode(&pNextColumn);
                    }
                }
                
                if (columnList)
                    columnList->Release();
                iRow++;
            }
            else if ((lstrcmpiW(bstrName, L"XML") == 0) || (lstrcmpiW(bstrName, L"MSInfo") == 0))
            {
                //get past <xml> & <msinfo>
                this->WalkTree(pNextChild, bCreateCategory);
            }
            else if (lstrcmpiW(bstrName, L"Category") == 0)
            {
                if (!bCreateCategory)
                {
                    bCreateCategory = TRUE;//First category encountered. Subsequent categories get their own node.
                    this->WalkTree(pNextChild, bCreateCategory);
                }
                else
                {
                    CMSInfo7Category* pNewCat = new CMSInfo7Category();
                    pNewCat->SetParent(this);
                    pNewCat->SetPrevSibling(pPrevCat);

                    if (pPrevCat)
                        pPrevCat->SetNextSibling(pNewCat);
                    else
                        m_pFirstChild = pNewCat;

                    pPrevCat = pNewCat;
                    pNewCat->WalkTree(pNextChild, bCreateCategory);
                }
            }
            
            pNextChild->Release();  
            childList->nextNode(&pNextChild);
        }
    }
  
    return S_OK;
}

// we want these msgs to look very similar to those displayed by the live category
void CMSInfo7Category::GetErrorText(CString * pstrTitle, CString * pstrMessage)
{
	if (SUCCEEDED(m_hrError))
	{
		ASSERT(0 && "why call GetErrorText for no error?");
		CMSInfoCategory::GetErrorText(pstrTitle, pstrMessage);
		return;
	}

	if (pstrTitle)
		pstrTitle->LoadString(IDS_CANTCOLLECT);

	if (pstrMessage)
	{
		switch (m_hrError)
		{
		case WBEM_E_OUT_OF_MEMORY:
			pstrMessage->LoadString(IDS_OUTOFMEMERROR);
			break;

		case WBEM_E_ACCESS_DENIED:
			pstrMessage->LoadString(IDS_GATHERACCESS_LOCAL);
			break;

		case WBEM_E_INVALID_NAMESPACE:
			pstrMessage->LoadString(IDS_BADSERVER_LOCAL);
			break;

		case 0x800706BA:	// RPC Server Unavailable
		case WBEM_E_TRANSPORT_FAILURE:
			pstrMessage->LoadString(IDS_NETWORKERROR_LOCAL);
			break;

		case WBEM_E_FAILED:
		case WBEM_E_INVALID_PARAMETER:
		default:
			pstrMessage->LoadString(IDS_UNEXPECTED);
		}

#ifdef _DEBUG
		{
			CString strTemp;
			strTemp.Format(_T("\n\r\n\rDebug Version Only: [HRESULT = 0x%08X]"), m_hrError);
			*pstrMessage += strTemp;
		}
#endif
	}
}

///////////////
//EO CMSInfo7Category

CMSInfo5Category::CMSInfo5Category()
{
    
    this->m_pFirstChild = NULL;
    this->m_pNextSibling = NULL;
    this->m_pParent = NULL;
    this->m_pPrevSibling = NULL;
}


//-----------------------------------------------------------------------------
// Saves the actual data (by row and column) to the file
// 
//-----------------------------------------------------------------------------

void CMSInfoCategory::SaveElements(CMSInfoFile *pFile)
{
    CString				szWriteString;
	MSIColumnSortType	stColumn;
    unsigned            iColCount;
    unsigned            iRowCount;
    GetCategoryDimensions((int*) &iColCount,(int*) &iRowCount);
	
	DataComplexity		dcAdvanced;
	CArray <int, int &>	aColumnValues;
	pFile->WriteUnsignedInt(iColCount);

	if (iColCount == 0)
		return;

    //for(unsigned iCol = 0; iCol < iColCount; iCol++)
    for(int iCol = iColCount - 1; iCol >= 0 ; iCol--)
    {
		unsigned	uWidth;
        BOOL bSort,bLexical;
        GetColumnInfo(iCol,&szWriteString,&uWidth,&bSort,&bLexical);
        if (bSort)
        {
            if (bLexical)
            {
                stColumn = LEXICAL;
            }
            else
            {
                stColumn = BYVALUE;
            }
        }
        else
        {
            stColumn = NOSORT;
        }
        if (IsColumnAdvanced(iCol))
        {
		    dcAdvanced = ADVANCED;
        }
        else
        {
            dcAdvanced = BASIC;
        }
		if (stColumn == BYVALUE)
        {
			aColumnValues.Add(iCol);
		}
		pFile->WriteUnsignedInt(uWidth);
		pFile->WriteString(szWriteString);
		pFile->WriteUnsignedInt((unsigned) stColumn);
		pFile->WriteByte((BYTE)dcAdvanced);
	}
	int			wNextColumn = -1;
	unsigned	iArray		= 0;
	pFile->WriteUnsignedInt(iRowCount);
    //for(int iRow = 0; iRow < (int) iRowCount; iRow++)
    for(int iRow = iRowCount - 1; iRow >= 0 ; iRow--)
    {
        if (IsRowAdvanced(iRow))
        {
		    dcAdvanced = ADVANCED;
        }
        else
        {
            dcAdvanced = BASIC;
        }
		pFile->WriteByte((BYTE)dcAdvanced);
	}
	//	Iterate over columns, writing sort indices for BYVALUE columns.
    DWORD dwSortIndex;
    //for(iCol = 0; iCol < iColCount; iCol++)
    for(iCol = iColCount - 1; iCol >= 0 ; iCol--)
    {
        //following variables are not used except for sort info
        CString strUnused;
        UINT iWidth;
        BOOL fSorts;
        BOOL fLexical;
        GetColumnInfo(iCol,&strUnused,&iWidth,&fSorts,&fLexical);
        CDWordArray arySortIndices;
        //for(unsigned iRow = 0; iRow < iRowCount; iRow++)
        for(int iRow = iRowCount - 1; iRow >= 0 ; iRow--)
        {   
			CString * pstrData;
			this->GetData(iRow, iCol, &pstrData, &dwSortIndex);

			// dwSortIndex = m_adwData[iRow * m_iColCount + iCol];
            if (fSorts && !fLexical)
            {
                arySortIndices.Add(dwSortIndex);
            }
            // szWriteString = m_astrData[iRow * m_iColCount + iCol];
            pFile->WriteString(*pstrData);

		}
        if (fSorts && !fLexical)
        {
            ASSERT((unsigned) arySortIndices.GetSize() ==  iRowCount && "wrong number of Sort indices");
            //for(unsigned iRow = 0; iRow < iRowCount; iRow++)
            for(int iRow = iRowCount - 1; iRow >= 0 ; iRow--)
            {
                pFile->WriteUnsignedLong(arySortIndices.GetAt(iRow));
            }
		}
	}

}





//-----------------------------------------------------------------------------
// Fills the various data structures with information in a msinfo file
//-----------------------------------------------------------------------------

BOOL CMSInfo5Category::LoadFromNFO(CMSInfoFile* pFile)
{
    //TD: check validity of the file
    try
    {
        pFile->ReadString(this->m_strName);
	    this->m_strCaption = this->m_strName;
        pFile->ReadSignedInt(this->m_iColCount);
	    if (m_iColCount == 0) 
        {
		    this->m_iRowCount = 0;
		    return TRUE;
	    }
        this->m_acolumns = new CMSInfoColumn[m_iColCount];
        for(int iColumn = m_iColCount - 1; iColumn  >= 0; iColumn--)
        {
            UINT uiWidth;
		    pFile->ReadUnsignedInt(uiWidth);
            CString strCaption;
		    pFile->ReadString(strCaption);
            unsigned wSortType;
		    pFile->ReadUnsignedInt(wSortType);
            BOOL fSorts;
            BOOL fLexical;
            if ( NOSORT == wSortType)
            {
                fLexical = FALSE;
                fSorts = FALSE;
            }
            else if (BYVALUE == wSortType)
            {
                fLexical = FALSE;
                fSorts = TRUE;
            }
            else
            {
                fLexical = TRUE;
                fSorts = TRUE;
            }
            BOOL fAdvanced;
            BYTE btAdvanced;
		    pFile->ReadByte(btAdvanced); 
            fAdvanced = (BOOL)  btAdvanced;
            m_acolumns[iColumn].m_strCaption = strCaption;
            m_acolumns[iColumn].m_uiWidth = uiWidth;
            m_acolumns[iColumn].m_fSorts = fSorts;
            m_acolumns[iColumn].m_fLexical = fLexical;
            m_acolumns[iColumn].m_fAdvanced = fAdvanced;
            m_acolumns[iColumn].m_uiCaption = 0;
        }
 	    pFile->ReadSignedInt(this->m_iRowCount);
        //Nodes that have no data, but only serve as parents to other nodes, have no Rows
        //and a column count of 1

    
	    m_astrData		= new CString[m_iColCount * m_iRowCount];
	    m_adwData		= new DWORD[m_iColCount * m_iRowCount];
	    m_afRowAdvanced = new BOOL[m_iRowCount];

        //for(int iRow = 0; iRow < m_iRowCount; iRow++)
        for(int iRow = m_iRowCount - 1; iRow >=0; iRow--)
        {
            BYTE bComplexity;
            pFile->ReadByte(bComplexity);
            if (BASIC == bComplexity)
            {
                this->m_afRowAdvanced[iRow] = FALSE;
            }
            else
            {
                this->m_afRowAdvanced[iRow] = TRUE;
            }
	    }

        for(iColumn = m_iColCount - 1; iColumn  >= 0; iColumn--)
        {
            CMSInfoColumn* pCol = &this->m_acolumns[(unsigned)iColumn];
            //for(iRow = 0; iRow <  this->m_iRowCount; iRow++)
            for(int iRow = m_iRowCount - 1; iRow >=0; iRow--)
            {
                CString strData;
                pFile->ReadString(strData);
	            m_astrData[iRow * m_iColCount + iColumn] = strData;
		    }
            //sort values are another row of ints like Complexity
            //for(iRow = 0; iRow <  this->m_iRowCount; iRow++)
            for(iRow = m_iRowCount - 1; iRow >=0; iRow--)
            {
                CMSInfoColumn* pColInfo = &this->m_acolumns[iColumn];
                if (pColInfo->m_fSorts && !pColInfo->m_fLexical)
                {
                    unsigned uiSortOrder;
                    pFile->ReadUnsignedInt(uiSortOrder);
                    m_adwData[iRow * m_iColCount + iColumn] = uiSortOrder;
                }       
		    }
	    }
    }
    //TD: exception handling
    catch (CFileException* pException)
    {
        pException->ReportError();
        pException->Delete();

        return FALSE;
    }
    catch (CFileFormatException* pException)
    {
        pException->Delete();
        return FALSE;
    }
    catch (...)
    {
		::AfxSetResourceHandle(_Module.GetResourceInstance());
		//messaging is actually handled elsewhere
		/*CString strCaption, strMessage;
		strCaption.LoadString(IDS_SYSTEMINFO);
		strMessage.LoadString(IDS_BADNFOFILE);
		::MessageBox(NULL,strMessage, strCaption,MB_OK);*/
        return FALSE;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// Read the header information found at the beginning of the file
//-----------------------------------------------------------------------------


BOOL ReadMSI5NFOHeader(CMSInfoFile* pFile)
{
    unsigned iMsinfoFileVersion;
    try
    {
        pFile->ReadUnsignedInt(iMsinfoFileVersion);
        if (iMsinfoFileVersion == CMSInfoFile::VERSION_500_MAGIC_NUMBER)
	    {
		    unsigned uVersion;
		    pFile->ReadUnsignedInt(uVersion);
		    ASSERT(uVersion == 0x500 && "Version number does not match format #");
            if (uVersion != 0x500)
            {
                return NULL;
            }
        }
        else
        {
            return NULL;
        }
    
        LONG  l;
	    pFile->ReadLong(l);	//	Save time.
        time_t tsSaveTime = (ULONG) l;
        //TD: sanity test on date
        CString		szUnused;
	    pFile->ReadString(szUnused);		//	Network machine name
	    pFile->ReadString(szUnused);		//	Network user name
    }
    catch (CFileException* pException)
    {
        pException->ReportError();
        pException->Delete();
        return FALSE;
    }
    catch (CFileFormatException* pException)
    {
        //TD: exception handling
        pException->Delete();
        return FALSE;
    }
    catch (...)
    {
        //messagebox the user in OpenMSInfoFile
        return FALSE;
    }
    return TRUE;
}





CMSInfo5Category::~CMSInfo5Category()
{
   this->DeleteAllContent();
};


//-----------------------------------------------------------------------------
// Static member of CMSInfo5Category
// Starts the process of reading a file, creating a new CMSInfo5Category object
// for each category found, and returning a pointer to the root node
//-----------------------------------------------------------------------------

HRESULT CMSInfo5Category::ReadMSI5NFO(HANDLE hFile,CMSInfo5Category** ppRootCat, LPCTSTR szFilename)
{
    CMSInfo5Category* pRootCat = new CMSInfo5Category();
    CFile* pFile = new CFile((INT_PTR) hFile);
    CMSInfoFile msiFile(pFile);
	unsigned iNodeData;
    if (!ReadMSI5NFOHeader(&msiFile))
    {
		//make sure this gets in 2/14 checkin!
/*        CString strCaption, strMessage;
		::AfxSetResourceHandle(_Module.GetResourceInstance());
		strCaption.LoadString(IDS_SYSTEMINFO);
		strMessage.LoadString(IDS_BADNFOFILE);
		MessageBox(NULL,strMessage, strCaption,MB_OK);*/
        return E_FAIL;
    }
    try
    {
        CMSInfo5Category* pCat = NULL;    
        CMSInfo5Category* pPreviousCat;
        if (!pRootCat->LoadFromNFO(&msiFile))
        {
            delete pRootCat;
            pRootCat = NULL;
			CString strCaption, strMessage;
			::AfxSetResourceHandle(_Module.GetResourceInstance());
			strCaption.LoadString(IDS_SYSTEMINFO);
			strMessage.LoadString(IDS_BADNFOFILE);
			MessageBox(NULL,strMessage, strCaption,MB_OK);
            return E_FAIL;
        }
		//there will be a dummy System Information node, with colcount of 1 and rowcount of 0
		//we need to discard this.
		if (pRootCat->m_iColCount == 1 && pRootCat->m_iRowCount == 0)
		{
			delete pRootCat;
			pRootCat = new CMSInfo5Category();

			msiFile.ReadUnsignedInt(iNodeData);
			if (!pRootCat->LoadFromNFO(&msiFile))
			{	delete pRootCat;
				pRootCat = NULL;
				CString strCaption, strMessage;
				::AfxSetResourceHandle(_Module.GetResourceInstance());
				strCaption.LoadString(IDS_SYSTEMINFO);
				strMessage.LoadString(IDS_BADNFOFILE);
				MessageBox(NULL,strMessage, strCaption,MB_OK);
				return E_FAIL;
			}
		}
		if (szFilename)
		{
			CString strAppend;

			strAppend.Format(_T(" (%s)"), szFilename);
			pRootCat->m_strCaption += strAppend;
		}

        pPreviousCat = pRootCat;
        unsigned iNextNodeType = CMSInfo5Category::FIRST;
        
        //iNextNodeType specifies where in the node tree to put the category
        for(;iNextNodeType != CMSInfo5Category::END;)
        {
            msiFile.ReadUnsignedInt(iNodeData);
			if (pPreviousCat == pRootCat)
			{
				//disregard this particular node position indicator, since we 
				//don't want an empty root category like MSInfo 5.0
				iNodeData = CMSInfo5Category::CHILD;
			}
            iNextNodeType = iNodeData & CMSInfo5Category::MASK;  
            switch (iNextNodeType)
            {
                case CMSInfo5Category::END:     
                   pPreviousCat->SetNextSibling(NULL);
                   pPreviousCat->SetFirstChild(NULL);
                   break;         
 
                case CMSInfo5Category::NEXT:
                    pCat = new CMSInfo5Category();
                    if (!pCat->LoadFromNFO(&msiFile))
                    {
                        delete pCat;
                        pCat = NULL;
                        return E_FAIL;
                    }
                    pCat->SetPrevSibling(pPreviousCat);
                    //the parent of the previous sibling should be the parent for this
                    if (pPreviousCat)
                    {
                        pCat->SetParent((CMSInfo5Category *) pPreviousCat->GetParent());
                        pPreviousCat->SetNextSibling(pCat);
                        pCat->SetPrevSibling(pPreviousCat);
                    }
                    pPreviousCat = pCat;
                break;    
                case CMSInfo5Category::CHILD:
                    pCat = new CMSInfo5Category();
                    if (!pCat->LoadFromNFO(&msiFile))
                    {
                        delete pCat;
                        pCat = NULL;
                        return E_FAIL;
                    }
                    pCat->SetParent(pPreviousCat);
                    pPreviousCat->SetFirstChild(pCat);
                    pCat->SetPrevSibling(NULL);
                    pPreviousCat = pCat;
                break;
                case CMSInfo5Category::PARENT:
                    pCat = new CMSInfo5Category();
                    if (!pCat->LoadFromNFO(&msiFile))
                    {
                        delete pCat;
                        pCat = NULL;
                        return E_FAIL;
                    }
                    //if this a parent, we need to backtrack out of current branch of tree
                    //to find the appropriate parent, get an index from iNodeData
                    //and go back that many categories.
                    unsigned iDepth = (iNodeData & ~CMSInfo5Category::MASK);
                    for(unsigned i = 0; i < iDepth; i++)
                    {
                        pPreviousCat = (CMSInfo5Category *) pPreviousCat->GetParent();
                    
                    }
                    if (!pPreviousCat)
                    {
                        return E_FAIL;
                    }
                    //now move to the end of chain of children
                    for(;pPreviousCat->GetNextSibling();)
                    {
                        pPreviousCat = (CMSInfo5Category *) pPreviousCat->GetNextSibling();
                    }
                    pPreviousCat->SetNextSibling(pCat);
                    pCat->SetParent((CMSInfo5Category *) pPreviousCat->GetParent());
                    pCat->SetPrevSibling(pPreviousCat);
                    pCat->SetNextSibling(NULL);
                    pPreviousCat = pCat;
                break;
            }
        }
    }
    catch (CFileException* pException)
    {
        pException->ReportError();
        pException->Delete();
        return E_FAIL;

    }
    catch (CFileFormatException* pException)
    {
        //TD: cleanup
        pException->Delete();
        return E_FAIL;

    }
    catch (...)
    {
        ::AfxSetResourceHandle(_Module.GetResourceInstance());
		CString strCaption, strMessage;

		strCaption.LoadString(IDS_SYSTEMINFO);
		strMessage.LoadString(IDS_BADNFOFILE);
		::MessageBox(NULL,strMessage, strCaption,MB_OK);
        return E_FAIL;
    }
    //no need to delete pFile; it will be cleaned up by CMSInfoFile destructor
	*ppRootCat = pRootCat;
    return S_OK;
    
}


//-----------------------------------------------------------------------------
// Saves this category to a MSInfo 5 file, which must already have header information 
// written to it
//-----------------------------------------------------------------------------

BOOL CMSInfoCategory::SaveToNFO(CMSInfoFile* pFile)
{
	CString strCaption;
	GetNames(&strCaption, NULL);

	pFile->WriteString(strCaption);
    SaveElements(pFile);
	return TRUE;
}

HANDLE CMSInfo5Category::GetFileFromCab(CString strFileName)
{
    CString strDest;
    GetCABExplodeDir(strDest,TRUE,"");
    OpenCABFile(strFileName,strDest);
    CString strFilename;
    FindFileToOpen(strDest,strFilename);
    return CreateFile(strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
}


//-----------------------------------------------------------------------------
//Saves category information as text, recursing children in bRecursive is true
//-----------------------------------------------------------------------------


BOOL CMSInfoCategory::SaveAsText(CMSInfoTextFile* pTxtFile, BOOL bRecursive)
{
    CString strOut;
    CString strBracket;
    VERIFY(strBracket.LoadString(IDS_LEFTBRACKET) && "Failed to find resource IDS_LEFTBRACKET");
    strOut = strBracket;
    CString strName, strCaption;
    GetNames(&strCaption,&strName);
	strOut += strCaption;
    VERIFY(strBracket.LoadString(IDS_RIGHTBRACKET) && "Failed to find resource IDS_RIGHTBRACKET");
    strOut += strBracket;
    pTxtFile->WriteString("\r\n");
    pTxtFile->WriteString(strOut);
    int iRowCount,iColCount;
    this->GetCategoryDimensions(&iColCount,&iRowCount);
    CString strColHeader;
    UINT uiUnused;
    BOOL fUnused;
    CString strColSpacing = "\t";
    pTxtFile->WriteString("\r\n");
    pTxtFile->WriteString("\r\n");
    if (1 == iColCount && 0 == iRowCount)
    {
        //this is a parent node, with no data of its own    

        CString strCatHeading;
        strCatHeading.LoadString(IDS_CATEGORYHEADING);
        pTxtFile->WriteString(strCatHeading);
    }
    else
    {   
        //for(int iCol = iColCount - 1; iCol >= 0 ; iCol--)
        for(int iCol = 0; iCol < iColCount ; iCol++)
        {
            GetColumnInfo(iCol,&strColHeader,&uiUnused,&fUnused,&fUnused);
            pTxtFile->WriteString(strColHeader);
            pTxtFile->WriteString(strColSpacing);
        }
        pTxtFile->WriteString("\r\n");

        CString strRowInfo;
        //for(int iRow = iRowCount - 1; iRow >= 0; iRow--)
        for(int iRow = 0;iRow  < iRowCount; iRow++)
        {
            //for(int iCol = iColCount - 1; iCol >= 0 ; iCol--)
            for(int iCol = 0; iCol < iColCount ; iCol++)
            {
                //this->GetData(iRow,iCol,&strRowInfo,&dwUnused);
		if(m_astrData)
			strRowInfo = m_astrData[iRow * m_iColCount + iCol];
		else
			strRowInfo.LoadString(IDS_CANTCOLLECT);
                pTxtFile->WriteString(strRowInfo);
                pTxtFile->WriteString(strColSpacing);
            
            }
            pTxtFile->WriteString("\r\n");
        }
    }
    if (bRecursive && this->m_pFirstChild != NULL)
    {
        for(CMSInfo5Category* pChild = (CMSInfo5Category*) this->GetFirstChild();pChild != NULL;pChild = (CMSInfo5Category*) pChild->GetNextSibling())
        {
             pChild->SaveAsText(pTxtFile,TRUE);

        }
    }
    return TRUE;
    
}

///////////////////////
//Functions added by a-kjaw
// The code needs to be refined & is copy-paste from SaveAsText code.
//Maybe a good idea to parameterize SaveAsText func.
/*BOOL CMSInfoCategory::SaveAsXml(CMSInfoTextFile* pTxtFile, BOOL bRecursive)
{
    //if this has no parent, it is topmost node, so
    //if we're writing whole tree (bRecursive is TRUE) then now is when 
    //we want to write header
    if (!this->m_pParent && bRecursive)
    {
		pTxtFile->WriteString("<?xml version=\"1.0\" ?>\r\n"); 
		pTxtFile->WriteString("<MsInfo>\r\n");		
    }

	CStringArray csarr;

    CString strOut;
    CString strBracket;

    CString strName, strCaption;
    GetNames(&strCaption,&strName);
	strOut += strCaption;
    strOut += strBracket;
	
	pTxtFile->WriteString("<Category name=\"");
    pTxtFile->WriteString(strOut);
	pTxtFile->WriteString("\">\r\n");	

    int iRowCount,iColCount;
    this->GetCategoryDimensions(&iColCount,&iRowCount);
    CString strColHeader;
    UINT uiUnused;
    BOOL fUnused;
	int iSpaceLoc = 0;

    if (1 == iColCount && 0 == iRowCount)
    {
        //this is a parent node, with no data of its own    

        //CString strCatHeading;
        //strCatHeading.LoadString(IDS_CATEGORYHEADING);
		//pTxtFile->WriteString("<Category>");
        //pTxtFile->WriteString(strCatHeading);
		//pTxtFile->WriteString("</Category>\r\n");
    }
    else
    {   
        //for(int iCol = iColCount - 1; iCol >= 0 ; iCol--)
		csarr.RemoveAll();
        for(int iCol = 0; iCol < iColCount ; iCol++)
        {
			//XML wont accept spaces at node names. ie. <Category Name> should be <Category_Name>
            GetColumnInfo(iCol,&strColHeader,&uiUnused,&fUnused,&fUnused);
			while((iSpaceLoc = strColHeader.Find(_T(" ") , 0)) != -1)
				strColHeader.SetAt(iSpaceLoc , _T('_'));

			csarr.Add(strColHeader);
        }

        CString strRowInfo;

        for(int iRow = 0;iRow  < iRowCount; iRow++)
        {

            for(int iCol = 0; iCol < iColCount ; iCol++)
            {

                strRowInfo = m_astrData[iRow * m_iColCount + iCol];

				pTxtFile->WriteString("<");
				pTxtFile->WriteString(csarr[iCol]);
				pTxtFile->WriteString(">");

                //Put CDATA here to take care of all weird characters.
				pTxtFile->WriteString("<![CDATA[");
				pTxtFile->WriteString(strRowInfo);
				pTxtFile->WriteString("]]>");

				pTxtFile->WriteString("</");
				pTxtFile->WriteString(csarr[iCol]);
				pTxtFile->WriteString(">\r\n");
            
            }
            pTxtFile->WriteString("\r\n");
        }

		pTxtFile->WriteString("</Category>\r\n");		

    }
    if (bRecursive && this->m_pFirstChild != NULL)
    {
        for(CMSInfo5Category* pChild = (CMSInfo5Category*) this->GetFirstChild();pChild != NULL;pChild = (CMSInfo5Category*) pChild->GetNextSibling())
        {
             pChild->SaveAsXml(pTxtFile,TRUE);

        }
    }
    return TRUE;
}*/

//-----------------------------------------------------------------------------
// Saves this category as text to an open file, and recursively saves subcategories
// if bRecursive is true
// Assumes file can be close when last category is written
//-----------------------------------------------------------------------------

BOOL CMSInfoCategory::SaveAsText(HANDLE hFile, BOOL bRecursive, LPTSTR lpMachineName)
{
	CFile * pFileOut = new CFile((INT_PTR)hFile);

	// The text file is Unicode, so it needs the marker (339423).

	WCHAR wUnicodeMarker = 0xFEFF;
	pFileOut->Write((const void *)&wUnicodeMarker, sizeof(WCHAR));

	try
	{
		CMSInfoTextFile * pTxtFile = new CMSInfoTextFile(pFileOut);
		
		CTime tNow = CTime::GetCurrentTime();
		CString strTimeFormat;

		VERIFY(strTimeFormat.LoadString(IDS_TIME_FORMAT) && "Failed to find resource IDS_TIME_FORMAT");
		CString	strHeaderText = tNow.Format(strTimeFormat);
		pTxtFile->WriteString(strHeaderText);
    
		if (NULL != lpMachineName)
		{
			CString	strMachine;
			
			strMachine.LoadString(IDS_SYSTEMNAME);
			strMachine += _tcsupr(lpMachineName);
			pTxtFile->WriteString(strMachine);
		}
		
		if (!this->SaveAsText(pTxtFile,bRecursive))
		{
		    return FALSE;
		}
		delete pTxtFile;
    }
	catch(CFileException* pException)
	{
		pException->ReportError();
		pException->Delete();
	}
	catch (CException* pException)
	{
		pException->ReportError();
		pException->Delete();
	}
	catch(...)
	{
		::AfxSetResourceHandle(_Module.GetResourceInstance());
		CString strCaption, strMessage;

		strCaption.LoadString(IDS_SYSTEMINFO);
		strMessage.LoadString(IDS_FILESAVEERROR_UNKNOWN);
		::MessageBox(NULL,strMessage, strCaption,MB_OK);
	}
    //CloseHandle(hFile);

    return TRUE;
}

///////////////////////
//Functions added by a-kjaw
// The code needs to be refined & is copy-paste from SaveAsText code.
//Maybe a good idea to parameterize SaveAsText func.
/*BOOL CMSInfoCategory::SaveAsXml(HANDLE hFile, BOOL bRecursive)
{
	CFile* pFileOut = new CFile((INT_PTR)hFile);
	try
	{
		CMSInfoTextFile* pTxtFile = new CMSInfoTextFile(pFileOut);
		if (!this->SaveAsXml(pTxtFile,bRecursive))
		{
		    return FALSE;
		}
		pTxtFile->WriteString("</MsInfo>\r\n");
		delete pTxtFile;
    }
	catch(CFileException e)
	{
		e.ReportError();
	}
	catch (CException e)
	{
		e.ReportError();
	}
	catch(...)
	{
		::AfxSetResourceHandle(_Module.GetResourceInstance());
		CString strCaption, strMessage;

		strCaption.LoadString(IDS_SYSTEMINFO);
		strMessage.LoadString(IDS_FILESAVEERROR_UNKNOWN);
		::MessageBox(NULL,strMessage, strCaption,MB_OK);
	}
    //CloseHandle(hFile);

    
    return TRUE;
}*/


//-----------------------------------------------------------------------------
// Static function that saves specified category to a MSInfo 5 nfo file
// writing header information (so it should be used only to save either root
// category or single category 
//-----------------------------------------------------------------------------

BOOL CMSInfoCategory::SaveNFO(HANDLE hFile, CMSInfoCategory* pCategory, BOOL fRecursive)
{
    //msiFile will delete pFile in its destructor 
	try
	{
		CFile* pFile = new CFile((INT_PTR) hFile);
		CMSInfoFile msiFile(pFile);
		msiFile.WriteHeader(NULL);
		if (!fRecursive || pCategory->GetParent() != NULL)
		{
			pCategory->SaveToNFO(&msiFile);	
			msiFile.WriteEndMark();
			return TRUE;
		}
		CMSInfoCategory* pNext = NULL;
		CMSInfoCategory* pRoot = pCategory;
		//change col and row count of pCategory, to use it as a to create empty node System Information
		//node, saving original col and row count
		
		int iRowCount, iColCount;
		iRowCount = pCategory->m_iRowCount;
		iColCount = pCategory->m_iColCount;
		pCategory->m_iColCount = 1;
		pCategory->m_iRowCount = 0;
		if (!pCategory->SaveToNFO(&msiFile))
		{
			return FALSE;
		}
		//restore col and row counts
		pCategory->m_iColCount = iColCount;
		pCategory->m_iRowCount = iRowCount;
		
		//write child mark
		msiFile.WriteChildMark();
		do
		{
			//write the data for each category as it is encountered
			if (!pCategory->SaveToNFO(&msiFile))
			{
				return FALSE;
			}
			//if we have a child, traverse it
			pNext = pCategory->GetFirstChild();
			if (pCategory == pRoot)
			{
				msiFile.WriteNextMark();
				pCategory = pNext;
				continue;
			}
			else if (pNext != NULL)
			{
				msiFile.WriteChildMark();
				pCategory = pNext;
				continue;
			}
			/*if (pCategory == pRoot)
			{
				break;
			}*/
			//if we have reached the bottom of our list, traverse our siblings
			pNext = pCategory->GetNextSibling();
			if (pNext != NULL)
			{
				msiFile.WriteNextMark();
				pCategory = pNext;
				continue;
			}
			//if we have no more siblings, find our nearest parent's sibling, traversing
			//upwards until we find the node we started with
			pNext = pCategory->GetParent();
			ASSERT(pNext != NULL);
			unsigned uParentCount = 0;
			while (pNext != pRoot)
			{
				++uParentCount;
				pCategory = pNext->GetNextSibling();
				//our parent has a sibling, continue with it
				if (pCategory != NULL)
				{	
					msiFile.WriteParentMark(uParentCount);
					break;
				}
				pNext = pNext->GetParent();

			}
			//if we've returned to our root node, we're done
			if (pNext == pRoot)
			{
				break;
			}
		} while (pCategory != NULL);
		msiFile.WriteEndMark();
			
	}
	catch(CFileException* pException)
	{
		pException->ReportError();
		pException->Delete();
	}
	catch (CException* pException)
	{
		pException->ReportError();
		pException->Delete();
	}
	catch(...)
	{
		::AfxSetResourceHandle(_Module.GetResourceInstance());
		CString strCaption, strMessage;

		strCaption.LoadString(IDS_SYSTEMINFO);
		strMessage.LoadString(IDS_FILESAVEERROR_UNKNOWN);
		::MessageBox(NULL,strMessage, strCaption,MB_OK);
	}
    return TRUE;
}


BOOL CMSInfoCategory::SaveXML(HANDLE hFile)
{
    BOOL bRet = FALSE;
    CMSInfoTextFile* pTxtFile = NULL; 
    CFile* pFileOut = new CFile((INT_PTR)hFile);
    try 
    {
        pTxtFile = new CMSInfoTextFile(pFileOut);
        if (pTxtFile)
            bRet = SaveXML(pTxtFile);
    }
    catch(CFileException* pException)
    {
	    pException->ReportError();
	    pException->Delete();
    }
    catch (CException* pException)
    {
	    pException->ReportError();
	    pException->Delete();
    }
    catch(...)
    {
	    ::AfxSetResourceHandle(_Module.GetResourceInstance());
	    CString strCaption, strMessage;

	    strCaption.LoadString(IDS_SYSTEMINFO);
	    strMessage.LoadString(IDS_FILESAVEERROR_UNKNOWN);
	    ::MessageBox(NULL,strMessage, strCaption,MB_OK);
    }
  
    if (pTxtFile)
    {
      delete pTxtFile;
      pTxtFile = NULL;
    }
    return bRet;
}

BOOL CMSInfoCategory::SaveXML(CMSInfoTextFile* pTxtFile)
{
	CString strData, tmpData;
	
	if (!this->m_pParent)
	{
		#if defined(_UNICODE)
			WORD wBom = 0xFEFF; //Unicode Byte Order Mark   
			pTxtFile->m_pFile->Write(&wBom, 2);
		#endif
		
		strData += _T("<?xml version=\"1.0\"?>\r\n<MsInfo>\r\n");
		
		CTime tNow = CTime::GetCurrentTime();
		CString	strTime = tNow.FormatGmt(_T("%x %X"));
		CString	strVersion("7.0");

		tmpData.Format(_T("<Metadata>\r\n<Version>%s</Version>\r\n<CreationUTC>%s</CreationUTC>\r\n</Metadata>\r\n"), strVersion, strTime);
		strData += tmpData;
		tmpData.Empty();
	}

	CString strName, strCaption;
	GetNames(&strCaption,&strName);
	strData += _T("<Category name=\"");
	strData += strCaption;
	strData += _T("\">\r\n");
    
	CString strBadXML = _T("& '<>\"");
	if(SUCCEEDED(m_hrError))
	{
		int iRowCount,iColCount;
		GetCategoryDimensions(&iColCount, &iRowCount);

		//TCHAR buf[500] = {0};
		//_stprintf(buf, _T("iRowCount=%d iColCount=%d HRESULT=%d m_astrData=%d\r\n"), iRowCount, iColCount, m_hrError, m_astrData);
		//pTxtFile->WriteString(buf);

		UINT uiUnused;
		BOOL fUnused;
		int iSpaceLoc = 0;
		CString strColHeader, strRowInfo;
		
		if(!iRowCount && (iColCount > 1))
		{
			strData += _T("<Data>\r\n");
			
			for(int iCol = 0; iCol < iColCount ; iCol++)
			{
				GetColumnInfo(iCol, &strColHeader, &uiUnused, &fUnused, &fUnused);
				//replace blank spaces with underscores. v-stlowe here is also where we should remove any other 
				//characters that XML won't like, like "'" in French
				//v-stlowe 7/2/2001
				while((iSpaceLoc = strColHeader.FindOneOf(strBadXML)) != -1)
					strColHeader.SetAt(iSpaceLoc , _T('_'));
				tmpData.Format(_T("<%s>%s</%s>\r\n"), strColHeader, strRowInfo, strColHeader);
				strData += tmpData;
			}

			strData += _T("</Data>\r\n");
		}

		for(int iRow = 0;iRow < iRowCount; iRow++)
		{
			strData += _T("<Data>\r\n");
			for(int iCol = 0; iCol < iColCount ; iCol++)
			{
				GetColumnInfo(iCol, &strColHeader, &uiUnused, &fUnused, &fUnused);
				//replace blank spaces with underscores. v-stlowe here is also where we should remove any other 
				//characters that XML won't like, like "'" in French
				//v-stlowe 7/2/2001
				while((iSpaceLoc = strColHeader.FindOneOf(strBadXML)) != -1)
					strColHeader.SetAt(iSpaceLoc , _T('_'));
							
				if(!m_astrData)
					break;
				strRowInfo = m_astrData[iRow * m_iColCount + iCol];

				tmpData.Format(_T("<%s><![CDATA[%s]]></%s>\r\n"), strColHeader, strRowInfo, strColHeader);
				strData += tmpData;
			}

			strData += _T("</Data>\r\n");
		}
	}
	else
	{
		tmpData.Format(_T("<Data>\r\n<MSINFOERROR>%d</MSINFOERROR>\r\n</Data>\r\n"), m_hrError);
		strData += tmpData;
	}

	pTxtFile->WriteString(strData);
	
  for(CMSInfoCategory* pChild = this->GetFirstChild(); pChild != NULL; pChild = pChild->GetNextSibling())
      pChild->SaveXML(pTxtFile);

  pTxtFile->WriteString(_T("</Category>\r\n"));

  if (!this->m_pParent)
      pTxtFile->WriteString(_T("</MsInfo>"));		

  return TRUE;
}


//-----------------------------------------------------------------------------
//  Prints this category, and recursively prints subcategories, if bRecursive is 
//  true.  If nStartPage and nEndPage are 0, page range is ignored (all pages are
//  printed).  If bRecursive is true and a print range is specified, 
//  each category will be processed but only information that would fall on the page range
//  will be printed
//-----------------------------------------------------------------------------


void CMSInfoCategory::Print(HDC hDC, BOOL bRecursive,int nStartPage, int nEndPage, LPTSTR lpMachineName)
{
    //nStartPage and nEndPage mark a page range to print; 
    //if both are 0, then print everything
    CMSInfoPrintHelper* pPrintHelper = new CMSInfoPrintHelper(hDC,nStartPage,nEndPage);
    //header info..do we need this?
    // WCHAR wHeader = 0xFEFF;
	//pTxtFile->Write( &wHeader, 2);
	try
	{
		CTime		tNow = CTime::GetCurrentTime();
		CString		strTimeFormat;
		strTimeFormat.LoadString(IDS_TIME_FORMAT);
		CString		strHeaderText = tNow.Format(strTimeFormat);
		pPrintHelper->PrintLine(strHeaderText);
		if (NULL != lpMachineName)
    {
      CString	strMachine;
		  strMachine.LoadString(IDS_SYSTEMNAME);
      strMachine += _tcsupr(lpMachineName);
      pPrintHelper->PrintLine(strMachine);
    }
		Print(pPrintHelper,bRecursive);
	}
	catch (CException* pException)
	{
		pException->ReportError();
		pException->Delete();
	}
	catch(...)
	{
		::AfxSetResourceHandle(_Module.GetResourceInstance());
		CString strCaption, strMessage;

		strCaption.LoadString(IDS_SYSTEMINFO);
		strMessage.LoadString(IDS_PRINT_GENERIC);
		::MessageBox(NULL,strMessage, strCaption,MB_OK);
	}
    delete pPrintHelper;
}

//-----------------------------------------------------------------------------
//  Prints this category, and recursively prints subcategories, if bRecursive is 
//  true.  If nStartPage and nEndPage are 0, page range is ignored (all pages are
//  printed).  If bRecursive is true and a print range is specified, 
//  each category will be processed but only information that would fall on the page range
//  will be printed
//-----------------------------------------------------------------------------


void CMSInfoCategory::Print(CMSInfoPrintHelper* pPrintHelper, BOOL bRecursive)
{
    
    CString strOut;
    CString strBracket;
    VERIFY(strBracket.LoadString(IDS_LEFTBRACKET) && "Failed to find resource IDS_LEFTBRACKET");
    strOut = strBracket;
    CString strName, strCaption;
    GetNames(&strCaption,&strName);
    strOut += strCaption;
    VERIFY(strBracket.LoadString(IDS_RIGHTBRACKET) && "Failed to find resource IDS_RIGHTBRACKET");
    strOut += strBracket;
    pPrintHelper->PrintLine("");
    pPrintHelper->PrintLine(strOut);
    int iRowCount,iColCount;
    this->GetCategoryDimensions(&iColCount,&iRowCount);
    CString strColHeader;
    UINT uiUnused;
    BOOL fUnused;
    //TD: put in resources
    CString strColSpacing = "    ";
    pPrintHelper->PrintLine("");
    if (1 == iColCount && 0 == iRowCount)
    {
        //this is a parent node, with no data of its own    

        CString strCatHeading;
        strCatHeading.LoadString(IDS_CATEGORYHEADING);
        pPrintHelper->PrintLine(strCatHeading);
    }
    else if (iColCount > 0)
    {   
        CString strComposite;
        for(int iCol =0 ; iCol <iColCount ; iCol++)
        {
            GetColumnInfo(iCol,&strColHeader,&uiUnused,&fUnused,&fUnused);
            strComposite += strColHeader;
            strComposite += strColSpacing;
            
        }
        pPrintHelper->PrintLine(strComposite);
        strComposite = "";

        CString strRowInfo;
        //for(int iRow = iRowCount - 1; iRow >= 0; iRow--)
        for(int iRow = 0; iRow < iRowCount; iRow++)
        {
            //for(int iCol = iColCount - 1; iCol >= 0 ; iCol--)
            for(int iCol =0 ; iCol <iColCount ; iCol++)
            {
                strRowInfo = m_astrData[iRow * m_iColCount + iCol];
                strComposite += strRowInfo;
                strComposite += strColSpacing;       
            }
            pPrintHelper->PrintLine(strComposite);
            strComposite = "";
        }
    }
    if (bRecursive && this->m_pFirstChild != NULL)
    {
        for(CMSInfo5Category* pChild = (CMSInfo5Category*) this->GetFirstChild();pChild != NULL;pChild = (CMSInfo5Category*) pChild->GetNextSibling())
        {
            pChild->Print(pPrintHelper,TRUE);

        }
    }
}

//-----------------------------------------------------------------------------
// Prints a line of text (if current page is in print range) and updates positioning
// information.  If the line is too long to fit on page it is split and printed on
// multiple lines
//-----------------------------------------------------------------------------

extern void StringReplace(CString & str, LPCTSTR szLookFor, LPCTSTR szReplaceWith);

void CMSInfoPrintHelper::PrintLine( CString strLine)
{
    
    //simple line printing function that makes sure that if line exceeds page length,
    //it will wrap to the next line
    //m_nCurrentLineIndex will be the line number, not the vertical position
    //increment the line index, so calling object will print next line
    //at appropriate vertical position
    ++m_nCurrentLineIndex;
    strLine.TrimRight();
    //replace tabs with whitespace
    StringReplace(strLine, _T("\t"), _T("     ")); // strLine.Replace(_T("\t"),_T("     "));
    CSize csLinecaps = m_pPrintDC->GetTextExtent(strLine);
    //see if current position is on page; if not (we've printed to the bottom of the page)
    //paginate, and reset index to 0
    int nFooterMargin =  GetFooterMargin();
    int nVDeviceCaps = GetDeviceCaps(m_hDC,VERTRES);
    int nPageVertSize = GetDeviceCaps(m_hDC,VERTRES) - csLinecaps.cy - GetFooterMargin();
    if (GetVerticalPos(m_nCurrentLineIndex,csLinecaps)  >= nPageVertSize)
    {
        Paginate();
        if (IsInPageRange(m_nPageNumber))
        {
            StartPage(this->GetHDC());
            PrintHeader();
            m_bNeedsEndPage = TRUE;
        }
    }
    int nHorzSize = GetDeviceCaps(m_hDC,HORZRES);
    if (csLinecaps.cx > nHorzSize)
    {
        //line is longer than device caps, and needs to be adjusted
        CString strAdjusted;
       
        for(int i = 0;i < strLine.GetLength() ;i++)
        {
            strAdjusted += strLine[i];
            csLinecaps = m_pPrintDC->GetTextExtent(strAdjusted);
            if (csLinecaps.cx > nHorzSize)
            {
                strAdjusted = strAdjusted.Left(--i);
                //yPosition will be m_nLineIndex* height of a line
                //check to see if this page is within print range
                //if it isn't, we don't want the text to actually go to the printer
                if (IsInPageRange(m_nPageNumber))
                {
                    //pDC->TextOut(this->GetVerticalPos(this->m_nCurrentLineIndex,csLinecaps),0,strAdjusted);
                    //m_pPrintDC->TextOut(0,this->GetVerticalPos(this->m_nCurrentLineIndex,csLinecaps),strAdjusted,strAdjusted.GetLength());
                     VERIFY(TextOut(m_hDC,0,this->GetVerticalPos(this->m_nCurrentLineIndex,csLinecaps),strAdjusted,strAdjusted.GetLength()));
                     

                }
                PrintLine(strLine.Right(strLine.GetLength() -i));
                break;
            }
        }
    }
    else
    {
        if (IsInPageRange(m_nPageNumber))
        {
            //for debug...remove
            int z = this->GetVerticalPos(this->m_nCurrentLineIndex,csLinecaps);
            VERIFY(TextOut(m_hDC,0,this->GetVerticalPos(this->m_nCurrentLineIndex,csLinecaps),strLine,strLine.GetLength()));
            //TRACE("%d %d %s\n",z,m_nCurrentLineIndex,strLine);
        }
    }
    
}


//-----------------------------------------------------------------------------
// Manages GDI objects (DC and Font), and information about printing positions
// and page ranges
//-----------------------------------------------------------------------------

CMSInfoPrintHelper::CMSInfoPrintHelper(HDC hDC,int nStartPage, int nEndPage) 
: m_nStartPage(nStartPage),m_nEndPage(nEndPage),m_nCurrentLineIndex(0),m_nPageNumber(1),m_hDC(hDC)

{
    m_pPrintDC = new CDC();
    m_pPrintDC->Attach(hDC);
    

    // Create the font for printing. Read font information from string
	// resources, to allow the localizers to control what font is
	// used for printing. Set the variables for the default font to use.

	int		nHeight				= 10;
	int		nWeight				= FW_NORMAL;
	BYTE	nCharSet			= DEFAULT_CHARSET;
	BYTE	nPitchAndFamily		= DEFAULT_PITCH | FF_DONTCARE;
	CString	strFace				= "Courier New";


	// Load string resources to see if we should use other values
	// than the defaults.

	CString	strHeight, strWeight, strCharSet, strPitchAndFamily, strFaceName;
	strHeight.LoadString(IDS_PRINT_FONT_HEIGHT);
	strWeight.LoadString(IDS_PRINT_FONT_WEIGHT);
	strCharSet.LoadString(IDS_PRINT_FONT_CHARSET);
	strPitchAndFamily.LoadString(IDS_PRINT_FONT_PITCHANDFAMILY);
	strFaceName.LoadString(IDS_PRINT_FONT_FACENAME);

	if (!strHeight.IsEmpty() && ::_ttol(strHeight))
		nHeight = ::_ttoi(strHeight);

	if (!strWeight.IsEmpty())
		nWeight = ::_ttoi(strWeight);

	if (!strCharSet.IsEmpty())
		nCharSet = (BYTE) ::_ttoi(strCharSet);

	if (!strPitchAndFamily.IsEmpty())
		nPitchAndFamily = (BYTE) ::_ttoi(strPitchAndFamily);

	strFaceName.TrimLeft();
	if (!strFaceName.IsEmpty() && strFaceName != CString("facename"))
		strFace = strFaceName;
    m_pCurrentFont = new CFont();
    nHeight = -((this->m_pPrintDC->GetDeviceCaps (LOGPIXELSY) * nHeight) / 72);
    VERIFY(this->m_pCurrentFont->CreateFont(nHeight, 0, 0, 0, nWeight, 0, 0, 0,
        nCharSet, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
        DEFAULT_QUALITY, nPitchAndFamily, strFace));
    m_pOldFont = (CFont*) m_pPrintDC->SelectObject(this->m_pCurrentFont);
    ASSERT(m_pOldFont && "Error Selecting Font object into CDC");
    DOCINFO docinfo;
    memset(&docinfo, 0, sizeof(docinfo));
    docinfo.cbSize = sizeof(docinfo);
    CString strDocName;
    strDocName.LoadString(IDS_PRINTING_DOCNAME);
    docinfo.lpszDocName = strDocName;
    m_pPrintDC->StartDoc(&docinfo);
    m_pPrintDC->StartPage();
    PrintHeader();
    m_bNeedsEndPage = TRUE;
}



CMSInfoPrintHelper::~CMSInfoPrintHelper()
{
    if (m_bNeedsEndPage)
    {
        VERIFY(EndPage(m_pPrintDC->m_hDC));
    }
    int nResult = m_pPrintDC->EndDoc();
	ASSERT(nResult >= 0);
    //reportprinting error
	//should be if < -1
	if (nResult < 0) 
    {
		AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		CString		strError, strTitle;

		switch(nResult) 
        {
		case SP_OUTOFDISK:
			VERIFY(strError.LoadString(IDS_PRINT_NODISK));
			break;
		case SP_OUTOFMEMORY:
			VERIFY(strError.LoadString(IDS_PRINT_NOMEMORY));
			break;
		case SP_USERABORT:
			VERIFY(strError.LoadString(IDS_PRINT_USERABORTED));
			break;
		case SP_ERROR:
		default:
			VERIFY(strError.LoadString(IDS_PRINT_GENERIC));
			break;
		}
		strTitle.LoadString(IDS_DESCRIPTION);
		::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strError, strTitle, MB_OK);
	}
    m_pPrintDC->SelectObject(m_pOldFont);
    if (m_pCurrentFont)
    {
        delete m_pCurrentFont;
    }
    this->m_pPrintDC->Detach();
    delete m_pPrintDC;
}

//-----------------------------------------------------------------------------
// Used to calculate where on printed page a line of text should go
// nLineIndex is sequenced line number; csLinecaps is size returned by
// GetTextExtent for a string of text
//-----------------------------------------------------------------------------

int CMSInfoPrintHelper::GetVerticalPos(int nLineIndex,CSize csLinecaps)
{
    //returns an int which specifies the vertical position at which a given line of text
    //should print

    CString strLinespacing;

    //spacing is based on string resource IDS_PRINT_LINESPACING
    strLinespacing.LoadString(IDS_PRINT_LINESPACING);
    TCHAR** ppStopChr = NULL;//not used
    double flLineSpacing =_tcstod(strLinespacing,ppStopChr);
    return (int)(csLinecaps.cy * flLineSpacing )*m_nCurrentLineIndex;
}


//-----------------------------------------------------------------------------
// Performs page load-eject on printer
//-----------------------------------------------------------------------------

void CMSInfoPrintHelper::Paginate()
{

    //TD: print page number in footer
    //Do we assume roman numerals for page numbers?

    //check to see if this page is within print range
    //if it is, call StartPage and EndPage to make printer spit out paper;
    //otherwise, just change indexes...
    if (IsInPageRange(m_nPageNumber))
    {
        //use string resource for page number format
        CString strPageFooter;
        CString strPageFormat;
        strPageFormat.LoadString(IDS_PRINT_FTR_CTR);
        strPageFooter.Format(strPageFormat,m_nPageNumber);
        //print number in middle of page
        int nHorzRes,nVertRes;
        nHorzRes = m_pPrintDC->GetDeviceCaps(HORZRES);
        nVertRes = m_pPrintDC->GetDeviceCaps(VERTRES);
        
        this->m_pPrintDC->TextOut(nHorzRes / 2,nVertRes - this->GetFooterMargin(),strPageFooter);
        EndPage(this->GetHDC());
        m_bNeedsEndPage = FALSE;
    }
    m_nCurrentLineIndex = 0;
    this->m_nPageNumber++;

}

//-----------------------------------------------------------------------------
// determines if page ranges need to be checked
// and if a given page number is in a specified page range
//-----------------------------------------------------------------------------



BOOL CMSInfoPrintHelper::IsInPageRange(int nPageNumber)
{
    //if both m_nStartPage and m_nEndPage are 0, we are printing all pages
    if (-1 == m_nStartPage && -1 == m_nEndPage)
    {
        return TRUE;
    }
    if (nPageNumber >= this->m_nStartPage && nPageNumber  <= this->m_nEndPage)
    {
        return TRUE;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
//Gets the space to leave at the bottom of the page for page number, etc.
//-----------------------------------------------------------------------------

int CMSInfoPrintHelper::GetFooterMargin()
{
    //use resource string to set footer margin
    CString strRes;
    strRes.LoadString(IDS_PRINT_FTR_CTR );
    CSize sizeText = m_pPrintDC->GetTextExtent(strRes);
    return sizeText.cy;

}









void CMSInfoPrintHelper::PrintHeader()
{
    CString strHeader;
    strHeader.LoadString(IDS_PRINT_HDR_RIGHT_CURRENT);
    CSize sizeString = m_pPrintDC->GetTextExtent(strHeader);
    int nXPos = m_pPrintDC->GetDeviceCaps(HORZRES) - sizeString.cx;
    this->m_pPrintDC->TextOut(nXPos,0,strHeader);
    m_nCurrentLineIndex++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msinfotool.cpp ===
//=============================================================================
// The CMSInfoTool class encapsulates a tool (which can appear on the Tools
// menu or as part of a context sensitive menu).
//=============================================================================

#include "stdafx.h"
#include "msinfotool.h"
#include "wmiabstraction.h"

// Trick the resource.h include file into defining the _APS_NEXT_COMMAND_VALUE
// symbol. We can use this to add menu items dynamically.

#ifndef APSTUDIO_INVOKED
	#define APSTUDIO_INVOKED 1
	#include "resource.h"
	#undef APSTUDIO_INVOKED
#else
	#include "resource.h"
#endif

// An array of tools to be included (in addition to the registry tools).

MSITOOLINFO aInitialToolset[] = 
{
	{ IDS_CABCONTENTSNAME, 0, NULL, NULL, _T("explorer"), NULL, _T("%2") },
	{ IDS_DRWATSONNAME, 0, _T("%windir%\\system32\\drwtsn32.exe"), NULL, NULL, NULL, NULL },
	{ IDS_DXDIAGNAME, 0, _T("%windir%\\system32\\dxdiag.exe"), NULL, NULL, NULL, NULL },
	{ IDS_SIGVERIFNAME, 0, _T("%windir%\\system32\\sigverif.exe"), NULL, NULL, NULL, NULL },
	{ IDS_SYSTEMRESTNAME, 0, _T("%windir%\\system32\\restore\\rstrui.exe"), NULL, NULL, NULL, NULL },
	{ IDS_NETDIAGNAME, 0, _T("hcp://system/netdiag/dglogs.htm"), NULL, NULL, NULL, NULL },
	{ 0, 0, NULL, NULL, NULL, NULL, NULL }
};

//-----------------------------------------------------------------------------
// Check to see if the specified file (with path information) exists on
// the machine.
//-----------------------------------------------------------------------------

BOOL FileExists(const CString & strFile)
{
	WIN32_FIND_DATA finddata;
	HANDLE			h = FindFirstFile(strFile, &finddata);

	if (INVALID_HANDLE_VALUE != h)
	{
		FindClose(h);
		return TRUE;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Delete the map of tools.
//-----------------------------------------------------------------------------

void RemoveToolset(CMapWordToPtr & map)
{
	WORD			wCommand;
	CMSInfoTool *	pTool;

	for (POSITION pos = map.GetStartPosition(); pos != NULL; )
	{
		map.GetNextAssoc(pos, wCommand, (void * &) pTool);
		ASSERT(pTool);
		if (pTool)
			delete pTool;
	}

	map.RemoveAll();
}

//-----------------------------------------------------------------------------
// Load the map of tools from the specified registry location. This will be
// called in the case when there is no CAB file open.
//
// If an HKEY is passed in, it should be open, and it will be closed when
// the function is complete.
//-----------------------------------------------------------------------------

void LoadGlobalToolset(CMapWordToPtr & map, HKEY hkeyTools)
{
	RemoveToolset(map);

	// This should automatically put us out of the range of any menu IDs
	// stored in the resources.

	CMSInfoTool * pTool;
	DWORD dwID = _APS_NEXT_COMMAND_VALUE;
	DWORD dwIndex = 0;

	// Load the tools out of the array built into the code.

	for (MSITOOLINFO * pInitialTool = aInitialToolset; pInitialTool->m_szCommand || pInitialTool->m_szCABCommand; pInitialTool++)
	{
		pTool = new CMSInfoTool;
		if (pTool)
		{
			if (pTool->LoadGlobalFromMSITOOLINFO(dwID, pInitialTool, FALSE))
			{
				map.SetAt((WORD) dwID, (void *) pTool);
				dwID++;
			}
			else
				delete pTool;
		}
	}

	// Make sure we have an open handle for the tools section of the registry.

	HKEY hkeyBase = hkeyTools;
	if (hkeyBase == NULL)
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools\\MSInfo\\Toolsets\\MSInfo"), 0, KEY_READ, &hkeyBase) != ERROR_SUCCESS)
			return;

	// Enumerate the subkeys of the tools key.

	HKEY	hkeySub;
	DWORD	dwChild = MAX_PATH;
	TCHAR	szChild[MAX_PATH];

	while (RegEnumKeyEx(hkeyBase, dwIndex++, szChild, &dwChild, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
	{
		if (RegOpenKeyEx(hkeyBase, szChild, 0, KEY_READ, &hkeySub) == ERROR_SUCCESS)
		{
			pTool = new CMSInfoTool;
			if (pTool)
			{
				if (pTool->LoadGlobalFromRegistry(hkeySub, dwID, FALSE, map))
				{
					map.SetAt((WORD) dwID, (void *) pTool);
					dwID++;
				}
				else
					delete pTool;
			}
			RegCloseKey(hkeySub);
		}

		dwChild = MAX_PATH;
	}

	RegCloseKey(hkeyBase);
}

//-----------------------------------------------------------------------------
// Load the map of tools from the specified registry location. This will be
// called in the case when there IS a CAB file open.
//
// If an HKEY is passed in, it should be open, and it will be closed when
// the function is complete.
//-----------------------------------------------------------------------------

void LoadGlobalToolsetWithOpenCAB(CMapWordToPtr & map, LPCTSTR szCABDir, HKEY hkeyTools)
{
	// This should automatically put us out of the range of any menu IDs
	// stored in the resources.

	RemoveToolset(map);

	CMSInfoTool *	pTool;
	DWORD			dwID = _APS_NEXT_COMMAND_VALUE;
	DWORD			dwIndex = 0;

	// Load the tools out of the array built into the code.

	for (MSITOOLINFO * pInitialTool = aInitialToolset; pInitialTool->m_szCommand || pInitialTool->m_szCABCommand; pInitialTool++)
	{
		pTool = new CMSInfoTool;
		if (pTool)
		{
			if (pTool->LoadGlobalFromMSITOOLINFO(dwID, pInitialTool, TRUE))
			{
				pTool->Replace(_T("%2"), szCABDir);
				map.SetAt((WORD) dwID, (void *) pTool);
				dwID++;
			}
			else
				delete pTool;
		}
	}

	// Make sure we have an open handle for the tools section of the registry.

	HKEY hkeyBase = hkeyTools;
	if (hkeyBase == NULL)
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools\\MSInfo\\Tools"), 0, KEY_READ, &hkeyBase) != ERROR_SUCCESS)
			return;

	// Enumerate the subkeys of the tools key.

	HKEY	hkeySub;
	DWORD	dwChild = MAX_PATH;
	TCHAR	szChild[MAX_PATH];

	while (RegEnumKeyEx(hkeyBase, dwIndex++, szChild, &dwChild, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
	{
		if (RegOpenKeyEx(hkeyBase, szChild, 0, KEY_READ, &hkeySub) == ERROR_SUCCESS)
		{
			pTool = new CMSInfoTool;
			if (pTool)
			{
				if (pTool->LoadGlobalFromRegistry(hkeySub, dwID, TRUE, map))
				{
					pTool->Replace(_T("%2"), szCABDir);
					map.SetAt((WORD) dwID, (void *) pTool);
					dwID++;

					// If this tool is for CAB contents, and there is a cabextensions
					// string, then we want to look in the contents of the CAB for all
					// of the files with that extension. For each file we find, we should
					// insert a submenu item with the file name.

					CString strExtensions = pTool->GetCABExtensions();
					if (!strExtensions.IsEmpty())
					{
						CString strExtension = strExtensions; // TBD - allow for more than one
						
						CString strSearch(szCABDir);
						if (strSearch.Right(1) != CString(_T("\\")))
							strSearch += _T("\\");
						strSearch += CString(_T("*.")) + strExtension;

						WIN32_FIND_DATA finddata;
						HANDLE			hFindFile = FindFirstFile(strSearch, &finddata);

						if (INVALID_HANDLE_VALUE != hFindFile)
						{
							do
							{
								CMSInfoTool * pSubTool = pTool->CloneTool(dwID, finddata.cFileName);
								if (pSubTool)
								{
									pSubTool->Replace(_T("%1"), finddata.cFileName);
									map.SetAt((WORD) dwID, (void *) pSubTool);
									dwID++;
								}

							} while (FindNextFile(hFindFile, &finddata));

							FindClose(hFindFile);
						}
					}
				}
				else
					delete pTool;
			}
			RegCloseKey(hkeySub);
		}

		dwChild = MAX_PATH;
	}

	RegCloseKey(hkeyBase);
}

//-----------------------------------------------------------------------------
// Check to see if the specified tool exists on this machine.
//-----------------------------------------------------------------------------

BOOL ToolExists(const CString & strTool, const CString & strParameters)
{
	CString strWorking(strTool);

	// If the tool is MMC, we really want to look for the existence of
	// the parameter (the MSC file).

	CString strCheck(strTool);
	strCheck.MakeLower();
	if (strCheck.Find(_T("\\mmc.exe")) != -1)
		strWorking = strParameters;

	// If the tool is actually a HSC page (it starts with "hcp:") then we need
	// to change it into a file path (converting forward slashes to backslashes)
	// and prepend the helpctr path.

	if (strCheck.Find(_T("hcp:")) == 0)
	{
		TCHAR szHelpCtrPath[MAX_PATH];
		if (0 != ::ExpandEnvironmentStrings(_T("%windir%\\pchealth\\helpctr"), szHelpCtrPath, MAX_PATH))
		{
			CString strHelpCtrPath(szHelpCtrPath);
			strWorking.Replace(_T("hcp://"), _T("\\"));
			strWorking.Replace(_T("/"), _T("\\"));
			strWorking = strHelpCtrPath + strWorking;
		}
	}

	if (strWorking.Find(_T("\\")) != -1)
		return (FileExists(strWorking));

	// The command for the tool doesn't have path information in it. That
	// means we'll need to check all the directories in the path to see
	// if it exists.

	const DWORD dwBufferSize = MAX_PATH * 10;	// TBD - figure out the actual max
	LPTSTR		szPath = new TCHAR[dwBufferSize];
	BOOL		fFound = TRUE;	// better to show the tool incorrectly if there's an error
	CString		strCandidate;

	if (szPath && dwBufferSize > ExpandEnvironmentStrings(_T("%path%"), szPath, dwBufferSize))
	{
		CString strPath(szPath);

		fFound = FALSE;
		while (!strPath.IsEmpty())
		{
			strCandidate = strPath.SpanExcluding(_T(";"));
			if (strPath.GetLength() != strCandidate.GetLength())
				strPath = strPath.Right(strPath.GetLength() - strCandidate.GetLength() - 1);
			else
				strPath.Empty();

			if (strCandidate.Right(1) != CString(_T("\\")))
				strCandidate += _T("\\");
			strCandidate += strWorking;

			if (FileExists(strCandidate))
			{
				fFound = TRUE;
				break;
			}
		}
	}

	if (szPath)
		delete [] szPath;

	return fFound;
}

//=============================================================================
// CMSInfoTool Methods
//=============================================================================

//-----------------------------------------------------------------------------
// Load this tool from the specified registry key.
//-----------------------------------------------------------------------------

BOOL CMSInfoTool::LoadGlobalFromRegistry(HKEY hkeyTool, DWORD dwID, BOOL fCABOpen, CMapWordToPtr & map)
{
	TCHAR	szBuffer[MAX_PATH];
	DWORD	dwType, dwSize;

	// Read in the values from the specified registry key.

	LPCTSTR aszValueNames[] = { _T(""), _T("command"), _T("description"), _T("parameters"), _T("cabcommand"), _T("cabextensions"),  _T("cabparameters"), NULL };
	CString * apstrValues[] = { &m_strName, &m_strCommand, &m_strDescription, &m_strParameters, &m_strCABCommand, &m_strCABExtension, &m_strCABParameters, NULL };

	for (int i = 0; aszValueNames[i] && apstrValues[i]; i++)
	{
		dwSize = sizeof(TCHAR) * MAX_PATH;
		if (ERROR_SUCCESS == RegQueryValueEx(hkeyTool, aszValueNames[i], NULL, &dwType, (LPBYTE) szBuffer, &dwSize))
			*(apstrValues[i]) = szBuffer;
		else
		{
			if (_tcscmp(aszValueNames[i], _T("parameters")) == 0)
				if (ERROR_SUCCESS == RegQueryValueEx(hkeyTool, _T("param"), NULL, &dwType, (LPBYTE) szBuffer, &dwSize))
					*(apstrValues[i]) = szBuffer;
		}
	}

	m_dwID = dwID;

	if (m_strName.IsEmpty())
		return FALSE;

	// Look for the name of this tool in the map (don't want to add it twice).

	CMSInfoTool *	pTool;
	WORD			wCommand;

	for (POSITION pos = map.GetStartPosition(); pos != NULL; )
	{
		map.GetNextAssoc(pos, wCommand, (void * &) pTool);
		if (pTool && m_strName.CompareNoCase(pTool->m_strName) == 0)
			return FALSE;
	}

	// Special hack - don't include help center in the list of tools.

	CString strCommand(m_strCommand);
	strCommand.MakeLower();
	if (strCommand.Find(_T("helpctr.exe")) != -1)
		return FALSE;

	// Another special hack - need explorer.exe, not just explorer.
	
	if (m_strCABCommand.CompareNoCase(_T("explorer")) == 0)
		m_strCABCommand = _T("explorer.exe");

	// If a CAB has been opened, and there is a specific command for that
	// case, AND the command exists, then set the flag so we use that
	// command.
	//
	// Otherwise, check to see if the default command exists.

	m_fCABOpen = FALSE;
	if (fCABOpen && !m_strCABCommand.IsEmpty() && ToolExists(m_strCABCommand, m_strCABParameters))
		m_fCABOpen = TRUE;
	else if (m_strCommand.IsEmpty() || !ToolExists(m_strCommand, m_strParameters))
		return FALSE;

	return TRUE;
}

//-----------------------------------------------------------------------------
// Load this tool from the specified registry key.
//-----------------------------------------------------------------------------

BOOL CMSInfoTool::LoadGlobalFromMSITOOLINFO(DWORD dwID, MSITOOLINFO * pTool, BOOL fCABOpen)
{
	ASSERT(pTool);
	if (pTool == NULL)
		return FALSE;

	if (pTool->m_uiNameID != 0)
		m_strName.LoadString(pTool->m_uiNameID);
	else
		m_strName = pTool->m_szCommand;

	if (pTool->m_uiDescriptionID != 0)
		m_strDescription.LoadString(pTool->m_uiDescriptionID);
	else
		m_strDescription = pTool->m_szCommand;

	m_strCommand = pTool->m_szCommand;
	m_strParameters = pTool->m_szParams;
	m_strCABCommand = pTool->m_szCABCommand;
	m_strCABExtension = pTool->m_szCABExtension;
	m_strCABParameters = pTool->m_szCABParams;

	CString strCommand(m_strCommand);
	strCommand.MakeLower();
	if (strCommand.Find(_T("%windir%")) != -1)
	{
		TCHAR szBuffer[MAX_PATH];
		if (::ExpandEnvironmentStrings(m_strCommand, szBuffer, MAX_PATH))
			m_strCommand = szBuffer;
	}

	m_dwID = dwID;

	if (m_strName.IsEmpty())
		return FALSE;

	// Special hack - don't include help center in the list of tools.

	strCommand = m_strCommand;
	strCommand.MakeLower();
	if (strCommand.Find(_T("helpctr.exe")) != -1)
		return FALSE;

	// Another special hack - need explorer.exe, not just explorer.
	
	if (m_strCABCommand.CompareNoCase(_T("explorer")) == 0)
		m_strCABCommand = _T("explorer.exe");

	// If a CAB has been opened, and there is a specific command for that
	// case, AND the command exists, then set the flag so we use that
	// command.
	//
	// Otherwise, check to see if the default command exists.

	m_fCABOpen = FALSE;
	if (fCABOpen && !m_strCABCommand.IsEmpty() && ToolExists(m_strCABCommand, m_strCABParameters))
		m_fCABOpen = TRUE;
	else if (m_strCommand.IsEmpty() || !ToolExists(m_strCommand, m_strParameters))
		return FALSE;

	return TRUE;
}

//-----------------------------------------------------------------------------
// Execute should actually launch this tool.
//-----------------------------------------------------------------------------

void CMSInfoTool::Execute()
{
	if (m_fCABOpen)
		ShellExecute(NULL, NULL, m_strCABCommand, m_strCABParameters, NULL, SW_SHOWNORMAL);
	else
		ShellExecute(NULL, NULL, m_strCommand, m_strParameters, NULL, SW_SHOWNORMAL);
}

//-----------------------------------------------------------------------------
// Replace is used to convert fields in the command and parameters to actual
// values which make sense (i.e. "%2" is replaced with the CAB directory).
//-----------------------------------------------------------------------------

void CMSInfoTool::Replace(LPCTSTR szReplace, LPCTSTR szWith)
{
	if (m_fCABOpen)
	{
		StringReplace(m_strCABCommand, szReplace, szWith);
		StringReplace(m_strCABParameters, szReplace, szWith);
	}
}

//-----------------------------------------------------------------------------
// Make a copy of this tool, with the new ID.
//-----------------------------------------------------------------------------

CMSInfoTool * CMSInfoTool::CloneTool(DWORD dwID, LPCTSTR szName)
{
	CMSInfoTool * pNewTool = new CMSInfoTool;
	if (pNewTool)
	{
		this->m_fHasSubitems = TRUE;

		pNewTool->m_dwID = dwID;
		pNewTool->m_dwParentID = this->GetID();

		pNewTool->m_fCABOpen			= this->m_fCABOpen;
		pNewTool->m_strName				= szName;
		pNewTool->m_strCommand			= this->m_strCommand;
		pNewTool->m_strDescription		= this->m_strDescription;
		pNewTool->m_strParameters		= this->m_strParameters;
		pNewTool->m_strCABCommand		= this->m_strCABCommand;
		pNewTool->m_strCABExtension		= this->m_strCABExtension;
		pNewTool->m_strCABParameters	= this->m_strCABParameters;
	}

	return (pNewTool);
}

//-----------------------------------------------------------------------------
// Create the tool explicitly (note - this has very limited use at this point).
//-----------------------------------------------------------------------------

void CMSInfoTool::Create(DWORD dwID, BOOL fCABOnly, LPCTSTR szName, LPCTSTR szCommand, LPCTSTR szDesc, LPCTSTR szParam, LPCTSTR szCABCommand, LPCTSTR szCABExt, LPCTSTR szCABParam)
{
	m_dwID				= dwID;
	m_fCABOpen			= fCABOnly;
	m_strName			= szName;
	m_strCommand		= szCommand;
	m_strDescription	= szDesc;
	m_strParameters		= szParam;
	m_strCABCommand		= szCABCommand;
	m_strCABExtension	= szCABExt;
	m_strCABParameters	= szCABParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msinfo4category.cpp ===
// MSInfo4Category.cpp: implementation of the CMSInfo4Category class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "category.h"
#include "msictrl.h"
#include "datasource.h"
#include "MSInfo4Category.h"
#include "MSInfo5Category.h"
#include "filestuff.h"
#include <afxole.h>
#include "FileIO.h"
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CNFO4DataSource* CMSInfo4Category::s_pNfo4DataSource = NULL;
//a-kjaw
BOOL CMSInfo4Category::m_bIsControlInstalled = TRUE;
//a-kjaw
CMSInfo4Category::CMSInfo4Category() : m_pUnknown(NULL)
{

}

CMSInfo4Category::~CMSInfo4Category()
{
    
}

HRESULT CMSInfo4Category::ReadMSI4NFO(CString strFileName/*HANDLE hFile*/,CMSInfo4Category** ppRootCat)
{
 
  
	DWORD       grfMode = STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE;
    CComPtr<IStream> pStream;
    CComBSTR bstrFileName(strFileName);
    CComPtr<IStorage> pStorage;
 	HRESULT hr = StgOpenStorage(bstrFileName, NULL, grfMode, NULL, 0, &pStorage);
   
	if (!SUCCEEDED(hr))
	{
        return hr;
    }
    CComBSTR bstrMSIStream(_T("MSInfo"));
    hr = pStorage->OpenStream(bstrMSIStream, NULL, grfMode, 0, &pStream);
	if (!SUCCEEDED(hr))
	{
        return hr;
    } 
    COleStreamFile* pOStream;
    pOStream = new COleStreamFile(pStream);
    const DWORD	MSI_FILE_VER = 0x03000000;
	DWORD		dwVersion, dwCount;
    ULONG ulCount;
	// First, read and check the version number in the stream.
    ulCount = pOStream->Read((void *) &dwVersion, sizeof(DWORD));
	if (FAILED(hr)  || ulCount != sizeof(DWORD))
    {
		return E_FAIL;
    }

	if (dwVersion != MSI_FILE_VER)
		return E_FAIL;

	// The next thing in the stream is a set of three strings, each terminated by
	// a newline character. These three strings are the time/date, machine name and
	// user name from the saving system. The length of the total string precedes 
	// the string.

	DWORD dwSize;
    ulCount = pOStream->Read(&dwSize,sizeof(DWORD));
	if ( ulCount != sizeof(DWORD))
		return E_FAIL;

	char * szBuffer = new char[dwSize];
	if (szBuffer == NULL)
		return E_FAIL;
    
    ulCount = pOStream->Read((void *) szBuffer,dwSize);
	if (ulCount != dwSize)
	{
		delete szBuffer;
		return E_FAIL;
	}

	// We don't actually care about these values (now at least).
    /*
	CString strData(szBuffer, dwSize);
	m_strTimeDateStamp = strData.SpanExcluding("\n");
	strData = strData.Right(strData.GetLength() - m_strTimeDateStamp.GetLength() - 1);
	m_strMachineName = strData.SpanExcluding("\n");
	strData = strData.Right(strData.GetLength() - m_strMachineName.GetLength() - 1);
	m_strUserName = strData.SpanExcluding("\n");
    */

	delete szBuffer;

	// Next, read the map from CLSIDs to stream names. This also includes some
	// other information about the controls. First we should find a DWORD with
	// the count of controls.

	DWORD dwControlCount;
    ulCount = pOStream->Read(&dwControlCount,sizeof(DWORD));
    delete pOStream;
	if (ulCount != sizeof(int))
		return E_FAIL;

	SAVED_CONTROL_INFO controlInfo;
	CString strCLSID, strStreamName;
    //a-stephl
    CMapStringToString	mapStreams;
	for (DWORD i = 0; i < dwControlCount; i++)
	{
		if (FAILED(pStream->Read((void *) &controlInfo, sizeof(SAVED_CONTROL_INFO), &dwCount)) || dwCount != sizeof(SAVED_CONTROL_INFO))
			return E_FAIL;

		strCLSID = controlInfo.szCLSID;
		strStreamName = controlInfo.szStreamName;
		// We don't currently care about this information...
        /*
		strSize.Format("%ld", controlInfo.dwSize);
		strInfo.FormatMessage(IDS_OCX_INFO, controlInfo.szName, controlInfo.szVersion, strSize);
		m_mapCLSIDToInfo.SetAt(strCLSID, strInfo);
        */
		mapStreams.SetAt(strCLSID, strStreamName);
	}
	// Read and build the category tree. Read the first level, which must be 0.
	int iLevel;
	if (FAILED(pStream->Read((void *) &iLevel, sizeof(int), &dwCount)) || dwCount != sizeof(int))
		return E_FAIL;

	if (iLevel == 0)
	{
		LARGE_INTEGER li; li.HighPart = -1; li.LowPart = (ULONG)(0 - sizeof(int));
		if (FAILED(pStream->Seek(li, STREAM_SEEK_CUR, NULL)))
			return E_FAIL;
		if (!SUCCEEDED(RecurseLoad410Tree(ppRootCat,pStream,pStorage,mapStreams)))
        {
			return E_FAIL;
        }
		
		// After RecurseLoadTree is through, we should be able to read a -1
		// for the next level.

		if (FAILED(pStream->Read((void *) &iLevel, sizeof(int), &dwCount)) || dwCount != sizeof(int) || iLevel != -1)
        {
			return E_FAIL;
        }
        ASSERT(iLevel == -1 && "unexpected value read after RecurseLoadTree");
	}
	else
		return E_FAIL;

	CString strAppend;
	strAppend.Format(_T(" (%s)"), strFileName);
	(*ppRootCat)->m_strCaption += strAppend;
	
    return S_OK;
}

//-----------------------------------------------------------------------------
// This function (which doesn't really use recursion - the name is left over
// from 4.10 MSInfo) read the category tree from the MSInfo stream and creates
// the necessary COCXFolder objects to represent it.
//-----------------------------------------------------------------------------

HRESULT CMSInfo4Category::RecurseLoad410Tree(CMSInfo4Category** ppRoot, CComPtr<IStream> pStream,CComPtr<IStorage> pStorage,CMapStringToString&	mapStreams)
{
	// This array of folders is used to keep track of the last folder read
	// on each level. This is useful for getting the parent and previous
	// sibling when reading a new folder.
    CMSInfo4Category* pRoot = NULL;
 	// The iLevel variable keeps track of the current tree level we are
	// reading a folder for. A -1 indicates the end of the tree.

	DWORD dwCount;
	int iLevel = 1;
	if (FAILED(pStream->Read((void *) &iLevel, sizeof(int), &dwCount)) || dwCount != sizeof(int))
		return E_FAIL;

	int iLastLevel = iLevel;
    HRESULT hr;
    CMSInfo4Category* pLastCat = NULL;
    for(;iLevel != -1;)
    {
        CMSInfo4Category* pCat = new CMSInfo4Category();
        hr = pCat->LoadFromStream(pStream,pStorage);
        if (FAILED(hr))
        {
            delete pCat;
            return hr;
        }
        if (!pRoot)
        {
            pRoot = pCat;
        }
        //CString strCLSID(pCat->m_bstrCLSID);
        if (!mapStreams.Lookup(pCat->m_strCLSID,pCat->m_strStream))
        {
            ASSERT(1);
        }
       
        if (iLevel == iLastLevel)
        {
            pCat->m_pPrevSibling = pLastCat;
            if (pLastCat)
            {
                pCat->m_pParent = pLastCat->m_pParent;
                pLastCat->m_pNextSibling = pCat;
                
            }
        }
        else if (iLevel - 1 == iLastLevel)
        {
            //we've just stepped from parent to child
            pCat->m_pPrevSibling = NULL;
            if (pLastCat)
            {
                pCat->m_pParent = pLastCat;
                pLastCat->m_pFirstChild = pCat;
                
            }
        }
        else if (iLevel < iLastLevel)
        {
            //we need to trace back up chain to find common parent
            DWORD iLevelDiff = iLastLevel - iLevel;
            for(DWORD i = 0; i < iLevelDiff; i++)
            {
                if (!pLastCat)
                {
                    break;
                }
                pLastCat = (CMSInfo4Category*) pLastCat->m_pParent;
            }
            pCat->m_pPrevSibling = pLastCat;
            if (pLastCat)
            {
                pCat->m_pParent = pLastCat->m_pParent;
                pLastCat->m_pNextSibling = pCat;
            }
        }
        pLastCat = pCat;
        iLastLevel = iLevel;
        if (FAILED(pStream->Read((void *) &iLevel, sizeof(int), &dwCount)) || dwCount != sizeof(int))
			return E_FAIL;

    }

//a-kjaw
	if( CMSInfo4Category::m_bIsControlInstalled == FALSE)
	{
		CString strCaption, strMessage;

		::AfxSetResourceHandle(_Module.GetResourceInstance());
		strCaption.LoadString(IDS_SYSTEMINFO);
		strMessage.LoadString(IDS_NOWI2KRESKIT);
		::MessageBox(NULL, strMessage, strCaption, MB_OK | MB_ICONEXCLAMATION);

		CMSInfo4Category::m_bIsControlInstalled = TRUE;
	}
//a-kjaw


    *ppRoot = pRoot;
	// We read a -1 to exit the loop, then we are through with the
	// category tree. Backup (so any other recursion trees will read
	// the -1 as well) and return TRUE.

	if (iLevel == -1)
	{
		LARGE_INTEGER li; li.HighPart = -1; li.LowPart = (ULONG)(0 - sizeof(int));
		if (FAILED(pStream->Seek(li, STREAM_SEEK_CUR, NULL)))
			return E_FAIL;
	}

	return S_OK;
}





//-----------------------------------------------------------------------------
// This function creates a CMSInfo4Category object based on the information read
// from the stream.
//-----------------------------------------------------------------------------
HRESULT CMSInfo4Category::LoadFromStream(CComPtr<IStream> pStream,CComPtr<IStorage> pStorage)
{
	// Read in the values from the stream. Make sure they're all there before
	// we create the COCXFolder.

	BOOL	fUsesView = FALSE;
	BOOL	fControl = FALSE;
	DWORD	dwView = 0;
	CLSID	clsidCategory;
	char	szName[100];

	if (FAILED(pStream->Read((void *) &fUsesView, sizeof(BOOL), NULL))) return E_FAIL;
	if (FAILED(pStream->Read((void *) &fControl, sizeof(BOOL), NULL))) return E_FAIL;
	if (FAILED(pStream->Read((void *) &dwView, sizeof(DWORD), NULL))) return E_FAIL;
	if (FAILED(pStream->Read((void *) &clsidCategory, sizeof(CLSID), NULL))) return E_FAIL;
	if (FAILED(pStream->Read((void *) &szName, sizeof(char) * 100, NULL))) return E_FAIL;

//	USES_CONVERSION;
//	LPOLESTR lpName = A2W(szName);
    
    this->m_clsid = clsidCategory;

///////a-kjaw		
	CComPtr<IUnknown> pUnk;
	HRESULT hr = S_OK;
	if( !IsEqualGUID(m_clsid , GUID_NULL) )
	hr = CoCreateInstance( m_clsid , NULL, CLSCTX_ALL , IID_IUnknown , 
		(LPVOID*)&pUnk);
	
	if (FAILED(hr))
    {
        m_bIsControlInstalled = FALSE;
    }
///////a-kjaw

    //StringFromCLSID(this->m_clsid,&m_bstrCLSID);
	LPOLESTR lpstrCLSID;
	StringFromCLSID(this->m_clsid,&lpstrCLSID);
	m_strCLSID = lpstrCLSID;
	CoTaskMemFree(lpstrCLSID);
    this->m_pStorage = pStorage;
    this->m_dwView = dwView;
    this->m_strName = szName;
    m_strCaption = szName;
	return S_OK;
}

HRESULT	CMSInfo4Category::Refresh()
{
    return S_OK;
}

HRESULT	CMSInfo4Category::CreateControl(HWND hWnd,CRect& rct)
{
    try
    {
        /*LPOLESTR lpCLSID;
	    if (FAILED(StringFromCLSID(m_clsid, &lpCLSID)))
		    return E_FAIL;*/

    
        HRESULT hr = E_FAIL;
	    if (m_pUnknown == NULL)
        {
	        
            hr = CoCreateInstance(m_clsid,NULL,CLSCTX_INPROC_SERVER,IID_IUnknown,(void**) &m_pUnknown);
        }

	    // Get the stream for this control, and load it.
        if (!SUCCEEDED(hr))
        {
            return hr;
        }
	    DWORD grfMode = STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE;
        CComPtr<IStream> pStream;
        USES_CONVERSION;
        CComBSTR bstrStream = m_strStream;//A2W(m_strStream);
        hr = m_pStorage->OpenStream(bstrStream, NULL, grfMode, 0, &pStream);
	    if (!SUCCEEDED(hr))
        {
            return hr;
        }
        else
	    {
            COleStreamFile	olefile(pStream.Detach());
			CMSIControl* p4Ctrl = new CMSIControl(m_clsid);
            CWnd* pWnd = CWnd::FromHandle(hWnd);
            AfxEnableControlContainer();
            //if (!p4Ctrl->Create(NULL, WS_VISIBLE | WS_CHILD, rct, pWnd, 0, &olefile, FALSE, NULL))
            if (!p4Ctrl->Create(NULL, /*WS_VISIBLE |*/ WS_CHILD, rct, pWnd, 0, &olefile, FALSE, NULL))
            {
                return E_FAIL;
            }
            olefile.Close();
            p4Ctrl->MSInfoUpdateView();
            p4Ctrl->MSInfoRefresh();
            
        
            //Add Control and CLSID to map of CLSID's
            CMSInfo4Category::s_pNfo4DataSource->AddControlMapping(m_strCLSID,p4Ctrl);
        }
    }
    catch (COleException* pException)
    {
        ASSERT(0);
        pException->Delete();
    }
    catch (CException* pException)
    {
        ASSERT(0);
        pException->Delete();
    }
    catch (...)
    {
        ASSERT(0);
    }
    
    return S_OK;
}





//---------------------------------------------------------------------------
// GetDISPID returns the DISPID for a given string, by looking it up using
// IDispatch->GetIDsOfNames. This avoids hardcoding DISPIDs in this class.
//---------------------------------------------------------------------------

BOOL CMSInfo4Category::GetDISPID(IDispatch * pDispatch, LPOLESTR szMember, DISPID *pID)
{
	BOOL	result = FALSE;
	DISPID	dispid;

	if (SUCCEEDED(pDispatch->GetIDsOfNames(IID_NULL, &szMember, 1, LOCALE_SYSTEM_DEFAULT, &dispid)))
	{
		*pID = dispid;
		result = TRUE;
	}

	return result;
}

HRESULT CMSInfo4Category::ShowControl(HWND hWnd, CRect rctList, BOOL fShow)
{
    try
    {
        //CString strCLSID(m_bstrCLSID);
        CMSIControl* p4Ctrl = NULL;
        if (!CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(m_strCLSID,p4Ctrl))
        {
            if (!SUCCEEDED(CreateControl(hWnd,rctList)))
            {
                //could not serialize control
                return E_FAIL;
            }
            if(!CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(m_strCLSID,p4Ctrl))
            {
                if (!IsDisplayableCategory())
                {
                    //this is one of the parent nodes, which does not display info
                    CMSInfo4Category::s_pNfo4DataSource->UpdateCurrentControl(NULL);
                    return S_OK;
                }
                return E_FAIL;
            }
        }
        else
        {
            ResizeControl(rctList);
        }
        ASSERT(p4Ctrl && "Invalid OCX pointer");

		if (fShow)
		{
			CMSInfo4Category::s_pNfo4DataSource->UpdateCurrentControl(p4Ctrl);
			p4Ctrl->ShowWindow(SW_SHOW);
			p4Ctrl->SetMSInfoView(this->m_dwView);
			p4Ctrl->MSInfoUpdateView();
			p4Ctrl->MSInfoRefresh();
		}
		else
			p4Ctrl->ShowWindow(SW_HIDE);
    }
    catch (CException* pException)
    {
        ASSERT(0);
        pException->Delete();
    }
    catch (...)
    {
        ASSERT(0);
    }
    return S_OK;
}

//TD: Move into nfodata.cpp?

CNFO4DataSource::CNFO4DataSource()
{
    m_pCurrentControl = NULL;
}

CNFO4DataSource::~CNFO4DataSource()
{
    CString strKey;
    CMSIControl* pCtrl;
//    m_pCurrentControl->DestroyWindow();
    for(POSITION mapPos = m_mapCLSIDToControl.GetStartPosition( );;)
    {
        if (!mapPos)
        {
            break;
        }
        m_mapCLSIDToControl.GetNextAssoc(mapPos, strKey, (void*&)pCtrl);
        pCtrl->DestroyWindow();
        delete pCtrl;
    
    }

}


void CNFO4DataSource::UpdateCurrentControl(CMSIControl* pControl)
{
    if (m_pCurrentControl && pControl != m_pCurrentControl)
    {
        m_pCurrentControl->ShowWindow(SW_HIDE);
        
    }
    m_pCurrentControl = pControl;
}


//---------------------------------------------------------------------------
// Creates the datasource, and the root CMSInfo4Category
//---------------------------------------------------------------------------

HRESULT CNFO4DataSource::Create(CString strFileName)
{
	CMSInfo4Category * pNewRoot = NULL;
    CMSInfo4Category::SetDataSource(this);
	HRESULT hr = CMSInfo4Category::ReadMSI4NFO(strFileName, &pNewRoot);
 	if (SUCCEEDED(hr) && pNewRoot)
		m_pRoot = pNewRoot;
    
	return hr;
}


void CMSInfo4Category::Print(CMSInfoPrintHelper* pPrintHelper, BOOL bRecursive)
{
#ifdef A_STEPHL
//      ASSERT(0);
#endif
    CString strOut;
    CString strBracket;
    VERIFY(strBracket.LoadString(IDS_LEFTBRACKET) && "Failed to find resource IDS_LEFTBRACKET");
    strOut = strBracket;
    CString strName, strCaption;
    GetNames(&strCaption,&strName);
    strOut += strCaption;
    VERIFY(strBracket.LoadString(IDS_RIGHTBRACKET) && "Failed to find resource IDS_RIGHTBRACKET");
    strOut += strBracket;
    pPrintHelper->PrintLine("");
    pPrintHelper->PrintLine(strOut);
    int iRowCount,iColCount;
    this->GetCategoryDimensions(&iColCount,&iRowCount);
    CString strColHeader;
     //TD: put in resources
    CString strColSpacing = "    ";
    pPrintHelper->PrintLine("");
    /*if (1 == iColCount && 0 == iRowCount)
    {
        //this is a parent node, with no data of its own    

        CString strCatHeading;
        strCatHeading.LoadString(IDS_CATEGORYHEADING);
        pPrintHelper->PrintLine(strCatHeading);
    }*/

    //  When allocating the
	// buffer for the information, allocate 5 extra bytes (1 for the null, and
	// 4 to hold "\r\n\r\n").
	CString strLine;
    CMSIControl* pControl = NULL;
	
    if (!CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(m_strCLSID,pControl))
    {
		//need to make sure it's not "empty parent" category, like HARDWARE RESOURCES
		if ("{00000000-0000-0000-0000-000000000000}" == m_strCLSID)
		{
			//this is a parent node, with no data of its own    
			CString strCatHeading;
			strCatHeading.LoadString(IDS_CATEGORYHEADING);
			pPrintHelper->PrintLine(strCatHeading);
		}
		else
		{
			pPrintHelper->PrintLine("");
			strLine.LoadString(IDS_NOOCX);
			pPrintHelper->PrintLine(strLine);
			CString strDetail;
			strDetail.LoadString(IDS_NOOCXDETAIL);
			pPrintHelper->PrintLine(strDetail);
		}
		

    }
    else
    {
        //pControl->SetMSInfoView(this->m_dwView);
        //pControl->MSInfoUpdateView();
        //pControl->MSInfoRefresh();
	    long lBufferLength = pControl->MSInfoGetData(m_dwView, NULL, 0);
	    if (lBufferLength < 0)
        {
            ASSERT(1);
        }
        else
	    {
		    char *	pBuffer = new char[lBufferLength + 5];
		    if (pBuffer)
		    {
			    strcpy(pBuffer, "\r\n\r\n");
			    if (!pControl->MSInfoGetData(m_dwView, (long *) (&pBuffer[4]), lBufferLength + 1) == lBufferLength)
                {
                    ASSERT(1);
                }
                else
                {
                    //process pBuffer for strings to print
                    CString strBuff(pBuffer);
                    CString strCharSet = _T("\r\n");
                    strCharSet += _T("\r"); //strCharSet += 10;
                    strCharSet += _T("\n"); //strCharSet += 13;
                    /*for(int i = 0; ;)
                    {                                     
                        i = strBuff.FindOneOf(strCharSet);
                        strLine = strBuff.Left(i);
                        pPrintHelper->PrintLine(strLine);
                        i+=2;
                        strBuff = strBuff.Right(strBuff.GetLength() - i);
						//a-stephl: to fix OSR4.1 bug#135918
						if (i > strBuff.GetLength())
						{
							pPrintHelper->PrintLine(strBuff);
							break;
						}

                    }*/
					//a-stephl: to fix OSR4.1 bug#135918
					//for(int i = 0; ;)
					int i = 0;
					while( i > 0)
                    {                                     
                        i = strBuff.FindOneOf(strCharSet);
						if (-1 == i)
						{
							pPrintHelper->PrintLine(strBuff);
						}
                        strLine = strBuff.Left(i);
                        pPrintHelper->PrintLine(strLine);
                        i+=2;
                        strBuff = strBuff.Right(strBuff.GetLength() - i);						
                    }
					//end a-stephl: to fix OSR4.1 bug#135918
                    delete pBuffer;
                }
            }
        }
    }
    if (bRecursive && this->m_pFirstChild != NULL)
    {
        for(CMSInfo4Category* pChild = (CMSInfo4Category*) this->GetFirstChild();pChild != NULL;pChild = (CMSInfo4Category*) pChild->GetNextSibling())
        {
            pChild->Print(pPrintHelper,TRUE);

        }
    }
}

void CMSInfo4Category::Print(HDC hDC, BOOL bRecursive,int nStartPage, int nEndPage)
{
   

    
    //nStartPage and nEndPage mark a page range to print; 
    //if both are 0, then print everything
    CMSInfoPrintHelper* pPrintHelper = new CMSInfoPrintHelper(hDC,nStartPage,nEndPage);
    //header info..do we need this?
    // WCHAR wHeader = 0xFEFF;
	//pTxtFile->Write( &wHeader, 2);
	CTime		tNow = CTime::GetCurrentTime();
	CString		strTimeFormat;
    strTimeFormat.LoadString(IDS_TIME_FORMAT);
    CString		strHeaderText = tNow.Format(strTimeFormat);
	pPrintHelper->PrintLine(strHeaderText);
	pPrintHelper->PrintLine("");
    Print(pPrintHelper,bRecursive);
    delete pPrintHelper;
}



HRESULT CMSInfo4Category::RefreshAllForPrint(HWND hWnd, CRect rctList)
{
    if (this->m_pFirstChild != NULL)
    {
        for(CMSInfo4Category* pChild = (CMSInfo4Category*) this->GetFirstChild();pChild != NULL;pChild = (CMSInfo4Category*) pChild->GetNextSibling())
        {
            CMSIControl* p4Ctrl;
            //if (pChild->GetClsid() != 
            if (!CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(pChild->m_strCLSID,p4Ctrl))
            {
                if (FAILED(pChild->CreateControl(hWnd,rctList)))
                {
                    return E_FAIL;
                }
                if (CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(pChild->m_strCLSID,p4Ctrl))
                {
                    p4Ctrl->ShowWindow(SW_HIDE);
                }
                else //if (!CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(pChild->m_strCLSID,p4Ctrl))
                {
                    //ASSERT(!pChild->IsDisplayableCategory() && "Invalid Class ID");
					//OCX is not installed on this system
                    
                }
                
            }
            pChild->RefreshAllForPrint(hWnd,rctList);

        }
    }
    return S_OK;
}

BOOL CMSInfo4Category::IsDisplayableCategory()
{
    if ("{00000000-0000-0000-0000-000000000000}" == this->m_strCLSID)
    {
        return FALSE;
    }
    return TRUE;
}


//-----------------------------------------------------------------------------
//Saves category information as text, recursing children in bRecursive is true
//-----------------------------------------------------------------------------


BOOL CMSInfo4Category::SaveAsText(CMSInfoTextFile* pTxtFile, BOOL bRecursive)
{
	  
    CString strOut;
    CString strBracket;
    VERIFY(strBracket.LoadString(IDS_LEFTBRACKET) && "Failed to find resource IDS_LEFTBRACKET");
    strOut = strBracket;
    CString strName, strCaption;
    GetNames(&strCaption,&strName);
    strOut += strCaption;
    VERIFY(strBracket.LoadString(IDS_RIGHTBRACKET) && "Failed to find resource IDS_RIGHTBRACKET");
    strOut += strBracket;
    pTxtFile->WriteString("\r\n\r\n");
    pTxtFile->WriteString(strOut);
  
    CMSIControl* pControl = NULL;
    if (!CMSInfo4Category::s_pNfo4DataSource->GetControlFromCLSID(m_strCLSID,pControl))
    {
        ASSERT(1);
    }
    else
    {
		pControl->MSInfoUpdateView();
		pControl->MSInfoRefresh();
 	    long lBufferLength = pControl->MSInfoGetData(m_dwView, NULL, 0);
	    if (lBufferLength < 0)
        {
            ASSERT(1);
        }
        else
	    {
		    char *	pBuffer = new char[lBufferLength + 5];
		    if (pBuffer)
		    {
			    strcpy(pBuffer, "\r\n\r\n");
			    if (!pControl->MSInfoGetData(m_dwView, (long *) (&pBuffer[4]), lBufferLength + 1) == lBufferLength)
                {
                    ASSERT(0 && "could not get data from control");
                }
                else
                {
                    //process pBuffer for strings to print
                    CString strBuff(pBuffer);
                    pTxtFile->WriteString(pBuffer);
                    delete pBuffer;
                }
            }
        }
    }
    if (bRecursive && this->m_pFirstChild != NULL)
    {
        for(CMSInfo4Category* pChild = (CMSInfo4Category*) this->GetFirstChild();pChild != NULL;pChild = (CMSInfo4Category*) pChild->GetNextSibling())
        {
            pChild->SaveAsText(pTxtFile,TRUE);

        }
    }
    return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msinfotool.h ===
//=============================================================================
// The CMSInfoTool class encapsulates a tool (which can appear on the Tools
// menu or as part of a context sensitive menu).
//=============================================================================

#pragma once

extern void RemoveToolset(CMapWordToPtr & map);
extern void LoadGlobalToolset(CMapWordToPtr & map, HKEY hkeyTools = NULL);
extern void LoadGlobalToolsetWithOpenCAB(CMapWordToPtr & map, LPCTSTR szCABDir, HKEY hkeyTools = NULL);

struct MSITOOLINFO
{
	UINT	m_uiNameID;
	UINT	m_uiDescriptionID;
	LPCTSTR	m_szCommand;
	LPCTSTR m_szParams;
	LPCTSTR m_szCABCommand;
	LPCTSTR m_szCABExtension;
	LPCTSTR m_szCABParams;
};

class CMSInfoTool
{
public:
	CMSInfoTool() : m_dwParentID(0), m_fHasSubitems(FALSE), m_hmenu(NULL) {};
	~CMSInfoTool() {};

	BOOL			LoadGlobalFromRegistry(HKEY hkeyTool, DWORD dwID, BOOL fCABOpen, CMapWordToPtr & map);
	BOOL			LoadGlobalFromMSITOOLINFO(DWORD dwID, MSITOOLINFO * pTool, BOOL fCABOpen);
	void			Create(DWORD dwID, BOOL fCABOnly, LPCTSTR szName, LPCTSTR szCommand, LPCTSTR szDesc, LPCTSTR szParam, LPCTSTR szCABCommand, LPCTSTR szCABExt, LPCTSTR szCABParam);
	void			Execute();
	DWORD			GetID() { return m_dwID; };
	DWORD			GetParentID() { return m_dwParentID; };
	CString			GetName() { return m_strName; };
	CString			GetCABExtensions() { return (m_fCABOpen) ? m_strCABExtension : CString(_T("")); };
	BOOL			HasSubitems() { return m_fHasSubitems; };
	void			Replace(LPCTSTR szReplace, LPCTSTR szWith);
	CMSInfoTool *	CloneTool(DWORD dwID, LPCTSTR szName);
	void			SetHMENU(HMENU hmenu) { m_hmenu = hmenu; };
	HMENU			GetHMENU() { return m_hmenu; };

private:
	DWORD		m_dwID;
	DWORD		m_dwParentID;

	BOOL		m_fCABOpen;
	BOOL		m_fHasSubitems;

	CString		m_strName;
	CString		m_strCommand;
	CString		m_strDescription;
	CString		m_strParameters;
	CString		m_strCABCommand;
	CString		m_strCABExtension;
	CString		m_strCABParameters;

	HMENU		m_hmenu;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\msinfo5category.h ===
class CMSInfoFile;

//=============================================================================
// CMSInfoPrintHelper is used to manage pagination and GDI resources used in printing
//=============================================================================

class CMSInfoPrintHelper
{
    
public:
	void PrintHeader();

	HDC m_hDC;
	int m_nEndPage;
	int m_nStartPage;
    HDC GetHDC(){return m_hDC;};
    CMSInfoPrintHelper(HDC hDC,int nStartPage, int nEndPage);
    void PrintLine(CString strLine);
    ~CMSInfoPrintHelper();

protected:
	BOOL IsInPageRange(int nPageNumber);
    void Paginate();
	int GetVerticalPos(int nLineIndex,CSize csLinecaps);
    int GetHeaderMargin();
    int GetFooterMargin();
    
    //Used to manage the positioning of text on the printer Device Context
    CDC* m_pPrintDC;
    int m_nCurrentLineIndex;
    CFont* m_pOldFont;
    CFont* m_pCurrentFont;
    int m_nPageNumber;
    BOOL m_bNeedsEndPage;

};

//=============================================================================
// CMSInfo5Category is used to load MSInfo 5 and 6 NFO files
//=============================================================================


class CMSInfo5Category : public CMSInfoCategory
{
public:
	
    enum NodeType { FIRST = 0x6000, CHILD = 0x8000, NEXT = 0x4000, END = 0x2000, PARENT = 0x1000,
			MASK = 0xf000 };
    CMSInfo5Category();
    virtual ~CMSInfo5Category();
 	DataSourceType GetDataSourceType() { return NFO_500; };
    // Functions specific to the subclass:
    virtual BOOL LoadFromNFO(CMSInfoFile* pFile);
    static HRESULT ReadMSI5NFO(HANDLE hFile,CMSInfo5Category** ppRootCat, LPCTSTR szFilename = NULL);
	BOOL Refresh();
protected:
    HANDLE GetFileFromCab(CString strFileName);
    void SetParent(CMSInfo5Category* pParent){m_pParent = pParent;};
    void SetNextSibling(CMSInfo5Category* pSib)
    {
        m_pNextSibling = pSib;
    };
    void SetPrevSibling(CMSInfo5Category* pPrev)
    {
        m_pPrevSibling = pPrev;
    };
    void SetFirstChild(CMSInfo5Category* pChild){m_pFirstChild = pChild;};
};


//=============================================================================
// CMSInfo7Category is used to load MSInfo 7 NFO files
//=============================================================================

class CMSInfo7Category : public CMSInfoCategory
{

public:
	
    CMSInfo7Category();
    virtual ~CMSInfo7Category();
    DataSourceType GetDataSourceType() { return NFO_700; };
    void GetErrorText(CString * pstrTitle, CString * pstrMessage);
    
    // Functions specific to the subclass:
    static HRESULT ReadMSI7NFO(CMSInfo7Category** ppRootCat, LPCTSTR szFilename = NULL);
    virtual BOOL LoadFromXML(LPCTSTR szFilename);
    HRESULT WalkTree(IXMLDOMNode* node, BOOL bCreateCategory);

	// Adding this to fix the lack of sorting in opened NFO files. It's safer at this point to
	// not add anything to the NFO file (sorting information isn't saved). Instead, we'll 
	// make the assumption that every column should sort. However, if the category has only
	// two columns, AND there is a blank line in the data followed by more data, it means that
	// sorting shouldn't be allowed (as for WinSock).

	BOOL GetColumnInfo(int iColumn, CString * pstrCaption, UINT * puiWidth, BOOL * pfSorts, BOOL * pfLexical)
	{
		BOOL fReturn = CMSInfoCategory::GetColumnInfo(iColumn, pstrCaption, puiWidth, pfSorts, pfLexical);
		
		if (fReturn)
		{
			if (pfLexical != NULL)
				*pfLexical = TRUE;

			if (pfSorts != NULL)
			{
				*pfSorts = TRUE;

				// If there are two columns, and a blank line with more data to follow, don't
				// allow the sorting.

				if (2 == m_iColCount)
				{
					CString * pstrData;

					for (int iRow = 0; iRow < m_iRowCount && *pfSorts; iRow++)
						if (GetData(iRow, 0, &pstrData, NULL) && pstrData != NULL && pstrData->IsEmpty() && (iRow + 1 < m_iRowCount))
							*pfSorts = FALSE;
				}
			}
		}

		return fReturn;
	}

protected:
    void SetParent(CMSInfo7Category* pParent){m_pParent = pParent;};
    void SetNextSibling(CMSInfo7Category* pSib)
    {
        m_pNextSibling = pSib;
    };
    void SetPrevSibling(CMSInfo7Category* pPrev)
    {
        m_pPrevSibling = pPrev;
    };
    void SetFirstChild(CMSInfo7Category* pChild){m_pFirstChild = pChild;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\mspid.h ===
// MSPID.h : Declaration of the CMSPID

#ifndef __MSPID_H_
#define __MSPID_H_

#include "resource.h"       // main symbols
#include <vector>
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CMSPID
class ATL_NO_VTABLE CMSPID : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSPID, &CLSID_MSPID>,
	public IDispatchImpl<IMSPID, &IID_IMSPID, &LIBID_MSINFO32Lib>
{
public:
	CMSPID(): m_szMachineName(NULL), 
						m_szMSSoftware(_T("software\\microsoft")),
						m_szCurrKeyName(NULL),
						m_szWindowsPID(NULL),
						m_szIEPID(NULL)
	{
		m_bstrWindows.LoadString(IDS_WINDOWS);//localized "Windows"
		m_bstrIE.LoadString(IDS_IE);//localized "Internet Exporer"

		//valid PID keys/values
		m_vecPIDKeys.push_back(_T("productid"));
		m_vecPIDKeys.push_back(_T("pid"));
		
		//PIDs with these substrings are rejected 
		m_vecBadPIDs.push_back(_T("11111"));
		m_vecBadPIDs.push_back(_T("12345"));
		m_vecBadPIDs.push_back(_T("none"));

		//don't go here
		m_vecKeysToSkip.push_back(_T("Uninstall"));
		m_vecKeysToSkip.push_back(_T("Installer"));
		m_vecKeysToSkip.push_back(_T("Windows NT"));
	}

  ~CMSPID()
  {
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MSPID)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSPID)
	COM_INTERFACE_ENTRY(IMSPID)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

private:
  BOOL ReadValues(const HKEY&);
	BOOL ReadValue(const HKEY&, LPCTSTR);
	void EnumSubKeys(const HKEY&, LPCTSTR);
	void SearchKey(LPCTSTR);
	
	LPCTSTR m_szMachineName;
	LPCTSTR m_szMSSoftware;
	LPCTSTR m_szCurrKeyName;
	LPTSTR m_szWindowsPID;
	LPTSTR m_szIEPID;
	CComBSTR m_bstrWindows;
	CComBSTR m_bstrIE;
	vector<TCHAR *> m_vecPIDKeys;
	vector<TCHAR *> m_vecBadPIDs;
	vector<TCHAR *> m_vecKeysToSkip;
	vector<CComBSTR> m_vecData;

// IMSPID
public:
	STDMETHOD(GetPIDInfo)(/*[in]*/ VARIANT *, /*[out, retval]*/ VARIANT *);
};

#endif //__MSPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\mspid.cpp ===
// MSPID.cpp : Implementation of CMSPID
#include "stdafx.h"
#include "msinfo32.h"
#include "MSPID.h"

/////////////////////////////////////////////////////////////////////////////
// CMSPID

//1)  create a vector of Product Names & their PIDS.
//2)  create a safearray of variants and populate it with the values from the vector.
//3)  return a pointer to this safearray.

STDMETHODIMP CMSPID::GetPIDInfo(VARIANT *pMachineName, VARIANT *pVal)
{
	if(pMachineName->vt == VT_BSTR)
	{
		USES_CONVERSION;
		m_szMachineName = OLE2T(pMachineName->bstrVal);
	}
	
	SearchKey(m_szMSSoftware);

	if(m_szWindowsPID)
	{
		if(m_szIEPID)
		{
			//insert IE pid only if different from windows.
			if(_tcsicmp(m_szWindowsPID, m_szIEPID))
			{
				m_vecData.push_back(m_bstrIE);
				m_vecData.push_back(CComBSTR(m_szIEPID));
			}
		}

		m_vecData.push_back(m_bstrWindows);
		m_vecData.push_back(CComBSTR(m_szWindowsPID));
	}

	if(m_szWindowsPID)
	{
		delete[] m_szWindowsPID;
		m_szWindowsPID = NULL;
	}
		
	if(m_szIEPID)
	{
		delete[] m_szIEPID;
		m_szIEPID = NULL;
	}
  
  SAFEARRAY *pSa = NULL;
  SAFEARRAYBOUND rgsabound = {m_vecData.size(), 0}; 
  pSa = SafeArrayCreate(VT_VARIANT, 1, &rgsabound);
  
  VARIANT* pVar = NULL;
  SafeArrayAccessData(pSa, reinterpret_cast<void **>(&pVar));

  vector<CComBSTR>::iterator it;
  long lIdx = 0;
  for(it = m_vecData.begin(); it != m_vecData.end(); it++, lIdx++)
  {
    pVar[lIdx].vt = VT_BSTR; 
    pVar[lIdx].bstrVal = SysAllocString((*it).m_str);
  }

  SafeArrayUnaccessData(pSa); 
  
  VariantInit(pVal);
  pVal->vt = VT_ARRAY | VT_VARIANT;
  pVal->parray = pSa;
  
  return S_OK;
}

/*
1) connect to HKLM on a remote machine (trivial case is local)
2) open key "SOFTWARE\Microsoft"
3) use this key for item 4
4) if key is called "ProductID"
     get it's default value data
   else
     if key has a value called "ProductID"
	     get it's data
     else
	     while there are subkeys to enum
	     {
	       enum subkeys
         use next key for item 4
       }
*/

void CMSPID::SearchKey(LPCTSTR szKey)
{
	HKEY hkResult = NULL, hKey = NULL;
	if(ERROR_SUCCESS == RegConnectRegistry(m_szMachineName, HKEY_LOCAL_MACHINE, &hKey))
	{
		if(hKey != NULL && ERROR_SUCCESS == RegOpenKeyEx(hKey, szKey, 0, KEY_READ, &hkResult))
		{
			BOOL bMatch = FALSE;
			TCHAR *pos = _tcsrchr(szKey, '\\');
			if(pos)
				pos++;//past the "\"
			else
				pos = const_cast<TCHAR *>(szKey);	
			
			vector<TCHAR *>::iterator it;
			for(it = m_vecPIDKeys.begin(); it != m_vecPIDKeys.end(); it++)
			{
				if(!_tcsicmp(pos, *it))
				{
					bMatch = TRUE;
					break;
				}
			}

			m_szCurrKeyName = szKey;

			try
			{
				if(bMatch)
					ReadValue(hkResult, NULL);
				else
					if(!ReadValues(hkResult))
						EnumSubKeys(hkResult, szKey);
				
				RegCloseKey(hkResult);
				hkResult = NULL;
			}
			catch (...)
			{
				if (hkResult != NULL)
				{
					RegCloseKey(hkResult);
					hkResult = NULL;
				}

				if (hKey != NULL)
				{
					RegCloseKey(hKey);
					hKey = NULL;
				}
			}
		}
		
		if (hKey != NULL)
			RegCloseKey(hKey);
	}
}

BOOL CMSPID::ReadValue(const HKEY& hKey, LPCTSTR szValueName)
{
	DWORD cbData = NULL;
	TCHAR *szData = NULL;
	BOOL bMatch = FALSE;
	vector<TCHAR *>::iterator it;

	RegQueryValueEx(hKey, szValueName, NULL, NULL, (LPBYTE) szData, &cbData);
	if(cbData > 0)
	{
		szData = new TCHAR[cbData];
		ZeroMemory(szData,sizeof(szData));
		if(szData)
		{
			RegQueryValueEx(hKey, szValueName, NULL, NULL, (LPBYTE) szData, &cbData);
			bMatch = TRUE;
			
			for(it = m_vecBadPIDs.begin(); it != m_vecBadPIDs.end(); it++)
			{
				if(_tcsstr(_tcslwr(szData), *it))
				{
					bMatch = FALSE; //invalid PID
					break;
				}
			}
		}
	}
	
	if(bMatch)
	{
		TCHAR *pos1 = _tcsstr(m_szCurrKeyName, m_szMSSoftware); //The key under "Software\Microsoft" is the product name
		TCHAR *szProductName = NULL;
		if(pos1)
		{
			pos1+= _tcslen(m_szMSSoftware);
			pos1++;//past the backslash
			TCHAR *pos2 = _tcsstr(pos1, _T("\\"));
			if(pos2)
			{
				szProductName = new TCHAR[pos2 - pos1 + 1];
				if(szProductName)
				{
					_tcsncpy(szProductName, pos1, pos2 - pos1); 
					szProductName[pos2 - pos1] = '\0';
				}
			}
		}
		
		if(szProductName)
		{
			if(m_bstrWindows && !_tcsicmp(szProductName, m_bstrWindows))
			{
				m_szWindowsPID = new TCHAR[_tcslen(szData) + 1];
				if(m_szWindowsPID)
				{
					ZeroMemory(m_szWindowsPID,sizeof(m_szWindowsPID));
					//_tcsncpy(m_szWindowsPID, szData,_tcslen(szData));
					/*for some reason, _tcsncpy sometimes seems to append garbage on the end
					of strings  
					Since we've just 0'd the string, strcat should act like strcpy
					*/
					_tcsncat(m_szWindowsPID, szData,_tcslen(szData));
				}
			}
			else if(m_bstrIE && !_tcsicmp(szProductName, m_bstrIE))
			{
				m_szIEPID = new TCHAR[_tcslen(szData) + 1];
				if(m_szIEPID)
				{
					ZeroMemory(m_szIEPID,sizeof(m_szIEPID));
					//_tcsncpy(m_szIEPID, szData,_tcslen(szData));
					/*for some reason, _tcsncpy sometimes seems to append garbage on the end
					of strings  
					Since we've just 0'd the string, strcat should act like strcpy
					*/
					_tcsncat(m_szIEPID,szData,_tcslen(szData));
				}

			}
			else
			{
				m_vecData.push_back(CComBSTR(szProductName));
				m_vecData.push_back(CComBSTR(szData));
			}

			delete[] szProductName;
			szProductName = NULL;
		}
	}
		

	if(szData)
	{
		delete[] szData;
		szData = NULL;
	}
	
	return bMatch;
}

BOOL CMSPID::ReadValues(const HKEY& hKey)
{
	BOOL bRet = FALSE;
	vector<TCHAR *>::iterator it;
	for(it = m_vecPIDKeys.begin(); it != m_vecPIDKeys.end(); it++)
  {
    if(ReadValue(hKey, *it))
			break; //find just one
  }
	
	return bRet;
} 

void CMSPID::EnumSubKeys(const HKEY& hKey, LPCTSTR szKey)
{
	const LONG lMaxKeyLen = 2000;
	DWORD dwSubKeyLen = lMaxKeyLen;
	TCHAR szSubKeyName[lMaxKeyLen] = {0};
	TCHAR *szNewKey = NULL;
	DWORD dwIndex = 0;
	BOOL bSkip = FALSE;
	vector<TCHAR *>::iterator it;

	LONG lRet = RegEnumKeyEx(hKey, dwIndex++, szSubKeyName, &dwSubKeyLen, NULL, NULL, NULL, NULL);
	while(lRet == ERROR_SUCCESS)
	{
		bSkip = FALSE;
		for(it = m_vecKeysToSkip.begin(); it != m_vecKeysToSkip.end(); it++)
		{
			if(!_tcsicmp(szSubKeyName, *it))
			{
				bSkip = TRUE; //skip this subkey 
				break;
			}
		}
		
		if(!bSkip)	
		{
			//szNewKey = new TCHAR[_tcslen(szKey) + dwSubKeyLen + 2]; // slash & null
			CString szNewKey(szKey);
			if(szNewKey)
			{
				//_tcsncpy(szNewKey, szKey,_tcslen(szKey));
				szNewKey += _T("\\");
				//_tcsncat(szNewKey, _T("\\"),1);
				//_tcsncat(szNewKey, szSubKeyName,dwSubKeyLen);
				szNewKey += szSubKeyName;
				SearchKey(szNewKey);

				//delete[] szNewKey;
				//szNewKey = NULL;
			}
		}
		
		dwSubKeyLen = lMaxKeyLen;
		lRet = RegEnumKeyEx(hKey, dwIndex++, szSubKeyName, &dwSubKeyLen, NULL, NULL, NULL, NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\nfodata.cpp ===
//=============================================================================
// This file contains code to implement the CMSInfoCategory derived class for
// showing saved NFO data.
//=============================================================================

#include "stdafx.h"
#include "category.h"
#include "datasource.h"
#include "msinfo5category.h"

//=============================================================================
// CNFO6DataSource provides information from a 5.0/6.0 NFO file.
//=============================================================================

CNFO6DataSource::CNFO6DataSource()
{
}

CNFO6DataSource::~CNFO6DataSource()
{
}

HRESULT CNFO6DataSource::Create(HANDLE h, LPCTSTR szFilename)
{
	CMSInfo5Category * pNewRoot = NULL;

	HRESULT hr = CMSInfo5Category::ReadMSI5NFO(h, &pNewRoot, szFilename);
	if (SUCCEEDED(hr) && pNewRoot)
		m_pRoot = pNewRoot;

	return hr;
}

//=============================================================================
// CNFO7DataSource provides information from a 7.0 NFO file.
//=============================================================================

CNFO7DataSource::CNFO7DataSource()
{
}

CNFO7DataSource::~CNFO7DataSource()
{
}

HRESULT CNFO7DataSource::Create(LPCTSTR szFilename)
{
	CMSInfo7Category * pNewRoot = NULL;

	HRESULT hr = CMSInfo7Category::ReadMSI7NFO(&pNewRoot, szFilename);
	if (SUCCEEDED(hr) && pNewRoot)
		m_pRoot = pNewRoot;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\pseudomenu.cpp ===
//=============================================================================
// Implementation for the pseudo menu and menu bar classes used by the
// msinfo control.
//=============================================================================

#include "stdafx.h"
#include "pseudomenu.h"
#include "resource.h"

//=============================================================================
// CPseudoMenu functions.
//=============================================================================

//-----------------------------------------------------------------------------
// Constructor and destructor are really simple.
//-----------------------------------------------------------------------------

CPseudoMenu::CPseudoMenu(LPCTSTR szCaption, COLORREF crNormal, COLORREF crHighlight) : 
  m_hMenu(NULL), 
  m_strCaption(szCaption),
  m_crNormal(crNormal),
  m_crHighlight(crHighlight),
  m_fHighlight(FALSE)
{ 
	m_rect.left = m_rect.right = m_rect.top = m_rect.bottom = 0;
};

CPseudoMenu::~CPseudoMenu()
{
	if (m_hMenu)
		::DestroyMenu(m_hMenu);
}

//-----------------------------------------------------------------------------
// Get the size of this menu. We'll need the DC for this.
//-----------------------------------------------------------------------------

void CPseudoMenu::GetSize(HDC hdc, int * pcx, int * pcy)
{
	SIZE size;

	// Temporarily adding on a find button using the menu bar. This will go
	// eventually go away.
	
	CString strCaption(m_strCaption);
	if (strCaption.Left(1) == _T("\t"))
		strCaption = strCaption.Mid(1);

	if (::GetTextExtentPoint32(hdc, strCaption, strCaption.GetLength(), &size))
	{
		if (pcx)
			*pcx = size.cx + size.cy;
		if (pcy)
			*pcy = size.cy;

		m_rect.right = m_rect.left + size.cx + size.cy;
		m_rect.bottom = m_rect.top + size.cy;
	}
}

//-----------------------------------------------------------------------------
// Move the menu.
//-----------------------------------------------------------------------------

void CPseudoMenu::SetLocation(int cx, int cy) 
{ 
	int cxWidth = m_rect.right - m_rect.left;
	int cyHeight = m_rect.bottom - m_rect.top;

	m_rect.left = cx; 
	m_rect.top = cy; 
	m_rect.right = m_rect.left + cxWidth;
	m_rect.bottom = m_rect.top + cyHeight;
};

//-----------------------------------------------------------------------------
// Update the colors.
//-----------------------------------------------------------------------------

void CPseudoMenu::UpdateColors(COLORREF crNormal, COLORREF crHighlight)
{
	m_crNormal = crNormal;
	m_crHighlight = crHighlight;
}

//-----------------------------------------------------------------------------
// Change the highlight status, and return if an actual change was made.
//-----------------------------------------------------------------------------

BOOL CPseudoMenu::SetHighlight(BOOL fHighlight)
{
	BOOL fDifferent = (m_fHighlight != fHighlight);
	m_fHighlight = fHighlight; 
	return fDifferent;
}

//-----------------------------------------------------------------------------
// Draw the menu caption, using the specified highlight (indicates if the
// mouse is over the menu).
//-----------------------------------------------------------------------------

void CPseudoMenu::Render(HDC hdc)
{
	CDC dc;
	dc.Attach(hdc);

	// Temporarily adding on a find button using the menu bar. This will go
	// eventually go away.

	// Draw the menu caption.

	int cyRectHeight = m_rect.bottom - m_rect.top;
	int cySmall = (cyRectHeight - 3)/4;
	int cyMedium = (cyRectHeight - 3)/2;
	int cyTiny = (cyRectHeight - 3)/6;

	// Draw the small arrow icon.

	CBrush brush((m_fHighlight) ? m_crHighlight : m_crNormal);
	CPen pen(PS_SOLID, 1,(m_fHighlight) ? m_crHighlight : m_crNormal);
	CBrush * pOldBrush = dc.SelectObject(&brush);
	CPen * pOldPen = dc.SelectObject(&pen);

	if (m_strCaption.Left(1) != _T("\t"))
	{
		POINT aPoints[] = { {m_rect.left + cySmall, m_rect.top + cyMedium - cyTiny}, 
							{m_rect.left + cyMedium + cySmall, m_rect.top + cyMedium - cyTiny}, 
							{m_rect.left + cyMedium, m_rect.top + cyMedium + cySmall - cyTiny}};
		dc.Polygon(aPoints, 3);
	}
	else
	{
		CGdiObject * pFontOld = dc.SelectStockObject(DEFAULT_GUI_FONT);
		TEXTMETRIC metrics;
		dc.GetTextMetrics(&metrics);
		CSize size = dc.GetTextExtent(m_strCaption.Mid(1));
		dc.SelectObject(pFontOld);

		POINT aPoints[] = { {m_rect.left, m_rect.top + metrics.tmHeight}, 
							{m_rect.left + size.cx, m_rect.top + metrics.tmHeight}};
		dc.Polygon(aPoints, 2);
	}

	dc.SelectObject(pOldBrush);
	dc.SelectObject(pOldPen);

	// Temporarily adding on a find button using the menu bar. This will go
	// eventually go away.

	CString strCaption(m_strCaption);
	if (strCaption.Left(1) == _T("\t"))
		strCaption = strCaption.Mid(1);

	CGdiObject * pFontOld = dc.SelectStockObject(DEFAULT_GUI_FONT);
	COLORREF crTextOld = dc.SetTextColor((m_fHighlight) ? m_crHighlight : m_crNormal);
	int nBkModeOld = dc.SetBkMode(TRANSPARENT);
	RECT rectText;
	::CopyRect(&rectText, &m_rect);

	// The text needs to be offset over by the height (to allow for the arrow icon).
	
	if (m_strCaption.Left(1) != _T("\t"))
		rectText.left += cyRectHeight;

	dc.DrawText(strCaption, strCaption.GetLength(), &rectText, 0);
	dc.SelectObject(pFontOld);
	dc.SetTextColor(crTextOld);
	dc.SetBkMode(nBkModeOld);

	dc.Detach();
}

//-----------------------------------------------------------------------------
// Attach the new HMENU and return the existing HMENU.
//-----------------------------------------------------------------------------

HMENU CPseudoMenu::AttachMenu(HMENU hmenu)
{
	HMENU hmenuOriginal = m_hMenu;
	m_hMenu = hmenu;
	return (hmenuOriginal);
}

//-----------------------------------------------------------------------------
// Display the menu and track the user interaction with it until an item is
// selected. Return the ID of the item selected.
//-----------------------------------------------------------------------------

UINT CPseudoMenu::TrackMenu(HWND hwnd, POINT * pPoint)
{
	// Temporarily adding on a find button using the menu bar. This will go
	// eventually go away.

	if (m_strCaption.Left(1) == _T("\t"))
		return ID_EDIT_FIND;

	UINT uReturn = 0;
	const UINT uFlags = TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD | TPM_LEFTBUTTON;

	if (m_hMenu)
		uReturn = ::TrackPopupMenu(m_hMenu, uFlags, pPoint->x, pPoint->y, 0, hwnd, NULL);

	return uReturn;
}

//=============================================================================
// CPseudoMenuBar functions.
//=============================================================================

//-----------------------------------------------------------------------------
// Constructor and destructor.
//-----------------------------------------------------------------------------

CPseudoMenuBar::CPseudoMenuBar()
{
	m_rect.left = m_rect.right = m_rect.top = m_rect.bottom = 0;
	for (int i = 0; i < MaxMenus; i++)
		m_pmenus[i] = NULL;
	m_ptOrigin.x = m_ptOrigin.y = 5;
}

CPseudoMenuBar::~CPseudoMenuBar()
{
	for (int i = 0; i < MaxMenus; i++)
		if (m_pmenus[i])
			delete m_pmenus[i];
}

//-----------------------------------------------------------------------------
// Load the menu specified by the resource ID.
//-----------------------------------------------------------------------------

void CPseudoMenuBar::LoadFromResource(HINSTANCE hinstance, UINT uResourceID, COLORREF crNormal, COLORREF crHighlight)
{
	HMENU hmenu = ::LoadMenu(hinstance, MAKEINTRESOURCE(uResourceID));
	if (hmenu)
	{
		try
		{
			TCHAR szBuffer[MAX_PATH] = _T("");
			MENUITEMINFO mii;
			int index = 0;

			mii.cbSize = sizeof(MENUITEMINFO);
			mii.fMask = MIIM_TYPE;
			mii.dwTypeData = szBuffer;

			HMENU hmenuSub = ::GetSubMenu(hmenu, 0);
			while (hmenuSub && index < MaxMenus)
			{
				mii.cch = MAX_PATH;
				GetMenuItemInfo(hmenu, 0, TRUE, &mii);

				CPseudoMenu * pMenu = new CPseudoMenu(szBuffer, crNormal, crHighlight);
				pMenu->AttachMenu(hmenuSub);
				InsertMenu(index++, pMenu);
				::RemoveMenu(hmenu, 0, MF_BYPOSITION);

				hmenuSub = ::GetSubMenu(hmenu, 0);
			}

			// Temporarily adding on a find button using the menu bar. This will go
			// eventually go away. With 196808, it has.
			//	
			//	{
			//		CString strFindButton;
			//
			//		::AfxSetResourceHandle(_Module.GetResourceInstance());
			//		strFindButton.LoadString(IDS_FINDBUTTONCAP);
			//		strFindButton = CString(_T("\t")) + strFindButton;
			//		CPseudoMenu * pFind = new CPseudoMenu(strFindButton, crNormal, crHighlight);
			//		InsertMenu(index++, pFind);
			//	}

			::DestroyMenu(hmenu);
		}
		catch (...)
		{
			::DestroyMenu(hmenu);
		}
	}
}

//-----------------------------------------------------------------------------
// Update the colors for each individual menu.
//-----------------------------------------------------------------------------

void CPseudoMenuBar::UpdateColors(COLORREF crNormal, COLORREF crHighlight)
{
	for (int index = 0; index < MaxMenus; index++)
		if (m_pmenus[index])
			m_pmenus[index]->UpdateColors(crNormal, crHighlight);
}

//-----------------------------------------------------------------------------
// Insert the pseudo menu into the indicated index.
//-----------------------------------------------------------------------------

void CPseudoMenuBar::InsertMenu(int index, CPseudoMenu * pMenu)
{
	if (index >= 0 && index < MaxMenus)
	{
		if (m_pmenus[index])
			delete m_pmenus[index];
		m_pmenus[index] = pMenu;
		m_fNeedToComputeRect = TRUE;
	}
}

//-----------------------------------------------------------------------------
// Return a pointer to the requested pseudo menu.
//-----------------------------------------------------------------------------

CPseudoMenu * CPseudoMenuBar::GetMenu(int index)
{
	return (index >= 0 && index < MaxMenus) ? m_pmenus[index] : NULL;
}

//-----------------------------------------------------------------------------
// Get the point from which the menu should be launched. This will be
// converted into screen coordinates for the call to TrackMenu. An
// alternative version takes coordinates instead of an index.
//-----------------------------------------------------------------------------

void CPseudoMenuBar::GetMenuPoint(HDC hdc, int index, POINT * pPoint)
{
	RecomputeRect(hdc);
	if (index >= 0 && index < MaxMenus && m_pmenus[index])
		m_pmenus[index]->GetMenuPoint(pPoint);
}

void CPseudoMenuBar::GetMenuPoint(HDC hdc, int cx, int cy, POINT * pPoint)
{
	RecomputeRect(hdc);
	for (int i = 0; i < MaxMenus; i++)
		if (m_pmenus[i] && m_pmenus[i]->HitTest(cx, cy))
		{
			m_pmenus[i]->GetMenuPoint(pPoint);
			break;
		}
}

//-----------------------------------------------------------------------------
// Given the coordinates, determine if one of the menus should be drawn with
// a highlight. If the state of one or more menus changes, return TRUE so the
// caller knows the menu bar needs to be re-rendered.
//-----------------------------------------------------------------------------

BOOL CPseudoMenuBar::TrackHighlight(HDC hdc, int cx, int cy)
{
	BOOL fReturn = FALSE;

	RecomputeRect(hdc);
	for (int i = 0; i < MaxMenus; i++)
		if (m_pmenus[i])
			fReturn |= m_pmenus[i]->SetHighlight(m_pmenus[i]->HitTest(cx, cy));

	return fReturn;
}

//-----------------------------------------------------------------------------
// Set the menu bar so that none of the items are highlighted. Return whether
// we need to be repainted.
//-----------------------------------------------------------------------------

BOOL CPseudoMenuBar::NoHighlight()
{
	BOOL fReturn = FALSE;

	for (int i = 0; i < MaxMenus; i++)
		if (m_pmenus[i])
			fReturn |= m_pmenus[i]->SetHighlight(FALSE);

	return fReturn;
}

//-----------------------------------------------------------------------------
// This is used to actually display the menu and allow the user to choose an
// option from it. The pPoint parameter is the screen point for the menu
// display. The cx and cy parameters are the local coordinates used to find
// the correct menu to show.
//-----------------------------------------------------------------------------

UINT CPseudoMenuBar::TrackMenu(HWND hwnd, POINT * pPoint, int cx, int cy)
{
	for (int i = 0; i < MaxMenus; i++)
		if (m_pmenus[i] && m_pmenus[i]->HitTest(cx, cy))
			return m_pmenus[i]->TrackMenu(hwnd, pPoint);
	return 0;
}

//-----------------------------------------------------------------------------
// Set the origin for the display of the menu bar.
//-----------------------------------------------------------------------------

void CPseudoMenuBar::SetOrigin(HDC hdc, POINT point)
{
	m_ptOrigin = point;
	m_fNeedToComputeRect = TRUE;
	RecomputeRect(hdc);
}

//-----------------------------------------------------------------------------
// Rendering the menu bar consists of rendering each menu.
//-----------------------------------------------------------------------------

void CPseudoMenuBar::Render(HDC hdc)
{
	RecomputeRect(hdc);

	for (int i = 0; i < MaxMenus; i++)
		if (m_pmenus[i])
			m_pmenus[i]->Render(hdc);
}

//-----------------------------------------------------------------------------
// A private function used to place all the menus, and compute the bounding
// rectangle.
//-----------------------------------------------------------------------------

void CPseudoMenuBar::RecomputeRect(HDC hdc)
{
	if (!m_fNeedToComputeRect)
		return;
	m_fNeedToComputeRect = FALSE;

	int cx = 0, cy = 0;
	int cxCurrent = m_ptOrigin.x;

	for (int i = 0; i < MaxMenus; i++)
		if (m_pmenus[i])
		{
			// Temporarily adding on a find button using the menu bar. This will go
			// eventually go away.

			if (m_pmenus[i]->GetCaption().Left(1) == _T("\t"))
			{
				// Move the button over to the right.

				CDC dc;
				dc.Attach(hdc);
				CGdiObject * pFontOld = dc.SelectStockObject(DEFAULT_GUI_FONT);
				CString strCaption = m_pmenus[i]->GetCaption().Mid(1);
				CSize sizeText = dc.GetTextExtent(strCaption);
				dc.SelectObject(pFontOld);
				if ((m_winRect.right - sizeText.cx - 5) > cxCurrent)
					cxCurrent = m_winRect.right - sizeText.cx - 5;
				m_pmenus[i]->SetLocation(cxCurrent, m_ptOrigin.y);
				m_pmenus[i]->GetSize(hdc, &cx, &cy);
				cxCurrent += cx;
				dc.Detach();
				continue;
			}

			m_pmenus[i]->SetLocation(cxCurrent, m_ptOrigin.y);
			m_pmenus[i]->GetSize(hdc, &cx, &cy);
			cxCurrent += cx;
		}

	::SetRect(&m_rect, m_ptOrigin.x, m_ptOrigin.y, m_ptOrigin.x + cxCurrent - 5, m_ptOrigin.y + cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\refreshdialog.h ===
#if !defined(AFX_REFRESHDIALOG_H__35CE7EBD_E518_4734_872E_D234A892E49E__INCLUDED_)
#define AFX_REFRESHDIALOG_H__35CE7EBD_E518_4734_872E_D234A892E49E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// refreshdialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRefreshDialog dialog

class CRefreshDialog : public CDialog
{
// Construction
public:
	CRefreshDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRefreshDialog)
	enum { IDD = IDD_REFRESHDIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRefreshDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRefreshDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REFRESHDIALOG_H__35CE7EBD_E518_4734_872E_D234A892E49E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\pseudomenu.h ===
//=============================================================================
// This file contains definitions of classes to implement the pseudo menus
// and menu bars for the msinfo control.
//=============================================================================

#pragma once

//-----------------------------------------------------------------------------
// This class implements a single pseudo-menu on the screen. Caller should
// construct it, attach an HMENU and use Render, HitTest and TrackMenu
// to manage the menu.
//-----------------------------------------------------------------------------

class CPseudoMenu
{
public:
	CPseudoMenu(LPCTSTR szCaption, COLORREF crNormal, COLORREF crHighlight);
	~CPseudoMenu();

public:
	// Methods for setting the location for this menu (by the upper left
	// corner) and getting the bounding rectangle for the label.

	void			SetLocation(int cx, int cy);
	void			GetSize(HDC hdc, int * pcx, int * pcy);
	const RECT *	GetRect() { return &m_rect; };
	void			GetMenuPoint(POINT * pPoint) { pPoint->x = m_rect.left; pPoint->y = m_rect.bottom; };
	CString			GetCaption() { return m_strCaption; };
	void			UpdateColors(COLORREF crNormal, COLORREF crHighlight);

	// Render the label for the menu (possibly highlighted if the mouse
	// is over the menu). Determine if the given coordinate intersects
	// the menu label.

	BOOL	SetHighlight(BOOL fHighlight);
	void	Render(HDC hdc);
	BOOL	HitTest(int cx, int cy) { return PtInRect(&m_rect, CPoint(cx, cy)); };

	// Attach new HMENU. Return the original HMENU (for the caller to deal with).

	HMENU	AttachMenu(HMENU hmenu);
	HMENU	GetHMENU() { return m_hMenu; };

	// Track the user's selection of a menu, and return the ID of the
	// selected item.

	UINT	TrackMenu(HWND hwnd, POINT * pPoint);

private:
	RECT		m_rect;
	HMENU		m_hMenu;
	CString		m_strCaption;
	COLORREF	m_crNormal;
	COLORREF	m_crHighlight;
	BOOL		m_fHighlight;
};

//-----------------------------------------------------------------------------
// This class implements a pseudo menu bar. It contains a collection of
// CPseudoMenu objects, and encapsulates hit testing, rendering, etc. for the
// group of menus.
//-----------------------------------------------------------------------------

class CPseudoMenuBar
{
public:
	CPseudoMenuBar();
	~CPseudoMenuBar();

	// Functions for inserting and accessing CPseudoMenu objects.

	void			LoadFromResource(HINSTANCE hinstance, UINT uResourceID, COLORREF crNormal, COLORREF crHighlight);
	void			InsertMenu(int index, CPseudoMenu * pMenu);
	CPseudoMenu *	GetMenu(int index);
	void			UpdateColors(COLORREF crNormal, COLORREF crHighlight);

	// Functions for managing the size of the total menu bar, testing for
	// hits, rendering, etc.

	const RECT *	GetRect(HDC hdc) { RecomputeRect(hdc); return &m_rect; };
	BOOL			HitTest(HDC hdc, int cx, int cy) { RecomputeRect(hdc); return PtInRect(&m_rect, CPoint(cx, cy)); };
	void			GetMenuPoint(HDC hdc, int index, POINT * pPoint);
	void			GetMenuPoint(HDC hdc, int cx, int cy, POINT * pPoint);
	BOOL			NoHighlight();
	BOOL			TrackHighlight(HDC hdc, int cx, int cy);
	UINT			TrackMenu(HWND hwnd, POINT * pPoint, int cx, int cy);
	void			SetOrigin(HDC hdc, POINT point);
	void			Render(HDC hdc);

private:
	void			RecomputeRect(HDC hdc);

private:
	enum { MaxMenus = 20 };
	CPseudoMenu *	m_pmenus[MaxMenus];	// TBD - arbitrary limit
	RECT			m_rect;
	BOOL			m_fNeedToComputeRect;
	POINT			m_ptOrigin;

public:
	// Temporarily adding on a find button using the menu bar. This will go
	// eventually go away.

	RECT			m_winRect;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\refreshthread.h ===
//=============================================================================
// Define the classes and functions used to manage threaded WMI refreshes.
//=============================================================================

#pragma once

#include "category.h"

class CRefreshThread
{
	friend DWORD WINAPI ThreadRefresh(void * pArg);
public:
	CRefreshThread(HWND hwnd);
	~CRefreshThread();

	void StartRefresh(CMSInfoLiveCategory * pCategory, BOOL fRecursive = FALSE, BOOL fForceRefresh = FALSE);
	void CancelRefresh();
	void KillRefresh();
	BOOL IsRefreshing();
	BOOL WaitForRefresh();
	void EnterCriticalSection() { ::EnterCriticalSection(&m_criticalsection); };
	void LeaveCriticalSection() { ::LeaveCriticalSection(&m_criticalsection); };

	BOOL GetForceRefresh() { return m_fForceRefresh; };

	HRESULT CheckWMIConnection();
	void GetRefreshStatus(LONG * pCount, CString * pstrCurrent) 
	{ 
		::EnterCriticalSection(&m_csCategoryRefreshing);
		*pCount = m_nCategoriesRefreshed; 
		*pstrCurrent = m_strCategoryRefreshing;
		::LeaveCriticalSection(&m_csCategoryRefreshing);
	};

public:
	CMSInfoLiveCategory *	m_pcategory;		// category to refresh
	CString					m_strMachine;		// machine from which to gather data

protected:
	volatile BOOL			m_fCancel;			// cancel the current refresh, stay in thread
	volatile BOOL			m_fQuit;			// exit the thread
	volatile BOOL			m_fRecursive;		// refresh categories recursively
	volatile BOOL			m_fForceRefresh;	// if TRUE, refigure all the cached data
	volatile LONG			m_nCategoriesRefreshed;  // number of categories refreshed
	
	CString					m_strCategoryRefreshing; // category currently being refreshed
	CRITICAL_SECTION		m_csCategoryRefreshing;	 // critical section to guard the string

	HANDLE					m_eventDone;		// refresh thread fires when done
	HANDLE					m_eventStart;		// main thread fires when more data
	CRITICAL_SECTION		m_criticalsection;

	HRESULT					m_hresult;
	HRESULT					m_hrWMI;

	HWND					m_hwnd;

	HANDLE					m_hThread;
	DWORD					m_dwThreadID;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\refreshthread.cpp ===
//=============================================================================
// Code used to manage threaded WMI refreshes.
//=============================================================================

#include "stdafx.h"
#include "refreshthread.h"
#include "wmilive.h"

//-----------------------------------------------------------------------------
// The constructor - create the events to manage the refresh thread.
//-----------------------------------------------------------------------------

CRefreshThread::CRefreshThread(HWND hwnd) :
 m_fCancel(FALSE), m_fQuit(FALSE), m_fRecursive(FALSE), m_fForceRefresh(FALSE), m_pcategory(NULL),
 m_hThread(NULL), m_dwThreadID(0), m_hwnd(hwnd), m_hrWMI(E_FAIL)
{
	// Generate a system wide unique name for the events (in case there are multiple
	// instances of MSInfo running). If we can't generate a GUID for this, use the tick count.

	CString strEvent(_T(""));
	GUID	guid;

	if (SUCCEEDED(::CoCreateGuid(&guid)))
	{
		LPOLESTR lpGUID;

		if (SUCCEEDED(StringFromCLSID(guid, &lpGUID)))
		{
			strEvent = lpGUID;
			CoTaskMemFree(lpGUID);
		}
	}

	if (strEvent.IsEmpty())
		strEvent.Format(_T("%08x"), ::GetTickCount());

	m_eventDone  = CreateEvent(NULL, TRUE, TRUE, CString(_T("MSInfoDone")) + strEvent);
	m_eventStart = CreateEvent(NULL, TRUE, FALSE, CString(_T("MSInfoStart")) + strEvent);

	::InitializeCriticalSection(&m_criticalsection);
	::InitializeCriticalSection(&m_csCategoryRefreshing);
}

//-----------------------------------------------------------------------------
// The destructor should stop a refresh and get rid of the events.
//-----------------------------------------------------------------------------

CRefreshThread::~CRefreshThread()
{
	KillRefresh();
	DeleteCriticalSection(&m_criticalsection);
	DeleteCriticalSection(&m_csCategoryRefreshing);
	CloseHandle(m_eventDone);
	CloseHandle(m_eventStart);
}

//-----------------------------------------------------------------------------
// Start the refresh thread for the specified category.
//-----------------------------------------------------------------------------

DWORD WINAPI ThreadRefresh(void * pArg);
void CRefreshThread::StartRefresh(CMSInfoLiveCategory * pCategory, BOOL fRecursive, BOOL fForceRefresh)
{
	CancelRefresh();

	m_fRecursive = fRecursive;
	m_fForceRefresh = fForceRefresh;
	m_pcategory = pCategory;
	m_fCancel = FALSE;
	m_nCategoriesRefreshed = 0;

	if (m_hThread == NULL)
	{
		::ResetEvent(m_eventDone);
		::ResetEvent(m_eventStart);
		m_hThread = ::CreateThread(NULL, 0, ThreadRefresh, (LPVOID) this, 0, &m_dwThreadID);
	}
	else
	{
		::ResetEvent(m_eventDone);
		::SetEvent(m_eventStart);
	}
}

//-----------------------------------------------------------------------------
// Cancel the refresh in progress.
//-----------------------------------------------------------------------------

void CRefreshThread::CancelRefresh()
{
	m_fCancel = TRUE;
	WaitForRefresh();
}

//-----------------------------------------------------------------------------
// Kill the refresh thread.
//-----------------------------------------------------------------------------

BOOL gfEndingSession = FALSE;
void CRefreshThread::KillRefresh()
{
	// If we're exiting normally, allow 30 seconds to finish WMI business, if
	// the Windows session is ending, allow 5 seconds.

	DWORD dwTimeout = (gfEndingSession) ? 5000 : 30000;

	// Cancel the refresh, passing in the shorter timeout.

	m_fCancel = TRUE;
	if (IsRefreshing())
		::WaitForSingleObject(m_eventDone, dwTimeout);

	// Tell the thread to quit, wait the timeout to see if it does so before
	// terminating it.

	m_fQuit = TRUE;
	m_fCancel = TRUE;
	::SetEvent(m_eventStart);
	if (WAIT_TIMEOUT == ::WaitForSingleObject(m_hThread, dwTimeout))
		::TerminateThread(m_hThread, 0);

	::CloseHandle(m_hThread);
	m_hThread = NULL;
}

//-----------------------------------------------------------------------------
// Is there currently a refresh going on?
//-----------------------------------------------------------------------------

BOOL CRefreshThread::IsRefreshing()
{
	return (WAIT_TIMEOUT == ::WaitForSingleObject(m_eventDone, 0));
}

//-----------------------------------------------------------------------------
// Wait for the current refresh to finish.
//-----------------------------------------------------------------------------

BOOL CRefreshThread::WaitForRefresh()
{
	if (IsRefreshing())
		return (WAIT_TIMEOUT != ::WaitForSingleObject(m_eventDone, 600000));

	return TRUE;
}

//-----------------------------------------------------------------------------
// Check the WMI connection to the named computer. Useful for remoting.
//-----------------------------------------------------------------------------

HRESULT CRefreshThread::CheckWMIConnection()
{
	HWND hwndTemp = m_hwnd;

	m_pcategory = NULL;
	m_hwnd = NULL;

	if (m_hThread == NULL)
	{
		::ResetEvent(m_eventDone);
		::ResetEvent(m_eventStart);
		m_hThread = ::CreateThread(NULL, 0, ThreadRefresh, (LPVOID) this, 0, &m_dwThreadID);
	}

	WaitForRefresh();
	m_hwnd = hwndTemp;
	return m_hrWMI;
}

//-----------------------------------------------------------------------------
// This code runs in the worker thread which does the WMI queries. When it
// starts, it creates the WMI objects it will use. It then loops, doing
// the refreshes, until it's told to quit.
//
// TBD - need to know when to get rid of cached data.
//-----------------------------------------------------------------------------

DWORD WINAPI ThreadRefresh(void * pArg)
{
	CRefreshThread * pParent = (CRefreshThread *) pArg;
	if (pParent == NULL)
		return 0;

	CoInitialize(NULL);

	// TBD

	CWMILiveHelper * pWMI = new CWMILiveHelper();
	HRESULT hrWMI = E_FAIL;
	if (pWMI)
		hrWMI = pWMI->Create(pParent->m_strMachine);
	pParent->m_hrWMI = hrWMI;

	CMapPtrToPtr			mapRefreshFuncToData;
	CPtrList				lstCategoriesToRefresh;
	CMSInfoLiveCategory *	pLiveCategory;
	CMSInfoLiveCategory *	pChild;
	HRESULT					hr;
	CString					strCaption;

	// Loop until it's indicated we should quit.

	while (!pParent->m_fQuit)
	{
		// If there's a category pointer, then refresh the data for that category.
		
		if (pParent->m_pcategory)
		{
			ASSERT(lstCategoriesToRefresh.IsEmpty());
			
			// We use a list of categories to refresh (this allows us to do recursive refreshes).
			// If the refresh isn't recursive, only one category will be put in the list.

			lstCategoriesToRefresh.AddHead((void *) pParent->m_pcategory);
			while (!lstCategoriesToRefresh.IsEmpty())
			{
				pLiveCategory = (CMSInfoLiveCategory *) lstCategoriesToRefresh.RemoveHead();
				if (pLiveCategory == NULL)
					continue;

				// Update the progress information on a multi-category refresh operation.
				// This includes the number of categories refreshed and the name of the
				// currently refreshing category (which is guarded by a critical section).

				pLiveCategory->GetNames(&strCaption, NULL);
				::EnterCriticalSection(&pParent->m_csCategoryRefreshing);
				pParent->m_nCategoriesRefreshed += 1;
				pParent->m_strCategoryRefreshing = strCaption;
				::LeaveCriticalSection(&pParent->m_csCategoryRefreshing);

				if (pLiveCategory->m_iColCount && pLiveCategory->m_pRefreshFunction)
				{
					// Refresh the data.

					pLiveCategory->m_hrError = S_OK;

					if (FAILED(hrWMI))
					{
						pLiveCategory->m_hrError = hrWMI;
						pLiveCategory->m_dwLastRefresh = ::GetTickCount();
					}
					else if (pLiveCategory->m_pRefreshFunction)
					{
						// Allocate the array of pointer lists which will contain the results
						// of this refresh. Each pointer in the list will refer to a CMSIValue.

						CPtrList * aptrList = new CPtrList[pLiveCategory->m_iColCount];
						if (aptrList)
						{
							// Retrieve any refresh function specific storage that may have been created.

							void * pRefreshData;
							if (!mapRefreshFuncToData.Lookup((void *)pLiveCategory->m_pRefreshFunction, pRefreshData))
								pRefreshData = NULL;

							// Call the refresh function for this category, with the refresh index.

							hr = pLiveCategory->m_pRefreshFunction(pWMI,
																   pLiveCategory->m_dwRefreshIndex,
																   &pParent->m_fCancel,
																   aptrList,
																   pLiveCategory->m_iColCount,
																   &pRefreshData);
							pLiveCategory->m_hrError = hr;

							// If the refresh function allocated some storage, save it.

							if (pRefreshData)
								mapRefreshFuncToData.SetAt((void *)pLiveCategory->m_pRefreshFunction, pRefreshData);

							// If a long refresh time is needed for testing, uncomment the following:
							//
							// ::Sleep(5000 /* milliseconds */);

							if (!pParent->m_fCancel && SUCCEEDED(pLiveCategory->m_hrError))
							{
								// Get the number of rows of data.

								int iRowCount = (int)aptrList[0].GetCount();

	#ifdef _DEBUG
								for (int i = 0; i < pLiveCategory->m_iColCount; i++)
									ASSERT(iRowCount == aptrList[i].GetCount());
	#endif

								// Update the category's current data. This has to be done in a
								// critical section, since the main thread accesses this data.

								pParent->EnterCriticalSection();

								pLiveCategory->DeleteContent();
								if (iRowCount)
									pLiveCategory->AllocateContent(iRowCount);

								for (int j = 0; j < pLiveCategory->m_iColCount; j++)
									for (int i = 0; i < pLiveCategory->m_iRowCount; i++)
										if (!aptrList[j].IsEmpty())
										{
											CMSIValue * pValue = (CMSIValue *) aptrList[j].RemoveHead();
											pLiveCategory->SetData(i, j, pValue->m_strValue, pValue->m_dwValue);
											
											// Set the advanced flag for either the first column, or
											// for any column which is advanced (any cell in a row
											// being advanced makes the whole row advanced).

											if (j == 0 || pValue->m_fAdvanced)
												pLiveCategory->SetAdvancedFlag(i, pValue->m_fAdvanced);

											delete pValue;
										}

								pParent->LeaveCriticalSection();

								// Record the time this refresh was done.

								pParent->m_pcategory->m_dwLastRefresh = ::GetTickCount();
							}
							else
							{
								// The refresh was cancelled or had an error - delete the new data. If the 
								// refresh had an error, record the time the refresh was attempted.

								if (FAILED(pLiveCategory->m_hrError))
									pParent->m_pcategory->m_dwLastRefresh = ::GetTickCount();
							}

							for (int iCol = 0; iCol < pLiveCategory->m_iColCount; iCol++)
								while (!aptrList[iCol].IsEmpty())	// shouldn't be true unless refresh cancelled
									delete (CMSIValue *) aptrList[iCol].RemoveHead();
							delete [] aptrList;
						}
					}
				}
				else
				{
					pParent->m_pcategory->m_dwLastRefresh = ::GetTickCount();
				}

				// If this is a recursive refresh, then we should add all of the children of this
				// category to the list of categories to be refreshed.

				if (pParent->m_fRecursive)
				{
					pChild = (CMSInfoLiveCategory *) pLiveCategory->GetFirstChild();
					while (pChild)
					{
						lstCategoriesToRefresh.AddTail((void *) pChild);
						pChild = (CMSInfoLiveCategory *) pChild->GetNextSibling();
					}
				}
			} // while
		}
		else if (pParent->m_pcategory)
		{
			// Record the time this refresh was done.

			pParent->m_pcategory->m_dwLastRefresh = ::GetTickCount();
		}

		// Signal the parent window that there's new data ready to be displayed.
		// Do this even if cancelled, so old data will be shown.

		if (pParent->m_hwnd && !pParent->m_fCancel)
			::PostMessage(pParent->m_hwnd, WM_MSINFODATAREADY, 0, (LPARAM)pParent->m_pcategory);

		::SetEvent(pParent->m_eventDone);

		// Go to sleep until it's time to return to work.

		::WaitForSingleObject(pParent->m_eventStart, INFINITE);
		::ResetEvent(pParent->m_eventStart);
		::ResetEvent(pParent->m_eventDone);
	}

	// Deallocate an cached stuff saved by the refresh functions.

	RefreshFunction	pFunc;
	void *			pCache;

	for (POSITION pos = mapRefreshFuncToData.GetStartPosition(); pos;)
	{
		mapRefreshFuncToData.GetNextAssoc(pos, (void * &)pFunc, pCache);
		if (pFunc)
			pFunc(NULL, 0, NULL, NULL, 0, &pCache);
	}
	mapRefreshFuncToData.RemoveAll();

	if (pWMI)
		delete pWMI;
	CoUninitialize();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\remotedialog.cpp ===
// remotedialog.cpp : Implementation of CRemoteDialog
#include "stdafx.h"
#include "remotedialog.h"

/////////////////////////////////////////////////////////////////////////////
// CRemoteDialog

/////////////////////////////////////////////////////////////////////////////
// CRemoteDialog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\remotedialog.h ===
// remotedialog.h : Declaration of the CRemoteDialog

#ifndef __REMOTEDIALOG_H_
#define __REMOTEDIALOG_H_

#include "resource.h"       // main symbols
#include <atlhost.h>
#include <richedit.h>

/////////////////////////////////////////////////////////////////////////////
// CRemoteDialog
class CRemoteDialog : 
	public CAxDialogImpl<CRemoteDialog>
{
public:
	CRemoteDialog() : m_strMachine(_T("")), m_fRemote(FALSE), m_hwndParent(NULL)
	{
	}

	~CRemoteDialog()
	{
	}

	enum { IDD = IDD_REMOTEDIALOG };

BEGIN_MSG_MAP(CRemoteDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_HANDLER(IDC_NETWORKCOMPUTER, BN_CLICKED, OnClickedNetworkComputerButton)
	COMMAND_HANDLER(IDC_LOCALSYSTEM, BN_CLICKED, OnClickedLocalSystemButton)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
	CString		m_strMachine;
	BOOL		m_fRemote;
	HWND		m_hwndParent;

	CWindow		m_wndMachineName, m_wndMachineNameLabel;

public:
	void SetRemoteDialogValues(HWND hwndParent, BOOL fRemote, LPCTSTR szMachine)
	{
		m_strMachine = szMachine;
		m_fRemote = fRemote;
		m_hwndParent = hwndParent;
	}

	void GetRemoteDialogValues(BOOL * pfRemote, CString * pstrMachine)
	{
		if (pfRemote)
			*pfRemote = m_fRemote;

		if (pstrMachine)
			*pstrMachine = m_strMachine;
	}

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		m_wndMachineName.Attach(GetDlgItem(IDC_NETWORKNAME));
		m_wndMachineNameLabel.Attach(GetDlgItem(IDC_NETNAMELABEL));

		m_wndMachineName.SendMessage(EM_SETTEXTMODE, TM_PLAINTEXT, 0);

		SetDlgItemText(IDC_NETWORKNAME, m_strMachine);
		if (m_fRemote)
			CheckRadioButton(IDC_LOCALSYSTEM, IDC_NETWORKCOMPUTER, IDC_NETWORKCOMPUTER);
		else
		{
			m_wndMachineName.EnableWindow(FALSE);
			m_wndMachineNameLabel.EnableWindow(FALSE);
			CheckRadioButton(IDC_LOCALSYSTEM, IDC_NETWORKCOMPUTER, IDC_LOCALSYSTEM);
		}

		CenterWindow(m_hwndParent);
		return 1;  // Let the system set the focus
	}

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		// Get the machine name from the rich edit control (use EM_GETTEXTEX
		// to preserve its Unicode-ness).

		TCHAR		szBuffer[MAX_PATH];
		GETTEXTEX	gte;

		gte.cb				= MAX_PATH;
		gte.flags			= GT_DEFAULT;
		gte.codepage		= 1200; // Unicode
		gte.lpDefaultChar	= NULL;
		gte.lpUsedDefChar	= NULL;
		m_wndMachineName.SendMessage(EM_GETTEXTEX, (WPARAM)&gte, (LPARAM)szBuffer);
		m_strMachine = szBuffer;

		EndDialog(wID);
		return 0;
	}

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		m_wndMachineName.GetWindowText(m_strMachine.GetBuffer(MAX_PATH), MAX_PATH);
		m_strMachine.ReleaseBuffer();

		EndDialog(wID);
		return 0;
	}

	LRESULT OnClickedNetworkComputerButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		UpdateMachineFieldState();
		return 0;
	}

	LRESULT OnClickedLocalSystemButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		UpdateMachineFieldState();
		return 0;
	}

	void UpdateMachineFieldState()
	{
		m_fRemote = (IsDlgButtonChecked(IDC_NETWORKCOMPUTER) == BST_CHECKED);
		m_wndMachineName.EnableWindow(m_fRemote);
		m_wndMachineNameLabel.EnableWindow(m_fRemote);
	}
};

#endif //__REMOTEDIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msinfo32.rc
//
#define IDSTOPFIND                      3
#define IDNEWSEARCH                     4
#define IDCANCELFIND                    4
#define IDFINDNEXT                      5
#define IDS_PROJNAME                    100
#define IDS_OPENFILTER                  101
#define IDB_MSINFO                      102
#define IDS_DEFAULTEXTENSION            102
#define IDR_MSINFO                      103
#define IDS_REFRESHMESSAGE              103
#define IDD_MSINFO                      104
#define IDS_SAVEFILTER                  104
#define IDS_SELECTCATEGORY              105
#define IDS_EXPORTFILTER                106
#define IDS_DEFAULTEXPORTEXTENSION      107
#define IDS_CANTCOLLECT                 108
#define IDS_OUTOFMEMERROR               109
#define IDS_GATHERACCESS                110
#define IDS_GATHERACCESS_LOCAL          111
#define IDS_BADSERVER                   112
#define IDS_BADSERVER_LOCAL             113
#define IDS_NETWORKERROR                114
#define IDS_NETWORKERROR_LOCAL          115
#define IDS_UNEXPECTED                  116
#define IDS_SYSTEMINFO                  117
#define IDR_TEST                        119
#define IDR_MENUBAR                     201
#define IDC_TREE                        201
#define IDC_LIST                        202
#define IDD_FINDDIALOG                  203
#define IDC_EDITFINDWHAT                203
#define IDD_REMOTEDIALOG                203
#define IDC_CHECKSEARCHSELECTED         204
#define IDD_REFRESHDIALOG               204
#define IDC_CHECKSEARCHCATSONLY         205
#define IDD_ABOUTBOX                    205
#define IDC_REFRESHMESSAGE              207
#define IDC_FINDWHATLABEL               208
#define IDD_WAITFORREFRESHDIALOG        208
#define IDSTARTFIND                     209
#define IDR_ACCELERATOR1                209
#define IDC_SYSINFOSOURCE               211
#define IDC_LOCALSYSTEM                 212
#define IDC_NETWORKCOMPUTER             213
#define IDC_NETNAMELABEL                214
#define IDC_NETWORKNAME                 215
#define IDC_HISTORYCOMBO                217
#define IDC_HISTORYLABEL                218
#define IDC_REFRESHPROGRESS             219
#define IDC_REFRESHCAT                  220
#define IDS_BYTES                       334
#define IDS_KB                          335
#define IDS_MB                          336
#define IDS_GB                          337
#define IDS_TB                          338
#define IDS_ERROR_NOVALUE               339
#define IDS_ERROR_NOPROPERTY            340
#define IDS_NOOCX                       341
#define IDS_NOOCXDETAIL                 342
#define IDS_NOMOREMATCHES               343
#define IDS_CANCELFIND                  344
#define IDS_CLOSEFIND                   345
#define IDS_FINDNEXT                    346
#define IDS_FINDBUTTON                  347
#define IDS_SEARCHMESSAGE               348
#define IDS_ONLYINHELPCTR               349
#define IDS_BADCABFILE                  350
#define IDS_VERSION5YES                 351
#define IDS_VERSION5NO                  352
#define IDS_SIZEBYTES                   353
#define IDS_SIZEKB_BYTES                354
#define IDS_SIZEMB_BYTES                355
#define IDS_SIZEGB_BYTES                356
#define IDS_SIZEKB                      357
#define IDS_UNKNOWNFILETYPE             358
#define IDS_DAYSAGO                     359
#define IDS_REMOTEERRORLOCAL            360
#define IDS_REMOTEERRORREMOTE           361
#define IDS_DELTACHANGE                 362
#define IDS_DELTANOCHANGES              363
#define IDS_XMLEXTENSION                364
#define IDS_XMLSAVEFILTER               365
#define IDS_XMLSAVEERR                  366
#define IDS_OPENXMLFILTER               367
#define IDS_XMLNOTPCHHEALTH             368
#define IDS_REFRESHHISTORYMESSAGE       369
#define IDS_CABTXTTOOL                  370
#define IDS_FAULTLOG                    371
#define IDS_SYSTEMRESTORE               372
#define IDS_SAVEBOTHFILTER              373
#define IDS_WMICONTROL                  374
#define IDS_HISTORYADDED                375
#define IDS_HISTORYREMOVED              376
#define IDS_HISTORYCHANGE               377
#define IDS_VIEWSYSTEMSNAPSHOT          378
#define IDS_VIEWCURRENTSYSTEMINFO       379
#define IDS_SAVENFOFILTER               380
#define IDS_HELPCOMINGSOON              381
#define IDS_FINDBUTTONCAP               382
#define IDS_NOWI2KRESKIT                383
#define IDR_WHQLOBJ                     384
#define IDS_DRWATSONNAME                385
#define IDS_DXDIAGNAME                  386
#define IDS_SIGVERIFNAME                387
#define IDS_SYSTEMRESTNAME              388
#define IDS_NETDIAGNAME                 389
#define IDR_MSPID                       390
#define IDS_DOCDESCRIPTION              391
#define IDD_HISTORYREFRESHPROGRESS      392
#define IDC_PROGRESS1                   393
#define IDS_EXPORTDIALOGTITLE           394
#define IDS_WINDOWS                     395
#define IDS_IE                          396
#define IDS_CABCONTENTSNAME		397
#define IDS_VER4NFODISABLED		398
#define ID_FILE_OPENNFO                 32768
#define ID_FILE_SAVENFO                 32769
#define ID_FILE_EXIT                    32770
#define ID_FILE_EXPORT                  32774
#define ID_FILE_PRINTSETUP              32776
#define ID_VIEW_REFRESH                 32778
#define ID_VIEW_BASIC                   32779
#define ID_VIEW_ADVANCED                32780
#define ID_HELP_ABOUTSYSTEMINFO         32781
#define ID_HELP_ABOUT                   32781
#define ID_TOOLS_PLACEHOLDER            32782
#define ID_EDIT_FINDNEXT                32783
#define ID_EDIT_SELECTALL               32784
#define ID_VIEW_REMOTE_COMPUTER         32785
#define ID_VIEW_CURRENT                 32786
#define ID_VIEW_HISTORY                 32787
#define ID_HELP_CONTENTS                32788
#define ID_HELP_TOPIC                   32789
#define ID_WHAT_IS_THIS                 32790

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        210
#define _APS_NEXT_COMMAND_VALUE         32791
#define _APS_NEXT_CONTROL_VALUE         221
#define _APS_NEXT_SYMED_VALUE           120
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\resourcemap.h ===
//=============================================================================
// The CResourceMap class is useful for several data categories. It contains
// a map of the Win32_PnPAllocatedResource class.
//=============================================================================

#pragma once

#include "category.h"
#include "dataset.h"
#include "wmiabstraction.h"

class CResourceMap
{
public:
	CResourceMap();
	~CResourceMap();

	HRESULT Initialize(CWMIHelper * pWMIHelper);
	CStringList * Lookup(const CString & strKey);

	DWORD				m_dwInitTime;
	CMapStringToOb		m_map;
	HRESULT				m_hr;

private:
	void Empty();
};

// The container is a nice way to ensure that we only have one resource map around.
// But it's a pain when we're remoting, so we aren't using it now:

/*
class CResourceMapContainer
{
public:
	CResourceMapContainer() : m_pMap(NULL) {};
	~CResourceMapContainer() { if (m_pMap) delete m_pMap; };
	
	CResourceMap * GetResourceMap(CWMIHelper * pWMI)
	{
		if (m_pMap == NULL)
		{
			m_pMap = new CResourceMap;
			if (m_pMap)
				m_pMap->Initialize(pWMI);
		}

		return m_pMap;
	};

private:
	CResourceMap * m_pMap;
};
*/

// If we were using the resource map container - these would be uncommented:
//
// extern CResourceMapContainer gResourceMap;
// CResourceMapContainer gResourceMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9E31E459_79CF_4F09_82F4_4A98E988859E__INCLUDED_)
#define AFX_STDAFX_H__9E31E459_79CF_4F09_82F4_4A98E988859E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

//a-kjaw

#ifndef _SETUPAPI_VER 
#define _SETUPAPI_VER 0x0501
#endif

enum Classes_Provided 
{
	Class_Win32_PnPSignedDriver , 
	Class_Win32_PnPSignedDriverCIMDataFile , 
	Class_Win32_PnPSignedDriverWin32PnPEntity
};
//a-kjaw
#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>
#include <atlwin.h>

enum MSIColumnSortType { NOSORT, LEXICAL, BYVALUE };
enum DataComplexity { BASIC, ADVANCED };

#define WM_MSINFODATAREADY	WM_USER + 1

#undef _msxml_h_
#include "msxml.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9E31E459_79CF_4F09_82F4_4A98E988859E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\resourcemap.cpp ===
//=============================================================================
// The CResourceMap class is useful for several data categories. It contains
// a map of the Win32_PnPAllocatedResource class.
//=============================================================================

#include "stdafx.h"
#include "resourcemap.h"

CResourceMap::CResourceMap() : m_dwInitTime(0), m_hr(S_OK) { }

CResourceMap::~CResourceMap()
{
	Empty();
}

void CResourceMap::Empty()
{
	CString			strKey;
	CStringList *	plistStrings;

	for (POSITION pos = m_map.GetStartPosition(); pos != NULL;)
	{
		m_map.GetNextAssoc(pos, strKey, (CObject*&) plistStrings);
		if (plistStrings)
			delete plistStrings;
	}

	m_map.RemoveAll();
}

HRESULT CResourceMap::Initialize(CWMIHelper * pWMIHelper)
{
	if (m_dwInitTime)
		return m_hr;

	ASSERT(pWMIHelper);
	Empty();

	CString aAssociationClasses[] = 
	{
		_T("Win32_PnPAllocatedResource"),
		_T("Win32_CIMLogicalDeviceCIMDataFile"),
		_T("")
	};

	for (int j = 0; !aAssociationClasses[j].IsEmpty(); j++)
	{
		// Enumerate the class, inserting each Antecedent, Dependent pair into the map.

		CString strAntecedent, strDependent, strQuery;
		CStringList * pstringlist;

		CWMIObjectCollection * pCollection = NULL;
		HRESULT hr = pWMIHelper->Enumerate(aAssociationClasses[j], &pCollection);
		if (SUCCEEDED(hr))
		{
			CWMIObject * pObject = NULL;
			while (S_OK == pCollection->GetNext(&pObject))
			{
				strAntecedent.Empty();
				strDependent.Empty();

				if (SUCCEEDED(pObject->GetValueString(_T("Antecedent"), &strAntecedent)) &&
					SUCCEEDED(pObject->GetValueString(_T("Dependent"),  &strDependent)))
				{
					// Strip off the machine and namespace (too many ways for these to be formatted).

					int i = strAntecedent.Find(_T(":"));
					if (i != -1)
						strAntecedent = strAntecedent.Right(strAntecedent.GetLength() - i - 1);

					i = strDependent.Find(_T(":"));
					if (i != -1)
						strDependent = strDependent.Right(strDependent.GetLength() - i - 1);

					pstringlist = Lookup(strAntecedent);
					if (!pstringlist)
					{
						pstringlist = new CStringList;
						if (pstringlist)
							m_map.SetAt(strAntecedent, (CObject *) pstringlist);
					}
					if (pstringlist)
						pstringlist->AddTail(strDependent);

					pstringlist = Lookup(strDependent);
					if (!pstringlist)
					{
						pstringlist = new CStringList;
						if (pstringlist)
							m_map.SetAt(strDependent, (CObject *) pstringlist);
					}
					if (pstringlist)
						pstringlist->AddTail(strAntecedent);
				}
			}

			delete pObject;
			delete pCollection;
		}
		else
		{
			m_hr = hr;
			break;
		}
	}

	m_dwInitTime = ::GetTickCount();
	return m_hr;
}

CStringList * CResourceMap::Lookup(const CString & strKey)
{
	CStringList *	plistStrings;

	if (m_map.Lookup(strKey, (CObject*&) plistStrings))
		return plistStrings;
	else
		return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\swenvironment.cpp ===
//=============================================================================
// Contains the refresh functions for the software environment categories.
//=============================================================================

#include "stdafx.h"
#include "category.h"
#include "dataset.h"
#include "wmiabstraction.h"

//-----------------------------------------------------------------------------
// This function gathers running task information.
//-----------------------------------------------------------------------------

HRESULT RunningTasks(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	if (pWMI == NULL)
		return S_OK;

	LPCTSTR szTaskProperties = _T("Name, ExecutablePath, ProcessID, Priority, MinimumWorkingSetSize, MaximumWorkingSetSize, CreationDate");

	CString strName, strPath, strProcessID, strPriority, strMinWorking, strMaxWorking, strStartTime;
	CString strFileObjectPath, strDate, strSize, strVersion;
	DWORD	dwProcessID, dwPriority, dwMinWorking, dwMaxWorking, dwStartTime, dwDate, dwSize;

	HRESULT hr = S_OK;

	CWMIObjectCollection * pCollection = NULL;
	hr = pWMI->Enumerate(_T("Win32_Process"), &pCollection, szTaskProperties);
	if (SUCCEEDED(hr))
	{
		CWMIObject * pObject = NULL;
		CWMIObject * pFileObject = NULL;
		while (S_OK == pCollection->GetNext(&pObject))
		{
			strName.Empty(); strPath.Empty(); strProcessID.Empty(); strPriority.Empty();
			strMinWorking.Empty(); strMaxWorking.Empty(); strStartTime.Empty();
			strDate.Empty(); strSize.Empty(); strVersion.Empty();

			dwProcessID = dwPriority = dwMinWorking = dwMaxWorking = dwStartTime = dwDate = dwSize = 0;

			pObject->GetInterpretedValue(_T("Name"), _T("%l"), _T('l'), &strName, NULL);
			pObject->GetInterpretedValue(_T("ExecutablePath"), _T("%l"), _T('l'), &strPath, NULL);
			//pObject->GetInterpretedValue(_T("ProcessID"), _T("0x%08x"), _T('x'), &strProcessID, &dwProcessID);
//a-kjaw . to fix bug "MSInfo: Running Tasks PID's are being displayed in HEX"
			pObject->GetInterpretedValue(_T("ProcessID"), _T("%d"), _T('x'), &strProcessID, &dwProcessID);
//a-kjaw
			pObject->GetInterpretedValue(_T("Priority"), _T("%d"), _T('d'), &strPriority, &dwPriority);
			pObject->GetInterpretedValue(_T("MinimumWorkingSetSize"), _T("%d"), _T('d'), &strMinWorking, &dwMinWorking);
			pObject->GetInterpretedValue(_T("MaximumWorkingSetSize"), _T("%d"), _T('d'), &strMaxWorking, &dwMaxWorking);
			pObject->GetInterpretedValue(_T("CreationDate"), _T("%t"), _T('t'), &strStartTime, &dwStartTime);

			strFileObjectPath.Format(_T("CIM_DataFile.Name='%s'"), strPath);
			if (SUCCEEDED(pWMI->GetObject(strFileObjectPath, &pFileObject)))
			{
				pFileObject->GetInterpretedValue(_T("CreationDate"), _T("%t"), _T('t'), &strDate, &dwDate);
				pFileObject->GetInterpretedValue(_T("FileSize"), _T("%z"), _T('z'), &strSize, &dwSize);
				pFileObject->GetInterpretedValue(_T("Version"), _T("%s"), _T('s'), &strVersion, NULL);
				delete pFileObject;
				pFileObject = NULL;
			}
			else
			{
				strVersion = strSize = strDate = GetMSInfoHRESULTString(E_MSINFO_NOVALUE);
			}

			pWMI->AppendCell(aColValues[0], strName, 0);
			pWMI->AppendCell(aColValues[1], strPath, 0);
			pWMI->AppendCell(aColValues[2], strProcessID, dwProcessID);
			pWMI->AppendCell(aColValues[3], strPriority, dwPriority);
			pWMI->AppendCell(aColValues[4], strMinWorking, dwMinWorking);
			pWMI->AppendCell(aColValues[5], strMaxWorking, dwMaxWorking);
			pWMI->AppendCell(aColValues[6], strStartTime, dwStartTime);
			pWMI->AppendCell(aColValues[7], strVersion, 0);
			pWMI->AppendCell(aColValues[8], strSize, dwSize);
			pWMI->AppendCell(aColValues[9], strDate, dwDate);
		}
		delete pObject;
		delete pCollection;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// This function gathers loaded module information.
//
// The list of loaded modules contains all the executables and other entities
// (such as DLLs) which are currently loaded. This can be found using the
// WMI class CIM_ProcessExecutable. The trick is to remove duplicates (since
// DLLs will show up for each time they are loaded).
//-----------------------------------------------------------------------------

HRESULT LoadedModules(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	ASSERT(iColCount == 6);
	if (pWMI == NULL)
		return S_OK;

	HRESULT		hr = S_OK;
	CString		strAntecedent;
	CStringList	listModules;

	// Enumerate the CIM_ProcessExecutable class, creating a list of unique
	// loaded files.

	CWMIObjectCollection * pCollection = NULL;
	hr = pWMI->Enumerate(_T("CIM_ProcessExecutable"), &pCollection);
	if (SUCCEEDED(hr))
	{
		CWMIObject * pObject = NULL;
		while (S_OK == pCollection->GetNext(&pObject))
		{
			if (SUCCEEDED(pObject->GetValueString(_T("Antecedent"), &strAntecedent)))
			{
				strAntecedent.MakeLower();
				if (NULL == listModules.Find(strAntecedent))
					listModules.AddTail(strAntecedent);
			}
		}
		delete pObject;
		delete pCollection;
	}

	// Traverse the list of unique modules and get information for each file.

	CWMIObject *	pFileObject;
	CString			strFileObject;

	while (!listModules.IsEmpty())
	{
		strFileObject = listModules.RemoveHead();

		int iColon = strFileObject.Find(_T(":"));
		if (iColon != -1)
			strFileObject = strFileObject.Right(strFileObject.GetLength() - iColon - 1);

		if (SUCCEEDED(pWMI->GetObject(strFileObject, &pFileObject)))
		{
			pWMI->AddObjectToOutput(aColValues, iColCount, pFileObject, _T("FileName, Version, FileSize, CreationDate, Manufacturer, Name"), IDS_LOADEDMODULE1);
			delete pFileObject;
		}
		else
		{
			int iEquals = strFileObject.Find(_T("="));
			if (iEquals != -1)
				strFileObject = strFileObject.Right(strFileObject.GetLength() - iEquals - 1);

			// TBD - old MFC doesn't have these: strFileObject.TrimLeft(_T("\"'"));
			// strFileObject.TrimRight(_T("\"'"));
			StringReplace(strFileObject, _T("\\\\"), _T("\\"));

			pWMI->AppendCell(aColValues[0], strFileObject, 0);
			pWMI->AppendCell(aColValues[1], _T(""), 0);
			pWMI->AppendCell(aColValues[2], _T(""), 0);
			pWMI->AppendCell(aColValues[3], _T(""), 0);
			pWMI->AppendCell(aColValues[4], _T(""), 0);
			pWMI->AppendCell(aColValues[5], strFileObject, 0);
		}
	}

	return hr;
}

//-----------------------------------------------------------------------------
// This function gathers OLE information.
//-----------------------------------------------------------------------------

HRESULT OLERegistration(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	ASSERT(iColCount == 2);
	if (pWMI == NULL)
		return S_OK;

	HRESULT		hr = S_OK;
	CString		strCheckObject;

	int i = 1;

	CWMIObjectCollection * pCollection = NULL;
	hr = pWMI->Enumerate(_T("Win32_ClassicCOMClassSetting"), &pCollection, _T("Caption, LocalServer32, Insertable, Control"));
	if (SUCCEEDED(hr))
	{
		CWMIObject * pObject = NULL;
		while (S_OK == pCollection->GetNext(&pObject))
		{
			DWORD dwInsertable = 0, dwControl = -1;

			pObject->GetValueDWORD(_T("Insertable"), &dwInsertable);
			pObject->GetValueDWORD(_T("Control"), &dwControl);

			if (dwInsertable == -1 && dwControl == 0)
			{
				if (SUCCEEDED(pObject->GetValueString(_T("Caption"), &strCheckObject)) && !strCheckObject.IsEmpty())
					pWMI->AddObjectToOutput(aColValues, iColCount, pObject, _T("Caption, LocalServer32"), IDS_OLEREG1);
			}
		}

		delete pObject;
		delete pCollection;
	}

	return hr;
}


HRESULT WindowsErrorReporting(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);
	if (pWMI == NULL)
		return S_OK;

	HRESULT hr = S_OK;

	LPCTSTR aszQueries[] = 
	{
		_T("SELECT TimeGenerated, SourceName, Message FROM Win32_NTLogEvent WHERE EventIdentifier = 1000"),
		_T("SELECT TimeGenerated, SourceName, Message FROM Win32_NTLogEvent WHERE EventIdentifier = 1001"),
		_T("SELECT TimeGenerated, SourceName, Message FROM Win32_NTLogEvent WHERE EventIdentifier = 1002"),
		NULL
	};

	for (int i = 0; aszQueries[i] != NULL; i++)
	{
		CWMIObjectCollection * pCollection = NULL;
		if (SUCCEEDED(pWMI->WQLQuery(aszQueries[i], &pCollection)))
		{
			CWMIObject * pObject = NULL;
			while (S_OK == pCollection->GetNext(&pObject))
			{
				pWMI->AddObjectToOutput(aColValues, iColCount, pObject, _T("TimeGenerated, SourceName, Message"), IDS_SWWINERR1);
			}
			delete pObject;
			delete pCollection;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\simplequery.cpp ===
//=============================================================================
// Contains the refresh function for a simple query function (a simple query
// is one which involves a single WMI class and little post processing).
//=============================================================================

#include "stdafx.h"
#include "category.h"
#include "dataset.h"
#include "wmiabstraction.h"
#include "resourcemap.h"

//-----------------------------------------------------------------------------
// These functions implement features found in the new versions of MFC (new
// than what we're currently building with).
//-----------------------------------------------------------------------------

void StringReplace(CString & str, LPCTSTR szLookFor, LPCTSTR szReplaceWith)
{
	CString strWorking(str);
	CString strReturn;
	CString strLookFor(szLookFor);
	CString strReplaceWith(szReplaceWith);

	int iLookFor = strLookFor.GetLength();
	int iNext;

	while (!strWorking.IsEmpty())
	{
		iNext = strWorking.Find(strLookFor);
		if (iNext == -1)
		{
			strReturn += strWorking;
			strWorking.Empty();
		}
		else
		{
			strReturn += strWorking.Left(iNext);
			strReturn += strReplaceWith;
			strWorking = strWorking.Right(strWorking.GetLength() - (iNext + iLookFor));
		}
	}

	str = strReturn;
}

//-----------------------------------------------------------------------------
// The CSimpleQuery class encapsulates the simple query data. An array of these
// is created containing an element for each category to use this refresh
// function.
//-----------------------------------------------------------------------------

class CSimpleQuery
{
public:
	CSimpleQuery(DWORD dwIndex, LPCTSTR szClass, LPCTSTR szProperties, UINT uiColumns, BOOL fShowResources = FALSE, BOOL fBlankDividers = FALSE) :
	  m_dwIndex(dwIndex),
	  m_strClass(szClass),
	  m_strProperties(szProperties),
	  m_uiColumns(uiColumns),
	  m_fBlankDividers(fBlankDividers),
	  m_fShowResources(fShowResources) {};
	~CSimpleQuery() {};

public:
	DWORD		m_dwIndex;			// the index of this particular query
	CString		m_strClass;			// name of WMI class to enumerate
	CString		m_strProperties;	// properties to enumerate (in order displayed, comma delimited)
	BOOL		m_fShowResources;	// show resources used (must be two column "item|value" format)
	UINT		m_uiColumns;		// resource ID for the string containing the data to go in columns
	BOOL		m_fBlankDividers;	// insert a blank line between each instance
};

// TBD - need to mark some items as advanced

CSimpleQuery aSimpleQueries[] = 
{
	CSimpleQuery(QUERY_CDROM, _T("Win32_CDRomDrive"), _T("Drive, Description, MediaLoaded, MediaType, Name, Manufacturer, Status, TransferRate, MSIAdvancedSCSITargetId, MSIAdvancedPNPDeviceID"), IDS_CDROMCOLUMNS, TRUE, TRUE),
	CSimpleQuery(QUERY_SERVICES, _T("Win32_Service"), _T("DisplayName, Name, State, StartMode, ServiceType, PathName, ErrorControl, StartName, TagId"), IDS_SERVICES1, FALSE),
	CSimpleQuery(QUERY_PROGRAMGROUP, _T("Win32_ProgramGroup"), _T("GroupName, Name, UserName"), IDS_PROGRAMGROUP1, FALSE),
	CSimpleQuery(QUERY_STARTUP, _T("Win32_StartupCommand"), _T("Caption, Command, User, Location"), IDS_STARTUP1, FALSE),
	CSimpleQuery(QUERY_KEYBOARD, _T("Win32_Keyboard"), _T("Description, Name, Layout, MSIAdvancedPNPDeviceID, NumberOfFunctionKeys"), IDS_KEYBOARD1, TRUE, TRUE),
	CSimpleQuery(QUERY_POINTDEV, _T("Win32_PointingDevice"), _T("HardwareType, NumberOfButtons, Status, MSIAdvancedPNPDeviceID, MSIAdvancedPowerManagementSupported, MSIAdvancedDoubleSpeedThreshold, MSIAdvancedHandedness"), IDS_POINTDEV1, TRUE, TRUE),
	CSimpleQuery(QUERY_MODEM, _T("Win32_POTSModem"), _T("Caption, Description, DeviceID, DeviceType, AttachedTo, AnswerMode, MSIAdvancedPNPDeviceID, MSIAdvancedProviderName, MSIAdvancedModemInfPath, MSIAdvancedModemInfSection, MSIAdvancedBlindOff, MSIAdvancedBlindOn, CompressionOff, CompressionOn, ErrorControlForced, ErrorControlOff, ErrorControlOn, MSIAdvancedFlowControlHard, MSIAdvancedFlowControlOff, MSIAdvancedFlowControlSoft, MSIAdvancedDCB, MSIAdvancedDefault, MSIAdvancedInactivityTimeout, MSIAdvancedModulationBell, MSIAdvancedModulationCCITT, MSIAdvancedPrefix, MSIAdvancedPulse, MSIAdvancedReset, MSIAdvancedResponsesKeyName, SpeakerModeDial, SpeakerModeOff, SpeakerModeOn, SpeakerModeSetup, SpeakerVolumeHigh, SpeakerVolumeLow, SpeakerVolumeMed, MSIAdvancedStringFormat, MSIAdvancedTerminator, MSIAdvancedTone"), IDS_MODEM1, TRUE, TRUE),
	CSimpleQuery(QUERY_NETPROT, _T("Win32_NetworkProtocol"), _T("Name, ConnectionlessService, GuaranteesDelivery, GuaranteesSequencing, MSIAdvancedMaximumAddressSize, MSIAdvancedMaximumMessageSize, MSIAdvancedMessageOriented, MSIAdvancedMinimumAddressSize, MSIAdvancedPseudoStreamOriented, MSIAdvancedSupportsBroadcasting, MSIAdvancedSupportsConnectData, MSIAdvancedSupportsDisconnectData, MSIAdvancedSupportsEncryption, MSIAdvancedSupportsExpeditedData, MSIAdvancedSupportsGracefulClosing, MSIAdvancedSupportsGuaranteedBandwidth, MSIAdvancedSupportsMulticasting"), IDS_NETPROT1, FALSE, TRUE),
	CSimpleQuery(QUERY_ENVVAR, _T("Win32_Environment"), _T("Name, VariableValue, UserName"), IDS_ENVVAR1, FALSE),
	CSimpleQuery(QUERY_SOUNDDEV, _T("Win32_SoundDevice"), _T("Caption, Manufacturer, Status, MSIAdvancedPNPDeviceID"), IDS_SOUNDDEV1, TRUE, TRUE),
	CSimpleQuery(QUERY_DISPLAY, _T("Win32_VideoController"), _T("Name, MSIAdvancedPNPDeviceID, VideoProcessor, AdapterCompatibility, MSIAdvancedDescription, MSIAdvancedAdapterRAM, MSIAdvancedInstalledDisplayDrivers, DriverVersion, MSIAdvancedInfFilename, MSIAdvancedInfSection, MSIAdvancedNumberOfColorPlanes, MSIAdvancedCurrentNumberOfColors, CurrentHorizontalResolution, CurrentVerticalResolution, CurrentRefreshRate, CurrentBitsPerPixel"), IDS_DISPLAY1, TRUE, TRUE),
	CSimpleQuery(QUERY_INFRARED, _T("Win32_InfraredDevice"), _T("Caption"), IDS_INFRARED1, TRUE, TRUE),
	CSimpleQuery(QUERY_PARALLEL, _T("Win32_ParallelPort"), _T("Name, MSIAdvancedPNPDeviceID"), IDS_PARALLEL1, TRUE, TRUE),
	CSimpleQuery(QUERY_PRINTER, _T("Win32_Printer"), _T("Name, DriverName, PortName, ServerName"), IDS_PRINTER1, FALSE),
	CSimpleQuery(QUERY_NETCONNECTION, _T("Win32_NetworkConnection"), _T("LocalName, RemoteName, ResourceType, ConnectionType, UserName"), IDS_NETCONNECTION1, FALSE),
	CSimpleQuery(QUERY_DRIVER, _T("Win32_SystemDriver"), _T("Name, Description, PathName, ServiceType, Started, StartMode, State, Status, ErrorControl, AcceptPause, AcceptStop"), IDS_DRIVER1, FALSE),
	CSimpleQuery(QUERY_SIGNEDDRIVER, _T("Win32_PnPSignedDriver"), _T("DeviceName, IsSigned, DeviceClass, DriverVersion, DriverDate, Manufacturer, InfName, DriverName, DeviceID"), IDS_SIGNEDDRIVER1, FALSE),
	CSimpleQuery(QUERY_IDE, _T("Win32_IDEController"), _T("Caption, Manufacturer, Status, PNPDeviceID"), IDS_IDE1, TRUE, TRUE),
	CSimpleQuery(QUERY_SCSI, _T("Win32_SCSIController"), _T("Caption, Manufacturer, Status, MSIAdvancedPNPDeviceID"), IDS_SCSI1, TRUE, TRUE),
	CSimpleQuery(QUERY_PRINTJOBS, _T("Win32_PrintJob"), _T("Document, Size, Owner, Notify, Status, TimeSubmitted, StartTime, UntilTime, ElapsedTime, PagesPrinted, JobId, Priority, Parameters, DriverName, PrintProcessor, HostPrintQueue, DataType, Name"), IDS_PRINTJOBS1, FALSE),
	CSimpleQuery(0, _T(""), _T(""), 0)
};

//-----------------------------------------------------------------------------
// The refresh function which processes the simple query. The correct query
// is found in the query array. For each instance of the class, the column
// data will be inserted into the array of column values, and the format
// flags will be replaced with the actual data.
//-----------------------------------------------------------------------------

BOOL ProcessColumnString(CMSIValue * pValue, CWMIObject * pObject, CString * pstrProperties);
BOOL GetResourcesFromPNPID(CWMIHelper * pWMI, CResourceMap * pResourceMap, LPCTSTR szPNPID, CPtrList * aColValues);

HRESULT NetAdapter(CWMIHelper * pWMI, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, CResourceMap * pResourceMap);
HRESULT SerialPort(CWMIHelper * pWMI, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, CResourceMap * pResourceMap);

HRESULT SimpleQuery(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	HRESULT hr = S_OK;

	// Find the correct query.

	CSimpleQuery * pQuery = aSimpleQueries;
	while (pQuery->m_dwIndex && pQuery->m_dwIndex != dwIndex)
		pQuery++;

	if (pQuery->m_dwIndex != dwIndex && dwIndex != QUERY_NETADAPTER && dwIndex != QUERY_SERIALPORT)
	{
		ASSERT(0 && "bad dwIndex to SimpleQuery()");
		return E_FAIL;
	}

	// Make sure we have a resource map (or can create one).

	if (ppCache)
	{
		if (pWMI && *ppCache == NULL)
		{
			*ppCache = (void *) new CResourceMap;
			if (*ppCache)
			{
				hr = ((CResourceMap *) *ppCache)->Initialize(pWMI);
				if (FAILED(hr))
				{
					delete ((CResourceMap *) *ppCache);
					*ppCache = (void *) NULL;
				}
			}
		}
		else if (pWMI == NULL && *ppCache)
		{
			delete ((CResourceMap *) *ppCache);
			return S_OK;
		}
	}
	CResourceMap * pResourceMap = (CResourceMap *) *ppCache;

	// This is a nice way to cache to resource map for multiple functions, but it's
	// a monumental pain when we remote to a different machine:
	//
	// CResourceMap * pResourceMap = gResourceMap.GetResourceMap(pWMI);
	// if (pResourceMap == NULL)
	// 	return hr;

	// Check to see if this is one of the special case queries.

	if (dwIndex == QUERY_NETADAPTER)
		return NetAdapter(pWMI, pfCancel, aColValues, iColCount, pResourceMap);

	if (dwIndex == QUERY_SERIALPORT)
		return SerialPort(pWMI, pfCancel, aColValues, iColCount, pResourceMap);

	// Enumerate the requested class.

	CWMIObjectCollection * pCollection = NULL;
	hr = pWMI->Enumerate(pQuery->m_strClass, &pCollection, pQuery->m_strProperties);
	if (SUCCEEDED(hr))
	{
		CWMIObject * pObject = NULL;
		while (S_OK == pCollection->GetNext(&pObject))
		{
			CString strProperties = pQuery->m_strProperties;

			// If this is the second or later iteration, then we should add a blank
			// set of entries to the columns.

			if (pQuery->m_fBlankDividers)
				pWMI->AppendBlankLine(aColValues, iColCount);

			pWMI->AddObjectToOutput(aColValues, iColCount, pObject, strProperties, pQuery->m_uiColumns);

			// If so marked, we should see what resources (drivers, IRQs, etc.) are
			// associated with this object and add them to the list.

			if (pQuery->m_fShowResources)
			{
				ASSERT(iColCount == 2);
				CString strPNPID = pObject->GetString(_T("PNPDeviceID"));
				if (!strPNPID.IsEmpty())
					GetResourcesFromPNPID(pWMI, pResourceMap, strPNPID, aColValues);
			}
		}

		delete pObject;
		delete pCollection;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Given a resource map and a PNP ID string, this function will add all the
// resources used by that PNP device (IRQs, drivers, etc.) to a two column
// array of string lists.
//-----------------------------------------------------------------------------

BOOL GetResourcesFromPNPID(CWMIHelper * pWMI, CResourceMap * pResourceMap, LPCTSTR szPNPID, CPtrList * aColValues)
{
	CString		strPath, strResourcePath;
	CString		strPNPDeviceID(szPNPID);

	StringReplace(strPNPDeviceID, _T("\\"), _T("\\\\"));
	strPath.Format(_T("Win32_PnPEntity.DeviceID=\"%s\""), strPNPDeviceID);

	CStringList * pResourceList = pResourceMap->Lookup(strPath);
	if (pResourceList)
	{
		::AfxSetResourceHandle(_Module.GetResourceInstance());
		for (POSITION pos = pResourceList->GetHeadPosition(); pos != NULL;)
		{
			strResourcePath = pResourceList->GetNext(pos);
			CWMIObject * pResourceObject;
			if (SUCCEEDED(pWMI->GetObject(strResourcePath, &pResourceObject)))
			{
				CString strClass;
				if (SUCCEEDED(pResourceObject->GetValueString(_T("__CLASS"), &strClass)))
				{
					CString strItem;
					if (strClass == _T("Win32_IRQResource"))
						strItem.LoadString(IDS_IRQCHANNEL);
					else if (strClass == _T("Win32_PortResource"))
						strItem.LoadString(IDS_IOPORT);
					else if (strClass == _T("Win32_DMAChannel"))
						strItem.LoadString(IDS_DMACHANNEL);
					else if (strClass == _T("Win32_DeviceMemoryAddress"))
						strItem.LoadString(IDS_MEMORYADDRESS);
					else if (strClass == _T("CIM_DataFile"))
						strItem.LoadString(IDS_DRIVER);

					if (!strItem.IsEmpty())
					{
						CString strValue;
						if (SUCCEEDED(pResourceObject->GetValueString(_T("Caption"), &strValue)))
						{
							if (strClass == _T("CIM_DataFile"))
							{
								CString strVersion, strDate, strSize;

								pResourceObject->GetInterpretedValue(_T("FileSize"), _T("%z"), _T('z'), &strSize, NULL);
								pResourceObject->GetValueString(_T("Version"), &strVersion);
								pResourceObject->GetInterpretedValue(_T("CreationDate"), _T("%t"), _T('t'), &strDate, NULL);

								if (!strVersion.IsEmpty() || !strDate.IsEmpty() || !strSize.IsEmpty())
									strValue += CString(_T(" (")) + strVersion + CString(_T(", ")) + strSize + CString(_T(", ")) + strDate + CString(_T(")"));
							}

							pWMI->AppendCell(aColValues[0], strItem, 0);
							pWMI->AppendCell(aColValues[1], strValue, 0);
						}
					}
				}

				delete pResourceObject;
			} // if we could get the object
		} // for enumerating through the list
	} // if there is a list

	return TRUE;
}

//-----------------------------------------------------------------------------
// The specific query for the network adapter class.
//-----------------------------------------------------------------------------

HRESULT NetAdapter(CWMIHelper * pWMI, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, CResourceMap * pResourceMap)
{
	HRESULT hr = S_OK;

	LPCTSTR	szNetworkAdapterProperties = _T("Caption, AdapterType, MSIAdvancedProductName, MSIAdvancedInstalled, MSIAdvancedPNPDeviceID, MSIAdvancedTimeOfLastReset, MSIAdvancedIndex");
	LPCTSTR	szNetworkAdapterConfigProperties = _T("ServiceName, IPAddress, IPSubnet, DefaultIPGateway, DHCPEnabled, MSIAdvancedDHCPServer, MSIAdvancedDHCPLeaseExpires, MSIAdvancedDHCPLeaseObtained, MACAddress, Index");

	CPtrList listNetAdapterConfig;

	CWMIObjectCollection * pCollection = NULL;
	hr = pWMI->Enumerate(_T("Win32_NetworkAdapter"), &pCollection, szNetworkAdapterProperties);
	if (SUCCEEDED(hr))
	{
		CWMIObject * pObject = NULL;
		while (S_OK == pCollection->GetNext(&pObject))
		{
			pWMI->AppendBlankLine(aColValues, iColCount);
			pWMI->AddObjectToOutput(aColValues, iColCount, pObject, szNetworkAdapterProperties, IDS_NETWORKADAPTER1);

			DWORD dwIndex;
			if (SUCCEEDED(pObject->GetValueDWORD(_T("Index"), &dwIndex)))
			{
				if (listNetAdapterConfig.IsEmpty())
				{
					// Enumerate the class and cache the objects.

					CWMIObjectCollection * pConfigCollection = NULL;
					if (SUCCEEDED(pWMI->Enumerate(_T("Win32_NetworkAdapterConfiguration"), &pConfigCollection, szNetworkAdapterConfigProperties)))
					{
						CWMIObject * pConfigObject = NULL;
						while (S_OK == pConfigCollection->GetNext(&pConfigObject))
						{
							DWORD dwConfigIndex;
							if (SUCCEEDED(pConfigObject->GetValueDWORD(_T("Index"), &dwConfigIndex)))
								if (dwConfigIndex == dwIndex)
									pWMI->AddObjectToOutput(aColValues, iColCount, pConfigObject, szNetworkAdapterConfigProperties, IDS_NETWORKADAPTER2);
							
							listNetAdapterConfig.AddTail((void *)pConfigObject);
							pConfigObject = NULL;
						}

						delete pConfigObject;
						delete pConfigCollection;
					}
				}
				else
				{
					// Look through the list of cached objects.

					for (POSITION pos = listNetAdapterConfig.GetHeadPosition(); pos != NULL;)
					{
						CWMIObject * pConfigObject = (CWMIObject *)listNetAdapterConfig.GetNext(pos);
						DWORD dwConfigIndex;
						if (pConfigObject && SUCCEEDED(pConfigObject->GetValueDWORD(_T("Index"), &dwConfigIndex)))
							if (dwConfigIndex == dwIndex)
								pWMI->AddObjectToOutput(aColValues, iColCount, pConfigObject, szNetworkAdapterConfigProperties, IDS_NETWORKADAPTER2);
					}
				}
			}

			CString strPNPID = pObject->GetString(_T("PNPDeviceID"));
			if (!strPNPID.IsEmpty())
				GetResourcesFromPNPID(pWMI, pResourceMap, strPNPID, aColValues);
		}
		delete pObject;
		delete pCollection;

		while (!listNetAdapterConfig.IsEmpty())
		{
			CWMIObject * pDeleteObject = (CWMIObject *)listNetAdapterConfig.RemoveHead();
			if (pDeleteObject)
				delete pDeleteObject;
		}
	}

	return hr;
}

//-----------------------------------------------------------------------------
// The specific query for the serial port class.
// 
// TBD - cache the config values to save re-enumerating.
//-----------------------------------------------------------------------------

HRESULT SerialPort(CWMIHelper * pWMI, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, CResourceMap * pResourceMap)
{
	HRESULT hr = S_OK;

	LPCTSTR	szSerialPortProperties = _T("Name, Status, MSIAdvancedPNPDeviceID, MSIAdvancedMaximumInputBufferSize, MSIAdvancedMaximumOutputBufferSize, MSIAdvancedSettableBaudRate, MSIAdvancedSettableDataBits, MSIAdvancedSettableFlowControl, MSIAdvancedSettableParity, MSIAdvancedSettableParityCheck, MSIAdvancedSettableStopBits, MSIAdvancedSettableRLSD, MSIAdvancedSupportsRLSD, MSIAdvancedSupports16BitMode, MSIAdvancedSupportsSpecialCharacters, MSIAdvancedDeviceID");
	LPCTSTR	szSerialPortConfigProperties = _T("BaudRate, BitsPerByte, StopBits, Parity, IsBusy, MSIAdvancedAbortReadWriteOnError, MSIAdvancedBinaryModeEnabled, MSIAdvancedContinueXMitOnXOff, MSIAdvancedCTSOutflowControl, MSIAdvancedDiscardNULLBytes, MSIAdvancedDSROutflowControl, MSIAdvancedDSRSensitivity, MSIAdvancedDTRFlowControlType, MSIAdvancedEOFCharacter, MSIAdvancedErrorReplaceCharacter, MSIAdvancedErrorReplacementEnabled, MSIAdvancedEventCharacter, MSIAdvancedParityCheckEnabled, MSIAdvancedRTSFlowControlType, MSIAdvancedXOffCharacter, MSIAdvancedXOffXMitThreshold, MSIAdvancedXOnCharacter, MSIAdvancedXOnXMitThreshold, MSIAdvancedXOnXOffInFlowControl, MSIAdvancedXOnXOffOutFlowControl, Name");

	CWMIObjectCollection * pCollection = NULL;
	hr = pWMI->Enumerate(_T("Win32_SerialPort"), &pCollection, szSerialPortProperties);
	if (SUCCEEDED(hr))
	{
		CWMIObject * pObject = NULL;
		while (S_OK == pCollection->GetNext(&pObject))
		{
			pWMI->AppendBlankLine(aColValues, iColCount);
			pWMI->AddObjectToOutput(aColValues, iColCount, pObject, szSerialPortProperties, IDS_SERIALPORT1);

			CString strDeviceID;
			if (SUCCEEDED(pObject->GetValueString(_T("DeviceID"), &strDeviceID)))
			{
				CWMIObjectCollection * pConfigCollection = NULL;
				if (SUCCEEDED(pWMI->Enumerate(_T("Win32_SerialPortConfiguration"), &pConfigCollection, szSerialPortConfigProperties)))
				{
					CWMIObject * pConfigObject = NULL;
					while (S_OK == pConfigCollection->GetNext(&pConfigObject))
					{
						CString strConfigDeviceID;
						if (SUCCEEDED(pConfigObject->GetValueString(_T("Name"), &strConfigDeviceID)))
							if (strDeviceID.CompareNoCase(strConfigDeviceID) == 0)
								pWMI->AddObjectToOutput(aColValues, iColCount, pConfigObject, szSerialPortConfigProperties, IDS_SERIALPORT2);
					}
					delete pConfigObject;
					delete pConfigCollection;
				}
			}

			CString strPNPID = pObject->GetString(_T("PNPDeviceID"));
			if (!strPNPID.IsEmpty())
				GetResourcesFromPNPID(pWMI, pResourceMap, strPNPID, aColValues);
		}
		delete pObject;
		delete pCollection;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\resourcecategory.cpp ===
//=============================================================================
// Contains the refresh function for the resource categories.
//=============================================================================

#include "stdafx.h"
#include "category.h"
#include "dataset.h"
#include "wmiabstraction.h"
#include "resourcemap.h"

//
// The compiler doesn't like this perfectly correct code:
//
//    (dwIndex >= RESOURCE_DMA && dwIndex <= RESOURCE_MEM)
//
#pragma warning(disable:4296)  // expression is always true/false

//-----------------------------------------------------------------------------
// The resource refreshing function handles all of the categories under the
// resource subtree. It makes heavy use of the CResourceMap class to cache
// values and speed up subsequent resource queries.
//-----------------------------------------------------------------------------

HRESULT ResourceCategories(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || aColValues);

	HRESULT hr = S_OK;

	if (ppCache)
	{
		if (pWMI && *ppCache == NULL)
		{
			*ppCache = (void *) new CResourceMap;
			if (*ppCache)
			{
				hr = ((CResourceMap *) *ppCache)->Initialize(pWMI);
				if (FAILED(hr))
				{
					delete ((CResourceMap *) *ppCache);
					*ppCache = (void *) NULL;
				}
			}
		}
		else if (pWMI == NULL && *ppCache)
		{
			delete ((CResourceMap *) *ppCache);
			return S_OK;
		}
	}
	CResourceMap * pResourceMap = (CResourceMap *) *ppCache;

	// This is a nice way to cache to resource map for multiple functions, but it's
	// a monumental pain when we remote to a different machine:
	//
	// CResourceMap * pResourceMap = gResourceMap.GetResourceMap(pWMI);
	// if (pResourceMap == NULL)
	//	return hr;

	// Based on the index, we'll (probably) want to enumerate a resource category.

	if (dwIndex >= RESOURCE_DMA && dwIndex <= RESOURCE_MEM)
	{
		CString strClass;

		switch (dwIndex)
		{
		case RESOURCE_DMA:
			strClass = _T("Win32_DMAChannel");
			break;
		case RESOURCE_IRQ:
			strClass = _T("Win32_IRQResource");
			break;
		case RESOURCE_IO:
			strClass = _T("Win32_PortResource");
			break;
		case RESOURCE_MEM:
			strClass = _T("Win32_DeviceMemoryAddress");
			break;
		}

		CWMIObjectCollection * pCollection = NULL;
		hr = pWMI->Enumerate(strClass, &pCollection);
		if (SUCCEEDED(hr))
		{
			CWMIObject * pObject = NULL;
			CWMIObject * pDeviceObject = NULL;
			CString strDevicePath, strPath;
			CStringList * pDeviceList;

			while (S_OK == pCollection->GetNext(&pObject))
			{
				DWORD dwCaption = 0;

				switch (dwIndex)
				{
				case RESOURCE_DMA:
					pObject->GetValueDWORD(_T("DMAChannel"), &dwCaption);
					break;
				case RESOURCE_IRQ:
					pObject->GetValueDWORD(_T("IRQNumber"), &dwCaption);
					break;
				case RESOURCE_IO:
					pObject->GetValueDWORD(_T("StartingAddress"), &dwCaption);
					break;
				case RESOURCE_MEM:
					pObject->GetValueDWORD(_T("StartingAddress"), &dwCaption);
					break;
				}

				// Get the path for this resource (strip off machine stuff).

				strPath = pObject->GetString(_T("__PATH"));
				int i = strPath.Find(_T(":"));
				if (i != -1)
					strPath = strPath.Right(strPath.GetLength() - i - 1);

				// Look up the list of devices assigned to this resource.

				pDeviceList = pResourceMap->Lookup(strPath);
				if (pDeviceList)
				{
					for (POSITION pos = pDeviceList->GetHeadPosition(); pos != NULL;)
					{
						strDevicePath = pDeviceList->GetNext(pos);
						if (SUCCEEDED(pWMI->GetObject(strDevicePath, &pDeviceObject)))
						{
							pWMI->AppendCell(aColValues[1], pDeviceObject->GetString(_T("Caption")), 0);
							delete pDeviceObject;
							pDeviceObject = NULL;
						}
						else
							pWMI->AppendCell(aColValues[1], _T(""), 0);

						pWMI->AppendCell(aColValues[0], pObject->GetString(_T("Caption")), dwCaption);
						pWMI->AppendCell(aColValues[2], pObject->GetString(_T("Status")), 0);
					}
				}
			}

			delete pObject;
			delete pCollection;
		}
	}
	else if (dwIndex == RESOURCE_CONFLICTS && pResourceMap && !pResourceMap->m_map.IsEmpty())
	{
		// Scan through each element of the map.

		CString				strKey;
		CStringList *		plistStrings;
		CString				strResourcePath;
		CString				strDevicePath;
		CWMIObject *		pResourceObject;
		CWMIObject *		pDeviceObject;

		for (POSITION pos = pResourceMap->m_map.GetStartPosition(); pos != NULL;)
		{
			pResourceMap->m_map.GetNextAssoc(pos, strKey, (CObject*&) plistStrings);
			if (plistStrings)
			{
				// Check to see if there are more than one items associated with this one.

				if (plistStrings->GetCount() > 1)
				{
					// Then figure out if this is for a resource class. Just look for the 
					// class name in the key.

					BOOL fResource = FALSE;
					if (strKey.Find(_T("Win32_IRQResource")) != -1)
						fResource = TRUE;
					else if (strKey.Find(_T("Win32_PortResource")) != -1)
						fResource = TRUE;
					else if (strKey.Find(_T("Win32_DMAChannel")) != -1)
						fResource = TRUE;
					else if (strKey.Find(_T("Win32_DeviceMemoryAddress")) != -1)
						fResource = TRUE;

					if (fResource)
					{
						CString strItem, strValue;

						// Get the name of this shared resource.

						strResourcePath = strKey;
						pResourceObject = NULL;
						hr = pWMI->GetObject(strResourcePath, &pResourceObject);
						if (SUCCEEDED(hr))
						{
							strItem.Empty();
							if (strKey.Find(_T("Win32_PortResource")) != -1)
							{
								strItem.LoadString(IDS_IOPORT);
								strItem += CString(_T(" "));
							}
							else if (strKey.Find(_T("Win32_DeviceMemoryAddress")) != -1)
							{
								strItem.LoadString(IDS_MEMORYADDRESS);
								strItem += CString(_T(" "));
							}

							CString strTemp;
							pResourceObject->GetValueString(_T("Caption"), &strTemp);
							if (!strTemp.IsEmpty())
								strItem += strTemp;

							delete pResourceObject;
						}

						for (POSITION pos = plistStrings->GetHeadPosition(); pos != NULL;)
						{
							strDevicePath = plistStrings->GetNext(pos);
							pDeviceObject = NULL;
							hr = pWMI->GetObject(strDevicePath, &pDeviceObject);
							if (SUCCEEDED(hr))
							{
								if (SUCCEEDED(pDeviceObject->GetValueString(_T("Caption"), &strValue)))
								{
									pWMI->AppendCell(aColValues[0], strItem, 0);
									pWMI->AppendCell(aColValues[1], strValue, 0);
								}
								delete pDeviceObject;
							}
						}

						pWMI->AppendBlankLine(aColValues, iColCount, FALSE);
					}
				}
			}
		}
	}
	else if (dwIndex == RESOURCE_FORCED)
	{
		CWMIObjectCollection * pCollection = NULL;
		hr = pWMI->Enumerate(_T("Win32_PnPEntity"), &pCollection, _T("Caption, PNPDeviceID, ConfigManagerUserConfig"));
		if (SUCCEEDED(hr))
		{
			CWMIObject * pObject = NULL;
			while (S_OK == pCollection->GetNext(&pObject))
			{
				DWORD dwUserConfig;
				if (SUCCEEDED(pObject->GetValueDWORD(_T("ConfigManagerUserConfig"), &dwUserConfig)))
				{
					if (dwUserConfig)
					{
						pWMI->AppendCell(aColValues[0], pObject->GetString(_T("Caption")), 0);
						pWMI->AppendCell(aColValues[1], pObject->GetString(_T("PNPDeviceID")), 0);
					}
				}
			}
			delete pObject;
			delete pCollection;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\systemsummary.cpp ===
//=============================================================================
// Contains the refresh function for the system summary category.
//=============================================================================

#include "stdafx.h"
#include "category.h"
#include "dataset.h"
#include "wmiabstraction.h"

extern CString DelimitNumber(double dblValue, int iDecimalDigits = 0);
extern CString gstrMB;		// global string "MB" (will be localized)

HRESULT SystemSummary(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	ASSERT(pWMI == NULL || (aColValues && iColCount == 2));

	// Get the WMI objects we'll be needing. We'll check the first one to see if we
	// have a connection to WMI.

	CWMIObjectCollection * pCollection = NULL;
	CWMIObject * pOSObject = NULL;

	HRESULT hr = pWMI->Enumerate(_T("Win32_OperatingSystem"), &pCollection); //, _T("Caption, Version, CSDVersion, BuildNumber, Manufacturer, WindowsDirectory, SystemDirectory, BootDevice, Locale, FreePhysicalMemory, TotalVirtualMemorySize, FreeVirtualMemory, SizeStoredInPagingFiles"));
	if (SUCCEEDED(hr))
	{
		hr = pCollection->GetNext(&pOSObject);
		if (FAILED(hr))
			pOSObject = NULL;
		delete pCollection;
	}

	if (FAILED(hr))
		return hr;

	CWMIObject * pComputerObject	= pWMI->GetSingleObject(_T("Win32_ComputerSystem"), _T("Name, Manufacturer, Model, SystemType, UserName, DaylightInEffect"));
	CWMIObject * pPFUObject			= pWMI->GetSingleObject(_T("Win32_PageFileUsage"), _T("Caption"));

	if (pOSObject)
		pWMI->AddObjectToOutput(aColValues, iColCount, pOSObject, _T("Caption, Version, CSDVersion, BuildNumber, Manufacturer"), IDS_SYSSUMM1);

	// If the system has activation pending, show the number of days left.

	CWMIObject * pActivationObject = pWMI->GetSingleObject(_T("Win32_WindowsProductActivation"), _T("RemainingGracePeriod, ActivationRequired"));
	if (pActivationObject != NULL)
	{
		DWORD dwActivationPending;
		if (SUCCEEDED(pActivationObject->GetValueDWORD(_T("ActivationRequired"), &dwActivationPending)) && dwActivationPending != 0)
			pWMI->AddObjectToOutput(aColValues, iColCount, pActivationObject, _T("RemainingGracePeriod"), IDS_SYSSUMM12);
		delete pActivationObject;
	}

	if (pComputerObject)
		pWMI->AddObjectToOutput(aColValues, iColCount, pComputerObject, _T("Name, Manufacturer, Model, SystemType"), IDS_SYSSUMM2);

	pCollection = NULL;
	CWMIObject * pProcessorObject = NULL;
	CString strOSVersion(_T("Description,Manufacturer,MaxClockSpeed"));
	CString strProcessorQuery(_T("Description,Manufacturer"));
	CString strProcessorSpeedSource = _T(",MaxClockSpeed");
	if (pOSObject != NULL && SUCCEEDED(pOSObject->GetValueString(_T("Version"),&strOSVersion)))
	{
		if (strOSVersion.Left(3) == _T("5.0"))//remoting to Win2k machine?
		{
			strProcessorSpeedSource = _T(",CurrentClockSpeed");
		}
	}
	strProcessorQuery += strProcessorSpeedSource;
	if (SUCCEEDED(pWMI->Enumerate(_T("Win32_Processor"), &pCollection,strProcessorQuery)))
	{
		while (S_OK == pCollection->GetNext(&pProcessorObject) && pProcessorObject != NULL)
		{
			CString strOutput = _T("Description, Manufacturer") + strProcessorSpeedSource;
			pWMI->AddObjectToOutput(aColValues, iColCount, pProcessorObject,strOutput /*_T("Description, Manufacturer, MaxClockSpeed")*/, IDS_SYSSUMM3);
			delete pProcessorObject;
			pProcessorObject = NULL;
		}

		delete pCollection;
	}

	// Try to get every property of Win32_BIOS that we'd like to show.

	CWMIObject * pBIOSObject = pWMI->GetSingleObject(_T("Win32_BIOS"), _T("Manufacturer, Version, SMBIOSPresent, SMBIOSBIOSVersion, ReleaseDate, SMBIOSMajorVersion, SMBIOSMinorVersion, BIOSVersion"));

	// If GetSingleObject failed (the pointer is NULL) try again, without BIOSVersion.

	if (pBIOSObject == NULL)
		pBIOSObject = pWMI->GetSingleObject(_T("Win32_BIOS"), _T("Manufacturer, Version, SMBIOSPresent, SMBIOSBIOSVersion, ReleaseDate, SMBIOSMajorVersion, SMBIOSMinorVersion"));

	if (pBIOSObject)
	{
		// Per NadirA (bug 409578) this is the preferred order for getting BIOS info.

		DWORD dwSMBIOSPresent = 0;
		if (FAILED(pBIOSObject->GetValueDWORD(_T("SMBIOSPresent"), &dwSMBIOSPresent)))
			dwSMBIOSPresent = 0;

		CString strDummy;
		if (dwSMBIOSPresent != 0 && SUCCEEDED(pBIOSObject->GetValueString(_T("SMBIOSBIOSVersion"), &strDummy)))
		{
			// We need to change the format strings for the BIOS and SMBIOS values in this case.

			CString strBIOSFormat, strSMBIOSFormat;
			strBIOSFormat.LoadString(IDS_SYSSUMM4);
			strSMBIOSFormat.LoadString(IDS_SYSSUMM11);

			strBIOSFormat = strBIOSFormat.SpanExcluding(_T("|")) + CString(_T("|%s %s, %c"));
			strSMBIOSFormat = strSMBIOSFormat.SpanExcluding(_T("|")) + CString(_T("|%d.%d"));

			pWMI->AddObjectToOutput(aColValues, iColCount, pBIOSObject, _T("Manufacturer, SMBIOSBIOSVersion, ReleaseDate"), strBIOSFormat);
			pWMI->AddObjectToOutput(aColValues, iColCount, pBIOSObject, _T("SMBIOSMajorVersion, SMBIOSMinorVersion"), strSMBIOSFormat);
		}
		else if (SUCCEEDED(pBIOSObject->GetValueString(_T("BIOSVersion"), &strDummy)))
		{
			pWMI->AddObjectToOutput(aColValues, iColCount, pBIOSObject, _T("BIOSVersion, ReleaseDate"), IDS_SYSSUMM4);
		}
		else
		{
			pWMI->AddObjectToOutput(aColValues, iColCount, pBIOSObject, _T("Version, ReleaseDate"), IDS_SYSSUMM4);
		}
	}

	if (pOSObject)
		pWMI->AddObjectToOutput(aColValues, iColCount, pOSObject, _T("WindowsDirectory, MSIAdvancedSystemDirectory, MSIAdvancedBootDevice, Locale"), IDS_SYSSUMM5);

	// Add information about the HAL.DLL to the summary (bug 382771). The DLL
	// will be found in the system directory.

	if (pOSObject != NULL)
	{
		CString strSystemDirectory = pOSObject->GetString(_T("SystemDirectory"));
		if (!strSystemDirectory.IsEmpty())
		{
			CString strPath;
			strPath.Format(_T("CIM_DataFile.Name='%s\\hal.dll'"), strSystemDirectory);

			CWMIObject * pHALObject;
			if (SUCCEEDED(pWMI->GetObject(strPath, &pHALObject)))
			{
				pWMI->AddObjectToOutput(aColValues, iColCount, pHALObject, _T("Version"), IDS_SYSSUMM13);
				delete pHALObject;
			}
		}
	}

	if (pComputerObject)
		pWMI->AddObjectToOutput(aColValues, iColCount, pComputerObject, _T("MSIAdvancedUserName"), IDS_SYSSUMM6);

	if (pComputerObject)
	{
		BOOL	fUseStandard = TRUE;
		DWORD	dwValue;
		if (SUCCEEDED(pComputerObject->GetValueDWORD(_T("DaylightInEffect"), &dwValue)) && dwValue)
			fUseStandard = FALSE;

		CWMIObject * pTimeZoneObject = pWMI->GetSingleObject(_T("Win32_TimeZone"));
		if (pTimeZoneObject)
		{
			pWMI->AddObjectToOutput(aColValues, iColCount, pTimeZoneObject, (fUseStandard) ? _T("StandardName") : _T("DaylightName"), IDS_SYSSUMM10);
			delete pTimeZoneObject;
		}
	}

	// To get an accurate picture of the we need to enumerate the values of Win32_PhysicalMemory,
	// which reports the memory installed in each slot.

	double dblTotalPhysicalMemory = 0.0;
	pCollection = NULL;
	CWMIObject * pMemoryObject = NULL;
	if (SUCCEEDED(pWMI->Enumerate(_T("Win32_PhysicalMemory"), &pCollection, _T("Capacity"))))
	{
		while (S_OK == pCollection->GetNext(&pMemoryObject) && pMemoryObject != NULL)
		{
			double dblTemp;
			if (SUCCEEDED(pMemoryObject->GetValueDoubleFloat(_T("Capacity"), &dblTemp)))
				dblTotalPhysicalMemory += dblTemp;
			delete pMemoryObject;
			pMemoryObject = NULL;
		}

		delete pCollection;
	}

	// On some older machines, without SMBIOS, Win32_PhysicalMemory isn't supported.
	// In that case, look at Win32_ComputerSystem::TotalPhysicalMemory. XP bug 441343.

	if (dblTotalPhysicalMemory == 0.0)
	{
		CWMIObject * pObject = pWMI->GetSingleObject(_T("Win32_ComputerSystem"), _T("TotalPhysicalMemory"));
		if (pObject != NULL)
			if (FAILED(pObject->GetValueDoubleFloat(_T("TotalPhysicalMemory"), &dblTotalPhysicalMemory)))
				dblTotalPhysicalMemory = 0.0;
	}

	if (dblTotalPhysicalMemory != 0.0)
	{
		CString strCaption;
		CString strValue(DelimitNumber(dblTotalPhysicalMemory/(1024.0*1024.0), 2));

		if (gstrMB.IsEmpty())
			gstrMB.LoadString(IDS_MB);
		strValue += _T(" ") + gstrMB;

		// For the caption, use the format string we used before (just the first column).

		strCaption.LoadString(IDS_SYSSUMM7);
		strCaption = strCaption.SpanExcluding(_T("|"));

		pWMI->AppendCell(aColValues[0], strCaption, 0);
		pWMI->AppendCell(aColValues[1], strValue, (DWORD)dblTotalPhysicalMemory);
	}

	if (pOSObject)
		pWMI->AddObjectToOutput(aColValues, iColCount, pOSObject, _T("FreePhysicalMemory, TotalVirtualMemorySize, FreeVirtualMemory, SizeStoredInPagingFiles"), IDS_SYSSUMM8);

	if (pPFUObject)
		pWMI->AddObjectToOutput(aColValues, iColCount, pPFUObject, _T("MSIAdvancedCaption"), IDS_SYSSUMM9);

	if (pOSObject) delete pOSObject;
	if (pComputerObject) delete pComputerObject;
	if (pProcessorObject) delete pProcessorObject;
	if (pBIOSObject) delete pBIOSObject	;
	if (pPFUObject) delete pPFUObject;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\version5extension.cpp ===
//=============================================================================
// Code for loading and refreshing version 5.0 extensions.
//=============================================================================

#include "stdafx.h"
#include "category.h"
#include "dataset.h"
#include "wmiabstraction.h"
#include "version5extension.h"

CMapExtensionRefreshData gmapExtensionRefreshData;

extern HRESULT ChangeWBEMSecurity(IUnknown * pUnknown);

//-----------------------------------------------------------------------------
// Load the specified template from the named extension. This will involve
// loading the DLL and using the entry point to retrieve the text for the
// extension's template.
//
// Once the data is loaded, it's parsed into version 5 format structures.
//-----------------------------------------------------------------------------

typedef DWORD (__cdecl *pfuncGetTemplate)(void ** ppBuffer);

DWORD CTemplateFileFunctions::ParseTemplateIntoVersion5Categories(const CString & strExtension, CMapWordToPtr & mapVersion5Categories)
{
	DWORD dwRootID = 0;

	HINSTANCE hinst = LoadLibrary(strExtension);
	if (hinst == NULL)
		return dwRootID;

	pfuncGetTemplate pfunc = (pfuncGetTemplate) GetProcAddress(hinst, "GetTemplate");
	if (pfunc == NULL)
	{
		FreeLibrary(hinst);
		return dwRootID;
	}

	// Call the DLL function with a NULL parameter to get the size of the buffer.

	void * pBuffer;
	CMemFile memfile;
	DWORD dwBufferSize = (*pfunc)((void **)&pBuffer);
	if (dwBufferSize && pBuffer)
	{
		memfile.Attach((BYTE *)pBuffer, dwBufferSize, 0);
		dwRootID = ReadTemplateFile(&memfile, mapVersion5Categories);
		memfile.Detach();
		(void)(*pfunc)(NULL); // calling the exported DLL function with NULL frees its buffers
	}

	if (hinst != NULL)
		FreeLibrary(hinst);

	return dwRootID;
}

//-----------------------------------------------------------------------------
// This function reads the contents of a template file (in this case, a memory
// file) and produces a map of ID, INTERNAL_CATEGORY pointer pairs. It returns
// the ID for the root node in the tree.
//-----------------------------------------------------------------------------

DWORD CTemplateFileFunctions::ReadTemplateFile(CFile * pFile, CMapWordToPtr & mapVersion5Categories)
{
	ASSERT(pFile);
	if (pFile == NULL || !VerifyUNICODEFile(pFile) || !ReadHeaderInfo(pFile))
		return 0;

	return (ReadNodeRecursive(pFile, mapVersion5Categories, 0, 0));
}

//-----------------------------------------------------------------------------
// Make sure this is an MSInfo template file.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ReadHeaderInfo(CFile * pFile)
{
	return VerifyAndAdvanceFile(pFile, CString(_T(TEMPLATE_FILE_TAG)));
}

//-----------------------------------------------------------------------------
// This method verifies that the passed file is a UNICODE file, by reading the
// value 0xFEFF from the file. It also leaves the file pointer past this word.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::VerifyUNICODEFile(CFile * pFile)
{
	WORD verify;

	if (pFile->Read((void *) &verify, sizeof(WORD)) != sizeof(WORD))
		return FALSE;

	return (verify == 0xFEFF);
}

//-----------------------------------------------------------------------------
// This method verifies that the text in strVerify comes next in the file (not
// including case or whitespace differences) and advances the file past that
// text. If the text was the next content in the file, TRUE is returned,
// otherwise FALSE. If FALSE is returned, the file is backed up to where it
// was when this method was called.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::VerifyAndAdvanceFile(CFile * pFile, const CString & strVerify)
{
	DWORD	dwPosition = pFile->GetPosition();
	WCHAR	cLastChar, cCurrentChar = L'\0';
	BOOL	fInComment = FALSE;
	int		iCharIndex = 0, iStringLen = strVerify.GetLength();

	while (iCharIndex < iStringLen)
	{
		// Save the last character read, since the comment token ("//") is
		// two characters long.

		cLastChar = cCurrentChar;

		// Read the next character in the file.

		if (pFile->Read((void *) &cCurrentChar, sizeof(WCHAR)) != sizeof(WCHAR))
			return FALSE;

		// If we're in a comment, and the character we just read isn't a new line,
		// we want to ignore it.

		if (fInComment)
		{
			if (cCurrentChar == L'\n')
				fInComment = FALSE;
			continue;
		}

		// Check to see if we've started into a comment. Note that we ignore
		// the first '/' also by continuing.

		if (cCurrentChar == L'/')
		{
			if (cLastChar == L'/')
				fInComment = TRUE;
			continue;
		}
		
		// Skip whitespace, and also leading commas.

		if (iswspace(cCurrentChar) || (cCurrentChar == L',' && iCharIndex == 0))
			continue;

		if (cCurrentChar != (WCHAR)strVerify[iCharIndex])
		{
			pFile->Seek((LONG)dwPosition, CFile::begin);
			return FALSE;
		}

		iCharIndex++;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// This is the recursive function to read a node. It reads the information
// from the node parameters, creates the node, and processes the contents of
// the block following the node (contained within "{}"'s). It's called
// recursively if there are any nodes in that block.
//
// In this version (for 6.0), it returns the ID of the node it's read.
//-----------------------------------------------------------------------------

DWORD CTemplateFileFunctions::ReadNodeRecursive(CFile * pFile, CMapWordToPtr & mapCategories, DWORD dwParentID, DWORD dwPrevID)
{
	// Determine if we need to create a new category for this node. Read the 
	// information from the file to determine the identifier for the new category.

	CString	strEnumerateClass, strIdentifier;

	if (!VerifyAndAdvanceFile(pFile, CString(NODE_KEYWORD) + CString("(")))
		return 0;

	if (!ReadArgument(pFile, strEnumerateClass))
		return 0;

	if (!ReadArgument(pFile, strIdentifier))
		return 0;

	// Generate the ID for this new node. This should be one greater than the max in the
	// map (or one, if the map is empty).

	DWORD	dwID = 0;
	WORD	wMapID;
	void *	pDontCare;

	for (POSITION pos = mapCategories.GetStartPosition(); pos != NULL;)
	{
		mapCategories.GetNextAssoc(pos, wMapID, pDontCare);
		if ((DWORD) wMapID > dwID)
			dwID = (DWORD) wMapID;
	}

	dwID += 1;

	// Create the category for the node.

	INTERNAL_CATEGORY * pCategory = CreateCategory(mapCategories, dwID, dwParentID, dwPrevID);

	// Read the contents of the node argument list ("node(enum, identifier, field(source, formatstr, arg...))")
	// We've already read up to and including the identifier.

	pCategory->m_strEnumerateClass = strEnumerateClass;
	pCategory->m_strIdentifier = strIdentifier;

	if (!ReadField(pFile, pCategory->m_fieldName))
		return 0;

	// Copy the field name to the name of the category (they are two different
	// member variables to allow for dynamically refreshed names, which turns
	// out to be unnecessary in this version).

	pCategory->m_categoryName.m_strText = pCategory->m_fieldName.m_strFormat;

	if (!ReadArgument(pFile, pCategory->m_strNoInstances))
		return 0;

	if (!VerifyAndAdvanceFile(pFile, CString("){")))
		return 0;

	// Process the contents of the block (enclosed in "{}") for this node.

	DWORD	dwSubNodePrev = 0, dwNewNode = 0;
	CString	strKeyword;

	// If this new category isn't actually new (i.e. it is being read from a
	// template and overlaps an existing category) see if there are any
	// existing children.
	//
	// Version 6.0: these are being read into distinct trees, so there should
	// be no overlap (it would be resolved later).

	while (GetKeyword(pFile, strKeyword))
	{
		if (strKeyword.CompareNoCase(CString(NODE_KEYWORD)) == 0)
		{
			dwNewNode = ReadNodeRecursive(pFile, mapCategories, dwID, dwSubNodePrev);
			if (dwNewNode == 0)
				return 0;

			// If this is the first child node we've read, save its ID.

			if (pCategory->m_dwChildID == 0)
				pCategory->m_dwChildID = dwNewNode;

			// If we've read another child node, set its next field appropriately.

			if (dwSubNodePrev)
			{
				INTERNAL_CATEGORY * pPrevCategory = GetInternalRep(mapCategories, dwSubNodePrev);
				if (pPrevCategory)
					pPrevCategory->m_dwNextID = dwNewNode;
			}
			dwSubNodePrev = dwNewNode;
		}
		else if (strKeyword.CompareNoCase(CString(COLUMN_KEYWORD)) == 0)
		{
			if (!ReadColumnInfo(pFile, mapCategories, dwID))
				return 0;
		}
		else if (strKeyword.CompareNoCase(CString(LINE_KEYWORD)) == 0)
		{
			GATH_LINESPEC * pNewLineSpec = ReadLineInfo(pFile);
			
			if (pNewLineSpec == NULL)
				return 0;

			// Add the line we just read in to the end of the list of line specs for this
			// internal category.

			if (pCategory->m_pLineSpec == NULL)
				pCategory->m_pLineSpec = pNewLineSpec;
			else
			{
				GATH_LINESPEC * pLineSpec = pCategory->m_pLineSpec;
				while (pLineSpec->m_pNext)
					pLineSpec = pLineSpec->m_pNext;
				pLineSpec->m_pNext = pNewLineSpec;
			}
		}
		else if (strKeyword.CompareNoCase(CString(ENUMLINE_KEYWORD)) == 0)
		{
			GATH_LINESPEC * pNewLineSpec = ReadLineEnumRecursive(pFile, mapCategories);
			
			if (pNewLineSpec == NULL)
				return 0;

			// Add the line we just read in to the end of the list of line specs for this
			// internal category.

			if (pCategory->m_pLineSpec == NULL)
				pCategory->m_pLineSpec = pNewLineSpec;
			else
			{
				GATH_LINESPEC * pLineSpec = pCategory->m_pLineSpec;
				while (pLineSpec->m_pNext)
					pLineSpec = pLineSpec->m_pNext;
				pLineSpec->m_pNext = pNewLineSpec;
			}
		}
		else
		{
			ASSERT(FALSE);
			VerifyAndAdvanceFile(pFile, strKeyword);
		}
	}

	if (!VerifyAndAdvanceFile(pFile, CString("}")))
		return 0;

	return dwID;
}

//-----------------------------------------------------------------------------
// Get the category structure, given a DWORD ID.
//-----------------------------------------------------------------------------

INTERNAL_CATEGORY * CTemplateFileFunctions::GetInternalRep(CMapWordToPtr & mapCategories, DWORD dwID)
{
	INTERNAL_CATEGORY * pReturn;
	if (mapCategories.Lookup((WORD) dwID, (void * &) pReturn))
		return pReturn;
	return NULL;
}

//-----------------------------------------------------------------------------
// Create the internal category structure.
//
// Version 6.0: this doesn't set the category ID.
//-----------------------------------------------------------------------------

INTERNAL_CATEGORY * CTemplateFileFunctions::CreateCategory(CMapWordToPtr & mapCategories, DWORD dwNewID, DWORD dwParentID, DWORD dwPrevID)
{
	INTERNAL_CATEGORY *	pInternalCat;
	INTERNAL_CATEGORY *	pPreviousCat;
	CString				strName;

	pInternalCat = new INTERNAL_CATEGORY;
	if (!pInternalCat)
		return NULL;

	pInternalCat->m_dwID		= dwNewID;
	pInternalCat->m_fListView	= TRUE;
	pInternalCat->m_dwParentID	= dwParentID;
	pInternalCat->m_dwPrevID	= dwPrevID;

	if (dwPrevID)
	{
		pPreviousCat = GetInternalRep(mapCategories, dwPrevID);
		if (pPreviousCat)
			pPreviousCat->m_dwNextID = dwNewID;
	}

	mapCategories.SetAt((WORD)dwNewID, (void *) pInternalCat);
	return pInternalCat;
}

//-----------------------------------------------------------------------------
// This method simply reads an argument (as string) from the file, until a
// punctuation or whitespace character is found. If a quote mark is found,
// all characters are included in the string until another quote is found.
// NOTE: currently no way to have a quote mark in the string.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ReadArgument(CFile * pFile, CString & strSource)
{
	BOOL	fInQuote = FALSE, fInComment = FALSE;
	CString	strTemp;
	WCHAR	cLastChar, cCurrentChar = L'\0';

	// Skip over characters until we reach an alphanumeric char. If we find
	// a close paren, then we've reached the end of the argument list and
	// should return FALSE.

	do
	{
		// Save the last character read, since the comment token ("//") is
		// two characters long.

		cLastChar = cCurrentChar;

		// Read the next character in the file.

		if (pFile->Read((void *) &cCurrentChar, sizeof(WCHAR)) != sizeof(WCHAR))
			return FALSE;

		// If we're in a comment, and the character we just read isn't a new line,
		// we want to ignore it.

		if (fInComment)
		{
			if (cCurrentChar == L'\n')
				fInComment = FALSE;
			continue;
		}

		// Check to see if we've started into a comment.

		if (cCurrentChar == L'/')
		{
			if (cLastChar == L'/')
				fInComment = TRUE;
			continue;
		}

		if (cCurrentChar == L')')
			return FALSE;
	} while (!iswalnum(cCurrentChar) && cCurrentChar != L'"');

	// Read characters into the string until we find whitespace or punctuation.
	do
	{	
		
		if (cCurrentChar == L'"')
		{
			fInQuote = !fInQuote;
			continue;
		}
		
		if (iswalnum(cCurrentChar) || fInQuote)
		{

			char strt[5] = "";
			BOOL used = FALSE;
#ifdef UNICODE
			strTemp += (TCHAR) cCurrentChar;
#else
			WideCharToMultiByte(CP_ACP, 0, &cCurrentChar, 1, strt, 2, "?", &used);
			strTemp += strt;
#endif

		}
		else
		{
			break;
		}
		
	} while (pFile->Read((void *) &cCurrentChar, sizeof(WCHAR)) == sizeof(WCHAR));

	// If the last character read (the one which terminated this argument) was
	// not a comma, then back the file up so that the character can be re-read
	// and interpreted.

	if (cCurrentChar != L',')
		pFile->Seek(-(LONG)sizeof(WCHAR), CFile::current);
	
	strSource = strTemp;
	return TRUE;
}

//-----------------------------------------------------------------------------
// A field consists of a source string, followed by a format string, followed
// by a list of zero or more arguments.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ReadField(CFile * pFile, GATH_FIELD & field)
{
	// Advance past the field keyword and read the two source and format strings.

	if (!VerifyAndAdvanceFile(pFile, CString(FIELD_KEYWORD) + CString("(")))
		return FALSE;

	if (!ReadArgument(pFile, field.m_strSource))
		return FALSE;

	if (!ReadArgument(pFile, field.m_strFormat))
		return FALSE;

	// Read arguments until there are no more, building them into a list of
	// arguments stored by the FIELD struct.

	GATH_VALUE		arg;
	GATH_VALUE *	pArg = NULL;

	while (ReadArgument(pFile, arg.m_strText))
	{
		if (pArg == NULL)
		{
			field.m_pArgs = new GATH_VALUE;
			if (field.m_pArgs == NULL)
				return FALSE;
			*field.m_pArgs = arg;
			pArg = field.m_pArgs;
		}
		else
		{
			pArg->m_pNext = new GATH_VALUE;
			if (pArg->m_pNext == NULL)
				return FALSE;
			*pArg->m_pNext = arg;
			pArg = pArg->m_pNext;
		}
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Read an enumline(){} block. This construct is used to group lines together
// which are enumerated for each instance of a class. A line is added to 
// the parent node's list of lines with a m_strEnumerateClass equal to the 
// class to be enumerated. The added line structure will have children lines 
// (the lines to be enumerated) referenced by m_pEnumeratedGroup.
//-----------------------------------------------------------------------------

GATH_LINESPEC * CTemplateFileFunctions::ReadLineEnumRecursive(CFile * pFile, CMapWordToPtr & mapCategories)
{
	if (!VerifyAndAdvanceFile(pFile, CString(ENUMLINE_KEYWORD) + CString("(")))
		return NULL;

	// Declare a line specification variable to store the line info.

	GATH_LINESPEC * pNewLineSpec = new GATH_LINESPEC;
	if (pNewLineSpec == NULL)
		return NULL;

	// Read in the enumerated class variable.

	if (!ReadArgument(pFile, pNewLineSpec->m_strEnumerateClass))
	{
		delete pNewLineSpec;
		return NULL;
	}

	// Read in the variable (zero or more) number of fields for the constraints.

	GATH_FIELD * pNewField = new GATH_FIELD;
	if (pNewField == NULL)
		return NULL;

	while (ReadField(pFile, *pNewField))
	{
		if (pNewLineSpec->m_pConstraintFields == NULL)
			pNewLineSpec->m_pConstraintFields = pNewField;
		else
		{
			// Add the newly read field to the end of the field list. Note,
			// this is inefficient, and should be fixed. (NOTE)

			GATH_FIELD * pFieldScan = pNewLineSpec->m_pConstraintFields;
			while (pFieldScan->m_pNext)
				pFieldScan = pFieldScan->m_pNext;
			pFieldScan->m_pNext = pNewField;
		}

		pNewField = new GATH_FIELD;
		if (pNewField == NULL)
			return NULL;
	}

	delete pNewField;

	// Advance past the close paren and the (necessary) open bracket.

	if (!VerifyAndAdvanceFile(pFile, CString("){")))
	{
		delete pNewLineSpec;
		return NULL;
	}

	// Read the contents of the block (should be all lines or enumlines).

	CString strKeyword;
	while (GetKeyword(pFile, strKeyword))
	{
		if (strKeyword.CompareNoCase(CString(LINE_KEYWORD)) == 0)
		{
			GATH_LINESPEC * pNewSubLine = ReadLineInfo(pFile);
			if (pNewSubLine == NULL)
			{
				delete pNewLineSpec;
				return NULL;
			}

			if (pNewLineSpec->m_pEnumeratedGroup == NULL)
				pNewLineSpec->m_pEnumeratedGroup = pNewSubLine;
			else
			{
				GATH_LINESPEC * pLineSpec = pNewLineSpec->m_pEnumeratedGroup;
				while (pLineSpec->m_pNext)
					pLineSpec = pLineSpec->m_pNext;
				pLineSpec->m_pNext = pNewSubLine;
			}
		}
		else if (strKeyword.CompareNoCase(CString(ENUMLINE_KEYWORD)) == 0)
		{
			GATH_LINESPEC * pNewSubLine = ReadLineEnumRecursive(pFile, mapCategories);
			if (pNewSubLine == NULL)
			{
				delete pNewLineSpec;
				return NULL;
			}

			if (pNewLineSpec->m_pEnumeratedGroup == NULL)
				pNewLineSpec->m_pEnumeratedGroup = pNewSubLine;
			else
			{
				GATH_LINESPEC * pLineSpec = pNewLineSpec->m_pEnumeratedGroup;
				while (pLineSpec->m_pNext)
					pLineSpec = pLineSpec->m_pNext;
				pLineSpec->m_pNext = pNewSubLine;
			}
		}
		else
		{
			delete pNewLineSpec;
			return NULL;
		}
	}

	if (!VerifyAndAdvanceFile(pFile, CString("}")))
	{
		delete pNewLineSpec;
		return NULL;
	}

	return pNewLineSpec;
}

//-----------------------------------------------------------------------------
// This method reads in a "column" line from the file, adding the appropriate
// entries for the columns into the category referenced by dwID. The column
// line contains a bunch of fields in a list.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ReadColumnInfo(CFile * pFile, CMapWordToPtr & mapCategories, DWORD dwID)
{
	CString	strTemp;

	if (!VerifyAndAdvanceFile(pFile, CString(COLUMN_KEYWORD) + CString("(")))
		return FALSE;

	// Get the internal category referenced by dwID.

	INTERNAL_CATEGORY * pCategory = GetInternalRep(mapCategories, dwID);
	if (!pCategory)
		return FALSE;

	// We only allow one column specifier list per node.

	if (pCategory->m_pColSpec)
		return FALSE;

	// While we are still reading fields from the file, keep adding to the column list.

	GATH_FIELD * pNewField = new GATH_FIELD;
	if (pNewField == NULL)
		return FALSE;

	while (ReadField(pFile, *pNewField))
	{
		if (pCategory->m_pColSpec == NULL)
			pCategory->m_pColSpec = pNewField;
		else
		{
			// Scan to the last field in the linespec.m_pFields list, and insert the new field.

			GATH_FIELD * pFieldScan = pCategory->m_pColSpec;
			while (pFieldScan->m_pNext)
				pFieldScan = pFieldScan->m_pNext;
			pFieldScan->m_pNext = pNewField;
		}

		// Parse the width out of the column caption.

		if (pNewField->m_strFormat.ReverseFind(_T(',')) != -1)
		{
			strTemp = pNewField->m_strFormat.Right(pNewField->m_strFormat.GetLength() - pNewField->m_strFormat.ReverseFind(_T(',')) - 1);
			pNewField->m_usWidth = (unsigned short) _ttoi(strTemp);
			pNewField->m_strFormat = pNewField->m_strFormat.Left(pNewField->m_strFormat.GetLength() - strTemp.GetLength() - 1);
		}
		else
		{
			ASSERT(FALSE);
			pNewField->m_usWidth = (unsigned short) 80;
		}
		
		// Parse off any remaining information in the column label (the label ends
		// with [name, n], when n is the width, and name is the ID for the column
		// which should not be displayed).

		if (pNewField->m_strFormat.ReverseFind(_T('[')) != -1)
			pNewField->m_strFormat = pNewField->m_strFormat.Left(pNewField->m_strFormat.ReverseFind(_T('[')) - 1);

		// Read the sorting type from the file.

		if (ReadArgument(pFile, strTemp))
		{
			if (strTemp.CompareNoCase(CString(_T(SORT_LEXICAL))) == 0)
				pNewField->m_sort = LEXICAL;
			else if (strTemp.CompareNoCase(CString(_T(SORT_VALUE))) == 0)
				pNewField->m_sort = BYVALUE;
			else
				pNewField->m_sort = NOSORT;
		}
		else
			return FALSE;

		// Read the complexity (BASIC or ADVANCED) from the file.

		if (ReadArgument(pFile, strTemp))
		{
			if (strTemp.CompareNoCase(CString(_T(COMPLEXITY_ADVANCED))) == 0)
				pNewField->m_datacomplexity = ADVANCED;
			else
				pNewField->m_datacomplexity = BASIC;
		}
		else
			return FALSE;

		pNewField = new GATH_FIELD;
		if (pNewField == NULL)
			return FALSE;
	}

	delete pNewField;

	if (!VerifyAndAdvanceFile(pFile, CString(")")))
		return FALSE;

	return TRUE;
}

//-----------------------------------------------------------------------------
// Read in the information for a single line. Add the line to the internal
// representation of the category. NOTE: inefficient, since this will be
// called multiple times and the line list will need to be scanned to the
// end each time.
//-----------------------------------------------------------------------------

GATH_LINESPEC * CTemplateFileFunctions::ReadLineInfo(CFile * pFile)
{
	if (!VerifyAndAdvanceFile(pFile, CString(LINE_KEYWORD) + CString("(")))
		return NULL;

	// Declare a line specification variable to store the line info.

	GATH_LINESPEC * pNewLineSpec = new GATH_LINESPEC;
	if (pNewLineSpec == NULL)
		return NULL;

	// While we are still reading fields from the file, keep adding to the column list.
	// NOTE: inefficient, repeated scans through linespec.m_pFields list.

	GATH_FIELD * pNewField = new GATH_FIELD;
	if (pNewField == NULL)
	{
		delete pNewLineSpec;
		return NULL;
	}

	// Read in the complexity (BASIC or ADVANCED) for this line.

	CString strTemp;
	if (ReadArgument(pFile, strTemp))
	{
		if (strTemp.CompareNoCase(CString(_T(COMPLEXITY_ADVANCED))) == 0)
			pNewLineSpec->m_datacomplexity = ADVANCED;
		else
			pNewLineSpec->m_datacomplexity = BASIC;
	}
	else
		return FALSE;

	while (ReadField(pFile, *pNewField))
	{
		if (pNewLineSpec->m_pFields == NULL)
			pNewLineSpec->m_pFields = pNewField;
		else
		{
			// Scan to the last field in the linespec.m_pFields list, and insert the new field.

			GATH_FIELD * pFieldScan = pNewLineSpec->m_pFields;
			while (pFieldScan->m_pNext)
				pFieldScan = pFieldScan->m_pNext;
			pFieldScan->m_pNext = pNewField;
		}

		pNewField = new GATH_FIELD;
		if (pNewField == NULL)
		{
			delete pNewLineSpec;
			return NULL;
		}
	}

	delete pNewField;

	if (!VerifyAndAdvanceFile(pFile, CString(")")))
	{
		delete pNewLineSpec;
		return NULL;
	}

	return pNewLineSpec;
}

//-----------------------------------------------------------------------------
// This method returns the next keyword in the file. Any whitespace or
// punctuation is skipped until an alphanumeric character is read. The keyword
// returned is the string starting with this character until whitespace or
// punctuation is encountered. Note: it is very important that this function
// returns the file to the state it was in when the function started, with
// the current position restored.
//
// NOTE: inefficient
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::GetKeyword(CFile * pFile, CString & strKeyword)
{
	CString	strTemp = CString("");
	DWORD	dwPosition = pFile->GetPosition();
	WCHAR	cLastChar, cCurrentChar = L'\0';
	BOOL	fInComment = FALSE;

	// Skip over whitespace characters until we reach an alphanumeric char.

	do
	{
		// Save the last character read, since the comment token ("//") is
		// two characters long.

		cLastChar = cCurrentChar;

		// Read the next character in the file.

		if (pFile->Read((void *) &cCurrentChar, sizeof(WCHAR)) != sizeof(WCHAR))
			return FALSE;

		// If we're in a comment, and the character we just read isn't a new line,
		// we want to ignore it.

		if (fInComment)
		{
			if (cCurrentChar == L'\n')
				fInComment = FALSE;
			continue;
		}

		// Check to see if we've started into a comment.

		if (cCurrentChar == _T('/'))
		{
			if (cLastChar == _T('/'))
				fInComment = TRUE;
			continue;
		}
	} while (iswspace(cCurrentChar) || cCurrentChar == L'/' || fInComment);
		
	// Read the keyword while it's alphanumeric.

	if (iswalnum(cCurrentChar))
		do
		{
			strTemp += (TCHAR) cCurrentChar;

			if (pFile->Read((void *) &cCurrentChar, sizeof(WCHAR)) != sizeof(WCHAR))
				return FALSE;
		} while (iswalnum(cCurrentChar));

	// Reset the file, set the keyword and return.

	pFile->Seek((LONG)dwPosition, CFile::begin);
	strKeyword = strTemp;
	return !strTemp.IsEmpty();
}

//-----------------------------------------------------------------------------
// INTERNAL_CATEGORY constructor and destructor.
//-----------------------------------------------------------------------------

INTERNAL_CATEGORY::INTERNAL_CATEGORY()
{
	m_categoryName.m_strText	= CString(" ");
	m_fieldName.m_strFormat		= CString(" ");
	m_strEnumerateClass			= CString("");
	m_strIdentifier				= CString("");
	m_strNoInstances			= CString("");
	m_fListView					= FALSE;
	m_fDynamic					= FALSE;
	m_dwID						= 0;
	m_dwParentID				= 0;
	m_dwChildID					= 0;
	m_dwPrevID					= 0;
	m_dwNextID					= 0;
	m_dwDynamicChildID			= 0;
	m_dwColCount				= 0;
	m_pColSpec					= NULL;
	m_aCols						= NULL;
	m_pLineSpec					= NULL;
	m_dwLineCount				= 0;
	m_apLines					= NULL;
	m_fIncluded					= TRUE;
	m_fRefreshed				= FALSE;
	m_dwLastError				= S_OK; // GATH_ERR_NOERROR;
}

INTERNAL_CATEGORY::~INTERNAL_CATEGORY()
{
	if (m_pColSpec)
		delete m_pColSpec;

	if (m_aCols)
		delete [] m_aCols;

	if (m_pLineSpec)
		delete m_pLineSpec;

	if (m_apLines)
	{
		for (DWORD dwIndex = 0; dwIndex < m_dwLineCount; dwIndex++)
			delete m_apLines[dwIndex];
		delete [] m_apLines;
	}
}

//-----------------------------------------------------------------------------
// GATH_FIELD constructor and destructor.
//-----------------------------------------------------------------------------

GATH_FIELD::GATH_FIELD()
{
	m_pArgs				= NULL;
	m_pNext				= NULL;
	m_usWidth			= 0;
	m_sort				= NOSORT;
	m_datacomplexity	= BASIC;
}

GATH_FIELD::~GATH_FIELD()
{
	if (m_pArgs) delete m_pArgs;
	if (m_pNext) delete m_pNext;
}

//-----------------------------------------------------------------------------
// GATH_VALUE constructor and destructor.
//-----------------------------------------------------------------------------

GATH_VALUE::GATH_VALUE()
{
	m_pNext	 = NULL;
	m_dwValue = 0L;
}

GATH_VALUE::~GATH_VALUE()
{
	if (m_pNext) delete m_pNext;
}

//-----------------------------------------------------------------------------
// GATH_LINESPEC constructor and destructor.
//-----------------------------------------------------------------------------

GATH_LINESPEC::GATH_LINESPEC()
{
	m_pFields				= NULL;
	m_pEnumeratedGroup	= NULL;
	m_pConstraintFields	= NULL;
	m_pNext					= NULL;
	m_datacomplexity		= BASIC;
}

GATH_LINESPEC::~GATH_LINESPEC()
{
	if (m_pFields)
		delete m_pFields;

	if (m_pEnumeratedGroup)
		delete m_pEnumeratedGroup;

	if (m_pConstraintFields)
		delete m_pConstraintFields;

	if (m_pNext)
		delete m_pNext;
}

//-----------------------------------------------------------------------------
// GATH_LINE constructor and destructor.
//-----------------------------------------------------------------------------

GATH_LINE::GATH_LINE()
{
	m_datacomplexity = BASIC;
	m_aValue = NULL;
}

GATH_LINE::~GATH_LINE()
{
	if (m_aValue)
		delete [] m_aValue;
}

//-----------------------------------------------------------------------------
// This function is called to refresh the data for all of the extensions. It
// will use the refresh index to look up the line spec, and then call some
// version 5.0 functions to do the refresh. Finally, it will convert the
// data generated by those functions into our new format.
//-----------------------------------------------------------------------------

HRESULT RefreshExtensions(CWMIHelper * pWMI, DWORD dwIndex, volatile BOOL * pfCancel, CPtrList * aColValues, int iColCount, void ** ppCache)
{
	HRESULT hr = S_OK;

	if (pWMI == NULL)
		return hr;

	pWMI->m_hrLastVersion5Error = S_OK;

	// Reset the caches so the data is actually refreshed (140535).

	pWMI->Version5ClearCache();
	pWMI->m_enumMap.Reset();

	// Get the line spec pointer for this index.

	GATH_LINESPEC * pLineSpec = gmapExtensionRefreshData.Lookup(dwIndex);
	if (pLineSpec == NULL)
		return hr;

	// Here's some code from 5.0 for refreshing a list of line pointers for a line spec.

	CPtrList listLinePtrs;
	if (CRefreshFunctions::RefreshLines(pWMI, pLineSpec, (DWORD) iColCount, listLinePtrs, pfCancel))
	{
		// Move the contents of the list of lines to our internal structures.

		if (listLinePtrs.GetCount() > 0)
		{
			GATH_LINE * pLine;

			for (POSITION pos = listLinePtrs.GetHeadPosition(); pos != NULL;)
			{
				pLine = (GATH_LINE *) listLinePtrs.GetNext(pos);
				if (pLine == NULL || pLine->m_aValue == NULL)
					continue;

				for (int iCol = 0; iCol < iColCount; iCol++)
				{
					CString strValue  = pLine->m_aValue[iCol].m_strText;
					DWORD	dwValue   = pLine->m_aValue[iCol].m_dwValue;
					BOOL	fAdvanced = (pLine->m_datacomplexity == ADVANCED);

					pWMI->AppendCell(aColValues[iCol], strValue, dwValue, fAdvanced);
				}

				delete pLine;
			}
		}
		else
		{
			CString * pstrNoData = gmapExtensionRefreshData.LookupString(dwIndex);
			
			if (pstrNoData && !pstrNoData->IsEmpty() && iColCount > 0)
			{
				pWMI->AppendCell(aColValues[0], *pstrNoData, 0, FALSE);
				for (int iCol = 1; iCol < iColCount; iCol++)
					pWMI->AppendCell(aColValues[iCol], _T(""), 0, FALSE);
			}
		}
	}

	return pWMI->m_hrLastVersion5Error;
}

//-----------------------------------------------------------------------------
// Refresh the list of lines based on the list of line fields. We'll also
// need to set the number of lines. The list of lines is generated based on
// the pLineSpec pointer and dwColumns variables. The generated lines are
// returned in the listLinePtrs parameter.
//-----------------------------------------------------------------------------

BOOL CRefreshFunctions::RefreshLines(CWMIHelper * pWMI, GATH_LINESPEC * pLineSpec, DWORD dwColumns, CPtrList & listLinePtrs, volatile BOOL * pfCancel)
{
	BOOL bReturn = TRUE;

	// Traverse the list of line specifiers to generate the list of lines.

	GATH_LINESPEC *	pCurrentLineSpec = pLineSpec;
	GATH_LINE *		pLine = NULL;

	while (pCurrentLineSpec && (pfCancel == NULL || *pfCancel == FALSE))
	{
		// Check if the current line spec is for a single line or an enumerated group.

		if (pCurrentLineSpec->m_strEnumerateClass.IsEmpty() || pCurrentLineSpec->m_strEnumerateClass.CompareNoCase(CString(STATIC_SOURCE)) == 0)
		{
			// This is for a single line. Allocate a new line structure and fill it
			// in with the data generated from the line spec.

			pLine = new GATH_LINE;
			if (pLine == NULL)
			{
				bReturn = FALSE;
				break;
			}

			try
			{
				if (RefreshOneLine(pWMI, pLine, pCurrentLineSpec, dwColumns))
					listLinePtrs.AddTail((void *) pLine);
				else
				{
					bReturn = FALSE;
					break;
				}
			}
			catch (...)
			{
				if (pLine)
					delete pLine;
				pLine = NULL;
				bReturn = FALSE;
				break;
			}
		}
		else
		{
			// This line represents an enumerated group of lines. We need to enumerate
			// the class and call RefreshLines for the group of enumerated lines, once
			// for each class instance.

			if (pWMI->Version5ResetClass(pCurrentLineSpec->m_strEnumerateClass, pCurrentLineSpec->m_pConstraintFields))
				do
				{
					if (!RefreshLines(pWMI, pCurrentLineSpec->m_pEnumeratedGroup, dwColumns, listLinePtrs, pfCancel))
						break;
				} while (pWMI->Version5EnumClass(pCurrentLineSpec->m_strEnumerateClass, pCurrentLineSpec->m_pConstraintFields));
		}

		pCurrentLineSpec = pCurrentLineSpec->m_pNext;
	}

	if (pfCancel && *pfCancel)
		return FALSE;

	// If there was a failure generating the lines, clean up after ourselves.

	if (!bReturn)
	{
		if (pLine)
			delete pLine;

		for (POSITION pos = listLinePtrs.GetHeadPosition(); pos != NULL;)
		{
			pLine = (GATH_LINE *) listLinePtrs.GetNext(pos) ;
			if (pLine)
				delete pLine;
		}

		listLinePtrs.RemoveAll();
		return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Refresh a line based on a line spec.
//-----------------------------------------------------------------------------

BOOL CRefreshFunctions::RefreshOneLine(CWMIHelper * pWMI, GATH_LINE * pLine, GATH_LINESPEC * pLineSpec, DWORD dwColCount)
{
	// Allocate the new array of values.

	if (pLine->m_aValue)
		delete [] pLine->m_aValue;

	pLine->m_aValue = new GATH_VALUE[dwColCount];
	if (pLine->m_aValue == NULL)
		return FALSE;

	// Set the data complexity for the line based on the line spec.

	pLine->m_datacomplexity = pLineSpec->m_datacomplexity;

	// Compute each of the values for the fields.

	GATH_FIELD * pField = pLineSpec->m_pFields;
	for (DWORD dwIndex = 0; dwIndex < dwColCount; dwIndex++)
	{
		if (pField == NULL)
			return FALSE;
		if (!RefreshValue(pWMI, &pLine->m_aValue[dwIndex], pField))
			return FALSE;
		pField = pField->m_pNext;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// This method takes the information in a GATH_FIELD struct and uses it to
// generate a current GATH_VALUE struct.
//-----------------------------------------------------------------------------

BOOL CRefreshFunctions::RefreshValue(CWMIHelper * pWMI, GATH_VALUE * pVal, GATH_FIELD * pField)
{
	TCHAR			szFormatFragment[MAX_PATH];
	const TCHAR		*pSourceChar;
	TCHAR			*pDestinationChar;
	TCHAR			cFormat = _T('\0');
	BOOL			fReadPercent = FALSE;
	BOOL			fReturnValue = TRUE;
	CString			strResult, strTemp;
	int				iArgNumber = 0;
	DWORD			dwValue = 0L;

	// Process the format string. Because of the difficulty caused by having
	// variable number of arguments to be inserted (like printf), we'll need
	// to break the format string into chunks and do the sprintf function
	// for each format flag we come across.

	pSourceChar			= (LPCTSTR) pField->m_strFormat;
	pDestinationChar	= szFormatFragment;

	while (*pSourceChar)
	{
		if (fReadPercent)
		{
			// If we read a percent sign, we should be looking for a valid flag.
			// We are using some additional flags to printf (and not supporting
			// others). If we read another percent, just insert a single percent.
			
			switch (*pSourceChar)
			{
			case _T('%'):
				fReadPercent = FALSE;
				break;

			case _T('b'): case _T('B'):
			case _T('l'): case _T('L'):
			case _T('u'): case _T('U'):
			case _T('s'): case _T('S'):
				fReadPercent = FALSE;
				cFormat = *pSourceChar;
				*pDestinationChar = _T('s');
				break;

			case _T('t'): case _T('T'):
				fReadPercent = FALSE;
				cFormat = *pSourceChar;
				*pDestinationChar = _T('s');
				break;

			case _T('x'): case _T('X'):
			case _T('d'): case _T('D'):
				fReadPercent = FALSE;
				cFormat = _T('d');
				*pDestinationChar = *pSourceChar;
				break;

			case _T('q'): case _T('Q'):
				fReadPercent = FALSE;
				cFormat = _T('q');
				*pDestinationChar = _T('s');
				break;

			case _T('z'): case _T('Z'):
				fReadPercent = FALSE;
				cFormat = _T('z');
				*pDestinationChar = _T('s');
				break;

			case _T('y'): case _T('Y'):
				fReadPercent = FALSE;
				cFormat = _T('y');
				*pDestinationChar = _T('s');
				break;

			case _T('v'): case _T('V'):
				fReadPercent = FALSE;
				cFormat = _T('v');
				*pDestinationChar = _T('s');
				break;

			case _T('f'): case _T('F'):
				fReadPercent = FALSE;
				cFormat = *pSourceChar;
				*pDestinationChar = *pSourceChar;
				break;

			default:
				*pDestinationChar = *pSourceChar;
			}
		}
		else if (*pSourceChar == _T('%'))
		{
			*pDestinationChar = _T('%');
			fReadPercent = TRUE;
		}
		else
			*pDestinationChar = *pSourceChar;

		pSourceChar++;
		pDestinationChar++;

		// If a format flag is set or we are at the end of the source string,
		// then we have a complete fragment and we should produce some output,
		// which will be concatenated to the strResult string.

		if (cFormat || *pSourceChar == _T('\0'))
		{
			*pDestinationChar = _T('\0');
			if (cFormat)
			{
				// Based on the format type, get a value from the provider for
				// the next argument. Format the result using the formatting 
				// fragment we extracted, and concatenate it.

				if (GetValue(pWMI, cFormat, szFormatFragment, strTemp, dwValue, pField, iArgNumber++))
				{
					strResult += strTemp;
					cFormat = _T('\0');
				}
				else
				{
					strResult = strTemp;
					break;
				}
			}
			else
			{
				// There was no format flag, but we are at the end of the string.
				// Add the fragment we got to the result string.

				strResult += CString(szFormatFragment);
			}

			pDestinationChar = szFormatFragment;
		}
	}

	// Assign the values we generated to the GATH_VALUE structure. Important note:
	// the dwValue variable will only have ONE value, even though multiple values
	// might have been generated to build the strResult string. Only the last
	// value will be saved in dwValue. This is OK, because this value is only
	// used for sorting a column when the column is marked for non-lexical sorting.
	// In that case, there should be only one value used to generat the string.

	pVal->m_strText = strResult;
	pVal->m_dwValue = dwValue;

	return fReturnValue;
}

//-----------------------------------------------------------------------------
// Return a string with delimiters added for the number.
//-----------------------------------------------------------------------------

CString DelimitNumber(double dblValue)
{
	NUMBERFMT fmt;
	TCHAR szResult[MAX_PATH] = _T("");
	TCHAR szDelimiter[4] = _T(",");

	GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szDelimiter, 4);

	memset(&fmt, 0, sizeof(NUMBERFMT));
	fmt.Grouping = 3;
	fmt.lpDecimalSep = _T(""); // doesn't matter - there aren't decimal digits
	fmt.lpThousandSep = szDelimiter;

	CString strValue;
	strValue.Format(_T("%.0f"), dblValue);
	GetNumberFormat(LOCALE_USER_DEFAULT, 0, strValue, &fmt, szResult, MAX_PATH);

	return CString(szResult);
}

//-----------------------------------------------------------------------------
// This method gets a single value from the provider, based on the format
// character from the template file. It formats the results using the 
// format string szFormatFragment, which should only take one argument.
//-----------------------------------------------------------------------------

BOOL CRefreshFunctions::GetValue(CWMIHelper * pWMI, TCHAR cFormat, TCHAR *szFormatFragment, CString &strResult, DWORD &dwResult, GATH_FIELD *pField, int iArgNumber)
{
	CString			strTemp;
	COleDateTime	datetimeTemp;
	double			dblValue;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	strResult.Empty();
	dwResult = 0L;

	if (!pField->m_strSource.IsEmpty() && pField->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) != 0)
	{
		// Find the right argument for this formatting (indicated by the iArgNumber
		// parameter.

		GATH_VALUE * pArg = pField->m_pArgs;
		while (iArgNumber && pArg)
		{
			pArg = pArg->m_pNext;
			iArgNumber--;
		}

		if (pArg == NULL)
			return FALSE;

		switch (cFormat)
		{
		case 'b': case 'B':
			// This is a boolean type. Show either true or false, depending on
			// the numeric value.

			if (pWMI->Version5QueryValueDWORD(pField->m_strSource, pArg->m_strText, dwResult, strTemp))
			{
				strTemp = (dwResult) ? pWMI->m_strTrue : pWMI->m_strFalse;
				strResult.Format(szFormatFragment, strTemp);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'd': case 'D':
			// This is the numeric type.

			if (pWMI->Version5QueryValueDWORD(pField->m_strSource, pArg->m_strText, dwResult, strTemp))
			{
				strResult.Format(szFormatFragment, dwResult);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'f': case 'F':
			// This is the double floating point type.

			if (pWMI->Version5QueryValueDoubleFloat(pField->m_strSource, pArg->m_strText, dblValue, strTemp))
			{
				strResult.Format(szFormatFragment, dblValue);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 't': case 'T':
			// This is the OLE date and time type. Format the date and time into the
			// string result, and return the date part in the DWORD (the day number is
			// to the left of the decimal in the DATE type).

			if (pWMI->Version5QueryValueDateTime(pField->m_strSource, pArg->m_strText, datetimeTemp, strTemp))
			{
				strResult = datetimeTemp.Format();
				dwResult  = (DWORD)(DATE)datetimeTemp;
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'l': case 'L':
			// This is a string type, with the string converted to lower case.

			if (pWMI->Version5QueryValue(pField->m_strSource, pArg->m_strText, strTemp))
			{
				strTemp.MakeLower();
				strResult.Format(szFormatFragment, strTemp);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'u': case 'U':
			// This is a string type, with the string converted to upper case.

			if (pWMI->Version5QueryValue(pField->m_strSource, pArg->m_strText, strTemp))
			{
				strTemp.MakeUpper();
				strResult.Format(szFormatFragment, strTemp);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 's': case 'S':
			// This is the string type (string is the default type).

			if (pWMI->Version5QueryValue(pField->m_strSource, pArg->m_strText, strTemp))
			{
				strResult.Format(szFormatFragment, strTemp);

				// We only need to do this when the value returned is a number
				// and is going in a column that we want to sort numerically.
				// This won't break the case where a numeric string is to be
				// sorted as a string because dwResult will be ignored.
				if (!strTemp.IsEmpty() && iswdigit( strTemp[0]))
					dwResult = _ttol( (LPCTSTR)strTemp);

				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'q': case 'Q':
			// This is a specialized type for the Win32_BIOS class. We want to show
			// the "Version" property - if it isn't there, then we want to show
			// the "Name" property and "ReleaseDate" properties concatenated
			// together.

			if (pWMI->Version5QueryValue(pField->m_strSource, CString(_T("Version")), strTemp))
			{
				strResult = strTemp;
				return TRUE;
			}
			else
			{
				if (pWMI->Version5QueryValue(pField->m_strSource, CString(_T("Name")), strTemp))
					strResult = strTemp;

				if (pWMI->Version5QueryValueDateTime(pField->m_strSource, CString(_T("ReleaseDate")), datetimeTemp, strTemp))
					strResult += CString(_T(" ")) + datetimeTemp.Format();

				return TRUE;
			}
			break;

		case 'z': case 'Z':
			// This is a specialized size type, where the value is a numeric count
			// of bytes. We want to convert it into the best possible units for
			// display (for example, display "4.20 MB (4,406,292 bytes)").

			if (pWMI->Version5QueryValueDoubleFloat(pField->m_strSource, pArg->m_strText, dblValue, strTemp))
			{
				double	dValue = (double) dblValue;
				DWORD	dwDivisor = 1;

				// Reduce the dValue to the smallest possible number (with a larger unit).

				while (dValue > 1024.0 && dwDivisor < (1024 * 1024 * 1024))
				{
					dwDivisor *= 1024;
					dValue /= 1024.0;
				}

				if (dwDivisor == 1)
					strResult.Format(IDS_SIZEBYTES, DelimitNumber(dblValue));
				else if (dwDivisor == (1024))
					strResult.Format(IDS_SIZEKB_BYTES, dValue, DelimitNumber(dblValue));
				else if (dwDivisor == (1024 * 1024))
					strResult.Format(IDS_SIZEMB_BYTES, dValue, DelimitNumber(dblValue));
				else if (dwDivisor == (1024 * 1024 * 1024))
					strResult.Format(IDS_SIZEGB_BYTES, dValue, DelimitNumber(dblValue));

				dwResult = (DWORD) dblValue;	// So we can sort on this value (bug 391127).
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'y': case 'Y':
			// This is a specialized size type, where the value is a numeric count
			// of bytes, already in KB. If it's big enough, show it in MB or GB.

			if (pWMI->Version5QueryValueDoubleFloat(pField->m_strSource, pArg->m_strText, dblValue, strTemp))
			{
				strResult.Format(IDS_SIZEKB, DelimitNumber(dblValue));
				dwResult = (DWORD) dblValue;	// So we can sort on this value (bug 391127).
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'v': case 'V':
			// This is a specialized type, assumed to be an LCID (locale ID). Show the
			// locale.

			if (pWMI->Version5QueryValue(pField->m_strSource, pArg->m_strText, strTemp))
			{
				// strTemp contains a string locale ID (like "0409"). Convert it into
				// and actual LCID.

				LCID lcid = (LCID) _tcstoul(strTemp, NULL, 16);
				TCHAR szCountry[MAX_PATH];
				if (GetLocaleInfo(lcid, LOCALE_SCOUNTRY, szCountry, MAX_PATH))
					strResult = szCountry;
				else
					strResult = strTemp;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		default:
			ASSERT(FALSE); // unknown formatting flag
			return TRUE;
		}
	}

	return FALSE;
}

//=============================================================================
// Functions extending the CWMILiveHelper to support version 5 style refreshes.
//=============================================================================

#include "wmilive.h"

//-----------------------------------------------------------------------------
// Reset the CMSIEnumerator pointer to the start of the enumeration (and
// make sure there is one). Remove the object pointer, so the first call
// to GetObject will return the first item in the enumerator.
//-----------------------------------------------------------------------------

BOOL CWMILiveHelper::Version5ResetClass(const CString & strClass, GATH_FIELD * pConstraints)
{
	CMSIEnumerator * pMSIEnumerator = Version5GetEnumObject(strClass, pConstraints);
	if (pMSIEnumerator == NULL)
		return FALSE;

	// Reset the enumerator, and remove the cached object pointer if there is one.

	pMSIEnumerator->Reset(pConstraints);
	Version5RemoveObject(strClass);

	CMSIObject * pObject = Version5GetObject(strClass, pConstraints);
	if (pObject == NULL || pObject->IsValid() == MOS_NO_INSTANCES)
		return FALSE;
		
	return TRUE;
}

//-----------------------------------------------------------------------------
// Move the cached IWbemClassObject pointer to the next instance.
//-----------------------------------------------------------------------------

BOOL CWMILiveHelper::Version5EnumClass(const CString & strClass, GATH_FIELD * pConstraints)
{
	// Verify that there is an object enumerator in place.

	if (Version5GetEnumObject(strClass, pConstraints) == NULL)
		return FALSE;

	// If there is an object interface, remove it, then make a new one.
	// Then retrieve the object pointer (this will do the Next on the
	// enumerator to get the next instance).

	Version5RemoveObject(strClass);
	CMSIObject * pObject = Version5GetObject(strClass, pConstraints);
	if (pObject && (pObject->IsValid() == MOS_INSTANCE))
		return TRUE;

	return FALSE;
}

//-----------------------------------------------------------------------------
// Retrieve the interface pointer for the specified IEnumWbemClassObject.
// If there isn't one cached, create one and cache it. It's possible for the
// pConstraints parameter to contain a field specify a WBEM SQL condition for
// this enumerator.
//-----------------------------------------------------------------------------

CMSIEnumerator * CWMILiveHelper::Version5GetEnumObject(const CString & strClass, const GATH_FIELD * pConstraints)
{
	// See if we've cached this enumerator object.

	CMSIEnumerator * pReturn = NULL;
	if (m_mapClassToEnumInterface.Lookup(strClass, (void * &) pReturn))
		return pReturn;

	// We'll need to create this enumerator here, and save it in the cache.

	pReturn = new CMSIEnumerator;
	if (pReturn == NULL)	
		return NULL;

	if (FAILED(pReturn->Create(strClass, pConstraints, this)))
	{
		delete pReturn;
		return NULL;
	}

	m_mapClassToEnumInterface.SetAt(strClass, (void *) pReturn);
	return pReturn;
}

//-----------------------------------------------------------------------------
// Remove the specified IWbemClassObject pointer from the cache.
//-----------------------------------------------------------------------------

void CWMILiveHelper::Version5RemoveObject(const CString & strClass)
{
	CMSIObject * pObject = NULL;

	if (m_mapClassToInterface.Lookup(strClass, (void * &) pObject) && pObject)
		delete pObject;

	m_mapClassToInterface.RemoveKey(strClass);
}

//-----------------------------------------------------------------------------
// Retrieve the interface pointer for the specified IWbemClassObject.
// If there isn't one cached, create one and cache it.
//-----------------------------------------------------------------------------

CMSIObject * CWMILiveHelper::Version5GetObject(const CString & strClass, const GATH_FIELD * pConstraints, CString * pstrLabel)
{
	CMSIObject * pReturn = NULL;
	if (m_mapClassToInterface.Lookup(strClass, (void * &) pReturn))
		return pReturn;

	// We don't have one of these objects cached. Get one from the enumerator.

	CMSIEnumerator * pEnumerator = Version5GetEnumObject(strClass);
	if (pEnumerator)
	{
		HRESULT hr = pEnumerator->Next(&pReturn);
		if (S_OK != hr)
		{
			if (pReturn)
				delete pReturn;
			pReturn = NULL;

			m_hrError = hr;
		}
	}

	if (pReturn)
		m_mapClassToInterface.SetAt(strClass, (void *) pReturn);

	return pReturn;
}

//-----------------------------------------------------------------------------
// This method is used to get the current value for a given class and property
// string. Starting with the IWbemServices interface, it gets an interface
// for the requested class enums the first instance. Performance is improved
// by caching the instance interfaces in m_mapClassToInterface.
//-----------------------------------------------------------------------------

BOOL CWMILiveHelper::Version5QueryValue(const CString & strClass, const CString & strProperty, CString & strResult)
{
	strResult.Empty();

	CMSIObject * pObject = Version5GetObject(strClass, NULL);
	ASSERT(pObject);
	if (!pObject)
		return FALSE;

	switch (pObject->IsValid())
	{
	case MOS_INSTANCE:
		{
			BOOL fUseValueMap = FALSE;
			CString strProp(strProperty);

			if (strProp.Left(8) == CString(_T("ValueMap")))
			{
				strProp = strProp.Right(strProp.GetLength() - 8);
				fUseValueMap = TRUE;
			}

			VARIANT variant;
			BSTR	propName = strProp.AllocSysString();

			VariantInit(&variant);
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
			{
				// If the property we just got is an array, we should convert it to string
				// containing a list of the items in the array.

				if ((variant.vt & VT_ARRAY) && (variant.vt & VT_BSTR) && variant.parray)
				{
					if (SafeArrayGetDim(variant.parray) == 1)
					{
						long lLower = 0, lUpper = 0;

						SafeArrayGetLBound(variant.parray, 0, &lLower);
						SafeArrayGetUBound(variant.parray, 0, &lUpper);

						CString	strWorking;
						BSTR	bstr = NULL;
						for (long i = lLower; i <= lUpper; i++)
							if (SUCCEEDED(SafeArrayGetElement(variant.parray, &i, (wchar_t*)&bstr)))
							{
								if (i != lLower)
									strWorking += _T(", ");
								strWorking += bstr;
							}
						strResult = strWorking;
						return TRUE;
					}
				}
				else if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					strResult = V_BSTR(&variant);

					CString strFound;
					if (fUseValueMap && SUCCEEDED(Version5CheckValueMap(strClass, strProp, strResult, strFound)))
						strResult = strFound;

					return TRUE;
				}
				else
					strResult = m_strPropertyUnavail;
			}
			else
				strResult = m_strBadProperty;
		}
		break;

	case MOS_MSG_INSTANCE:
		pObject->GetErrorLabel(strResult);
		break;

	case MOS_NO_INSTANCES:
	default:
		ASSERT(FALSE);
		break;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// This method is equivalent to QueryValue, except it returns a DWORD value.
// If FALSE is returned, then the string in strMessage should be displayed.
//-----------------------------------------------------------------------------

BOOL CWMILiveHelper::Version5QueryValueDWORD(const CString & strClass, const CString & strProperty, DWORD & dwResult, CString & strMessage)
{
	dwResult = 0L;
	strMessage.Empty();

	CMSIObject * pObject = Version5GetObject(strClass, NULL);
	ASSERT(pObject);
	if (!pObject)
		return FALSE;

	switch (pObject->IsValid())
	{
	case MOS_INSTANCE:
		{
			VARIANT variant;
			BSTR	propName = strProperty.AllocSysString();

			VariantInit(&variant);
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
			{
				if (VariantChangeType(&variant, &variant, 0, VT_I4) == S_OK)
				{
					dwResult = V_I4(&variant);
					return TRUE;
				}
				else
					strMessage = m_strPropertyUnavail;
			}
			else
				strMessage = m_strBadProperty;
		}
		break;

	case MOS_MSG_INSTANCE:
		pObject->GetErrorLabel(strMessage);
		break;

	case MOS_NO_INSTANCES:
	default:
		ASSERT(FALSE);
		break;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// This method is equivalent to QueryValue, except it returns a double float
// value. If FALSE is returned, then the string in strMessage should
// be displayed.
//-----------------------------------------------------------------------------

BOOL CWMILiveHelper::Version5QueryValueDoubleFloat(const CString & strClass, const CString & strProperty, double & dblResult, CString & strMessage)
{
	dblResult = 0L;
	strMessage.Empty();

	CMSIObject * pObject = Version5GetObject(strClass, NULL);
	ASSERT(pObject);
	if (!pObject)
		return FALSE;

	switch (pObject->IsValid())
	{
	case MOS_INSTANCE:
		{
			VARIANT variant;
			BSTR	propName = strProperty.AllocSysString();

			VariantInit(&variant);
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
			{
				if (VariantChangeType(&variant, &variant, 0, VT_R8) == S_OK)
				{
					dblResult = V_R8(&variant);
					return TRUE;
				}
				else
					strMessage = m_strPropertyUnavail;
			}
			else
				strMessage = m_strBadProperty;
		}
		break;

	case MOS_MSG_INSTANCE:
		pObject->GetErrorLabel(strMessage);
		break;

	case MOS_NO_INSTANCES:
	default:
		ASSERT(FALSE);
		break;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// This method is equivalent to QueryValue, except it returns an OLE date
// & time object. If FALSE is returned, then the string in strMessage should
// be displayed.
//-----------------------------------------------------------------------------

BOOL CWMILiveHelper::Version5QueryValueDateTime(const CString & strClass, const CString & strProperty, COleDateTime & datetime, CString & strMessage)
{
	datetime.SetDateTime(0, 1, 1, 0, 0, 0);
	strMessage.Empty();

	CMSIObject * pObject = Version5GetObject(strClass, NULL);
	ASSERT(pObject);
	if (!pObject)
		return FALSE;

	switch (pObject->IsValid())
	{
	case MOS_INSTANCE:
		{
			VARIANT variant;
			BSTR	propName = strProperty.AllocSysString();

			VariantInit(&variant);
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
			{
				if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					// Parse the date and time into an COleDateTime object. Note: we should
					// be able to get an OLE date from WBEM, but for now we need to just
					// deal with the string returned.

					int     nYear, nMonth, nDay, nHour, nMin, nSec;
					CString strTemp = V_BSTR(&variant);

					nYear   = _ttoi(strTemp.Mid(0,  4));
					nMonth  = _ttoi(strTemp.Mid(4,  2));
					nDay    = _ttoi(strTemp.Mid(6,  2));
					nHour   = _ttoi(strTemp.Mid(8,  2));
					nMin    = _ttoi(strTemp.Mid(10, 2));
					nSec    = _ttoi(strTemp.Mid(12, 2));

					datetime.SetDateTime(nYear, nMonth, nDay, nHour, nMin, nSec);
					return TRUE;
				}
				else
					strMessage = m_strPropertyUnavail;
			}
			else
				strMessage = m_strBadProperty;
		}
		break;

	case MOS_MSG_INSTANCE:
		pObject->GetErrorLabel(strMessage);
		break;

	case MOS_NO_INSTANCES:
	default:
		ASSERT(FALSE);
		break;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Evaluate whether or not a specific object meets the filtering requirements
// set by the constraints (filtering are the constraints where one half is
// a static value).
//-----------------------------------------------------------------------------

BOOL CWMILiveHelper::Version5EvaluateFilter(IWbemClassObject * pObject, const GATH_FIELD * pConstraints)
{
	const GATH_FIELD	*	pLHS = pConstraints, * pRHS = NULL;
	VARIANT					variant;
	CString					strValue;
	BSTR					propName;

	ASSERT(pObject);
	if (pObject == NULL)
		return FALSE;

	while (pLHS && pLHS->m_pNext)
	{
		pRHS = pLHS->m_pNext;
		VariantInit(&variant);

		// If either the left or right hand side is static, we need to do the check.
		// First check out if the left side is static.

		if (pLHS->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0 && pRHS->m_pArgs)
		{
			propName = pRHS->m_pArgs->m_strText.AllocSysString();
			strValue.Empty();

			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
				if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					strValue = V_BSTR(&variant);
					if (strValue.CompareNoCase(pLHS->m_strFormat) != 0)
						return FALSE;
				}
		}

		// Next check out if the right side is static.

		if (pRHS->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0 && pLHS->m_pArgs)
		{
			propName = pLHS->m_pArgs->m_strText.AllocSysString();
			strValue.Empty();

			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
				if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					strValue = V_BSTR(&variant);
					if (strValue.CompareNoCase(pRHS->m_strFormat) != 0)
						return FALSE;
				}
		}

		// Advance our pointer to the left hand side by two.

		pLHS = pRHS->m_pNext;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// This method uses an object interface and the constraint fields to advance
// any joined classes to the correct instances.
//-----------------------------------------------------------------------------

void CWMILiveHelper::Version5EvaluateJoin(const CString & strClass, IWbemClassObject * pObject, const GATH_FIELD * pConstraints)
{
	const GATH_FIELD		*pLHS = pConstraints, *pRHS = NULL;
	const GATH_FIELD		*pEnumerated, *pJoinedTo;
	GATH_FIELD				fieldEnumerated, fieldJoinedTo;
	VARIANT					variant;
	CString					strValue;
	BSTR					propName;

	ASSERT(pObject);
	if (pObject == NULL)
		return;

	while (pLHS && pLHS->m_pNext)
	{
		pRHS = pLHS->m_pNext;

		// If either side is static, this is a filter, rather than a join.

		if ((pRHS->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0) ||
			 (pLHS->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0))
		{
			pLHS = pRHS->m_pNext;
			continue;
		}

		// Find out which side refers to the class we're enumerating.

		if (pRHS->m_strSource.CompareNoCase(strClass) == 0)
		{
			pEnumerated = pRHS;
			pJoinedTo = pLHS;
		}
		else if (pLHS->m_strSource.CompareNoCase(strClass) == 0)
		{
			pEnumerated = pLHS;
			pJoinedTo = pRHS;
		}
		else
		{
			pLHS = pRHS->m_pNext;
			continue;
		}

		// Next, enumerate through the instances of the joined to class until
		// we find one which satisfies the constraint. We can use the EvaluateFilter
		// method to find out when the constraint is met. Set up a field pointer
		// for the constraint (get the value from the enumerated class and use it
		// as a static.

		fieldJoinedTo = *pJoinedTo;
		fieldJoinedTo.m_pNext = NULL;

		VariantInit(&variant);
		strValue.Empty();
		if (pEnumerated->m_pArgs)
		{
			propName = pEnumerated->m_pArgs->m_strText.AllocSysString();
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
				if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					strValue = V_BSTR(&variant);
				}
		}

		fieldEnumerated.m_strSource = CString(STATIC_SOURCE);
		fieldEnumerated.m_pNext = &fieldJoinedTo;
		fieldEnumerated.m_strFormat = strValue;

		// Now, enumerate the joined to class until it meets the constraints.

		Version5RemoveObject(pJoinedTo->m_strSource);
		Version5ResetClass(pJoinedTo->m_strSource, &fieldEnumerated);
		Version5GetObject(pJoinedTo->m_strSource, &fieldEnumerated);

		// Advance our pointer to the left hand side by two.

		pLHS = pRHS->m_pNext;
	}

	// Because the GATH_FIELD destructor follows next pointers, we want
	// to unlink our two GATH_FIELD locals. Also, we don't want the
	// destructor for fieldJoinedTo to delete the arguments.

	fieldEnumerated.m_pNext = NULL;
	fieldJoinedTo.m_pArgs = NULL;
}

//-----------------------------------------------------------------------------
// Evaluate whether or not the constraints indicate that a class is being
// enumerated as a dependency class. This is currently indicated by a single
// field structure with a static value of "dependency".
//-----------------------------------------------------------------------------

BOOL CWMILiveHelper::Version5IsDependencyJoin(const GATH_FIELD * pConstraints)
{
	if (pConstraints != NULL && pConstraints->m_pNext == NULL)
		if (pConstraints->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0)
			if (pConstraints->m_strFormat.CompareNoCase(CString(DEPENDENCY_JOIN)) == 0)
				return TRUE;

	return FALSE;
}

//-----------------------------------------------------------------------------
// This method is used when a dependency class is being enumerated. In a
// dependency class, each property of a class instance contains a reference
// to an instance in another class. This method will cache eache of the
// instances specified by the dependency class so properties of those instances
// can be referred to in the line structures.
//-----------------------------------------------------------------------------

void CWMILiveHelper::Version5EvaluateDependencyJoin(IWbemClassObject * pObject)
{
	VARIANT				variant, varClassName;
	IWbemClassObject *	pNewObject = NULL;

	//if (pObject->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_LOCAL_ONLY) == S_OK)
	//while (pObject->Next(0, NULL, &variant, NULL, NULL) == S_OK)

	VariantInit(&variant);
	VariantClear(&variant);
	if (pObject->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY) == WBEM_S_NO_ERROR)
		while (pObject->Next(0, NULL, &variant, NULL, NULL) == WBEM_S_NO_ERROR)
		{
			if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
			{
				// Use the object path to create a pointer to the specified
				// object and store it in the cache.

				CString strObjectPath = V_BSTR(&variant);
				BSTR	bstrObjectPath = strObjectPath.AllocSysString();

				HRESULT hRes = m_pIWbemServices->GetObject(bstrObjectPath, 0, NULL, &pNewObject, NULL);

				if (SUCCEEDED(hRes))
				{
					// We need to get the class name of the new object so we know
					// where to cache it. We could parse it out of the object path,
					// but it will be better in the long run to get it by querying
					// the new object.

					if (pNewObject)
					{
						CString	strClassName, strClassNameProp(_T("__CLASS"));
						BSTR	classNameProp = strClassNameProp.AllocSysString();

						VariantInit(&varClassName);
						VariantClear(&varClassName);
						if (pNewObject->Get(classNameProp, 0L, &varClassName, NULL, NULL) == S_OK)
							if (VariantChangeType(&varClassName, &varClassName, 0, VT_BSTR) == S_OK)
								strClassName = V_BSTR(&varClassName);

						if (!strClassName.IsEmpty())
						{
							CMSIObject * pNewMSIObject = new CMSIObject(pNewObject, CString(_T("")), S_OK, this, MOS_INSTANCE);
							if (pNewMSIObject)
							{
								CMSIObject * pOldObject = NULL;
								
								if (m_mapClassToInterface.Lookup(strClassName, (void * &) pOldObject) && pOldObject)
									delete pOldObject;
								m_mapClassToInterface.SetAt(strClassName, (void *) pNewMSIObject);
							}
						}
						else
						{
							delete pNewObject;
							pNewObject = NULL;
						}
					}
				}
			}
			VariantClear(&variant);
		}
}

//-----------------------------------------------------------------------------
// Remove the specified IEnumWbemClassObject pointer from the cache.
//-----------------------------------------------------------------------------

void CWMILiveHelper::Version5RemoveEnumObject(const CString & strClass)
{
	CMSIEnumerator * pEnumObject = NULL;

	if (m_mapClassToEnumInterface.Lookup(strClass, (void * &) pEnumObject) && pEnumObject)
		delete pEnumObject;

	m_mapClassToEnumInterface.RemoveKey(strClass);
}

//-----------------------------------------------------------------------------
// Clear out the contents of the caches (forcing the interfaces to be
// retrieved again).
//-----------------------------------------------------------------------------

void CWMILiveHelper::Version5ClearCache()
{
	CMSIObject *			pObject = NULL;
	CMSIEnumerator *		pEnumObject = NULL;
	POSITION                pos;
	CString                 strClass;

	for (pos = m_mapClassToInterface.GetStartPosition(); pos != NULL;)
	{
		m_mapClassToInterface.GetNextAssoc(pos, strClass, (void * &) pObject);
		if (pObject)
			delete pObject;
	}
	m_mapClassToInterface.RemoveAll();

	for (pos = m_mapClassToEnumInterface.GetStartPosition(); pos != NULL;)
	{
		m_mapClassToEnumInterface.GetNextAssoc(pos, strClass, (void * &) pEnumObject);
		if (pEnumObject)
			delete pEnumObject;
	}
	m_mapClassToEnumInterface.RemoveAll();
}

//-----------------------------------------------------------------------------
// This function is used to retrieve a pointer to IWbemServices for a
// particular namespace. The default namespace is cimv2.
//-----------------------------------------------------------------------------

IWbemServices * CWMILiveHelper::Version5GetWBEMService(CString * pstrNamespace)
{
	if (pstrNamespace == NULL || pstrNamespace->IsEmpty())
		return m_pServices;

	// Something like the following is useful for forcing a provider error when
	// testing the error containment:
	//
	// if (*pstrNamespace == _T("MSAPPS")) *pstrNamespace += _T("X");

	IWbemServices * pServices;

	// In 5.0 we kept a map, but we probably won't do it here...
	//
	//	if (m_mapNamespaceToService.Lookup(*pstrNamespace, (void * &) pServices) && pServices)
	//		return pServices;

	// There is no WBEM services pointer for that namespace, we need to create one.

	CString strNamespace(_T(""));
	if (m_strMachine.IsEmpty())
		strNamespace = CString(_T("\\\\.\\root\\")) + *pstrNamespace;
	else
	{
		if (m_strMachine.Right(1) == CString(_T("\\")))
			strNamespace = m_strMachine + CString(_T("root\\")) + *pstrNamespace;
		else
			strNamespace = m_strMachine + CString(_T("\\root\\")) + *pstrNamespace;
		if (strNamespace.Left(2).Compare(CString(_T("\\\\"))) != 0)
			strNamespace = CString(_T("\\\\")) + strNamespace;
	}

	IWbemLocator * pIWbemLocator = NULL;
	if (CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pIWbemLocator) == S_OK)
	{
		BSTR	pNamespace = strNamespace.AllocSysString();
		
		HRESULT	hrServer = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL, &pServices);

		if (pNamespace)
			SysFreeString(pNamespace);

		if (pIWbemLocator)
		{
			pIWbemLocator->Release();
			pIWbemLocator = NULL;
		}

		if (SUCCEEDED(hrServer) && pServices)
		{
			ChangeWBEMSecurity(pServices);
			
			// In 5.0 we kept a map, but we probably won't do it here...
			//
			//	m_mapNamespaceToService.SetAt(*pstrNamespace, (void *) pServices);

			if (m_pIWbemServices)
				m_pIWbemServices->Release();
			
			m_pIWbemServices = pServices;
			m_pIWbemServices->AddRef();

			return pServices;
		}

		m_hrLastVersion5Error = hrServer;
	}

	return NULL;
}

//-----------------------------------------------------------------------------
// The CMSIEnumerator class encapsulates the WBEM enumerator interface, or
// implements our own form of enumerator (such as for the LNK command in the
// template file).
//
// Nothing particularly interesting about the constructor or destructor.
//-----------------------------------------------------------------------------

CMSIEnumerator::CMSIEnumerator()
{
	m_enumtype			= CMSIEnumerator::CLASS;
	m_fOnlyDups			= FALSE;
	m_fGotDuplicate		= FALSE;
	m_fMinOfOne			= FALSE;
	m_iMinOfOneCount	= 0;
	m_pEnum				= NULL;
	m_pWMI				= NULL;
	m_pConstraints		= NULL;
	m_pSavedDup			= NULL;
	m_pstrList			= NULL;
	m_hresCreation		= S_OK;
}

CMSIEnumerator::~CMSIEnumerator()
{
	if (m_pEnum)
	{
		switch (m_enumtype)
		{
		case CMSIEnumerator::WQL:
			break;

		case CMSIEnumerator::LNK:
			m_pWMI->m_enumMap.SetEnumerator(m_strAssocClass, m_pEnum);
			break;

		case CMSIEnumerator::INTERNAL:
			if (m_pstrList)
			{
				delete m_pstrList;
				m_pstrList = NULL;
			}
			break;
			
		case CMSIEnumerator::CLASS:
		default:
			m_pWMI->m_enumMap.SetEnumerator(m_strClass, m_pEnum);
			break;
		}
		
		m_pEnum->Release();
		m_pEnum = NULL;
	}
}

//-----------------------------------------------------------------------------
// Creating the CMSIEnumerator object involves determining what sort of
// enumerator is required. We support the following types:
//
//		1. Straight enumeration of a class
//		2. Enumerate class, with applied constraints
//		3. Enumerate the results of a WQL statement.
//		4. Interprete a LNK command to enumerate associated classes.
//		5. Do internal processing on an INTERNAL type.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::Create(const CString & strClass, const GATH_FIELD * pConstraints, CWMIHelper * pWMI)
{
	if (strClass.IsEmpty() || !pWMI)
		return E_INVALIDARG;

	// Create may be called multiple times (to reset the enumerator). So we may need to
	// release the enumerator pointer.

	if (m_pEnum)
	{
		m_pEnum->Release();
		m_pEnum = NULL;
	}

	// Divide the specified class into class and namespace parts, get the WBEM service.

	CString strNamespacePart(_T("")), strClassPart(strClass);
	int		i = strClass.Find(_T(":"));
	if (i != -1)
	{
		strNamespacePart = strClass.Left(i);
		strClassPart = strClass.Right(strClass.GetLength() - i - 1);
	}

	IWbemServices * pServices = pWMI->Version5GetWBEMService(&strNamespacePart);
	if (pServices == NULL)
		return NULL;

	// First, we need to determine what type of enumerator this is. Scan through
	// the constraints - if we see one which has a string starting with "WQL:" or
	// "LNK:", then we know what type this enumerator is.

	CString				strStatement;
	const GATH_FIELD *	pScanConstraint = pConstraints;

	while (pScanConstraint)
	{
		if (pScanConstraint->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0)
		{
			if (pScanConstraint->m_strFormat.Left(4).CompareNoCase(CString(_T("WQL:"))) == 0)
				m_enumtype = CMSIEnumerator::WQL;
			else if (pScanConstraint->m_strFormat.Left(4).CompareNoCase(CString(_T("LNK:"))) == 0)
				m_enumtype = CMSIEnumerator::LNK;
			else if (pScanConstraint->m_strFormat.Left(4).CompareNoCase(CString(_T("INT:"))) == 0)
				m_enumtype = CMSIEnumerator::INTERNAL;

			if (m_enumtype != CMSIEnumerator::CLASS)
			{
				strStatement = pScanConstraint->m_strFormat;
				strStatement = strStatement.Right(strStatement.GetLength() - 4);
				break;
			}
		}
		pScanConstraint = pScanConstraint->m_pNext;
	}

	// If this is a WQL or a LNK enumerator, processes the statement by replacing
	// [class.property] with the actual value from WBEM. If we find the string
	// "[min-of-one]", make a note of it for later.

	if (m_enumtype == CMSIEnumerator::WQL)
		ProcessEnumString(strStatement, m_fMinOfOne, m_fOnlyDups, pWMI, m_strNoInstanceLabel, TRUE);
	else if (m_enumtype == CMSIEnumerator::LNK)
		if (SUCCEEDED(ParseLNKCommand(strStatement, m_strObjPath, m_strAssocClass, m_strResultClass)))
		{
			// Save the object path for later - so we can change the object without
			// completely reprocessing the statement. Then replace the keywords in
			// the statement and break out the pieces again.

			m_strLNKObject = m_strObjPath;
			ProcessEnumString(strStatement, m_fMinOfOne, m_fOnlyDups, pWMI, m_strNoInstanceLabel);
			ParseLNKCommand(strStatement, m_strObjPath, m_strAssocClass, m_strResultClass);
		}

	// Now, based on the enumerator type, create the WBEM enumerator object.

	switch (m_enumtype)
	{
	case CMSIEnumerator::WQL:
		{
			BSTR language = SysAllocString(L"WQL");
			BSTR query = strStatement.AllocSysString();

			m_hresCreation = pServices->ExecQuery(language, query, WBEM_FLAG_RETURN_IMMEDIATELY, 0, &m_pEnum);

			SysFreeString(query);
			SysFreeString(language);
		}
		break;

	case CMSIEnumerator::LNK:
		{
			m_hresCreation = ParseLNKCommand(strStatement, m_strObjPath, m_strAssocClass, m_strResultClass);
			if (SUCCEEDED(m_hresCreation))
			{
				BSTR className = m_strAssocClass.AllocSysString();
				m_pEnum = pWMI->m_enumMap.GetEnumerator(m_strAssocClass);
				if (m_pEnum)
					m_hresCreation = S_OK;
				else
					m_hresCreation = pServices->CreateInstanceEnum(className, WBEM_FLAG_SHALLOW | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &m_pEnum);
				SysFreeString(className);
			}
		}
		break;

	case CMSIEnumerator::INTERNAL:
		// We'll call a function here so we can do whatever processing is required
		// to create this internal enumeration.

		m_hresCreation = CreateInternalEnum(strStatement, pWMI);
		break;

	case CMSIEnumerator::CLASS:
	default:
		{
			BSTR className = strClassPart.AllocSysString();
			m_pEnum = pWMI->m_enumMap.GetEnumerator(strClassPart);
			if (m_pEnum)
				m_hresCreation = S_OK;
			else
				m_hresCreation = pServices->CreateInstanceEnum(className, WBEM_FLAG_SHALLOW | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &m_pEnum);

			SysFreeString(className);
		}
	}

	// Set some of the other member variables.

	m_strClass			= strClass;
	m_pWMI				= pWMI;
	m_iMinOfOneCount	= (m_fMinOfOne) ? 1 : 0;
	m_pConstraints		= pConstraints;

	if (m_pEnum)
		ChangeWBEMSecurity(m_pEnum);

	// Based on the HRESULT from creating the enumeration, determine what to return.
	// For certain errors, we want to act like the creation succeeded, then supply
	// objects which return the error text.

	if (FAILED(m_hresCreation))
	{
		m_fMinOfOne = TRUE;
		m_iMinOfOneCount = 1;
	}

	pServices->Release();

	return S_OK;
}

//-----------------------------------------------------------------------------
// This function is used to create internal enumeration types (enumerations
// which are beyond the template file syntax). Basically a bunch of special
// cases.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::CreateInternalEnum(const CString & strInternal, CWMIHelper * pWMI)
{
	if (strInternal.CompareNoCase(CString(_T("dlls"))) == 0)
	{
		// We want to enumerate all the loaded dlls and exes on the system. 
		// This can be done by enumerating the CIM_ProcessExecutable class
		// and removing duplicate file names. We'll keep the filenames (with
		// path information) in a string list.

		if (m_pstrList == NULL)
		{
			m_pstrList = new CStringList;
			if (m_pstrList == NULL)
				return E_FAIL;
		}
		else
			m_pstrList->RemoveAll();

		HRESULT hr = S_OK;
		IWbemServices * pServices = pWMI->Version5GetWBEMService();
		if (pServices)
		{
			BSTR className = SysAllocString(L"CIM_ProcessExecutable");
			IEnumWbemClassObject * pEnum = NULL;
			hr = pServices->CreateInstanceEnum(className, WBEM_FLAG_SHALLOW | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnum);
			
			if (SUCCEEDED(hr))
			{
				IWbemClassObject *	pWBEMObject = NULL;
				ULONG				uReturned;
				VARIANT				variant;
				BSTR				propName = SysAllocString(L"Antecedent");

				VariantInit(&variant);

				do 
				{
					uReturned = 0;
					hr = pEnum->Next(TIMEOUT, 1, &pWBEMObject, &uReturned);
					if (SUCCEEDED(hr) && pWBEMObject && uReturned)
					{
						// For each instance of CIM_ProcessExecutable, get the 
						// Antecedent property (which contains the file path).
						// If it is unique, save it in the list.

						VariantClear(&variant);
						if (pWBEMObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
						{
							if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
							{
								CString strResult = V_BSTR(&variant);

								strResult.MakeLower();
								if (m_pstrList->Find(strResult) == NULL)
									m_pstrList->AddHead(strResult);
							}
						}
					}
				} while (SUCCEEDED(hr) && pWBEMObject && uReturned);

				::SysFreeString(propName);
				pEnum->Release();
			}

			::SysFreeString(className);
			pServices->Release();
		}

		return hr;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Help function for ProcessEnumString, used to convert single backslashes
// into double backslashes (required for WQL statements).
//-----------------------------------------------------------------------------

void MakeDoubleBackslashes(CString & strValue)
{
	CString strTemp(strValue);
	CString strResults;

	while (!strTemp.IsEmpty())
	{
		if (strTemp[0] != _T('\\'))
		{
			int index = strTemp.Find(_T('\\'));
			if (index < 0)
				index = strTemp.GetLength();
			strResults += strTemp.Left(index);
			strTemp = strTemp.Right(strTemp.GetLength() - index);
		}
		else
		{
			strResults += CString("\\\\");
			strTemp = strTemp.Mid(1);
		}
	}

	strValue = strResults;
}

//-----------------------------------------------------------------------------
// This function replaces [class.property] with the actual value of the
// property, and strings out [min-of-one], indicating if it was present in
// the fMinOfOne parameter.
//-----------------------------------------------------------------------------

void CMSIEnumerator::ProcessEnumString(CString & strStatement, BOOL & fMinOfOne, BOOL & fOnlyDups, CWMIHelper * pWMI, CString & strNoInstanceLabel, BOOL fMakeDoubleBackslashes)
{
	CString	strMinOfOne(_T("min-of-one"));
	CString strOnlyDups(_T("more-than-one"));
	CString strResults;

	fMinOfOne = FALSE;
	fOnlyDups = FALSE;

	while (!strStatement.IsEmpty())
	{
		if (strStatement[0] != _T('['))
		{
			int index = strStatement.Find(_T('['));
			if (index < 0)
				index = strStatement.GetLength();
			strResults += strStatement.Left(index);
			strStatement = strStatement.Right(strStatement.GetLength() - index);
		}
		else
		{
			CString strKeyword;

			strStatement = strStatement.Right(strStatement.GetLength() - 1);
			int index = strStatement.Find(_T(']'));
			if (index < 0)
				break;

			strKeyword = strStatement.Left(index);
			if (strKeyword.Left(strMinOfOne.GetLength()).CompareNoCase(strMinOfOne) == 0)
			{
				fMinOfOne = TRUE;
				
				int iEqualsIndex = strKeyword.Find(_T('='));
				if (iEqualsIndex > 0)
					strNoInstanceLabel = strKeyword.Right(strKeyword.GetLength() - iEqualsIndex - 1);
			}
			else if (strKeyword.Left(strOnlyDups.GetLength()).CompareNoCase(strOnlyDups) == 0)
			{
				fOnlyDups = TRUE;
				
				int iEqualsIndex = strKeyword.Find(_T('='));
				if (iEqualsIndex > 0)
					strNoInstanceLabel = strKeyword.Right(strKeyword.GetLength() - iEqualsIndex - 1);
			}
			else if (!strKeyword.IsEmpty())
			{
				int iDotIndex = strKeyword.Find(_T('.'));
				if (iDotIndex >= 0)
				{
					CString strValue;
					if (pWMI->Version5QueryValue(strKeyword.Left(iDotIndex), strKeyword.Right(strKeyword.GetLength() - iDotIndex - 1), strValue))
					{
						if (fMakeDoubleBackslashes)
							MakeDoubleBackslashes(strValue);
						strResults += strValue;
					}
				}
			}
			strStatement = strStatement.Right(strStatement.GetLength() - (index + 1));
		}
	}

	strStatement = strResults;
}

//-----------------------------------------------------------------------------
// Parse the component classes from the LNK command.
//-----------------------------------------------------------------------------
			
HRESULT CMSIEnumerator::ParseLNKCommand(const CString & strStatement, CString & strObjPath, CString & strAssocClass, CString & strResultClass)
{
	// We need to parse out the LNK statement into two or three components,
	// from the form "objPath->assocClass[->resultClass]", with the
	// brackets indicating that the resultClass is optional.

	CString strWorking(strStatement);

	int iArrowIndex = strWorking.Find(_T("->"));
	if (iArrowIndex == -1)
		return E_INVALIDARG;

	strObjPath = strWorking.Left(iArrowIndex);
	strWorking = strWorking.Right(strWorking.GetLength() - (iArrowIndex + 2));

	iArrowIndex = strWorking.Find(_T("->"));
	if (iArrowIndex == -1)
		strAssocClass = strWorking;
	else
	{
		strAssocClass = strWorking.Left(iArrowIndex);
		strWorking = strWorking.Right(strWorking.GetLength() - (iArrowIndex + 2));
		strResultClass = strWorking;
		strResultClass.MakeLower();
	}

	strAssocClass.TrimRight(); strAssocClass.TrimLeft();
	strObjPath.TrimRight(); strObjPath.TrimLeft();
	strResultClass.TrimRight(); strResultClass.TrimLeft();

	return S_OK;
}

//-----------------------------------------------------------------------------
// The Next method will advance the enumerator based on the type of this
// enumerator.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::Next(CMSIObject ** ppObject)
{
	if (!ppObject)
		return E_INVALIDARG;

	*ppObject = NULL;

	// If there was an error creating the enumeration, return the error code.

	if (FAILED(m_hresCreation))
		return m_hresCreation;

	if (m_pEnum == NULL && m_enumtype != CMSIEnumerator::INTERNAL)
		return E_UNEXPECTED;

	HRESULT				hRes = S_OK;
	IWbemClassObject *	pWBEMObject = NULL;

	switch (m_enumtype)
	{
	case CMSIEnumerator::LNK:
		{
			// Scan through the enumerated associate class. Look for one which
			// satisfies our requirements.

			CString				strTemp, strAssociatedObject(_T(""));
			ULONG				uReturned;
			IWbemClassObject *	pAssocObj;

			do
			{
				pAssocObj = NULL;
				uReturned = 0;
				hRes = m_pEnum->Next(TIMEOUT, 1, &pAssocObj, &uReturned);

				if (!pAssocObj || FAILED(hRes) || uReturned != 1)
				{
					// Even if we didn't succeed in getting a new object,
					// we might have a saved one if we're only showing
					// "more-than-one" objects.

					if (m_fOnlyDups && m_pSavedDup && m_fGotDuplicate)
					{
						// We have found one previously, so return it.
						// Make it look like the Next call was successful.

						m_pSavedDup = NULL;
						hRes = S_OK;
						uReturned = 1;
						strAssociatedObject = m_strSavedDup;
						break;
					}
					else
					{
						if (m_pSavedDup)
						{
							// We only got one object instance, so get rid of it.

							m_pSavedDup->Release();
							m_pSavedDup = NULL;
						}
						break;
					}
				}

				if (AssocObjectOK(pAssocObj, strTemp))
				{
					// This object passed the filter - but if we're showing
					// only "more-than-one" objects, save this one and return
					// the saved one.

					if (m_fOnlyDups)
					{
						if (m_pSavedDup)
						{
							// We have found one previously, so return it and
							// save the current.

							IWbemClassObject *	pSwap = pAssocObj;
							CString				strSwap = strTemp;

							pAssocObj = m_pSavedDup;
							m_pSavedDup = pSwap;

							strTemp = m_strSavedDup;
							m_strSavedDup = strSwap;

							m_fGotDuplicate = TRUE;
						}
						else
						{
							// This is the first one we've found - don't
							// return it until we find another.

							m_pSavedDup = pAssocObj;
							m_strSavedDup = strTemp;
							m_fGotDuplicate = FALSE;
							continue;
						}
					}

					strAssociatedObject = strTemp;
					pAssocObj->Release();
					break;
				}

				pAssocObj->Release();
			} while (pAssocObj);

			// If there is an associated object path, get the object.

			if (!strAssociatedObject.IsEmpty())
			{
				BSTR path = strAssociatedObject.AllocSysString();
				if (m_pWMI->m_pIWbemServices != NULL)
					hRes = m_pWMI->m_pIWbemServices->GetObject(path, 0, NULL, &pWBEMObject, NULL);
				else
					hRes = E_FAIL;
				SysFreeString(path);
			}
		}
		break;

	case CMSIEnumerator::WQL:
		{
			ULONG uReturned;

			hRes = m_pEnum->Next(TIMEOUT, 1, &pWBEMObject, &uReturned);
		}
		break;

	case CMSIEnumerator::INTERNAL:
		hRes = InternalNext(&pWBEMObject);
		break;

	case CMSIEnumerator::CLASS:
	default:
		{
			ULONG uReturned;

			// EvaluateFilter and IsDependencyJoin handle a NULL pConstraints parameter,
			// but for efficiency we're going to have a distinct branch for a non-NULL
			// value (since it will usually be NULL).

			if (m_pConstraints)
			{
				// Keep enumerating the instances of this class until we've
				// found one which satisfies all of the filters.

				do
				{
					pWBEMObject = NULL;
					hRes = m_pEnum->Next(TIMEOUT, 1, &pWBEMObject, &uReturned);

					if (!pWBEMObject || hRes != S_OK || uReturned != 1)
						break;
					else if (m_pWMI->Version5EvaluateFilter(pWBEMObject, m_pConstraints))
						break;

					pWBEMObject->Release();
				} while (pWBEMObject);

				// If this class is being enumerated as a dependency class, then
				// locate all the objects it references. If it isn't, we still
				// need to check for any joins to other classes formed by the constraints.

				if (pWBEMObject)
					if (m_pWMI->Version5IsDependencyJoin(m_pConstraints))
						m_pWMI->Version5EvaluateDependencyJoin(pWBEMObject);
					else
						m_pWMI->Version5EvaluateJoin(m_strClass, pWBEMObject, m_pConstraints);
			}
			else
				hRes = m_pEnum->Next(TIMEOUT, 1, &pWBEMObject, &uReturned);
		}
		break;
	}

	if (pWBEMObject == NULL)
	{
		// There was no object to get. We'll still create a CMSIObject, but
		// we'll set its state to indicate either that there are no instances,
		// or one instance with an error message.

		if (SUCCEEDED(hRes) && (m_iMinOfOneCount == 0))
			*ppObject = new CMSIObject(pWBEMObject, m_strNoInstanceLabel, hRes, m_pWMI, MOS_NO_INSTANCES);
		else
			*ppObject = new CMSIObject(pWBEMObject, m_strNoInstanceLabel, hRes, m_pWMI, MOS_MSG_INSTANCE);
	}
	else
		*ppObject = new CMSIObject(pWBEMObject, m_strNoInstanceLabel, hRes, m_pWMI, MOS_INSTANCE);

	if (m_iMinOfOneCount)
		m_iMinOfOneCount--;

	return S_OK;
}

//-----------------------------------------------------------------------------
// InternalNext is used to return a WBEM object for an internal enumeration
// (one that requires processing beyond the template file). Basically a 
// set of special cases.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::InternalNext(IWbemClassObject ** ppWBEMObject)
{
	if (m_pstrList && !m_pstrList->IsEmpty())
	{
		CString strNextObject = m_pstrList->RemoveHead();
		if (!strNextObject.IsEmpty())
		{
			IWbemServices * pServices = m_pWMI->Version5GetWBEMService();
			if (pServices)
			{
				BSTR objectpath = strNextObject.AllocSysString();
				HRESULT hr = S_OK;

 				if (FAILED(pServices->GetObject(objectpath, 0, NULL, ppWBEMObject, NULL)))
					hr = E_FAIL;
				::SysFreeString(objectpath);
				pServices->Release();
				return hr;
			}
		}
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Reset should just reset the enumerator pointer.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::Reset(const GATH_FIELD * pConstraints)
{
	HRESULT hRes = S_OK;

	if (m_pEnum)
	{
		switch (m_enumtype)
		{
		case CMSIEnumerator::WQL:
			hRes = Create(m_strClass, pConstraints, m_pWMI);
			break;

		case CMSIEnumerator::LNK:
			{
				BOOL	fDummy, fDummy2;
				CString	strDummy;

				m_strObjPath = m_strLNKObject;
				ProcessEnumString(m_strObjPath, fDummy, fDummy2, m_pWMI, strDummy);
				m_iMinOfOneCount = (m_fMinOfOne) ? 1 : 0;
				hRes = m_pEnum->Reset();
			}
			break;

		case CMSIEnumerator::INTERNAL:
			hRes = Create(m_strClass, pConstraints, m_pWMI);
			break;

		case CMSIEnumerator::CLASS:
		default:
			m_iMinOfOneCount = (m_fMinOfOne) ? 1 : 0;
			hRes = m_pEnum->Reset();
			break;
		}
	}
	else
		hRes = E_UNEXPECTED;
	
	return hRes;
}

//-----------------------------------------------------------------------------
// Evaluate if the pObject parameter is valid for this LNK enumerator. In
// particular, we must find the m_strObjPath in one of its properties, and
// possibly finding another property containing the m_strResultClass string.
//-----------------------------------------------------------------------------

BOOL CMSIEnumerator::AssocObjectOK(IWbemClassObject * pObject, CString & strAssociatedObject)
{
	strAssociatedObject.Empty();
	ASSERT(pObject);
	if (pObject == NULL)
		return FALSE;

	VARIANT variant;
	CString strReturn(_T("")), strValue;

	// Traverse the set of non-system properties. Look for one the is the same
	// as the object path.

	pObject->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY);
	VariantInit(&variant);
	while (pObject->Next(0, NULL, &variant, NULL, NULL) == WBEM_S_NO_ERROR)
	{
		if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
			strValue = V_BSTR(&variant);
		VariantClear(&variant);

		if (strValue.CompareNoCase(m_strObjPath) == 0)
			break;
	}
	pObject->EndEnumeration();

	// If we found a property containing the object path, look through for other
	// paths which might be to objects we're insterested in.

	if (strValue.CompareNoCase(m_strObjPath) == 0)
	{
		pObject->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY);
		while (strReturn.IsEmpty() && (pObject->Next(0, NULL, &variant, NULL, NULL) == WBEM_S_NO_ERROR))
		{
			if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				strValue = V_BSTR(&variant);

			if (strValue.CompareNoCase(m_strObjPath) != 0)
			{
				if (m_strResultClass.IsEmpty())
					strReturn = strValue;
				else
				{
					CString strSearch(strValue);
					strSearch.MakeLower();
					if (strSearch.Find(m_strResultClass) != -1)
						strReturn = strValue;
				}
			}

			VariantClear(&variant);
		}
		pObject->EndEnumeration();
	}

	if (!strReturn.IsEmpty())
	{
		strAssociatedObject = strReturn;
		return TRUE;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Implement the CMSIObject class. This is just a thin wrapper for the
// IWbemClassObject interface.
//-----------------------------------------------------------------------------

CMSIObject::CMSIObject(IWbemClassObject * pObject, const CString & strLabel, HRESULT hres, CWMIHelper * pWMI, MSIObjectState objState)
{
	m_pObject		= pObject;
	m_strLabel		= strLabel;
	m_hresCreation	= hres;
	m_pWMI			= pWMI;
	m_objState		= objState;
}

CMSIObject::~CMSIObject()
{
	if (m_pObject)
	{
		m_pObject->Release();
		m_pObject = NULL;
	}
}

HRESULT CMSIObject::Get(BSTR property, LONG lFlags, VARIANT *pVal, VARTYPE *pvtType, LONG *plFlavor)
{
	ASSERT(m_objState != MOS_NO_INSTANCES);

	// If there is an object interface, just pass the request on through.

	if (m_pObject)
		return m_pObject->Get(property, lFlags, pVal, NULL /* pvtType */, plFlavor);

	// Otherwise, we need to return the appropriate string.
	
	CString strReturn;
	GetErrorLabel(strReturn);

	V_BSTR(pVal) = strReturn.AllocSysString();
	pVal->vt = VT_BSTR;
	return S_OK;
}

MSIObjectState CMSIObject::IsValid()
{
	return m_objState;
}

HRESULT CMSIObject::GetErrorLabel(CString & strError)
{
	switch (m_hresCreation)
	{
	case WBEM_E_ACCESS_DENIED:
		strError = m_pWMI->m_strBadProperty;	// shouldn't be showing errors this way in 6.0
		break;

	case WBEM_E_TRANSPORT_FAILURE:
		strError = m_pWMI->m_strBadProperty;
		break;

	case S_OK:
	case WBEM_S_FALSE:
	default:
		// This object was created from an enumeration that was marked as "min-of-one",
		// meaning that at least one object, even if it's not valid, needed to be
		// returned from the enumeration. Return the string we saved at object creation.

		if (!m_strLabel.IsEmpty())
			strError = m_strLabel;
		else
			strError = m_pWMI->m_strBadProperty;
		break;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Look up strVal in the ValueMap (if it exists) for strClass.strProperty
// If the value or the ValueMap is not found, return E_Something.
//
// Useful code snippet - this will dump the contents of the cache of
// saved values. To find all value mapped properties, but this code
// someplace where it will execute when MSInfo exits, change QueryValue
// to call CheckValueMap for all properties, then run MSInfo and do a global
// refresh (like to save an NFO).
//
//	msiLog.WriteLog(CMSInfoLog::BASIC, _T("BEGIN Dump of ValueMap Cache\r\n"));
//	CString key, val, log;
//	for (POSITION pos = g_mapValueMap.GetStartPosition(); pos != NULL;)
//	{
//		g_mapValueMap.GetNextAssoc(pos, key, val);
//		log.Format(_T(" %s = %s\r\n", key, val);
//		msiLog.WriteLog(CMSInfoLog::BASIC, log);
//	}
//	msiLog.WriteLog(CMSInfoLog::BASIC, _T("END Dump of ValueMap Cache\r\n"));
//-----------------------------------------------------------------------------

CMapStringToString g_mapValueMap;

HRESULT CWMILiveHelper::Version5CheckValueMap(const CString& strClass, const CString& strProperty, const CString& strVal, CString &strResult)
{
	IWbemClassObject *	pWBEMClassObject = NULL;
    HRESULT				hrMap = S_OK, hr = S_OK;
    VARIANT				vArray, vMapArray;
	IWbemQualifierSet *	qual = NULL;

	// Check the cache of saved values.

	CString strLookup = strClass + CString(_T(".")) + strProperty + CString(_T(":")) + strVal;
	if (g_mapValueMap.Lookup(strLookup, strResult))
		return S_OK;

	// Get the class object (not instance) for this class.

	IWbemServices * pServices = Version5GetWBEMService();
	if (!pServices)
		return E_FAIL;

	CString strFullClass(_T("\\\\.\\root\\cimv2:"));
	strFullClass += strClass;
	BSTR bstrObjectPath = strFullClass.AllocSysString();
	hr = pServices->GetObject(bstrObjectPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pWBEMClassObject, NULL);
	::SysFreeString(bstrObjectPath);
	pServices->Release();

	if (FAILED(hr))
		return hr;

	// Get the qualifiers from the class object.

	BSTR bstrProperty = strProperty.AllocSysString();
    hr = pWBEMClassObject->GetPropertyQualifierSet(bstrProperty, &qual);
	::SysFreeString(bstrProperty);

	if (SUCCEEDED(hr) && qual)
	{
		// Get the ValueMap and Value arrays.

		hrMap = qual->Get(L"ValueMap", 0, &vMapArray, NULL);
		hr = qual->Get(L"Values", 0, &vArray, NULL);

		if (SUCCEEDED(hr) && vArray.vt == (VT_BSTR | VT_ARRAY))
		{
			// Get the property value we're mapping.

			long index;
			if (SUCCEEDED(hrMap))
			{
				SAFEARRAY * pma = V_ARRAY(&vMapArray);
				long lLowerBound = 0, lUpperBound = 0 ;

				SafeArrayGetLBound(pma, 1, &lLowerBound);
				SafeArrayGetUBound(pma, 1, &lUpperBound);
				BSTR vMap;

				for (long x = lLowerBound; x <= lUpperBound; x++)
				{
					
					SafeArrayGetElement(pma, &x, &vMap);
					
					if (0 == strVal.CompareNoCase((LPCTSTR)vMap))
					{
						index = x;
						break; // found it
					}
				} 
			}
			else
			{
				// Shouldn't hit this case - if mof is well formed
				// means there is no value map where we are expecting one.
				// If the strVal we are looking for is a number, treat it
				// as an index for the Values array. If it's a string, 
				// then this is an error.

				TCHAR * szTest = NULL;
				index = _tcstol((LPCTSTR)strVal, &szTest, 10);

				if (szTest == NULL || (index == 0 && *szTest != 0) || strVal.IsEmpty())
					hr = E_FAIL;
			}

			// Lookup the string.

			if (SUCCEEDED(hr))
			{
				SAFEARRAY * psa = V_ARRAY(&vArray);
				long ix[1] = {index};
				BSTR str2;

				hr = SafeArrayGetElement(psa, ix, &str2);
				if (SUCCEEDED(hr))
				{
					strResult = str2;
					SysFreeString(str2);
					hr = S_OK;
				}
				else
				{
					hr = WBEM_E_VALUE_OUT_OF_RANGE;
				}
			}
		}

		qual->Release();
	}

	if (SUCCEEDED(hr))
		g_mapValueMap.SetAt(strLookup, strResult);

	return hr;
}

//-----------------------------------------------------------------------------
// The CEnumMap is a utility class to cache IEnumWbemClassObject pointers.
// There will be one instance of this class used to improve performance
// by avoiding the high overhead associated with creating enumerators for
// certain classes.
//-----------------------------------------------------------------------------

IEnumWbemClassObject * CEnumMap::GetEnumerator(const CString & strClass)
{
	IEnumWbemClassObject * pEnum = NULL;
	IEnumWbemClassObject * pNewEnum = NULL;

	if (m_mapEnum.Lookup(strClass, (void * &) pEnum))
	{
		if (pEnum && SUCCEEDED(pEnum->Clone(&pNewEnum)) && pNewEnum)
			pNewEnum->Reset();
		else
			pNewEnum = NULL;
	}

	return pNewEnum;
}

void CEnumMap::SetEnumerator(const CString & strClass, IEnumWbemClassObject * pEnum)
{
	if (pEnum)
	{
		IEnumWbemClassObject * pEnumExisting = NULL;
		if (m_mapEnum.Lookup(strClass, (void * &) pEnumExisting))
		{
			; //WRITE(_T("SetEnumerator for %s, already exists, ignoring.\r\n"), strClass);
		}
		else
		{
			pEnum->AddRef();
			m_mapEnum.SetAt(strClass, pEnum);
		}
	}
}

void CEnumMap::Reset()
{
	IEnumWbemClassObject *	pEnum = NULL;
	CString					key;

	for (POSITION pos = m_mapEnum.GetStartPosition(); pos != NULL;)
	{
	   m_mapEnum.GetNextAssoc(pos, key, (void * &) pEnum);
	   if (pEnum)
		   pEnum->Release();
	}

	m_mapEnum.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\whqlobj.cpp ===
///////////////////////////////////////////////////////////////////////////////
//This file has the implementation for the WMI Provider for WHQL.
//Uses MFC
///////////////////////////////////////////////////////////////////////////////

// WhqlObj.cpp : Implementation of CWhqlObj
#include "stdafx.h"
#include "msinfo32.h"
#include "WhqlObj.h"
#include "chkdrv.h"

HCATADMIN g_hCatAdmin;

Classes_Provided	eClasses;

/////////////////////////////////////////////////////////////////////////////
// CWhqlObj
//v-stlowe 5-7-2001
SCODE CWhqlObj::PutPropertyDTMFValue(IWbemClassObject* pInstance, LPCTSTR szName, LPCTSTR szValue)
{
	HRESULT	hr = S_FALSE;
	if (pInstance)
	{
		CComVariant ovValue(szValue);
		hr = ovValue.ChangeType(VT_DATE);
		COleDateTime dateTime = ovValue;
		CString strDateTime = dateTime.Format(_T("%Y%m%d%H%M%S.******+***"));
		ovValue.Clear();//v-stlowe 10-15/2001
		ovValue = strDateTime.AllocSysString();
		if(SUCCEEDED(hr))
		{
			hr = pInstance->Put(szName, 0, &ovValue, 0);
		}
		ovValue.Clear();//v-stlowe 10-15/2001
	}
	return hr;
}



SCODE CWhqlObj::PutPropertyValue(IWbemClassObject* pInstance, LPCTSTR szName, LPCTSTR szValue)
{
	HRESULT	hr = S_FALSE;
	
	if(pInstance)
	{
		hr = pInstance->Put(CComBSTR(szName), 0, &CComVariant(szValue), 0);
	}
	
	return hr;
}

int WalkTreeHelper(DEVNODE hDevnode, DEVNODE hParent)
{
	CheckDevice *pCurrentDevice;
	DEVNODE hSibling;
	DEVNODE hChild;
	CONFIGRET retval;
 
	pCurrentDevice = new CheckDevice(hDevnode, hParent);
	
	if(pCurrentDevice)
	{
		retval = pCurrentDevice->GetChild(&hChild);
		if(!retval)
		{
			WalkTreeHelper(hChild, hDevnode);
		}

		retval = pCurrentDevice->GetSibling(&hSibling);
		if(!retval)
		{
			WalkTreeHelper(hSibling, hParent);
		}
	}

	return TRUE;
}

int CWhqlObj::WalkTree(void)
{
	CONFIGRET retval;
	DEVNODE hDevnode;
	//v-stlowe
	CheckDevice * pCurrentDevice = (CheckDevice *) DevnodeClass::GetHead();
	if (pCurrentDevice)
	{
		return TRUE;
	}

	//end v-stlowe
	// create devnode list
	retval = CM_Locate_DevNode(&hDevnode, NULL, CM_LOCATE_DEVNODE_NORMAL);
	if(retval)
	{
		//logprintf("ERROR: Could not locate any PnP Devices\r\n");
		return FALSE;
	}
  else
		WalkTreeHelper(hDevnode, NULL);

   return(TRUE);
}


STDMETHODIMP CWhqlObj::Initialize(LPWSTR pszUser, 
																	LONG lFlags,
																	LPWSTR pszNamespace,
																	LPWSTR pszLocale,
																	IWbemServices *pNamespace,
																	IWbemContext *pCtx,
																	IWbemProviderInitSink *pInitSink)
{
	if(pNamespace)
		pNamespace->AddRef();

	//Standard Var Inits.
	m_pNamespace = pNamespace;
	
	//Let CIMOM know you are initialized
	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	
	return WBEM_S_NO_ERROR;
}

SCODE CWhqlObj::CreateInstanceEnumAsync(BSTR RefStr, 
																				long lFlags, 
																				IWbemContext *pCtx,
																				IWbemObjectSink *pHandler)
{
	HRESULT hr = S_OK;
	IWbemClassObject *pClass = NULL;
	IWbemClassObject **ppInstances = NULL;
	LONG cInstances, lIndex;
	
	cInstances = lIndex = 0L;
	
	// Do a check of arguments and make sure we have pointer to Namespace
	if(pHandler == NULL || m_pNamespace == NULL)
		return WBEM_E_INVALID_PARAMETER;

	// Get a class object from CIMOM
	hr = m_pNamespace->GetObject(RefStr, 0, pCtx, &pClass, NULL);
	if(FAILED(hr))
		return WBEM_E_FAILED;

	CString csRefStr = RefStr;

	if(_tcsicmp(csRefStr , _T("Win32_PnPSignedDriver")) == 0)
	{
		eClasses = Class_Win32_PnPSignedDriver;
	}
	else if(_tcsicmp(csRefStr , _T("Win32_PnPSignedDriverCIMDataFile")) == 0)
	{
		eClasses = Class_Win32_PnPSignedDriverCIMDataFile;
	}
		
	CPtrArray ptrArr;
	ptrArr.RemoveAll();
	
	CreateList(ptrArr, pClass, pCtx, eClasses); //regular devices
	BuildPrinterFileList(ptrArr, pClass, pCtx, eClasses); //installed printers
	
	hr = pClass->Release();

	cInstances	= (LONG)ptrArr.GetSize();
	ppInstances = (IWbemClassObject**)new LPVOID[cInstances];

	for(int nIndex = 0 ;nIndex<cInstances ;nIndex++)
		ppInstances[nIndex] = (IWbemClassObject*)ptrArr[nIndex];

	if (SUCCEEDED(hr))
	{
		// Send the instances to the caller
		hr = pHandler->Indicate(cInstances, ppInstances);

		for (lIndex = 0; lIndex < cInstances; lIndex++)
			ppInstances[lIndex]->Release();
	}

	// Cleanup
	if (ppInstances)
	{
		delete []ppInstances;
		ppInstances = NULL;		
	}
	
	ptrArr.RemoveAll();
	// End Cleanup

	// Set status
	hr = pHandler->SetStatus(0, hr, NULL, NULL);
	return hr;
}

typedef BOOL (WINAPI *pSetupVerifyInfFile)(
    IN  PCWSTR                  InfName,
    IN  PSP_ALTPLATFORM_INFO    AltPlatformInfo,                OPTIONAL
    OUT PSP_INF_SIGNER_INFO_W   InfSignerInfo
    );


int CWhqlObj::CreateList(CPtrArray& ptrArr, IWbemClassObject *& pClass, IWbemContext *pCtx ,Classes_Provided eClasses)
{
	if(pCtx == NULL)
		return S_FALSE;

	TCHAR szName[MAX_PATH] ;
	TCHAR szDeviceID[MAX_PATH] , szClassGuid[MAX_PATH] , szDeviceDesc[MAX_PATH];	
	LONG len = sizeof(szName);
	HRESULT hr = S_FALSE;
	ULONG lRet = 0L;
	LONG lIndex = 0L;
	CString	cstring;	
	IWbemClassObject *pInstance	= NULL;		
	CheckDevice	*pCurrentDevice = NULL;		
	CheckDevice *pToBeDeletedDevice = NULL;		
	FileNode *file;		
	CComBSTR bstr;
	BOOL bAddedInstance = FALSE;
	TCHAR szTemp[ MAX_PATH + 1 ];
	SP_INF_SIGNER_INFO infSignerInfo;

	HINSTANCE hinst = NULL;
	pSetupVerifyInfFile fpSetupVerifyInfFile = NULL;
		
	hinst = LoadLibrary(_T("SetupApi.dll"));
	#ifdef _UNICODE					
		fpSetupVerifyInfFile = (pSetupVerifyInfFile)GetProcAddress(hinst, "SetupVerifyInfFileW");
	#else
		fpSetupVerifyInfFile = (pSetupVerifyInfFile)GetProcAddress(hinst, "SetupVerifyInfFileA");
	#endif

	ZeroMemory(&infSignerInfo , sizeof(SP_INF_SIGNER_INFO));
	infSignerInfo.cbSize = sizeof(SP_INF_SIGNER_INFO);		

	WalkTree();

	CString csPathStr;
	GetServerAndNamespace(pCtx, csPathStr); //Get Server And Namespace.

	pCurrentDevice = (CheckDevice *) DevnodeClass::GetHead();

	while(pCurrentDevice)
	{
		if(eClasses == Class_Win32_PnPSignedDriver && !bAddedInstance)
		{
			bAddedInstance = TRUE;
			if(pClass)
				hr = pClass->SpawnInstance(0, &pInstance);

			if(SUCCEEDED(hr) && pInstance)
			{
				//m_ptrArr.Add(pInstance);
				ptrArr.Add(pInstance);
				PutPropertyValue( pInstance , _T("DeviceName") , pCurrentDevice->DeviceName());
				PutPropertyValue( pInstance , _T("DeviceClass") , pCurrentDevice->DeviceClass());
				PutPropertyValue( pInstance , _T("HardwareID") , pCurrentDevice->HardwareID());
				PutPropertyValue( pInstance , _T("CompatID") , pCurrentDevice->CompatID());
				PutPropertyValue( pInstance , _T("DeviceID") , pCurrentDevice->DeviceID());
				PutPropertyValue( pInstance , _T("ClassGuid") , pCurrentDevice->GUID());
				PutPropertyValue( pInstance , _T("Location") , pCurrentDevice->Location());
				PutPropertyValue( pInstance , _T("PDO") , pCurrentDevice->PDO());
				PutPropertyValue( pInstance , _T("Manufacturer") , pCurrentDevice->MFG());
				PutPropertyValue( pInstance , _T("FriendlyName") , pCurrentDevice->FriendlyName());
				PutPropertyValue( pInstance , _T("InfName") , pCurrentDevice->InfName());
				PutPropertyValue( pInstance , _T("DriverProviderName") , pCurrentDevice->InfProvider());
				PutPropertyValue( pInstance , _T("DevLoader") , pCurrentDevice->DevLoader());
				PutPropertyValue( pInstance , _T("DriverName") , pCurrentDevice->DriverName());

				PutPropertyDTMFValue( pInstance , _T("DriverDate") , pCurrentDevice->DriverDate());
				PutPropertyValue( pInstance , _T("Description") , pCurrentDevice->DriverDesc());
				PutPropertyValue( pInstance , _T("DriverVersion") , pCurrentDevice->DriverVersion());
				PutPropertyValue( pInstance , _T("InfSection") , pCurrentDevice->InfSection());

				if(pCurrentDevice->InfName())
				{
					//cstring.Format(_T("%%WINDIR%%\\inf\\%s"), pCurrentDevice->InfName());
					//ExpandEnvironmentStrings(cstring , szTemp , sizeof(szTemp) + 1 );

					TCHAR *pInfpath = NULL;
					DWORD dw = ExpandEnvironmentStrings(_T("%windir%"), NULL, 0);
					if(dw > 0)
					{
						pInfpath = new TCHAR[dw];
						if(pInfpath)
						{
							dw = ExpandEnvironmentStrings(_T("%windir%"), pInfpath, dw);
							CString szTemp(pInfpath);
							szTemp += _T("\\inf\\");
							szTemp += pCurrentDevice->InfName();
							
							BOOL bRet = FALSE;

							//Do only if SetupApi.dll loaded & we have got fpSetupVerifyInfFile 
							if(fpSetupVerifyInfFile != NULL)
							{
								bRet = (*fpSetupVerifyInfFile)(
								/*IN  PCSTR*/ szTemp,
								/*IN  PSP_ALTPLATFORM_INFO*/NULL,
								/*OUT PSP_INF_SIGNER_INFO_A*/   &infSignerInfo
								);					  

								hr = pInstance->Put(L"IsSigned", 0, &CComVariant(bRet), 0 );
								if(bRet)
									PutPropertyValue( pInstance , _T("Signer") , infSignerInfo.DigitalSigner);
							}

							delete[] pInfpath;
							pInfpath = NULL;

						}//if(pInfpath)
					}//if(dw > 0)
				}//if(pCurrentDevice->InfName())
			}
		}

		if(eClasses == Class_Win32_PnPSignedDriverCIMDataFile)
		{
			CString szAntecedent(pCurrentDevice->DeviceID()); //Antecedent
			if(!szAntecedent.IsEmpty())
			{
				szAntecedent.Replace(_T("\\"), _T("\\\\"));

				file = pCurrentDevice->GetFileList();
				while(file)
				{
					CString szDependent(file->FilePath()); //Dependent
					if(!szDependent.IsEmpty())
					{
						szDependent.Replace(_T("\\"), _T("\\\\"));

						if(pClass)
							hr = pClass->SpawnInstance(0, &pInstance);

						if(SUCCEEDED(hr) && pInstance)
						{
							if(!csPathStr.IsEmpty())
							{
								CString szData(csPathStr);
								szData += _T(":Win32_PnPSignedDriver.DeviceID=\"");
								szData += szAntecedent;
								szData += _T("\"");
								hr = pInstance->Put(_T("Antecedent"), 0, &CComVariant(szData), 0);

								szData.Empty();

								szData = csPathStr;
								szData += _T(":CIM_DataFile.Name=\"");
								szData += szDependent;
								szData += _T("\"");
								hr = pInstance->Put(_T("Dependent"), 0, &CComVariant(szData), 0);
	
								ptrArr.Add(pInstance);
							}
						}
					}

					file = file->pNext;
				}
			}
		}

		pToBeDeletedDevice = pCurrentDevice;//10/19/2001
		pCurrentDevice = (CheckDevice *)pCurrentDevice->GetNext();
		if(pToBeDeletedDevice)//10/19/2001
			delete pToBeDeletedDevice  ;//delete pToBeDeletedDevice  which will release it from CheckDevice Linked List.//10/19/2001

		bAddedInstance = FALSE;
	}

	if(hinst)
		FreeLibrary(hinst);
	return hr;
}

SCODE CWhqlObj::GetServerAndNamespace(IWbemContext* pCtx, CString& csPathStr)
{
	HRESULT		hr			= S_FALSE;
	ULONG		lRet		= 0L;
	
	CComBSTR language	= _T("WQL");
	CComBSTR query		= _T("select __NameSpace , __Server from Win32_PnpEntity");

	CComPtr<IEnumWbemClassObject> pEnum;
	CComPtr<IWbemClassObject> pObject;

	hr = m_pNamespace->ExecQuery(language , query ,
		WBEM_FLAG_RETURN_IMMEDIATELY|WBEM_FLAG_FORWARD_ONLY, pCtx , &pEnum);

	language.Empty();
	query.Empty();

	if(pEnum == NULL)
		return S_FALSE;

	CComVariant		v;
	
	//Get Server And Namespace from the Enum.
	if( WBEM_S_NO_ERROR == pEnum->Next(WBEM_INFINITE , 1 , &pObject , &lRet ) )  
	{
		//Fill csPathStr.Its value will be used in Antecedent & Dependent in assoc. class.
		//At the end of the condition we should have something like
		//csPathStr = "\\\\A-KJAW-RI1\\root\\CIMV2"
		if(csPathStr.IsEmpty())
		{
			hr = pObject->Get(L"__Server", 0, &v, NULL , NULL);
			if( SUCCEEDED(hr) )
			{
				csPathStr += _T("\\\\");
				csPathStr += V_BSTR(&v);
				hr = pObject->Get(L"__NameSpace", 0, &v, NULL , NULL);
				if( SUCCEEDED(hr) )
				{
					csPathStr += _T("\\");
					csPathStr += V_BSTR(&v);
				}
				ATLTRACE(_T("Server & Namespace Path = %s\n") , csPathStr);
				VariantClear(&v);
			}
		}
	}

	return hr;
}

/*************************************************************************
*   Function : VerifyIsFileSigned
*   Purpose : Calls WinVerifyTrust with Policy Provider GUID to
*   verify if an individual file is signed.
**************************************************************************/
BOOL VerifyIsFileSigned(LPTSTR pcszMatchFile, PDRIVER_VER_INFO lpVerInfo)
{
    INT                 iRet;
    HRESULT             hRes;
    WINTRUST_DATA       WinTrustData;
    WINTRUST_FILE_INFO  WinTrustFile;
    GUID                gOSVerCheck = DRIVER_ACTION_VERIFY;
    GUID                gPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;
#ifndef UNICODE
    WCHAR               wszFileName[MAX_PATH];
#endif

    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pFile = &WinTrustFile;
    WinTrustData.pPolicyCallbackData = (LPVOID)lpVerInfo;

    ZeroMemory(lpVerInfo, sizeof(DRIVER_VER_INFO));
    lpVerInfo->cbStruct = sizeof(DRIVER_VER_INFO);

    ZeroMemory(&WinTrustFile, sizeof(WINTRUST_FILE_INFO));
    WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);

#ifndef UNICODE
    iRet = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcszMatchFile, -1, (LPWSTR)&wszFileName, cA(wszFileName));
    WinTrustFile.pcwszFilePath = wszFileName;
#else
    WinTrustFile.pcwszFilePath = pcszMatchFile;
#endif

    hRes = WinVerifyTrust((HWND) INVALID_HANDLE_VALUE, &gOSVerCheck, &WinTrustData);
    if (hRes != ERROR_SUCCESS) {
    
        hRes = WinVerifyTrust((HWND) INVALID_HANDLE_VALUE, &gPublishedSoftware, &WinTrustData);
    }

    //
    // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
    // that was allocated in our call to WinVerifyTrust.
    //
    if (lpVerInfo && lpVerInfo->pcSignerCertContext) {

        CertFreeCertificateContext(lpVerInfo->pcSignerCertContext);
        lpVerInfo->pcSignerCertContext = NULL;
    }

    return(hRes == ERROR_SUCCESS);
}

//
// Given a specific LPFILENODE, verify that the file is signed or unsigned.
// Fill in all the necessary structures so the listview control can display properly.
//
BOOL VerifyFileNode(LPFILENODE lpFileNode)
{
    HANDLE                  hFile;
    BOOL                    bRet;
    HCATINFO                hCatInfo = NULL;
    HCATINFO                PrevCat = NULL;
    WINTRUST_DATA           WinTrustData;
    WINTRUST_CATALOG_INFO   WinTrustCatalogInfo;
    DRIVER_VER_INFO         VerInfo;
    GUID                    gSubSystemDriver = DRIVER_ACTION_VERIFY;
    HRESULT                 hRes;
    DWORD                   cbHash = HASH_SIZE;
    BYTE                    szHash[HASH_SIZE];
    LPBYTE                  lpHash = szHash;
    CATALOG_INFO            CatInfo;
    LPTSTR                  lpFilePart;
    TCHAR                   szBuffer[MAX_PATH];
    static TCHAR            szCurrentDirectory[MAX_PATH];
    OSVERSIONINFO           OsVersionInfo;
    BOOL bTmp = FALSE;
#ifndef UNICODE
    WCHAR UnicodeKey[MAX_PATH];
#endif
        
    if (!SetCurrentDirectory(lpFileNode->lpDirName)) {
    
        return FALSE;
    }
    
    //
    // Get the handle to the file, so we can call CryptCATAdminCalcHashFromFileHandle
    //
    hFile = CreateFile( lpFileNode->lpFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        
        lpFileNode->LastError = GetLastError();

        return FALSE;
    }

    // Initialize the hash buffer
    ZeroMemory(lpHash, HASH_SIZE);

    // Generate the hash from the file handle and store it in lpHash
    if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, lpHash, 0)) {
        
        //
        // If we couldn't generate a hash, it might be an individually signed catalog.
        // If it's a catalog, zero out lpHash and cbHash so we know there's no hash to check.
        //
        if (IsCatalogFile(hFile, NULL)) {
            
            lpHash = NULL;
            cbHash = 0;
        
        } else {  // If it wasn't a catalog, we'll bail and this file will show up as unscanned.
            
            CloseHandle(hFile);
            return FALSE;
        }
    }

    // Close the file handle
    CloseHandle(hFile);

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //
    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;

    ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
    VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

    //
    // Only validate against the current OS Version, unless the bValidateAgainstAnyOs
    // parameter was TRUE.  In that case we will just leave the sOSVersionXxx fields
    // 0 which tells WinVerifyTrust to validate against any OS.
    //
    if (!lpFileNode->bValidateAgainstAnyOs) {
        OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
        if (GetVersionEx(&OsVersionInfo)) {
            VerInfo.sOSVersionLow.dwMajor = OsVersionInfo.dwMajorVersion;
            VerInfo.sOSVersionLow.dwMinor = OsVersionInfo.dwMinorVersion;
            VerInfo.sOSVersionHigh.dwMajor = OsVersionInfo.dwMajorVersion;
            VerInfo.sOSVersionHigh.dwMinor = OsVersionInfo.dwMinorVersion;
        }
    }


    WinTrustData.pCatalog = &WinTrustCatalogInfo;

    ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
    WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
    WinTrustCatalogInfo.pbCalculatedFileHash = lpHash;
    WinTrustCatalogInfo.cbCalculatedFileHash = cbHash;
#ifdef UNICODE
    WinTrustCatalogInfo.pcwszMemberTag = lpFileNode->lpFileName;
#else
    MultiByteToWideChar(CP_ACP, 0, lpFileNode->lpFileName, -1, UnicodeKey, cA(UnicodeKey));
    WinTrustCatalogInfo.pcwszMemberTag = UnicodeKey;
#endif

    //
    // Now we try to find the file hash in the catalog list, via CryptCATAdminEnumCatalogFromHash
    //
    //PrevCat = NULL;
    hCatInfo = CryptCATAdminEnumCatalogFromHash(g_hCatAdmin, lpHash, cbHash, 0, &PrevCat);

    //
    // We want to cycle through the matching catalogs until we find one that matches both hash and member tag
    //
    bRet = FALSE;
    while (hCatInfo && !bRet) {
        
        ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
        CatInfo.cbStruct = sizeof(CATALOG_INFO);
        
        if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) {
            
            WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            // Now verify that the file is an actual member of the catalog.
    				hRes = WinVerifyTrust((HWND) INVALID_HANDLE_VALUE, &gSubSystemDriver, &WinTrustData);
            
            if (hRes == ERROR_SUCCESS) {
#ifdef UNICODE
                GetFullPathName(CatInfo.wszCatalogFile, MAX_PATH, szBuffer, &lpFilePart);
#else
                WideCharToMultiByte(CP_ACP, 0, CatInfo.wszCatalogFile, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                GetFullPathName(szBuffer, MAX_PATH, szBuffer, &lpFilePart);
#endif
                lpFileNode->lpCatalog = (LPTSTR) MALLOC((lstrlen(lpFilePart) + 1) * sizeof(TCHAR));

                if (lpFileNode->lpCatalog) {

                    lstrcpy(lpFileNode->lpCatalog, lpFilePart);
                }

                bRet = TRUE;
            }

            //
            // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
            // that was allocated in our call to WinVerifyTrust.
            //
            if (VerInfo.pcSignerCertContext != NULL) {

                CertFreeCertificateContext(VerInfo.pcSignerCertContext);
                VerInfo.pcSignerCertContext = NULL;
            }
        }

        if (!bRet) {
            
            // The hash was in this catalog, but the file wasn't a member... so off to the next catalog
            PrevCat = hCatInfo;
            hCatInfo = CryptCATAdminEnumCatalogFromHash(g_hCatAdmin, lpHash, cbHash, 0, &PrevCat);
        }
    }

    // Mark this file as having been scanned.
    lpFileNode->bScanned = TRUE;

    if (!hCatInfo) {
        
        //
        // If it wasn't found in the catalogs, check if the file is individually signed.
        //
        bRet = VerifyIsFileSigned(lpFileNode->lpFileName, (PDRIVER_VER_INFO)&VerInfo);
        
        if (bRet) {
            
            // If so, mark the file as being signed.
            lpFileNode->bSigned = TRUE;
        }
    
    } else {
        
        // The file was verified in the catalogs, so mark it as signed and free the catalog context.
        lpFileNode->bSigned = TRUE;
        CryptCATAdminReleaseCatalogContext(g_hCatAdmin, hCatInfo, 0);
    }

    if (lpFileNode->bSigned) {

#ifdef UNICODE
        lpFileNode->lpVersion = (LPTSTR) MALLOC((lstrlen(VerInfo.wszVersion) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpVersion) {
            
            lstrcpy(lpFileNode->lpVersion, VerInfo.wszVersion);
        }

        lpFileNode->lpSignedBy = (LPTSTR) MALLOC((lstrlen(VerInfo.wszSignedBy) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpSignedBy) {
            
            lstrcpy(lpFileNode->lpSignedBy, VerInfo.wszSignedBy);
        }
#else
        WideCharToMultiByte(CP_ACP, 0, VerInfo.wszVersion, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        lpFileNode->lpVersion = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpVersion) {
            
            lstrcpy(lpFileNode->lpVersion, szBuffer);
        }

        WideCharToMultiByte(CP_ACP, 0, VerInfo.wszSignedBy, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        lpFileNode->lpSignedBy = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpSignedBy) {
            
            lstrcpy(lpFileNode->lpSignedBy, szBuffer);
        }
#endif
    
    } else {
        // 
        // Get the icon (if the file isn't signed) so we can display it in the listview faster.
        //
        //MyGetFileInfo(lpFileNode);
    }

    return lpFileNode->bSigned;
}


LPFILENODE CreateFileNode(LPTSTR lpDirectory, LPTSTR lpFileName)
{
    LPFILENODE                  lpFileNode;
    TCHAR                       szDirName[MAX_PATH];
    FILETIME                    ftLocalTime;
    WIN32_FILE_ATTRIBUTE_DATA   faData;
    BOOL                        bRet;
    
    GetCurrentDirectory(MAX_PATH, szDirName);
    CharLowerBuff(szDirName, lstrlen(szDirName));

    lpFileNode = (LPFILENODE) MALLOC(sizeof(FILENODE));

    if (lpFileNode) 
    {
        lpFileNode->lpFileName = (LPTSTR) MALLOC((lstrlen(lpFileName) + 1) * sizeof(TCHAR));

        if (!lpFileNode->lpFileName) 
        {
            goto clean0;
        }
        
        lstrcpy(lpFileNode->lpFileName, lpFileName);
        CharLowerBuff(lpFileNode->lpFileName, lstrlen(lpFileNode->lpFileName));
    
        if (lpDirectory)
        {
            lpFileNode->lpDirName = (LPTSTR) MALLOC((lstrlen(lpDirectory) + 1) * sizeof(TCHAR));
            
            if (!lpFileNode->lpDirName) 
            {
                goto clean0;
            }
                
            lstrcpy(lpFileNode->lpDirName, lpDirectory);
            CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
        }
        else
        {
            lpFileNode->lpDirName = (LPTSTR) MALLOC((lstrlen(szDirName) + 1) * sizeof(TCHAR));

            if (!lpFileNode->lpDirName) 
            {
                goto clean0;
            }
            
            lstrcpy(lpFileNode->lpDirName, szDirName);
            CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
        }
    
        if (lpDirectory)
            SetCurrentDirectory(lpDirectory);
    
        ZeroMemory(&faData, sizeof(WIN32_FILE_ATTRIBUTE_DATA));
        bRet = GetFileAttributesEx(lpFileName, GetFileExInfoStandard, &faData);
        if (bRet) 
        {
            // Store away the last access time for logging purposes.
            FileTimeToLocalFileTime(&faData.ftLastWriteTime, &ftLocalTime);
            FileTimeToSystemTime(&ftLocalTime, &lpFileNode->LastModified);
        }
    }
    
    if (lpDirectory)
        SetCurrentDirectory(szDirName);

    return lpFileNode;

clean0:

    //
    // If we get here then we weren't able to allocate all of the memory needed
    // for this structure, so free up any memory we were able to allocate and
    // reutnr NULL.
    //
    if (lpFileNode) 
    {
        if (lpFileNode->lpFileName) 
        {
            FREE(lpFileNode->lpFileName);
        }

        if (lpFileNode->lpDirName) 
        {
            FREE(lpFileNode->lpDirName);
        }

        FREE(lpFileNode);
    }

    return NULL;
}

LPFILENODE Check_File(LPTSTR szFilePathName)
{
	LPFILENODE lpFileNode = NULL;

	// If we don't already have a g_hCatAdmin handle, acquire one.
  if (!g_hCatAdmin) {
      CryptCATAdminAcquireContext(&g_hCatAdmin, NULL, 0);
  }
	
	TCHAR* szFileName = szFilePathName;
	
	if(szFilePathName)
	{
		szFileName = _tcsrchr(szFilePathName, _T('\\'));
		if(szFileName)
		{
			*szFileName++ = _T('\0');

			lpFileNode = CreateFileNode(szFilePathName, szFileName);
			if(lpFileNode)
			{
				VerifyFileNode(lpFileNode);
			}
		}
	}

	return lpFileNode; 
}

// returns data between dbl quotes, unescapes slashes
// "\\\\red-prn-23\\priv0124" -> \\red-prn-23\priv0124
LPTSTR GetQuotedData(VARIANT& v, BOOL bUnescapeSlashs = TRUE)
{
	CString szData;
	if(v.vt == VT_BSTR)
	{
		szData = v.bstrVal;
		if(!szData.IsEmpty()) 
		{
			int nPos = szData.Find(_T('"'));
			if(nPos >= 0 && (szData.GetLength() > 1))
			{
				szData = szData.Mid(nPos + 1);
				nPos = szData.Find(_T('"'));
				if(nPos >= 0)
				{
					szData = szData.Mid(0, nPos);
					if(bUnescapeSlashs)
						szData.Replace(_T("\\\\"), _T("\\"));	
				}
			}	
		}

		VariantClear(&v);
		v.vt = VT_BSTR;
		v.bstrVal = CComBSTR(szData);	
	}
	CComBSTR bstrData(szData);
	if (!bstrData)
	{
		bstrData = (_T(""));
	}
	return bstrData;
	//return CComBSTR(szData);
}

void CWhqlObj::BuildPrinterFileList(CPtrArray& ptrArr, IWbemClassObject *& pClass, IWbemContext *pCtx , Classes_Provided eClasses)
{
	IEnumWbemClassObject *pEnum = NULL;
	IWbemClassObject *pInstance	= NULL;
	IWbemClassObject *pObject	= NULL;
	ULONG uReturned = 0;
	HRESULT hr = WBEM_S_NO_ERROR;
	CComVariant	val;
	LPFILENODE lpFileNode = NULL;

	if((eClasses == Class_Win32_PnPSignedDriver) || 
		 (eClasses == Class_Win32_PnPSignedDriverCIMDataFile))
	{
		hr = CoImpersonateClient(); //Impersonate the client. This is a must to be able to see network printers.
		


		CString csPathStr;
		GetServerAndNamespace(pCtx, csPathStr); //Get Server And Namespace.

		hr = m_pNamespace->CreateInstanceEnum(CComBSTR("Win32_PrinterDriverDll"), 
							WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
							pCtx,
							&pEnum);
							
		while(WBEM_S_NO_ERROR == hr && pEnum)
		{
			hr = pEnum->Next(WBEM_INFINITE,
					1,
					&pObject,
					&uReturned);

			if(SUCCEEDED(hr) && pObject)
			{
				hr = pObject->Get(_T("Antecedent"), 0, &val, NULL , NULL);
				if(SUCCEEDED(hr))
				{
					if(pClass)
						hr = pClass->SpawnInstance(0, &pInstance);

					if(SUCCEEDED(hr) && pInstance)
					{
						if(eClasses == Class_Win32_PnPSignedDriver)
						{
							LPTSTR szDriverPath = GetQuotedData(val);
							if(szDriverPath)
							{
								lpFileNode = Check_File(szDriverPath);
								if(lpFileNode)
								{
									val = lpFileNode->bSigned;
									hr = pInstance->Put(_T("IsSigned"), 0, &val, 0);

									val.Clear();

									val = lpFileNode->lpVersion;
									hr = pInstance->Put(_T("DriverVersion"), 0, &val, 0);

									val.Clear();

									val = lpFileNode->lpSignedBy;
									hr = pInstance->Put(_T("Signer"), 0, &val, 0);
									val.Clear();
									if (lpFileNode->lpFileName) 
									{
										FREE(lpFileNode->lpFileName);
									}
									if (lpFileNode->lpDirName) 
									{
										FREE(lpFileNode->lpDirName);
									}

									FREE(lpFileNode);
								}
							}
						}
						else if(eClasses == Class_Win32_PnPSignedDriverCIMDataFile)
						{
							GetQuotedData(val, FALSE);
							CString szData(csPathStr);
							szData += _T(":CIM_DataFile.Name=\"");
							szData += val.bstrVal;
							szData += _T("\"");
							val = szData;

							hr = pInstance->Put(_T("Dependent"), 0, &val, 0);
						}

						val.Clear();

						hr = pObject->Get(_T("Dependent"), 0, &val, NULL , NULL);
						if(SUCCEEDED(hr))
						{
							if(eClasses == Class_Win32_PnPSignedDriver)
							{
								GetQuotedData(val);
								hr = pInstance->Put(_T("DeviceID"), 0, &val, 0);
							}
							else if(eClasses == Class_Win32_PnPSignedDriverCIMDataFile)
							{
								GetQuotedData(val, FALSE);
								CString szData(csPathStr);
								szData += _T(":Win32_PnPSignedDriver.DeviceID=\"");
								szData += val.bstrVal;
								szData += _T("\"");
								val = szData;

								hr = pInstance->Put(_T("Antecedent"), 0, &val, 0);
							}
						}
						
						ptrArr.Add(pInstance);
					}

					val.Clear();
				}
				
				if(pObject)
				{
					pObject->Release();
					pObject = NULL;
				}
			}

			val.Clear();

		}

		if(pEnum)
		{
			pEnum->Release();
			pEnum = NULL;
		}

		CoRevertToSelf(); //Revert back
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\whqlobj.h ===
// WhqlObj.h : Declaration of the CWhqlObj

#ifndef __WHQLOBJ_H_
#define __WHQLOBJ_H_

#include "resource.h"       // main symbols
#include "WbemProv.h"
#include <softpub.h>

// Macros and pre-defined values
#define     cbX(X)      sizeof(X)
#define     cA(a)       (cbX(a)/cbX(a[0]))
#define     MALLOC(x)   HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (x))
#define     FREE(x)     if (x) { HeapFree(GetProcessHeap(), 0, (x)); x = NULL; }
#define     EXIST(x)    (GetFileAttributes(x) != 0xFFFFFFFF)
#define     MAX_INT     0x7FFFFFFF
#define     HASH_SIZE   100
#define     NUM_PAGES   2

typedef struct tagFileNode
{
    LPTSTR          lpFileName;
    LPTSTR          lpDirName;
    LPTSTR          lpVersion;
    LPTSTR          lpCatalog;
    LPTSTR          lpSignedBy;
    LPTSTR          lpTypeName;
    INT             iIcon;
    BOOL            bSigned;
    BOOL            bScanned;
    BOOL            bValidateAgainstAnyOs;
    DWORD           LastError;
    SYSTEMTIME      LastModified;
    struct  tagFileNode *next;
} FILENODE, *LPFILENODE;


/////////////////////////////////////////////////////////////////////////////
// CWhqlObj

class ATL_NO_VTABLE CWhqlObj : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWhqlObj, &CLSID_WhqlObj>,
	public IDispatchImpl<IWhqlObj, &IID_IWhqlObj, &LIBID_MSINFO32Lib>,
	public IWbemProviderInit,
	public IWbemServices
{
public:
	CWhqlObj()
	{
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_WHQLPROV)
DECLARE_REGISTRY_RESOURCEID(IDR_WHQLOBJ)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWhqlObj)
	COM_INTERFACE_ENTRY(IWhqlObj)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
	COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()

// IWhqlObj
public:

//IWbemProviderInit
		STDMETHOD(Initialize)(
			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pNamespace,
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink);

		STDMETHOD(GetByPath)(BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext *pCtx) {return WBEM_E_NOT_SUPPORTED;};

//IWbemServices  
	HRESULT STDMETHODCALLTYPE OpenNamespace(
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall(
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink(
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClass(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
	
private:
	IWbemServices* m_pNamespace;
	//IWbemClassObject*	m_pClass;
	//CString m_csPathStr ;
	//CPtrArray m_ptrArr;

	SCODE PutPropertyValue(IWbemClassObject*, LPCTSTR, LPCTSTR);
	SCODE PutPropertyDTMFValue(IWbemClassObject* pInstance, LPCTSTR szName, LPCTSTR szValue);//v-stlowe
	int WalkTree(void);
	int CreateList(CPtrArray&, IWbemClassObject *&, IWbemContext *, Classes_Provided);
	SCODE	GetServerAndNamespace(IWbemContext*, CString&);
	void BuildPrinterFileList(CPtrArray&, IWbemClassObject *&, IWbemContext *, Classes_Provided);
};

#endif //__WHQLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\version5extension.h ===
//=============================================================================
// Contains definitions for reading in version 5.0 MSInfo extensions.
//=============================================================================

#pragma once

//-----------------------------------------------------------------------------
// Constants used in the data gathering files.
//-----------------------------------------------------------------------------

#define NODE_KEYWORD			"node"
#define COLUMN_KEYWORD			"columns"
#define LINE_KEYWORD			"line"
#define ENUMLINE_KEYWORD		"enumlines"
#define FIELD_KEYWORD			"field"
#define STATIC_SOURCE			"static"
#define TEMPLATE_FILE_TAG		"MSINFO,0000"
#define SORT_VALUE				"VALUE"
#define SORT_LEXICAL			"LEXICAL"
#define COMPLEXITY_ADVANCED		"ADVANCED"
#define COMPLEXITY_BASIC		"BASIC"
#define DEPENDENCY_JOIN			"dependency"
#define SQL_FILTER				"WQL:"

//-----------------------------------------------------------------------------
// These structures are used by the INTERNAL_CATEGORY structure to store both
// the specification for what information is shown as well as the actually 
// data to be shown (refreshed on command).
//-----------------------------------------------------------------------------
// GATH_VALUE is used to store a list of strings. A list of column names or a 
// list of arguments would use the GATH_VALUE struct. Note, a next pointer is
// not needed because these structures will be allocated contiguously (in
// an array).

struct GATH_VALUE
{
	GATH_VALUE();
	~GATH_VALUE();
	CString			m_strText;
	DWORD			m_dwValue;
	GATH_VALUE *	m_pNext;
};

// A GATH_FIELD is used to store the specification for a text string. It contains
// a format string (a printf style string) and a GATH_VALUE pointer to a list of
// arguments for the format string.

struct GATH_FIELD
{
	GATH_FIELD();
	~GATH_FIELD();
	CString				m_strSource;		// WBEM class containing information
	CString				m_strFormat;		// printf-type format string
	unsigned short		m_usWidth;			// width (if this field is for a column)
	MSIColumnSortType	m_sort;				// how to sort this column
	DataComplexity		m_datacomplexity;	// is this column BASIC or ADVANCED
	GATH_VALUE *		m_pArgs;			// arguments for m_strFormat
	GATH_FIELD *		m_pNext;			// next field in the list
};

// A GATH_LINESPEC is used to specify what is shown on a line in the listview. It
// contains a string for a class to enumerate. If this string is empty, then
// the struct merely represents a single line in the display. The GATH_FIELD pointer
// is to a list of the fields (one for each column), and the m_pNext pointer is
// to the next line to be displayed. If m_strEnumerateClass is not empty, then
// the class specified is enumerated, and the lines pointed to by m_pEnumeratedGroup
// are repeated for each instance of the class. Note, if a class is to be enumerated,
// the m_pFields pointer must be null (since this line won't display anything
// itself, but enumerate a class for another group of lines).
//
// m_pConstraintFields is a pointer to a linked list of fields which serve as
// constraints for the enumeration. These can be used to filter the enumerated
// instances or to perform joins to related classes so they are enumerated as
// well is the primary class. m_pConstraintFields should only be non-NULL when
// m_pEnumeratedGroup is non-NULL.

struct GATH_LINESPEC
{
	GATH_LINESPEC();
	~GATH_LINESPEC();
	CString			m_strEnumerateClass;
	DataComplexity	m_datacomplexity;
	GATH_FIELD *	m_pFields;
	GATH_LINESPEC *	m_pEnumeratedGroup;
	GATH_FIELD *	m_pConstraintFields;
	GATH_LINESPEC *	m_pNext;
};

// The GATH_LINE struct contains the actual data to be displayed on a line. The 
// refresh operation will take list of GATH_LINESPEC structs and create a list 
// of GATH_LINE structs. The m_aValue pointer is to a list of values to be 
// displayed (one per column).

struct GATH_LINE
{
	GATH_LINE();
	~GATH_LINE();
	GATH_VALUE *	m_aValue;
	DataComplexity	m_datacomplexity;
};

//-----------------------------------------------------------------------------
// The following structure is used within this object to store information
// about the categories. Specifically, this structure will be allocated for
// each category, and a pointer stored in m_mapCategories. This representation
// will not be used outside this object, rather, a CDataCategory object will
// be used.
//-----------------------------------------------------------------------------

struct INTERNAL_CATEGORY
{
	INTERNAL_CATEGORY();
	~INTERNAL_CATEGORY();

	GATH_VALUE		m_categoryName;			// realized name of category
	GATH_FIELD		m_fieldName;			// field used to get name
	CString			m_strEnumerateClass;	// if !(empty or "static"), this category repeated
	CString			m_strIdentifier;		// non-localized internal name
	CString			m_strNoInstances;		// message to use if there are no instances
	BOOL			m_fListView;			// is this cat a list view
	BOOL			m_fDynamic;				// was this cat enumerated
	BOOL			m_fIncluded;			// should this cat be included
	DWORD			m_dwID;					// the ID for this cat

	DWORD			m_dwParentID;			// my parent
	DWORD			m_dwChildID;			// my first child
	DWORD			m_dwDynamicChildID;		// my first dynamically created child
	DWORD			m_dwNextID;				// my next sibling
	DWORD			m_dwPrevID;				// my previous sibling

	DWORD			m_dwColCount;			// number of columns
	GATH_FIELD *	m_pColSpec;				// list of fields to make col names
	GATH_VALUE *	m_aCols;				// realized list of columns

	GATH_LINESPEC*	m_pLineSpec;			// list of line specifiers
	DWORD			m_dwLineCount;			// number of lines (NOT number of line specs)
	GATH_LINE *	*	m_apLines;				// realized list of lines

	BOOL			m_fRefreshed;			// has the category ever been refreshed

	DWORD			m_dwLastError;			// last error specific to this category
};

//-----------------------------------------------------------------------------
// A class to contain the template functions.
//-----------------------------------------------------------------------------

class CTemplateFileFunctions
{
public:
	static DWORD				ParseTemplateIntoVersion5Categories(const CString & strExtension, CMapWordToPtr & mapVersion5Categories);
	static DWORD				ReadTemplateFile(CFile * pFile, CMapWordToPtr & mapVersion5Categories);
	static BOOL					ReadHeaderInfo(CFile * pFile);
	static BOOL					VerifyUNICODEFile(CFile * pFile);
	static BOOL					VerifyAndAdvanceFile(CFile * pFile, const CString & strVerify);
	static DWORD				ReadNodeRecursive(CFile * pFile, CMapWordToPtr & mapCategories, DWORD dwParentID, DWORD dwPrevID);
	static INTERNAL_CATEGORY *	GetInternalRep(CMapWordToPtr & mapCategories, DWORD dwID);
	static INTERNAL_CATEGORY *	CreateCategory(CMapWordToPtr & mapCategories, DWORD dwNewID, DWORD dwParentID, DWORD dwPrevID);
	static BOOL					ReadArgument(CFile * pFile, CString & strSource);
	static BOOL					ReadField(CFile * pFile, GATH_FIELD & field);
	static GATH_LINESPEC *		ReadLineEnumRecursive(CFile * pFile, CMapWordToPtr & mapCategories);
	static BOOL					ReadColumnInfo(CFile * pFile, CMapWordToPtr & mapCategories, DWORD dwID);
	static GATH_LINESPEC *		ReadLineInfo(CFile * pFile);
	static BOOL					GetKeyword(CFile * pFile, CString & strKeyword);
};

//-----------------------------------------------------------------------------
// A class to contain the refresh functions.
//-----------------------------------------------------------------------------

class CWMIHelper;

class CRefreshFunctions
{
public:
	static BOOL RefreshLines(CWMIHelper * pWMI, GATH_LINESPEC * pLineSpec, DWORD dwColumns, CPtrList & listLinePtrs, volatile BOOL * pfCancel);
	static BOOL RefreshOneLine(CWMIHelper * pWMI, GATH_LINE * pLine, GATH_LINESPEC * pLineSpec, DWORD dwColCount);
	static BOOL RefreshValue(CWMIHelper * pWMI, GATH_VALUE * pVal, GATH_FIELD * pField);
	static BOOL GetValue(CWMIHelper * pWMI, TCHAR cFormat, TCHAR *szFormatFragment, CString &strResult, DWORD &dwResult, GATH_FIELD *pField, int iArgNumber);
};

//-----------------------------------------------------------------------------
// The CMSIObject class is a thin wrapper for the IWbemClassObject interface.
// We use this so we can return a custom label for a null object (if there
// are no instances, we sometimes want to show some caption).
//-----------------------------------------------------------------------------

typedef enum { MOS_NO_INSTANCES, MOS_MSG_INSTANCE, MOS_INSTANCE } MSIObjectState;

struct IWbemClassObject;
class CMSIObject
{
public:
	CMSIObject(IWbemClassObject * pObject, const CString & strLabel, HRESULT hres, CWMIHelper * pWMI, MSIObjectState objState);
	~CMSIObject();

	HRESULT Get(BSTR property, LONG lFlags, VARIANT *pVal, VARTYPE *pvtType, LONG *plFlavor);
	HRESULT	GetErrorLabel(CString & strError);
	MSIObjectState IsValid();

private:
	IWbemClassObject *				m_pObject;
	CString							m_strLabel;
	HRESULT							m_hresCreation;
	CWMIHelper *					m_pWMI;
	MSIObjectState					m_objState;
};

//-----------------------------------------------------------------------------
// The CMSIEnumerator class encapsulates the WBEM enumerator interface, or
// implements our own form of enumerator (such as for the LNK command in the
// template file).
//-----------------------------------------------------------------------------

struct IEnumWbemClassObject;
class CMSIEnumerator
{
public:
	CMSIEnumerator();
	~CMSIEnumerator();

	HRESULT Create(const CString & strClass, const GATH_FIELD * pConstraints, CWMIHelper * pWMI);
	HRESULT Next(CMSIObject ** ppObject);
	HRESULT Reset(const GATH_FIELD * pConstraints);

private:
	typedef enum { CLASS, WQL, LNK, INTERNAL } EnumType;

private:
	EnumType				m_enumtype;
	BOOL					m_fOnlyDups;
	BOOL					m_fGotDuplicate;
	BOOL					m_fMinOfOne;
	int						m_iMinOfOneCount;
	CString					m_strClass;
	CString					m_strObjPath;
	CString					m_strAssocClass;
	CString					m_strResultClass;
	CString					m_strLNKObject;
	CString					m_strNoInstanceLabel;
	IEnumWbemClassObject *	m_pEnum;
	CWMIHelper *			m_pWMI;
	const GATH_FIELD *		m_pConstraints;
	HRESULT					m_hresCreation;
	IWbemClassObject * 		m_pSavedDup;
	CString					m_strSavedDup;
	CStringList	*			m_pstrList;

private:
	BOOL	AssocObjectOK(IWbemClassObject * pObject, CString & strAssociatedObject);
	HRESULT ParseLNKCommand(const CString & strStatement, CString & strObjPath, CString & strAssocClass, CString & strResultClass);
	void	ProcessEnumString(CString & strStatement, BOOL & fMinOfOne, BOOL & fOnlyDups, CWMIHelper * pWMI, CString & strNoInstanceLabel, BOOL fMakeDoubleBackslashes = FALSE);
	HRESULT CreateInternalEnum(const CString & strInternal, CWMIHelper * pWMI);
	HRESULT InternalNext(IWbemClassObject ** ppWBEMObject);
};

//-----------------------------------------------------------------------------
// A class to map a DWORD to refresh data (used by the refresh function).
//-----------------------------------------------------------------------------

class CMapExtensionRefreshData
{
public:
	CMapExtensionRefreshData() : m_dwIndex(0) { };
	~CMapExtensionRefreshData()
	{
		GATH_LINESPEC * pLineSpec;
		WORD			key;

		for (POSITION pos = m_map.GetStartPosition(); pos != NULL;)
		{
			m_map.GetNextAssoc(pos, key, (void * &) pLineSpec);
			if (pLineSpec)
				delete pLineSpec;
		}
		m_map.RemoveAll();

		CString * pstr;
		for (pos = m_mapStrings.GetStartPosition(); pos != NULL;)
		{
			m_mapStrings.GetNextAssoc(pos, key, (void * &) pstr);
			if (pstr)
				delete pstr;
		}
		m_mapStrings.RemoveAll();
	}

	DWORD Insert(GATH_LINESPEC * pLineSpec)
	{
		if (pLineSpec == NULL)
			return 0;

		m_dwIndex += 1;
		m_map.SetAt((WORD) m_dwIndex, (void *) pLineSpec);
		return m_dwIndex;
	}

	void InsertString(DWORD dwID, const CString & strInsert)
	{
		CString * pstr = new CString(strInsert);
		m_mapStrings.SetAt((WORD) dwID, (void *) pstr);
	}

	GATH_LINESPEC * Lookup(DWORD dwIndex)
	{
		GATH_LINESPEC * pReturn;
		if (m_map.Lookup((WORD) dwIndex, (void * &) pReturn))
			return pReturn;
		return NULL;
	}

	CString * LookupString(DWORD dwIndex)
	{
		CString * pstrReturn;
		if (m_mapStrings.Lookup((WORD) dwIndex, (void * &) pstrReturn))
			return pstrReturn;
		return NULL;;
	}

private:
	DWORD			m_dwIndex;
	CMapWordToPtr	m_map;
	CMapWordToPtr	m_mapStrings;
};

extern CMapExtensionRefreshData gmapExtensionRefreshData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\wmilive.cpp ===
//=============================================================================
// This file contains the code for the classes which implement a live WMI
// data source.
//=============================================================================

#include "stdafx.h"
#include "wmilive.h"
#include "resource.h"

//-----------------------------------------------------------------------------
// It's necessary to modify the security settings on a new WMI interface.
//-----------------------------------------------------------------------------

inline HRESULT ChangeWBEMSecurity(IUnknown * pUnknown)
{
	IClientSecurity * pCliSec = NULL;

	HRESULT hr = pUnknown->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
	if (FAILED(hr))
		return hr;

	hr = pCliSec->SetBlanket(pUnknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
	pCliSec->Release();
	return hr;
}

//=============================================================================
// CWMILiveObject Functions
// 
// The constructor/destructor are really straight forward.
//=============================================================================

CWMILiveObject::CWMILiveObject() : m_pObject(NULL), m_pServices(NULL)
{
}

CWMILiveObject::~CWMILiveObject()
{
	if (m_pObject != NULL)
	{
		m_pObject->Release();
		m_pObject = NULL;
	}

	if (m_pServices != NULL)
	{
		m_pServices->Release();
		m_pServices = NULL;
	}
}

//-----------------------------------------------------------------------------
// The Create functions will either create the object from a WMI object, or
// from a service pointer and a path.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObject::Create(IWbemServices * pServices, IWbemClassObject * pObject)
{
	ASSERT(pObject && "calling CWMILiveObject::Create with a null object");
	if (m_pObject != NULL)
		m_pObject->Release();

	m_pObject = pObject;
	if (m_pObject)
		m_pObject->AddRef();

	m_pServices = pServices;
	if (m_pServices)
		m_pServices->AddRef();

	return S_OK;
}

HRESULT CWMILiveObject::Create(IWbemServices * pServices, LPCTSTR szObjectPath)
{
	ASSERT(pServices && szObjectPath);
	if (m_pObject != NULL)
	{
		m_pObject->Release();
		m_pObject = NULL; // must be NULL or GetObject bitches
	}

#ifdef UNICODE
	BSTR bstrPath = SysAllocString(szObjectPath);
#else
	USES_CONVERSION;
	LPOLESTR szWidePath = T2OLE(szObjectPath);
	BSTR bstrPath = SysAllocString(szWidePath);
#endif

	HRESULT hr;
	if (bstrPath)
	{
		hr = pServices->GetObject(bstrPath, 0L, NULL, &m_pObject, NULL);
		SysFreeString(bstrPath);
	}
	else
		hr = E_OUTOFMEMORY;

	m_pServices = pServices;
	if (m_pServices)
		m_pServices->AddRef();

	return hr;
}

//-----------------------------------------------------------------------------
// The simple GetValue returns the named value as a variant.
//
// The pointer to an existing uninitialized VARIANT structure that receives
// the property value, if found. Because this is an output parameter, this
// method calls VariantInit on this VARIANT, so you must be sure that this
// is not pointing to an active VARIANT.
//
// Note: You must call VariantClear on the returned VARIANT when its value
// is no longer required. This will prevent memory leaks in the client process.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObject::GetValue(LPCTSTR szProperty, VARIANT * pvarValue)
{
	ASSERT(szProperty && pvarValue);
	if (m_pObject == NULL)
	{
		ASSERT(0 && "CWMILiveObject::GetValue called on a null object");
		return E_FAIL;
	}

#ifdef UNICODE
	BSTR bstrProperty = SysAllocString(szProperty);
#else
	USES_CONVERSION;
	LPOLESTR szWideProperty = T2OLE(szProperty);
	BSTR bstrProperty = SysAllocString(szWideProperty);
#endif

	HRESULT hr;
	if (bstrProperty)
	{
		hr = m_pObject->Get(bstrProperty, 0L, pvarValue, NULL, NULL);
		SysFreeString(bstrProperty);

		if (FAILED(hr))
			hr = E_MSINFO_NOPROPERTY;
	}
	else
		hr = E_FAIL;

	return hr;
}

//-----------------------------------------------------------------------------
// Get the named value as a string. Handle this even if the result is an
// array of values. The caller is responsible for freeing the string.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObject::GetValueString(LPCTSTR szProperty, CString * pstrValue)
{
	ASSERT(pstrValue);
	VARIANT variant;

	HRESULT hr = GetValue(szProperty, &variant);
	if (SUCCEEDED(hr))
	{
		// If the property we just got is an array, we should convert it to string
		// containing a list of the items in the array.

		if ((variant.vt & VT_ARRAY) && (variant.vt & VT_BSTR) && variant.parray)
		{
			if (SafeArrayGetDim(variant.parray) == 1)
			{
				long lLower = 0, lUpper = 0;

				SafeArrayGetLBound(variant.parray, 1, &lLower);
				SafeArrayGetUBound(variant.parray, 1, &lUpper);

				CComBSTR bstrWorking;
				BSTR	 bstr = NULL;
				for (long i = lLower; i <= lUpper; i++)
					if (SUCCEEDED(SafeArrayGetElement(variant.parray, &i, (wchar_t*)&bstr)))
					{
						if (i != lLower)
							bstrWorking.Append(L", ");
						bstrWorking.AppendBSTR(bstr);
					}

				*pstrValue = bstrWorking;
			}
		}
		else if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
		{
			CComBSTR bstrWorking(V_BSTR(&variant));

			unsigned int i, nLength = bstrWorking.Length();
			BOOL fNonPrintingChar = FALSE;

			for (i = 0; i < nLength && !fNonPrintingChar; i++)
				if (((BSTR)bstrWorking)[i] < (WCHAR)0x20)	// the 0x20 is from the XML spec
					fNonPrintingChar = TRUE;

			if (fNonPrintingChar)
			{
				CString strWorking;
				for (i = 0; i < nLength; i++)
				{
					WCHAR c = ((BSTR)bstrWorking)[i];
					if (c >= (WCHAR)0x20)
						strWorking += c;
					else
					{
						CString strTemp;
						strTemp.Format(_T("&#x%04x;"), c);
						strWorking += strTemp;
					}
				}

				*pstrValue = strWorking;
			}
			else
				*pstrValue = bstrWorking;
		}
		else
		{
			hr = E_MSINFO_NOVALUE;
		}
	}

	VariantClear(&variant);
	return hr;
}

//-----------------------------------------------------------------------------
// Get the named value as a DWORD.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObject::GetValueDWORD(LPCTSTR szProperty, DWORD * pdwValue)
{
	ASSERT(pdwValue);
	VARIANT variant;

	HRESULT hr = GetValue(szProperty, &variant);
	if (SUCCEEDED(hr))
	{
		if (VariantChangeType(&variant, &variant, 0, VT_I4) == S_OK)
			*pdwValue = V_I4(&variant);
		else
			hr = E_MSINFO_NOVALUE;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Get the named value as a SYSTEMTIME.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObject::GetValueTime(LPCTSTR szProperty, SYSTEMTIME * psystimeValue)
{
	ASSERT(psystimeValue);
	VARIANT variant;

	HRESULT hr = GetValue(szProperty, &variant);
	if (SUCCEEDED(hr))
	{
		if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
		{
			USES_CONVERSION;
			LPTSTR szDate = OLE2T(V_BSTR(&variant));

			// Parse the date string into the SYSTEMTIME struct. It would be better to
			// get the date from WMI directly, but there was a problem with this. TBD - 
			// look into whether or not we can do this now.

			ZeroMemory(psystimeValue, sizeof(SYSTEMTIME));
			psystimeValue->wSecond	= (unsigned short)_ttoi(szDate + 12);	szDate[12] = _T('\0');
			psystimeValue->wMinute	= (unsigned short)_ttoi(szDate + 10);	szDate[10] = _T('\0');
			psystimeValue->wHour	= (unsigned short)_ttoi(szDate +  8);	szDate[ 8] = _T('\0');
			psystimeValue->wDay		= (unsigned short)_ttoi(szDate +  6);	szDate[ 6] = _T('\0');
			psystimeValue->wMonth	= (unsigned short)_ttoi(szDate +  4);	szDate[ 4] = _T('\0');
			psystimeValue->wYear	= (unsigned short)_ttoi(szDate +  0);
		}
		else
			hr = E_MSINFO_NOVALUE;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Get the named value as a double float.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObject::GetValueDoubleFloat(LPCTSTR szProperty, double * pdblValue)
{
	ASSERT(pdblValue);
	VARIANT variant;

	HRESULT hr = GetValue(szProperty, &variant);
	if (SUCCEEDED(hr))
	{
		if (VariantChangeType(&variant, &variant, 0, VT_R8) == S_OK)
			*pdblValue = V_R8(&variant);
		else
			hr = E_MSINFO_NOVALUE;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Check for a value map value. If there isn't one, just use the untranslated
// value.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObject::GetValueValueMap(LPCTSTR szProperty, CString * pstrValue)
{
	CString strResult;
	HRESULT hr = GetValueString(szProperty, &strResult);
	
	if (SUCCEEDED(hr))
	{
		CString strClass;
		CString strValueMapVal;

		if (m_pServices && SUCCEEDED(GetValueString(_T("__CLASS"), &strClass)))
			if (SUCCEEDED(CWMILiveHelper::CheckValueMap(m_pServices, strClass, szProperty, strResult, strValueMapVal)))
				strResult = strValueMapVal;
	}

	*pstrValue = strResult;
	return hr;
}

//=============================================================================
// CWMILiveObjectCollection Functions
// 
// The constructor and destructor for CWMILiveObjectCollection are very
// straightforward.
//=============================================================================

CWMILiveObjectCollection::CWMILiveObjectCollection(IWbemServices * pServices) :	m_pServices(pServices),	m_pEnum(NULL)
{
	ASSERT(m_pServices);
	if (m_pServices)
		m_pServices->AddRef();
}

CWMILiveObjectCollection::~CWMILiveObjectCollection()
{
	if (m_pServices)
		m_pServices->Release();

	if (m_pEnum)
		m_pEnum->Release();
}

//-----------------------------------------------------------------------------
// Create the collection of WMI objects (a WMI enumerator) based on the
// class name and the requested properties.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObjectCollection::Create(LPCTSTR szClass, LPCTSTR szProperties)
{
	ASSERT(szClass);

	if (m_pEnum)
		m_pEnum->Release();

	// Build the appopriate WQL query statement from the class and requested properties.

	LPCTSTR szWQLProperties = (szProperties && szProperties[0]) ? szProperties : _T("*");
	LPTSTR szQuery = new TCHAR[_tcsclen(szWQLProperties) + _tcsclen(szClass) + 14 /* length of "SELECT  FROM " + 1 */];
	if (szQuery == NULL)
		return E_OUTOFMEMORY;
	wsprintf(szQuery, _T("SELECT %s FROM %s"), szWQLProperties, szClass);

	HRESULT hr = CreateWQL(szQuery);
	delete [] szQuery;
	return hr;
}

//-----------------------------------------------------------------------------
// Create the collection of WMI objects (a WMI enumerator) based on the query.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObjectCollection::CreateWQL(LPCTSTR szQuery)
{
	ASSERT(szClass);

	if (m_pEnum)
		m_pEnum->Release();

	// Perform the query using our saved services pointer.

	HRESULT hr;
	BSTR bstrLanguage = SysAllocString(L"WQL");
#ifdef UNICODE
	BSTR bstrQuery = SysAllocString(szQuery);
#else
	USES_CONVERSION;
	LPOLESTR szWideQuery = T2OLE(szQuery);
	BSTR bstrQuery = SysAllocString(szWideQuery);
#endif

	if (bstrLanguage && bstrQuery)
		hr = m_pServices->ExecQuery(bstrLanguage, bstrQuery, WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, 0, &m_pEnum);
	else
		hr = E_OUTOFMEMORY;
	
	if (SUCCEEDED(hr))
		ChangeWBEMSecurity(m_pEnum);

	if (bstrQuery)
		SysFreeString(bstrQuery);
	if (bstrLanguage)
		SysFreeString(bstrLanguage);

	return hr;
}

//-----------------------------------------------------------------------------
// Create this class of an existing enumerator. This may be a little odd,
// since the enumerators will interact if both are advancing.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObjectCollection::Create(IEnumWbemClassObject * pEnum)
{
	if (m_pEnum)
		m_pEnum->Release();

	m_pEnum = pEnum;
	
	if (m_pEnum)
	{
		m_pEnum->AddRef();
		ChangeWBEMSecurity(m_pEnum);
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Return the next item in the WMI enumerator as a CWMILiveObject object.
//-----------------------------------------------------------------------------

HRESULT CWMILiveObjectCollection::GetNext(CWMIObject ** ppObject)
{
	ASSERT(ppObject);
	if (m_pEnum == NULL)
	{
		ASSERT(0 && "CWMILiveObjectCollection::GetNext called on a null enumerator");
		return E_FAIL;
	}

	IWbemClassObject *	pRealWMIObject = NULL;
	ULONG				uReturned;

	HRESULT hr = m_pEnum->Next(TIMEOUT, 1, &pRealWMIObject, &uReturned);
	if (hr == S_OK && uReturned == 1)
	{
		if (*ppObject == NULL)
			*ppObject = new CWMILiveObject;

		if (*ppObject)
		{
			hr = ((CWMILiveObject *)(*ppObject))->Create(m_pServices, pRealWMIObject); // this will AddRef the pointer
			if (FAILED(hr))
			{
				delete (CWMILiveObject *)(*ppObject);
				*ppObject = NULL;
			}
		}
		else
			hr = E_OUTOFMEMORY;
		pRealWMIObject->Release();
	}

	return hr;
}

//=============================================================================
// CWMILiveHelper Functions
// 
// The constructor/destructor are really straight forward.
//=============================================================================

CWMILiveHelper::CWMILiveHelper() : m_hrError(S_OK), m_strMachine(_T("")), m_strNamespace(_T("")), m_pServices(NULL)
{
}

CWMILiveHelper::~CWMILiveHelper()
{
	if (m_pServices)
	{
		m_pServices->Release();
		m_pServices = NULL;
	}

	if (m_pIWbemServices)
	{
		m_pIWbemServices->Release();
		m_pIWbemServices = NULL;
	}

	Version5ClearCache();
}

//-----------------------------------------------------------------------------
// Enumerate creates a CWMILiveObjectCollection based on the class.
//-----------------------------------------------------------------------------

HRESULT CWMILiveHelper::Enumerate(LPCTSTR szClass, CWMIObjectCollection ** ppCollection, LPCTSTR szProperties)
{
	ASSERT(m_pServices);
	if (m_pServices == NULL)
		return E_FAIL;

	ASSERT(ppCollection);
	if (ppCollection == NULL)
		return E_INVALIDARG;

	CWMILiveObjectCollection * pLiveCollection;

	if (*ppCollection)
		pLiveCollection = (CWMILiveObjectCollection *) *ppCollection;
	else
		pLiveCollection = new CWMILiveObjectCollection(m_pServices);

	if (pLiveCollection == NULL)
		return E_FAIL; // TBD - memory failure

	CString strProperties(szProperties);
	StringReplace(strProperties, _T("MSIAdvanced"), _T(""));

	HRESULT hr = pLiveCollection->Create(szClass, strProperties);
	if (SUCCEEDED(hr))
		*ppCollection = (CWMIObjectCollection *) pLiveCollection;
	else
		delete pLiveCollection;
	return hr;
}

//-----------------------------------------------------------------------------
// WQLQuery creates a CWMILiveObjectCollection based on the query.
//-----------------------------------------------------------------------------

HRESULT CWMILiveHelper::WQLQuery(LPCTSTR szQuery, CWMIObjectCollection ** ppCollection)
{
	ASSERT(m_pServices);
	if (m_pServices == NULL)
		return E_FAIL;

	ASSERT(ppCollection);
	if (ppCollection == NULL)
		return E_INVALIDARG;

	CWMILiveObjectCollection * pLiveCollection;

	if (*ppCollection)
		pLiveCollection = (CWMILiveObjectCollection *) *ppCollection;
	else
		pLiveCollection = new CWMILiveObjectCollection(m_pServices);

	if (pLiveCollection == NULL)
		return E_FAIL; // TBD - memory failure

	HRESULT hr = pLiveCollection->CreateWQL(szQuery);
	if (SUCCEEDED(hr))
		*ppCollection = (CWMIObjectCollection *) pLiveCollection;
	else
		delete pLiveCollection;
	return hr;
}

//-----------------------------------------------------------------------------
// Get the named object.
//-----------------------------------------------------------------------------

HRESULT CWMILiveHelper::GetObject(LPCTSTR szObjectPath, CWMIObject ** ppObject)
{
	ASSERT(ppObject);
	if (ppObject == NULL)
		return E_INVALIDARG;

	CString strPath(szObjectPath);

	if (strPath.Find(_T(":")) == -1)
	{
		// The path passed in is not a full object path if it doesn't have a colon.

		CString strMachine(_T("."));
		CString strNamespace(_T("cimv2"));

		if (!m_strMachine.IsEmpty())
			strMachine = m_strMachine;

		if (!m_strNamespace.IsEmpty())
			strNamespace = m_strNamespace;

		strPath = CString(_T("\\\\")) + strMachine + CString(_T("\\root\\")) + strNamespace + CString(_T(":")) + strPath;
	}

	HRESULT hr = E_FAIL;
	CWMILiveObject * pObject = NULL;
	if (m_pServices)
	{
		pObject = new CWMILiveObject;
		if (pObject)
			hr = pObject->Create(m_pServices, strPath);
	}

	if (SUCCEEDED(hr))
		*ppObject = pObject;
	else if (pObject)
		delete pObject;

	return hr;
}

//-----------------------------------------------------------------------------
// Create this WMI helper based on the machine and namespace.
//-----------------------------------------------------------------------------

HRESULT CWMILiveHelper::Create(LPCTSTR szMachine, LPCTSTR szNamespace)
{
	if (m_pServices)
		m_pServices->Release();

	m_strMachine = _T(".");
	if (szMachine && *szMachine)
	{
		m_strMachine = szMachine;
		if (m_strMachine.Left(2) == _T("\\\\"))
			m_strMachine = m_strMachine.Right(m_strMachine.GetLength() - 2);
	}

	m_strNamespace = _T("cimv2");
	if (szNamespace && *szNamespace)
		m_strNamespace = szNamespace;

	// We get a WBEM interface pointer by first creating a WBEM locator interface, then
	// using it to connect to a server to get an IWbemServices pointer.

	CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0);
	IWbemServices * pService = NULL;
	IWbemLocator * pIWbemLocator = NULL;

	HRESULT hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pIWbemLocator);
	if (SUCCEEDED(hr))
	{
		if (pIWbemLocator)
		{
			CString strWMINamespace;
			strWMINamespace.Format(_T("\\\\%s\\root\\%s"), m_strMachine, m_strNamespace);
			BSTR pNamespace = strWMINamespace.AllocSysString();
			if (pNamespace)
			{
				hr = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL, &pService);
				SysFreeString(pNamespace);
			}
			pIWbemLocator->Release();
			pIWbemLocator = NULL;
		}
	}

	if (pService && SUCCEEDED(hr))
		ChangeWBEMSecurity(pService);

	m_hrError	= hr;
	m_pServices = pService;

	return hr;
}

//-----------------------------------------------------------------------------
// Get a new WMI helper for the specified namespace.
//
// TBD - this should do something.
//-----------------------------------------------------------------------------

HRESULT CWMILiveHelper::NewNamespace(LPCTSTR szNamespace, CWMIHelper **ppNewHelper)
{
	return E_FAIL;
}

//-----------------------------------------------------------------------------
// Get the current namespace of this WMI helper.
//
// TBD - this should do something.
//-----------------------------------------------------------------------------

HRESULT CWMILiveHelper::GetNamespace(CString * pstrNamespace)
{
	return E_FAIL;
}

//-----------------------------------------------------------------------------
// Check to see if there is an associated value in a value map for this
// combination of class, property and value. This is lifted from the
// version 5.0 code.
//-----------------------------------------------------------------------------

CMapStringToString g_mapValueMapV7;

HRESULT CWMILiveHelper::CheckValueMap(IWbemServices * pServices, const CString& strClass, const CString& strProperty, const CString& strVal, CString &strResult)
{
	IWbemClassObject *	pWBEMClassObject = NULL;
    HRESULT				hrMap = S_OK, hr = S_OK;
    VARIANT				vArray, vMapArray;
	IWbemQualifierSet *	qual = NULL;

	if (!pServices)
		return E_FAIL;

	// Check the cache of saved values.

	CString strLookup = strClass + CString(_T(".")) + strProperty + CString(_T(":")) + strVal;
	if (g_mapValueMapV7.Lookup(strLookup, strResult))
		return S_OK;

	// Get the class object (not instance) for this class.

	CString strFullClass(_T("\\\\.\\root\\cimv2:"));
	strFullClass += strClass;
	BSTR bstrObjectPath = strFullClass.AllocSysString();
	hr = pServices->GetObject(bstrObjectPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pWBEMClassObject, NULL);
	::SysFreeString(bstrObjectPath);

	if (FAILED(hr))
		return hr;

	// Get the qualifiers from the class object.

	BSTR bstrProperty = strProperty.AllocSysString();
    hr = pWBEMClassObject->GetPropertyQualifierSet(bstrProperty, &qual);
	::SysFreeString(bstrProperty);

	if (SUCCEEDED(hr) && qual)
	{
		// Get the ValueMap and Value arrays.

		hrMap = qual->Get(L"ValueMap", 0, &vMapArray, NULL);
		hr = qual->Get(L"Values", 0, &vArray, NULL);

		if (SUCCEEDED(hr) && vArray.vt == (VT_BSTR | VT_ARRAY))
		{
			// Get the property value we're mapping.

			long index;
			if (SUCCEEDED(hrMap))
			{
				SAFEARRAY * pma = V_ARRAY(&vMapArray);
				long lLowerBound = 0, lUpperBound = 0 ;

				SafeArrayGetLBound(pma, 1, &lLowerBound);
				SafeArrayGetUBound(pma, 1, &lUpperBound);
				BSTR vMap;

				for (long x = lLowerBound; x <= lUpperBound; x++)
				{
					SafeArrayGetElement(pma, &x, &vMap);

					CString strMapVal(vMap);
					if (0 == strVal.CompareNoCase(strMapVal))
					{
						index = x;
						break; // found it
					}
				} 
			}
			else
			{
				// Shouldn't hit this case - if mof is well formed
				// means there is no value map where we are expecting one.
				// If the strVal we are looking for is a number, treat it
				// as an index for the Values array. If it's a string, 
				// then this is an error.

				TCHAR * szTest = NULL;
				index = _tcstol((LPCTSTR)strVal, &szTest, 10);

				if (szTest == NULL || (index == 0 && *szTest != 0) || strVal.IsEmpty())
					hr = E_FAIL;
			}

			// Lookup the string.

			if (SUCCEEDED(hr))
			{
				SAFEARRAY * psa = V_ARRAY(&vArray);
				long ix[1] = {index};
				BSTR str2;

				hr = SafeArrayGetElement(psa, ix, &str2);
				if (SUCCEEDED(hr))
				{
					strResult = str2;
					SysFreeString(str2);
					hr = S_OK;
				}
				else
				{
					hr = WBEM_E_VALUE_OUT_OF_RANGE;
				}
			}
		}

		qual->Release();
	}

	if (SUCCEEDED(hr))
		g_mapValueMapV7.SetAt(strLookup, strResult);

	return hr;
}

//-----------------------------------------------------------------------------
// This function supplies a string for a given MSInfo specific HRESULT.
//-----------------------------------------------------------------------------

CString gstrNoValue, gstrNoProperty;

CString GetMSInfoHRESULTString(HRESULT hr)
{
	switch (hr)
	{
	case E_MSINFO_NOVALUE:
		if (gstrNoValue.IsEmpty())
		{
			::AfxSetResourceHandle(_Module.GetResourceInstance());
			gstrNoValue.LoadString(IDS_ERROR_NOVALUE);
		}

		return (gstrNoValue);

	case E_MSINFO_NOPROPERTY:
		if (gstrNoProperty.IsEmpty())
		{
			::AfxSetResourceHandle(_Module.GetResourceInstance());
			gstrNoProperty.LoadString(IDS_ERROR_NOPROPERTY);
		}

		return (gstrNoProperty);

	default:
		return (CString(_T("")));
	}
}

//-----------------------------------------------------------------------------
// This is a wrapper for the GetObject() method in IWbemServices. This is
// called when there is a certain set of properties to get.
//
// Turns out this doesn't speed us up appreciably on our WMI uses.
//-----------------------------------------------------------------------------

/*
HRESULT CWMILiveObject::PartialInstanceGetObject(IWbemServices * pServices, BSTR bstrPath, IWbemClassObject ** ppObject, LPCTSTR szProperties)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ((pServices != NULL) && (bstrPath != NULL) && (ppObject != NULL))
    {
		IWbemContext * pWbemContext = NULL;
		hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void**) &pWbemContext);

		CStringArray csaProperties;
		CString strProperties(szProperties), strProperty;
		int index = 0;
		while (!strProperties.IsEmpty())
		{
			strProperty = strProperties.SpanExcluding(_T(", "));
			strProperties = strProperties.Mid(strProperty.GetLength());
			strProperties.TrimLeft(_T(", "));
			csaProperties.SetAtGrow(index++, strProperty);
		}

        if (pWbemContext != NULL)
        {
            variant_t vValue;
            V_VT(&vValue) = VT_BOOL;
            V_BOOL(&vValue) = VARIANT_TRUE;

            // First set the value that says we are using Get extensions
            if ((SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue))) &&
                (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_CLIENT_REQUEST", 0L, &vValue))) )
            {
                // Delete any unneeded properties
                pWbemContext->DeleteValue(L"__GET_EXT_KEYS_ONLY", 0L);

                // Now build the array of properties
                SAFEARRAYBOUND rgsabound [ 1 ] ;

                rgsabound[0].cElements = csaProperties.GetSize() ;
                rgsabound[0].lLbound = 0 ;
                V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
                if ( V_ARRAY(&vValue) )
                {
                    V_VT(&vValue) = VT_BSTR | VT_ARRAY;

                    for (long x=0; x < csaProperties.GetSize(); x++)
                    {
                        bstr_t bstrProp = csaProperties[x];
                        
                        SafeArrayPutElement(
                            V_ARRAY(&vValue), 
                            &x, 
                            (LPVOID) (BSTR) bstrProp);
                    }

                    // Put the array into the context object
                    if (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_PROPERTIES", 0L, &vValue)))
                    {
						hr = pServices->GetObject(bstrPath, 0, pWbemContext, ppObject, 0);

                        vValue.Clear();
                        V_VT(&vValue) = VT_BOOL;
                        V_BOOL(&vValue) = VARIANT_FALSE;
                        pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue);
                    }
                }
                else
                {
                }
            }
        }
        else
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\wmihelper.cpp ===
//=============================================================================
// Contains the functions for the base WMI helper class.
//=============================================================================

#include "stdafx.h"
#include "category.h"
#include "wmiabstraction.h"
#include "resource.h"
#include "dataset.h"

//-----------------------------------------------------------------------------
// Loads the string identified by uiResourceID, and parses it into the columns
// in aColValues. The string should be of the form "www|xxx|yyy|zzz" - this
// will be parsed into two rows: www,xxx and yyy,zzz. Values will be inserted
// into the aColValues array of pointer lists of CMSIValue structs.
//-----------------------------------------------------------------------------

void CWMIHelper::LoadColumnsFromResource(UINT uiResourceID, CPtrList * aColValues, int iColCount)
{
	AfxSetResourceHandle(_Module.GetResourceInstance());

	CString strResource;
	if (strResource.LoadString(uiResourceID))
	{
		CMSIValue * pValue;
		int			iCol = 0;

		while (!strResource.IsEmpty())
		{
			pValue = new CMSIValue(strResource.SpanExcluding(_T("|\n")), 0);
			if (pValue)
			{
				ASSERT(!pValue->m_strValue.IsEmpty());
				strResource = strResource.Right(strResource.GetLength() - pValue->m_strValue.GetLength() - 1);

				aColValues[iCol].AddTail((void *) pValue);
				iCol += 1;
				if (iCol == iColCount)
					iCol = 0;
			}
			else
				strResource.Empty();
		}
	}
}

//-----------------------------------------------------------------------------
// Same as the previous, but uses a string instead of a resource ID.
//-----------------------------------------------------------------------------

void CWMIHelper::LoadColumnsFromString(LPCTSTR szColumns, CPtrList * aColValues, int iColCount)
{
	if (szColumns != NULL)
	{
		CString		strColumns(szColumns);
		CMSIValue * pValue;
		int			iCol = 0;

		while (!strColumns.IsEmpty())
		{
			pValue = new CMSIValue(strColumns.SpanExcluding(_T("|\n")), 0);
			if (pValue)
			{
				ASSERT(!pValue->m_strValue.IsEmpty());
				strColumns = strColumns.Right(strColumns.GetLength() - pValue->m_strValue.GetLength() - 1);

				aColValues[iCol].AddTail((void *) pValue);
				iCol += 1;
				if (iCol == iColCount)
					iCol = 0;
			}
			else
				strColumns.Empty();
		}
	}
}

//-----------------------------------------------------------------------------
// Return the first object of the specified class.
//-----------------------------------------------------------------------------

CWMIObject * CWMIHelper::GetSingleObject(LPCTSTR szClass, LPCTSTR szProperties)
{
	ASSERT(szClass);

	CWMIObjectCollection * pCollection = NULL;
	CWMIObject * pObject = NULL;

	if (SUCCEEDED(Enumerate(szClass, &pCollection, szProperties)))
	{
		if (FAILED(pCollection->GetNext(&pObject)))
			pObject = NULL;
		delete pCollection;
	}

	return pObject;
}

//-----------------------------------------------------------------------------
// Delimit the specified number.
//-----------------------------------------------------------------------------

CString DelimitNumber(double dblValue, int iDecimalDigits = 0)
{
	NUMBERFMT fmt;
	TCHAR szResult[MAX_PATH] = _T("");
	TCHAR szDelimiter[4] = _T(",");
	TCHAR szDecimal[4] = _T(".");

	GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szDelimiter, 4);
	GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDecimal, 4);

	memset(&fmt, 0, sizeof(NUMBERFMT));
	fmt.Grouping = 3;
	fmt.lpDecimalSep = (iDecimalDigits) ? szDecimal : _T("");
	fmt.NumDigits = iDecimalDigits;
	fmt.lpThousandSep = szDelimiter;

	CString strValue;
	CString strFormatString;
	strFormatString.Format(_T("%%.%df"), iDecimalDigits);
	strValue.Format(strFormatString, dblValue);

	// GetNumberFormat requires the decimal to be a '.', while CString::Format
	// uses the locale value. So we need to go back and replace it.

	StringReplace(strValue, szDecimal, _T("."));
	GetNumberFormat(LOCALE_USER_DEFAULT, 0, strValue, &fmt, szResult, MAX_PATH);

	return CString(szResult);
}

//-----------------------------------------------------------------------------
// Return the requested value from the object, as a string and/or a DWORD.
// Use the chFormat flag to determine how to format the results.
//
// The return result is the actual format character to use for displaying the
// results in a string.
//
// TBD - do something better with the HRESULTs returned.
//-----------------------------------------------------------------------------

CString gstrYes;	// global string "yes" (will be localized)
CString gstrNo;		// global string "no" (will be localized)
CString gstrBytes;	// global string "bytes" (will be localized)
CString gstrKB;		// global string "KB" (will be localized)
CString gstrMB;		// global string "MB" (will be localized)
CString gstrGB;		// global string "GB" (will be localized)
CString gstrTB;		// global string "TB" (will be localized)

HRESULT CWMIObject::GetInterpretedValue(LPCTSTR szProperty, LPCTSTR szFormat, TCHAR chFormat, CString * pstrValue, DWORD * pdwValue)
{
	HRESULT hr = E_FAIL;
	CString strValue(_T(""));
	DWORD	dwValue = 0;

	::AfxSetResourceHandle(_Module.GetResourceInstance());

	switch (chFormat)
	{
	case _T('s'):
	case _T('u'):
	case _T('l'):
		{
			hr = GetValueString(szProperty, &strValue);
			if (SUCCEEDED(hr))
			{
				if (chFormat == _T('u'))
					strValue.MakeUpper();
				else if (chFormat == _T('l'))
					strValue.MakeLower();
				strValue.TrimRight();
			}
		}
		break;

	case _T('v'):
		{
			hr = GetValueValueMap(szProperty, &strValue);
		}
		break;

	case _T('d'):
	case _T('x'):
		{
			hr = GetValueDWORD(szProperty, &dwValue);
			if (SUCCEEDED(hr))
			{
				strValue.Format(szFormat, dwValue);
			}
		}
		break;

	case _T('f'):
		{
			double dblValue;
			hr = GetValueDoubleFloat(szProperty, &dblValue);
			if (SUCCEEDED(hr))
			{
				strValue.Format(szFormat, dblValue);
				dwValue = (DWORD) dblValue;
			}
		}
		break;

	case _T('b'):
		{
			if (gstrYes.IsEmpty())
				gstrYes.LoadString(IDS_YES);

			if (gstrNo.IsEmpty())
				gstrNo.LoadString(IDS_NO);

			hr = GetValueDWORD(szProperty, &dwValue);
			if (SUCCEEDED(hr))
			{
				strValue = (dwValue) ? gstrYes : gstrNo;
			}
		}
		break;

	case _T('w'):
	case _T('y'):
	case _T('z'):
		{
			if (gstrBytes.IsEmpty())
				gstrBytes.LoadString(IDS_BYTES);

			if (gstrKB.IsEmpty())
				gstrKB.LoadString(IDS_KB);

			if (gstrMB.IsEmpty())
				gstrMB.LoadString(IDS_MB);

			if (gstrGB.IsEmpty())
				gstrGB.LoadString(IDS_GB);

			if (gstrTB.IsEmpty())
				gstrTB.LoadString(IDS_TB);

			double dblValue;
			hr = GetValueDoubleFloat(szProperty, &dblValue);
			if (SUCCEEDED(hr))
			{
				CString strFormattedNumber;

				dwValue = (DWORD) dblValue;	// TBD potential loss of digits
				if (chFormat == _T('w'))
					strFormattedNumber = DelimitNumber(dblValue);
				else
				{
					int iDivTimes = (chFormat == _T('y')) ? 1 : 0;
					double dblWorking(dblValue);
					for (; iDivTimes <= 4 && dblWorking >= 1024.0; iDivTimes++)
						dblWorking /= 1024.0;

					strFormattedNumber = DelimitNumber(dblWorking, (iDivTimes) ? 2 : 0);
					switch (iDivTimes)
					{
					case 0:
						strFormattedNumber += _T(" ") + gstrBytes;
						break;

					case 1:
						strFormattedNumber += _T(" ") + gstrKB;
						break;

					case 2:
						strFormattedNumber += _T(" ") + gstrMB;
						break;

					case 3:
						strFormattedNumber += _T(" ") + gstrGB;
						break;

					case 4:
						strFormattedNumber += _T(" ") + gstrTB;
						break;
					}

					if (chFormat == _T('z') && iDivTimes)
						strFormattedNumber += _T(" (") + DelimitNumber(dblValue) + _T(" ") + gstrBytes + _T(")");
				}

				strValue = strFormattedNumber;
			}
		}
		break;

	case _T('t'):
		{
			COleDateTime oledatetime;
			SYSTEMTIME systimeValue;

			hr = GetValueTime(szProperty, &systimeValue);
			oledatetime = (COleDateTime) systimeValue;
			if (SUCCEEDED(hr))
			{
				dwValue = (DWORD)(DATE)oledatetime;

				// Try to get the date in the localized format.

				strValue.Empty();
				TCHAR szBuffer[MAX_PATH];	// seems plenty big
				if (::GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systimeValue, NULL, szBuffer, MAX_PATH))
				{
					strValue = szBuffer;
					if (::GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &systimeValue, NULL, szBuffer, MAX_PATH))
						strValue += CString(_T(" ")) + CString(szBuffer);
				}

				// Fall back on our old (partially incorrect) method.

				if (strValue.IsEmpty())
					strValue = oledatetime.Format(0, LOCALE_USER_DEFAULT);
			}
		}
		break;

	case _T('c'):
		{
			COleDateTime oledatetime;
			SYSTEMTIME systimeValue;

			hr = GetValueTime(szProperty, &systimeValue);
			oledatetime = (COleDateTime) systimeValue;
			if (SUCCEEDED(hr))
			{
				dwValue = (DWORD)(DATE)oledatetime;

				// Try to get the date in the localized format.

				strValue.Empty();
				TCHAR szBuffer[MAX_PATH];	// seems plenty big
				if (::GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systimeValue, NULL, szBuffer, MAX_PATH))
					strValue = szBuffer;

				// Fall back on our old (partially incorrect) method.

				if (strValue.IsEmpty())
					strValue = oledatetime.Format(0, LOCALE_USER_DEFAULT);
			}
		}
		break;

	case _T('a'):
		{
			hr = GetValueString(szProperty, &strValue);
			if (SUCCEEDED(hr))
			{
				// strValue contains a string locale ID (like "0409"). Convert it into
				// and actual LCID.

				LCID lcid = (LCID) _tcstoul(strValue, NULL, 16);
				TCHAR szCountry[MAX_PATH];
				if (GetLocaleInfo(lcid, LOCALE_SCOUNTRY, szCountry, MAX_PATH))
					strValue = szCountry;
			}
		}
		break;

	default:
		break;
		// Just continue with the loop.
	}

	if (SUCCEEDED(hr))
	{
		if (pstrValue)
		{
			if (chFormat == _T('d') || chFormat == _T('x') || chFormat == _T('f'))
				*pstrValue = strValue;
			else
			{
				CString strFormat(szFormat);

				int iPercent = strFormat.Find(_T("%"));
				int iLength = strFormat.GetLength();
				if (iPercent != -1)
				{
					while (iPercent < iLength && strFormat[iPercent] != chFormat)
						iPercent++;

					if (iPercent < iLength)
					{
						strFormat.SetAt(iPercent, _T('s'));
						pstrValue->Format(strFormat, strValue);
					}
				}
			}
		}

		if (pdwValue)
			*pdwValue = dwValue;
	}
	else
	{
		if (pstrValue)
			*pstrValue = GetMSInfoHRESULTString(hr);
		if (pdwValue)
			*pdwValue = 0;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// These functions implement features found in the new versions of MFC (new
// than what we're currently building with).
//-----------------------------------------------------------------------------

int StringFind(CString & str, LPCTSTR szLookFor, int iStartFrom)
{
	CString strWorking(str.Right(str.GetLength() - iStartFrom));
	int		iFind = strWorking.Find(szLookFor);

	if (iFind != -1)
		iFind += iStartFrom;

	return iFind;
}

//-----------------------------------------------------------------------------
// Process the specified string. It will contain a format string with one
// or more flags (flags specific to MSInfo). We need to replace is flag with
// a properly formatted value from pObject, determined by the next property
// in pstrProperties.
//-----------------------------------------------------------------------------

BOOL ProcessColumnString(CMSIValue * pValue, CWMIObject * pObject, CString * pstrProperties)
{
	CString	strPropertyValue, strProperty, strFragment;
	CString	strResults(_T(""));
	CString strFormatString(pValue->m_strValue);
	DWORD	dwResults;
	BOOL	fAdvanced = FALSE;
	BOOL	fAllPiecesFailed = TRUE;
	HRESULT hr = S_OK;

	while (!strFormatString.IsEmpty() && SUCCEEDED(hr))
	{
		// Get the next fragment of the format string with a single format specifier.

		int iPercent = strFormatString.Find(_T("%"));
		if (iPercent == -1)
		{
			strResults += strFormatString;
			break;
		}

		int iSecondPercent = StringFind(strFormatString, _T("%"), iPercent + 1);
		if (iSecondPercent == -1)
		{
			strFragment = strFormatString;
			strFormatString.Empty();
		}
		else
		{
			strFragment = strFormatString.Left(iSecondPercent);
			strFormatString = strFormatString.Right(strFormatString.GetLength() - iSecondPercent);
		}

		// Find the format character for this fragment.

		TCHAR chFormat;
		do
			chFormat = strFragment[++iPercent];
		while (!_istalpha(chFormat));

		// Get the property name for this fragment.

		int iComma = pstrProperties->Find(_T(","));
		if (iComma != -1)
		{
			strProperty = pstrProperties->Left(iComma);
			*pstrProperties = pstrProperties->Right(pstrProperties->GetLength() - iComma - 1);
		}
		else
		{
			strProperty = *pstrProperties;
			pstrProperties->Empty();
		}
		strProperty.TrimLeft();
		strProperty.TrimRight();

		if (strProperty.Left(11) == CString(_T("MSIAdvanced")))
		{
			fAdvanced = TRUE;
			strProperty = strProperty.Right(strProperty.GetLength() - 11);
		}

		// Get the actual value the property and add it to the string.

		hr = pObject->GetInterpretedValue(strProperty, strFragment, chFormat, &strPropertyValue, &dwResults);
		if (SUCCEEDED(hr))
		{
			fAllPiecesFailed = FALSE;
			strResults += strPropertyValue;
		}
		else
			strResults += GetMSInfoHRESULTString(hr);
	}

	if (!fAllPiecesFailed)
	{
		pValue->m_strValue = strResults;
		pValue->m_dwValue = dwResults;
	}
	else
	{
		pValue->m_strValue = GetMSInfoHRESULTString(hr);
		pValue->m_dwValue = 0;
	}
	pValue->m_fAdvanced = fAdvanced;

	return TRUE;
}

//-----------------------------------------------------------------------------
// A general purpose function to add the contents of object pObject to the
// columns, based on the properties in szProperties and the string referenced
// by uiColumns.
//-----------------------------------------------------------------------------

void CWMIHelper::AddObjectToOutput(CPtrList * aColValues, int iColCount, CWMIObject * pObject, LPCTSTR szProperties, UINT uiColumns)
{
	POSITION aPositions[32];	// should never be more than 32 columns
	ASSERT(iColCount < 32);

	CString strProperties(szProperties);

	// Save the starting position for the new entries we're adding from the resoure.

	int iColListStart = (int)aColValues[0].GetCount();
	LoadColumnsFromResource(uiColumns, aColValues, iColCount);

	// Look through each of the new cells. For each string in a cell, if we
	// find a formatting flag (like %s), get the next property out of the
	// property list and format the string.

	for (int iCol = 0; iCol < iColCount; iCol++)
		aPositions[iCol] = aColValues[iCol].FindIndex(iColListStart);

	while (aPositions[0])
		for (iCol = 0; iCol < iColCount; iCol++)
		{
			ASSERT(aPositions[iCol]);
			if (aPositions[iCol])
			{
				CMSIValue * pValue = (CMSIValue *) aColValues[iCol].GetNext(aPositions[iCol]);
				if (pValue && pValue->m_strValue.Find(_T("%")) != -1)
					ProcessColumnString(pValue, pObject, &strProperties);
			}
		}
}

//-----------------------------------------------------------------------------
// Same as previous, but takes a string instead of a resource ID.
//-----------------------------------------------------------------------------

void CWMIHelper::AddObjectToOutput(CPtrList * aColValues, int iColCount, CWMIObject * pObject, LPCTSTR szProperties, LPCTSTR szColumns)
{
	POSITION aPositions[32];	// should never be more than 32 columns
	ASSERT(iColCount < 32);

	CString strProperties(szProperties);

	// Save the starting position for the new entries we're adding from the resoure.

	int iColListStart = (int)aColValues[0].GetCount();
	LoadColumnsFromString(szColumns, aColValues, iColCount);

	// Look through each of the new cells. For each string in a cell, if we
	// find a formatting flag (like %s), get the next property out of the
	// property list and format the string.

	for (int iCol = 0; iCol < iColCount; iCol++)
		aPositions[iCol] = aColValues[iCol].FindIndex(iColListStart);

	while (aPositions[0])
		for (iCol = 0; iCol < iColCount; iCol++)
		{
			ASSERT(aPositions[iCol]);
			if (aPositions[iCol])
			{
				CMSIValue * pValue = (CMSIValue *) aColValues[iCol].GetNext(aPositions[iCol]);
				if (pValue && pValue->m_strValue.Find(_T("%")) != -1)
					ProcessColumnString(pValue, pObject, &strProperties);
			}
		}
}

void CWMIHelper::AppendBlankLine(CPtrList * aColValues, int iColCount, BOOL fOnlyIfNotEmpty)
{
	if (aColValues[0].GetCount() || fOnlyIfNotEmpty == FALSE)
		for (int iCol = 0; iCol < iColCount; iCol++)
			AppendCell(aColValues[iCol], _T(""), 0);
}

void CWMIHelper::AppendCell(CPtrList & listColumns, const CString & strValue, DWORD dwValue, BOOL fAdvanced)
{
	CMSIValue * pValue = new CMSIValue(strValue, dwValue, fAdvanced);
	if (pValue)
		listColumns.AddTail((void *) pValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\wmilive.h ===
//=============================================================================
// This file defines the classes for live WMI data access (which are subclassed
// from the abstract base classes in wmiabstraction.h).
//=============================================================================

#pragma once
#include "wmiabstraction.h"
#include "wbemcli.h"

// Set a timeout value for WMI queries of 20 second. No single WMI operation
// should take longer - if it does, we should assume it isn't coming back.

#define TIMEOUT 20000

//-----------------------------------------------------------------------------
// The CWMILiveObject implements a CWMIObject using a real WMI object. It
// can be created with either a IWbemClassObject pointer, or a services
// pointer and a path.
//-----------------------------------------------------------------------------

class CWMILiveObject : public CWMIObject
{
public:
	CWMILiveObject();
	virtual ~CWMILiveObject();

	// Functions inherited from the base class:

	HRESULT GetValue(LPCTSTR szProperty, VARIANT * pvarValue);
	HRESULT GetValueString(LPCTSTR szProperty, CString * pstrValue);
	HRESULT GetValueDWORD(LPCTSTR szProperty, DWORD * pdwValue);
	HRESULT GetValueTime(LPCTSTR szProperty, SYSTEMTIME * psystimeValue);
	HRESULT GetValueDoubleFloat(LPCTSTR szProperty, double * pdblValue);
	HRESULT GetValueValueMap(LPCTSTR szProperty, CString * pstrValue);

	// Functions specific to this subclass:
	//
	// Note - Create with an object pointer will addref() the pointer:

	HRESULT Create(IWbemServices * pServices, IWbemClassObject * pObject);
	HRESULT Create(IWbemServices * pServices, LPCTSTR szObjectPath);

private:
	IWbemClassObject *	m_pObject;
	IWbemServices *		m_pServices;
};

//-----------------------------------------------------------------------------
// The CWMILiveObjectCollection implements a collection of live WMI objects
// using a WMI enumerator. This collection can be created from an existing
// IEnumWbemClassObject pointer, from a WQL statement or from a WMI class name.
//-----------------------------------------------------------------------------

class CWMILiveObjectCollection : public CWMIObjectCollection
{
public:
	CWMILiveObjectCollection(IWbemServices * pServices);
	virtual ~CWMILiveObjectCollection();

	// Functions inherited from the base class:

	HRESULT Create(LPCTSTR szClass, LPCTSTR szProperties = NULL);
	HRESULT GetNext(CWMIObject ** ppObject);

	// Functions specific to this subclass:
	//
	// Note - Create with an enum pointer will addref() the pointer:

public:
	HRESULT Create(IEnumWbemClassObject * pEnum);
	HRESULT CreateWQL(LPCTSTR szQuery);

private:
	IEnumWbemClassObject *	m_pEnum;
	IWbemServices *			m_pServices;
};

//-----------------------------------------------------------------------------
// The CWMILiveHelper function encapsulates a WMI connection (which might be to
// XML).
//-----------------------------------------------------------------------------

class CWMILiveHelper : public CWMIHelper
{
public:
	CWMILiveHelper();
	~CWMILiveHelper();

	HRESULT Enumerate(LPCTSTR szClass, CWMIObjectCollection ** ppCollection, LPCTSTR szProperties = NULL);
	HRESULT WQLQuery(LPCTSTR szQuery, CWMIObjectCollection ** ppCollection);
	HRESULT NewNamespace(LPCTSTR szNamespace, CWMIHelper **ppNewHelper);
	HRESULT GetNamespace(CString * pstrNamespace);
	HRESULT GetObject(LPCTSTR szObjectPath, CWMIObject ** ppObject);

public:
	// Functions specific to this subclass:

	HRESULT Create(LPCTSTR szMachine = NULL, LPCTSTR szNamespace = NULL);

	// Check the value map for a given value. This is static since the object
	// must be able to call it and there is no back pointer to this class.

	static HRESULT CheckValueMap(IWbemServices * pServices, const CString& strClass, const CString& strProperty, const CString& strVal, CString &strResult);

	// These functions are specific to version 5.0 refreshes.

	BOOL Version5ResetClass(const CString & strClass, GATH_FIELD * pConstraints);
	BOOL Version5EnumClass(const CString & strClass, GATH_FIELD * pConstraints);

	BOOL Version5QueryValueDWORD(const CString & strClass, const CString & strProperty, DWORD & dwResult, CString & strMessage);
	BOOL Version5QueryValueDateTime(const CString & strClass, const CString & strProperty, COleDateTime & datetime, CString & strMessage);
	BOOL Version5QueryValueDoubleFloat(const CString & strClass, const CString & strProperty, double & dblResult, CString & strMessage);
	BOOL Version5QueryValue(const CString & strClass, const CString & strProperty, CString & strResult);
	
	CMSIEnumerator * Version5GetEnumObject(const CString & strClass, const GATH_FIELD * pConstraints = NULL);
	CMSIObject *	 Version5GetObject(const CString & strClass, const GATH_FIELD * pConstraints, CString * pstrLabel = NULL);
	void			 Version5RemoveObject(const CString & strClass);
	IWbemServices *  Version5GetWBEMService(CString * pstrNamespace = NULL);
	BOOL			 Version5EvaluateFilter(IWbemClassObject * pObject, const GATH_FIELD * pConstraints);
	void			 Version5EvaluateJoin(const CString & strClass, IWbemClassObject * pObject, const GATH_FIELD * pConstraints);
	BOOL			 Version5IsDependencyJoin(const GATH_FIELD * pConstraints);
	void			 Version5EvaluateDependencyJoin(IWbemClassObject * pObject);
	void			 Version5RemoveEnumObject(const CString & strClass);
	void			 Version5ClearCache();
	HRESULT			 Version5CheckValueMap(const CString& strClass, const CString& strProperty, const CString& strVal, CString &strResult);

private:
	HRESULT			m_hrError;
	CString			m_strMachine;
	CString			m_strNamespace;
	IWbemServices *	m_pServices;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\xmlobject.cpp ===
// XMLObject.cpp: implementation of the CXMLObject class.
//
//////////////////////////////////////////////////////////////////////
//hcp://system/sysinfo/msinfo.htm C:\WINDOWS\PCHEALTH\HELPCTR\System\SYSINFO\msinfo.htm 
#include "stdafx.h"
#include "resource.h"
#include "XMLObject.h"
#include "msxml.h"
#include "HistoryParser.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLObject::CXMLObject()
{
	
}

CXMLObject::~CXMLObject()
{

}

//---------------------------------------------------------------------------
//  Creates a new CXMLObject, which basically wraps the INSTANCE xml node pased in as pNode
//  pNode will have been selected with a query something like
//  Snapshot/CIM/DECLARATION/DECLGROUP.WITHPATH/VALUE.OBJECTWITHPATH/INSTANCE[@CLASSNAME $ieq$ ";	
//
//---------------------------------------------------------------------------

HRESULT CXMLObject::Create(CComPtr<IXMLDOMNode> pNode, CString strClassName)
{
	
	ASSERT(pNode != NULL && "NULL smart pointer passed in");
	m_pNode = pNode;
	m_strClassName = strClassName;
	return S_OK;
}

//---------------------------------------------------------------------------
//  Finds a specific property node in m_pNode
//---------------------------------------------------------------------------

HRESULT CXMLObject::GetPROPERTYNode(LPCTSTR szProperty,CComPtr<IXMLDOMNode>& pPropNode)
{
	
	CString strSubQuery(_T(""));
	HRESULT hr;
	if (FALSE)
	{
	}
	else
	{
		strSubQuery = _T("PROPERTY[@NAME $ieq$");
		strSubQuery += _T('\"');
		strSubQuery += szProperty;
		strSubQuery += _T('\"');
		strSubQuery += _T("]");
	}
	CComBSTR bstrSubQuery(strSubQuery);
	hr = S_FALSE;
	hr = this->m_pNode->selectSingleNode(bstrSubQuery,&pPropNode);
	if (FAILED(hr) || !pPropNode)
	{
		return E_FAIL;
	}
	return S_OK;

}



//---------------------------------------------------------------------------
//  Tries to find the value specified by szProperty in associated INSTANCE node
// (m_pNode)
//---------------------------------------------------------------------------
HRESULT CXMLObject::GetValue(LPCTSTR szProperty, VARIANT * pvarValue)
{
	CComBSTR bstrAttributeText;
	CComPtr<IXMLDOMNode> pSubNode;
	HRESULT hr = GetPROPERTYNode(szProperty,pSubNode);
	if (FAILED(hr))
	{
		pvarValue->vt = VT_EMPTY;
		return E_MSINFO_NOVALUE;
	}
	
	ASSERT(pSubNode != NULL);
	CComVariant varAttr;
	varAttr.vt = VT_BSTR;
	hr = pSubNode->get_text(&varAttr.bstrVal);
	pvarValue->vt = VT_BSTR;
	pvarValue->bstrVal = varAttr.bstrVal;
	return S_OK;
}

//---------------------------------------------------------------------------
//  Finds value specified by szProperty, returns it as string
//---------------------------------------------------------------------------
HRESULT CXMLObject::GetValueString(LPCTSTR szProperty, CString * pstrValue)
{
	try
	{
		if (!pstrValue)
		{
			ASSERT(0 && "NULL POINTER PASSED IN");
			return E_FAIL;
		}	
		HRESULT hr;
		CComVariant ovValue;
		hr = this->GetValue(szProperty,&ovValue);
		//some properties have to be interpolated if not found...
		if (ovValue.vt == VT_EMPTY)
		{
			
			
			if (_tcsicmp(szProperty,_T("__PATH")) == 0)
			{
				return GetPath(pstrValue);
				
			}
			else if (_tcsicmp(szProperty,_T("Antecedent")) == 0)
			{
				ASSERT(this->m_strClassName.CompareNoCase("Win32_PNPAllocatedResource") == 0);
				this->GetAntecedent(pstrValue);
				return S_OK;

			}
			else if (_tcsicmp(szProperty,_T("Dependent")) == 0)
			{
				ASSERT(this->m_strClassName.CompareNoCase("Win32_PNPAllocatedResource") == 0);
				this->GetDependent(pstrValue);
				return S_OK;
			}
			else if (_tcsicmp(szProperty,_T("Caption")) == 0)
			{
				if (this->m_strClassName.CompareNoCase(_T("Win32_PnPEntity")) == 0)
				{
					//need to get PNP device name
					CString strPNPID;
					GetValueString(_T("DeviceID"),&strPNPID);
					CComPtr<IXMLDOMDocument> pDoc;
					
					if (FAILED(this->m_pNode->get_ownerDocument(&pDoc)) || !pDoc)
					{
						return E_MSINFO_NOVALUE;
					}
					*pstrValue = GetPNPNameByID(pDoc,CComBSTR(strPNPID));
					return S_OK;
				}
				else if (this->m_strClassName.CompareNoCase(_T("Win32_DMAChannel")) == 0)
				{
					return GetValueString(_T("Name"),pstrValue);
				}
				else if (this->m_strClassName.CompareNoCase(_T("Win32_StartupCommand")) == 0)
				{
					return GetValueString(_T("Name"),pstrValue);
				} 
				else if (this->m_strClassName.CompareNoCase(_T("Win32_PortResource")) == 0)
				{
					return GetValueString(_T("Name"),pstrValue);
				}
				else if (this->m_strClassName.CompareNoCase(_T("Win32_IRQResource")) == 0)
				{
					return GetValueString(_T("Name"),pstrValue);
				}
				else if (this->m_strClassName.CompareNoCase(_T("Win32_DeviceMemoryAddress")) == 0)
				{
					return GetValueString(_T("Description"),pstrValue);
				}
				else if (this->m_strClassName.CompareNoCase(_T("Win32_StartupCommand")) == 0)
				{
					return GetValueString(_T("Name"),pstrValue);
				}
				
			}

			else if (_tcsicmp(szProperty,_T("Status")) == 0)
			{

				AfxSetResourceHandle(_Module.GetResourceInstance());
				VERIFY(pstrValue->LoadString(IDS_ERROR_NOVALUE)  && _T("could not find string resource"));
				return S_OK;
			}
			else if (_tcsicmp(szProperty,_T("Name")) == 0 && m_strClassName.CompareNoCase(_T("Win32_Printer")) == 0)
			{
				return GetValueString(_T("DeviceID"),pstrValue);			
			}
			else if (_tcsicmp(szProperty,_T("ServerName")) == 0 && m_strClassName.CompareNoCase(_T("Win32_Printer")) == 0)
			{
				return GetValueString(_T("PortName"),pstrValue);			
			}
			else if (_tcsicmp(szProperty,_T("DriveType")) == 0 && m_strClassName.CompareNoCase(_T("Win32_LogicalDisk")) == 0)
			{
				return GetValueString(_T("Description"),pstrValue);			
			}
			AfxSetResourceHandle(_Module.GetResourceInstance());
			VERIFY(pstrValue->LoadString(IDS_ERROR_NOVALUE)  && _T("could not find string resource"));
			return hr;
			
		}
		if (ovValue.vt != VT_EMPTY)
		{
			USES_CONVERSION;
			CString strVal = OLE2A(ovValue.bstrVal);
			*pstrValue = strVal;
			return hr;
		}
		else
		{
			*pstrValue = _T("");
			AfxSetResourceHandle(_Module.GetResourceInstance());
			VERIFY(pstrValue->LoadString(IDS_ERROR_NOVALUE)  && "could not find string resource");
			return S_OK;
		}
	}
	catch(COleException * pException)
	{
		ASSERT(0 && "conversion error?");
		pException->Delete();
	}
	catch (...)
	{
		ASSERT(0 && "unknown error");
	}
	return E_FAIL;
	
}

//---------------------------------------------------------------------------
//  Finds value specified by szProperty, returns it as DWORD
//---------------------------------------------------------------------------
HRESULT CXMLObject::GetValueDWORD(LPCTSTR szProperty, DWORD * pdwValue)
{
	if (!pdwValue)
	{
		ASSERT(0 && "NULL POINTER PASSED IN");
		return E_MSINFO_NOVALUE;
	}
	CComVariant varValue;
	HRESULT hr = GetValue(szProperty,&varValue);
	if (FAILED(hr))
	{
		return E_MSINFO_NOVALUE;
	}    
	hr = varValue.ChangeType(VT_UI4);
	if (SUCCEEDED(hr))
	{
		*pdwValue = varValue.ulVal;
	}
	else
	{
		return E_MSINFO_NOVALUE;
	}
	return hr;
}

//---------------------------------------------------------------------------
//  Finds value specified by szProperty, returns it as SYSTEMTIME  
//---------------------------------------------------------------------------
HRESULT CXMLObject::GetValueTime(LPCTSTR szProperty, SYSTEMTIME * psystimeValue)
{
	if (!psystimeValue)
	{
		ASSERT(0 && "NULL POINTER PASSED IN");
		return E_MSINFO_NOVALUE;
	}
	VARIANT variant;

	HRESULT hr = GetValue(szProperty, &variant);
	if (SUCCEEDED(hr))
	{
		if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
		{
			USES_CONVERSION;
			LPTSTR szDate = OLE2T(V_BSTR(&variant));
			if (szDate == NULL || _tcslen(szDate) == 0)
			{
				//probably "PROPOGATED" value
				return E_MSINFO_NOVALUE;
			}
			// Parse the date string into the SYSTEMTIME struct. It would be better to
			// get the date from WMI directly, but there was a problem with this. TBD - 
			// look into whether or not we can do this now.

			ZeroMemory(psystimeValue, sizeof(SYSTEMTIME));
			psystimeValue->wSecond	= (unsigned short)_ttoi(szDate + 12);	szDate[12] = _T('\0');
			psystimeValue->wMinute	= (unsigned short)_ttoi(szDate + 10);	szDate[10] = _T('\0');
			psystimeValue->wHour	= (unsigned short)_ttoi(szDate +  8);	szDate[ 8] = _T('\0');
			psystimeValue->wDay		= (unsigned short)_ttoi(szDate +  6);	szDate[ 6] = _T('\0');
			psystimeValue->wMonth	= (unsigned short)_ttoi(szDate +  4);	szDate[ 4] = _T('\0');
			psystimeValue->wYear	= (unsigned short)_ttoi(szDate +  0);
		}
		else
			hr = E_MSINFO_NOVALUE;
	}

	return hr;
}

//---------------------------------------------------------------------------
//  Finds value specified by szProperty, returns it as FLOAT
//---------------------------------------------------------------------------
HRESULT CXMLObject::GetValueDoubleFloat(LPCTSTR szProperty, double * pdblValue)
{
	if (!pdblValue)
	{
		ASSERT(0 && "NULL POINTER PASSED IN");
		return E_MSINFO_NOVALUE;
	}
	CComPtr<IXMLDOMNode> pPropNode;
	CComVariant varValue;
	HRESULT hr = GetPROPERTYNode(szProperty,pPropNode);
	if (FAILED(hr) || !pPropNode)
	{
		return E_MSINFO_NOVALUE;
	}   
	varValue.vt = VT_BSTR;
	hr = pPropNode->get_text(&varValue.bstrVal);
	if (FAILED(hr))
	{
		ASSERT(0 && "could not get text from PROPERTY node");
		*pdblValue = (double) -1;
		return E_MSINFO_NOVALUE;
	}

	hr = varValue.ChangeType(VT_R4);
	if (FAILED(hr))
	{
		varValue.Clear();

		ASSERT(0 && "unable to convert between variant types");
		return E_MSINFO_NOVALUE;
	}
	*pdblValue = varValue.fltVal;
	return hr;
}

//---------------------------------------------------------------------------
//  This function exists to provide compatiblilty with CWMIObject. All it does 
//  is a GetValueString(szProperty,pstrValue)
//---------------------------------------------------------------------------
HRESULT CXMLObject::GetValueValueMap(LPCTSTR szProperty, CString * pstrValue)
{
	if (!pstrValue)
	{
		ASSERT(0 && "NULL POINTER PASSED IN");
		return E_MSINFO_NOVALUE;
	}
	return GetValueString(szProperty,pstrValue);
}



//////////////////////////////////////////////////////////////////////
// CXMLObjectCollection Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLObjectCollection::CXMLObjectCollection(CComPtr<IXMLDOMDocument> pXMLDoc) : m_pXMLDoc(pXMLDoc)
{
	
}

CXMLObjectCollection::~CXMLObjectCollection()
{

}

//-----------------------------------------------------------------------------
// Return the next node in list of INSTANCE nodes selected by 
// CXMLObjectCollection::Create, as a CXMLObject
//-----------------------------------------------------------------------------

HRESULT CXMLObjectCollection::GetNext(CWMIObject ** ppObject)
{
	ASSERT(ppObject);
	if (m_pList == NULL)
	{
		ASSERT(0 && "CXMLObjectCollection::GetNext called on a null enumerator");
		return E_FAIL;
	}
	CComPtr<IXMLDOMNode> pNode;
	HRESULT hr = m_pList->nextNode(&pNode);
	if (!pNode)
	{
		//we're at end of m_pList
		return E_FAIL;
	}
	if (hr == S_OK && pNode)
	{
		if (*ppObject == NULL)
		{
			*ppObject = new CXMLObject();
		}
		if (*ppObject)
		{
			hr = ((CXMLObject *)(*ppObject))->Create(pNode,m_strClassName); // this will AddRef the pointer
			if (FAILED(hr))
			{
				delete (CXMLObject *)(*ppObject);
				*ppObject = NULL;
			}
		}
		if (*ppObject)
		{
			return hr;
		}
		else
			hr = E_OUTOFMEMORY;
	}

	return hr;
}


//---------------------------------------------------------------------------
//  
//---------------------------------------------------------------------------
HRESULT CXMLObjectCollection::Create(LPCTSTR szClass, LPCTSTR szProperties)
{
	HRESULT hr;
	ASSERT(szClass);
	m_strClassName = szClass;
	CString strQuery;
	if (_tcsicmp(szClass,_T("Win32_PNPAllocatedResource")) == 0)
	{
		strQuery = _T("Snapshot//INSTANCENAME[@CLASSNAME");
	}
	else
	{
		strQuery = _T("Snapshot//INSTANCE[@CLASSNAME");
	}
	strQuery += _T("$ieq$");
	strQuery += _T('\"');
	strQuery += szClass;
	strQuery += _T('\"');
	strQuery += _T("]");
	long lListLen = 0;
	hr = this->m_pXMLDoc->getElementsByTagName(CComBSTR(strQuery),&m_pList);
	ASSERT(SUCCEEDED(hr) && "could not get list of instances to match this class");

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CXMLJelper Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
//extern CComPtr<IStream> g_pStream;


CXMLHelper::CXMLHelper(CComPtr<IXMLDOMDocument> pXMLDoc): m_pXMLDoc(pXMLDoc)
{
	

}



CXMLHelper::~CXMLHelper()
{

}

//---------------------------------------------------------------------------
//  Gets a CXMLObjectCollection which contains a list of instances of the
//  class specified by szClass
//---------------------------------------------------------------------------
HRESULT CXMLHelper::Enumerate(LPCTSTR szClass, CWMIObjectCollection ** ppCollection, LPCTSTR szProperties)
{
	CString strCorrectedClass = szClass;
	ASSERT(ppCollection);
	if (ppCollection == NULL)
		return E_INVALIDARG;

	CXMLObjectCollection * pXMLCollection;

	if (*ppCollection)
		pXMLCollection = (CXMLObjectCollection  *) *ppCollection;
	else
		pXMLCollection = new CXMLObjectCollection(m_pXMLDoc);

	if (pXMLCollection == NULL)
		return E_FAIL; // TBD - memory failure

	HRESULT hr = pXMLCollection->Create(strCorrectedClass, szProperties);
	if (SUCCEEDED(hr))
		*ppCollection = (CWMIObjectCollection *) pXMLCollection;
	else
		delete pXMLCollection;
	return hr;

}


//---------------------------------------------------------------------------
//  finds the instance node that matches szObjectPath, and stores the node
//  in a CXMLObject
//  szObjectPath will be something like "Win32_DMAChannel.DMAChannel=2"
//---------------------------------------------------------------------------
HRESULT CXMLHelper::GetObject(LPCTSTR szObjectPath, CWMIObject ** ppObject) 
{	
	
	ASSERT(ppObject);
	if (ppObject == NULL)
		return E_INVALIDARG;
	//
	//strip everything to left of ":"
	CString strPath(szObjectPath);
	int i = strPath.Find(_T(":"));
	if (i > -1)
	{
		strPath = strPath.Right(strPath.GetLength() - i - 1);
	}
	i = strPath.Find(_T("."));
	//separate the string into resource type (e.g. Win32_DMAChannel)
	CString strClassName;
	if (i > -1)
	{
		strClassName = strPath.Left(i);
		strPath = strPath.Right(strPath.GetLength() - i - 1);
	}
	//get the name of the attribute we're looking for in the XML file:
	CString strPropertyName;
	CString strPropertyValue;
	i = strPath.Find(_T("="));
	if (i > -1)
	{
		strPropertyName = strPath.Left(i);
		strPath = strPath.Right(strPath.GetLength() - i - 1);
		//get the value that we need to match in the antecedent
		strPropertyValue = strPath;
	}
	//Create the XML Query pattern to find a node that matches
	CString strQuery = _T("Snapshot//INSTANCE[@CLASSNAME $ieq$ ");
	strQuery += _T("\"");
	strQuery += strClassName;
	strQuery += _T("\"");
	strQuery += _T("]/PROPERTY[@NAME $ieq$ ");
	strQuery += _T("\"");
	strQuery += strPropertyName;
	strQuery += _T("\"]");
	CComBSTR bstrQuery(strQuery);
	CComPtr<IXMLDOMNodeList> pList;
	HRESULT hr;
	hr = m_pXMLDoc->getElementsByTagName(bstrQuery,&pList);
	if (FAILED(hr) || !pList)
	{
		return E_FAIL;
	}
	//find the node whose KEYVALUE node's value matches strPropertyValue
	long lListLen;
	hr = pList->get_length(&lListLen);
	for(int n = 0; n < lListLen; n++)
	{
		CComPtr<IXMLDOMNode> pNode;
		hr = pList->nextNode(&pNode);
		if (FAILED(hr) || !pNode)
		{
			return E_FAIL;
		}
		CComBSTR bstrValue;
		hr = pNode->get_text(&bstrValue);
		USES_CONVERSION;
		CString strValue = OLE2A(bstrValue);
		if (strValue.CompareNoCase(strPropertyValue) == 0)
		{
			CComPtr<IXMLDOMNode> pInstanceNode;
			hr = pNode->get_parentNode(&pInstanceNode);
			if (FAILED(hr) || !pInstanceNode)
			{
				ASSERT(0 && "could not get parent node of PROPERTY");
				return E_FAIL;
			}
			CXMLObject* pObject = new CXMLObject();
			pObject->Create(pInstanceNode,strClassName);
			*ppObject = pObject;
			return S_OK;
		}
	}

	return E_FAIL; 
};


//---------------------------------------------------------------------------
//Gets the text from the sub (child) node of pNode which is selected by bstrQuery
//---------------------------------------------------------------------------
HRESULT GetSubnodeText(CComPtr<IXMLDOMNode> pNode,CComBSTR bstrQuery, CString& strText)
{
	HRESULT hr;
	CComPtr<IXMLDOMNode> pSubNode;
	hr = pNode->selectSingleNode(bstrQuery,&pSubNode);
	if (!SUCCEEDED(hr) || !pSubNode)
	{
		ASSERT(0 && "xml query matched no nodes");
		return E_FAIL;
	}
	CComBSTR bstrText;
	hr = pSubNode->get_text(&bstrText);
	ASSERT(SUCCEEDED(hr));
	USES_CONVERSION;
	strText = OLE2A(bstrText);
	
	return hr;
}



//---------------------------------------------------------------------------
//  Gets the Antecedent node component of an Association
//  m_pNode is probably an INSTANCE of Win32_PnPAllocatedResource; 
//  we need to search for /PROPERTY.REFERENCE
//---------------------------------------------------------------------------
HRESULT CXMLObject::GetAntecedent(CString* pstrAntecedent)
{
	HRESULT hr;
	CString strWMIPath;
	CComPtr<IXMLDOMNode> pSubNode;
	hr = m_pNode->selectSingleNode(CComBSTR(_T("KEYBINDING[@NAME $ieq$ \"Antecedent\"]")),&pSubNode);
	ASSERT(SUCCEEDED(hr));
	
	if (!SUCCEEDED(hr) || !pSubNode)
	{
		return E_FAIL;
	}

	CString strTemp;
	hr = GetSubnodeText(pSubNode,CComBSTR(_T("VALUE.REFERENCE/INSTANCEPATH/NAMESPACEPATH/HOST")),strTemp);
	ASSERT(SUCCEEDED(hr));
	strWMIPath = _T("\\\\");
	strWMIPath += strTemp;
	strWMIPath += _T("\\root");
	strWMIPath += _T("\\cimv2");
	CComPtr<IXMLDOMNode> pInstanceNode;
	hr = pSubNode->selectSingleNode(CComBSTR(_T("VALUE.REFERENCE/INSTANCEPATH/INSTANCENAME")),&pInstanceNode);
	CComPtr<IXMLDOMElement> pElement;
	hr = pInstanceNode->QueryInterface(IID_IXMLDOMElement,(void**) &pElement);
	if (!SUCCEEDED(hr) || !pElement)
	{
		return E_FAIL;	
	}
	CComVariant varElement;
	hr = pElement->getAttribute(CComBSTR(_T("CLASSNAME")),&varElement);
	pElement.Release();
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
	{
		return E_FAIL;
	}
	strWMIPath += _T(":");
	USES_CONVERSION;
	strWMIPath += OLE2A(varElement.bstrVal);
	//now get the "Keybinding Name"
	pInstanceNode.Release();
	pElement.Release();
	hr = pSubNode->selectSingleNode(CComBSTR(_T("VALUE.REFERENCE/INSTANCEPATH/INSTANCENAME/KEYBINDING")),&pInstanceNode);
	ASSERT(SUCCEEDED(hr));
	hr = pInstanceNode->QueryInterface(IID_IXMLDOMElement,(void**) &pElement);
	if (!SUCCEEDED(hr) || !pElement)
	{
		return E_FAIL;	
	}
	hr = pElement->getAttribute(CComBSTR("NAME"),&varElement);
	if (!SUCCEEDED(hr) || !pElement)
	{
		return E_FAIL;	
	}
	strWMIPath += _T(".");
	strWMIPath += OLE2A(varElement.bstrVal);

	//now get value on right of =
	CComBSTR bstrValue;
	hr = pInstanceNode->get_text(&bstrValue);
	strWMIPath += _T("=");
	strWMIPath += OLE2A(bstrValue);
	pInstanceNode.Release();
	pElement.Release();
	*pstrAntecedent = strWMIPath;

	return hr;
}

//---------------------------------------------------------------------------
//  Gets the Dependent node component of an Association
//  m_pNode is probably an INSTANCE of Win32_PnPAllocatedResource; 
//  we need to search for /PROPERTY.REFERENCE
//---------------------------------------------------------------------------
HRESULT CXMLObject::GetDependent(CString* pstrDependent)
{
	HRESULT hr;
	CString strWMIPath;
	CComPtr<IXMLDOMNode> pSubNode;
	hr = this->m_pNode->selectSingleNode(CComBSTR(_T("KEYBINDING[@NAME $ieq$ \"Dependent\"]")),&pSubNode);
	ASSERT(SUCCEEDED(hr));
	
	if (!SUCCEEDED(hr) || !pSubNode)
	{
		return E_FAIL;
	}

	CString strTemp;
	hr = GetSubnodeText(pSubNode,CComBSTR(_T("VALUE.REFERENCE/INSTANCEPATH/NAMESPACEPATH/HOST")),strTemp);
	ASSERT(SUCCEEDED(hr));
	strWMIPath = _T("\\\\");
	strWMIPath += strTemp;
	strWMIPath += _T("\\root");
	strWMIPath += _T("\\cimv2");
	CComPtr<IXMLDOMNode> pInstanceNode;
	hr = pSubNode->selectSingleNode(CComBSTR(_T("VALUE.REFERENCE/INSTANCEPATH/INSTANCENAME")),&pInstanceNode);
	CComPtr<IXMLDOMElement> pElement;
	hr = pInstanceNode->QueryInterface(IID_IXMLDOMElement,(void**) &pElement);
	if (!SUCCEEDED(hr) || !pElement)
	{
		return E_FAIL;	
	}
	CComVariant varElement;
	hr = pElement->getAttribute(CComBSTR(_T("CLASSNAME")),&varElement);
	pElement.Release();
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
	{
		return E_FAIL;
	}
	strWMIPath += _T(":");
	USES_CONVERSION;
	strWMIPath += OLE2A(varElement.bstrVal);
	//now get the "Keybinding Name"
	pInstanceNode.Release();
	pElement.Release();
	hr = pSubNode->selectSingleNode(CComBSTR(_T("VALUE.REFERENCE/INSTANCEPATH/INSTANCENAME/KEYBINDING")),&pInstanceNode);
	ASSERT(SUCCEEDED(hr));
	hr = pInstanceNode->QueryInterface(IID_IXMLDOMElement,(void**) &pElement);
	if (!SUCCEEDED(hr) || !pElement)
	{
		return E_FAIL;	
	}
	hr = pElement->getAttribute(CComBSTR("NAME"),&varElement);
	if (!SUCCEEDED(hr) || !pElement)
	{
		return E_FAIL;	
	}
	strWMIPath += _T(".");
	strWMIPath += OLE2A(varElement.bstrVal);

	//now get value on right of =
	pInstanceNode.Release();
	pElement.Release();
	hr = pSubNode->selectSingleNode(CComBSTR("VALUE.REFERENCE/INSTANCEPATH/INSTANCENAME/KEYBINDING/KEYVALUE"),&pInstanceNode);
	ASSERT(SUCCEEDED(hr));
	hr = pInstanceNode->QueryInterface(IID_IXMLDOMElement,(void**) &pElement);
	if (!SUCCEEDED(hr) || !pElement)
	{
		return E_FAIL;	
	}
	hr = pElement->getAttribute(CComBSTR("VALUETYPE"),&varElement);
	CComBSTR bstrText;
	hr = pInstanceNode->get_text(&bstrText);

	if (!SUCCEEDED(hr) || !pElement)
	{
		return E_FAIL;	
	}
	strWMIPath += _T("=");
	strWMIPath += OLE2A(bstrText);
	*pstrDependent = strWMIPath;
	return S_OK;
}

//---------------------------------------------------------------------------
//  Gets a pseudo WMI path from an INSTANCE node
//---------------------------------------------------------------------------
HRESULT CXMLObject::GetPath(CString* strPath)
{
	HRESULT hr;
	*strPath = _T("\\\\A-STEPHL500\\root\\cimv2");
	*strPath += _T(":");
	*strPath += this->m_strClassName;
	*strPath += _T(".");
	CString strDependent;

	//Get INSTANCEPATH node, which is previous sibling to INSTANCE
	ASSERT(m_pNode != NULL && "NULL m_pNode");
	CComPtr<IXMLDOMNode> pInstancePathNode;
	
	hr = m_pNode->get_previousSibling(&pInstancePathNode);
	if (FAILED(hr) || !pInstancePathNode)
	{
		ASSERT(0 && "could not get INSTANCEPATH node from m_pNode");
		return E_FAIL;
	}
	// get INSTANCENAME
	CComPtr<IXMLDOMNode> pInstanceNameNode;
	hr = pInstancePathNode->selectSingleNode(CComBSTR(_T("INSTANCENAME")),&pInstanceNameNode);
	if (FAILED(hr) || !pInstanceNameNode)
	{
		ASSERT(0 && "could not get INSTANCENAME node from m_pNode");
		return E_FAIL;
	}
	// get KEYBINDING
	CComPtr<IXMLDOMNode> pKeyBindingNode;
	//hr = pInstanceNameNode->selectSingleNode(CComBSTR("KEYBINDING"),&pKeyBindingNode);
	hr = pInstanceNameNode->get_firstChild(&pKeyBindingNode);
	if (FAILED(hr) || !pKeyBindingNode)
	{
		ASSERT(0 && "could not get KEYBINDING node from m_pNode");
		return E_FAIL;
	}
	//get KEYBINDING name
	CComPtr<IXMLDOMElement> pNameElement;
	hr = pKeyBindingNode->QueryInterface(IID_IXMLDOMElement,(void**) &pNameElement);
	if (FAILED(hr) | !pNameElement)
	{
		ASSERT(0 && "could not QI pNode for Element");
		return E_FAIL;
	}
	
	CComVariant varKeybindingName;
	hr = pNameElement->getAttribute(CComBSTR(_T("NAME")),&varKeybindingName);
	if (FAILED(hr))
	{
		ASSERT(0 && "could not get NAME attribute from pNameElement");
	}
	USES_CONVERSION;

	*strPath += OLE2A(varKeybindingName.bstrVal);
	//get KEYBINDING value
	CComBSTR bstrKeyValue;
	hr = pKeyBindingNode->get_text(&bstrKeyValue);
	ASSERT(SUCCEEDED(hr) && "failed to get keybinding value");
	*strPath += _T("=");
	*strPath += OLE2A(bstrKeyValue);
	return S_OK;
}


//---------------------------------------------------------------------------
//  Refreshes the category
//---------------------------------------------------------------------------
BOOL CXMLSnapshotCategory::Refresh(CXMLDataSource * pSource, BOOL fRecursive)
{
	if (!SUCCEEDED(pSource->Refresh(this)))
	{
		return FALSE;
	}
	if (fRecursive)
	{
		for(CMSInfoCategory* pChildCat = (CMSInfoCategory*) this->GetFirstChild();pChildCat != NULL;pChildCat = (CMSInfoCategory*) pChildCat->GetNextSibling())
		{
			if(pChildCat->GetDataSourceType() == XML_SNAPSHOT)
			{
				if (!((CXMLSnapshotCategory*)pChildCat)->Refresh(pSource,fRecursive))
					return FALSE;
			}
		}
	}
	return TRUE;
}

//---------------------------------------------------------------------------
//Creates a snapshot category that parallels a cagetory in the "live" tree
// by copying category name, etc from pLiveCat  
//---------------------------------------------------------------------------
CXMLSnapshotCategory::CXMLSnapshotCategory(CMSInfoLiveCategory* pLiveCat,CXMLSnapshotCategory* pParent,CXMLSnapshotCategory* pPrevSibling) :
	CMSInfoLiveCategory(pLiveCat->m_uiCaption,
	pLiveCat->m_strName,
	pLiveCat->m_pRefreshFunction,
	pLiveCat->m_dwRefreshIndex,
	pParent,
	pPrevSibling,
	_T(""),
	NULL, 
	TRUE, 
	ALL_ENVIRONMENTS)
{
		
	m_iColCount = pLiveCat->m_iColCount;
	m_pRefreshFunction = pLiveCat->m_pRefreshFunction;
	m_strCaption = pLiveCat->m_strCaption;

	if (m_iColCount)
	{
		m_acolumns = new CMSInfoColumn[m_iColCount];

		if (m_acolumns != NULL)
		{
			m_fDynamicColumns = TRUE;

			for (int i = 0; i < m_iColCount; i++)
			{
				m_acolumns[i].m_strCaption = pLiveCat->m_acolumns[i].m_strCaption;
				m_acolumns[i].m_uiCaption = pLiveCat->m_acolumns[i].m_uiCaption;
				m_acolumns[i].m_uiWidth = pLiveCat->m_acolumns[i].m_uiWidth;
				m_acolumns[i].m_fSorts = pLiveCat->m_acolumns[i].m_fSorts;
				m_acolumns[i].m_fLexical = pLiveCat->m_acolumns[i].m_fLexical;
				m_acolumns[i].m_fAdvanced = pLiveCat->m_acolumns[i].m_fAdvanced;
			}
		}
	}
	//build tree using existing live categories
	CMSInfoLiveCategory* pLiveChild = (CMSInfoLiveCategory*) pLiveCat->GetFirstChild();
	if (pLiveChild)
	{
		m_pFirstChild = NULL;
		CXMLSnapshotCategory* pPrevSS = NULL;
		for(;pLiveChild != NULL;pLiveChild = (CMSInfoLiveCategory*) pLiveChild->GetNextSibling())
		{	
			CXMLSnapshotCategory* pNewSS = new CXMLSnapshotCategory(pLiveChild,this,pPrevSS);
			if (m_pFirstChild == NULL)
			{
				ASSERT(pPrevSS == NULL);
				m_pFirstChild = pNewSS;
			}
			pPrevSS = pNewSS;
		}
	}

}

//---------------------------------------------------------------------------
//  Creates a CXMLDatasource from an XML file specified in strFileName
//---------------------------------------------------------------------------
HRESULT CXMLDataSource::Create(CString strFileName, CMSInfoLiveCategory* pRootLiveCat,HWND hwnd)
{
	m_hwnd = hwnd;
	
	m_pHistoryRoot = &catHistorySystemSummary;

	HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
					IID_IXMLDOMDocument, (void**)&m_pXMLDoc);
	if (FAILED(hr) || !m_pXMLDoc)
	{
		ASSERT(0 && "unable to create instance of IID_IXMLDOMDocument");
		return E_FAIL;
	}
	VARIANT_BOOL varBSuccess;
	try
	{
		hr = m_pXMLDoc->load(CComVariant(strFileName),&varBSuccess);
		if (FAILED(hr) || !varBSuccess)
		{
			ASSERT(0 && "unable to load xml document");
			m_pXMLDoc = NULL;
			return E_FAIL;
		}
	}
	catch(...)
	{
		m_pXMLDoc = NULL;
		return E_FAIL;
	}
	//TD: verify that this is looks like a valid incident file or saved DCO stream
	
	this->m_pRoot = new CXMLSnapshotCategory(pRootLiveCat,NULL,NULL);

	return S_OK; 
}

//---------------------------------------------------------------------------
//  
//---------------------------------------------------------------------------
HRESULT CXMLDataSource::Refresh(CXMLSnapshotCategory* pCat)
{
	if (pCat->GetDataSourceType() != XML_SNAPSHOT || ! pCat->m_pRefreshFunction)
	{
		return S_OK;
	}

	CoInitialize(NULL);

	
	CXMLHelper* pWMI = new CXMLHelper(m_pXMLDoc);
	HRESULT hrWMI = E_FAIL;
	if (pWMI)
		hrWMI = pWMI->Create(_T(""));
	
	CMapPtrToPtr			mapRefreshFuncToData;
	CPtrList				lstCategoriesToRefresh;
	CMSInfoLiveCategory *	pLiveCategory;
	HRESULT					hr;

	if (pCat->m_iColCount)
	{
		pLiveCategory = (CMSInfoLiveCategory *) pCat;
		if (pLiveCategory->EverBeenRefreshed())
		{
			if (pWMI)
				delete pWMI;
			return S_OK;
		}
		CPtrList * aptrList = new CPtrList[pLiveCategory->m_iColCount];
		if (aptrList)
		{
			// Retrieve any refresh function specific storage that may have been created.

			void * pRefreshData;
			if (!mapRefreshFuncToData.Lookup((void *)pLiveCategory->m_pRefreshFunction, pRefreshData))
				pRefreshData = NULL;
			// Call the refresh function for this category, with the refresh index.
			hr = pLiveCategory->m_pRefreshFunction(pWMI,
												   pLiveCategory->m_dwRefreshIndex,
												   NULL,
												   aptrList,
												   pLiveCategory->m_iColCount,
												   &pRefreshData);
			pLiveCategory->m_hrError = hr;

			// If the refresh function allocated some storage, save it.

			if (pRefreshData)
				mapRefreshFuncToData.SetAt((void *)pLiveCategory->m_pRefreshFunction, pRefreshData);

			if (SUCCEEDED(pLiveCategory->m_hrError))
			{
				// Get the number of rows of data.

				int iRowCount = (int)aptrList[0].GetCount();

#ifdef _DEBUG
				for (int i = 0; i < pLiveCategory->m_iColCount; i++)
					ASSERT(iRowCount == aptrList[i].GetCount());
#endif

				// Update the category's current data. This has to be done in a
				// critical section, since the main thread accesses this data.

				pLiveCategory->DeleteContent();
				if (iRowCount)
					pLiveCategory->AllocateContent(iRowCount);

				for (int j = 0; j < pLiveCategory->m_iColCount; j++)
					for (int i = 0; i < pLiveCategory->m_iRowCount; i++)
					{
						CMSIValue * pValue = (CMSIValue *) aptrList[j].RemoveHead();
						pLiveCategory->SetData(i, j, pValue->m_strValue, pValue->m_dwValue);
						
						// Set the advanced flag for either the first column, or
						// for any column which is advanced (any cell in a row
						// being advanced makes the whole row advanced).

						if (j == 0 || pValue->m_fAdvanced)
							pLiveCategory->SetAdvancedFlag(i, pValue->m_fAdvanced);

						delete pValue;
					}
				pCat->m_dwLastRefresh = ::GetTickCount();
			}
			else
			{
				// The refresh was cancelled or had an error - delete the new data. If the 
				// refresh had an error, record the time the refresh was attempted.

				if (FAILED(pLiveCategory->m_hrError))
					pCat->m_dwLastRefresh = ::GetTickCount();
			}

			for (int iCol = 0; iCol < pLiveCategory->m_iColCount; iCol++)
				while (!aptrList[iCol].IsEmpty())	// shouldn't be true unless refresh cancelled
					delete (CMSIValue *) aptrList[iCol].RemoveHead();
			delete [] aptrList;
		}
	}


	RefreshFunction	pFunc;
	void *			pCache;

	for (POSITION pos = mapRefreshFuncToData.GetStartPosition(); pos;)
	{
		mapRefreshFuncToData.GetNextAssoc(pos, (void * &)pFunc, pCache);
		if (pFunc)
			pFunc(NULL, 0, NULL, NULL, 0, &pCache);
	}
	mapRefreshFuncToData.RemoveAll();

	if (pWMI)
		delete pWMI;
	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\wmiabstraction.h ===
//=============================================================================
// This file describes classes used by MSInfo to abstract its access to WMI
// classes and enumerations. This abstraction allows for displaying data
// from live WMI or from a saved XML file.
//=============================================================================

#pragma once

#include "resource.h"

//-----------------------------------------------------------------------------
// MSInfo has a couple of specific errors - one where there is no property
// by the specified name, and when where the value returned for the requested
// property is NULL.
//-----------------------------------------------------------------------------

typedef enum tag_MSINFOSTATUS
{
	MSINFO_NO_ERROR		= 0,
	E_MSINFO_NOVALUE	= 0x80043001,
	E_MSINFO_NOPROPERTY	= 0x80043002
} MSINFOSTATUS;

//-----------------------------------------------------------------------------
// The CWMIObject abstract base class encapsulates a WMI object, which may
// in reality be a live WMI object, or an object recreated from the XML
// storage of an object.
//-----------------------------------------------------------------------------

class CWMIObject
{
public:
	CWMIObject() {};
	virtual ~CWMIObject() {};

	// The following methods return information about a property of this object.
	//
	//	S_OK implies success
	//	E_MSINFO_NOPROPERTY means the named property doesn't exist
	//	E_MSINFO_NOVALUE means the property exists, but is empty

	virtual HRESULT GetValue(LPCTSTR szProperty, VARIANT * pvarValue) = 0;
	virtual HRESULT GetValueString(LPCTSTR szProperty, CString * pstrValue) = 0;
	virtual HRESULT GetValueDWORD(LPCTSTR szProperty, DWORD * pdwValue) = 0;
	virtual HRESULT GetValueTime(LPCTSTR szProperty, SYSTEMTIME * psystimeValue) = 0;
	virtual HRESULT GetValueDoubleFloat(LPCTSTR szProperty, double * pdblValue) = 0;
	virtual HRESULT GetValueValueMap(LPCTSTR szProperty, CString * pstrValue) = 0;

	// Some shortcuts and helper functions.

	virtual CString GetString(LPCTSTR szProperty)
	{
		CString strReturn;
		if (SUCCEEDED(GetValueString(szProperty, &strReturn)))
			return strReturn;
		else
			return CString(_T(""));
	}

	virtual HRESULT GetInterpretedValue(LPCTSTR szProperty, LPCTSTR szFormat, TCHAR chFormat, CString * pstrValue, DWORD * pdwValue);
};

//-----------------------------------------------------------------------------
// The CWMIObjectCollection abstract base class encapsulates a collection
// of CWMIObject's. This collection may be treated like an enumeration.
// Subclases of this class may implement the collection as a WMI enumerator,
// or an existing blob of XML data.
//-----------------------------------------------------------------------------

class CWMIObjectCollection
{
public:
	CWMIObjectCollection() {};
	virtual ~CWMIObjectCollection() {};

	// The Create function creates the collection of objects (note - Create
	// may be called multiple times on the same object). If the szProperties
	// parameter is non-NULL, then it contains a comma delimited list of the
	// minimum set of properties which should be included in the collection
	// of objects. If it's NULL, then all available properties should be
	// included.

	virtual HRESULT Create(LPCTSTR szClass, LPCTSTR szProperties = NULL) = 0;

	// The following two functions are used to manage the enumeration.  GetNext
	// returns the next enumerated CWMIObject. When there are no more objects,
	// GetNext returns S_FALSE. Obviously, the caller is responsible for
	// deleting the object returned.
	//
	// Note - if the ppObject points to a non-NULL pointer, it's assumed that
	// the object has already been created, and can be reused.

	virtual HRESULT GetNext(CWMIObject ** ppObject) = 0;
};

//-----------------------------------------------------------------------------
// The CEnumMap is a utility class to cache IEnumWbemClassObject pointers.
// There will be one instance of this class used to improve performance
// by avoiding the high overhead associated with creating enumerators for
// certain classes.
//-----------------------------------------------------------------------------

struct IEnumWbemClassObject;
class CEnumMap
{
public:
	CEnumMap() { };
	~CEnumMap() { Reset(); };

	IEnumWbemClassObject * GetEnumerator(const CString & strClass);
	void SetEnumerator(const CString & strClass, IEnumWbemClassObject * pEnum);
	void Reset();

private:
	CMapStringToPtr m_mapEnum;
};

//-----------------------------------------------------------------------------
// The CWMIHelper function encapsulates a WMI connection (which might be to
// XML).
//-----------------------------------------------------------------------------

struct GATH_FIELD;
struct IWbemServices;
struct IWbemClassObject;
class CMSIEnumerator;
class CMSIObject;

class CWMIHelper
{
public:
	CWMIHelper() : m_pIWbemServices(NULL)
	{
		::AfxSetResourceHandle(_Module.GetResourceInstance());
		m_strTrue.LoadString(IDS_VERSION5YES);
		m_strFalse.LoadString(IDS_VERSION5NO);
		m_strPropertyUnavail.LoadString(IDS_ERROR_NOVALUE);
		m_strBadProperty.LoadString(IDS_ERROR_NOPROPERTY);
	};
	virtual ~CWMIHelper() {};

	// Enumerate creates a CWMIObjectCollection derived object which enumerates the specified class.
	// If szProperties is not null, then it points to a string containing a list of properties to be
	// gathered; otherwise all the properties are included.
	//
	// Note - if ppCollection points to a non-NULL pointer, it's assumed that this object
	// can be reused, and no new collection is created.

	virtual HRESULT Enumerate(LPCTSTR szClass, CWMIObjectCollection ** ppCollection, LPCTSTR szProperties = NULL) = 0;

	// Performs a WQL query (if the subclass supports it).

	virtual HRESULT WQLQuery(LPCTSTR szQuery, CWMIObjectCollection ** ppCollection)
	{
		return E_FAIL;
	}

	virtual void LoadColumnsFromResource(UINT uiResourceID, CPtrList * aColValues, int iColCount);
	virtual void LoadColumnsFromString(LPCTSTR szColumns, CPtrList * aColValues, int iColCount);
	virtual CWMIObject * GetSingleObject(LPCTSTR szClass, LPCTSTR szProperties = NULL);
	virtual HRESULT NewNamespace(LPCTSTR szNamespace, CWMIHelper **ppNewHelper) { return E_FAIL; };
	virtual HRESULT GetNamespace(CString * pstrNamespace) { return E_FAIL; };
	virtual HRESULT GetObject(LPCTSTR szObjectPath, CWMIObject ** ppObject) { return E_FAIL; };
	virtual void AddObjectToOutput(CPtrList * aColValues, int iColCount, CWMIObject * pObject, LPCTSTR szProperties, UINT uiColumns);
	virtual void AddObjectToOutput(CPtrList * aColValues, int iColCount, CWMIObject * pObject, LPCTSTR szProperties, LPCTSTR szColumns);
	virtual void AppendBlankLine(CPtrList * aColValues, int iColCount, BOOL fOnlyIfNotEmpty = TRUE);
	virtual void AppendCell(CPtrList & listColumns, const CString & strValue, DWORD dwValue, BOOL fAdvanced = FALSE);

	// These functions are specific to version 5.0 refreshes, and will be overloaded by the
	// live WMI helper.

	virtual BOOL Version5ResetClass(const CString & strClass, GATH_FIELD * pConstraintFields) { return FALSE; };
	virtual BOOL Version5EnumClass(const CString & strClass, GATH_FIELD * pConstraintFields) { return FALSE; };

	virtual BOOL Version5QueryValueDWORD(const CString & strClass, const CString & strProperty, DWORD & dwResult, CString & strMessage) { return FALSE; };
	virtual BOOL Version5QueryValueDateTime(const CString & strClass, const CString & strProperty, COleDateTime & datetime, CString & strMessage) { return FALSE; };
	virtual BOOL Version5QueryValueDoubleFloat(const CString & strClass, const CString & strProperty, double & dblResult, CString & strMessage) { return FALSE; };
	virtual BOOL Version5QueryValue(const CString & strClass, const CString & strProperty, CString & strResult) { return FALSE; };

	virtual CMSIEnumerator * Version5GetEnumObject(const CString & strClass, const GATH_FIELD * pConstraints = NULL) { return NULL; };
	virtual void			Version5RemoveObject(const CString & strClass) {};
	virtual CMSIObject *	Version5GetObject(const CString & strClass, const GATH_FIELD * pConstraints, CString * pstrLabel = NULL) { return NULL; };
	virtual IWbemServices * Version5GetWBEMService(CString * pstrNamespace = NULL) { return NULL; };
	virtual BOOL			Version5EvaluateFilter(IWbemClassObject * pObject, const GATH_FIELD * pConstraints) { return FALSE; };
	virtual void			Version5EvaluateJoin(const CString & strClass, IWbemClassObject * pObject, const GATH_FIELD * pConstraints) {};
	virtual BOOL			Version5IsDependencyJoin(const GATH_FIELD * pConstraints) { return FALSE; };
	virtual void			Version5EvaluateDependencyJoin(IWbemClassObject * pObject) {};
	virtual void			Version5RemoveEnumObject(const CString & strClass) {};
	virtual void			Version5ClearCache() {};
	virtual HRESULT			Version5CheckValueMap(const CString& strClass, const CString& strProperty, const CString& strVal, CString &strResult) { return E_FAIL; };

public:
	CString				m_strTrue, m_strFalse, m_strPropertyUnavail, m_strBadProperty;
	CMapStringToPtr		m_mapClassToInterface;
	CMapStringToPtr		m_mapClassToEnumInterface;
	CEnumMap			m_enumMap;
	IWbemServices *		m_pIWbemServices;
	HRESULT				m_hrLastVersion5Error;
};

//-----------------------------------------------------------------------------
// Useful utility functions.
//-----------------------------------------------------------------------------

extern void StringReplace(CString & str, LPCTSTR szLookFor, LPCTSTR szReplaceWith);
extern CString GetMSInfoHRESULTString(HRESULT hr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\control\xmlobject.h ===
// XMLObject.h: interface for the CXMLObject class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLOBJECT_H__916BE5F2_D29F_484A_9084_1ABB3759F117__INCLUDED_)
#define AFX_XMLOBJECT_H__916BE5F2_D29F_484A_9084_1ABB3759F117__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include "wmiabstraction.h"

#include "msxml.h"
#include "category.h"
#include "datasource.h"

class CXMLObject : public CWMIObject  
{
private:
	CComPtr<IXMLDOMNode> m_pNode;
public:
	CComVariant m_varValue;
	HRESULT GetPath(CString* strPath);
	HRESULT GetDependent(CString* pstrAntecedent);
	HRESULT GetAntecedent(CString* pstrAntecedent);
	CString m_strClassName;
	CXMLObject();
	virtual ~CXMLObject();
	//HRESULT GetKeybinding(CString* pstrKBName, CString* pstrKBValue);
	//HRESULT GetAssociationNode(CComPtr<IXMLDOMNode>& pAssocNode);
	HRESULT GetPROPERTYNode(LPCTSTR szProperty,CComPtr<IXMLDOMNode>& pPropNode);
	HRESULT Create(CComPtr<IXMLDOMNode> pNode,CString strClassName);
	HRESULT GetValue(LPCTSTR szProperty, VARIANT * pvarValue);
	HRESULT GetValueString(LPCTSTR szProperty, CString * pstrValue);
	HRESULT GetValueDWORD(LPCTSTR szProperty, DWORD * pdwValue);
	HRESULT GetValueTime(LPCTSTR szProperty, SYSTEMTIME * psystimeValue);
	HRESULT GetValueDoubleFloat(LPCTSTR szProperty, double * pdblValue);
	HRESULT GetValueValueMap(LPCTSTR szProperty, CString * pstrValue);
};


class CXMLObjectCollection : public CWMIObjectCollection  
{
	CComPtr<IXMLDOMDocument> m_pXMLDoc;//if we get a build error here, we may need to undefine _msxml_h_
	CComPtr<IXMLDOMNodeList> m_pList;
public:
	CString m_strClassName;
	HRESULT Create(LPCTSTR szClass, LPCTSTR szProperties);
	HRESULT GetNext(CWMIObject ** ppObject);
	CXMLObjectCollection(CComPtr<IXMLDOMDocument> pXMLDoc);
	virtual ~CXMLObjectCollection();

};


class CXMLHelper : public CWMIHelper  
{
	private:
	CComPtr<IXMLDOMDocument> m_pXMLDoc;//if we get a build error here, we may need to undefine _msxml_h_

public:
	CXMLHelper(CComPtr<IXMLDOMDocument> pXMLDoc);
	virtual ~CXMLHelper();
	HRESULT Enumerate(LPCTSTR szClass, CWMIObjectCollection ** ppCollection, LPCTSTR szProperties);
	HRESULT GetObject(LPCTSTR szObjectPath, CWMIObject ** ppObject);
	HRESULT Create(LPCTSTR szMachine) { return S_OK; };
};
class CXMLDataSource;
class CXMLSnapshotCategory : public CMSInfoLiveCategory
{
public:
	void AppendFilenameToCaption(CString strFileName)
	{
		CString strCaption;
		GetNames(&strCaption, NULL);	// forces the caption name to be loaded

		//m_strCaption += _T(" ") + strFileName;
		//a-stephl fix to OSR v 4.1 bug # 137363
		m_strCaption += _T(" [") + strFileName;
		m_strCaption += _T("]");
		//end a-stephl fix to OSR v 4.1 bug # 137363
	}
	CXMLSnapshotCategory::CXMLSnapshotCategory(UINT uiCaption, LPCTSTR szName, RefreshFunction pFunction, DWORD dwRefreshIndex, CMSInfoCategory * pParent, CMSInfoCategory * pPrevious, CMSInfoColumn * pColumns, BOOL fDynamicColumns, CategoryEnvironment environment)
		: CMSInfoLiveCategory(uiCaption,szName,pFunction,dwRefreshIndex,pParent,pPrevious, _T(""), pColumns, fDynamicColumns,environment)
		{};
	//this constructor copies caption, name, etc from one of the existing (static) CMSInfoLiveCategory's
	CXMLSnapshotCategory(CMSInfoLiveCategory* pLiveCat,CXMLSnapshotCategory* pParent,CXMLSnapshotCategory* pPrevSibling);
	virtual BOOL Refresh(CXMLDataSource * pSource, BOOL fRecursive);
	virtual DataSourceType GetDataSourceType() { return XML_SNAPSHOT;};
	
};






#endif // !defined(AFX_XMLOBJECT_H__916BE5F2_D29F_484A_9084_1ABB3759F117__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\autostartdlg.cpp ===
// AutoStartDlg.cpp : implementation file
//

#include "stdafx.h"
#include "msconfig.h"
#include "AutoStartDlg.h"
#include "MSConfigState.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAutoStartDlg dialog


CAutoStartDlg::CAutoStartDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAutoStartDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAutoStartDlg)
	m_checkDontShow = FALSE;
	//}}AFX_DATA_INIT
}


void CAutoStartDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAutoStartDlg)
	DDX_Check(pDX, IDC_CHECKDONTSHOW, m_checkDontShow);
	//}}AFX_DATA_MAP
}

//-----------------------------------------------------------------------------
// Catch the help messages to show the MSConfig help file.
//-----------------------------------------------------------------------------

BOOL CAutoStartDlg::OnHelpInfo(HELPINFO * pHelpInfo) 
{
	TCHAR szHelpPath[MAX_PATH];

	// Try to find a localized help file to open (bug 460691). It should be
	// located in %windir%\help\mui\<LANGID>.

	if (::ExpandEnvironmentStrings(_T("%SystemRoot%\\help\\mui"), szHelpPath, MAX_PATH))
	{
		CString strLanguageIDPath;

		LANGID langid = GetUserDefaultUILanguage();
		strLanguageIDPath.Format(_T("%s\\%04x\\msconfig.chm"), szHelpPath, langid);

		if (FileExists(strLanguageIDPath))
		{
			::HtmlHelp(::GetDesktopWindow(), strLanguageIDPath, HH_DISPLAY_TOPIC, 0);
			return TRUE;
		}
	}

	if (::ExpandEnvironmentStrings(_T("%windir%\\help\\msconfig.chm"), szHelpPath, MAX_PATH))
		::HtmlHelp(::GetDesktopWindow(), szHelpPath, HH_DISPLAY_TOPIC, 0); 
	return TRUE;
}

void CAutoStartDlg::OnHelp()
{
    OnHelpInfo(NULL);
}

BEGIN_MESSAGE_MAP(CAutoStartDlg, CDialog)
	//{{AFX_MSG_MAP(CAutoStartDlg)
		// NOTE: the ClassWizard will add message map macros here
		ON_WM_HELPINFO()
		ON_COMMAND(ID_HELP, OnHelp)	
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAutoStartDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\makefile.inc ===
..\html\SIhtml01.htm: ..\html\msinfo.htm
	copy /v $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\bootadv.h ===
// bootadv.h : Declaration of the CBootIniAdvancedDlg

#ifndef __BOOTINIADVANCEDDLG_H_
#define __BOOTINIADVANCEDDLG_H_

#include "resource.h"       // main symbols
#include <atlhost.h>
#include <math.h>

#define MINBOOTMB			64		// from SkIn (from MSDN, 8MB is the minimum for /MAXMEM)
#define MIN_1394_CHANNEL	1
#define MAX_1394_CHANNEL	62

/////////////////////////////////////////////////////////////////////////////
// CBootIniAdvancedDlg
class CBootIniAdvancedDlg : 
	public CAxDialogImpl<CBootIniAdvancedDlg>
{
public:
	CBootIniAdvancedDlg()
	{
	}

	~CBootIniAdvancedDlg()
	{
	}

	enum { IDD = IDD_BOOTINIADVANCEDDLG };

BEGIN_MSG_MAP(CBootIniAdvancedDlg)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_HANDLER(IDC_BIABAUDRATE, BN_CLICKED, OnClickedBaudRateCheck)
	COMMAND_HANDLER(IDC_BIADEBUG, BN_CLICKED, OnClickedDebugCheck)
	COMMAND_HANDLER(IDC_BIADEBUGPORT, BN_CLICKED, OnClickedDebugPortCheck)
	COMMAND_HANDLER(IDC_BIAMAXMEM, BN_CLICKED, OnClickedMaxMemCheck)
	COMMAND_HANDLER(IDC_BIANUMPROC, BN_CLICKED, OnClickedNumProcCheck)
	NOTIFY_HANDLER(IDC_SPINMAXMEM, UDN_DELTAPOS, OnDeltaSpinMaxMem)
	COMMAND_HANDLER(IDC_EDITMAXMEM, EN_KILLFOCUS, OnKillFocusEditMaxMem)
	COMMAND_HANDLER(IDC_COMBOCOMPORT, CBN_SELCHANGE, OnSelChangeComboComPort)
	COMMAND_HANDLER(IDC_BIACHANNEL, BN_CLICKED, OnClickedBIAChannel)
	NOTIFY_HANDLER(IDC_SPINCHANNEL, UDN_DELTAPOS, OnDeltaSpinChannel)
	COMMAND_HANDLER(IDC_EDITCHANNEL, EN_KILLFOCUS, OnKillFocusChannel)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	
	//-------------------------------------------------------------------------
	// Launch the advanced option dialog for the specified boot.ini line.
	// Modifies the string passed in if appropriate, returns TRUE if the user
	// made modifications, FALSE otherwise.
	//-------------------------------------------------------------------------

	BOOL ShowAdvancedOptions(CString & strIniLine)
	{
		m_strWorkingLine = strIniLine;
		
		BOOL fReturn = (DoModal() == IDOK);
		if (fReturn)
			strIniLine = m_strWorkingLine;

		return fReturn;
	}

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		// Initialize the drop down list for the number of processors available.

		SYSTEM_INFO si;
		::GetSystemInfo(&si);

		CString strItem;
		for (DWORD dwProc = 1; dwProc <= si.dwNumberOfProcessors; dwProc++)
		{
			strItem.Format(_T("%d"), dwProc);
			::SendMessage(GetDlgItem(IDC_COMBOPROCS), CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)strItem);
		}

		// Initialize the drop down list for the number of COM ports available.

		::SendMessage(GetDlgItem(IDC_COMBOCOMPORT), CB_ADDSTRING, 0, (LPARAM)_T("COM1:"));
		::SendMessage(GetDlgItem(IDC_COMBOCOMPORT), CB_ADDSTRING, 0, (LPARAM)_T("COM2:"));
		::SendMessage(GetDlgItem(IDC_COMBOCOMPORT), CB_ADDSTRING, 0, (LPARAM)_T("COM3:"));
		::SendMessage(GetDlgItem(IDC_COMBOCOMPORT), CB_ADDSTRING, 0, (LPARAM)_T("COM4:"));
		::SendMessage(GetDlgItem(IDC_COMBOCOMPORT), CB_ADDSTRING, 0, (LPARAM)_T("1394"));

		// Initialize the drop down list for the available baud rates.

		::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_ADDSTRING, 0, (LPARAM)_T("300"));
		::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_ADDSTRING, 0, (LPARAM)_T("1200"));
		::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_ADDSTRING, 0, (LPARAM)_T("2400"));
		::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_ADDSTRING, 0, (LPARAM)_T("4800"));
		::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_ADDSTRING, 0, (LPARAM)_T("9600"));
		::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_ADDSTRING, 0, (LPARAM)_T("19200"));
		::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_ADDSTRING, 0, (LPARAM)_T("38400"));
		::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_ADDSTRING, 0, (LPARAM)_T("57600"));
		::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_ADDSTRING, 0, (LPARAM)_T("115200"));

		// Get the maximum value for the /MAXMEM spinner.

		MEMORYSTATUS ms;
		GlobalMemoryStatus(&ms);
		// We should round the memory value up to the next 4MB boundary (455761) since
		// many machines report a little less than the full amount of RAM. Old line:
		//
		//		m_iMaxMB = (int)ceil((double)ms.dwTotalPhys / (1024.0 * 1024.0));

		m_iMaxMB = ((int)ceil((double)ms.dwTotalPhys / (1024.0 * 1024.0 * 4.0)) * 4);

		// Set the controls of the dialog based on the line we're editing.

		SetDlgControlsToString();
		SetDlgControlState();

		return 1;  // Let the system set the focus
	}

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetStringToDlgControls();

#ifdef DEBUG
		::AfxMessageBox(m_strWorkingLine);
#endif

		EndDialog(wID);
		return 0;
	}

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		EndDialog(wID);
		return 0;
	}

	//-------------------------------------------------------------------------
	// Set the states of the controls in the dialog (based on the values in
	// the other controls).
	//-------------------------------------------------------------------------

	void SetDlgControlState()
	{
		BOOL fMaxMem = (BST_CHECKED == IsDlgButtonChecked(IDC_BIAMAXMEM));
		::EnableWindow(GetDlgItem(IDC_EDITMAXMEM), fMaxMem);
		::EnableWindow(GetDlgItem(IDC_SPINMAXMEM), fMaxMem);

		BOOL fNumProc = (BST_CHECKED == IsDlgButtonChecked(IDC_BIANUMPROC));
		::EnableWindow(GetDlgItem(IDC_COMBOPROCS), fNumProc);

		BOOL fDebug = (BST_CHECKED == IsDlgButtonChecked(IDC_BIADEBUG));
		::EnableWindow(GetDlgItem(IDC_BIADEBUGPORT), fDebug);

		BOOL fDebugPort = (BST_CHECKED == IsDlgButtonChecked(IDC_BIADEBUGPORT));
		::EnableWindow(GetDlgItem(IDC_COMBOCOMPORT), fDebug && fDebugPort);

		TCHAR szTemp[MAX_PATH];
		BOOL fFirewire = FALSE;
		BOOL fCOMPort = FALSE;
		if (GetDlgItemText(IDC_COMBOCOMPORT, szTemp, MAX_PATH))
		{
			if (_tcscmp(szTemp, _T("1394")) == 0)
				fFirewire = TRUE;
			else if (szTemp[0] == _T('C'))
				fCOMPort = TRUE;
		}

		::EnableWindow(GetDlgItem(IDC_BIABAUDRATE), fDebug && fDebugPort && fCOMPort);
		::EnableWindow(GetDlgItem(IDC_BIACHANNEL), fDebug && fDebugPort && fFirewire);
		
		BOOL fDebugRate = (BST_CHECKED == IsDlgButtonChecked(IDC_BIABAUDRATE));
		::EnableWindow(GetDlgItem(IDC_COMBOBAUD), fDebug && fDebugRate && !fFirewire);

		BOOL fDebugChannel = (BST_CHECKED == IsDlgButtonChecked(IDC_BIACHANNEL));
		::EnableWindow(GetDlgItem(IDC_EDITCHANNEL), fDebug && fDebugPort && fDebugChannel && fFirewire);
		::EnableWindow(GetDlgItem(IDC_SPINCHANNEL), fDebug && fDebugPort && fDebugChannel && fFirewire);
	}

	//-------------------------------------------------------------------------
	// Sets the value of a combo box to the value in a string.
	//-------------------------------------------------------------------------

	void SetComboBox(LPCTSTR szLine, LPCTSTR szFlag, LPCTSTR szValidChars, UINT uiCB)
	{
		CString strLine(szLine);

		int i = strLine.Find(szFlag);
		if (i != -1)
		{
			CString strWorking(strLine.Mid(i));
			strWorking.TrimLeft(szFlag);
			strWorking.TrimLeft(_T(" ="));
			strWorking = strWorking.SpanIncluding(szValidChars);
			if (CB_ERR == ::SendMessage(GetDlgItem(uiCB), CB_SELECTSTRING, -1, (LPARAM)(LPCTSTR)strWorking))
			{
				LRESULT lIndex = ::SendMessage(GetDlgItem(uiCB), CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)strWorking);
				if (lIndex != CB_ERR)
					::SendMessage(GetDlgItem(uiCB), CB_SETCURSEL, (WPARAM)lIndex, 0);
			}
		}
	}

	//-------------------------------------------------------------------------
	// Set contents of the controls to reflect the contents of 
	// m_strWorkingLine.
	//-------------------------------------------------------------------------

	void SetDlgControlsToString()
	{
		CString strLine(m_strWorkingLine);
		strLine.MakeLower();

		CheckDlgButton(IDC_BIAMAXMEM,		(strLine.Find(_T("/maxmem")) != -1));
		CheckDlgButton(IDC_BIANUMPROC,		(strLine.Find(_T("/numproc")) != -1));
		CheckDlgButton(IDC_BIAPCILOCK,		(strLine.Find(_T("/pcilock")) != -1));
		CheckDlgButton(IDC_BIADEBUG,		(strLine.Find(_T("/debug")) != -1));
		CheckDlgButton(IDC_BIADEBUGPORT,	(strLine.Find(_T("/debugport")) != -1));
		CheckDlgButton(IDC_BIABAUDRATE,		(strLine.Find(_T("/baudrate")) != -1));
		CheckDlgButton(IDC_BIACHANNEL,		(strLine.Find(_T("/channel")) != -1));

		CString strWorking;
		int i = strLine.Find(_T("/maxmem"));
		if (i != -1)
		{
			strWorking = strLine.Mid(i);
			strWorking.TrimLeft(_T("/maxmem ="));
			strWorking = strWorking.SpanIncluding(_T("0123456789"));
			SetDlgItemText(IDC_EDITMAXMEM, strWorking);
		}

		i = strLine.Find(_T("/channel"));
		if (i != -1)
		{
			strWorking = strLine.Mid(i);
			strWorking.TrimLeft(_T("/channel ="));
			strWorking = strWorking.SpanIncluding(_T("0123456789"));
			SetDlgItemText(IDC_EDITCHANNEL, strWorking);
		}

		SetComboBox(strLine, _T("/numproc"), _T("0123456789"), IDC_COMBOPROCS);
		SetComboBox(strLine, _T("/baudrate"), _T("0123456789"), IDC_COMBOBAUD);
		SetComboBox(strLine, _T("/debugport"), _T("com1234:"), IDC_COMBOCOMPORT);
	}

	//-------------------------------------------------------------------------
	// Funtions to add or remove a flag from the working string.
	//-------------------------------------------------------------------------

	void AddFlag(LPCTSTR szFlag)
	{
		CString strFlag(szFlag);

		// TBD - might be a better way to do this.

		CString strRemove = strFlag.SpanExcluding(_T("="));
		RemoveFlag(strRemove);

		if (m_strWorkingLine.IsEmpty())
			m_strWorkingLine = strFlag;
		else
		{
			m_strWorkingLine.TrimRight();
			m_strWorkingLine += CString(_T(" ")) + strFlag;
		}
	}

	void RemoveFlag(LPCTSTR szFlag)
	{
		CString strWorking(m_strWorkingLine);
		strWorking.MakeLower();
		
		int iTrimLeft = strWorking.Find(szFlag);
		if (iTrimLeft == -1)
			return;

		CString strNewLine(_T(""));
		if (iTrimLeft > 0)
			strNewLine = m_strWorkingLine.Left(iTrimLeft);

		int iTrimRight = strWorking.Find(_T("/"), iTrimLeft + 1);
		if (iTrimRight != -1)
			strNewLine += m_strWorkingLine.Mid(iTrimRight);

		m_strWorkingLine = strNewLine;
	}

	//-------------------------------------------------------------------------
	// Set contents of m_strWorkingLine to reflec the dialog controls.
	//-------------------------------------------------------------------------

	void SetStringToDlgControls()
	{
		CString strFlag;
		TCHAR	szTemp[MAX_PATH];

		if (BST_CHECKED == IsDlgButtonChecked(IDC_BIAMAXMEM) && GetDlgItemText(IDC_EDITMAXMEM, szTemp, MAX_PATH))
		{
			long lRequestedValue = _ttol(szTemp);
			long lAllowedValue = VerifyMaxMem(lRequestedValue);

			if (lRequestedValue != lAllowedValue)
			{
				wsprintf(szTemp, _T("%d"), lAllowedValue);
				SetDlgItemText(IDC_EDITMAXMEM, szTemp);
			}

			strFlag.Format(_T("/maxmem=%s"), szTemp);
			AddFlag(strFlag);
		}
		else
			RemoveFlag(_T("/maxmem"));

		if (BST_CHECKED == IsDlgButtonChecked(IDC_BIANUMPROC) && GetDlgItemText(IDC_COMBOPROCS, szTemp, MAX_PATH))
		{
			strFlag.Format(_T("/numproc=%s"), szTemp);
			AddFlag(strFlag);
		}
		else
			RemoveFlag(_T("/numproc"));

		if (BST_CHECKED == IsDlgButtonChecked(IDC_BIAPCILOCK))
			AddFlag(_T("/pcilock"));
		else
			RemoveFlag(_T("/pcilock"));

		if (BST_CHECKED == IsDlgButtonChecked(IDC_BIADEBUG))
		{
			AddFlag(_T("/debug"));

			if (BST_CHECKED == IsDlgButtonChecked(IDC_BIADEBUGPORT) && GetDlgItemText(IDC_COMBOCOMPORT, szTemp, MAX_PATH))
			{
				strFlag.Format(_T("/debugport=%s"), szTemp);
				AddFlag(strFlag);
			}
			else
				RemoveFlag(_T("/debugport"));

			if (::IsWindowEnabled(GetDlgItem(IDC_BIABAUDRATE)) && BST_CHECKED == IsDlgButtonChecked(IDC_BIABAUDRATE) && GetDlgItemText(IDC_COMBOBAUD, szTemp, MAX_PATH))
			{
				strFlag.Format(_T("/baudrate=%s"), szTemp);
				AddFlag(strFlag);
			}
			else
				RemoveFlag(_T("/baudrate"));

			if (::IsWindowEnabled(GetDlgItem(IDC_BIACHANNEL)) && BST_CHECKED == IsDlgButtonChecked(IDC_BIACHANNEL) && GetDlgItemText(IDC_EDITCHANNEL, szTemp, MAX_PATH))
			{
				long lRequestedValue = _ttol(szTemp);
				long lAllowedValue = VerifyChannel(lRequestedValue);

				if (lRequestedValue != lAllowedValue)
				{
					wsprintf(szTemp, _T("%d"), lAllowedValue);
					SetDlgItemText(IDC_EDITCHANNEL, szTemp);
				}
				
				strFlag.Format(_T("/channel=%s"), szTemp);
				AddFlag(strFlag);
			}
			else
				RemoveFlag(_T("/channel"));
		}
		else
		{
			RemoveFlag(_T("/debug"));
			RemoveFlag(_T("/debugport"));
			RemoveFlag(_T("/baudrate"));
			RemoveFlag(_T("/channel"));
		}
	}


private:
	CString		m_strWorkingLine;	// the line from the INI file we are modifying
	int			m_iMaxMB;			// max value for /MAXMEM

	LRESULT OnClickedBaudRateCheck(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (BST_CHECKED == IsDlgButtonChecked(IDC_BIABAUDRATE))
			if (CB_ERR == ::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_GETCURSEL, 0, 0))
				::SendMessage(GetDlgItem(IDC_COMBOBAUD), CB_SETCURSEL, 0, 0);

		SetDlgControlState();
		return 0;
	}

	LRESULT OnClickedDebugCheck(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetDlgControlState();
		return 0;
	}

	LRESULT OnClickedDebugPortCheck(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (BST_CHECKED == IsDlgButtonChecked(IDC_BIADEBUGPORT))
			if (CB_ERR == ::SendMessage(GetDlgItem(IDC_COMBOCOMPORT), CB_GETCURSEL, 0, 0))
				::SendMessage(GetDlgItem(IDC_COMBOCOMPORT), CB_SETCURSEL, 0, 0);

		SetDlgControlState();
		return 0;
	}

	LRESULT OnClickedMaxMemCheck(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (BST_CHECKED == IsDlgButtonChecked(IDC_BIAMAXMEM))
		{
			TCHAR szTemp[MAX_PATH];

			if (!GetDlgItemText(IDC_EDITMAXMEM, szTemp, MAX_PATH) || szTemp[0] == _T('\0'))
			{
				CString strMinValue;
				strMinValue.Format(_T("%d"), m_iMaxMB);
				SetDlgItemText(IDC_EDITMAXMEM, strMinValue);
			}
		}

		SetDlgControlState();
		return 0;
	}

	LRESULT OnClickedNumProcCheck(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (BST_CHECKED == IsDlgButtonChecked(IDC_BIANUMPROC))
			if (CB_ERR == ::SendMessage(GetDlgItem(IDC_COMBOPROCS), CB_GETCURSEL, 0, 0))
				::SendMessage(GetDlgItem(IDC_COMBOPROCS), CB_SETCURSEL, 0, 0);

		SetDlgControlState();
		return 0;
	}

	long VerifyMaxMem(long lMem)
	{
		if (lMem < MINBOOTMB)
			lMem = MINBOOTMB;

		if (lMem > m_iMaxMB)
			lMem = m_iMaxMB;

		return lMem;
	}

	LRESULT OnDeltaSpinMaxMem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		LPNMUPDOWN	pnmud = (LPNMUPDOWN)pnmh;
		TCHAR		szTemp[MAX_PATH];
		long		lNewVal = m_iMaxMB;

		if (GetDlgItemText(IDC_EDITMAXMEM, szTemp, MAX_PATH))
			lNewVal = VerifyMaxMem(_ttol(szTemp) - pnmud->iDelta);

		wsprintf(szTemp, _T("%d"), lNewVal);
		SetDlgItemText(IDC_EDITMAXMEM, szTemp);
		return 0;
	}

	LRESULT OnKillFocusEditMaxMem(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		TCHAR szTemp[MAX_PATH];
		if (GetDlgItemText(IDC_EDITMAXMEM, szTemp, MAX_PATH))
		{
			long lCurrentVal = _ttol(szTemp);
			long lAllowedVal = VerifyMaxMem(lCurrentVal);

			if (lCurrentVal != lAllowedVal)
			{
				wsprintf(szTemp, _T("%d"), lAllowedVal);
				SetDlgItemText(IDC_EDITMAXMEM, szTemp);
			}
		}
		return 0;
	}

	LRESULT OnSelChangeComboComPort(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetDlgControlState();
		return 0;
	}

	LRESULT OnClickedBIAChannel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (BST_CHECKED == IsDlgButtonChecked(IDC_BIACHANNEL))
		{
			TCHAR szTemp[MAX_PATH];

			if (!GetDlgItemText(IDC_EDITCHANNEL, szTemp, MAX_PATH) || szTemp[0] == _T('\0'))
				SetDlgItemText(IDC_EDITCHANNEL, _T("1"));
		}

		SetDlgControlState();
		return 0;
	}

	long VerifyChannel(long lChannel)
	{
		if (lChannel < MIN_1394_CHANNEL)
			lChannel = MIN_1394_CHANNEL;

		if (lChannel > MAX_1394_CHANNEL)
			lChannel = MAX_1394_CHANNEL;

		return lChannel;
	}

	LRESULT OnDeltaSpinChannel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		LPNMUPDOWN	pnmud = (LPNMUPDOWN)pnmh;
		TCHAR		szTemp[MAX_PATH];
		long		lNewVal = m_iMaxMB;

		if (GetDlgItemText(IDC_EDITCHANNEL, szTemp, MAX_PATH))
			lNewVal = VerifyChannel(_ttol(szTemp) - pnmud->iDelta);

		wsprintf(szTemp, _T("%d"), lNewVal);
		SetDlgItemText(IDC_EDITCHANNEL, szTemp);
		return 0;
	}

	LRESULT OnKillFocusChannel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		TCHAR szTemp[MAX_PATH];
		if (GetDlgItemText(IDC_EDITCHANNEL, szTemp, MAX_PATH))
		{
			long lCurrentVal = _ttol(szTemp);
			long lAllowedVal = VerifyChannel(lCurrentVal);

			if (lCurrentVal != lAllowedVal)
			{
				wsprintf(szTemp, _T("%d"), lAllowedVal);
				SetDlgItemText(IDC_EDITCHANNEL, szTemp);
			}
		}
		return 0;
	}
};

#endif //__BOOTINIADVANCEDDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\bootadv.cpp ===
// bootadv.cpp : Implementation of CBootIniAdvancedDlg
#include "stdafx.h"
#include "bootadv.h"

/////////////////////////////////////////////////////////////////////////////
// CBootIniAdvancedDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\essentialsvcdlg.cpp ===
// EssentialSvcDlg.cpp : implementation file
//

#include "stdafx.h"
#include "msconfig.h"
#include "EssentialSvcDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEssentialServiceDialog dialog


CEssentialServiceDialog::CEssentialServiceDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CEssentialServiceDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEssentialServiceDialog)
	m_fDontShow = FALSE;
	//}}AFX_DATA_INIT
}


void CEssentialServiceDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEssentialServiceDialog)
	DDX_Check(pDX, IDC_CHECKDONTSHOW, m_fDontShow);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEssentialServiceDialog, CDialog)
	//{{AFX_MSG_MAP(CEssentialServiceDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEssentialServiceDialog message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\autostartdlg.h ===
#if !defined(AFX_AUTOSTARTDLG_H__B5F4D069_ADC2_4C40_83A8_9A9C5C82CFD8__INCLUDED_)
#define AFX_AUTOSTARTDLG_H__B5F4D069_ADC2_4C40_83A8_9A9C5C82CFD8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AutoStartDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAutoStartDlg dialog

class CAutoStartDlg : public CDialog
{
// Construction
public:
	CAutoStartDlg(CWnd* pParent = NULL);   // standard constructor
	afx_msg void OnHelp();

// Dialog Data
	//{{AFX_DATA(CAutoStartDlg)
	enum { IDD = IDD_AUTOSTART };
	BOOL	m_checkDontShow;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoStartDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAutoStartDlg)
		// NOTE: the ClassWizard will add member functions here
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUTOSTARTDLG_H__B5F4D069_ADC2_4C40_83A8_9A9C5C82CFD8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\expanddlg.cpp ===
//=============================================================================
// The CExpandDlg class is designed to give the user a GUI for running the
// EXPAND program.
//=============================================================================

#include "stdafx.h"
#include <atlhost.h>
#include "msconfig.h"
#include "msconfigstate.h"
#include "ExpandDlg.h"
#include <regstr.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExpandDlg dialog


CExpandDlg::CExpandDlg(CWnd* pParent /*=NULL*/)	: CDialog(CExpandDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CExpandDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CExpandDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExpandDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExpandDlg, CDialog)
	//{{AFX_MSG_MAP(CExpandDlg)
	ON_BN_CLICKED(IDC_EXPANDBROWSEFILE, OnBrowseFile)
	ON_BN_CLICKED(IDC_EXPANDBROWSEFROM, OnBrowseFrom)
	ON_BN_CLICKED(IDC_EXPANDBROWSETO, OnBrowseTo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------
// When the dialog box is initializing, we should load the last paths used
// from the registry into the From and To combo boxes.
//-----------------------------------------------------------------------------

BOOL CExpandDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	TCHAR	szValueName[3];
	TCHAR	szValue[MAX_PATH];
	CRegKey regkey;
	DWORD	dwCount;

	// Add the setup path to the Exand from combo box.

	const TCHAR szRegValue[] = REGSTR_VAL_SRCPATH;
	const TCHAR szRegPath[] = REGSTR_PATH_SETUP REGSTR_KEY_SETUP;
	HKEY hkey;

	if (::RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
	{
		dwCount = MAX_PATH;
		if (::RegQueryValueEx(hkey, szRegValue, NULL, NULL, (LPBYTE)szValue, &dwCount) == ERROR_SUCCESS)
		{
			m_listFromStrings.AddHead(CString(szValue));
			::SendMessage(GetDlgItem(IDC_COMBOFROM)->m_hWnd, CB_INSERTSTRING, 0, (LPARAM)szValue);
		}
		RegCloseKey(hkey);
	}

	// Read the most recently used string for the From and To combo boxes.

	regkey.Attach(GetRegKey(_T("ExpandFrom")));
	for (int index = 9; index >= 0; index--)
	{
		_itot(index, szValueName, 10);
		dwCount = MAX_PATH;
		if (ERROR_SUCCESS == regkey.QueryValue(szValue, szValueName, &dwCount))
		{
			m_listFromStrings.AddHead(CString(szValue));
			::SendMessage(GetDlgItem(IDC_COMBOFROM)->m_hWnd, CB_INSERTSTRING, 0, (LPARAM)szValue);
		}
	}
	regkey.Detach();

	regkey.Attach(GetRegKey(_T("ExpandTo")));
	for (index = 9; index >= 0; index--)
	{
		_itot(index, szValueName, 10);
		dwCount = MAX_PATH;
		if (ERROR_SUCCESS == regkey.QueryValue(szValue, szValueName, &dwCount))
		{
			m_listToStrings.AddHead(CString(szValue));
			::SendMessage(GetDlgItem(IDC_COMBOTO)->m_hWnd, CB_INSERTSTRING, 0, (LPARAM)szValue);
		}
	}
	regkey.Detach();

	return TRUE;  // return TRUE unless you set the focus to a control
}

//-----------------------------------------------------------------------------
// When the user clicks OK, we should take the values from the controls and
// actually perform the EXPAND command:
//
//		EXPAND <source-dir>\*.cab -F:<filename> <destination-dir>
//-----------------------------------------------------------------------------

void CExpandDlg::OnOK() 
{
	CString strSource, strFile, strDestination, strParams;

	GetDlgItemText(IDC_EDITFILE, strFile);
	GetDlgItemText(IDC_COMBOFROM, strSource);
	GetDlgItemText(IDC_COMBOTO, strDestination);

	strFile.TrimRight();
	strSource.TrimRight();
	strDestination.TrimRight();

	// If any of the strings are empty, inform the user and don't exit.

	if (strFile.IsEmpty() || strSource.IsEmpty() || strDestination.IsEmpty())
	{
		Message(IDS_EXPANDEMPTYFIELD, m_hWnd);
		return;
	}

	// Validate the strings as much as possible:
	//
	// strFile			- check to see if this looks like a real file name
	// strSource		- make sure this file exists
	// strDestination	- make sure this directory exists

	if (strFile.FindOneOf(_T("*?\\/")) != -1)
	{
		Message(IDS_EXPANDBADFILE, m_hWnd);
		return;
	}

	if (!FileExists(strSource))
	{
		Message(IDS_EXPANDSOURCEDOESNTEXIST, m_hWnd);
		return;
	}

	CString strTemp(strDestination);
	strTemp.TrimRight(_T("\\"));
	if (strTemp.GetLength() == 2 && strTemp[1] == _T(':'))
	{
		// The user has just specified a drive. Check to see if the drive letter
		// exists.

		UINT nType = ::GetDriveType(strTemp);
		if (DRIVE_UNKNOWN == nType || DRIVE_NO_ROOT_DIR == nType)
		{
			Message(IDS_EXPANDDESTDOESNTEXIST, m_hWnd);
			return;
		}
	}
	else if (!FileExists(strDestination))
	{
		Message(IDS_EXPANDDESTDOESNTEXIST, m_hWnd);
		return;
	}

	// Add the strings from the To and From combo boxes to the history lists
	// (if they aren't already in them) and write those lists to the registry.

	TCHAR	szValueName[3];
	int		index;

	if (!strSource.IsEmpty() && NULL == m_listFromStrings.Find(strSource))
	{
		m_listFromStrings.AddHead(strSource);

		CRegKey regkey;
		HKEY hkey = GetRegKey(_T("ExpandFrom"));
		if (hkey != NULL)
		{
			regkey.Attach(hkey);
			index = 0;
			while (!m_listFromStrings.IsEmpty() && index < 10)
			{
				_itot(index++, szValueName, 10);
				regkey.SetValue(m_listFromStrings.RemoveHead(), szValueName);
			}
		}
	}

	if (!strDestination.IsEmpty() && NULL == m_listToStrings.Find(strDestination))
	{
		m_listToStrings.AddHead(strDestination);

		CRegKey regkey;
		HKEY hkey = GetRegKey(_T("ExpandTo"));
		if (hkey != NULL)
		{
			regkey.Attach(hkey);
			index = 0;
			while (!m_listToStrings.IsEmpty() && index < 10)
			{
				_itot(index++, szValueName, 10);
				regkey.SetValue(m_listToStrings.RemoveHead(), szValueName);
			}
		}
	}

	// If any of the strings contain spaces, it will need quotes around it.

	if (strDestination.Find(_T(' ')) != -1)
		strDestination = _T("\"") + strDestination + _T("\"");

	if (strSource.Find(_T(' ')) != -1)
		strSource = _T("\"") + strSource + _T("\"");

	if (strFile.Find(_T(' ')) != -1)
		strFile = _T("\"") + strFile + _T("\"");

	TCHAR szCommand[MAX_PATH];
	if (::GetSystemDirectory(szCommand, MAX_PATH))
	{
		CString strCommand(szCommand);
		strCommand += _T("\\expand.exe");
		strParams.Format(_T("%s -f:%s %s"), strSource, strFile, strDestination);
		::ShellExecute(NULL, _T("open"), strCommand, strParams, strDestination, SW_HIDE);

		// Useful for debugging:
		// 
		// strParams = _T("Executed:\n\n") + CString(szCommand) + _T(" ") + strParams;
		// ::AfxMessageBox(strParams);
	}
	CDialog::OnOK();
}

//-----------------------------------------------------------------------------
// Allow the user to browse for the file to be expanded. Once the file is
// found, put the name of the file in the edit control and the path of the
// file in the To combo box (since the user is likely to want to expand to
// that location).
//-----------------------------------------------------------------------------

void CExpandDlg::OnBrowseFile() 
{
	CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST);

	if (IDOK == dlg.DoModal())
	{
		CString strFile(dlg.GetFileName());
		SetDlgItemText(IDC_EDITFILE, strFile);

		CString strPath(dlg.GetPathName());
		strPath = strPath.Left(strPath.GetLength() - strFile.GetLength());
		SetDlgItemText(IDC_COMBOTO, strPath);
	}
}

//-----------------------------------------------------------------------------
// This lets the user browse for the CAB file to be used in the expand.
//-----------------------------------------------------------------------------

void CExpandDlg::OnBrowseFrom() 
{
	CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, _T("*.cab|*.cab||"));

	if (IDOK == dlg.DoModal())
		SetDlgItemText(IDC_COMBOFROM, dlg.GetPathName());
}

//-----------------------------------------------------------------------------
// This is a general purpose routine to allow the user to pick a folder (since
// there is no common dialog for this, it uses SHBrowseForFolder()).
//-----------------------------------------------------------------------------

BOOL BrowseForFolder(CString & strPath, UINT uiPromptID, HWND hwnd)
{
	BOOL		fReturn = FALSE;
	CString		strPrompt(_T(""));
	IMalloc *	pMalloc;

	if (FAILED(::SHGetMalloc(&pMalloc)))
		return FALSE;

	if (uiPromptID != 0)
		strPrompt.LoadString(uiPromptID);

	BROWSEINFO bi;
	bi.hwndOwner		= hwnd;
	bi.pidlRoot			= NULL;
	bi.pszDisplayName	= NULL;
	bi.lpszTitle		= (strPrompt.IsEmpty()) ? NULL : (LPCTSTR)strPrompt;
	bi.ulFlags			= BIF_RETURNONLYFSDIRS;
	bi.lpfn				= NULL;
	bi.lParam			= 0;

	LPITEMIDLIST pItemList = ::SHBrowseForFolder(&bi);
	if (pItemList != NULL)
	{
		TCHAR szPath[MAX_PATH];
		if (::SHGetPathFromIDList(pItemList, szPath))
		{
			strPath = szPath;
			fReturn = TRUE;
		}
		pMalloc->Free((void *)pItemList);
	}

	pMalloc->Release();
	return fReturn;
}

//-----------------------------------------------------------------------------
// This button allows the user to select the location for the expanded file.
//-----------------------------------------------------------------------------

void CExpandDlg::OnBrowseTo() 
{
	CString strPath;
	if (BrowseForFolder(strPath, IDS_SELECTTO, m_hWnd))
		SetDlgItemText(IDC_COMBOTO, strPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\msconfig.h ===
// MSConfig.h : main header file for the MSCONFIG application
//

#if !defined(AFX_MSCONFIG_H__E8C06876_EEE6_49C2_B461_07F39EECC0B8__INCLUDED_)
#define AFX_MSCONFIG_H__E8C06876_EEE6_49C2_B461_07F39EECC0B8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
// #include "MSConfig_i.h"

//=============================================================================
// Constants used in MSConfig (done as defines since this include file might
// be included multiple times).
//=============================================================================

#define MSCONFIGDIR			_T("%systemroot%\\pss")
#define MSCONFIGUNDOLOG		_T("msconfig.log")
#define COMMANDLINE_AUTO	_T("/auto")

/////////////////////////////////////////////////////////////////////////////
// CMSConfigApp:
// See MSConfig.cpp for the implementation of this class
//

class CMSConfigApp : public CWinApp
{
public:
	CMSConfigApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMSConfigApp)
	public:
	virtual BOOL InitInstance();
		virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMSConfigApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	//---------------------------------------------------------------------------
	// DoIExist is a way of detecting if another version of this app is
	// running - it avoids the problem of rapid invocations succeeding before
	// the window is created. It uses a semaphore to tell if we are already
	// running somewhere else.
	//---------------------------------------------------------------------------

	BOOL DoIExist(LPCTSTR szSemName)
	{
		HANDLE hSem;

		hSem = CreateSemaphore(NULL, 0, 1, szSemName);

		if (hSem != NULL && GetLastError() == ERROR_ALREADY_EXISTS)
		{
			CloseHandle(hSem);
			return TRUE;
		}

		return FALSE;
	}

	//---------------------------------------------------------------------------
	// FirstInstance is used to keep the app from loading multiple times. If this
	// is the first instance to run, this function returns TRUE. Otherwise it
	// activates the previous instance and returns FALSE. It looks for the
	// previous instance based on the window title.
	//---------------------------------------------------------------------------

	BOOL FirstInstance()
	{
		if (DoIExist(_T("MSConfigRunning")))
		{
			CString strCaption;

  			if (strCaption.LoadString(IDS_DIALOGCAPTION))
			{
				CWnd *PrevCWnd = CWnd::FindWindow(NULL, strCaption);
	  			if (PrevCWnd)
	  			{
	    			CWnd *ChildCWnd = PrevCWnd->GetLastActivePopup();
	    			PrevCWnd->SetForegroundWindow();
	    			if (PrevCWnd->IsIconic()) 
	       				PrevCWnd->ShowWindow(SW_RESTORE);
	    			if (PrevCWnd != ChildCWnd) 
	       				ChildCWnd->SetForegroundWindow();
	  			}
			}

			return (FALSE);
		}

		return (TRUE);
	}

	void InitializePages();
	BOOL ShowPropertySheet(int nInitialTab);
	void CleanupPages();
	void SetAutoRun(BOOL fAutoRun);
	void Reboot();

private:
	BOOL m_bATLInited;
private:
	BOOL InitATL();
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSCONFIG_H__E8C06876_EEE6_49C2_B461_07F39EECC0B8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\expanddlg.h ===
#if !defined(AFX_EXPANDDLG_H__9114AA62_7289_43FD_AC71_164FD869C6D9__INCLUDED_)
#define AFX_EXPANDDLG_H__9114AA62_7289_43FD_AC71_164FD869C6D9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ExpandDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CExpandDlg dialog

class CExpandDlg : public CDialog
{
// Construction
public:
	CExpandDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CExpandDlg)
	enum { IDD = IDD_EXTRACT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExpandDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CExpandDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnBrowseFile();
	afx_msg void OnBrowseFrom();
	afx_msg void OnBrowseTo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CStringList			m_listFromStrings;
	CStringList			m_listToStrings;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXPANDDLG_H__9114AA62_7289_43FD_AC71_164FD869C6D9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\essentialsvcdlg.h ===
#if !defined(AFX_ESSENTIALSVCDLG_H__BCD454BA_35D5_4506_A603_821BA5BF1B0E__INCLUDED_)
#define AFX_ESSENTIALSVCDLG_H__BCD454BA_35D5_4506_A603_821BA5BF1B0E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EssentialSvcDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEssentialServiceDialog dialog

class CEssentialServiceDialog : public CDialog
{
// Construction
public:
	CEssentialServiceDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEssentialServiceDialog)
	enum { IDD = IDD_ESSENTIALSERVICE };
	BOOL	m_fDontShow;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEssentialServiceDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEssentialServiceDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ESSENTIALSVCDLG_H__BCD454BA_35D5_4506_A603_821BA5BF1B0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\msconfig.cpp ===
//=============================================================================
// MSConfig.cpp
//
// This contains the high level implementation of MSConfig - this class
// creates all of the pages and displays a property sheet.
//=============================================================================

#include "stdafx.h"
#include "MSConfig.h"
#include <initguid.h>
#include "MSConfig_i.c"
#include "MSConfigState.h"
#include "PageServices.h"
#include "PageStartup.h"
#include "PageBootIni.h"
#include "PageIni.h"
#include "PageGeneral.h"
#include "MSConfigCtl.h"
#include "AutoStartDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MSCONFIGDIR			_T("%systemroot%\\pss")

//-----------------------------------------------------------------------------
// These global variables are pointers to each of the property pages shown
// in MSConfig. They are made global so that each page can potential make
// calls into other pages, to allow interaction.
//-----------------------------------------------------------------------------

CPageServices *	ppageServices = NULL;
CPageStartup *	ppageStartup = NULL;
CPageBootIni *	ppageBootIni = NULL;
CPageIni *		ppageWinIni = NULL;
CPageIni *		ppageSystemIni = NULL;
CPageGeneral *	ppageGeneral = NULL;

//-----------------------------------------------------------------------------
// Other globals.
//-----------------------------------------------------------------------------

CMSConfigSheet * pMSConfigSheet = NULL;		// global pointer to the property sheet

/////////////////////////////////////////////////////////////////////////////
// CMSConfigApp

BEGIN_MESSAGE_MAP(CMSConfigApp, CWinApp)
	//{{AFX_MSG_MAP(CMSConfigApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------
// Constructor. Nothing important here.
//-----------------------------------------------------------------------------

CMSConfigApp::CMSConfigApp()
{
}

CMSConfigApp theApp;

//-----------------------------------------------------------------------------
// InitInstance is where we create the property sheet and show it (assuming
// there isn't a command line flag to do otherwise).
//-----------------------------------------------------------------------------

BOOL	fBasicControls = FALSE;		// hide any advanced controls if true

BOOL CMSConfigApp::InitInstance()
{
	if (!InitATL())
		return FALSE;

	AfxEnableControlContainer();

	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
		return TRUE;
	}

	// If this is not the first instance, exit. The call to FirstInstance
	// will activate the previous instance.

	if (!FirstInstance())
		return FALSE;

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	// of your final executable, you should remove from the following
	// the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Process the command line to see if one of the following flags have been set:
	//
	//	/n (where n is a number)	startup showing the nth tab
	//	/basic						hide advanced features
	//	/commit n					make changes from tab number n permanent
	//	/auto						show the automatic launch dialog

	int		nInitialTab = 0;
	int		nCommitTab = 0;
	BOOL	fShowAutoDialog = FALSE;
	CString strCommandLine(m_lpCmdLine);
	CString strFlag, strTemp;

	strCommandLine.MakeLower();
	while (!strCommandLine.IsEmpty())
	{
		// Get the next flag from the command line (starting at a / or -,
		// and containing the text to the end of the string or the next
		// instance of a / or -).

		int iFlag = strCommandLine.FindOneOf(_T("/-"));
		if (iFlag == -1)
			break;

		strFlag = strCommandLine.Mid(iFlag + 1);
		strFlag = strFlag.SpanExcluding(_T("/-"));
		strCommandLine = strCommandLine.Mid(iFlag + 1 + strFlag.GetLength());
		strFlag.TrimRight();

		// Check for the /auto flag.

		if (strFlag.Find(_T("auto")) == 0)
			fShowAutoDialog = TRUE;

		// Check for the "/basic" flag.

		if (strFlag.Compare(_T("basic")) == 0)
		{
			fBasicControls = TRUE;
			continue;
		}

		// Check for the "/commit n" flag.

		if (strFlag.Left(6) == CString(_T("commit")))
		{
			// Find out which tab number to commit. Skip all of the
			// non-numeric characters.

			strTemp = strFlag.SpanExcluding(_T("0123456789"));
			if (strTemp.GetLength() < strFlag.GetLength())
			{
				strFlag = strFlag.Mid(strTemp.GetLength());
				if (!strFlag.IsEmpty())
				{
					TCHAR c = strFlag[0];
					if (_istdigit(c))
						nCommitTab = _ttoi((LPCTSTR)strFlag);
				}
			}

			continue;
		}

		// Finally, check for the "/n" flag, where n is the number of
		// the tab to initially display.

		if (strFlag.GetLength() == 1)
		{
			TCHAR c = strFlag[0];
			if (_istdigit(c))
				nInitialTab = _ttoi((LPCTSTR)strFlag);
		}
	}

	// Show the automatic launch dialog. The user may make settings in this
	// dialog that will keep MSConfig from automatically launching.

	if (fShowAutoDialog)
	{
		CAutoStartDlg dlg;
		dlg.DoModal();

		if (dlg.m_checkDontShow)
		{
			SetAutoRun(FALSE);
			return FALSE;
		}
	}

	// Check to see if the user is going to be able to make changes using MSConfig
	// (if not an admin, probably not). If the user doesn't have the necessary
	// privileges, don't run. Bug 475796.

	BOOL fModifyServices = FALSE, fModifyRegistry = FALSE;

	// Check to see if the user will be able to modify services.

	SC_HANDLE sch = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (sch != NULL)
	{
		fModifyServices = TRUE;
		::CloseServiceHandle(sch);
	}

	// Check to see if the user can modify the registry.

	HKEY hkey;
	if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools"), 0, KEY_WRITE, &hkey))
	{
		fModifyRegistry = TRUE;
		::RegCloseKey(hkey);
	}
	
	// If the user can't do both actions, exit now.

	if (!fModifyServices || !fModifyRegistry)
	{
		CString strText, strCaption;
		strCaption.LoadString(IDS_DIALOGCAPTION);
		strText.LoadString(IDS_NOPERMISSIONS);
		::MessageBox(NULL, strText, strCaption, MB_OK | MB_ICONSTOP);
		return FALSE;
	}

	// This will load all the pages.

	BOOL fNeedsReboot = FALSE;
	InitializePages();

	// If the command line specifies to commit a change, we won't
	// show the dialog.

	if (nCommitTab > 1) // ignore zero (no flag) and one (general tab)
	{
		CPageBase * pPage = NULL;
		CString		strTabCaption;

		if (NULL == ppageBootIni && nCommitTab >= 4)
			nCommitTab += 1; // adjust tab number if there is no BOOT.INI tab

		switch (nCommitTab)
		{
		case 2:
			pPage = dynamic_cast<CPageBase *>(ppageSystemIni);
			strTabCaption.LoadString(IDS_SYSTEMINI_CAPTION);
			break;
		case 3:
			pPage = dynamic_cast<CPageBase *>(ppageWinIni);
			strTabCaption.LoadString(IDS_WININI_CAPTION);
			break;
		case 4:
			pPage = dynamic_cast<CPageBase *>(ppageBootIni);
			strTabCaption.LoadString(IDS_BOOTINI_CAPTION);
			break;
		case 5:
			pPage = dynamic_cast<CPageBase *>(ppageServices);
			strTabCaption.LoadString(IDS_SERVICES_CAPTION);
			break;
		case 6:
			pPage = dynamic_cast<CPageBase *>(ppageStartup);
			strTabCaption.LoadString(IDS_STARTUP_CAPTION);
			break;
		}

		if (pPage)
		{
			CString strText, strCaption;
			strCaption.LoadString(IDS_DIALOGCAPTION);
			strText.Format(IDS_COMMITMESSAGE, strTabCaption);
			
			if (IDYES == ::MessageBox(NULL, strText, strCaption, MB_YESNO))
				pPage->CommitChanges();
		}
	}
	else
		fNeedsReboot = ShowPropertySheet(nInitialTab);

	CleanupPages();

	if (fNeedsReboot)
		Reboot();

	// Since the dialog has been closed, return FALSE so that we exit the
	// application, rather than start the application's message pump.

	return FALSE;
}


//-----------------------------------------------------------------------------
// Create all of the property pages. This function also contains the logic to
// exclude property pages under certain circumstances (for example, if there
// is no BOOT.INI file, don't create that page). TBD.
//-----------------------------------------------------------------------------

void CMSConfigApp::InitializePages()
{
	// The boot.ini tab shouldn't be added if the file doesn't exist (for
	// instance, on Win64).

	CString strBootINI(_T("c:\\boot.ini"));

	// Check the registry for a testing flag (which would mean we aren't
	// operating on the real BOOT.INI file).

	CRegKey regkey;
	if (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools\\MSConfig")))
	{
		TCHAR szBoot[MAX_PATH];
		DWORD dwCount = MAX_PATH;

		if (ERROR_SUCCESS == regkey.QueryValue(szBoot, _T("boot.ini"), &dwCount))
			strBootINI = szBoot;
	}

	if (FileExists(strBootINI))
		ppageBootIni = new CPageBootIni;
	else
		ppageBootIni = NULL;

	ppageServices = new CPageServices;
	ppageStartup = new CPageStartup;
	ppageWinIni = new CPageIni;
	ppageSystemIni = new CPageIni;
	ppageGeneral = new CPageGeneral;

	ppageWinIni->SetTabInfo(_T("win.ini"));
	ppageSystemIni->SetTabInfo(_T("system.ini"));
}

//-----------------------------------------------------------------------------
// Show the MSConfig property sheet. This function returns whether or not
// the computer should be rebooted.
//-----------------------------------------------------------------------------

BOOL CMSConfigApp::ShowPropertySheet(int nInitialTab)
{
	CMSConfigSheet sheet(IDS_DIALOGCAPTION, NULL, (nInitialTab > 0) ? nInitialTab - 1 : 0);

	// Add each of the pages to the property sheet.

	if (ppageGeneral)	sheet.AddPage(ppageGeneral);
	if (ppageSystemIni)	sheet.AddPage(ppageSystemIni);
	if (ppageWinIni)	sheet.AddPage(ppageWinIni);
	if (ppageBootIni)	sheet.AddPage(ppageBootIni);
	if (ppageServices)	sheet.AddPage(ppageServices);
	if (ppageStartup)	sheet.AddPage(ppageStartup);

	// Show the property sheet.

	pMSConfigSheet = &sheet;
	INT_PTR iReturn = sheet.DoModal();
	pMSConfigSheet = NULL;

	// Possibly set MSConfig to automatically run on boot, and
	// check to see if we need to restart.

	BOOL fRunMSConfigOnBoot = FALSE;
	BOOL fNeedToRestart = FALSE;

	CPageBase * apPages[5] = 
	{	
		ppageSystemIni,
		ppageWinIni,
		ppageBootIni,
		ppageServices,
		ppageStartup
	};

	for (int nPage = 0; nPage < 5; nPage++)
		if (apPages[nPage])
		{
			fRunMSConfigOnBoot |= (CPageBase::NORMAL != apPages[nPage]->GetAppliedTabState());
			fNeedToRestart |= apPages[nPage]->HasAppliedChanges();

			if (fRunMSConfigOnBoot && fNeedToRestart)
				break;
		}

	// If the user didn't click CANCEL, or the user applied a change, then
	// we should set whether or not MSConfig needs to automatically run on boot.

	if (fNeedToRestart || iReturn != IDCANCEL)
		SetAutoRun(fRunMSConfigOnBoot);

	return (fNeedToRestart);
}

//-----------------------------------------------------------------------------
// Cleanup the global property pages.
//-----------------------------------------------------------------------------

void CMSConfigApp::CleanupPages()
{
	if (ppageGeneral)	delete ppageGeneral;
	if (ppageSystemIni)	delete ppageSystemIni;
	if (ppageWinIni)	delete ppageWinIni;
	if (ppageBootIni)	delete ppageBootIni;
	if (ppageServices)	delete ppageServices;
	if (ppageStartup)	delete ppageStartup;
}

//-------------------------------------------------------------------------
// This function will set the appropriate registry key to make msconfig run
// on system start.
//-------------------------------------------------------------------------

void CMSConfigApp::SetAutoRun(BOOL fAutoRun)
{
	LPCTSTR	szRegKey = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
	LPCTSTR	szRegVal = _T("MSConfig");

	CRegKey regkey;
	if (ERROR_SUCCESS != regkey.Open(HKEY_LOCAL_MACHINE, szRegKey))
		return;

	if (fAutoRun)
	{
		TCHAR szModulePath[MAX_PATH + 1];
		DWORD dwLength = ::GetModuleFileName(::GetModuleHandle(NULL), szModulePath, MAX_PATH);
		if (dwLength == 0)
			return;
		szModulePath[dwLength] = _T('\0');

		if (!FileExists(szModulePath))
			return;

		CString strNewVal = CString(_T("\"")) + CString(szModulePath) + CString(_T("\" ")) + CString(COMMANDLINE_AUTO);
		regkey.SetValue(strNewVal, szRegVal);
	}
	else
		regkey.DeleteValue(szRegVal);
}

//-----------------------------------------------------------------------------
// Not much explanation needed here. The user is given an option to not
// restart the system.
//-----------------------------------------------------------------------------

void CMSConfigApp::Reboot()
{
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());

	if (hProcess)
	{
		HANDLE hToken;

		if (OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &hToken))
		{
			TOKEN_PRIVILEGES tp;

			tp.PrivilegeCount = 1;
			tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	
			if (LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tp.Privileges[0].Luid) && 
				AdjustTokenPrivileges(hToken, FALSE, &tp, NULL, NULL, NULL) && 
				(GetLastError() == ERROR_SUCCESS))
			{
				CRebootDlg dlg;
				
				if (dlg.DoModal() == IDOK)
					ExitWindowsEx(EWX_REBOOT, 0);
			}
			else
				Message(IDS_USERSHOULDRESTART);
		}
		CloseHandle(hProcess);
	}
}



CMSConfigModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

LONG CMSConfigModule::Unlock()
{
	AfxOleUnlockApp();
	return 0;
}

LONG CMSConfigModule::Lock()
{
	AfxOleLockApp();
	return 1;
}
LPCTSTR CMSConfigModule::FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p)
				return CharNext(p1);
			p = CharNext(p);
		}
		p1++;
	}
	return NULL;
}


int CMSConfigApp::ExitInstance()
{
	if (m_bATLInited)
	{
		_Module.RevokeClassObjects();
		_Module.Term();
		CoUninitialize();
	}

	return CWinApp::ExitInstance();

}

BOOL CMSConfigApp::InitATL()
{
	m_bATLInited = TRUE;

#if _WIN32_WINNT >= 0x0400
	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
	HRESULT hRes = CoInitialize(NULL);
#endif

	if (FAILED(hRes))
	{
		m_bATLInited = FALSE;
		return FALSE;
	}

	_Module.Init(ObjectMap, AfxGetInstanceHandle());
	_Module.dwThreadID = GetCurrentThreadId();

	LPTSTR lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
	TCHAR szTokens[] = _T("-/");

	BOOL bRun = TRUE;
	LPCTSTR lpszToken = _Module.FindOneOf(lpCmdLine, szTokens);
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_MSCONFIG, FALSE);
			_Module.UnregisterServer(TRUE); //TRUE means typelib is unreg'd
			bRun = FALSE;
			break;
		}
		if (lstrcmpi(lpszToken, _T("RegServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_MSCONFIG, TRUE);
			_Module.RegisterServer(TRUE);
			bRun = FALSE;
			break;
		}
		lpszToken = _Module.FindOneOf(lpszToken, szTokens);
	}

	if (!bRun)
	{
		m_bATLInited = FALSE;
		_Module.Term();
		CoUninitialize();
		return FALSE;
	}

	hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
		REGCLS_MULTIPLEUSE);
	if (FAILED(hRes))
	{
		m_bATLInited = FALSE;
		CoUninitialize();
		return FALSE;
	}	

	return TRUE;

}

//=============================================================================
// Implement the utility functions described in msconfigstate.h
//=============================================================================

void Message(LPCTSTR szMessage, HWND hwndParent)
{
	CString strCaption;
	strCaption.LoadString(IDS_APPCAPTION);
	if (hwndParent != NULL || pMSConfigSheet == NULL)
		::MessageBox(hwndParent, szMessage, strCaption, MB_OK);
	else
		::MessageBox(pMSConfigSheet->GetSafeHwnd(), szMessage, strCaption, MB_OK);
}

void Message(UINT uiMessage, HWND hwndParent)
{
	CString strMessage;
	strMessage.LoadString(uiMessage);
	Message((LPCTSTR)strMessage, hwndParent);
}

HKEY GetRegKey(LPCTSTR szSubKey)
{
	LPCTSTR szMSConfigKey = _T("SOFTWARE\\Microsoft\\Shared Tools\\MSConfig");
	CString strKey(szMSConfigKey);
	HKEY	hkey = NULL;

	// Try to open the base MSConfig key. If it succeeds, and there is no
	// subkey to open, return the HKEY. Otherwise, we need to create the
	// base key.

	if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMSConfigKey, 0, KEY_ALL_ACCESS, &hkey))
	{
		if (szSubKey == NULL)
			return hkey;
		::RegCloseKey(hkey);
	}
	else
	{
		// Create the MSConfig key (and close it).

		HKEY hkeyBase;
		if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools"), 0, KEY_ALL_ACCESS, &hkeyBase))
		{
			if (ERROR_SUCCESS == RegCreateKeyEx(hkeyBase, _T("MSConfig"), 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL))
				::RegCloseKey(hkey);
			::RegCloseKey(hkeyBase);
		}
	}

	if (szSubKey)
		strKey += CString(_T("\\")) + CString(szSubKey);

	if (ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, &hkey))
	{
		// If we couldn't open the subkey, then we should try to create it.

		if (szSubKey)
		{
			HKEY hkeyBase;
			if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMSConfigKey, 0, KEY_ALL_ACCESS, &hkeyBase))
			{
				if (ERROR_SUCCESS != RegCreateKeyEx(hkeyBase, szSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL))
					hkey = NULL;
				::RegCloseKey(hkeyBase);
			}
	 	}
	}

	return hkey;
}

HRESULT BackupFile(LPCTSTR szFilename, const CString & strAddedExtension, BOOL fOverwrite)
{
	CString strFrom(szFilename);
	CString strTo(GetBackupName(szFilename, strAddedExtension));

	if (!fOverwrite && FileExists(strTo))
		return S_FALSE;

	::SetFileAttributes(strTo, FILE_ATTRIBUTE_NORMAL);
	if (::CopyFile(strFrom, strTo, FALSE))
	{
		::SetFileAttributes(strTo, FILE_ATTRIBUTE_NORMAL);
		return S_OK;
	}

	return E_FAIL;
}

CString strBackupDir; // global string containing the path of the backup directory
const CString GetBackupName(LPCTSTR szFilename, const CString & strAddedExtension)
{
	// There should be a directory for MSConfig files. Make sure it exists
	// (create it if it doesn't).

	if (strBackupDir.IsEmpty())
	{
		TCHAR szMSConfigDir[MAX_PATH];

		if (MAX_PATH > ::ExpandEnvironmentStrings(MSCONFIGDIR, szMSConfigDir, MAX_PATH))
		{
			strBackupDir = szMSConfigDir;
			if (!FileExists(strBackupDir))
				::CreateDirectory(strBackupDir, NULL);
		}
	}

	CString strFrom(szFilename);
	int		i = strFrom.ReverseFind(_T('\\'));
	CString strFile(strFrom.Mid(i + 1));
	CString strTo(strBackupDir + _T("\\") + strFile + strAddedExtension);

	return strTo;
}

HRESULT RestoreFile(LPCTSTR szFilename, const CString & strAddedExtension, BOOL fOverwrite)
{
	CString strTo(szFilename);
	int		i = strTo.ReverseFind(_T('\\'));
	CString strFile(strTo.Mid(i + 1));
	CString strFrom(strBackupDir + _T("\\") + strFile + strAddedExtension);

	if (!fOverwrite && FileExists(strTo))
		return S_FALSE;

	DWORD dwAttributes = ::GetFileAttributes(strTo);
	::SetFileAttributes(strTo, FILE_ATTRIBUTE_NORMAL);
	if (::CopyFile(strFrom, strTo, FALSE))
	{
		::SetFileAttributes(strTo, dwAttributes);
		return S_OK;
	}

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\msconfigctl.h ===
// MSConfigCtl.h : Declaration of the CMSConfigCtl

#include "resource.h"       // main symbols
#include <atlhost.h>
#include "pagebase.h"
#include "msconfigstate.h"
#include "rebootdlg.h"

#if !defined(AFX_MSCONFIGSHEET_H__44ACE461_A2D0_4CEA_B9C8_CE2A16FE355E__INCLUDED_)
#define AFX_MSCONFIGSHEET_H__44ACE461_A2D0_4CEA_B9C8_CE2A16FE355E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MSConfigSheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMSConfigSheet

class CMSConfigSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMSConfigSheet)

// Construction
public:
	CMSConfigSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMSConfigSheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

	afx_msg void OnHelp();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMSConfigSheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMSConfigSheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMSConfigSheet)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	int		m_iSelectedPage;	// initial page to select
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSCONFIGSHEET_H__44ACE461_A2D0_4CEA_B9C8_CE2A16FE355E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\msconfigctl.cpp ===
#include "stdafx.h"
#include "Msconfig.h"
#include "MSConfigCtl.h"
#include "pagebase.h"
#include "pagegeneral.h"
#include "pagebootini.h"
#include "pageini.h"
#include "pageservices.h"
#include "pagestartup.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMSConfigSheet

IMPLEMENT_DYNAMIC(CMSConfigSheet, CPropertySheet)

CMSConfigSheet::CMSConfigSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage) : CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
	m_iSelectedPage = iSelectPage;
	m_psh.dwFlags |= PSH_USEPAGELANG;
}

CMSConfigSheet::CMSConfigSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage) : CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
	m_iSelectedPage = iSelectPage;
	m_psh.dwFlags |= PSH_USEPAGELANG;
}

CMSConfigSheet::~CMSConfigSheet()
{
}


BEGIN_MESSAGE_MAP(CMSConfigSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CMSConfigSheet)
	ON_WM_HELPINFO()
	ON_COMMAND(ID_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------
// Catch the help messages to show the MSConfig help file.
//-----------------------------------------------------------------------------

BOOL CMSConfigSheet::OnHelpInfo(HELPINFO * pHelpInfo) 
{
	TCHAR szHelpPath[MAX_PATH];

	// Try to find a localized help file to open (bug 460691). It should be
	// located in %windir%\help\mui\<LANGID>.

	if (::ExpandEnvironmentStrings(_T("%SystemRoot%\\help\\mui"), szHelpPath, MAX_PATH))
	{
		CString strLanguageIDPath;

		LANGID langid = GetUserDefaultUILanguage();
		strLanguageIDPath.Format(_T("%s\\%04x\\msconfig.chm"), szHelpPath, langid);

		if (FileExists(strLanguageIDPath))
		{
			::HtmlHelp(::GetDesktopWindow(), strLanguageIDPath, HH_DISPLAY_TOPIC, 0);
			return TRUE;
		}
	}

	if (::ExpandEnvironmentStrings(_T("%windir%\\help\\msconfig.chm"), szHelpPath, MAX_PATH))
		::HtmlHelp(::GetDesktopWindow(), szHelpPath, HH_DISPLAY_TOPIC, 0); 
	return TRUE;
}

void CMSConfigSheet::OnHelp()
{
    OnHelpInfo(NULL);
}

//-----------------------------------------------------------------------------
// Override this so we can make each page the active page, forcing each one's
// OnInitDialog to be called.
//-----------------------------------------------------------------------------

extern CPageIni * ppageSystemIni;

BOOL CMSConfigSheet::OnInitDialog() 
{
	CPropertySheet::OnInitDialog();

	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32.

	HICON hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	SetIcon(hIcon, TRUE);			// Set big icon
	SetIcon(hIcon, FALSE);		// Set small icon

	// Change the caption of the system.ini tab.

	if (ppageSystemIni)
	{
		int nItem = GetPageIndex(ppageSystemIni);
		if (nItem > 0)
		{
			CTabCtrl * pTabs = GetTabControl();
			if (pTabs)
			{
				CString strCaption;
				strCaption.LoadString(IDS_SYSTEMINI_CAPTION);
	
				TCITEM tci;
				tci.mask = TCIF_TEXT;
				tci.pszText = (LPTSTR)(LPCTSTR)strCaption;

				pTabs->SetItem(nItem, &tci);
			}
		}
	}

	// Set each page active (before we make the dialog visible) to force
	// the WM_INITDIALOG message to be sent.

	for (int iPage = 0; iPage < GetPageCount(); iPage++)
		SetActivePage(iPage);
	SetActivePage(m_iSelectedPage);

	return TRUE;  // return TRUE unless you set the focus to a control
}

//-----------------------------------------------------------------------------
// Check to see if the specified file (with path information) exists on
// the machine.
//-----------------------------------------------------------------------------

BOOL FileExists(const CString & strFile)
{
	WIN32_FIND_DATA finddata;
	HANDLE			h = FindFirstFile(strFile, &finddata);

	if (INVALID_HANDLE_VALUE != h)
	{
		FindClose(h);
		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\mscfgver.h ===
//-----------------------------------------------------------------------------
// This class is useful for retrieving information about a specific file. It
// uses the version resource code from Dr. Watson. To use it, create an
// instance of the class, and use the QueryFile method to query information
// about a specific file. Then use the Get* access functions to get the 
// values describing the information.
//-----------------------------------------------------------------------------

class CFileVersionInfo
{
public:
	//-------------------------------------------------------------------------
	// Local structures and macros used to retrieve the file version information.
	// These are necessary to use to the Dr. Watson codebase without too much
	// modification.
	//-------------------------------------------------------------------------

	struct VERSIONSTATE 
	{
		PVOID  pvData;
		TCHAR  tszLang[9];
		TCHAR  tszLang2[9];
	};

	struct FILEVERSION 
	{
		TCHAR   tszFileVersion[32];         /* File version */
		TCHAR   tszDesc[MAX_PATH];          /* File description */
		TCHAR   tszCompany[MAX_PATH];       /* Manufacturer */
		TCHAR   tszProduct[MAX_PATH];       /* Enclosing product */
	};

    CFileVersionInfo();
    ~CFileVersionInfo();

    HRESULT QueryFile(LPCSTR szFile, BOOL fHasDoubleBackslashes = FALSE);
    HRESULT QueryFile(LPCWSTR szFile, BOOL fHasDoubleBackslashes = FALSE);

    LPCTSTR GetVersion();
    LPCTSTR GetDescription();
    LPCTSTR GetCompany();
    LPCTSTR GetProduct();

private:
    FILEVERSION * m_pfv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\msconfigfind.cpp ===
// MSConfigFind.cpp : implementation file
//

#include "stdafx.h"
#include "msconfig.h"
#include "MSConfigFind.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMSConfigFind dialog


CMSConfigFind::CMSConfigFind(CWnd* pParent /*=NULL*/)
	: CDialog(CMSConfigFind::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMSConfigFind)
	m_fSearchFromTop = FALSE;
	m_strSearchFor = _T("");
	//}}AFX_DATA_INIT
}


void CMSConfigFind::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMSConfigFind)
	DDX_Check(pDX, IDC_CHECK1, m_fSearchFromTop);
	DDX_Text(pDX, IDC_SEARCHFOR, m_strSearchFor);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMSConfigFind, CDialog)
	//{{AFX_MSG_MAP(CMSConfigFind)
	ON_EN_CHANGE(IDC_SEARCHFOR, OnChangeSearchFor)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSConfigFind message handlers

void CMSConfigFind::OnChangeSearchFor() 
{
	CString str;
	GetDlgItemText(IDC_SEARCHFOR, str);

	::EnableWindow(GetDlgItem(IDOK)->GetSafeHwnd(), !str.IsEmpty());
}

BOOL CMSConfigFind::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	CString str;
	GetDlgItemText(IDC_SEARCHFOR, str);
	::EnableWindow(GetDlgItem(IDOK)->GetSafeHwnd(), !str.IsEmpty());
	return TRUE;  // return TRUE unless you set the focus to a control
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\msconfigdlg.h ===
// MSConfigDlg.h : header file
//

#if !defined(AFX_MSCONFIGDLG_H__E6475690_391F_43DF_AB12_D4971EC9E2B6__INCLUDED_)
#define AFX_MSCONFIGDLG_H__E6475690_391F_43DF_AB12_D4971EC9E2B6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "MSConfigCtl.h"

/////////////////////////////////////////////////////////////////////////////
// CMSConfigDlg dialog

class CMSConfigDlg : public CDialog
{
// Construction
public:
	CMSConfigDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMSConfigDlg)
	enum { IDD = IDD_MSCONFIG_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMSConfigDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	CMSConfigCtl	m_ctl;
	BOOL			m_fShowInfoDialog;		// TRUE if we should show the info dialog on startup

	// Generated message map functions
	//{{AFX_MSG(CMSConfigDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnButtonApply();
	afx_msg void OnButtonCancel();
	afx_msg void OnButtonOK();
	afx_msg void OnSelChangeMSConfigTab(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelChangingMSConfigTab(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClose();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnButtonHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSCONFIGDLG_H__E6475690_391F_43DF_AB12_D4971EC9E2B6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\msconfigfind.h ===
#if !defined(AFX_MSCONFIGFIND_H__66E289A9_5E98_4FB2_85F4_62102B485C86__INCLUDED_)
#define AFX_MSCONFIGFIND_H__66E289A9_5E98_4FB2_85F4_62102B485C86__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MSConfigFind.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMSConfigFind dialog

class CMSConfigFind : public CDialog
{
// Construction
public:
	CMSConfigFind(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMSConfigFind)
	enum { IDD = IDD_FINDDLG };
	BOOL	m_fSearchFromTop;
	CString	m_strSearchFor;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMSConfigFind)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMSConfigFind)
	afx_msg void OnChangeSearchFor();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSCONFIGFIND_H__66E289A9_5E98_4FB2_85F4_62102B485C86__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\msconfigstate.h ===
//=============================================================================
// This file describes helpful functions used throughout MSConfig.
//=============================================================================

#pragma once

#include "resource.h"
#include "pagebase.h"

extern BOOL FileExists(const CString & strFile);

//-------------------------------------------------------------------------
// Display a message to the user, either using a resource ID or a string.
//-------------------------------------------------------------------------

extern void Message(LPCTSTR szMessage, HWND hwndParent = NULL);
extern void Message(UINT uiMessage, HWND hwndParent = NULL);

//-------------------------------------------------------------------------
// Get a registry key for MSConfig use (tab pages can write values under
// this key). The caller is responsible for closing the key.
//
// If the key doesn't exist, then an attempt is made to create it.
//-------------------------------------------------------------------------

extern HKEY GetRegKey(LPCTSTR szSubKey = NULL);

//-------------------------------------------------------------------------
// Backup the specified file to the MSConfig directory. The 
// strAddedExtension will be appended to the file. If fOverwrite is FALSE
// then an existing file won't be replaced.
//-------------------------------------------------------------------------

extern HRESULT BackupFile(LPCTSTR szFilename, const CString & strAddedExtension = _T(""), BOOL fOverwrite = TRUE);

//-------------------------------------------------------------------------
// Restore the specified file from the MSConfig directory. The 
// strAddedExtension will be used in searching for the file in the backup
// directory. If fOverwrite is FALSE then an existing file won't
// be replaced.
//-------------------------------------------------------------------------

extern HRESULT RestoreFile(LPCTSTR szFilename, const CString & strAddedExtension = _T(""), BOOL fOverwrite = FALSE);

//-------------------------------------------------------------------------
// Get the name of the backup file (generated from an extension and the
// base name of the file to be backed up).
//-------------------------------------------------------------------------

extern const CString GetBackupName(LPCTSTR szFilename, const CString & strAddedExtension = _T(""));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pagebase.cpp ===
//=============================================================================
// Implementation for some functions in the CPageBase class (most are
// implented inline in the .h file). For descriptions of usage, refer to the
// header file.
//=============================================================================

#include "stdafx.h"
#include <atlhost.h>
#include "MSConfig.h"
#include "MSConfigState.h"
#include "PageBase.h"

//-----------------------------------------------------------------------------
// GetAppliedTabState()
//-----------------------------------------------------------------------------

CPageBase::TabState CPageBase::GetAppliedTabState()
{
	TabState tabstate = NORMAL;
	CRegKey regkey;
	regkey.Attach(GetRegKey(_T("state")));

	if ((HKEY)regkey != NULL)
	{
		DWORD dwValue;
		if (ERROR_SUCCESS == regkey.QueryValue(dwValue, GetName()))
			tabstate = (TabState)dwValue;
	}

	return tabstate;
}

//-----------------------------------------------------------------------------
// SetAppliedState()
//-----------------------------------------------------------------------------

void CPageBase::SetAppliedState(TabState state)
{
	CRegKey regkey;
	regkey.Attach(GetRegKey(_T("state")));

	if ((HKEY)regkey != NULL)
		regkey.SetValue((DWORD)state, GetName());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\msconfigdlg.cpp ===
// MSConfigDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MSConfig.h"
#include "MSConfigDlg.h"
#include "MSConfigState.h"
#include "AutoStartDlg.h"
#include <htmlhelp.h>

extern CMSConfigApp theApp;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSConfigDlg dialog

CMSConfigDlg::CMSConfigDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMSConfigDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMSConfigDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMSConfigDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMSConfigDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMSConfigDlg, CDialog)
	//{{AFX_MSG_MAP(CMSConfigDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTONAPPLY, OnButtonApply)
	ON_BN_CLICKED(IDC_BUTTONCANCEL, OnButtonCancel)
	ON_BN_CLICKED(IDC_BUTTONOK, OnButtonOK)
	ON_NOTIFY(TCN_SELCHANGE, IDC_MSCONFIGTAB, OnSelChangeMSConfigTab)
	ON_NOTIFY(TCN_SELCHANGING, IDC_MSCONFIGTAB, OnSelChangingMSConfigTab)
	ON_WM_CLOSE()
	ON_WM_HELPINFO()
	ON_BN_CLICKED(IDC_BUTTONHELP, OnButtonHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSConfigDlg message handlers

BOOL CMSConfigDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	CString strCommandLine(theApp.m_lpCmdLine);
	strCommandLine.MakeLower();

	// If we are being run with the auto command line (we're being automatically
	// run when the user boots) then we should display an informational dialog
	// (unless the user has indicated to not show the dialog).

	m_fShowInfoDialog = FALSE;
	if (strCommandLine.Find(COMMANDLINE_AUTO) != -1)
	{
		CMSConfigState * pState = m_ctl.GetState();
		if (pState)
		{
			CRegKey regkey;
			DWORD	dwValue;

			regkey.Attach(pState->GetRegKey());
			if (ERROR_SUCCESS != regkey.QueryValue(dwValue, _T("HideAutoNotification")) || dwValue != 1)
				m_fShowInfoDialog = TRUE;
		}
	}

	// Initialize the CMSConfigCtl object which does most of the work for
	// this application.

	m_ctl.Initialize(this, IDC_BUTTONAPPLY, IDC_PLACEHOLDER, IDC_MSCONFIGTAB, strCommandLine);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CMSConfigDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMSConfigDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}

	if (m_fShowInfoDialog)
	{
		m_fShowInfoDialog = FALSE;

		CAutoStartDlg dlg;
		dlg.DoModal();
		if (dlg.m_checkDontShow)
		{
			CMSConfigState * pState = m_ctl.GetState();
			if (pState)
			{
				CRegKey regkey;

				regkey.Attach(pState->GetRegKey());
				regkey.SetValue(1, _T("HideAutoNotification"));
			}
		}
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMSConfigDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CMSConfigDlg::OnButtonApply() 
{
	m_ctl.OnClickedButtonApply();
}

void CMSConfigDlg::OnButtonCancel() 
{
	m_ctl.OnClickedButtonCancel();
	EndDialog(0);
}

void CMSConfigDlg::OnButtonOK() 
{
	m_ctl.OnClickedButtonOK();
	EndDialog(0);
}

void CMSConfigDlg::OnSelChangeMSConfigTab(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_ctl.OnSelChangeMSConfigTab();
	*pResult = 0;
}

void CMSConfigDlg::OnSelChangingMSConfigTab(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_ctl.OnSelChangingMSConfigTab();
	*pResult = 0;
}

void CMSConfigDlg::OnClose() 
{
	OnButtonCancel();
	CDialog::OnClose();
}

BOOL CMSConfigDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	TCHAR szHelpPath[MAX_PATH];

	if (::ExpandEnvironmentStrings(_T("%windir%\\help\\msconfig.chm"), szHelpPath, MAX_PATH))
		::HtmlHelp(m_hWnd, szHelpPath, HH_DISPLAY_TOPIC, 0); 
	return TRUE;
}

void CMSConfigDlg::OnButtonHelp() 
{
	OnHelpInfo(NULL);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pagebase.h ===
//=============================================================================
// CPageBase defines a class which is an interface from which the tab page
// classes will inherit (using multiple inheritance). These methods will be
// called by the main MSConfig control to create and manipulate the pages.
//=============================================================================

#pragma once

extern BOOL FileExists(const CString & strFile);

class CPageBase
{
public:
	//-------------------------------------------------------------------------
	// This enumeration is used by the tab to communicate its state. NORMAL
	// means that the tab has made no changes to the system. DIAGNOSTIC
	// means the tab has disabled as much as possible. USER means an in-
	// between state (the user has disabled some things).
	//-------------------------------------------------------------------------

	typedef enum { NORMAL, DIAGNOSTIC, USER } TabState;

public:
	CPageBase() : m_fMadeChange(FALSE), m_fInitialized(FALSE) { }
	virtual ~CPageBase() { }

	//-------------------------------------------------------------------------
	// Get the tab state. These two functions will return the current tab
	// state, or the state which was last applied to the system.
	//
	// For the default implementation, the base pages should not override the
	// GetAppliedTabState() function, as long as they call 
	// CPageBase::SetAppliedState() when changes are applied.
	//-------------------------------------------------------------------------

	virtual TabState GetCurrentTabState() = 0;
	virtual TabState GetAppliedTabState();

	//-------------------------------------------------------------------------
	// CommitChanges() is called when the changes made by this tab are to be
	// made permanent. This base class version can be called if the derived
	// class is letting the base class maintain the applied state.
	//-------------------------------------------------------------------------

	virtual void CommitChanges()
	{
		SetAppliedState(NORMAL);
	}

	//-------------------------------------------------------------------------
	// MadeChanges() should return TRUE if this tab has applied changes to the
	// system. This is checked when determining if the computer should be
	// restarted when MSConfig exits. If the tab maintains the m_fMadeChange
	// variable, this doesn't need to be overridden.
	//-------------------------------------------------------------------------

	virtual BOOL HasAppliedChanges()
	{
		return m_fMadeChange;
	}

	//-------------------------------------------------------------------------
	// GetName() should return the name of this tab. This is an internal,
	// non-localized name.
	//-------------------------------------------------------------------------

	virtual LPCTSTR GetName() = 0;

	//-------------------------------------------------------------------------
	// The following two member functions are called to when the user makes
	// a global change to a tab's state (on the general tab).
	//-------------------------------------------------------------------------

	virtual void SetNormal() = 0;
	virtual void SetDiagnostic() = 0;

protected:
	//-------------------------------------------------------------------------
	// Sets the applied tab state (if the derived class is allowing the base
	// class to maintain this).
	//-------------------------------------------------------------------------

	void SetAppliedState(TabState state);

protected:
	BOOL		m_fMadeChange;	// has the tab applied changes to the system?
	BOOL		m_fInitialized;	// has OnInitDialog() been called?
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pagebootini.cpp ===
#include "stdafx.h"
#include "PageBootIni.h"
#include "MSConfigState.h"
#include "BootAdv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPageBootIni property page

IMPLEMENT_DYNCREATE(CPageBootIni, CPropertyPage)

CPageBootIni::CPageBootIni() : CPropertyPage(CPageBootIni::IDD)
{
	//{{AFX_DATA_INIT(CPageBootIni)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_fIgnoreEdit	= FALSE;
	m_strFileName	= BOOT_INI;
	m_fModified		= FALSE;
}

CPageBootIni::~CPageBootIni()
{
}

void CPageBootIni::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPageBootIni)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPageBootIni, CPropertyPage)
	//{{AFX_MSG_MAP(CPageBootIni)
	ON_BN_CLICKED(IDC_BOOTMOVEDOWN, OnBootMoveDown)
	ON_BN_CLICKED(IDC_BOOTMOVEUP, OnBootMoveUp)
	ON_LBN_SELCHANGE(IDC_LISTBOOTINI, OnSelChangeList)
	ON_BN_CLICKED(IDC_BASEVIDEO, OnClickedBase)
	ON_BN_CLICKED(IDC_BOOTLOG, OnClickedBootLog)
	ON_BN_CLICKED(IDC_NOGUIBOOT, OnClickedNoGUIBoot)
	ON_BN_CLICKED(IDC_SOS, OnClickedSOS)
	ON_BN_CLICKED(IDC_SAFEBOOT, OnClickedSafeBoot)
	ON_BN_CLICKED(IDC_SBDSREPAIR, OnClickedSBDSRepair)
	ON_BN_CLICKED(IDC_SBMINIMAL, OnClickedSBMinimal)
	ON_BN_CLICKED(IDC_SBMINIMALALT, OnClickedSBMinimalAlt)
	ON_BN_CLICKED(IDC_SBNETWORK, OnClickedSBNetwork)
	ON_EN_CHANGE(IDC_EDITTIMEOUT, OnChangeEditTimeOut)
	ON_EN_KILLFOCUS(IDC_EDITTIMEOUT, OnKillFocusEditTimeOut)
	ON_BN_CLICKED(IDC_BOOTADVANCED, OnClickedBootAdvanced)
	ON_BN_CLICKED(IDC_SETASDEFAULT, OnClickedSetAsDefault)
	ON_BN_CLICKED(IDC_CHECKBOOTPATHS, OnClickedCheckBootPaths)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPageBootIni message handlers

//-------------------------------------------------------------------------
// Initialize this page by reading the contents of the boot.ini file.
//-------------------------------------------------------------------------

void CPageBootIni::InitializePage()
{
	if (LoadBootIni() && m_nMinOSIndex != -1)
	{
		SyncControlsToIni();
		if (m_nMinOSIndex != -1)
		{
			::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, m_nMinOSIndex, 0);
			SelectLine(m_nMinOSIndex);
		}
	}
	else
	{
		// Failed to load the boot.ini file (or it was empty). Disable all controls.

		::EnableWindow(GetDlgItemHWND(IDC_BOOTMOVEUP), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_BOOTMOVEDOWN), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_SAFEBOOT), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_NOGUIBOOT), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_BOOTLOG), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_BASEVIDEO), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_SOS), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_BOOTADVANCED), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_SBNETWORK), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_SBDSREPAIR), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_SBMINIMAL), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_SBMINIMALALT), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_SETASDEFAULT), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_CHECKBOOTPATHS), FALSE);
		::EnableWindow(GetDlgItemHWND(IDC_EDITTIMEOUT), FALSE);
	}

	m_stateCurrent = CPageBase::GetAppliedTabState();
}

//-------------------------------------------------------------------------
// Load the contents of the BOOT.INI file into our local structures.
//-------------------------------------------------------------------------

BOOL CPageBootIni::LoadBootIni(CString strFileName)
{
	if (strFileName.IsEmpty())
		strFileName = m_strFileName;

	// Read the contents of the boot.ini file into a string.

	HANDLE h = ::CreateFile(strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE == h)
		return FALSE;

	CString strContents;
	DWORD	dwNumberBytesRead, dwNumberBytesToRead = ::GetFileSize(h, NULL);

	// The BOOT.INI file is ANSI, so we should read it and convert to Unicode.

	char * szBuffer = new char[dwNumberBytesToRead + 1];
	::ZeroMemory((PVOID)szBuffer, dwNumberBytesToRead + 1);
	if (!::ReadFile(h, (LPVOID)szBuffer, dwNumberBytesToRead, &dwNumberBytesRead, NULL))
		*szBuffer = _T('\0');
	::CloseHandle(h);

	// Do the conversion.

	USES_CONVERSION;
	LPTSTR szConverted = A2T(szBuffer);
	strContents = szConverted;
	delete [] szBuffer;

	if (dwNumberBytesToRead != dwNumberBytesRead || strContents.IsEmpty())
		return FALSE;

	// Save the original contents of the file.

	m_strOriginalContents = strContents;

	// Parse the contents of the string into an array of strings (one for each line
	// of the file).

	m_arrayIniLines.RemoveAll();
	m_arrayIniLines.SetSize(10, 10);

	CString strLine;
	int		nIndex = 0;

	while (!strContents.IsEmpty())
	{
		strLine = strContents.SpanExcluding(_T("\r\n"));
		if (!strLine.IsEmpty())
		{
			m_arrayIniLines.SetAtGrow(nIndex, strLine);
			nIndex += 1;
		}
		strContents = strContents.Mid(strLine.GetLength());
		strContents.TrimLeft(_T("\r\n"));
	}

	// Look through the lines read from the INI file, searching for particular
	// ones we'll want to make a note of.

	m_nTimeoutIndex = m_nDefaultIndex = m_nMinOSIndex = m_nMaxOSIndex = -1;
	for (int i = 0; i <= m_arrayIniLines.GetUpperBound(); i++)
	{
		CString strScanLine = m_arrayIniLines[i];
		strScanLine.MakeLower();
		strScanLine.Replace(_T(" "), _T(""));

		if (strScanLine.Find(_T("timeout=")) != -1)
			m_nTimeoutIndex = i;
		else if (strScanLine.Find(_T("default=")) != -1)
			m_nDefaultIndex = i;

		if (m_nMinOSIndex != -1 && m_nMaxOSIndex == -1 && (strScanLine.IsEmpty() || strScanLine[0] == _T('[')))
			m_nMaxOSIndex = i - 1;
		else if (strScanLine.Find(_T("[operatingsystems]")) != -1)
			m_nMinOSIndex = i + 1;
	}
	
	if (m_nMinOSIndex != -1 && m_nMaxOSIndex == -1)
		m_nMaxOSIndex = i - 1;

	return TRUE;
}

//----------------------------------------------------------------------------
// Update the state of the controls on this tab to match the contents of the
// internal representation of the INI file.
//----------------------------------------------------------------------------

void CPageBootIni::SyncControlsToIni(BOOL fSyncEditField)
{
	// We need to keep track of the extent of the strings in the list box
	// (to handle a horizontal scroll bar). Code from MSDN.

	DWORD		dwExtent, dwMaxExtent = 0;
	TEXTMETRIC	tm;

	HDC hDCListBox = ::GetDC(GetDlgItemHWND(IDC_LISTBOOTINI));
	HFONT hFontNew = (HFONT)::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), WM_GETFONT, NULL, NULL);
	HFONT hFontOld = (HFONT)::SelectObject(hDCListBox, hFontNew);
	::GetTextMetrics(hDCListBox, (LPTEXTMETRIC)&tm);

	CDC dc;
	dc.Attach(hDCListBox);
	for (int i = 0; i <= m_arrayIniLines.GetUpperBound(); i++)
		if (!m_arrayIniLines[i].IsEmpty())
		{
			CSize size = dc.GetTextExtent(m_arrayIniLines[i]);
			dwExtent = size.cx + tm.tmAveCharWidth;
			if (dwExtent > dwMaxExtent)
				dwMaxExtent = dwExtent;
		}
	dc.Detach();

	::SelectObject(hDCListBox, hFontOld);
	::ReleaseDC(GetDlgItemHWND(IDC_LISTBOOTINI), hDCListBox);

	// Set the extent for the list box.

	::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETHORIZONTALEXTENT, (WPARAM)dwMaxExtent, 0);

	// First, add the lines from the boot ini into the list control.
	
	::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_RESETCONTENT, 0, 0);
	for (int j = 0; j <= m_arrayIniLines.GetUpperBound(); j++)
		if (!m_arrayIniLines[j].IsEmpty())
			::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)m_arrayIniLines[j]);

	// Set the timeout value based on the boot.ini.

	if (m_nTimeoutIndex != -1 && fSyncEditField)
	{
		CString strTimeout = m_arrayIniLines[m_nTimeoutIndex];
		strTimeout.TrimLeft(_T("timeout= "));
		m_fIgnoreEdit = TRUE;
		SetDlgItemText(IDC_EDITTIMEOUT, strTimeout);
		m_fIgnoreEdit = FALSE;
	}
}

//----------------------------------------------------------------------------
// Update the controls based on the user's selection of a line.
//----------------------------------------------------------------------------

void CPageBootIni::SelectLine(int index)
{
	if (index < m_nMinOSIndex)
	{
		::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, m_nMinOSIndex, 0);
		SelectLine(m_nMinOSIndex);
		return;
	}

	if (index > m_nMaxOSIndex)
	{
		::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, m_nMaxOSIndex, 0);
		SelectLine(m_nMaxOSIndex);
		return;
	}

	HWND hwndFocus = ::GetFocus();

	::EnableWindow(GetDlgItemHWND(IDC_BOOTMOVEUP), (index > m_nMinOSIndex));
	::EnableWindow(GetDlgItemHWND(IDC_BOOTMOVEDOWN), (index < m_nMaxOSIndex));

	if ((index <= m_nMinOSIndex) && hwndFocus == GetDlgItemHWND(IDC_BOOTMOVEUP))
		NextDlgCtrl();

	if ((index >= m_nMaxOSIndex) && hwndFocus == GetDlgItemHWND(IDC_BOOTMOVEDOWN))
		PrevDlgCtrl();

	CString strOS = m_arrayIniLines[index];
	strOS.MakeLower();

	CheckDlgButton(IDC_SAFEBOOT, (strOS.Find(_T("/safeboot")) != -1));
	CheckDlgButton(IDC_NOGUIBOOT, (strOS.Find(_T("/noguiboot")) != -1));
	CheckDlgButton(IDC_BOOTLOG, (strOS.Find(_T("/bootlog")) != -1));
	CheckDlgButton(IDC_BASEVIDEO, (strOS.Find(_T("/basevideo")) != -1));
	CheckDlgButton(IDC_SOS, (strOS.Find(_T("/sos")) != -1));

	// If the line selected isn't for Whistler, then disable the controls.
	// If the line is for Whistler or W2K, but it has the string "CMDCONS" in
	// it, we shouldn't enable the controls.

	BOOL fEnableControls = ((strOS.Find(_T("whistler")) != -1) || (strOS.Find(_T("windows 2000")) != -1));
	fEnableControls |= ((strOS.Find(_T("windowsxp")) != -1) || (strOS.Find(_T("windows xp")) != -1));
	fEnableControls |= (strOS.Find(_T("windows server 2003")) != -1);
	fEnableControls = fEnableControls && (strOS.Find(_T("cmdcons")) == -1);
	::EnableWindow(GetDlgItemHWND(IDC_SAFEBOOT), fEnableControls);
	::EnableWindow(GetDlgItemHWND(IDC_NOGUIBOOT), fEnableControls);
	::EnableWindow(GetDlgItemHWND(IDC_BOOTLOG), fEnableControls);
	::EnableWindow(GetDlgItemHWND(IDC_BASEVIDEO), fEnableControls);
	::EnableWindow(GetDlgItemHWND(IDC_SOS), fEnableControls);
	::EnableWindow(GetDlgItemHWND(IDC_BOOTADVANCED), fEnableControls);

	BOOL fSafeboot = (strOS.Find(_T("/safeboot")) != -1);
	::EnableWindow(GetDlgItemHWND(IDC_SBNETWORK), fSafeboot && fEnableControls);
	::EnableWindow(GetDlgItemHWND(IDC_SBDSREPAIR), fSafeboot && fEnableControls);
	::EnableWindow(GetDlgItemHWND(IDC_SBMINIMAL), fSafeboot && fEnableControls);
	::EnableWindow(GetDlgItemHWND(IDC_SBMINIMALALT), fSafeboot && fEnableControls);

	if (fSafeboot)
	{
		CheckDlgButton(IDC_SBNETWORK, (strOS.Find(_T("/safeboot:network")) != -1));
		CheckDlgButton(IDC_SBDSREPAIR, (strOS.Find(_T("/safeboot:dsrepair")) != -1));

		if (strOS.Find(_T("/safeboot:minimal")) != -1)
		{
			BOOL fAlternateShell = (strOS.Find(_T("/safeboot:minimal(alternateshell)")) != -1);
			CheckDlgButton(IDC_SBMINIMAL, !fAlternateShell);
			CheckDlgButton(IDC_SBMINIMALALT, fAlternateShell);
		}
		else
		{
			CheckDlgButton(IDC_SBMINIMAL, FALSE);
			CheckDlgButton(IDC_SBMINIMALALT, FALSE);
		}

		int iSafeboot = strOS.Find(_T("/safeboot"));
		if (iSafeboot != -1)
		{
			m_strSafeBoot = strOS.Mid(iSafeboot + 1);
			m_strSafeBoot = m_strSafeBoot.SpanExcluding(_T(" /"));
			m_strSafeBoot = CString(_T("/")) + m_strSafeBoot;
		}
	}

	// Check to see if the selected operating system is the default.
	// Then enable the button accordingly.

	BOOL fEnableDefault = FALSE;
	if (m_nDefaultIndex >= 0)
	{
		CString strDefault = m_arrayIniLines[m_nDefaultIndex];
		int iEquals = strDefault.Find(_T('='));
		if (iEquals != -1)
		{
			strDefault = strDefault.Mid(iEquals + 1);
			strDefault.MakeLower();
			CString strCurrent = strOS.SpanExcluding(_T("="));

			strDefault.TrimLeft();
			strCurrent.TrimRight();

			if (strDefault != strCurrent || index > m_nMinOSIndex)
				fEnableDefault = TRUE;
		}
	}

	::EnableWindow(GetDlgItemHWND(IDC_SETASDEFAULT), fEnableDefault);
	if (!fEnableDefault && hwndFocus == GetDlgItemHWND(IDC_SETASDEFAULT))
		NextDlgCtrl();
}

//-------------------------------------------------------------------------
// Add or remove the specified flag from the currently selected OS line.
//-------------------------------------------------------------------------

void CPageBootIni::ChangeCurrentOSFlag(BOOL fAdd, LPCTSTR szFlag)
{
	int		iSelection = (int)::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_GETCURSEL, 0, 0);
	CString strFlagPlusSpace = CString(_T(" ")) + szFlag;
	CString strNewLine;

	if (iSelection == -1)
		return;

	if (fAdd)
	{
		if (m_arrayIniLines[iSelection].Find(szFlag) != -1)
		{
			ASSERT(0 && "the flag is already there");
			return;
		}
		strNewLine = m_arrayIniLines[iSelection] + strFlagPlusSpace;
	}
	else
	{
		int iIndex = m_arrayIniLines[iSelection].Find(strFlagPlusSpace);
		if (iIndex == -1)
		{
			ASSERT(0 && "there is no flag");
			return;
		}
		strNewLine = m_arrayIniLines[iSelection].Left(iIndex);
		strNewLine += m_arrayIniLines[iSelection].Mid(iIndex + strFlagPlusSpace.GetLength());
	}

	m_arrayIniLines.SetAt(iSelection, strNewLine);
	UserMadeChange();
	SyncControlsToIni();
	::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, iSelection, 0);
}

//-------------------------------------------------------------------------
// Sets the "default=" line in the boot.ini.
//-------------------------------------------------------------------------

void CPageBootIni::SetDefaultOS(int iIndex)
{
	if (m_nDefaultIndex == -1)
		return;

	// Get the current string "default=xxxx". Locate the location of the 
	// '=' so we can replace the later half of the line.

	CString strDefault = m_arrayIniLines[m_nDefaultIndex];
	int iEquals = strDefault.Find(_T('='));
	if (iEquals == -1)
		return;

	CString strValue = m_arrayIniLines[iIndex].SpanExcluding(_T("="));
	strValue.TrimRight();

	CString strNewDefault = strDefault.Left(iEquals + 1) + strValue;
	m_arrayIniLines.SetAt(m_nDefaultIndex, strNewDefault);
}

//-------------------------------------------------------------------------
// Write new contents to the BOOT.INI file.
//-------------------------------------------------------------------------

BOOL CPageBootIni::SetBootIniContents(const CString & strNewContents, const CString & strAddedExtension)
{
	// Extra safety code.

	if ((LPCTSTR)strNewContents == NULL || *((LPCTSTR)strNewContents) == _T('\0'))
		return FALSE;

	// To write to the BOOT.INI file, we need to set it to have normal
	// attributes. Save the attribute settings so we can restore them.

	DWORD dwWritten, dwAttribs = ::GetFileAttributes(m_strFileName);
	::SetFileAttributes(m_strFileName, FILE_ATTRIBUTE_NORMAL);

	HANDLE h = ::CreateFile(m_strFileName, GENERIC_WRITE, 0, NULL, TRUNCATE_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE == h)
	{
		::SetFileAttributes(m_strFileName, dwAttribs);
		return FALSE;
	}

	// Convert the internal BOOT.INI representation (Unicode) to ANSI for writing.

	USES_CONVERSION;
	LPSTR szBuffer = T2A((LPTSTR)(LPCTSTR)strNewContents);

	// CreateFile with TRUNCATE_EXISTING seems to SOMETIMES not set the file length to
	// zero, but to overwrite the existing file with zeroes and leave the pointer at
	// the end of the file.

	::SetFilePointer(h, 0, NULL, FILE_BEGIN);
	::WriteFile(h, (void *)szBuffer, strNewContents.GetLength(), &dwWritten, NULL);
	::SetEndOfFile(h);
	::CloseHandle(h);
	::SetFileAttributes(m_strFileName, dwAttribs);

	return TRUE;
}

//-------------------------------------------------------------------------
// We need to subclass the edit control to catch the enter key, so we
// can validate the data and not close MSConfig.
//-------------------------------------------------------------------------

CPageBootIni * pBootIniPage = NULL;	// pointer to the page, so we can call member functions
WNDPROC pOldBootIniEditProc = NULL; // save old wndproc when we subclass edit control
LRESULT BootIniEditSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
	switch (wm)
	{
	case WM_GETDLGCODE:
		return DLGC_WANTALLKEYS;

	case WM_CHAR:
		if (wp == VK_ESCAPE || wp == VK_RETURN)
		{
			if (pBootIniPage != NULL)
			{
				pBootIniPage->NextDlgCtrl();
				return 0;
			}
		}
		else if (wp == VK_TAB)
		{
			if (pBootIniPage != NULL)
			{
				if (::GetAsyncKeyState(VK_SHIFT) == 0)
					pBootIniPage->NextDlgCtrl();
				else
					pBootIniPage->PrevDlgCtrl();
				return 0;
			}
		}
		break;
	}

	if (pOldBootIniEditProc != NULL)	// better not be null
		return CallWindowProc(pOldBootIniEditProc, hwnd, wm, wp, lp);
	return 0;
}

//-------------------------------------------------------------------------
// Initialize the boot.ini page. Read in the INI file, set up internal
// structures to represent the file, and update the controls to reflect
// the internal structures.
//-------------------------------------------------------------------------

extern BOOL fBasicControls;
BOOL CPageBootIni::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	// Check the registry for a testing flag (which would mean we aren't
	// operating on the real BOOT.INI file). Removed for release.
	// 
	// CRegKey regkey;
	// if (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Shared Tools\\MSConfig")))
	// {
	// 	TCHAR szBoot[MAX_PATH];
	// 	DWORD dwCount = MAX_PATH;
	// 
	// 	if (ERROR_SUCCESS == regkey.QueryValue(szBoot, _T("boot.ini"), &dwCount))
	// 		m_strFileName = szBoot;
	// }

	InitializePage();

	if (fBasicControls)
		::ShowWindow(GetDlgItemHWND(IDC_BOOTADVANCED), SW_HIDE);

	// Subclass the edit control (to catch the enter key).

	HWND hWndEdit = GetDlgItemHWND(IDC_EDITTIMEOUT);
	if (hWndEdit)
	{
		pOldBootIniEditProc = (WNDPROC)::GetWindowLongPtr(hWndEdit, GWLP_WNDPROC);
		pBootIniPage = this;
		::SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (ULONG_PTR)(WNDPROC)&BootIniEditSubclassProc);
	}

	m_fInitialized = TRUE;
	return TRUE;  // return TRUE unless you set the focus to a control
}

//-------------------------------------------------------------------------
// Called when the user clicks move up or down.
//-------------------------------------------------------------------------

void CPageBootIni::OnBootMoveDown() 
{
	int iSelection = (int)::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_GETCURSEL, 0, 0);
	
	ASSERT(iSelection >= m_nMinOSIndex && iSelection < m_nMaxOSIndex);
	if (iSelection >= m_nMinOSIndex && iSelection < m_nMaxOSIndex)
	{
		CString strTemp = m_arrayIniLines[iSelection + 1];
		m_arrayIniLines.SetAt(iSelection + 1, m_arrayIniLines[iSelection]);
		m_arrayIniLines.SetAt(iSelection, strTemp);
		UserMadeChange();
		SyncControlsToIni();
		::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, iSelection + 1, 0);
		SelectLine(iSelection + 1);
	}
}

void CPageBootIni::OnBootMoveUp() 
{
	int iSelection = (int)::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_GETCURSEL, 0, 0);
	
	ASSERT(iSelection > m_nMinOSIndex && iSelection <= m_nMaxOSIndex);
	if (iSelection > m_nMinOSIndex && iSelection <= m_nMaxOSIndex)
	{
		CString strTemp = m_arrayIniLines[iSelection - 1];
		m_arrayIniLines.SetAt(iSelection - 1, m_arrayIniLines[iSelection]);
		m_arrayIniLines.SetAt(iSelection, strTemp);
		UserMadeChange();
		SyncControlsToIni();
		::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, iSelection - 1, 0);
		SelectLine(iSelection - 1);
	}
}

//-------------------------------------------------------------------------
// Called when the user clicks on a line in the list view.
//-------------------------------------------------------------------------

void CPageBootIni::OnSelChangeList() 
{
	SelectLine((int)::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_GETCURSEL, 0, 0));
}

//-------------------------------------------------------------------------
// The check boxes are handled uniformly - adding or removing a flag from
// the currently selected OS line.
//-------------------------------------------------------------------------

void CPageBootIni::OnClickedBase() 
{
	ChangeCurrentOSFlag(IsDlgButtonChecked(IDC_BASEVIDEO), _T("/basevideo"));
}

void CPageBootIni::OnClickedBootLog() 
{
	ChangeCurrentOSFlag(IsDlgButtonChecked(IDC_BOOTLOG), _T("/bootlog"));
}

void CPageBootIni::OnClickedNoGUIBoot() 
{
	ChangeCurrentOSFlag(IsDlgButtonChecked(IDC_NOGUIBOOT), _T("/noguiboot"));
}

void CPageBootIni::OnClickedSOS() 
{
	ChangeCurrentOSFlag(IsDlgButtonChecked(IDC_SOS), _T("/sos"));
}

//-------------------------------------------------------------------------
// The safeboot flag is a little more complicated, since it has an extra
// portion (from the radio buttons).
//-------------------------------------------------------------------------

void CPageBootIni::OnClickedSafeBoot() 
{
	CString strFlag(_T("/safeboot"));

	if (IsDlgButtonChecked(IDC_SBNETWORK))
		strFlag += _T(":network");
	else if (IsDlgButtonChecked(IDC_SBDSREPAIR))
		strFlag += _T(":dsrepair");
	else if (IsDlgButtonChecked(IDC_SBMINIMALALT))
		strFlag += _T(":minimal(alternateshell)");
	else
	{
		strFlag += _T(":minimal");
		CheckDlgButton(IDC_SBMINIMAL, 1);
	}

	BOOL fSafeBoot = IsDlgButtonChecked(IDC_SAFEBOOT);
	ChangeCurrentOSFlag(fSafeBoot, strFlag);
	m_strSafeBoot = strFlag;
	::EnableWindow(GetDlgItemHWND(IDC_SBNETWORK), fSafeBoot);
	::EnableWindow(GetDlgItemHWND(IDC_SBDSREPAIR), fSafeBoot);
	::EnableWindow(GetDlgItemHWND(IDC_SBMINIMAL), fSafeBoot);
	::EnableWindow(GetDlgItemHWND(IDC_SBMINIMALALT), fSafeBoot);
}

//-------------------------------------------------------------------------
// Clicking on one of the safeboot radio buttons requires a little extra
// processing, to remove the existing flag and add the new one.
//-------------------------------------------------------------------------

void CPageBootIni::OnClickedSBDSRepair() 
{
	ChangeCurrentOSFlag(FALSE, m_strSafeBoot);
	m_strSafeBoot = _T("/safeboot:dsrepair");
	ChangeCurrentOSFlag(TRUE, m_strSafeBoot);
}

void CPageBootIni::OnClickedSBMinimal() 
{
	ChangeCurrentOSFlag(FALSE, m_strSafeBoot);
	m_strSafeBoot = _T("/safeboot:minimal");
	ChangeCurrentOSFlag(TRUE, m_strSafeBoot);
}

void CPageBootIni::OnClickedSBMinimalAlt() 
{
	ChangeCurrentOSFlag(FALSE, m_strSafeBoot);
	m_strSafeBoot = _T("/safeboot:minimal(alternateshell)");
	ChangeCurrentOSFlag(TRUE, m_strSafeBoot);
}

void CPageBootIni::OnClickedSBNetwork() 
{
	ChangeCurrentOSFlag(FALSE, m_strSafeBoot);
	m_strSafeBoot = _T("/safeboot:network");
	ChangeCurrentOSFlag(TRUE, m_strSafeBoot);
}

//-------------------------------------------------------------------------
// As the user enters text in the timeout field, update the line in the
// ini file list box.
//-------------------------------------------------------------------------

void CPageBootIni::OnChangeEditTimeOut() 
{
	if (m_fIgnoreEdit)
		return;

	if (m_nTimeoutIndex == -1)
		return;

	CString strTimeout = m_arrayIniLines[m_nTimeoutIndex];
	int iEquals = strTimeout.Find(_T('='));
	if (iEquals == -1)
		return;
	while (strTimeout[iEquals + 1] == _T(' ') && (iEquals + 1) < strTimeout.GetLength())
		iEquals++;

	TCHAR szValue[MAX_PATH];
	GetDlgItemText(IDC_EDITTIMEOUT, szValue, MAX_PATH);
	CString strNewTimeout = strTimeout.Left(iEquals + 1) + szValue;
	m_arrayIniLines.SetAt(m_nTimeoutIndex, strNewTimeout);
	UserMadeChange();
	
	int iSelection = (int)::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_GETCURSEL, 0, 0);
	SyncControlsToIni(FALSE);

	if (iSelection != -1)
		::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, iSelection, 0);
}

void CPageBootIni::OnKillFocusEditTimeOut() 
{
	TCHAR szValue[MAX_PATH];
	GetDlgItemText(IDC_EDITTIMEOUT, szValue, MAX_PATH);
	
	CString strNewValue(_T(""));
	BOOL	fGiveUpFocus = FALSE;

	int iTimeout = _ttoi(szValue);
	if (iTimeout < 3 || iTimeout > 999)
	{
		CString strMessage, strCaption;
		strMessage.LoadString(IDS_TIMEOUTVALUE);
		strCaption.LoadString(IDS_APPCAPTION);
		MessageBox(strMessage, strCaption);

		if (iTimeout < 3)
			strNewValue = _T("3");
		else if (iTimeout > 999)
			strNewValue = _T("999");
	}
	else if (szValue[0] == _T('0'))
	{
		// Remove leading zeros.
		
		strNewValue.Format(_T("%d"), iTimeout);
		fGiveUpFocus = TRUE;
	}

	if (!strNewValue.IsEmpty() && m_nTimeoutIndex != -1)
	{
		CString strTimeout = m_arrayIniLines[m_nTimeoutIndex];
		int iEquals = strTimeout.Find(_T('='));
		if (iEquals != -1)
		{
			while (strTimeout[iEquals + 1] == _T(' ') && (iEquals + 1) < strTimeout.GetLength())
				iEquals++;

			CString strNewTimeout = strTimeout.Left(iEquals + 1) + strNewValue;
			m_arrayIniLines.SetAt(m_nTimeoutIndex, strNewTimeout);
			UserMadeChange();
		}

		SetDlgItemText(IDC_EDITTIMEOUT, strNewValue);
		::SendMessage(GetDlgItemHWND(IDC_EDITTIMEOUT), EM_SETSEL, (WPARAM)0, (LPARAM)-1);
		if (!fGiveUpFocus)
			GotoDlgCtrl(GetDlgItem(IDC_EDITTIMEOUT));
	}
}

//-------------------------------------------------------------------------
// Show the advanced options dialog box.
//-------------------------------------------------------------------------

void CPageBootIni::OnClickedBootAdvanced() 
{
	int iSelection = (int)::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_GETCURSEL, 0, 0);
	if (iSelection > 0)
	{
		CString strLine(m_arrayIniLines[iSelection]);
		CBootIniAdvancedDlg dlg;

		if (dlg.ShowAdvancedOptions(strLine))
		{
			m_arrayIniLines.SetAt(iSelection, strLine);
			UserMadeChange();
			SyncControlsToIni();
			::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, iSelection, 0);
		}
	}
}

//-------------------------------------------------------------------------
// If the user clicks "Set as Default", use the path information from the
// currently selected line to set the new "default=" line.
//-------------------------------------------------------------------------

void CPageBootIni::OnClickedSetAsDefault() 
{
	if (m_fIgnoreEdit)
		return;

	// Move the currently selected line to the top of the [operating systems]
	// section.

	int iSelection = (int)::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_GETCURSEL, 0, 0);
	if (iSelection < m_nMinOSIndex || iSelection > m_nMaxOSIndex)
		return;

	while (iSelection > m_nMinOSIndex)
	{
		CString strTemp = m_arrayIniLines[iSelection - 1];
		m_arrayIniLines.SetAt(iSelection - 1, m_arrayIniLines[iSelection]);
		m_arrayIniLines.SetAt(iSelection, strTemp);
		iSelection -= 1;
	}

	// Get the string from the selected line. Strip off everything after the '='.

	SetDefaultOS(iSelection);
	UserMadeChange();
	SyncControlsToIni(FALSE);
	::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, iSelection, 0);
	SelectLine(iSelection);
}

//-------------------------------------------------------------------------
// This attempts to programmatically check if each of the boot paths is
// valid. If an invalid path is found, the user is given the opportunity
// to remove it from the boot.ini file.
//-------------------------------------------------------------------------

void CPageBootIni::OnClickedCheckBootPaths() 
{
	BOOL	fFoundBadLine = FALSE;
	BOOL	fChangedFile = FALSE;
	BOOL	fWinNTType, fWin9xType;

	CString	strCaption;
	strCaption.LoadString(IDS_APPCAPTION);

	struct { LPCTSTR m_szSearch; BOOL * m_pType; } aOSType[] = 
	{
		{ _T("windows xp"),			&fWinNTType },
		{ _T("windowsxp"),			&fWinNTType },
		{ _T("windows nt"),			&fWinNTType },
		{ _T("whistler"),			&fWinNTType },
		{ _T("windows 2000"),		&fWinNTType },
		{ _T("windows server 2003"),	&fWinNTType },
		{ _T("microsoft windows"),	&fWin9xType },
		{ NULL,						NULL }
	};

	// Scan through each of the operating system lines in the boot.ini file.

	for (int i = m_nMinOSIndex; i <= m_nMaxOSIndex; i++)
	{
		CString strLine = m_arrayIniLines[i];
		strLine.MakeLower();

		// Try to figure out the type of the operating system line.

		fWinNTType = FALSE;
		fWin9xType = FALSE;

		for (int iType = 0; aOSType[iType].m_szSearch != NULL; iType++)
			if (strLine.Find(aOSType[iType].m_szSearch) != -1)
			{
				(*aOSType[iType].m_pType) = TRUE;
				break;
			}

		// Strip off the '=' and everything after it in the boot line.

		int iEquals = strLine.Find(_T('='));
		if (iEquals == -1)
			continue;
		strLine = strLine.Left(iEquals);
		strLine.TrimRight();
		if (strLine.IsEmpty())
			continue;

		// Depending on the type of the OS, we need to verify that it's
		// installed differently.

		if (fWin9xType)
		{
			// Look for the bootsect.dos file to see if this is a good drive.

			CString strCheck(strLine);
			if (strCheck.Right(1) != CString(_T("\\")))
				strCheck += CString(_T("\\"));
			strCheck += CString(_T("bootsect.dos"));
			
			if (FileExists(strCheck))
				continue;
		}
		else if (fWinNTType)
		{
			// If this line is for a recovery console (i.e. the line as "bootsect.dat"
			// in it), then look for the existence of that file.

			if (strLine.Find(_T("bootsect.dat")) != -1)
			{
				if (FileExists(strLine))
					continue;
			}
			else
			{
				// Look for the SYSTEM registry hive.

				CString strCheck(strLine);
				if (strCheck.Right(1) != CString(_T("\\")))
					strCheck += CString(_T("\\"));
				strCheck += CString(_T("system32\\config\\SYSTEM"));
				
				// Add the prefix to attempt to open an ARC path.

				strCheck = CString(_T("\\\\?\\GLOBALROOT\\ArcName\\")) + strCheck;

				if (FileExists(strCheck))
					continue;
			}
		}
		else	// this is not an OS type we can check
			continue;

		// If execution falls through to here, then the line in question was an OS
		// we care about, and it looks like it's invalid. Give the user the opportunity
		// to remove it from the BOOT.INI file.

		CString strMessage;
		strMessage.Format(IDS_BADBOOTLINE, m_arrayIniLines[i]);

		if (IDYES == MessageBox(strMessage, strCaption, MB_YESNO | MB_ICONQUESTION))
		{
			m_arrayIniLines.RemoveAt(i);
			m_nMaxOSIndex -= 1;

			// Check to see if the line we just removed is the default
			// operating system.

			CString strDefault = m_arrayIniLines[m_nDefaultIndex];
			iEquals = strDefault.Find(_T('='));
			if (iEquals != -1)
			{
				strDefault = strDefault.Mid(iEquals + 1);
				strDefault.TrimLeft();
				if (strDefault.CompareNoCase(strLine) == 0)
					SetDefaultOS(m_nMinOSIndex);
			}

			i -= 1; // so we look at the next line when the for loop increments i
			fChangedFile = TRUE;
		}

		fFoundBadLine = TRUE;
	}

	if (!fFoundBadLine)
		Message(IDS_NOBADBOOTLINES);
	else if (fChangedFile)
	{
		UserMadeChange();
		SyncControlsToIni();
		if (m_nMinOSIndex != -1)
		{
			::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, m_nMinOSIndex, 0);
			SelectLine(m_nMinOSIndex);
		}
	}
}

//-------------------------------------------------------------------------
// Return the current state of the tab.
//-------------------------------------------------------------------------

CPageBase::TabState CPageBootIni::GetCurrentTabState()
{
	if (!m_fInitialized)
		return GetAppliedTabState();

	return m_stateCurrent;
}

//-------------------------------------------------------------------------
// Applying the changes for the boot.ini tab means writing out the new
// file contents.
//
// The base class implementation is called to maintain the applied
// tab state.
//-------------------------------------------------------------------------

BOOL CPageBootIni::OnApply()
{
	if (!m_fModified)
		return TRUE;

	// Build up the new contents of the boot.ini file from the
	// list. If there is no backup of the boot.ini file, make
	// one (so the original can be restored). Then write the
	// contents out to the file.

	CString strNewContents;
	for (int i = 0; i <= m_arrayIniLines.GetUpperBound(); i++)
		if (!m_arrayIniLines[i].IsEmpty())
		{
			if (m_nTimeoutIndex == i)
			{
				CString strTimeoutValue(m_arrayIniLines[i]);
				strTimeoutValue.TrimLeft(_T("TIMEOUTtimeout ="));
				int iTimeout = _ttoi(strTimeoutValue);
				if (iTimeout < 3 || iTimeout > 999)
				{
					if (iTimeout < 3)
						strTimeoutValue = _T("3");
					else if (iTimeout > 999)
						strTimeoutValue = _T("999");
					
					int iEquals = m_arrayIniLines[i].Find(_T('='));
					if (iEquals != -1)
					{
						CString strNewTimeout = m_arrayIniLines[i].Left(iEquals + 1) + strTimeoutValue;
						m_arrayIniLines.SetAt(i, strNewTimeout);
					}
				}
			}

			strNewContents += m_arrayIniLines[i] + _T("\r\n");
		}

	// If we are currently in a "NORMAL" state, then we want to make a new
	// backup file (overwriting an existing one, if necessary). Otherwise,
	// only make a backup if there isn't already one. This preserves a good
	// backup when the user is making incremental changes.

	HRESULT hr = BackupFile(m_strFileName, _T(".backup"), (GetAppliedTabState() == NORMAL));
	if (FAILED(hr))
		return FALSE;

	SetBootIniContents(strNewContents);
	CPageBase::SetAppliedState(GetCurrentTabState());
	m_fMadeChange = TRUE;
	return TRUE;
}

//-------------------------------------------------------------------------
// Committing the changes means applying changes, then saving the current
// values to the registry with the commit flag. Refill the list.
//
// Then call the base class implementation.
//-------------------------------------------------------------------------

void CPageBootIni::CommitChanges()
{
	OnApply();
	m_stateCurrent = NORMAL;

	::DeleteFile(GetBackupName(m_strFileName, _T(".backup")));

	CPageBase::CommitChanges();
}

//-------------------------------------------------------------------------
// Set the overall state of the tab to normal or diagnostic.
//-------------------------------------------------------------------------

void CPageBootIni::SetNormal()
{
	// Setting the BOOT.INI tab state to normal means that the original
	// BOOT.INI file contents should be restored to the UI (not actually
	// saved until the changes are applied). If a BOOT.INI backup file
	// exists, we should reload the contents of it. If it doesn't exists,
	// reload the contents of the real BOOT.INI.
	//
	// Note - if the state is already NORMAL, don't do anything.

	if (m_stateCurrent == NORMAL)
		return;

	CString strBackup = GetBackupName(m_strFileName, _T(".backup"));
	if (FileExists(strBackup))
		LoadBootIni(strBackup);
	else
		LoadBootIni();

	int iSelection = (int)::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_GETCURSEL, 0, 0);
	SyncControlsToIni();
	if (iSelection > 0)
	{
		SelectLine(iSelection);
		::SendMessage(GetDlgItemHWND(IDC_LISTBOOTINI), LB_SETCURSEL, iSelection, 0);
	}

	UserMadeChange();
	m_stateCurrent = NORMAL;
}

void CPageBootIni::SetDiagnostic()
{
	// Don't do anything.
}

void CPageBootIni::OnDestroy() 
{
	// Undo the subclass

	pBootIniPage = NULL;
	HWND hWndEdit = GetDlgItemHWND(IDC_EDITTIMEOUT);
	if (pOldBootIniEditProc != NULL && hWndEdit)
		::SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (ULONG_PTR)(WNDPROC)pOldBootIniEditProc);

	CPropertyPage::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pagegeneral.h ===
#if !defined(AFX_PAGEGENERAL_H__7D4A5A55_7F12_4A22_87AF_158186FC700D__INCLUDED_)
#define AFX_PAGEGENERAL_H__7D4A5A55_7F12_4A22_87AF_158186FC700D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "PageBase.h"
#include "MSConfigState.h"

/////////////////////////////////////////////////////////////////////////////
// CPageGeneral dialog

class CPageGeneral : public CPropertyPage, public CPageBase
{
	DECLARE_DYNCREATE(CPageGeneral)

// Construction
public:
	CPageGeneral();
	~CPageGeneral();
// Dialog Data
	//{{AFX_DATA(CPageGeneral)
	enum { IDD = IDD_PAGEGENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPageGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPageGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnDiagnosticStartup();
	afx_msg void OnNormalStartup();
	afx_msg void OnSelectiveStartup();
	afx_msg void OnCheckProcSysIni();
	afx_msg void OnCheckStartupItems();
	afx_msg void OnCheckServices();
	afx_msg void OnCheckWinIni();
	afx_msg LRESULT OnSetCancelToClose(WPARAM wparam, LPARAM lparam);
	afx_msg void OnRadioModified();
	afx_msg void OnRadioOriginal();
	afx_msg void OnButtonExtract();
	afx_msg void OnButtonSystemRestore();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void		UpdateControls();
	void		ForceSelectiveRadio(BOOL fNewValue);
	TabState	GetCurrentTabState();
	BOOL		OnApply();
	void		CommitChanges();
	void		SetNormal();
	void		SetDiagnostic();
	LPCTSTR		GetName() { return _T("general"); };
	BOOL		OnSetActive();

private:
	void		UpdateCheckBox(CPageBase * pPage, UINT nControlID, BOOL & fAllNormal, BOOL & fAllDiagnostic);
	void		OnClickedCheckBox(CPageBase * pPage, UINT nControlID);

	HWND GetDlgItemHWND(UINT nID)
	{
		HWND hwnd = NULL;
		CWnd * pWnd = GetDlgItem(nID);
		if (pWnd)
			hwnd = pWnd->m_hWnd;
		ASSERT(hwnd);
		return hwnd;
	}

private:
	BOOL	m_fForceSelectiveRadio;		// TRUE if the user chose the selective radio button
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PAGEGENERAL_H__7D4A5A55_7F12_4A22_87AF_158186FC700D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pageini.cpp ===
#include "stdafx.h"
#include "PageIni.h"
#include "MSConfigFind.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPageIni property page

IMPLEMENT_DYNCREATE(CPageIni, CPropertyPage)

CPageIni::CPageIni() : CPropertyPage(CPageIni::IDD)
{
	//{{AFX_DATA_INIT(CPageIni)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_fModified = FALSE;
}

CPageIni::~CPageIni()
{
}

void CPageIni::SetTabInfo(LPCTSTR szFilename)
{
	m_strINIFile = szFilename;
}

void CPageIni::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPageIni)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPageIni, CPropertyPage)
	//{{AFX_MSG_MAP(CPageIni)
	ON_BN_CLICKED(IDC_BUTTONINIDISABLE, OnButtonDisable)
	ON_BN_CLICKED(IDC_BUTTONINIDISABLEALL, OnButtonDisableAll)
	ON_BN_CLICKED(IDC_BUTTONINIENABLE, OnButtonEnable)
	ON_BN_CLICKED(IDC_BUTTONINIENABLEALL, OnButtonEnableAll)
	ON_BN_CLICKED(IDC_BUTTONINIMOVEDOWN, OnButtonMoveDown)
	ON_BN_CLICKED(IDC_BUTTONINIMOVEUP, OnButtonMoveUp)
	ON_NOTIFY(TVN_SELCHANGED, IDC_INITREE, OnSelChangedTree)
	ON_BN_CLICKED(IDC_BUTTONSEARCH, OnButtonSearch)
	ON_NOTIFY(NM_CLICK, IDC_INITREE, OnClickTree)
	ON_BN_CLICKED(IDC_BUTTONINIEDIT, OnButtonEdit)
	ON_NOTIFY(TVN_ENDLABELEDIT, IDC_INITREE, OnEndLabelEdit)
	ON_BN_CLICKED(IDC_BUTTONININEW, OnButtonNew)
	ON_NOTIFY(TVN_BEGINLABELEDIT, IDC_INITREE, OnBeginLabelEditIniTree)
	ON_NOTIFY(TVN_KEYDOWN, IDC_INITREE, OnKeyDownTree)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//-------------------------------------------------------------------------
// Reads the contents of the INI file in to this class's internal
// structures.
//-------------------------------------------------------------------------

BOOL CPageIni::LoadINIFile(CStringArray & lines, int & iLastLine, BOOL fLoadBackupFile)
{
	lines.RemoveAll();

	// Open the specified INI file.

	TCHAR szPath[MAX_PATH];
	CString strINIFileLocation;

	strINIFileLocation.Format(_T("%%windir%%\\%s"), m_strINIFile);
	if (::ExpandEnvironmentStrings(strINIFileLocation, szPath, MAX_PATH) == 0)
		return FALSE;

	if (fLoadBackupFile)
	{
		CString strPath = GetBackupName(szPath, _T(".backup"));
		// Replacing unsafe string copy: _tcscpy(szPath, strPath);
		::ZeroMemory((PVOID)szPath, sizeof(szPath));
		_tcsncpy(szPath, strPath, (sizeof(szPath) / sizeof(TCHAR)) - 1);
	}
	else
	{
		// If a backup of this file doesn't exist, we should make one.

		BackupFile(szPath, _T(".backup"), FALSE);
	}

	CStdioFile inifile;
	if (inifile.Open(szPath, CFile::modeRead | CFile::typeText))
	{
		// Estimate how big the string array will need to be (the array
		// will grow if we're off). We'll estimate 15 characters/line, average.
		// And we'll set the array to grow by 16 if we exceed this.
		
		lines.SetSize(inifile.GetLength() / (15 * sizeof(TCHAR)), 16);

		// Read each line and insert it into the array.

		CString strLine;

		m_iLastLine = -1;
		while (inifile.ReadString(strLine))
		{
			strLine.TrimRight(_T("\r\n"));

			CString strCheck(strLine);
			strCheck.TrimLeft();
			if (!strCheck.IsEmpty())
				lines.SetAtGrow(++iLastLine, strLine);
		}

		inifile.Close();
	}
	else
		return FALSE;

	return TRUE;
}

//-------------------------------------------------------------------------
// Writes the contents of the array of lines out to the actual file.
//-------------------------------------------------------------------------

BOOL CPageIni::WriteINIFile(CStringArray & lines, int iLastLine, BOOL fUndoable)
{
	// Open the specified INI file.

	TCHAR szPath[MAX_PATH];
	CString strINIFileLocation;
	CString strINIFile(m_strINIFile);

	strINIFileLocation.Format(_T("%%windir%%\\%s"), strINIFile);
	if (::ExpandEnvironmentStrings(strINIFileLocation, szPath, MAX_PATH) == 0)
		return FALSE;

	CStdioFile inifile;
	if (inifile.Open(szPath, CFile::modeCreate | CFile::modeWrite | CFile::typeText))
	{
		// We need to traverse the tree structure to get the new contents of
		// the file.

		HWND		hwndTree = m_tree.m_hWnd;
		HTREEITEM	htiLine = TreeView_GetRoot(hwndTree);
		TVITEM		tvi;
		TCHAR		szBuffer[MAX_PATH];

		tvi.mask = TVIF_TEXT | TVIF_IMAGE;
		tvi.pszText = szBuffer;
		while (htiLine)
		{
			tvi.hItem = htiLine;
			tvi.cchTextMax = MAX_PATH;
			if (TreeView_GetItem(hwndTree, &tvi))
			{
				CString strLine(tvi.pszText);
				CString strCheck(strLine);

				strCheck.TrimLeft();
				if (!strCheck.IsEmpty())
				{
					if (!fUndoable && strLine.Find(DISABLE_STRING) != -1)
						strLine.Replace(DISABLE_STRING, _T("; "));

					strLine += CString(_T("\n"));
					inifile.WriteString(strLine);
				}
			}

			HTREEITEM htiNext = TreeView_GetChild(hwndTree, htiLine);
			if (htiNext)
			{
				htiLine = htiNext;
				continue;
			}

			htiNext = TreeView_GetNextSibling(hwndTree, htiLine);
			if (htiNext)
			{
				htiLine = htiNext;
				continue;
			}

			htiNext = TreeView_GetParent(hwndTree, htiLine);
			if (htiNext)
			{
				htiNext = TreeView_GetNextSibling(hwndTree, htiNext);
				if (htiNext)
				{
					htiLine = htiNext;
					continue;
				}
			}

			htiLine = NULL;
		}

		inifile.Close();
	}
	else
		return FALSE;

	return TRUE;
}

//-------------------------------------------------------------------------
// Updates the tree view to show the contents of the internal structures.
//-------------------------------------------------------------------------

void CPageIni::UpdateTreeView()
{
	TreeView_DeleteAllItems(m_tree.m_hWnd);

	ASSERT(m_iLastLine < m_lines.GetSize());
	if (m_iLastLine > m_lines.GetSize())
		return;

	TVINSERTSTRUCT tvis;
	tvis.hParent = TVI_ROOT;
	tvis.hInsertAfter = TVI_LAST;
	tvis.itemex.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
	tvis.itemex.iImage = m_checkedID;
	tvis.itemex.iSelectedImage = m_checkedID;

	// Add each line to the tree view.

	int iDisableLen = _tcslen(DISABLE_STRING);
	int iDisableLenHdr = _tcslen(DISABLE_STRING_HDR);
	for (int i = 0; i <= m_iLastLine; i++)
	{
		CString strLine = m_lines.GetAt(i);
		tvis.itemex.pszText = (LPTSTR)(LPCTSTR)strLine;

		if (!strLine.IsEmpty() && (_tcsnccmp((LPCTSTR)strLine, DISABLE_STRING, iDisableLen) == 0))
			tvis.itemex.iImage = tvis.itemex.iSelectedImage = m_uncheckedID;
		else
			tvis.itemex.iImage = tvis.itemex.iSelectedImage = m_checkedID;

		BOOL fSectionHeader = FALSE;
		if (!strLine.IsEmpty())
		{
			if (strLine[0] == _T('['))
				fSectionHeader = TRUE;
			else if (_tcsnccmp((LPCTSTR)strLine, DISABLE_STRING_HDR, iDisableLenHdr) == 0)
				fSectionHeader = TRUE;
		}

		if (fSectionHeader)
		{
			tvis.hParent = TVI_ROOT;
			tvis.hParent = TreeView_InsertItem(m_tree.m_hWnd, &tvis);
		}
		else
			TreeView_InsertItem(m_tree.m_hWnd, &tvis);
	}

	// Now scan the top level of the tree view. For every node which
	// has children, we want to set the image appropriately.

	for (HTREEITEM hti = TreeView_GetRoot(m_tree.m_hWnd); hti; hti = TreeView_GetNextSibling(m_tree.m_hWnd, hti))
		if (TreeView_GetChild(m_tree.m_hWnd, hti) != NULL)
			UpdateLine(hti);

	UpdateControls();
}

//-------------------------------------------------------------------------
// Update the image state of the specified line, based on the text in
// the line. If the line is a bracketed section header, this will involve
// scanning the children. Returns the index of the image set for the node.
//-------------------------------------------------------------------------

int CPageIni::UpdateLine(HTREEITEM hti)
{
	if (hti == NULL)
		return 0;

	TVITEM	tvi;
	tvi.hItem = hti;

	int	iNewImageIndex = m_checkedID;

	HTREEITEM htiChild = TreeView_GetChild(m_tree.m_hWnd, hti);
	if (htiChild)
	{
		BOOL fEnabledChild = FALSE, fDisabledChild = FALSE;

		while (htiChild)
		{
			if (UpdateLine(htiChild) == m_checkedID)
				fEnabledChild = TRUE;
			else
				fDisabledChild = TRUE;
			htiChild = TreeView_GetNextSibling(m_tree.m_hWnd, htiChild);
		}

		if (fDisabledChild)
			iNewImageIndex = (fEnabledChild) ? m_fuzzyID : m_uncheckedID;
	}
	else
	{
		TCHAR szBuffer[MAX_PATH];	// seems like a reasonably big value
		tvi.mask = TVIF_TEXT;
		tvi.pszText = szBuffer;
		tvi.cchTextMax = MAX_PATH;
		
		if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
			iNewImageIndex = (_tcsnccmp(tvi.pszText, DISABLE_STRING, _tcslen(DISABLE_STRING)) == 0) ? m_uncheckedID : m_checkedID;
	}

	tvi.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
	if (TreeView_GetItem(m_tree.m_hWnd, &tvi) && tvi.iImage != iNewImageIndex)
	{
		tvi.iSelectedImage = tvi.iImage = iNewImageIndex;
		TreeView_SetItem(m_tree.m_hWnd, &tvi);
	}

	return iNewImageIndex;
}

//-------------------------------------------------------------------------
// Enable or disable a node in the tree (and its children).
//-------------------------------------------------------------------------

void CPageIni::SetEnable(BOOL fEnable, HTREEITEM htiNode, BOOL fUpdateLine, BOOL fBroadcast)
{
	HTREEITEM hti = (htiNode) ? htiNode : TreeView_GetSelection(m_tree.m_hWnd);
	if (hti == NULL)
		return;

	HTREEITEM htiChild = TreeView_GetChild(m_tree.m_hWnd, hti);
	if (htiChild)
	{
		while (htiChild)
		{
			SetEnable(fEnable, htiChild, FALSE, FALSE);
			htiChild = TreeView_GetNextSibling(m_tree.m_hWnd, htiChild);
		}

		UpdateLine(hti);
	}
	else
	{
		int		iDisableLen = _tcslen(DISABLE_STRING);
		TCHAR	szBuffer[MAX_PATH];	// seems like a reasonably big value

		TVITEM tvi;
		tvi.hItem = hti;
		tvi.mask = TVIF_TEXT;
		tvi.pszText = &szBuffer[iDisableLen];	// leave some room to add disable string
		tvi.cchTextMax = MAX_PATH + iDisableLen;

		if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
		{
			BOOL fAlreadyEnabled = (_tcsnccmp(&szBuffer[iDisableLen], DISABLE_STRING, iDisableLen) != 0);
			if (fEnable != fAlreadyEnabled)
			{
				if (fEnable)
					tvi.pszText = &szBuffer[iDisableLen * 2];
				else
				{
					_tcsncpy(szBuffer, DISABLE_STRING, iDisableLen);
					tvi.pszText = szBuffer;
				}

				TreeView_SetItem(m_tree.m_hWnd, &tvi);

				if (fUpdateLine)
				{
					UpdateLine(hti);
					if (TreeView_GetParent(m_tree.m_hWnd, hti))
						UpdateLine(TreeView_GetParent(m_tree.m_hWnd, hti));
				}
			}
		}
	}

	if (fBroadcast)
		SetModified(TRUE);
}

//-------------------------------------------------------------------------
// Move the specified branch in the tree view to a new location.
//-------------------------------------------------------------------------

void CPageIni::MoveBranch(HWND hwndTree, HTREEITEM htiMove, HTREEITEM htiParent, HTREEITEM htiAfter)
{
	HTREEITEM htiNew = CopyBranch(hwndTree, htiMove, htiParent, htiAfter);
	if (htiNew != NULL)
	{
		TreeView_SelectItem(hwndTree, htiNew);
		TreeView_DeleteItem(hwndTree, htiMove);
		SetModified(TRUE);
	}
}

HTREEITEM CPageIni::CopyBranch(HWND hwndTree, HTREEITEM htiFrom, HTREEITEM htiToParent, HTREEITEM htiToAfter)
{
	TCHAR			szBuffer[MAX_PATH];
	TVINSERTSTRUCT	tvis;

	tvis.item.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_STATE;
	tvis.item.pszText = szBuffer;
	tvis.item.cchTextMax = MAX_PATH;
	tvis.item.hItem = htiFrom;
	tvis.item.stateMask = TVIS_EXPANDED;

	HTREEITEM htiNew = NULL;
	if (TreeView_GetItem(hwndTree, &tvis.item))
	{
		tvis.hParent = htiToParent;
		tvis.hInsertAfter = htiToAfter;
		htiNew = TreeView_InsertItem(hwndTree, &tvis);
	}

	HTREEITEM htiPrevious = TVI_FIRST;
	if (htiNew)
		for (HTREEITEM htiChild = TreeView_GetChild(hwndTree, htiFrom); htiChild; htiChild = TreeView_GetNextSibling(hwndTree, htiChild))
			htiPrevious = CopyBranch(hwndTree, htiChild, htiNew, htiPrevious);

	return htiNew;
}

//-------------------------------------------------------------------------
// Update the controls to reflect the state of the selection.
//-------------------------------------------------------------------------

void CPageIni::UpdateControls()
{
	BOOL fEnable = FALSE;
	BOOL fDisable = FALSE;
	BOOL fMoveUp = FALSE;
	BOOL fMoveDown = FALSE;

	HTREEITEM htiSelection = TreeView_GetSelection(m_tree.m_hWnd);
	if (htiSelection)
	{
		fMoveUp = (TreeView_GetPrevSibling(m_tree.m_hWnd, htiSelection) != NULL);
		fMoveDown = (TreeView_GetNextSibling(m_tree.m_hWnd, htiSelection) != NULL);

		TVITEM tvi;
		tvi.hItem = htiSelection;
		tvi.mask = TVIF_IMAGE;

		if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
		{
			fEnable = (tvi.iImage != m_checkedID);
			fDisable = (tvi.iImage != m_uncheckedID);
		}
	}

	HWND hwndFocus = ::GetFocus();

	CPageBase::TabState state = GetCurrentTabState();
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIDISABLEALL), (state != DIAGNOSTIC));
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIENABLEALL), (state != NORMAL));

	if ((state == DIAGNOSTIC) && hwndFocus == GetDlgItemHWND(IDC_BUTTONINIDISABLEALL))
		PrevDlgCtrl();

	if ((state == NORMAL) && hwndFocus == GetDlgItemHWND(IDC_BUTTONINIENABLEALL))
		NextDlgCtrl();

	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIDISABLE), fDisable);
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIENABLE), fEnable);
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIMOVEUP), fMoveUp);
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIMOVEDOWN), fMoveDown);

	if (!fMoveUp && hwndFocus == GetDlgItemHWND(IDC_BUTTONINIMOVEUP))
		NextDlgCtrl();

	if (!fMoveDown && hwndFocus == GetDlgItemHWND(IDC_BUTTONINIMOVEDOWN))
		PrevDlgCtrl();

	if (!fEnable && hwndFocus == GetDlgItemHWND(IDC_BUTTONINIENABLE))
		NextDlgCtrl();

	if (!fDisable && hwndFocus == GetDlgItemHWND(IDC_BUTTONINIDISABLE))
		PrevDlgCtrl();
}

//-------------------------------------------------------------------------
// Get the next item in the tree. Since we know this won't be more than
// two levels deep, we don't need to have a loop.
//-------------------------------------------------------------------------

HTREEITEM CPageIni::GetNextItem(HTREEITEM hti)
{
	if (hti == NULL)
		return NULL;

	HTREEITEM htiNext = TreeView_GetChild(m_tree.m_hWnd, hti);
	if (htiNext != NULL)
		return htiNext;

	htiNext = TreeView_GetNextSibling(m_tree.m_hWnd, hti);
	if (htiNext != NULL)
		return htiNext;

	htiNext = TreeView_GetParent(m_tree.m_hWnd, hti);
	if (htiNext != NULL)
		htiNext = TreeView_GetNextSibling(m_tree.m_hWnd, htiNext);
	
	return htiNext;
}

/////////////////////////////////////////////////////////////////////////////
// CPageIni message handlers

BOOL CPageIni::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	// These items are initially disabled.

	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIDISABLE), FALSE);
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIENABLE), FALSE);
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIMOVEUP), FALSE);
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIMOVEDOWN), FALSE);

	m_tree.Attach(GetDlgItemHWND(IDC_INITREE));
	VERIFY(m_fImageList = m_imagelist.Create(IDB_IMAGELIST, 0, 3, RGB(255, 0, 255)));
	if (m_fImageList)
		TreeView_SetImageList(m_tree.m_hWnd, m_imagelist, TVSIL_NORMAL);

	// If we are running on an RTL system, then the bitmaps for the check boxes
	// will be reversed. The imagemap includes reversed versions of the checked
	// and indetermined state, so we should just use the appropriate index.

	DWORD dwLayout;
	BOOL fRTL = FALSE;
	if (::GetProcessDefaultLayout(&dwLayout))
		fRTL = ((dwLayout & LAYOUT_RTL) != 0);
	m_checkedID = (fRTL) ? IMG_CHECKED_RTL : IMG_CHECKED;
	m_fuzzyID = (fRTL) ? IMG_FUZZY_RTL : IMG_FUZZY;
	m_uncheckedID = IMG_UNCHECKED;

	if (LoadINIFile(m_lines, m_iLastLine))
		UpdateTreeView();
	else
	{
		// set controls for no file TBD
	}

	m_fInitialized = TRUE;
	return TRUE;  // return TRUE unless you set the focus to a control
}

//-------------------------------------------------------------------------
// When the user clicks on an enable or disable button, we'll modify the
// text in the tree view and update the images.
//-------------------------------------------------------------------------

void CPageIni::OnButtonDisable() 
{
	SetEnable(FALSE);
	UpdateControls();
}

void CPageIni::OnButtonDisableAll() 
{
	for (HTREEITEM hti = TreeView_GetRoot(m_tree.m_hWnd); hti; hti = TreeView_GetNextSibling(m_tree.m_hWnd, hti))
		SetEnable(FALSE, hti, TRUE);
	UpdateControls();
}

void CPageIni::OnButtonEnable() 
{
	SetEnable(TRUE);
	UpdateControls();
}

void CPageIni::OnButtonEnableAll() 
{
	for (HTREEITEM hti = TreeView_GetRoot(m_tree.m_hWnd); hti; hti = TreeView_GetNextSibling(m_tree.m_hWnd, hti))
		SetEnable(TRUE, hti, TRUE);
	UpdateControls();
}

//-------------------------------------------------------------------------
// Move a branch of the tree up or down.
//-------------------------------------------------------------------------

void CPageIni::OnButtonMoveDown() 
{
	HTREEITEM htiSelection = TreeView_GetSelection(m_tree.m_hWnd);
	if (htiSelection)
	{
		HTREEITEM htiParent = TreeView_GetParent(m_tree.m_hWnd, htiSelection);
		HTREEITEM htiNext = TreeView_GetNextSibling(m_tree.m_hWnd, htiSelection);
		
		if (htiNext == NULL)
			return;

		if (htiParent == NULL)
			htiParent = TVI_ROOT;

		MoveBranch(m_tree.m_hWnd, htiSelection, htiParent, htiNext);
	}
}

void CPageIni::OnButtonMoveUp() 
{
	HTREEITEM htiSelection = TreeView_GetSelection(m_tree.m_hWnd);
	if (htiSelection)
	{
		HTREEITEM htiParent = TreeView_GetParent(m_tree.m_hWnd, htiSelection);
		HTREEITEM htiPrevious = TreeView_GetPrevSibling(m_tree.m_hWnd, htiSelection);
		
		if (htiPrevious == NULL)
			return;
		htiPrevious = TreeView_GetPrevSibling(m_tree.m_hWnd, htiPrevious);
		if (htiPrevious == NULL)
			htiPrevious = TVI_FIRST;

		if (htiParent == NULL)
			htiParent = TVI_ROOT;

		MoveBranch(m_tree.m_hWnd, htiSelection, htiParent, htiPrevious);
	}
}

void CPageIni::OnSelChangedTree(NMHDR * pNMHDR, LRESULT * pResult) 
{
	NM_TREEVIEW*  pNMTreeView = (NM_TREEVIEW *)pNMHDR;
	UpdateControls();
	*pResult = 0;
}

//-------------------------------------------------------------------------
// Search the tree view for a string (present a dialog to the user).
//-------------------------------------------------------------------------

void CPageIni::OnButtonSearch() 
{
	CMSConfigFind find;

	find.m_strSearchFor = m_strLastSearch;

	if (find.DoModal() == IDOK && !find.m_strSearchFor.IsEmpty())
	{
		CString strSearch(find.m_strSearchFor);
		m_strLastSearch = strSearch;
		strSearch.MakeLower();

		HTREEITEM htiSearch;

		if (find.m_fSearchFromTop)
			htiSearch = TreeView_GetRoot(m_tree.m_hWnd);
		else
		{
			htiSearch = TreeView_GetSelection(m_tree.m_hWnd);
			if (htiSearch == NULL)
				htiSearch = TreeView_GetRoot(m_tree.m_hWnd);
			else
				htiSearch = GetNextItem(htiSearch);
		}

		TVITEM tvi;
		TCHAR szBuffer[MAX_PATH];
		tvi.mask = TVIF_TEXT | TVIF_IMAGE;
		tvi.pszText = szBuffer;

		while (htiSearch != NULL)
		{
			tvi.hItem = htiSearch;
			tvi.cchTextMax = MAX_PATH;
			if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
			{
				CString strItem(szBuffer);
				strItem.MakeLower();

				if (strItem.Find(strSearch) != -1)
				{
					// We found a hit. Select the node.

					TreeView_SelectItem(m_tree.m_hWnd, htiSearch);
					break;
				}
			}

			htiSearch = GetNextItem(htiSearch);
		}

		if (htiSearch == NULL)
			Message(IDS_NOFIND);
	}
}

//-------------------------------------------------------------------------
// The current tab state can be found by looking through the tree view.
//-------------------------------------------------------------------------

CPageBase::TabState CPageIni::GetCurrentTabState()
{
	if (!m_fInitialized)
		return GetAppliedTabState();

	BOOL		fAllEnabled = TRUE, fAllDisabled = TRUE;
	HTREEITEM	hti = TreeView_GetRoot(m_tree.m_hWnd);
	TVITEM		tvi;

	tvi.mask = TVIF_IMAGE;
	while (hti)
	{
		tvi.hItem = hti;
		if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
		{
			if (m_uncheckedID != tvi.iImage)
				fAllDisabled = FALSE;
			if (m_checkedID != tvi.iImage)
				fAllEnabled = FALSE;
		}
		hti = TreeView_GetNextSibling(m_tree.m_hWnd, hti);
	}

	return ((fAllEnabled) ? NORMAL : ((fAllDisabled) ? DIAGNOSTIC : USER));
}

//-------------------------------------------------------------------------
// Apply the changes by saving the INI file.
//
// The base class implementation is called to maintain the
// applied tab state.
//-------------------------------------------------------------------------

BOOL CPageIni::OnApply()
{
	if (!m_fModified)
		return TRUE;

	WriteINIFile(m_lines, m_iLastLine);
	CPageBase::SetAppliedState(GetCurrentTabState());
	m_fMadeChange = TRUE;
	return TRUE;
}

//-------------------------------------------------------------------------
// To commit the changes, write the INI file without the distinguishing
// comments (by calling WriteINIFile with FALSE as the last param).
//
// Then call the base class implementation.
//-------------------------------------------------------------------------

void CPageIni::CommitChanges()
{
	WriteINIFile(m_lines, m_iLastLine, FALSE);
	LoadINIFile(m_lines, m_iLastLine);
	UpdateTreeView();
	CPageBase::CommitChanges();
}

//-------------------------------------------------------------------------
// Set the overall state of the tab to normal or diagnostic.
//-------------------------------------------------------------------------

void CPageIni::SetNormal()
{
	HWND hwndTree = m_tree.m_hWnd;
	HTREEITEM hti = TreeView_GetRoot(hwndTree);

	while (hti != NULL)
	{
		SetEnable(TRUE, hti, TRUE, FALSE);
		hti = TreeView_GetNextSibling(hwndTree, hti);
	}
	SetModified(TRUE);
	UpdateControls();
}

void CPageIni::SetDiagnostic()
{
	HWND hwndTree = m_tree.m_hWnd;
	HTREEITEM hti = TreeView_GetRoot(hwndTree);

	while (hti != NULL)
	{
		SetEnable(FALSE, hti, TRUE, FALSE);
		hti = TreeView_GetNextSibling(hwndTree, hti);
	}
	SetModified(TRUE);
	UpdateControls();
}

//-------------------------------------------------------------------------
// We need to look at user clicks on the tree view. If it is on an item,
// and also on the item's image, then we'll need to toggle the image
// state.
//-------------------------------------------------------------------------

void CPageIni::OnClickTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Determine if this tree click is on a node, and if it is, 
	// if it is on the image.

	TVHITTESTINFO tvhti;

	DWORD dwPoint = GetMessagePos();
	tvhti.pt.x = ((int)(short)LOWORD(dwPoint));
	tvhti.pt.y = ((int)(short)HIWORD(dwPoint));
	::ScreenToClient(m_tree.m_hWnd, &tvhti.pt);

	HTREEITEM hti = TreeView_HitTest(m_tree.m_hWnd, &tvhti);
	if (hti != NULL && (tvhti.flags & TVHT_ONITEMICON) != 0)
	{
		// This is a click that we care about. We need to get the
		// current state of this node so we know which way to
		// toggle the state. We'll make an arbitrary decision
		// that the toggle from undetermined is to enabled.

		TVITEM tvi;
		tvi.hItem = hti;
		tvi.mask = TVIF_IMAGE;

		if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
		{
			SetEnable(tvi.iImage != m_checkedID, hti);
			UpdateControls();
		}
	}
}

//-------------------------------------------------------------------------
// We allow the user to edit the lines in the INI file. When the user
// is through editing, we want to make sure we notify the framework
// that a change has been made.
//-------------------------------------------------------------------------

void CPageIni::OnButtonEdit() 
{
	HTREEITEM hti = TreeView_GetSelection(m_tree.m_hWnd);
	if (hti != NULL)
	{
		::SetFocus(m_tree.m_hWnd);
		TreeView_EditLabel(m_tree.m_hWnd, hti);
	}
}

//-------------------------------------------------------------------------
// WndProc for the edit control when editing a label in the tree (handles
// enter/esc better). Lifted from ME source.
//-------------------------------------------------------------------------

WNDPROC pOldEditProc = NULL; // save old wndproc when we subclass edit control
LRESULT TreeViewEditSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
	switch (wm)
	{
	case WM_GETDLGCODE:
	   return DLGC_WANTALLKEYS;

	// The Knowledge Base article describing the work-around for this
	// this bug indicates the following handling of VK_ESCAPE & VK_RETURN
	// is necessary -- however, under Memphis & OSR2 these keys are never
	// received (returning DLGC_WANTALLKEYS seems to fix the problem).
	// Perhaps it depends on which comctl32.dll is installed...

	case WM_CHAR:
	   if (wp == VK_ESCAPE || wp == VK_RETURN)
	   {
		   TreeView_EndEditLabelNow(GetParent(hwnd), wp == VK_ESCAPE);
		   return 0;
	   }
	   break;
	}

	if (pOldEditProc)	// better not be null
		return CallWindowProc(pOldEditProc, hwnd, wm, wp, lp);
	return 0;
}

//-------------------------------------------------------------------------
// The tree view doesn't handle enter and esc correctly, so when we start
// editing a label, we need to subclass the control.
//-------------------------------------------------------------------------

void CPageIni::OnBeginLabelEditIniTree(NMHDR * pNMHDR, LRESULT * pResult) 
{
	TV_DISPINFO * pTVDispInfo = (TV_DISPINFO *)pNMHDR;

	// Disable Move Up and Down buttons while editing.

	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIMOVEUP), FALSE);
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIMOVEDOWN), FALSE);
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIEDIT), FALSE);

	// TreeView controls don't properly handle Esc/Enter when editing
	// a label.  To fix this, it's necessary to subclass the label's edit
	// control and process Esc & Enter ourselves.  Sigh...
	
	HWND hWndEdit = TreeView_GetEditControl(m_tree.m_hWnd);
	if (hWndEdit)
	{
		pOldEditProc = (WNDPROC)::GetWindowLongPtr(hWndEdit, GWLP_WNDPROC);
		::SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (ULONG_PTR)(WNDPROC)&TreeViewEditSubclassProc);
	}
	
	*pResult = 0;
}

void CPageIni::OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult) 
{
	TV_DISPINFO * pTVDispInfo = (TV_DISPINFO *)pNMHDR;

	// Stop subclassing the edit control.

	HWND hWndEdit = TreeView_GetEditControl(m_tree.m_hWnd);
	if (hWndEdit && pOldEditProc)
	{
		::SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (ULONG_PTR)(WNDPROC)pOldEditProc);
		pOldEditProc = NULL;
	}

	// If the new text pointer is null, then the edit was cancelled.
	// We only care if a new item was being added, in which case
	// we should delete it.

    if (pTVDispInfo->item.pszText == NULL)
	{
		TCHAR	szBuffer[MAX_PATH];
		TVITEM	tvi;

		tvi.pszText = szBuffer;
		tvi.mask = TVIF_TEXT;
		tvi.hItem = pTVDispInfo->item.hItem;
		tvi.cchTextMax = MAX_PATH;
		if (TreeView_GetItem(m_tree.m_hWnd, &tvi) && tvi.pszText && tvi.pszText[0] == _T('\0'))
		{
			HTREEITEM hPriorItem = TreeView_GetPrevSibling(pTVDispInfo->hdr.hwndFrom, pTVDispInfo->item.hItem);
			if (hPriorItem == NULL)
				hPriorItem = TreeView_GetParent(pTVDispInfo->hdr.hwndFrom, pTVDispInfo->item.hItem);

			TreeView_DeleteItem(m_tree.m_hWnd, pTVDispInfo->item.hItem);

			if (hPriorItem)
				TreeView_SelectItem(pTVDispInfo->hdr.hwndFrom, hPriorItem);
		}

		*pResult = 0;
	}
	else
	{
		SetModified(TRUE);
		*pResult = 1;
	}

	::EnableWindow(GetDlgItemHWND(IDC_BUTTONINIEDIT), TRUE);
	UpdateControls();
}

//-------------------------------------------------------------------------
// If the user clicks on the new button, then add an empty tree view
// node after the currently selected one. If the selected node has
// children, add the node as the first child under the selected node.
// Then select the node for editing.
//-------------------------------------------------------------------------

void CPageIni::OnButtonNew() 
{
	HTREEITEM hti = TreeView_GetSelection(m_tree.m_hWnd);
	if (hti == NULL)
		hti = TreeView_GetRoot(m_tree.m_hWnd);

	if (hti == NULL)
		return;

	TVINSERTSTRUCT tvis;
	if (TreeView_GetChild(m_tree.m_hWnd, hti) != NULL)
	{
		tvis.hParent = hti;
		tvis.hInsertAfter = TVI_FIRST;
	}
	else
	{
		tvis.hParent = TreeView_GetParent(m_tree.m_hWnd, hti);
		tvis.hInsertAfter = hti;
	}

	TCHAR szBuffer[] = _T("");

	tvis.itemex.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
	tvis.itemex.iImage = m_checkedID;
	tvis.itemex.iSelectedImage = m_checkedID;
	tvis.itemex.pszText = szBuffer;

	HTREEITEM htiNew = TreeView_InsertItem(m_tree.m_hWnd, &tvis);
	if (htiNew != NULL)
	{
		TreeView_SelectItem(m_tree.m_hWnd, htiNew);
		TreeView_EditLabel(m_tree.m_hWnd, htiNew);
	}
}

//-------------------------------------------------------------------------
// If the user hits the space bar with an item selected in the tree, toggle
// the state of the item.
//-------------------------------------------------------------------------

void CPageIni::OnKeyDownTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
	TV_KEYDOWN * pTVKeyDown = (TV_KEYDOWN *)pNMHDR;

	if (pTVKeyDown->wVKey == VK_SPACE)
	{
		HTREEITEM hti = TreeView_GetSelection(m_tree.m_hWnd);
		if (hti != NULL)
		{
			TVITEM tvi;
			tvi.mask = TVIF_IMAGE;
			tvi.hItem = hti;

			if (TreeView_GetItem(m_tree.m_hWnd, &tvi))
			{
				SetEnable(tvi.iImage != m_checkedID, hti);
				UpdateControls();
			}
		}
	}

	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pagebootini.h ===
//=============================================================================
// PageBootIni.h : Declaration of the CPageBootIni
//
// TESTING NOTE:
// 
// If the registry value "HKLM\SOFTWARE\Microsoft\Shared Tools\MSConfig:boot.ini"
// is set, that string will indicate what file this tab edits (otherwise it will
// be editing the c:\boot.ini file). For testing without interfering with your
// real boot.ini file, make a copy of boot.ini, set it to the same attributes
// and set this key appropriately.
//=============================================================================

#if !defined(AFX_PAGEBOOTINI_H__30CE1B24_CA43_4AFF_870C_7D49CCCF86BF__INCLUDED_)
#define AFX_PAGEBOOTINI_H__30CE1B24_CA43_4AFF_870C_7D49CCCF86BF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "PageBase.h"
#include "MSConfigState.h"

/////////////////////////////////////////////////////////////////////////////
// CPageBootIni dialog

#define BOOT_INI	_T("c:\\boot.ini")

class CPageBootIni : public CPropertyPage, public CPageBase
{
	DECLARE_DYNCREATE(CPageBootIni)

	friend LRESULT BootIniEditSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp);

// Construction
public:
	CPageBootIni();
	~CPageBootIni();

	void		InitializePage();
	BOOL		LoadBootIni(CString strFileName = _T(""));
	void		SyncControlsToIni(BOOL fSyncEditField = TRUE);
	void		SelectLine(int index);
	void		SetDefaultOS(int iIndex);
	BOOL		SetBootIniContents(const CString & strNewContents, const CString & strAddedExtension = _T(""));
	void		ChangeCurrentOSFlag(BOOL fAdd, LPCTSTR szFlag);
	LPCTSTR		GetName() { return _T("bootini"); };
	TabState	GetCurrentTabState();
	BOOL		OnApply();
	void		CommitChanges();
	void		SetNormal();
	void		SetDiagnostic();

// Dialog Data
	//{{AFX_DATA(CPageBootIni)
	enum { IDD = IDD_PAGEBOOTINI };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPageBootIni)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPageBootIni)
	virtual BOOL OnInitDialog();
	afx_msg void OnBootMoveDown();
	afx_msg void OnBootMoveUp();
	afx_msg void OnSelChangeList();
	afx_msg void OnClickedBase();
	afx_msg void OnClickedBootLog();
	afx_msg void OnClickedNoGUIBoot();
	afx_msg void OnClickedSOS();
	afx_msg void OnClickedSafeBoot();
	afx_msg void OnClickedSBDSRepair();
	afx_msg void OnClickedSBMinimal();
	afx_msg void OnClickedSBMinimalAlt();
	afx_msg void OnClickedSBNetwork();
	afx_msg void OnChangeEditTimeOut();
	afx_msg void OnKillFocusEditTimeOut();
	afx_msg void OnClickedBootAdvanced();
	afx_msg void OnClickedSetAsDefault();
	afx_msg void OnClickedCheckBootPaths();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CStringArray		m_arrayIniLines;		// array of lines in the ini file
	int					m_nTimeoutIndex;		// list index of the "timeout=" line
	int					m_nDefaultIndex;		// list index of the "default=" line
	int					m_nMinOSIndex;			// first list index of an OS line
	int					m_nMaxOSIndex;			// last list index of an OS line
	CString				m_strSafeBoot;			// the current string for the safeboot flag
	BOOL				m_fIgnoreEdit;			// used to avoid a recursion problem
	CString				m_strOriginalContents;	// contents of the BOOT.INI as read
	CString				m_strFileName;			// name (with path) of the boot.ini file
	TabState			m_stateCurrent;			// USER or NORMAL state

	HWND GetDlgItemHWND(UINT nID)
	{
		HWND hwnd = NULL;
		CWnd * pWnd = GetDlgItem(nID);
		if (pWnd)
			hwnd = pWnd->m_hWnd;
		ASSERT(hwnd);
		return hwnd;
	}

	void UserMadeChange()
	{
		m_stateCurrent = USER;
		SetModified(TRUE);
	}

private:
	BOOL m_fModified;
	void SetModified(BOOL bChanged = TRUE)
	{
		m_fModified = bChanged;
		CPropertyPage::SetModified(bChanged);
	}
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PAGEBOOTINI_H__30CE1B24_CA43_4AFF_870C_7D49CCCF86BF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pageini.h ===
//=============================================================================
// PageIni.h : Declaration of the CPageIni
//=============================================================================

#if !defined(AFX_PAGEINI_H__99C60D0D_C4C9_4FE9_AFD4_58E806AAD967__INCLUDED_)
#define AFX_PAGEINI_H__99C60D0D_C4C9_4FE9_AFD4_58E806AAD967__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "MSConfigState.h"
#include "PageBase.h"

#define IMG_UNCHECKED	2
#define IMG_CHECKED		3
#define IMG_FUZZY		9
#define IMG_FUZZY_RTL	10
#define IMG_CHECKED_RTL	11

#define DISABLE_STRING			_T(";msconfig ")
#define DISABLE_STRING_HDR		_T(";msconfig [")
#define TESTING_EXTENSION_KEY	_T("IniPageExtension")

/////////////////////////////////////////////////////////////////////////////
// CPageIni dialog

class CPageIni : public CPropertyPage, public CPageBase
{
	DECLARE_DYNCREATE(CPageIni)

// Construction
public:
	CPageIni();
	~CPageIni();

// Dialog Data
	//{{AFX_DATA(CPageIni)
	enum { IDD = IDD_PAGEINI };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPageIni)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPageIni)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonDisable();
	afx_msg void OnButtonDisableAll();
	afx_msg void OnButtonEnable();
	afx_msg void OnButtonEnableAll();
	afx_msg void OnButtonMoveDown();
	afx_msg void OnButtonMoveUp();
	afx_msg void OnSelChangedTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonSearch();
	afx_msg void OnClickTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonEdit();
	afx_msg void OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonNew();
	afx_msg void OnBeginLabelEditIniTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeyDownTree(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void		SetTabInfo(LPCTSTR szFilename);

private:
	BOOL		LoadINIFile(CStringArray & lines, int & iLastLine, BOOL fLoadBackupFile = FALSE);
	BOOL		WriteINIFile(CStringArray & lines, int iLastLine, BOOL fUndoable = TRUE);
	void		UpdateTreeView();
	int			UpdateLine(HTREEITEM hti);
	void		SetEnable(BOOL fEnable, HTREEITEM htiNode = NULL, BOOL fUpdateLine = TRUE, BOOL fBroadcast = TRUE);
	void		MoveBranch(HWND hwndTree, HTREEITEM htiMove, HTREEITEM htiParent, HTREEITEM htiAfter);
	HTREEITEM	CopyBranch(HWND hwndTree, HTREEITEM htiFrom, HTREEITEM htiToParent, HTREEITEM htiToAfter);
	void		UpdateControls();
	HTREEITEM	GetNextItem(HTREEITEM hti);
	TabState	GetCurrentTabState();
	BOOL		OnApply();
	void		CommitChanges();
	void		SetNormal();
	void		SetDiagnostic();
	LPCTSTR		GetName() { return m_strINIFile; };

	HWND GetDlgItemHWND(UINT nID)
	{
		HWND hwnd = NULL;
		CWnd * pWnd = GetDlgItem(nID);
		if (pWnd)
			hwnd = pWnd->m_hWnd;
		ASSERT(hwnd);
		return hwnd;
	}

private:
	BOOL m_fModified;
	void SetModified(BOOL bChanged = TRUE)
	{
		m_fModified = bChanged;
		CPropertyPage::SetModified(bChanged);
	}

private:
	CStringArray	m_lines;			// the lines of the INI file
	int				m_iLastLine;		// last real line in the m_line array
	CString			m_strCaption;		// contains the localized name of this page
	CString			m_strINIFile;		// the INI file this page is editing
	CString			m_strTestExtension;	// is set, this is appended to the file name
	CString			m_strLastSearch;	// last string searched for
	CImageList		m_imagelist;		// bitmaps for the tree view
	BOOL			m_fImageList;		// did the image list load correctly
	CWindow			m_tree;				// we'll attach this to the tree
	int				m_checkedID;		// image ID for checked image
	int				m_uncheckedID;		// image ID for unchecked image
	int				m_fuzzyID;			// image ID for the indetermined state.
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PAGEINI_H__99C60D0D_C4C9_4FE9_AFD4_58E806AAD967__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pagegeneral.cpp ===
#include "stdafx.h"
#include "PageGeneral.h"
#include "PageServices.h"
#include "PageStartup.h"
#include "PageBootIni.h"
#include "PageIni.h"
#include "PageGeneral.h"
#include "ExpandDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define WM_SETCANCELTOCLOSE		WM_USER + 1

extern CPageServices *	ppageServices;
extern CPageStartup *	ppageStartup;
extern CPageBootIni *	ppageBootIni;
extern CPageIni *		ppageWinIni;
extern CPageIni *		ppageSystemIni;
extern CPageGeneral *	ppageGeneral;

/////////////////////////////////////////////////////////////////////////////
// CPageGeneral property page

IMPLEMENT_DYNCREATE(CPageGeneral, CPropertyPage)

CPageGeneral::CPageGeneral() : CPropertyPage(CPageGeneral::IDD)
{
	//{{AFX_DATA_INIT(CPageGeneral)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_fForceSelectiveRadio = FALSE;
}

CPageGeneral::~CPageGeneral()
{
}

void CPageGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPageGeneral)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPageGeneral, CPropertyPage)
	//{{AFX_MSG_MAP(CPageGeneral)
	ON_BN_CLICKED(IDC_DIAGNOSTICSTARTUP, OnDiagnosticStartup)
	ON_BN_CLICKED(IDC_NORMALSTARTUP, OnNormalStartup)
	ON_BN_CLICKED(IDC_SELECTIVESTARTUP, OnSelectiveStartup)
	ON_BN_CLICKED(IDC_CHECK_PROCSYSINI, OnCheckProcSysIni)
	ON_BN_CLICKED(IDC_CHECKLOADSTARTUPITEMS, OnCheckStartupItems)
	ON_BN_CLICKED(IDC_CHECKLOADSYSSERVICES, OnCheckServices)
	ON_BN_CLICKED(IDC_CHECKPROCWININI, OnCheckWinIni)
	ON_MESSAGE(WM_SETCANCELTOCLOSE, OnSetCancelToClose)
	ON_BN_CLICKED(IDC_RADIOMODIFIED, OnRadioModified)
	ON_BN_CLICKED(IDC_RADIOORIGINAL, OnRadioOriginal)
	ON_BN_CLICKED(IDC_BUTTONEXTRACT, OnButtonExtract)
	ON_BN_CLICKED(IDC_BUTTONLAUNCHSYSRESTORE, OnButtonSystemRestore)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPageGeneral message handlers

BOOL CPageGeneral::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	// Check to see if system restore is on this system (it should be).

	BOOL	fSysRestorePresent = FALSE;
	TCHAR	szPath[MAX_PATH];

	if (::ExpandEnvironmentStrings(_T("%windir%\\system32\\restore\\rstrui.exe"), szPath, MAX_PATH))
		fSysRestorePresent = FileExists(szPath);
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONLAUNCHSYSRESTORE), fSysRestorePresent);

	// Hide the radio buttons for BOOT.INI if there isn't any such page.

	if (NULL == ppageBootIni)
	{
		::ShowWindow(GetDlgItemHWND(IDC_RADIOORIGINAL), SW_HIDE);
		::ShowWindow(GetDlgItemHWND(IDC_RADIOMODIFIED), SW_HIDE);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

//-------------------------------------------------------------------------
// When the this tab is shown, we should update the buttons based on the
// states of the other tabs.
//-------------------------------------------------------------------------

BOOL CPageGeneral::OnSetActive()
{
	UpdateControls();
	return TRUE;
}

//-------------------------------------------------------------------------
// Update the controls on the general tab based on the state of all the
// other tabs.
//-------------------------------------------------------------------------

void CPageGeneral::UpdateControls()
{
	// Get the state for each tabs. The state will be set in the check box
	// associated with the particular tab, and an overall state will be
	// maintained.

	BOOL fAllNormal = TRUE;
	BOOL fAllDiagnostic = TRUE;

	if (ppageSystemIni)	
		UpdateCheckBox(ppageSystemIni, IDC_CHECK_PROCSYSINI, fAllNormal, fAllDiagnostic);

	if (ppageWinIni)	
		UpdateCheckBox(ppageWinIni, IDC_CHECKPROCWININI, fAllNormal, fAllDiagnostic);

	if (ppageServices)	
		UpdateCheckBox(ppageServices, IDC_CHECKLOADSYSSERVICES, fAllNormal, fAllDiagnostic);

	if (ppageStartup)	
		UpdateCheckBox(ppageStartup, IDC_CHECKLOADSTARTUPITEMS, fAllNormal, fAllDiagnostic);

	if (ppageBootIni)	
	{
		if (NORMAL == dynamic_cast<CPageBase *>(ppageBootIni)->GetCurrentTabState())
			CheckRadioButton(IDC_RADIOORIGINAL, IDC_RADIOMODIFIED, IDC_RADIOORIGINAL);
		else
		{
			fAllNormal = FALSE;
			CheckRadioButton(IDC_RADIOORIGINAL, IDC_RADIOMODIFIED, IDC_RADIOMODIFIED);
		}
	}

	// Set the radio button based on the states of the tabs.

	if (fAllNormal && !m_fForceSelectiveRadio)
		CheckRadioButton(IDC_NORMALSTARTUP, IDC_SELECTIVESTARTUP, IDC_NORMALSTARTUP);
	else if (fAllDiagnostic && !m_fForceSelectiveRadio)
		CheckRadioButton(IDC_NORMALSTARTUP, IDC_SELECTIVESTARTUP, IDC_DIAGNOSTICSTARTUP);
	else
		CheckRadioButton(IDC_NORMALSTARTUP, IDC_SELECTIVESTARTUP, IDC_SELECTIVESTARTUP);

	::EnableWindow(GetDlgItemHWND(IDC_CHECK_PROCSYSINI), ((!fAllNormal && !fAllDiagnostic) || m_fForceSelectiveRadio));
	::EnableWindow(GetDlgItemHWND(IDC_CHECKPROCWININI), ((!fAllNormal && !fAllDiagnostic) || m_fForceSelectiveRadio));
	::EnableWindow(GetDlgItemHWND(IDC_CHECKLOADSYSSERVICES), ((!fAllNormal && !fAllDiagnostic) || m_fForceSelectiveRadio));
	::EnableWindow(GetDlgItemHWND(IDC_CHECKLOADSTARTUPITEMS), ((!fAllNormal && !fAllDiagnostic) || m_fForceSelectiveRadio));

	if (ppageBootIni)	
	{
		if ((!fAllNormal && !fAllDiagnostic) || m_fForceSelectiveRadio)
		{
			::EnableWindow(GetDlgItemHWND(IDC_RADIOORIGINAL), TRUE);
			::EnableWindow(GetDlgItemHWND(IDC_RADIOMODIFIED), (IDC_RADIOMODIFIED == GetCheckedRadioButton(IDC_RADIOORIGINAL, IDC_RADIOMODIFIED)));
		}
		else
		{
			::EnableWindow(GetDlgItemHWND(IDC_RADIOMODIFIED), FALSE);
			::EnableWindow(GetDlgItemHWND(IDC_RADIOORIGINAL), FALSE);
		}
	}
}

//-------------------------------------------------------------------------
// Update the checkbox for pPage (indicated by nControlID) as well as
// updating fAllNormal and fAllDiagnostic.
//-------------------------------------------------------------------------

void CPageGeneral::UpdateCheckBox(CPageBase * pPage, UINT nControlID, BOOL & fAllNormal, BOOL & fAllDiagnostic)
{
	CPageBase::TabState state = pPage->GetCurrentTabState();
	UINT nCheck = BST_CHECKED;
	if (state == CPageBase::DIAGNOSTIC)
		nCheck = BST_UNCHECKED;
	else if (state == CPageBase::USER)
		nCheck = BST_INDETERMINATE;

	CheckDlgButton(nControlID, nCheck);

	// Finally, we need to keep track if all of the check boxes are either
	// NORMAL or DIAGNOSTIC.

	if (state != CPageBase::NORMAL)
		fAllNormal = FALSE;
	if (state != CPageBase::DIAGNOSTIC)
		fAllDiagnostic = FALSE;
}

//-------------------------------------------------------------------------
// Allow another tab (OK, only the BOOT.INI tab will ever use this) to
// force the selection of the Selective radio button.
//-------------------------------------------------------------------------

void CPageGeneral::ForceSelectiveRadio(BOOL fNewValue)
{
	m_fForceSelectiveRadio = fNewValue;
}

//-------------------------------------------------------------------------
// If the user clicks on the Startup or Diagnostic radio button, then
// all of the tabs will receive the appropriate notification.
//-------------------------------------------------------------------------

void CPageGeneral::OnDiagnosticStartup() 
{
	m_fForceSelectiveRadio = FALSE;

	if (ppageSystemIni)	dynamic_cast<CPageBase *>(ppageSystemIni)->SetDiagnostic();
	if (ppageWinIni)	dynamic_cast<CPageBase *>(ppageWinIni)->SetDiagnostic();
	if (ppageBootIni)	dynamic_cast<CPageBase *>(ppageBootIni)->SetDiagnostic();
	if (ppageServices)	dynamic_cast<CPageBase *>(ppageServices)->SetDiagnostic();
	if (ppageStartup)	dynamic_cast<CPageBase *>(ppageStartup)->SetDiagnostic();

	UpdateControls();
}

void CPageGeneral::OnNormalStartup() 
{
	m_fForceSelectiveRadio = FALSE;

	if (ppageSystemIni)	dynamic_cast<CPageBase *>(ppageSystemIni)->SetNormal();
	if (ppageWinIni)	dynamic_cast<CPageBase *>(ppageWinIni)->SetNormal();
	if (ppageBootIni)	dynamic_cast<CPageBase *>(ppageBootIni)->SetNormal();
	if (ppageServices)	dynamic_cast<CPageBase *>(ppageServices)->SetNormal();
	if (ppageStartup)	dynamic_cast<CPageBase *>(ppageStartup)->SetNormal();

	UpdateControls();
}

//-------------------------------------------------------------------------
// Most of the CPageBase functions we need to override (pure virtual)
// shouldn't do anything at all.
//-------------------------------------------------------------------------

CPageBase::TabState CPageGeneral::GetCurrentTabState()
{
	return NORMAL;
}

BOOL CPageGeneral::OnApply()
{
	this->PostMessage(WM_SETCANCELTOCLOSE);
	return TRUE;
}

void CPageGeneral::CommitChanges()
{
}

void CPageGeneral::SetNormal()
{
}

void CPageGeneral::SetDiagnostic()
{
}

//-------------------------------------------------------------------------
// For some reason, CancelToClose() doesn't work if called in the
// OnApply override. So that function posts a user message to this
// page, which is handled by this function.
//-------------------------------------------------------------------------

LRESULT CPageGeneral::OnSetCancelToClose(WPARAM wparam, LPARAM lparam)
{
	CancelToClose();
	return 0;
}

//-------------------------------------------------------------------------
// If the user selects selective startup radio button, force the selection
// to stick even if all the checkboxes are diagnostic or normal.
//-------------------------------------------------------------------------

void CPageGeneral::OnSelectiveStartup() 
{
	m_fForceSelectiveRadio = TRUE;
	UpdateControls();
}

//-------------------------------------------------------------------------
// Handles the typical case for the checkbox click.
//-------------------------------------------------------------------------

void CPageGeneral::OnClickedCheckBox(CPageBase * pPage, UINT nControlID)
{
	ASSERT(pPage);
	ASSERT(nControlID);

	UINT nCheck = IsDlgButtonChecked(nControlID);
	if (pPage != NULL)
	{
		switch (nCheck)
		{
		case BST_UNCHECKED:
			pPage->SetDiagnostic();
			break;

		case BST_INDETERMINATE:
			pPage->SetDiagnostic();
			break;

		case BST_CHECKED:
			pPage->SetNormal();
			break;
		}

		SetModified(TRUE);
		UpdateControls();
	}
}

//-------------------------------------------------------------------------
// If the user clicks on a check box, we should allow the user
// to toggle between DIAGNOSTIC and NORMAL.
//-------------------------------------------------------------------------

void CPageGeneral::OnCheckProcSysIni() 
{
	OnClickedCheckBox(ppageSystemIni, IDC_CHECK_PROCSYSINI);
}

void CPageGeneral::OnCheckStartupItems() 
{
	OnClickedCheckBox(ppageStartup, IDC_CHECKLOADSTARTUPITEMS);
}

void CPageGeneral::OnCheckServices() 
{
	OnClickedCheckBox(ppageServices, IDC_CHECKLOADSYSSERVICES);
}

void CPageGeneral::OnCheckWinIni() 
{
	OnClickedCheckBox(ppageWinIni, IDC_CHECKPROCWININI);
}

//-------------------------------------------------------------------------
// Handle radio button selections for the BOOT.INI control.
//-------------------------------------------------------------------------

void CPageGeneral::OnRadioModified() 
{
	// The user can never actually select this radio button. If this option
	// is enabled, it's because it is already selected.
}

void CPageGeneral::OnRadioOriginal() 
{
	if (ppageBootIni)
	{
		dynamic_cast<CPageBase *>(ppageBootIni)->SetNormal();
		::EnableWindow(GetDlgItemHWND(IDC_RADIOMODIFIED), FALSE);
	}

	UpdateControls();
}

//-------------------------------------------------------------------------
// Display the extract dialog.
//-------------------------------------------------------------------------

void CPageGeneral::OnButtonExtract() 
{
	CExpandDlg dlg;
	dlg.DoModal();
}

//-------------------------------------------------------------------------
// Launch System Restore, if it's around.
//-------------------------------------------------------------------------

void CPageGeneral::OnButtonSystemRestore() 
{
	TCHAR szPath[MAX_PATH];

	if (::ExpandEnvironmentStrings(_T("%windir%\\system32\\restore\\rstrui.exe"), szPath, MAX_PATH))
		::ShellExecute(NULL, NULL, szPath, NULL, NULL, SW_SHOWNORMAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pageinternational.cpp ===
// PageIni.cpp : Implementation of CPageIni
#include "stdafx.h"

#if FALSE
//#include "PageInternational.h"
//#include <windowsx.h>

/*
 * Convert an object (X) to a count of bytes (cb).
 */
#define cbX(X) sizeof(X)

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))


static const TCHAR REGSTR_VAL_DOSVMCP[] = TEXT("DOSCP");
static const TCHAR REGSTR_VAL_DOSCC[] = TEXT("DOSCC");
static const TCHAR REGSTR_VAL_DOSCFN[] = TEXT("DOSCFN");
static const TCHAR REGSTR_VAL_DOSCPFN[] = TEXT("DOSCPFN");
static const TCHAR REGSTR_VAL_DOSKFN[] = TEXT("DOSKFN");
static const TCHAR REGSTR_VAL_DOSKT[] = TEXT("DOSKT");
static const TCHAR REGSTR_VAL_DOSKL[] = TEXT("DOSKL");
static const TCHAR REGSTR_VAL_DOSLID[] = TEXT("DOSLID");

static const TCHAR c_CodepageKey[] = TEXT("System\\CurrentControlSet\\Control\\Nls\\Codepage");

// Language ID defines
#define NO_LANG_ID	TEXT("  ")
#define	LANG_ID_BE	TEXT("be")
#define	LANG_ID_BG	TEXT("bg")
#define	LANG_ID_BL	TEXT("bl")
#define	LANG_ID_BR	TEXT("br")
#define	LANG_ID_CA	TEXT("ca")
#define	LANG_ID_CF	TEXT("cf")
#define	LANG_ID_CZ	TEXT("cz")
#define	LANG_ID_DK	TEXT("dk")
#define	LANG_ID_ET	TEXT("et")
#define	LANG_ID_FR	TEXT("fr")
#define	LANG_ID_GK	TEXT("gk")
#define	LANG_ID_GR	TEXT("gr")
#define	LANG_ID_HE	TEXT("he")
#define	LANG_ID_HU	TEXT("hu")
#define	LANG_ID_IS	TEXT("is")
#define	LANG_ID_IT	TEXT("it")
#define	LANG_ID_LA	TEXT("la")
#define	LANG_ID_NL	TEXT("nl")
#define	LANG_ID_NO	TEXT("no")
#define	LANG_ID_PL	TEXT("pl")
#define	LANG_ID_PO	TEXT("po")
#define	LANG_ID_RO	TEXT("ro")
#define	LANG_ID_RU	TEXT("ru")
#define	LANG_ID_SF	TEXT("sf")
#define	LANG_ID_SG	TEXT("sg")
#define	LANG_ID_SL	TEXT("sl")
#define	LANG_ID_SP	TEXT("sp")
#define	LANG_ID_SU	TEXT("su")
#define	LANG_ID_SV	TEXT("sv")
#define LANG_ID_TR	TEXT("tr")
#define	LANG_ID_UK	TEXT("uk")
#define	LANG_ID_UR	TEXT("ur")
#define	LANG_ID_YC	TEXT("yc")
#define	LANG_ID_YU	TEXT("yu")


//----------------------------------------------------------------------
// International settings for all code pages

INTL_INFO cp_874[] = {
	{IDS_THAI,	0,	0,	0,	0,	NO_LANG_ID,	0,	0,	0},
};

INTL_INFO cp_932[] = {
	{IDS_JAPANESE_101,	932,	81,	101,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	0,	IDS_JKEYBRD_SYS},
	{IDS_JAPANESE_106,	932,	81,	106,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	0,	IDS_JKEYBRD_SYS},
};

INTL_INFO cp_936[] = {
	{IDS_CHINA,		936,	86,	0,	0,	NO_LANG_ID,	0,	0,	0},
};

INTL_INFO cp_949[] = {
	{IDS_KOREAN,	949,	82,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	0,	0},
};

INTL_INFO cp_950[] = {
	{IDS_TAIWAN,	950,	88,	0,	0,	NO_LANG_ID,	0,	0,	0},
};

INTL_INFO cp_1250[] = {
	{IDS_ALBANIAN,		852,	355,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	0},
	{IDS_CROATIAN,		852,	385,	0,	0,	LANG_ID_YU,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBRD2_SYS},
	{IDS_CZECH,			852,	42,		0,	0,	LANG_ID_CZ,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBRD2_SYS},
	{IDS_HUNGARIAN,		852,	36,		0,	0,	LANG_ID_HU,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBRD2_SYS},
	{IDS_POLISH,		852,	48,		0,	0,	LANG_ID_PL,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBRD2_SYS},
	{IDS_POLISH_Prgmers, 852,	48,		0,	0,	LANG_ID_PL,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBRD4_SYS},
	{IDS_ROMANIAN,		852,	40,		0,	0,	LANG_ID_RO,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBRD2_SYS},
	{IDS_SLOVAK,		852,	421,	0,	0,	LANG_ID_SL,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBRD2_SYS},
	{IDS_SLOVENIAN,		852,	386,	0,	0,	LANG_ID_YU,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBRD2_SYS},
};

INTL_INFO cp_1251[] = {
	{IDS_BELARUSSIAN,	866,	375,	0,	0,	LANG_ID_BL,	IDS_COUNTRY_SYS,	IDS_EGA3_CPI,	IDS_KEYBRD3_SYS},
	{IDS_BULGARIAN,		855,	359,	0,	0,	LANG_ID_BG,	IDS_COUNTRY_SYS,	IDS_EGA3_CPI,	IDS_KEYBRD2_SYS},
	{IDS_RUSSIAN,		866,	7,		0,	0,	LANG_ID_RU,	IDS_COUNTRY_SYS,	IDS_EGA3_CPI,	IDS_KEYBRD3_SYS},
	{IDS_SERBIAN,		855,	381,	0,	0,	LANG_ID_YC,	IDS_COUNTRY_SYS,	IDS_EGA3_CPI,	IDS_KEYBRD2_SYS},
	{IDS_UKRANIAN,		866,	380,	0,	0,	LANG_ID_UR,	IDS_COUNTRY_SYS,	IDS_EGA3_CPI,	IDS_KEYBRD3_SYS},
};

INTL_INFO cp_1252[] = {
	{IDS_AFRICAN,			850,	27,		0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	0},
	{IDS_BASQUE,			850,	34,		0,	0,	LANG_ID_SP,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_CATALAN,			850,	34,		0,	0,	LANG_ID_SP,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_DANISH,			850,	31,		0,	0,	LANG_ID_DK,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_DUTCH_Belgian,		850,	32,		0,	0,	LANG_ID_BE,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_DUTCH_Standard,	850,	31,		0,	0,	LANG_ID_NL,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_ENGLISH_United_States,	0,	0,		0,	0,	NO_LANG_ID,	0,					0,				0},								
	{IDS_ENGLISH_Australian, 437,	61,		0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	0},
	{IDS_ENGLISH_British,	850,	44,		0,	0,	LANG_ID_UK,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	0},
	{IDS_ENGLISH_Canadian,	850,	4,		0,	0,	LANG_ID_CA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	0},
	{IDS_ENGLISH_Ireland,	850,	353,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	0},
	{IDS_ENGLISH_New_Zealand, 850,	64,		0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	0},
	{IDS_FINISH,			850,	358,	0,	0,	LANG_ID_SU,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_FRENCH_Belgian,	850,	32,		0,	0,	LANG_ID_BE,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_FRENCH_Canadian,	850,	2,		0,	0,	LANG_ID_CF,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_FRENCH_Luxembourg,	850,	33,		0,	0,	LANG_ID_FR,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_FRENCH_Standard,	850,	33,		0,	0,	LANG_ID_FR,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_FRENCH_Swiss,		850,	41,		0,	0,	LANG_ID_SF,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_GERMAN_Austrian,	850,	43,		0,	0,	LANG_ID_GR,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_GERMAN_Liechtenstein, 850,	49,		0,	0,	LANG_ID_GR,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_GERMAN_Luxembourg,	850,	49,		0,	0,	LANG_ID_GR,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_GERMAN_Standard,	850,	49,		0,	0,	LANG_ID_GR,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_GERMAN_Swiss,		850,	41,		0,	0,	LANG_ID_SG,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_ICELANDIC,			850,	354,	0,	0,	LANG_ID_IS,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_INDONESIAN,		850,	785,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	0},
	{IDS_ITALIAN_Standard,	850,	39,		0,	0,	LANG_ID_IT,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_ITALIAN_142_Standard, 850,	39,		0,	142, LANG_ID_IT, IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_ITALIAN_Swiss,		850,	41,		0,	0,	LANG_ID_IT,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_NORWEGIAN,			850,	47,		0,	0,	LANG_ID_NO,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_PORTUGUESE_Standard, 850,	351,	0,	0,	LANG_ID_PO,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_PORTUGUESE_Brazilian, 850,	55,		0,	0,	LANG_ID_BR,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Argentina,	850,	54,		0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Bolivia,	850,	591,	0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Chile,		850,	56,		0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Colombia,	850,	57,		0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Costa_Rica, 850,	3,		0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Ecuador,	850,	593,	0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_El_Salvador, 850,	503,	0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Honduras,	850,	504,	0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Mexico,	850,	52,		0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Modern_Sort, 850,	34,		0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Nicaragua,	850,	505,	0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SPANISH_Venezuela,	850,	58,		0,	0,	LANG_ID_LA,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
	{IDS_SWEDISH,			850,	46,		0,	0,	LANG_ID_SV,	IDS_COUNTRY_SYS,	IDS_EGA_CPI,	IDS_KEYBOARD_SYS},
};

INTL_INFO cp_1253[] = {
	{IDS_GREEK_737_LATIN,			737,	30,	0,	0,		LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_737_437_LATIN,		737,	30,	0,	0,		LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_869_LATIN,			869,	30,	0,	0,		LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_869_851_LATIN,		869,	30,	0,	0,		LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_737_IBM220,			737,	30,	0,	220,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_737_437_IBM220,		737,	30,	0,	220,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_869_IBM220,			869,	30,	0,	220,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_869_851_IBM220,		869,	30,	0,	220,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_737_IBM319,			737,	30,	0,	319,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_737_437_IBM319,		737,	30,	0,	319,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_869_IBM319,			869,	30,	0,	319,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_869_851_IBM319,		869,	30,	0,	319,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_737_LATIN_IBM319,	737,	30,	0,	319,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_737_437_LATIN_IBM319, 737,	30,	0,	319,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_869_LATIN_IBM319,	869,	30,	0,	319,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
	{IDS_GREEK_869_851_LATIN_IBM319, 869,	30,	0,	319,	LANG_ID_GK,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD4_SYS},
};

INTL_INFO cp_1254[] = {
	{IDS_TURKISH_F_TYPE,	857,	90,	0,	440,	LANG_ID_TR,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD2_SYS},
	{IDS_TURKISH_Q_TYPE,	857,	90,	0,	179,	LANG_ID_TR,	IDS_COUNTRY_SYS,	IDS_EGA2_CPI,	IDS_KEYBRD2_SYS},
};

INTL_INFO cp_1255[] = {
	{IDS_HEBREW,		862,	972,	0,	400,	LANG_ID_HE,	IDS_COUNTRY_SYS,	IDS_HEBEGA_CPI,	0},
};

INTL_INFO cp_1256[] = {
	{IDS_ARABIC_Algeria,	720,	213,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Bahrain,	720,	973,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Egypt,		720,	20,		0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Iraq,		720,	964,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Jordan,		720,	961,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Kuwait,		720,	965,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Lebanon,	720,	961,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Libya,		720,	218,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Morocco,	720,	212,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Oman,		720,	969,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Qatar,		720,	974,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Saudi_Arabia, 720,	966,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Syria,		720,	963,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Tunisia,	720,	216,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_U_A_E,		720,	971,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
	{IDS_ARABIC_Yemen,		720,	969,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA4_CPI,	0},
};

INTL_INFO cp_1257[] = {
	{IDS_ESTONIAN,		775,	372,	0,	0,	LANG_ID_ET,	IDS_COUNTRY_SYS,	IDS_EGA3_CPI,	IDS_KEYBRD4_SYS},
	{IDS_LATVIAN,		775,	371,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA3_CPI,	0},
	{IDS_LITHUANIAN,	775,	370,	0,	0,	NO_LANG_ID,	IDS_COUNTRY_SYS,	IDS_EGA3_CPI,	0},
};

INTL_INFO cp_1258[] = {
	{IDS_VIETNAMESE,	0,	0,	0,	0,	NO_LANG_ID,	0,	0,	0},
};
//----------------------------------------------------------------------
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// Intl_SetEditText
//
// Sets an editbox text with a reg entry.

void CPageInternational::Intl_SetEditText(HKEY hKey, LPCTSTR ptszRegValue, int ids, LPTSTR ptszCur)
{
	TCHAR tszData[MAX_PATH*2];
	DWORD cbData = sizeof(tszData);

	if (RegQueryValueEx(hKey, ptszRegValue, NULL, NULL, (LPBYTE)tszData,
						&cbData) == ERROR_SUCCESS)
	{
		::SetWindowText(GetDlgItem(ids), tszData);

		// saving appropriate initial setting
		lstrcpy(ptszCur, tszData);
	}
}

//----------------------------------------------------------------------
// Intl_SetRegValue
//
// Sets a reg entry with an editbox text (removes reg entry if text is empty).

void CPageInternational::Intl_SetRegValue(HKEY hKey, int ids, LPCTSTR ptszRegValue)
{
	TCHAR tszData[MAX_PATH*2];

	::GetWindowText(GetDlgItem(ids), tszData, MAX_PATH*2);
	if (tszData[0] != '\0')
		RegSetValueEx(hKey, ptszRegValue, 0, REG_SZ, (LPBYTE)tszData, lstrlen(tszData) + 1);
	else
		RegDeleteValue(hKey, ptszRegValue);
}

void CPageInternational::Intl_GetTextFromNum(UINT nNum, LPTSTR ptszText)
{
	if (nNum)
		_itoa(nNum, ptszText, 10);
	else
		lstrcpy(ptszText, "");
}

//----------------------------------------------------------------------
// Intl_GetTextFromIDS
//
// Helper for loading resource into string.

void CPageInternational::Intl_GetTextFromIDS(int ids, LPTSTR ptszText)
{
	if (ids)
	{
		CString str;

		str.LoadString(ids);
		ExpandEnvironmentStrings(str, ptszText, MAX_PATH);
	}
	else
		lstrcpy(ptszText, "");
}

//----------------------------------------------------------------------
// Intl_GetCPArray
//
// Returns proper array of intl settings for passed in code page.

UINT CPageInternational::Intl_GetCPArray(UINT nCodePage, INTL_INFO **ppIntlInfo)
{
	UINT cElements;

	switch(nCodePage)
	{
	case 874:
		*ppIntlInfo = cp_874;
		cElements = cA(cp_874);
		break;

	case 932:
		*ppIntlInfo = cp_932;
		cElements = cA(cp_932);
		break;

	case 936:
		*ppIntlInfo = cp_936;
		cElements = cA(cp_936);
		break;

	case 949:
		*ppIntlInfo = cp_949;
		cElements = cA(cp_949);
		break;

	case 950:
		*ppIntlInfo = cp_950;
		cElements = cA(cp_950);
		break;

	case 1250:
		*ppIntlInfo = cp_1250;
		cElements = cA(cp_1250);
		break;

	case 1251:
		*ppIntlInfo = cp_1251;
		cElements = cA(cp_1251);
		break;

	case 1252:
		*ppIntlInfo = cp_1252;
		cElements = cA(cp_1252);
		break;

	case 1253:
		*ppIntlInfo = cp_1253;
		cElements = cA(cp_1253);
		break;

	case 1254:
		*ppIntlInfo = cp_1254;
		cElements = cA(cp_1254);
		break;

	case 1255:
		*ppIntlInfo = cp_1255;
		cElements = cA(cp_1255);
		break;

	case 1256:
		*ppIntlInfo = cp_1256;
		cElements = cA(cp_1256);
		break;

	case 1257:
		*ppIntlInfo = cp_1257;
		cElements = cA(cp_1257);
		break;

	case 1258:
		*ppIntlInfo = cp_1258;
		cElements = cA(cp_1258);
		break;

	default:
		*ppIntlInfo = NULL;
		cElements = 0;
	}
	return cElements;
}

CPageInternational::CPageInternational()
{
	m_uiCaption = IDS_INTERNATIONAL_CAPTION;
	m_strName = _T("international");

	// init flags
	m_fInitializing = TRUE;
	m_fIntlDirty = FALSE;

	// init initial settings
	m_tszCurDOSCodePage[0] = '\0';
	m_tszCurCountryCode[0] = '\0';
	m_tszCurKeyboardType[0] = '\0';
	m_tszCurKeyboardLayout[0] = '\0';
	m_tszCurLanguageID[0] = '\0';
	m_tszCurCountryFilename[0] = '\0';
	m_tszCurCodePageFilename[0] = '\0';
	m_tszCurKeyboardFilename[0] = '\0';
}
/////////////////////////////////////////////////////////////////////////////
// CPageIni
LRESULT CPageInternational::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HWND hLang;
	INTL_INFO *pIntlInfo = NULL;
	UINT cElements, i, nItem;
	CString szLanguage;
	HKEY hKey;

	::EnableWindow(GetDlgItem(IDC_EDITCODEPAGE), TRUE);
	::EnableWindow(GetDlgItem(IDC_EDITCOUNTRYCODE), TRUE);
	::EnableWindow(GetDlgItem(IDC_EDITCOUNTRYDATAFILE), TRUE);
	::EnableWindow(GetDlgItem(IDC_EDITDISPLAYDATAFILE), TRUE);
	::EnableWindow(GetDlgItem(IDC_EDITKEYBOARDDATAFILE), TRUE);
	::EnableWindow(GetDlgItem(IDC_EDITKEYBOARDTYPE), TRUE);
	::EnableWindow(GetDlgItem(IDC_EDITKEYBOARDLAYOUT), TRUE);
	::EnableWindow(GetDlgItem(IDC_EDITLANGUAGEID), TRUE);
	::EnableWindow(GetDlgItem(IDC_COMBOLANGUAGES), TRUE);

	hLang = GetDlgItem(IDC_COMBOLANGUAGES);

	// set and select first Language combo box item
	szLanguage.LoadString(IDS_NO_LANG);
	nItem = ComboBox_AddString(hLang, szLanguage);
	ComboBox_SetCurSel(hLang, nItem);
	//nItem = ComboBox_AddString(hLang, TEXT("ABC"));

	// fill Language combo box based on active code page
	cElements = Intl_GetCPArray(GetACP(), &pIntlInfo);
	for (i = 0; i < cElements; i++)
	{
		szLanguage.LoadString(pIntlInfo[i].idsName);
		nItem = ComboBox_AddString(hLang, szLanguage.GetBuffer(0));
		ComboBox_SetItemData(hLang, nItem, &pIntlInfo[i]); 
	}

	// Open Codepage reg key
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_CodepageKey, 0, KEY_READ, &hKey)
		== ERROR_SUCCESS)
	{
		// set all edit boxes
		Intl_SetEditText(hKey, REGSTR_VAL_DOSVMCP, IDC_EDITCODEPAGE, m_tszCurDOSCodePage);
		Intl_SetEditText(hKey, REGSTR_VAL_DOSCC, IDC_EDITCOUNTRYCODE, m_tszCurCountryCode);
		Intl_SetEditText(hKey, REGSTR_VAL_DOSCFN, IDC_EDITCOUNTRYDATAFILE, m_tszCurCountryFilename);
		Intl_SetEditText(hKey, REGSTR_VAL_DOSCPFN, IDC_EDITDISPLAYDATAFILE, m_tszCurCodePageFilename);
		Intl_SetEditText(hKey, REGSTR_VAL_DOSKFN, IDC_EDITKEYBOARDDATAFILE, m_tszCurKeyboardFilename);
		Intl_SetEditText(hKey, REGSTR_VAL_DOSKT, IDC_EDITKEYBOARDTYPE, m_tszCurKeyboardType);
		Intl_SetEditText(hKey, REGSTR_VAL_DOSKL, IDC_EDITKEYBOARDLAYOUT, m_tszCurKeyboardLayout);
		Intl_SetEditText(hKey, REGSTR_VAL_DOSLID, IDC_EDITLANGUAGEID, m_tszCurLanguageID);

		RegCloseKey(hKey);
	}

	// limit appropriate edit boxes
	Edit_LimitText(GetDlgItem(IDC_EDITCODEPAGE), 5);
	Edit_LimitText(GetDlgItem(IDC_EDITCOUNTRYCODE), 5);
	Edit_LimitText(GetDlgItem(IDC_EDITKEYBOARDTYPE), 5);
	Edit_LimitText(GetDlgItem(IDC_EDITKEYBOARDLAYOUT), 5);
	Edit_LimitText(GetDlgItem(IDC_EDITLANGUAGEID), 2);

	// Done initializing
	m_fInitializing = FALSE;

	return TRUE;
}

LRESULT CPageInternational::OnSelchangeCombolanguages(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	int nItem;
	TCHAR tszText[MAX_PATH];
	INTL_INFO *pIntlInfo;

	nItem = ComboBox_GetCurSel(hWndCtl);
	if (nItem != CB_ERR)
	{
		if (nItem == 0)
		{
			// set to initial settings
			::SetWindowText(GetDlgItem(IDC_EDITCODEPAGE), m_tszCurDOSCodePage);
			::SetWindowText(GetDlgItem(IDC_EDITCOUNTRYCODE), m_tszCurCountryCode);
			::SetWindowText(GetDlgItem(IDC_EDITCOUNTRYDATAFILE), m_tszCurCountryFilename);
			::SetWindowText(GetDlgItem(IDC_EDITDISPLAYDATAFILE), m_tszCurCodePageFilename);
			::SetWindowText(GetDlgItem(IDC_EDITKEYBOARDDATAFILE), m_tszCurKeyboardFilename);
			::SetWindowText(GetDlgItem(IDC_EDITKEYBOARDTYPE), m_tszCurKeyboardType);
			::SetWindowText(GetDlgItem(IDC_EDITKEYBOARDLAYOUT), m_tszCurKeyboardLayout);
			::SetWindowText(GetDlgItem(IDC_EDITLANGUAGEID), m_tszCurLanguageID);
		}
		else
		{
			pIntlInfo = (INTL_INFO*)ComboBox_GetItemData(hWndCtl, nItem);
			if (pIntlInfo)
			{
				// set DOS code page
				Intl_GetTextFromNum(pIntlInfo->nDOSCodePage, tszText);
				::SetWindowText(GetDlgItem(IDC_EDITCODEPAGE), tszText);

				// set country code
				Intl_GetTextFromNum(pIntlInfo->nCountryCode, tszText);
				::SetWindowText(GetDlgItem(IDC_EDITCOUNTRYCODE), tszText);

				// set country data file name
				Intl_GetTextFromIDS(pIntlInfo->idsCountryFilename, tszText);
				::SetWindowText(GetDlgItem(IDC_EDITCOUNTRYDATAFILE), tszText);

				// set display data file name
				Intl_GetTextFromIDS(pIntlInfo->idsCodePageFilename, tszText);
				::SetWindowText(GetDlgItem(IDC_EDITDISPLAYDATAFILE), tszText);

				// set keyboard data file name
				Intl_GetTextFromIDS(pIntlInfo->idsKeyboardFilename, tszText);
				::SetWindowText(GetDlgItem(IDC_EDITKEYBOARDDATAFILE), tszText);

				// set keyboard type
				Intl_GetTextFromNum(pIntlInfo->nKeyboardType, tszText);
				::SetWindowText(GetDlgItem(IDC_EDITKEYBOARDTYPE), tszText);

				// set keyboard layout
				Intl_GetTextFromNum(pIntlInfo->nKeyboardLayout, tszText);
				::SetWindowText(GetDlgItem(IDC_EDITKEYBOARDLAYOUT), tszText);

				// set language id
				if (lstrcmp(pIntlInfo->tszLanguageID, NO_LANG_ID) != 0)
					lstrcpyn(tszText, pIntlInfo->tszLanguageID, 3);
				else
					tszText[0] = '\0';
				::SetWindowText(GetDlgItem(IDC_EDITLANGUAGEID), tszText);
			}
		}
	}
	return 0;
}

HRESULT CPageInternational::Notify(LPCTSTR szFromTab, LPCTSTR szToTab, TabNotify msg)
{
	if (CPageBase::Notify(szFromTab, szToTab, msg) == S_FALSE)
		return S_FALSE;

	HRESULT hrReturn = S_OK;
	HKEY hKey;

	switch (msg)
	{
	case TAB_APPLY:
		if (!IsDirty())
			return S_OK;
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_CodepageKey, 0, KEY_WRITE, &hKey)
			== ERROR_SUCCESS)
		{
			Intl_SetRegValue(hKey, IDC_EDITCODEPAGE, REGSTR_VAL_DOSVMCP);
			Intl_SetRegValue(hKey, IDC_EDITCOUNTRYCODE, REGSTR_VAL_DOSCC);
			Intl_SetRegValue(hKey, IDC_EDITCOUNTRYDATAFILE, REGSTR_VAL_DOSCFN);
			Intl_SetRegValue(hKey, IDC_EDITDISPLAYDATAFILE, REGSTR_VAL_DOSCPFN);
			Intl_SetRegValue(hKey, IDC_EDITKEYBOARDDATAFILE, REGSTR_VAL_DOSKFN);
			Intl_SetRegValue(hKey, IDC_EDITKEYBOARDTYPE, REGSTR_VAL_DOSKT);
			Intl_SetRegValue(hKey, IDC_EDITKEYBOARDLAYOUT, REGSTR_VAL_DOSKL);
			Intl_SetRegValue(hKey, IDC_EDITLANGUAGEID, REGSTR_VAL_DOSLID);

			RegCloseKey(hKey);
		}
		break;
	case TAB_NORMAL:
	case TAB_DIAGNOSTIC:
	default:
		break;
	}

	return hrReturn;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pageregistry.cpp ===
// PageIni.cpp : Implementation of CPageIni
#include "stdafx.h"
#include "PageRegistry.h"

/////////////////////////////////////////////////////////////////////////////
// CPageIni
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\rebootdlg.cpp ===
// rebootdlg.cpp : Implementation of CRebootDlg
#include "stdafx.h"
#include "rebootdlg.h"

/////////////////////////////////////////////////////////////////////////////
// CRebootDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pageregistry.h ===
// PageIni.h : Declaration of the CPageIni

// Commenting out this whole file - we're dropping the registry tab.

#if FALSE
/*
#ifndef __PAGEREGISTRY_H_
#define __PAGEREGISTRY_H_

#include "resource.h"       // main symbols
#include <atlhost.h>
#include "msconfigstate.h"
#include "pagebase.h"

/////////////////////////////////////////////////////////////////////////////
// CPageIni
class CPageRegistry : public CAxDialogImpl<CPageRegistry>, public CPageBase
{
public:
	CPageRegistry()
	{
		m_uiCaption = IDS_REGISTRY_CAPTION;
		m_strName = _T("registry");
	}

	~CPageRegistry()
	{
	}

	enum { IDD = IDD_PAGEREGISTRY };

BEGIN_MSG_MAP(CPageIni)
MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		::EnableWindow(GetDlgItem(IDC_LISTBOXREGISTRY), FALSE);
		::EnableWindow(GetDlgItem(IDC_BUTTONRUNREGCLEAN), FALSE);
		::EnableWindow(GetDlgItem(IDC_BUTTONCHECKREGISTRY), FALSE);
		return 0;
	}

private:
	//-------------------------------------------------------------------------
	// Overloaded functions from CPageBase (see CPageBase declaration for the
	// usage of these methods).
	//-------------------------------------------------------------------------

	void CreatePage(HWND hwnd, const RECT & rect)
	{
		Create(hwnd);
		MoveWindow(&rect);
	}

	CWindow * GetWindow()
	{
		return ((CWindow *)this);
	}

	BOOL Apply(CString * pstrTab, CString * pstrDescription, CString * pstrEntry)
	{
		SetDirty(FALSE);
		return TRUE;
	}

	BOOL Undo(const CString & strEntry)
	{
		return FALSE;
	}
};

#endif //__PAGEREGISTRY_H_
  */
#endif // FALSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pageservices.cpp ===
#include "stdafx.h"
#include "PageServices.h"
#include "MSConfigState.h"
#include "EssentialSvcDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This array contains the list of essential services. These must be in 
// lower case (for a caseless comparison).

LPCTSTR aszEssentialServices[] = 
{
	_T("rpclocator"),
	_T("rpcss"),
	NULL
};

/////////////////////////////////////////////////////////////////////////////
// CPageServices property page

IMPLEMENT_DYNCREATE(CPageServices, CPropertyPage)

CPageServices::CPageServices() : CPropertyPage(CPageServices::IDD)
{
	//{{AFX_DATA_INIT(CPageServices)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_fFillingList = FALSE;
	m_pBuffer = NULL;
	m_dwSize = 0;
	m_fHideMicrosoft = FALSE;
	m_fShowWarning = TRUE;
	m_fModified	= FALSE;
}

CPageServices::~CPageServices()
{
	if (m_pBuffer)
		delete [] m_pBuffer;
}

void CPageServices::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPageServices)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPageServices, CPropertyPage)
	//{{AFX_MSG_MAP(CPageServices)
	ON_WM_DESTROY()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LISTSERVICES, OnItemChangedListServices)
	ON_BN_CLICKED(IDC_BUTTONSERVDISABLEALL, OnButtonDisableAll)
	ON_BN_CLICKED(IDC_BUTTONSERVENABLEALL, OnButtonEnableAll)
	ON_BN_CLICKED(IDC_CHECKHIDEMS, OnCheckHideMS)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LISTSERVICES, OnColumnClickListServices)
	ON_NOTIFY(NM_SETFOCUS, IDC_LISTSERVICES, OnSetFocusList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPageServices message handlers

BOOL CPageServices::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	// Attach a CWindow to the list and set it up to have check boxes.

	m_list.Attach(GetDlgItem(IDC_LISTSERVICES)->m_hWnd);
	ListView_SetExtendedListViewStyle(m_list.m_hWnd, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

	// Insert all of the columns in the list.

	struct { UINT m_uiStringResource; int m_iPercentOfWidth; } aColumns[] = 
	{
		{ IDS_STATUS_COLUMN, 12 },
		{ IDS_MANUFACTURER_COLUMN, 44 },
		{ IDS_REQUIREDSERVICE, 12 },
		{ IDS_SERVICE_COLUMN, 30 },
		{ 0, 0 }
	};

	CRect rect;
	m_list.GetClientRect(&rect);
	int cxWidth = rect.Width();

	LVCOLUMN lvc;
	lvc.mask = LVCF_TEXT | LVCF_WIDTH;

	CString strCaption;

	m_fFillingList = TRUE;
	::AfxSetResourceHandle(_Module.GetResourceInstance());
	for (int i = 0; aColumns[i].m_uiStringResource; i++)
	{
		strCaption.LoadString(aColumns[i].m_uiStringResource);
		lvc.pszText = (LPTSTR)(LPCTSTR)strCaption;
		lvc.cx = aColumns[i].m_iPercentOfWidth * cxWidth / 100;
		ListView_InsertColumn(m_list.m_hWnd, 0, &lvc);
	}

	LoadServiceList();
	SetCheckboxesFromRegistry();
	m_fFillingList = FALSE;

	CheckDlgButton(IDC_CHECKHIDEMS, (m_fHideMicrosoft) ? BST_CHECKED : BST_UNCHECKED);

	DWORD dwValue;
	CRegKey regkey;
	regkey.Attach(GetRegKey());
	m_fShowWarning = (ERROR_SUCCESS != regkey.QueryValue(dwValue, HIDEWARNINGVALUE));

	m_iLastColumnSort = -1;

	SetControlState();

	m_fInitialized = TRUE;
	return TRUE;  // return TRUE unless you set the focus to a control
}

void CPageServices::OnDestroy() 
{
	CPropertyPage::OnDestroy();
	EmptyServiceList(FALSE);
}

//-------------------------------------------------------------------------
// Load the list of services into the list view.
//-------------------------------------------------------------------------

void CPageServices::LoadServiceList()
{
	SC_HANDLE sch = ::OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
	if (sch == NULL)
		return;

	DWORD dwSize = 0, dwBytesNeeded, dwServicesReturned, dwResume = 0;
	LVITEM lvi;

	// Might want SERVICE_DRIVER | SERVICE_WIN32

 	if (!EnumServicesStatus(sch, SERVICE_WIN32, SERVICE_STATE_ALL, NULL, dwSize, &dwBytesNeeded, &dwServicesReturned, &dwResume))
	{
		if (::GetLastError() == ERROR_MORE_DATA)
		{
			dwSize = dwBytesNeeded;
			dwResume = 0;

			LPBYTE lpBuffer = new BYTE[dwSize];
			if (lpBuffer != NULL && EnumServicesStatus(sch, SERVICE_WIN32, SERVICE_STATE_ALL, (LPENUM_SERVICE_STATUS)lpBuffer, dwSize, &dwBytesNeeded, &dwServicesReturned, &dwResume))
			{
				LPENUM_SERVICE_STATUS pServices = (LPENUM_SERVICE_STATUS) lpBuffer;

				CString strStopped, strStartPending, strStopPending, strRunning, strContinuePending, strPausePending, strPaused;
				CString	strYes;
				LPTSTR  szEmpty = _T("");

				strStopped.LoadString(IDS_SERVICESTOPPED);
				strStartPending.LoadString(IDS_SERVICESTARTPENDING);
				strStopPending.LoadString(IDS_SERVICESTOPPENDING);
				strRunning.LoadString(IDS_SERVICERUNNING);
				strContinuePending.LoadString(IDS_SERVICECONTINUEPENDING);
				strPausePending.LoadString(IDS_SERVICEPAUSEPENDING);
				strPaused.LoadString(IDS_SERVICEPAUSED);
				strYes.LoadString(IDS_YES);

				CRegKey regkey;
				regkey.Attach(GetRegKey(GetName()));
			
				int iPosition = 0;
				for (DWORD dwIndex = 0; dwIndex < dwServicesReturned; dwIndex++)
				{
					// We want to skip any services that are already disabled, unless
					// that service was disabled by us. If it was disabled by us, then
					// it will be in the registry.

					DWORD	dwStartType;
					CString strPath;

					SC_HANDLE schService = ::OpenService(sch, pServices->lpServiceName, SERVICE_QUERY_CONFIG);
					if (schService == NULL)
					{
						pServices++;
						continue;
					}

					if (!GetServiceInfo(schService, dwStartType, strPath))
					{
						::CloseServiceHandle(schService);
						pServices++;
						continue;
					}

					::CloseServiceHandle(schService);

					if (dwStartType == SERVICE_DISABLED)
						if (ERROR_SUCCESS != regkey.QueryValue(dwStartType, pServices->lpServiceName))
						{
							pServices++;
							continue;
						}

					// If we are hiding Microsoft services, check the manufacturer.

					CString strManufacturer;
					GetManufacturer(strPath, strManufacturer);
					if (m_fHideMicrosoft)
					{
						CString strSearch(strManufacturer);
						strSearch.MakeLower();
						if (strSearch.Find(_T("microsoft")) != -1)
						{
							pServices++;
							continue;
						}
					}

					// Insert the three columns.

					CServiceInfo * pServiceInfo = new CServiceInfo(pServices->lpServiceName, FALSE, dwStartType, strManufacturer, pServices->lpDisplayName);
					lvi.pszText = pServices->lpDisplayName;
					lvi.iSubItem = 0;
					lvi.iItem = iPosition++;
					lvi.lParam = (LPARAM) pServiceInfo;
					lvi.mask = LVIF_TEXT | LVIF_PARAM;
					ListView_InsertItem(m_list.m_hWnd, &lvi);
					lvi.mask = LVIF_TEXT;

					lvi.pszText = IsServiceEssential((CServiceInfo *)lvi.lParam) ? ((LPTSTR)(LPCTSTR)strYes) : szEmpty;
					lvi.iSubItem = 1;
					pServiceInfo->m_strEssential = lvi.pszText;
					ListView_SetItem(m_list.m_hWnd, &lvi);

					lvi.pszText = (LPTSTR)(LPCTSTR)strManufacturer;
					lvi.iSubItem = 2;
					ListView_SetItem(m_list.m_hWnd, &lvi);

					switch (pServices->ServiceStatus.dwCurrentState)
					{
					case SERVICE_STOPPED:
						lvi.pszText = (LPTSTR)(LPCTSTR)strStopped; break;
					case SERVICE_START_PENDING:
						lvi.pszText = (LPTSTR)(LPCTSTR)strStartPending; break;
					case SERVICE_STOP_PENDING:
						lvi.pszText = (LPTSTR)(LPCTSTR)strStopPending; break;
					case SERVICE_RUNNING:
						lvi.pszText = (LPTSTR)(LPCTSTR)strRunning; break;
					case SERVICE_CONTINUE_PENDING:
						lvi.pszText = (LPTSTR)(LPCTSTR)strContinuePending; break;
					case SERVICE_PAUSE_PENDING:
						lvi.pszText = (LPTSTR)(LPCTSTR)strPausePending; break;
					case SERVICE_PAUSED:
						lvi.pszText = (LPTSTR)(LPCTSTR)strPaused; break;
					}

					lvi.iSubItem = 3;
					pServiceInfo->m_strStatus = lvi.pszText;
					ListView_SetItem(m_list.m_hWnd, &lvi);

					pServices++;
				}
			}
			delete [] lpBuffer;
		}
	}

	::CloseServiceHandle(sch);
}

//-------------------------------------------------------------------------
// Empty the list of services.
//-------------------------------------------------------------------------

void CPageServices::EmptyServiceList(BOOL fUpdateUI)
{
	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		lvi.iItem = i;

		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CServiceInfo * pService = (CServiceInfo *)lvi.lParam;
			if (pService)
				delete pService;
		}
	}

	if (fUpdateUI)
		ListView_DeleteAllItems(m_list.m_hWnd);
}

//-------------------------------------------------------------------------
// Sets the check boxes in the list view to the state stored in the
// registry (which contains a list of what we've disabled).
//-------------------------------------------------------------------------

void CPageServices::SetCheckboxesFromRegistry()
{
	CRegKey regkey;
	regkey.Attach(GetRegKey(GetName()));

	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		lvi.iItem = i;

		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CServiceInfo * pService = (CServiceInfo *)lvi.lParam;
			if (pService)
			{
				if (ERROR_SUCCESS == regkey.QueryValue(pService->m_dwOldState, (LPCTSTR)pService->m_strService))
				{
					ListView_SetCheckState(m_list.m_hWnd, i, FALSE);
					pService->m_fChecked = FALSE;
				}
				else
				{
					ListView_SetCheckState(m_list.m_hWnd, i, TRUE);
					pService->m_fChecked = TRUE;
				}
			}
		}
	}
}

//-------------------------------------------------------------------------
// Sets the registry list of disabled services from the checkboxes in the
// list. If fCommit is true, it means that we are applying the changes
// permanently. Remove all the registry entries which would allow us
// to undo a change.
//-------------------------------------------------------------------------

void CPageServices::SetRegistryFromCheckboxes(BOOL fCommit)
{
	CRegKey regkey;
	regkey.Attach(GetRegKey(GetName()));

	if ((HKEY)regkey != NULL)
	{
		LVITEM lvi;
		lvi.mask = LVIF_PARAM;
		lvi.iSubItem = 0;

		for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
		{
			lvi.iItem = i;

			if (ListView_GetItem(m_list.m_hWnd, &lvi))
			{
				CServiceInfo * pService = (CServiceInfo *)lvi.lParam;
				if (pService)
				{
					if (!pService->m_fChecked && !fCommit)
						regkey.SetValue(pService->m_dwOldState, (LPCTSTR)pService->m_strService);
					else
						regkey.DeleteValue((LPCTSTR)pService->m_strService);
				}
			}
		}
	}
}

//-------------------------------------------------------------------------
// Set the state for all of the services. Note - if the new state is false
// (disabled) don't set the state for necessary services).
//-------------------------------------------------------------------------

void CPageServices::SetStateAll(BOOL fNewState)
{
	m_fFillingList = TRUE;

	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		lvi.iItem = i;

		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CServiceInfo * pService = (CServiceInfo *)lvi.lParam;
			if (pService && !IsServiceEssential(pService))
			{
				pService->m_fChecked = fNewState;
				ListView_SetCheckState(m_list.m_hWnd, i, fNewState);
			}
		}
	}

	m_fFillingList = FALSE;
	SetControlState();
}

//-------------------------------------------------------------------------
// Set the state of the services to disabled or enabled based on the
// values of the checkboxes.
//-------------------------------------------------------------------------

BOOL CPageServices::SetServiceStateFromCheckboxes()
{
	DWORD dwError = 0;

	SC_HANDLE schManager =::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (schManager != NULL)
	{
		LVITEM lvi;
		lvi.mask = LVIF_PARAM;
		lvi.iSubItem = 0;

		for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
		{
			lvi.iItem = i;

			if (ListView_GetItem(m_list.m_hWnd, &lvi))
			{
				CServiceInfo * pService = (CServiceInfo *)lvi.lParam;
				if (pService)
				{
					// Open this service and get the current state.
					
					SC_HANDLE schService = ::OpenService(schManager, pService->m_strService, SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG);
					if (schService != NULL)
					{
						DWORD	dwStart;
						CString	strPath;

						if (GetServiceInfo(schService, dwStart, strPath))
						{
							DWORD dwNewStart = 0;

							if (dwStart != SERVICE_DISABLED && !pService->m_fChecked)
							{
								pService->m_dwOldState = dwStart;
								if (!::ChangeServiceConfig(schService, SERVICE_NO_CHANGE, SERVICE_DISABLED, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
									dwError = ::GetLastError();
							}
							else if (dwStart == SERVICE_DISABLED && pService->m_fChecked)
							{
								if (!::ChangeServiceConfig(schService, SERVICE_NO_CHANGE, pService->m_dwOldState, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
									dwError = ::GetLastError();
							}
						}

						::CloseServiceHandle(schService);
					}
					else
						dwError = ::GetLastError();
				}
			}
		}

		::CloseServiceHandle(schManager);
	}
	else
		dwError = ::GetLastError();

	if (dwError != 0)
		Message((dwError == ERROR_ACCESS_DENIED) ? IDS_SERVICEACCESSDENIED : IDS_SERVICEOTHERERROR);

	return (dwError == 0);
}

//-------------------------------------------------------------------------
// Get the start type for the specified service. This will use a member
// variable buffer and size (so this won't need to allocate a new buffer
// each time).
//
// This will also get the path for the service.
//-------------------------------------------------------------------------

BOOL CPageServices::GetServiceInfo(SC_HANDLE schService, DWORD & dwStartType, CString & strPath)
{
	DWORD dwSizeNeeded;

	if (!::QueryServiceConfig(schService, (LPQUERY_SERVICE_CONFIG)m_pBuffer, m_dwSize, &dwSizeNeeded))
	{
		if (ERROR_INSUFFICIENT_BUFFER != ::GetLastError())
			return FALSE;

		if (m_pBuffer)
			delete [] m_pBuffer;
		m_pBuffer = new BYTE[dwSizeNeeded];
		m_dwSize = dwSizeNeeded;

		if (!::QueryServiceConfig(schService, (LPQUERY_SERVICE_CONFIG)m_pBuffer, m_dwSize, &dwSizeNeeded))
			return FALSE;
	}

	dwStartType = ((LPQUERY_SERVICE_CONFIG)m_pBuffer)->dwStartType;
	strPath = ((LPQUERY_SERVICE_CONFIG)m_pBuffer)->lpBinaryPathName;
	return TRUE;
}

//-------------------------------------------------------------------------
// Get the manufacturer for the named file.
//-------------------------------------------------------------------------

void CPageServices::GetManufacturer(LPCTSTR szFilename, CString & strManufacturer)
{
	// Trim off any command line stuff extraneous to the path.

	CString strPath(szFilename);
	int	iEnd = strPath.Find(_T('.'));

	if (iEnd == -1)
		iEnd = strPath.ReverseFind(_T('\\'));

	if (iEnd != -1)
	{
		int iSpace = strPath.Find(_T(' '), iEnd);
		if (iSpace != -1)
			strPath = strPath.Left(iSpace + 1);
	}
	strPath.TrimRight();
	
	// If there is no extension, then we'll try looking for a file with
	// an "EXE" extension.
	
	iEnd = strPath.Find(_T('.'));
	if (iEnd == -1)
		strPath += _T(".exe");

	strManufacturer.Empty();
	if (SUCCEEDED(m_fileversion.QueryFile((LPCTSTR)strPath)))
		strManufacturer = m_fileversion.GetCompany();

	if (strManufacturer.IsEmpty())
		strManufacturer.LoadString(IDS_UNKNOWN);
}

//-------------------------------------------------------------------------
// Save the state of each of the services by maintaining a list of services
// we've checked as disabled.
//-------------------------------------------------------------------------

void CPageServices::SaveServiceState()
{
	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		lvi.iItem = i;
		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CServiceInfo * pService = (CServiceInfo *)lvi.lParam;
			if (pService)
			{
				POSITION p = m_listDisabled.Find(pService->m_strService);
				if (pService->m_fChecked && p != NULL)
					m_listDisabled.RemoveAt(p);
				else if (!pService->m_fChecked && p == NULL)
					m_listDisabled.AddHead(pService->m_strService);
			}
		}
	}
}

//-------------------------------------------------------------------------
// Restore the checked state of the list based on the contents of the list
// of disabled services.
//-------------------------------------------------------------------------

void CPageServices::RestoreServiceState()
{
	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		lvi.iItem = i;

		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CServiceInfo * pService = (CServiceInfo *)lvi.lParam;
			if (pService)
			{
				pService->m_fChecked = (m_listDisabled.Find(pService->m_strService) == NULL);
				ListView_SetCheckState(m_list.m_hWnd, i, pService->m_fChecked);
			}
		}
	}
}

//-------------------------------------------------------------------------
// Indicate if the service is essential (i.e. it shouldn't be disabled).
//-------------------------------------------------------------------------

BOOL CPageServices::IsServiceEssential(CServiceInfo * pService)
{
	ASSERT(pService);

	CString strService(pService->m_strService);
	strService.MakeLower();

	for (int i = 0; aszEssentialServices[i] != NULL; i++)
		if (strService.Find(aszEssentialServices[i]) != -1)
			return TRUE;

	return FALSE;
}


// A function for sorting the service list. The low byte of lParamSort is the column
// to sort by. The next higher byte indicates whether the sort should be reversed.

int CALLBACK ServiceListSortFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	int iReturn		= 0;
	int iColumn		= (int)lParamSort & 0x00FF;
	int iReverse	= (int)lParamSort & 0xFF00;

	CPageServices::CServiceInfo * pService1 = (CPageServices::CServiceInfo *)lParam1;
	CPageServices::CServiceInfo * pService2 = (CPageServices::CServiceInfo *)lParam2;
	if (pService1 && pService2)
	{
		CString str1, str2;

		switch (iColumn)
		{
		case 0:
			str1 = pService1->m_strDisplay;
			str2 = pService2->m_strDisplay;
			break;

		case 1:
			str1 = pService1->m_strEssential;
			str2 = pService2->m_strEssential;
			break;

		case 2:
			str1 = pService1->m_strManufacturer;
			str2 = pService2->m_strManufacturer;
			break;

		case 3:
			str1 = pService1->m_strStatus;
			str2 = pService2->m_strStatus;
			break;

		default:
			break;
		}

		iReturn = str1.Collate(str2);
	}

	if (iReverse)
		iReturn *= -1;

	return iReturn;
}

//-------------------------------------------------------------------------
// If there is a change to the list, check to see if the user has changed
// the state of a check box.
//-------------------------------------------------------------------------

void CPageServices::OnItemChangedListServices(NMHDR * pNMHDR, LRESULT * pResult) 
{
	NM_LISTVIEW * pnmv = (NM_LISTVIEW *)pNMHDR;

	if (m_fFillingList)
	{
		*pResult = 0;
		return;
	}

	if (!pnmv)
	{
		*pResult = 0;
		return;
	}

	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;
	lvi.iItem = pnmv->iItem;

	if (ListView_GetItem(m_list.m_hWnd, &lvi))
	{
		CServiceInfo * pService = (CServiceInfo *)lvi.lParam;
		if (pService)
		{
			if (pService->m_fChecked != (BOOL)ListView_GetCheckState(m_list.m_hWnd, pnmv->iItem))
			{
				if (IsServiceEssential(pService))
				{
					m_fFillingList = TRUE;
					ListView_SetCheckState(m_list.m_hWnd, pnmv->iItem, TRUE);
					m_fFillingList = FALSE;

					if (m_fShowWarning)
					{
						CEssentialServiceDialog dlg;
						dlg.DoModal();
						if (dlg.m_fDontShow)
						{
							m_fShowWarning = FALSE;
							CRegKey regkey;
							regkey.Attach(GetRegKey());
							regkey.SetValue(1, HIDEWARNINGVALUE);
						}
					}

					*pResult = 0;
					return;
				}

				pService->m_fChecked = ListView_GetCheckState(m_list.m_hWnd, pnmv->iItem);
				SetModified(TRUE);
				SetControlState();
			}
		}
	}

	*pResult = 0;
}

//-------------------------------------------------------------------------
// The user wants to enable or disable all the services.
//-------------------------------------------------------------------------

void CPageServices::OnButtonDisableAll() 
{
	SetStateAll(FALSE);
	SetModified(TRUE);
}

void CPageServices::OnButtonEnableAll() 
{
	SetStateAll(TRUE);
	SetModified(TRUE);
}

//-------------------------------------------------------------------------
// If the user clicks the "Hide Microsoft Services" check box, refill the
// list of services appropriately.
//-------------------------------------------------------------------------

void CPageServices::OnCheckHideMS() 
{
	m_fHideMicrosoft = (IsDlgButtonChecked(IDC_CHECKHIDEMS) == BST_CHECKED);
	m_fFillingList = TRUE;
	SaveServiceState();
	EmptyServiceList();
	LoadServiceList();
	RestoreServiceState();
	m_fFillingList = FALSE;
	SetControlState();
}

//-------------------------------------------------------------------------
// If the user clicks on a column, we need to sort by that field. The
// low byte of the LPARAM we pass is the column to sort by, the next byte
// indicates if the sort should be reversed.
//-------------------------------------------------------------------------

void CPageServices::OnColumnClickListServices(NMHDR * pNMHDR, LRESULT * pResult) 
{
	LPNMLISTVIEW pnmv = (LPNMLISTVIEW) pNMHDR; 

	if (pnmv)
	{
		if (m_iLastColumnSort == pnmv->iSubItem)
			m_iSortReverse ^= 1;
		else
		{
			m_iSortReverse = 0;
			m_iLastColumnSort = pnmv->iSubItem;
		}

		LPARAM lparam = (LPARAM)((m_iSortReverse << 8) | pnmv->iSubItem);
		ListView_SortItems(m_list.m_hWnd, (PFNLVCOMPARE) ServiceListSortFunc, lparam);
	}

	*pResult = 0;
}

//-------------------------------------------------------------------------
// Return the current state of the tab (need to look through the list).
//-------------------------------------------------------------------------

CPageBase::TabState CPageServices::GetCurrentTabState()
{
	if (!m_fInitialized)
		return GetAppliedTabState();

	TabState	stateReturn = USER;
	BOOL		fAllEnabled = TRUE, fAllDisabled = TRUE;
	LVITEM		lvi;

	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		lvi.iItem = i;

		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CServiceInfo * pService = (CServiceInfo *)lvi.lParam;
			if (pService && !IsServiceEssential(pService))
			{
				if (pService->m_fChecked)
					fAllDisabled = FALSE;
				else
					fAllEnabled = FALSE;
			}
		}
	}

	if (fAllEnabled)
		stateReturn = NORMAL;
	else if (fAllDisabled)
		stateReturn = DIAGNOSTIC;

	return stateReturn;
}

//-------------------------------------------------------------------------
// Applying the changes for the services tab means setting the service
// states from the checkboxes, and saving the checkbox values in the
// registry.
//
// Finally, the base class implementation is called to maintain the
// applied tab state.
//-------------------------------------------------------------------------

BOOL CPageServices::OnApply()
{
	if (!m_fModified)
		return TRUE;

	SetServiceStateFromCheckboxes();
	SetRegistryFromCheckboxes();
	CPageBase::SetAppliedState(GetCurrentTabState());
//	CancelToClose();
	m_fMadeChange = TRUE;
	return TRUE;
}

//-------------------------------------------------------------------------
// Committing the changes means applying changes, then saving the current
// values to the registry with the commit flag. Refill the list.
//
// Then call the base class implementation.
//-------------------------------------------------------------------------

void CPageServices::CommitChanges()
{
	OnApply();
	SetRegistryFromCheckboxes(TRUE);
	m_fFillingList = TRUE;
	EmptyServiceList();
	LoadServiceList();
	SetCheckboxesFromRegistry();
	m_fFillingList = FALSE;
	CPageBase::CommitChanges();
}

//-------------------------------------------------------------------------
// Set the overall state of the tab to normal or diagnostic.
//-------------------------------------------------------------------------

void CPageServices::SetNormal()
{
	SetStateAll(TRUE);
	SetModified(TRUE);
}

void CPageServices::SetDiagnostic()
{
	SetStateAll(FALSE);
	SetModified(TRUE);
}

//-------------------------------------------------------------------------
// If nothing is selected when the list gets focus, select the first item
// (so the user sees where the focus is).
//-------------------------------------------------------------------------

void CPageServices::OnSetFocusList(NMHDR * pNMHDR, LRESULT * pResult) 
{
	if (0 == ListView_GetSelectedCount(m_list.m_hWnd) && 0 < ListView_GetItemCount(m_list.m_hWnd))
		ListView_SetItemState(m_list.m_hWnd, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

	*pResult = 0;
}

//-------------------------------------------------------------------------
// Update the state of the controls (the Enable and Disable All buttons).
//-------------------------------------------------------------------------

void CPageServices::SetControlState()
{
	BOOL fAllEnabled = TRUE, fAllDisabled = TRUE;
	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		BOOL fChecked = ListView_GetCheckState(m_list.m_hWnd, i);
		fAllDisabled = fAllDisabled && !fChecked;
		fAllEnabled = fAllEnabled && fChecked;
	}

	HWND hwndFocus = ::GetFocus();

	::EnableWindow(GetDlgItemHWND(IDC_BUTTONSERVDISABLEALL), !fAllDisabled);
	if (fAllDisabled && hwndFocus == GetDlgItemHWND(IDC_BUTTONSERVDISABLEALL))
		PrevDlgCtrl();

	::EnableWindow(GetDlgItemHWND(IDC_BUTTONSERVENABLEALL), !fAllEnabled);
	if (fAllEnabled && hwndFocus == GetDlgItemHWND(IDC_BUTTONSERVENABLEALL))
		NextDlgCtrl();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pageservices.h ===
//=============================================================================
// PageServices.h : Declaration of the CPageServices
//=============================================================================

#if !defined(AFX_PAGESERVICES_H__DE6A034D_3151_4CA3_9964_8F2CE73F6374__INCLUDED_)
#define AFX_PAGESERVICES_H__DE6A034D_3151_4CA3_9964_8F2CE73F6374__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PageServices.h : header file
//

#include "mscfgver.h"
#include <winsvc.h>
#include "MSConfigState.h"
#include "PageBase.h"

#define HIDEWARNINGVALUE _T("HideEssentialServiceWarning")

extern LPCTSTR aszEssentialServices[];
extern int CALLBACK ServiceListSortFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

class CPageServices : public CPropertyPage, public CPageBase
{
	DECLARE_DYNCREATE(CPageServices)

	// Sorting function needs to be a friend to access CServiceInfo class.

	friend int CALLBACK ServiceListSortFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

private:
	//-------------------------------------------------------------------------
	// This class is used to encapsulate a service for the services tab.
	//-------------------------------------------------------------------------

	class CServiceInfo
	{
	public:
		CServiceInfo(LPCTSTR szService, BOOL fChecked = FALSE, DWORD dwStartType = 0, LPCTSTR szManufacturer = NULL, LPCTSTR szDisplay = NULL)
			: m_strService(szService), m_fChecked(fChecked), m_dwOldState(dwStartType)
		{
			if (szManufacturer != NULL)
				m_strManufacturer = szManufacturer;

			if (szDisplay != NULL)
				m_strDisplay = szDisplay;
		};

		CString	m_strService; 
		CString m_strManufacturer;
		CString m_strDisplay;
		BOOL	m_fChecked;
		DWORD	m_dwOldState;
		CString	m_strEssential;
		CString	m_strStatus;
	};

public:
	CPageServices();
	~CPageServices();

	void		LoadServiceList();
	void		EmptyServiceList(BOOL fUpdateUI = TRUE);
	void		SetCheckboxesFromRegistry();
	void		SetRegistryFromCheckboxes(BOOL fCommit = FALSE);
	void		SetStateAll(BOOL fNewState);
	BOOL		SetServiceStateFromCheckboxes();
	BOOL		GetServiceInfo(SC_HANDLE schService, DWORD & dwStartType, CString & strPath);
	void		GetManufacturer(LPCTSTR szFilename, CString & strManufacturer);
	void		SaveServiceState();
	void		RestoreServiceState();
	BOOL		IsServiceEssential(CServiceInfo * pService);
	TabState	GetCurrentTabState();
	LPCTSTR		GetName() { return _T("services"); };
	BOOL		OnApply();
	void		CommitChanges();
	void		SetNormal();
	void		SetDiagnostic();
	void		SetControlState();

	HWND GetDlgItemHWND(UINT nID)
	{
		HWND hwnd = NULL;
		CWnd * pWnd = GetDlgItem(nID);
		if (pWnd)
			hwnd = pWnd->m_hWnd;
		ASSERT(hwnd);
		return hwnd;
	}

// Dialog Data
	//{{AFX_DATA(CPageServices)
	enum { IDD = IDD_PAGESERVICES };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPageServices)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPageServices)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnItemChangedListServices(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonDisableAll();
	afx_msg void OnButtonEnableAll();
	afx_msg void OnCheckHideMS();
	afx_msg void OnColumnClickListServices(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetFocusList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL m_fModified;
	void SetModified(BOOL bChanged = TRUE)
	{
		m_fModified = bChanged;
		CPropertyPage::SetModified(bChanged);
	}

private:
	CWindow				m_list;				// attached to the list view
	BOOL				m_fFillingList;		// true if we're currently filling the list with services
	LPBYTE				m_pBuffer;			// buffer used to get service start type
	DWORD				m_dwSize;			// the size of the buffer
	CFileVersionInfo	m_fileversion;		// used to query manufacturer
	BOOL				m_fHideMicrosoft;	// whether to show Microsoft services
	BOOL				m_fShowWarning;		// show the warning for trying to disable essential service
	CStringList			m_listDisabled;		// list of the disabled services (used to preserve state when hiding MS services)
	int					m_iLastColumnSort;	// last column the user sorted by
	int					m_iSortReverse;		// used to keep track of multiple sorts on a column
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PAGESERVICES_H__DE6A034D_3151_4CA3_9964_8F2CE73F6374__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pagestartup.h ===
#if !defined(AFX_PAGESTARTUP_H__928475DA_B332_47F4_8180_5C8B79DFC203__INCLUDED_)
#define AFX_PAGESTARTUP_H__928475DA_B332_47F4_8180_5C8B79DFC203__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "PageBase.h"
#include "MSConfigState.h"

//============================================================================
// The CStartupItem class is used to encapsulate an individual startup
// item. Pointers to these objects are maintained in the list.
//============================================================================

class CStartupItem
{
public:
	//------------------------------------------------------------------------
	// Constructor and destructor.
	//------------------------------------------------------------------------

	CStartupItem() { }
	virtual ~CStartupItem() { }

	//------------------------------------------------------------------------
	// If the derived classes use the base class member variables, these won't
	// need to be overridden.
	//------------------------------------------------------------------------

	virtual void GetDisplayInfo(CString & strItem, CString & strLocation, CString & strCommand)
	{
		strItem = m_strItem;
		strLocation = m_strLocation;
		strCommand = m_strCommand;
	}

	virtual BOOL IsLive()
	{
		return m_fLive;
	}

	//------------------------------------------------------------------------
	// Set whether or not the startup item is enabled. If disabling the
	// startup item, add a registry entry so it will be loaded again.
	// If enabling the startup item, delete the registry entry.
	//
	// Of course, do the appropriate thing to registry keys, etc.
	//------------------------------------------------------------------------

	virtual BOOL SetEnable(BOOL fEnable) = 0;

protected:
	BOOL	m_fLive;
	CString	m_strItem;
	CString	m_strLocation;
	CString m_strCommand;
};

//============================================================================
// The CStartupItemRegistry class is used to encapsulate an individual startup
// item stored in the registry.
//============================================================================

class CStartupItemRegistry : public CStartupItem
{
public:
	//------------------------------------------------------------------------
	// Overridden methods for this type of startup item.
	//------------------------------------------------------------------------

	CStartupItemRegistry();
	CStartupItemRegistry(HKEY hkey, LPCTSTR szKey, LPCTSTR szName, LPCTSTR szValueName, LPCTSTR szValue);
	CStartupItemRegistry(LPCTSTR szKey, LPCTSTR szName, LPCTSTR szValueName, LPCTSTR szValue);
	BOOL SetEnable(BOOL fEnable);

	//------------------------------------------------------------------------
	// Functions for this subclass.
	//------------------------------------------------------------------------

	BOOL Create(LPCTSTR szKeyName, HKEY hkey);
	static void RemovePersistedEntries();

private:
	HKEY	m_hkey;
	CString	m_strKey;
	CString	m_strValueName;
	BOOL	m_fIniMapping;
};

//============================================================================
// The CStartupItemFolder class is used to encapsulate an individual startup
// stored in the startup folder.
//============================================================================

class CStartupItemFolder : public CStartupItem
{
public:
	//------------------------------------------------------------------------
	// Class used to get information about a shortcut from a function running
	// in a different thread.
	//------------------------------------------------------------------------

	class CIconInfo
	{
	public:
		TCHAR	szPath[MAX_PATH * 2];
		TCHAR	szTarget[MAX_PATH * 2];
		TCHAR	szArgs[MAX_PATH * 2];
		HRESULT	hResult;
	};

public:
	//------------------------------------------------------------------------
	// Overridden methods for this type of startup item.
	//------------------------------------------------------------------------

	CStartupItemFolder();
	BOOL SetEnable(BOOL fEnable);

	//------------------------------------------------------------------------
	// Functions for this subclass.
	//------------------------------------------------------------------------

	BOOL Create(LPCTSTR szKeyName, HKEY hkey);
	BOOL Create(const WIN32_FIND_DATA & fd, HKEY hkey, LPCTSTR szRegPathToFolder, LPCTSTR szFolder, LPCTSTR szDir);
	static void RemovePersistedEntries();
	HRESULT GetIconInfo(CIconInfo & info);

private:
	CString	m_strFilePath;
	CString m_strBackupPath;
};

//============================================================================
// The class which implements the startup tab.
//============================================================================

class CPageStartup : public CPropertyPage, public CPageBase
{
	DECLARE_DYNCREATE(CPageStartup)

// Construction
public:
	CPageStartup();
	~CPageStartup();

// Dialog Data
	//{{AFX_DATA(CPageStartup)
	enum { IDD = IDD_PAGESTARTUP };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPageStartup)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPageStartup)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnItemChangedList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonDisableAll();
	afx_msg void OnButtonEnableAll();
	afx_msg void OnSetFocusList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonRestore();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	//=========================================================================
	// Functions overridden from CPageBase
	//=========================================================================

	TabState	GetCurrentTabState();
	BOOL		OnApply();
	void		CommitChanges();
	void		SetNormal();
	void		SetDiagnostic();
	LPCTSTR		GetName() { return _T("startup"); };

private:
	//=========================================================================
	// Functions specific to this tab.
	//=========================================================================

	void LoadStartupList();
	void LoadStartupListLiveItems();
	void LoadStartupListLiveItemsRunKey();
	void LoadStartupListLiveItemsStartup();
	void LoadStartupListLiveItemsWinIniKey();
	void LoadStartupListDisabledItems();
	void GetCommandName(CString & strCommand);
	void InsertStartupItem(CStartupItem * pItem);
	void EmptyList(BOOL fFreeMemoryOnly);
	void SetEnableForList(BOOL fEnable);

	HWND GetDlgItemHWND(UINT nID)
	{
		HWND hwnd = NULL;
		CWnd * pWnd = GetDlgItem(nID);
		if (pWnd)
			hwnd = pWnd->m_hWnd;
		ASSERT(hwnd);
		return hwnd;
	}

private:
	BOOL m_fModified;
	void SetModified(BOOL bChanged = TRUE)
	{
		m_fModified = bChanged;
		CPropertyPage::SetModified(bChanged);
	}

	//=========================================================================
	// Member variables.
	//=========================================================================

	CWindow		m_list;
	int			m_iNextPosition;
	BOOL		m_fIgnoreListChanges;
	TabState	m_stateRequested;		// save the requested state in case there are no startup items
};

//============================================================================
// CRestoreStartup implements a dialog box which allows the user to restore
// startup items disabled during upgrade.
//============================================================================

#define DISABLED_KEY		_T("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\DisabledRunKeys")
#define ENABLED_KEY			_T("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define DISABLED_STARTUP	_T("\\Disabled Startup")

class CRestoreStartup : public CDialog
{
// Construction
public:
	CRestoreStartup(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRestoreStartup)
	enum { IDD = IDD_RESTORE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRestoreStartup)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	static BOOL AreItemsToRestore();

private:
	//-------------------------------------------------------------------------
	// These classes are used to represent the various types of disabled
	// startup items we might restore. CStartupDisabled is an abstract base.
	//-------------------------------------------------------------------------

	class CStartupDisabled
	{
	public:
		CStartupDisabled() {};
		virtual ~CStartupDisabled() {};
		virtual void GetColumnCaptions(CString & strItem, CString & strLocation) = 0;
		virtual void Restore() = 0;
	};

	//-------------------------------------------------------------------------
	// CStartupDisabledRegistry represents Run key items in the registry that
	// were disabled.
	//-------------------------------------------------------------------------

	class CStartupDisabledRegistry : public CStartupDisabled
	{
	public:
		CStartupDisabledRegistry(LPCTSTR szValueName, LPCTSTR szValue, LPCTSTR szLocation, HKEY hkeyBase) : 
			m_strValueName(szValueName),
			m_strValue(szValue),
			m_strLocation(szLocation),
			m_hkeyBase(hkeyBase) {};
		~CStartupDisabledRegistry() {};

		void GetColumnCaptions(CString & strItem, CString & strLocation)
		{
			strItem = m_strValueName + CString(_T(" = ")) + m_strValue;
			strLocation = ((m_hkeyBase == HKEY_LOCAL_MACHINE) ? CString(_T("HKLM\\")) : CString(_T("HKCU\\"))) + m_strLocation;
		}

		void Restore()
		{
			// Create the value in the Run registry key.

			CRegKey regkey;
			if (ERROR_SUCCESS != regkey.Open(m_hkeyBase, m_strLocation, KEY_WRITE))
				return;
			BOOL fSet = (ERROR_SUCCESS == regkey.SetValue(m_strValue, m_strValueName));
			regkey.Close();

			// Delete it from the disabled location.

			if (fSet)
			{
				if (ERROR_SUCCESS != regkey.Open(m_hkeyBase, DISABLED_KEY, KEY_WRITE))
					return;
				regkey.DeleteValue(m_strValueName);
				regkey.Close();
			}
		}

	private:
		CString m_strValueName;
		CString m_strValue;
		CString m_strLocation;
		HKEY	m_hkeyBase;
	};

	//-------------------------------------------------------------------------
	// CStartupDisabledStartup represents startup group items that were
	// disabled.
	//-------------------------------------------------------------------------

	class CStartupDisabledStartup : public CStartupDisabled
	{
	public:
		CStartupDisabledStartup(LPCTSTR szFile, LPCTSTR szDestination, LPCTSTR szCurrentLocation) : 
			m_strFile(szFile),
			m_strDestination(szDestination),
			m_strCurrentLocation(szCurrentLocation) {};
		~CStartupDisabledStartup() {};

		void GetColumnCaptions(CString & strItem, CString & strLocation)
		{
			strItem = m_strFile;
			strLocation = m_strDestination;
		}

		void Restore()
		{
			// Move the file to the startup directory.

			CString strExisting(m_strCurrentLocation);
			if (strExisting.Right(1) != CString(_T("\\")))
				strExisting += CString(_T("\\"));
			strExisting += m_strFile;

			CString strDestination(m_strDestination);
			if (strDestination.Right(1) != CString(_T("\\")))
				strDestination += CString(_T("\\"));
			strDestination += m_strFile;

			::MoveFileEx(strExisting, strDestination, 0);
		}

	private:
		CString m_strFile;
		CString m_strDestination;
		CString m_strCurrentLocation;
	};

private:
	CWindow		m_list;
	int			m_iNextPosition;

private:
	void InsertDisabledStartupItem(CStartupDisabled * pItem);
	BOOL LoadDisabledStartupGroup();
	BOOL LoadDisabledRegistry();
	BOOL LoadDisabledItemList();
	void EmptyList();
	void SetOKState();

protected:

	// Generated message map functions
	//{{AFX_MSG(CRestoreStartup)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	virtual void OnOK();
	afx_msg void OnItemChangedRestoreList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PAGESTARTUP_H__928475DA_B332_47F4_8180_5C8B79DFC203__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pageinternational.h ===
// PageIni.h : Declaration of the CPageIni
#if FALSE
/*
#ifndef __PAGEINTERNATIONAL_H_
#define __PAGEINTERNATIONAL_H_

#include "resource.h"       // main symbols
#include <atlhost.h>
#include "msconfigstate.h"
#include "pagebase.h"

// main struct for all International info
typedef struct INTL_INFO
{
	UINT idsName;
	UINT nDOSCodePage;
	UINT nCountryCode;
	UINT nKeyboardType;
	UINT nKeyboardLayout;
	TCHAR tszLanguageID[4];
	UINT idsCountryFilename;
	UINT idsCodePageFilename;
	UINT idsKeyboardFilename;
} INTL_INFO;

/////////////////////////////////////////////////////////////////////////////
// CPageIni
class CPageInternational : public CAxDialogImpl<CPageInternational>, public CPageBase
{
public:
	CPageInternational();

	~CPageInternational()
	{
	}

	enum { IDD = IDD_PAGEINTERNATIONAL };

BEGIN_MSG_MAP(CPageIni)
MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
COMMAND_HANDLER(IDC_COMBOLANGUAGES, CBN_SELCHANGE, OnSelchangeCombolanguages)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSelchangeCombolanguages(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);


private:
	//-------------------------------------------------------------------------
	// Overloaded functions from CPageBase (see CPageBase declaration for the
	// usage of these methods).
	//-------------------------------------------------------------------------

	void CreatePage(HWND hwnd, const RECT & rect)
	{
		Create(hwnd);
		MoveWindow(&rect);
	}

	CWindow * GetWindow()
	{
		return ((CWindow *)this);
	}
	HRESULT Notify(LPCTSTR szFromTab, LPCTSTR szToTab, TabNotify msg);

private:
	BOOL m_fInitializing;
	BOOL m_fIntlDirty;

	// holders for initial settings
	TCHAR m_tszCurDOSCodePage[6];
	TCHAR m_tszCurCountryCode[6];
	TCHAR m_tszCurKeyboardType[6];
	TCHAR m_tszCurKeyboardLayout[6];
	TCHAR m_tszCurLanguageID[3];
	TCHAR m_tszCurCountryFilename[MAX_PATH];
	TCHAR m_tszCurCodePageFilename[MAX_PATH];
	TCHAR m_tszCurKeyboardFilename[MAX_PATH];

	void Intl_SetEditText(HKEY hKey, LPCTSTR ptszRegValue, int ids, LPTSTR ptszCur);
	void Intl_SetRegValue(HKEY hKey, int ids, LPCTSTR ptszRegValue);
	UINT Intl_GetCPArray(UINT nCodePage, INTL_INFO **ppIntlInfo);
	void Intl_GetTextFromNum(UINT nNum, LPTSTR ptszText);
	void Intl_GetTextFromIDS(int ids, LPTSTR ptszText);
	
};

#endif //__PAGEINTERNATIONAL_H_
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\pagestartup.cpp ===
#include "stdafx.h"
#include "PageStartup.h"
#include "MSConfigState.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPageStartup property page

IMPLEMENT_DYNCREATE(CPageStartup, CPropertyPage)

CPageStartup::CPageStartup() : CPropertyPage(CPageStartup::IDD)
{
	//{{AFX_DATA_INIT(CPageStartup)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_fModified	= FALSE;
}

CPageStartup::~CPageStartup()
{
}

void CPageStartup::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPageStartup)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPageStartup, CPropertyPage)
	//{{AFX_MSG_MAP(CPageStartup)
	ON_WM_DESTROY()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LISTSTARTUP, OnItemChangedList)
	ON_BN_CLICKED(IDC_BUTTONSUDISABLEALL, OnButtonDisableAll)
	ON_BN_CLICKED(IDC_BUTTONSUENABLEALL, OnButtonEnableAll)
	ON_NOTIFY(NM_SETFOCUS, IDC_LISTSTARTUP, OnSetFocusList)
	ON_BN_CLICKED(IDC_BUTTONSURESTORE, OnButtonRestore)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPageStartup message handlers

//-----------------------------------------------------------------------------
// Load the list of startup items.
//-----------------------------------------------------------------------------

void CPageStartup::LoadStartupList()
{
	m_fIgnoreListChanges = TRUE;
	EmptyList(FALSE);
	m_iNextPosition = 0;

	LoadStartupListLiveItems();
	LoadStartupListDisabledItems();
	m_fIgnoreListChanges = FALSE;
}

//-----------------------------------------------------------------------------
// Load the list of items which are actually being started on this system.
//-----------------------------------------------------------------------------

void CPageStartup::LoadStartupListLiveItems()
{
 	LoadStartupListLiveItemsRunKey();
	LoadStartupListLiveItemsStartup();
	LoadStartupListLiveItemsWinIniKey();
}

//-----------------------------------------------------------------------------
// Look under the Run registry key for startup items.
//-----------------------------------------------------------------------------

void CPageStartup::LoadStartupListLiveItemsRunKey()
{
	LPCTSTR	szRunKey = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
	HKEY	ahkey[] = {	HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER, NULL };
	TCHAR	szValueName[MAX_PATH], szValue[MAX_PATH];
	DWORD	dwSize;
	CRegKey	regkey;

	for (int i = 0; ahkey[i] != NULL; i++)
	{
		// Try to open the Run registry key.

		if (ERROR_SUCCESS != regkey.Open(ahkey[i], szRunKey, KEY_READ))
			continue;

		// Get the number of keys under the Run key and look at each one.

		DWORD dwValueCount;
		if (ERROR_SUCCESS != ::RegQueryInfoKey((HKEY)regkey, NULL, NULL, NULL, NULL, NULL, NULL, &dwValueCount, NULL, NULL, NULL, NULL))
		{
			regkey.Close();
			continue;
		}

		for (DWORD dwKey = 0; dwKey < dwValueCount; dwKey++)
		{
			dwSize = MAX_PATH;
			if (ERROR_SUCCESS != ::RegEnumValue((HKEY)regkey, dwKey, szValueName, &dwSize, NULL, NULL, NULL, NULL))
				continue;

			dwSize = MAX_PATH;
			if (ERROR_SUCCESS != regkey.QueryValue(szValue, szValueName, &dwSize))
				continue;

			// We don't want to show MSConfig in the startup item list.
			
			CString strTemp(szValue);
			strTemp.MakeLower();
			if (strTemp.Find(_T("msconfig.exe")) != -1)
				continue;

			// TBD - verify that the file exists?

			// To get the name of this startup item, we'll take the command and
			// strip off everything but the filename (without the extension).

			CString strName(szValue);
			GetCommandName(strName);

			// Create the startup item and insert it in the list.

			CStartupItemRegistry * pItem = new CStartupItemRegistry(ahkey[i], szRunKey, strName, szValueName, szValue);
			InsertStartupItem(pItem);
		}

		regkey.Close();
	}
}

//-----------------------------------------------------------------------------
// Look under the registry for the mapped win.ini file and check out its run
// and load items.
//-----------------------------------------------------------------------------

void CPageStartup::LoadStartupListLiveItemsWinIniKey()
{
	LPCTSTR aszValueNames[] = { _T("Run"), _T("Load"), NULL };
	CRegKey	regkey;
	TCHAR	szValue[MAX_PATH * 4];
	DWORD	dwSize;
	LPCTSTR szKeyName = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows");
	HKEY	hkey = HKEY_CURRENT_USER;

	if (ERROR_SUCCESS != regkey.Open(hkey, szKeyName, KEY_READ))
		return;

	for (int i = 0; aszValueNames[i] != NULL; i++)
	{
		dwSize = MAX_PATH * 4;
		if (ERROR_SUCCESS != regkey.QueryValue(szValue, aszValueNames[i], &dwSize))
			continue;

		// The string we get back is a comma delimited list of programs. We need
		// to parse them into individual programs.

		CString strLine(szValue);
		while (!strLine.IsEmpty())
		{
			CString strItem = strLine.SpanExcluding(_T(","));
			
			if (!strItem.IsEmpty())
			{
				// Create the startup item and insert it in the list.

				CString strCommandName(strItem);
				GetCommandName(strCommandName);

				CStartupItemRegistry * pItem = new CStartupItemRegistry(szKeyName, strCommandName, aszValueNames[i], strItem);
				InsertStartupItem(pItem);

				// Trim the item of the line.

				strLine = strLine.Mid(strItem.GetLength());
			}
			strLine.TrimLeft(_T(" ,"));
		}
	}

	regkey.Close();
}

//-----------------------------------------------------------------------------
// Look in the startup folder for items.
//-----------------------------------------------------------------------------

void CPageStartup::LoadStartupListLiveItemsStartup()
{
	LPCTSTR	szRunKey = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
	HKEY	ahkey[] = {	HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER, NULL };
	LPCTSTR aszRunValue[] = { _T("Common Startup"), _T("Startup"), NULL };
	CRegKey	regkey;
	TCHAR	szStartupFolderDir[MAX_PATH];
	TCHAR	szStartupFileSpec[_MAX_PATH];
	DWORD	dwSize;

	for (int i = 0; ahkey[i] != NULL; i++)
	{
		// Try to open the registry key.

		if (ERROR_SUCCESS != regkey.Open(ahkey[i], szRunKey, KEY_READ))
			continue;

		// Get the path for the startup item folder.

		dwSize = MAX_PATH;
		if (aszRunValue[i] == NULL || ERROR_SUCCESS != regkey.QueryValue(szStartupFolderDir, aszRunValue[i], &dwSize))
		{
			regkey.Close();
			continue;
		}
		regkey.Close();

		// Append the filespec on the end of the directory.

		_tmakepath(szStartupFileSpec, NULL, szStartupFolderDir, _T("*.*"), NULL);

		// Examine all of the files in the directory.

		WIN32_FIND_DATA fd;
		HANDLE hFind = FindFirstFile(szStartupFileSpec, &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do
			{
				// We want to ignore the desktop.ini file which might appear in startup.

				if ((fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) == 0 || _tcsicmp(fd.cFileName, _T("desktop.ini")) != 0)
				{
					// We only want to examine files which aren't directories.

					if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
					{
						CStartupItemFolder * pItem = new CStartupItemFolder;
						if (pItem)
						{
							if (pItem->Create(fd, ahkey[i], szRunKey, aszRunValue[i], szStartupFolderDir))
								this->InsertStartupItem(pItem);
							else
								delete pItem;
						}
					}
				}
			} while (FindNextFile(hFind, &fd));

			FindClose(hFind);
		}
	}
}

//-----------------------------------------------------------------------------
// Load the list of items which were being started on this system, but which
// we've disabled. This list is maintained in the registry.
//-----------------------------------------------------------------------------

void CPageStartup::LoadStartupListDisabledItems()
{
	CRegKey regkey;
	regkey.Attach(GetRegKey(_T("startupreg")));
	if ((HKEY)regkey != NULL)
	{
		DWORD	dwKeyCount, dwSize;
		TCHAR	szKeyName[MAX_PATH];

		if (ERROR_SUCCESS == ::RegQueryInfoKey((HKEY)regkey, NULL, NULL, NULL, &dwKeyCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
		{
			for (DWORD dwKey = 0; dwKey < dwKeyCount; dwKey++)
			{
				dwSize = MAX_PATH;
				if (ERROR_SUCCESS != ::RegEnumKeyEx((HKEY)regkey, dwKey, szKeyName, &dwSize, NULL, NULL, NULL, NULL))
					continue;

				CRegKey regkeyItem;
				if (ERROR_SUCCESS == regkeyItem.Open((HKEY)regkey, szKeyName, KEY_READ))
				{
					CStartupItemRegistry * pItem = new CStartupItemRegistry;
					if (pItem->Create(szKeyName, (HKEY)regkeyItem))
						InsertStartupItem(pItem);
					else
						delete pItem;
					regkeyItem.Close();
				}
			}
		}

		regkey.Close();
	}

	regkey.Attach(GetRegKey(_T("startupfolder")));
	if ((HKEY)regkey != NULL)
	{
		DWORD	dwKeyCount, dwSize;
		TCHAR	szKeyName[MAX_PATH];

		if (ERROR_SUCCESS == ::RegQueryInfoKey((HKEY)regkey, NULL, NULL, NULL, &dwKeyCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
		{
			for (DWORD dwKey = 0; dwKey < dwKeyCount; dwKey++)
			{
				dwSize = MAX_PATH;
				if (ERROR_SUCCESS != ::RegEnumKeyEx((HKEY)regkey, dwKey, szKeyName, &dwSize, NULL, NULL, NULL, NULL))
					continue;

				CRegKey regkeyItem;
				if (ERROR_SUCCESS == regkeyItem.Open((HKEY)regkey, szKeyName, KEY_READ))
				{
					CStartupItemFolder * pItem = new CStartupItemFolder;
					if (pItem->Create(szKeyName, (HKEY)regkeyItem))
						InsertStartupItem(pItem);
					else
						delete pItem;
					regkeyItem.Close();
				}
			}
		}

		regkey.Close();
	}
}

//-----------------------------------------------------------------------------
// Take a command line and strip off everything except the command name.
//-----------------------------------------------------------------------------

void CPageStartup::GetCommandName(CString & strCommand)
{
	// Strip off the path information.

	int iLastBackslash = strCommand.ReverseFind(_T('\\'));
	if (iLastBackslash != -1)
		strCommand = strCommand.Mid(iLastBackslash + 1);

	// Strip off the extension and any flags.

	int iDot = strCommand.Find(_T('.'));
	if (iDot != -1)
	{
		if (iDot != 0)
			strCommand = strCommand.Left(iDot);
		else
			strCommand.Empty();
	}
}

//-----------------------------------------------------------------------------
// Insert the specified item in the startup list. The caller is then not
// responsible for deleting the item.
//-----------------------------------------------------------------------------

void CPageStartup::InsertStartupItem(CStartupItem * pItem)
{
	ASSERT(pItem);
	if (pItem == NULL)
		return;

	// Get the strings to add to the list view.

	CString strItem, strLocation, strCommand;
	pItem->GetDisplayInfo(strItem, strLocation, strCommand);

	// Insert the item in the list view.

	LV_ITEM lvi;
	memset(&lvi, 0, sizeof(lvi));
	lvi.mask = LVIF_TEXT | LVIF_PARAM;
	lvi.iItem = m_iNextPosition;

	lvi.pszText = (LPTSTR)(LPCTSTR)strItem;
	lvi.iSubItem = 0;
	lvi.lParam = (LPARAM)pItem;

	m_iNextPosition = ListView_InsertItem(m_list.m_hWnd, &lvi);
	ListView_SetItemText(m_list.m_hWnd, m_iNextPosition, 1, (LPTSTR)(LPCTSTR)strCommand);
	ListView_SetItemText(m_list.m_hWnd, m_iNextPosition, 2, (LPTSTR)(LPCTSTR)strLocation);
	ListView_SetCheckState(m_list.m_hWnd, m_iNextPosition, pItem->IsLive());

	m_iNextPosition++;
}

//-----------------------------------------------------------------------------
// Remove all the items from the list view (freeing the objects pointed to
// by the LPARAM).
//-----------------------------------------------------------------------------

void CPageStartup::EmptyList(BOOL fFreeMemoryOnly)
{
	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		lvi.iItem = i;

		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CStartupItem * pItem = (CStartupItem *)lvi.lParam;
			if (pItem)
				delete pItem;

			// If we're leaving the list with these items, we better
			// not do a double delete.

			if (fFreeMemoryOnly)
			{
				lvi.lParam = 0;
				ListView_SetItem(m_list.m_hWnd, &lvi);
			}
		}
	}

	if (!fFreeMemoryOnly)
		ListView_DeleteAllItems(m_list.m_hWnd);
}

//-----------------------------------------------------------------------------
// Set the state of all of the items in the list.
//-----------------------------------------------------------------------------

void CPageStartup::SetEnableForList(BOOL fEnable)
{
	HWND hwndFocus = ::GetFocus();

	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
		ListView_SetCheckState(m_list.m_hWnd, i, fEnable);

	::EnableWindow(GetDlgItemHWND(IDC_BUTTONSUDISABLEALL), fEnable);
	if (!fEnable && hwndFocus == GetDlgItemHWND(IDC_BUTTONSUDISABLEALL))
		PrevDlgCtrl();

	::EnableWindow(GetDlgItemHWND(IDC_BUTTONSUENABLEALL), !fEnable);
	if (fEnable && hwndFocus == GetDlgItemHWND(IDC_BUTTONSUENABLEALL))
		NextDlgCtrl();
}

//============================================================================
// The CStartupItemRegistry class is used to encapsulate an individual startup
// stored in the registry.
//============================================================================

//----------------------------------------------------------------------------
// Construct this flavor of startup item.
//----------------------------------------------------------------------------

CStartupItemRegistry::CStartupItemRegistry()
{
	m_hkey = NULL;
	m_fIniMapping = FALSE;
}

CStartupItemRegistry::CStartupItemRegistry(HKEY hkey, LPCTSTR szKey, LPCTSTR szName, LPCTSTR szValueName, LPCTSTR szValue)
{
	m_fIniMapping = FALSE;
	m_fLive = TRUE;

	m_strItem = szName;
	m_strLocation = szKey;
	m_strCommand = szValue;

	// Add the HKEY to the location.

	if (hkey == HKEY_LOCAL_MACHINE)
		m_strLocation = CString(_T("HKLM\\")) + m_strLocation;
	else if (hkey == HKEY_CURRENT_USER)
		m_strLocation = CString(_T("HKCU\\")) + m_strLocation;
		
	m_hkey = hkey;
	m_strKey = szKey;
	m_strValueName = szValueName;
}

//----------------------------------------------------------------------------
// This constructor is specifically for items under the INI file registry
// mapping.
//----------------------------------------------------------------------------

CStartupItemRegistry::CStartupItemRegistry(LPCTSTR szKey, LPCTSTR szName, LPCTSTR szValueName, LPCTSTR szValue)
{
	m_fIniMapping = TRUE;
	m_fLive = TRUE;

	m_strItem = szName;
	m_strLocation = szKey;
	m_strCommand = szValue;
	m_strLocation = CString(_T("HKCU\\")) + m_strLocation + CString(_T(":")) + szValueName;
		
	m_hkey = HKEY_CURRENT_USER;
	m_strKey = szKey;
	m_strValueName = szValueName;
}

//----------------------------------------------------------------------------
// Enable or disable the startup item in the registry.
//----------------------------------------------------------------------------

BOOL CStartupItemRegistry::SetEnable(BOOL fEnable)
{
	if (fEnable == IsLive())
		return FALSE;

	CRegKey regkey;
	if (ERROR_SUCCESS != regkey.Open(m_hkey, m_strKey, KEY_ALL_ACCESS))
		return FALSE;

	LONG lReturnCode = ERROR_SUCCESS + 1; // need to initialize it to not ERROR_SUCCESS
	if (m_fIniMapping == FALSE)
	{
		// Create or delete the registry key from the data stored in
		// this object.

		if (fEnable)
			lReturnCode = regkey.SetValue(m_strCommand, m_strValueName);
		else
			lReturnCode = regkey.DeleteValue(m_strValueName);
	}
	else
	{
		// This item is an INI file mapping item (which means there
		// might be more than one item on this line).

		TCHAR szValue[MAX_PATH * 4];
		DWORD dwSize = MAX_PATH * 4;
		if (ERROR_SUCCESS == regkey.QueryValue(szValue, m_strValueName, &dwSize))
		{
			CString strValue(szValue);

			if (fEnable)
			{
				if (!strValue.IsEmpty())
					strValue += CString(_T(", "));
				strValue += m_strCommand;
			}
			else
			{
				// The harder case - we need to remove the item, and possibly commas.

				int iCommand = strValue.Find(m_strCommand);
				if (iCommand != -1)
				{
					CString strNewValue;

					if (iCommand > 0)
					{
						strNewValue = strValue.Left(iCommand);
						strNewValue.TrimRight(_T(", "));
					}

					if (strValue.GetLength() > (m_strCommand.GetLength() + iCommand))
					{
						if (!strNewValue.IsEmpty())
							strNewValue += CString(_T(", "));

						CString strRemainder(strValue.Mid(iCommand + m_strCommand.GetLength()));
						strRemainder.TrimLeft(_T(", "));
						strNewValue += strRemainder;
					}

					strValue = strNewValue;
				}
			}

			lReturnCode = regkey.SetValue(strValue, m_strValueName);
		}
	}

	regkey.Close();

	if (lReturnCode != ERROR_SUCCESS)
		return FALSE;

	// Delete or create the registry representation of this item.
	// This representation persists the startup item when it has
	// been deleted.

	regkey.Attach(GetRegKey(_T("startupreg")));
	if ((HKEY)regkey != NULL)
	{
		if (fEnable)
			regkey.DeleteSubKey(m_strValueName);
		else
		{
			regkey.SetKeyValue(m_strValueName, m_strKey, _T("key"));
			regkey.SetKeyValue(m_strValueName, m_strItem, _T("item"));
			if (m_hkey == HKEY_LOCAL_MACHINE)
				regkey.SetKeyValue(m_strValueName, _T("HKLM"), _T("hkey"));
			else
				regkey.SetKeyValue(m_strValueName, _T("HKCU"), _T("hkey"));
			regkey.SetKeyValue(m_strValueName, m_strCommand, _T("command"));
			regkey.SetKeyValue(m_strValueName, m_fIniMapping ? _T("1") : _T("0"), _T("inimapping"));
		}
		regkey.Close();
	}

	m_fLive = fEnable;
	return TRUE;
}

//----------------------------------------------------------------------------
// Create the startup item from the registry representation of the item.
//----------------------------------------------------------------------------

BOOL CStartupItemRegistry::Create(LPCTSTR szKeyName, HKEY hkey)
{
	if (hkey == NULL)
		return FALSE;

	CRegKey regkey;
	regkey.Attach(hkey);
	if ((HKEY)regkey == NULL)
		return FALSE;

	// Restore all of the values from the registry.

	TCHAR szValue[MAX_PATH];
	DWORD dwSize;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("key"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	m_strKey = szValue;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("command"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	m_strCommand = szValue;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("item"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	m_strItem = szValue;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("hkey"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	if (_tcscmp(szValue, _T("HKLM")) == 0)
		m_hkey = HKEY_LOCAL_MACHINE;
	else
		m_hkey = HKEY_CURRENT_USER;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("inimapping"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	if (_tcscmp(szValue, _T("0")) == 0)
		m_fIniMapping = FALSE;
	else
		m_fIniMapping = TRUE;

	regkey.Detach();

	m_strLocation = m_strKey;
	m_strValueName = szKeyName;
	m_fLive = FALSE;
	return TRUE;
}

//----------------------------------------------------------------------------
// Remove all the entries persisted in the registry.
//----------------------------------------------------------------------------

void CStartupItemRegistry::RemovePersistedEntries()
{
	CRegKey regkey;
	regkey.Attach(GetRegKey());
	if ((HKEY)regkey != NULL)
		regkey.RecurseDeleteKey(_T("startupreg"));
}

//============================================================================
// The CStartupItemFolder class is used to encapsulate an individual startup
// stored in the startup folder.
//============================================================================

CStartupItemFolder::CStartupItemFolder()
{
}

//----------------------------------------------------------------------------
// Enable or disable this startup item. Since the item is an actual file in
// a folder, disabling it will mean copying that file to a backup folder and
// creating a registry entry for it. Enabling will mean copying the file
// back to the appropriate startup folder and deleting the registry entry.
//----------------------------------------------------------------------------

BOOL CStartupItemFolder::SetEnable(BOOL fEnable)
{
	if (fEnable == IsLive())
		return FALSE;

	// Copy the file (from or to the backup directory).

	if (fEnable)
	{
		m_strBackupPath = GetBackupName(m_strFilePath, m_strLocation);
		::CopyFile(m_strBackupPath, m_strFilePath, FALSE);
	}
	else
	{
		BackupFile(m_strFilePath, m_strLocation, TRUE);
		m_strBackupPath = GetBackupName(m_strFilePath, m_strLocation);
	}

	// Update the registry for the new state. If we are making the file
	// disabled, then we need to save both the original path and the
	// backed up path (and the standard startup item stuff). Otherwise
	// just delete the key.

	CRegKey regkey;
	regkey.Attach(GetRegKey(_T("startupfolder")));
	if ((HKEY)regkey == NULL)
		return FALSE;
	
	// The name for the registry key just needs to be unique. And not
	// have any backslashes in it.

	CString strRegkey(m_strFilePath);
	strRegkey.Replace(_T("\\"), _T("^"));

	if (fEnable)
	{
		regkey.DeleteSubKey(strRegkey);
		::DeleteFile(m_strBackupPath);
	}
	else
	{
		regkey.SetKeyValue(strRegkey, m_strFilePath, _T("path"));
		regkey.SetKeyValue(strRegkey, m_strBackupPath, _T("backup"));
		regkey.SetKeyValue(strRegkey, m_strLocation, _T("location"));
		regkey.SetKeyValue(strRegkey, m_strCommand, _T("command"));
		regkey.SetKeyValue(strRegkey, m_strItem, _T("item"));
		::DeleteFile(m_strFilePath);
	}

	m_fLive = fEnable;
	return TRUE;
}

//----------------------------------------------------------------------------
// Load the disabled startup item from the registry.
//----------------------------------------------------------------------------

BOOL CStartupItemFolder::Create(LPCTSTR szKeyName, HKEY hkey)
{
	if (hkey == NULL)
		return FALSE;

	CRegKey regkey;
	regkey.Attach(hkey);
	if ((HKEY)regkey == NULL)
		return FALSE;

	// Restore all of the values from the registry.

	TCHAR szValue[MAX_PATH];
	DWORD dwSize;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("path"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	m_strFilePath = szValue;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("backup"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	m_strBackupPath = szValue;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("location"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	m_strLocation = szValue;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("command"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	m_strCommand = szValue;

	dwSize = MAX_PATH;
	if (ERROR_SUCCESS != regkey.QueryValue(szValue, _T("item"), &dwSize))
	{
		regkey.Detach();
		return FALSE;
	}
	m_strItem = szValue;

	regkey.Detach();
	m_fLive = FALSE;
	return TRUE;
}

//----------------------------------------------------------------------------
// Create the startup item from the file found in the folder. If the file
// is a shortcut, get the information about the target.
//----------------------------------------------------------------------------

BOOL CStartupItemFolder::Create(const WIN32_FIND_DATA & fd, HKEY hkey, LPCTSTR szRegPathToFolder, LPCTSTR szFolder, LPCTSTR szDir)
{
	// We want to save the path to the file in the startup folder (even if
	// it is a shortcut).

	m_strFilePath = szDir;
	if (m_strFilePath.Right(1) != CString(_T("\\")))
		m_strFilePath += CString(_T("\\"));
	m_strFilePath += fd.cFileName;

	// Look at the file to determine how to handle it.

	CString strFile(fd.cFileName);
	strFile.MakeLower();

	if (strFile.Right(4) == CString(_T(".lnk")))
	{
		// The file is a shortcut to a different command. Show that command.

		CIconInfo info;
		_tcsncpy(info.szPath, m_strFilePath, sizeof(info.szPath) / sizeof(TCHAR));

		if (SUCCEEDED(GetIconInfo(info)))
		{
			m_fLive			= TRUE;
			m_strItem		= fd.cFileName;
			m_strLocation	= szFolder;

			m_strCommand.Format(_T("%s %s"), info.szTarget, info.szArgs);
			
			int iDot = m_strItem.ReverseFind(_T('.'));
			if (iDot > 0)
				m_strItem = m_strItem.Left(iDot);

			return TRUE;
		}
	}
	else
	{
		// A file besides a shortcut. It may be an EXE, or some other file type
		// (we'll handle them the same).

		m_fLive			= TRUE;
		m_strItem		= fd.cFileName;
		m_strLocation	= szFolder;
		m_strCommand	= m_strFilePath;

		int iDot = m_strItem.ReverseFind(_T('.'));
		if (iDot > 0)
			m_strItem = m_strItem.Left(iDot);

		return TRUE;
	}

	return FALSE;
}

//----------------------------------------------------------------------------
// Get the information about a shortcut. Creates a thread to do so, since it
// needs to be done in an apartment model thread.
//
// JJ's code, cleaned up a bit.
//----------------------------------------------------------------------------

DWORD GetIconInfoProc(CStartupItemFolder::CIconInfo * pInfo);
HRESULT CStartupItemFolder::GetIconInfo(CIconInfo & info)
{
	DWORD	dwID;
	HANDLE	hThread;

	if (hThread = ::CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)GetIconInfoProc, &info, 0, &dwID))
	{
		info.hResult = S_OK;
		::WaitForSingleObject(hThread, INFINITE);
	}
	else
		info.hResult = E_FAIL;

	return info.hResult;
}

//----------------------------------------------------------------------------
// Remove all the entries persisted in the registry.
//----------------------------------------------------------------------------

void CStartupItemFolder::RemovePersistedEntries()
{
	CRegKey regkey;
	regkey.Attach(GetRegKey());
	if ((HKEY)regkey != NULL)
		regkey.RecurseDeleteKey(_T("startupfolder"));
}

//----------------------------------------------------------------------------
// Procedure (run in its own thread) to get information about a shortcut.
//
// JJ's code, cleaned up a bit.
//----------------------------------------------------------------------------

DWORD GetIconInfoProc(CStartupItemFolder::CIconInfo * pInfo)
{
	HRESULT			hResult;
	IShellLink *	psl = NULL;
	IPersistFile *	ppf = NULL;

	try
	{
		// We have to use COINIT_APARTMENTTHREADED.

		if (SUCCEEDED(hResult = CoInitialize(NULL)))
		{
			// Get a pointer to the IShellLink interface.

			if (SUCCEEDED(hResult = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (VOID **) &psl)))
			{ 
				// Get a pointer to the IPersistFile interface.

				if (SUCCEEDED(hResult = psl->QueryInterface(IID_IPersistFile, (VOID **) &ppf)))
				{
					BSTR bstrPath;
#ifdef UNICODE
					bstrPath = pInfo->szPath;
#else
					WCHAR wszTemp[MAX_PATH];
					if (pInfo->szPath(pInfo->szPath) < MAX_PATH)
						wsprintfW(wszTemp, L"%hs", pInfo->szPath);
					else
						wszTemp[0] = 0;
					bstrPath = wszTemp;
#endif

					if (SUCCEEDED(hResult = ppf->Load(bstrPath, STGM_READ)))
					{
						WIN32_FIND_DATA fd;

						hResult = psl->GetPath(pInfo->szTarget, sizeof(pInfo->szTarget), &fd, SLGP_SHORTPATH);
						hResult = psl->GetArguments(pInfo->szArgs, sizeof(pInfo->szArgs));
					} 
				}
			}
		}

		pInfo->hResult = hResult;

	}
	catch(...)
	{
		if (psl)
			psl->Release();
		if (ppf)
			ppf->Release();
		CoUninitialize();

		throw;
	}

	if (psl)
	{
		psl->Release();
		psl = NULL;
	}

	if (ppf)
	{
		ppf->Release();
		ppf = NULL;
	}

	CoUninitialize();

	return 0;
}

BOOL CPageStartup::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	::EnableWindow(GetDlgItemHWND(IDC_LISTSTARTUP), TRUE);

	// Attach to the list view and set the styles we need.

	m_fIgnoreListChanges = TRUE;
	m_list.Attach(GetDlgItemHWND(IDC_LISTSTARTUP));
	ListView_SetExtendedListViewStyle(m_list.m_hWnd, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

	// Add all of the necessary columns to the list view's header control.

	struct { UINT m_uiStringResource; int m_iPercentOfWidth; } aColumns[] = 
	{
		{ IDS_STARTUP_LOCATION, 50 },
		{ IDS_STARTUP_COMMAND, 25 },
		{ IDS_STARTUP_ITEM, 25 },
		{ 0, 0 }
	};

	CRect rect;
	m_list.GetClientRect(&rect);
	int cxWidth = rect.Width();

	LVCOLUMN lvc;
	lvc.mask = LVCF_TEXT | LVCF_WIDTH;

	CString strCaption;

	::AfxSetResourceHandle(_Module.GetResourceInstance());
	for (int i = 0; aColumns[i].m_uiStringResource; i++)
	{
		strCaption.LoadString(aColumns[i].m_uiStringResource);
		lvc.pszText = (LPTSTR)(LPCTSTR)strCaption;
		lvc.cx = aColumns[i].m_iPercentOfWidth * cxWidth / 100;
		ListView_InsertColumn(m_list.m_hWnd, 0, &lvc);
	}

	LoadStartupList();

	CPageBase::TabState state = GetCurrentTabState();
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONSUDISABLEALL), (state != DIAGNOSTIC));
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONSUENABLEALL), (state != NORMAL));

	m_stateRequested = GetAppliedTabState();
	m_fInitialized = TRUE;

	// Show the restore disabled startup item button based on whether or not
	// there are items to restore.

	::ShowWindow(GetDlgItemHWND(IDC_BUTTONSURESTORE), CRestoreStartup::AreItemsToRestore() ? SW_SHOW : SW_HIDE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
}

void CPageStartup::OnDestroy() 
{
	CPropertyPage::OnDestroy();
	EmptyList(TRUE);
}

//-----------------------------------------------------------------------------
// If there's a change to an item in the list, it's probably because the user
// has checked or unchecked a checkbox.
//-----------------------------------------------------------------------------

void CPageStartup::OnItemChangedList(NMHDR * pNMHDR, LRESULT * pResult) 
{
	NM_LISTVIEW * pNMListView = (NM_LISTVIEW  *)pNMHDR;

	if (!m_fIgnoreListChanges)
	{
		LVITEM lvi;
		lvi.mask = LVIF_PARAM;
		lvi.iSubItem = 0;
		lvi.iItem = pNMListView->iItem;

		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CStartupItem * pItem = (CStartupItem *)lvi.lParam;
			if (pItem)
			{
				BOOL fCurrentCheck = ListView_GetCheckState(m_list.m_hWnd, pNMListView->iItem);
				if (fCurrentCheck != pItem->IsLive())
					SetModified(TRUE);

				CPageBase::TabState state = GetCurrentTabState();
				::EnableWindow(GetDlgItemHWND(IDC_BUTTONSUDISABLEALL), (state != DIAGNOSTIC));
				::EnableWindow(GetDlgItemHWND(IDC_BUTTONSUENABLEALL), (state != NORMAL));
			}
		}
	}
	*pResult = 0;
}

//-----------------------------------------------------------------------------
// Handle the buttons to enable or disable all the items.
//-----------------------------------------------------------------------------

void CPageStartup::OnButtonDisableAll() 
{
	SetEnableForList(FALSE);
}

void CPageStartup::OnButtonEnableAll() 
{
	SetEnableForList(TRUE);
}

//-------------------------------------------------------------------------
// Return the current state of the tab (need to look through the list).
//-------------------------------------------------------------------------

CPageBase::TabState CPageStartup::GetCurrentTabState()
{
	if (!m_fInitialized)
		return GetAppliedTabState();

	// If there are no startup items, we can only return the 
	// state that was last requested.

	if (ListView_GetItemCount(m_list.m_hWnd) == 0)
		return m_stateRequested;

	TabState	stateReturn = USER;
	BOOL		fAllEnabled = TRUE, fAllDisabled = TRUE;
	LVITEM		lvi;

	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		if (ListView_GetCheckState(m_list.m_hWnd, i))
			fAllDisabled = FALSE;
		else
			fAllEnabled = FALSE;
	}

	if (fAllEnabled)
		stateReturn = NORMAL;
	else if (fAllDisabled)
		stateReturn = DIAGNOSTIC;

	return stateReturn;
}

//-------------------------------------------------------------------------
// Traverse the list looking for items which have check boxes that don't
// match the state of the items. For these items, set the state.
//
// Finally, the base class implementation is called to maintain the
// applied tab state.
//-------------------------------------------------------------------------

BOOL CPageStartup::OnApply()
{
	if (!m_fModified)
		return TRUE;

	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		lvi.iItem = i;

		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CStartupItem * pItem = (CStartupItem *)lvi.lParam;
			if (pItem)
			{
				BOOL fCurrentCheck = ListView_GetCheckState(m_list.m_hWnd, i);
				if (fCurrentCheck != pItem->IsLive())
					pItem->SetEnable(fCurrentCheck);
			}
		}
	}

	CPageBase::SetAppliedState(GetCurrentTabState());
	CancelToClose();
	m_fMadeChange = TRUE;
	return TRUE;
}

//-------------------------------------------------------------------------
// Apply the changes, remove the persisted registry entries, refill the
// list. Then call the base class implementation.
//-------------------------------------------------------------------------

void CPageStartup::CommitChanges()
{
	OnApply();
	CStartupItemRegistry::RemovePersistedEntries();
	CStartupItemFolder::RemovePersistedEntries();
	LoadStartupList();
	CPageBase::CommitChanges();
}

//-------------------------------------------------------------------------
// Set the overall state of the tab to normal or diagnostic.
//-------------------------------------------------------------------------

void CPageStartup::SetNormal()
{
	SetEnableForList(TRUE);
	m_stateRequested = NORMAL;
}

void CPageStartup::SetDiagnostic()
{
	SetEnableForList(FALSE);
	m_stateRequested = DIAGNOSTIC;
}

//-------------------------------------------------------------------------
// If nothing is selected when the list gets focus, select the first item
// (so the user sees where the focus is).
//-------------------------------------------------------------------------

void CPageStartup::OnSetFocusList(NMHDR * pNMHDR, LRESULT * pResult) 
{
	if (0 == ListView_GetSelectedCount(m_list.m_hWnd) && 0 < ListView_GetItemCount(m_list.m_hWnd))
		ListView_SetItemState(m_list.m_hWnd, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

	*pResult = 0;
}

//-------------------------------------------------------------------------
// Show the dialog which allows the user to restore startup items which
// were disabled during upgrade.
//-------------------------------------------------------------------------

void CPageStartup::OnButtonRestore() 
{
	CRestoreStartup dlg;
	dlg.DoModal();
	::EnableWindow(GetDlgItemHWND(IDC_BUTTONSURESTORE), CRestoreStartup::AreItemsToRestore());
}

//=========================================================================
// This code implements the CRestoreStartup dialog, which allows the
// user to restore items disabled by an upgrade.
//=========================================================================

CRestoreStartup::CRestoreStartup(CWnd* pParent /*=NULL*/) : CDialog(CRestoreStartup::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRestoreStartup)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

void CRestoreStartup::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRestoreStartup)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRestoreStartup, CDialog)
	//{{AFX_MSG_MAP(CRestoreStartup)
	ON_WM_DESTROY()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_RESTORELIST, OnItemChangedRestoreList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------
// As the dialog initializes, set the format of the list view, add the
// appropriate columns, and populate the list with the disabled startup items.
//-----------------------------------------------------------------------------

BOOL CRestoreStartup::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Set the list view to have check boxes.

	CWnd * pWnd = GetDlgItem(IDC_RESTORELIST);
	if (pWnd == NULL)
		return FALSE;
	m_list.Attach(pWnd->m_hWnd);
	ListView_SetExtendedListViewStyle(m_list.m_hWnd, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

	// Add all of the necessary columns to the list view's header control.

	struct { UINT m_uiStringResource; int m_iPercentOfWidth; } aColumns[] = 
	{
		{ IDS_STARTUP_ITEM, 65 },
		{ IDS_STARTUP_LOCATION, 35 },
		{ 0, 0 }
	};

	CRect rect;
	m_list.GetClientRect(&rect);
	int cxWidth = rect.Width();

	LVCOLUMN lvc;
	lvc.mask = LVCF_TEXT | LVCF_WIDTH;

	CString strCaption;

	::AfxSetResourceHandle(_Module.GetResourceInstance());
	for (int i = 0; aColumns[i].m_uiStringResource; i++)
	{
		strCaption.LoadString(aColumns[i].m_uiStringResource);
		lvc.pszText = (LPTSTR)(LPCTSTR)strCaption;
		lvc.cx = aColumns[i].m_iPercentOfWidth * cxWidth / 100;
		ListView_InsertColumn(m_list.m_hWnd, 0, &lvc);
	}

	// Load up the list with the disabled items.

	LoadDisabledItemList();
	SetOKState();
	return TRUE;
}

//-----------------------------------------------------------------------------
// Load the items in the list (from the registry and startup directory).
//-----------------------------------------------------------------------------

BOOL CRestoreStartup::LoadDisabledItemList()
{
	m_iNextPosition = 0;
	BOOL fRegistry = LoadDisabledRegistry();
	BOOL fStartup = LoadDisabledStartupGroup();
	return (fRegistry && fStartup);
}

//-----------------------------------------------------------------------------
// Read the list of disabled startup items which would be restored to the
// registry. This list is just stored in a different registry location.
//-----------------------------------------------------------------------------

BOOL CRestoreStartup::LoadDisabledRegistry()
{
	HKEY ahkeyBases[] = { HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER, NULL };

	for (int i = 0; ahkeyBases[i] != NULL; i++)
	{
		// Open the key containing the disabled items. We open it KEY_WRITE | KEY_READ,
		// even though we are just going to read in this function. This is because
		// if opening for this access fails, we don't want to list the items because
		// the user won't be able to restore the items.

		CRegKey regkey;
		if (ERROR_SUCCESS != regkey.Open(ahkeyBases[i], DISABLED_KEY, KEY_WRITE | KEY_READ))
			return FALSE;

		// Get the number of keys under the key and look at each one.

		DWORD dwValueCount, dwSize;
		if (ERROR_SUCCESS == ::RegQueryInfoKey((HKEY)regkey, NULL, NULL, NULL, NULL, NULL, NULL, &dwValueCount, NULL, NULL, NULL, NULL))
		{
			TCHAR szValueName[MAX_PATH], szValue[MAX_PATH];
			for (DWORD dwKey = 0; dwKey < dwValueCount; dwKey++)
			{
				dwSize = MAX_PATH;
				if (ERROR_SUCCESS != ::RegEnumValue((HKEY)regkey, dwKey, szValueName, &dwSize, NULL, NULL, NULL, NULL))
					continue;

				dwSize = MAX_PATH;
				if (ERROR_SUCCESS != regkey.QueryValue(szValue, szValueName, &dwSize))
					continue;

				// Create the startup item and insert it in the list.

				CStartupDisabledRegistry * pItem = new CStartupDisabledRegistry(szValueName, szValue, ENABLED_KEY, ahkeyBases[i]);
				InsertDisabledStartupItem(pItem);
			}
		}

		regkey.Close();
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Add the items from the disabled startup group to the list:
//
//		GIVEN the path to CSIDL_STARTUP, setup moves disabled items to
//		..\Disabled Startup	and makes it hidden; it potentially contains
//		the complete content of the original startup folder, which
//		can be anything.
//
// Note - we'll also need to look under CSIDL_COMMON_STARTUP.
//-----------------------------------------------------------------------------

BOOL CRestoreStartup::LoadDisabledStartupGroup()
{
	int		anFolders[] = { CSIDL_STARTUP, CSIDL_COMMON_STARTUP, 0 };
	TCHAR	szPath[MAX_PATH * 2];

	for (int i = 0; anFolders[i] != 0; i++)
	{
		if (FAILED(::SHGetSpecialFolderPath(NULL, szPath, anFolders[i], FALSE)))
			continue;

		// We need to trim off the last part of the path and replace it with
		// "Disabled Startup".

		CString strPath(szPath);
		int iLastSlash = strPath.ReverseFind(_T('\\'));
		if (iLastSlash == -1)
			continue;
		strPath = strPath.Left(iLastSlash) + CString(DISABLED_STARTUP);

		// Now look for files in the folder.

		CString strSearch(strPath);
		strSearch += CString(_T("\\*.*"));

		WIN32_FIND_DATA fd;
		HANDLE hFind = FindFirstFile(strSearch, &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do
			{
				// We want to ignore the desktop.ini file which might appear in startup.

				if ((fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) == 0 || _tcsicmp(fd.cFileName, _T("desktop.ini")) != 0)
				{
					// We only want to examine files which aren't directories.

					if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
					{
						CStartupDisabledStartup * pItem = new CStartupDisabledStartup(fd.cFileName, szPath, strPath);
						InsertDisabledStartupItem(pItem);
					}
				}
			} while (FindNextFile(hFind, &fd));

			FindClose(hFind);
		}
	}

	return TRUE;
}


//-----------------------------------------------------------------------------
// Insert the disabled item into the list view.
//-----------------------------------------------------------------------------

void CRestoreStartup::InsertDisabledStartupItem(CStartupDisabled * pItem)
{
	if (pItem == NULL)
		return;

	CString strItem, strLocation;
	pItem->GetColumnCaptions(strItem, strLocation);

	// Insert the item in the list view.

	LV_ITEM lvi;
	memset(&lvi, 0, sizeof(lvi));
	lvi.mask = LVIF_TEXT | LVIF_PARAM;
	lvi.iItem = m_iNextPosition;

	lvi.pszText = (LPTSTR)(LPCTSTR)strLocation;
	lvi.iSubItem = 0;
	lvi.lParam = (LPARAM)pItem;

	m_iNextPosition = ListView_InsertItem(m_list.m_hWnd, &lvi);
	ListView_SetItemText(m_list.m_hWnd, m_iNextPosition, 1, (LPTSTR)(LPCTSTR)strItem);
	ListView_SetCheckState(m_list.m_hWnd, m_iNextPosition, TRUE);

	m_iNextPosition++;
}

//-----------------------------------------------------------------------------
// Remove all the items from the list view (freeing the objects pointed to
// by the LPARAM).
//-----------------------------------------------------------------------------

void CRestoreStartup::EmptyList()
{
	LVITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
	{
		lvi.iItem = i;

		if (ListView_GetItem(m_list.m_hWnd, &lvi))
		{
			CStartupDisabled * pItem = (CStartupDisabled *)lvi.lParam;
			if (pItem)
				delete pItem;
		}
	}

	ListView_DeleteAllItems(m_list.m_hWnd);
}

//-----------------------------------------------------------------------------
// When the dialog is being destroyed, be sure to free the memory of the
// object pointers maintained in the list view.
//-----------------------------------------------------------------------------

void CRestoreStartup::OnDestroy() 
{
	EmptyList();
	CDialog::OnDestroy();
}

//-----------------------------------------------------------------------------
// If the user clicks on OK, then we should make sure he or she really wants
// to perform this operation. If so, then look though the list, calling the
// Restore function for each object with the checkbox checked.
//-----------------------------------------------------------------------------

void CRestoreStartup::OnOK() 
{
	CString strText, strCaption;

	strCaption.LoadString(IDS_DIALOGCAPTION);
	strText.LoadString(IDS_VERIFYRESTORE);

	if (IDYES == ::MessageBox(m_hWnd, strText, strCaption, MB_YESNO))
	{
		LVITEM		lvi;
		lvi.mask = LVIF_PARAM;
		lvi.iSubItem = 0;
		for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
			if (ListView_GetCheckState(m_list.m_hWnd, i))
			{
				lvi.iItem = i;
				if (ListView_GetItem(m_list.m_hWnd, &lvi))
				{
					CStartupDisabled * pItem = (CStartupDisabled *)lvi.lParam;
					if (pItem != NULL)
						pItem->Restore();
				}
			}
	}
	
	CDialog::OnOK();
}

//-----------------------------------------------------------------------------
// Enable or disable the OK button based on the state of the check boxes.
//-----------------------------------------------------------------------------

void CRestoreStartup::SetOKState()
{
	CWnd * pWnd = GetDlgItem(IDOK);
	if (pWnd == NULL)
		return;

	BOOL fEnable = FALSE;
	for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
		if (ListView_GetCheckState(m_list.m_hWnd, i))
		{
			fEnable = TRUE;
			break;
		}

	if (::IsWindowEnabled(pWnd->m_hWnd) != fEnable)
		::EnableWindow(pWnd->m_hWnd, fEnable);
}

//-----------------------------------------------------------------------------
// If the user changed something in the list, update the OK button state.
//-----------------------------------------------------------------------------

void CRestoreStartup::OnItemChangedRestoreList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	SetOKState();
	*pResult = 0;
}

//-----------------------------------------------------------------------------
// This static function will be called by the startup tab to determine if the
// button to launch this dialog box should be enabled.
//-----------------------------------------------------------------------------

BOOL CRestoreStartup::AreItemsToRestore()
{
	// Look in the registry for disabled items.

	HKEY ahkeyBases[] = { HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER, NULL };
	for (int j = 0; ahkeyBases[j] != NULL; j++)
	{
		CRegKey regkey;
		if (ERROR_SUCCESS == regkey.Open(ahkeyBases[j], DISABLED_KEY, KEY_READ))
		{
			DWORD dwValueCount;
			if (ERROR_SUCCESS == ::RegQueryInfoKey((HKEY)regkey, NULL, NULL, NULL, NULL, NULL, NULL, &dwValueCount, NULL, NULL, NULL, NULL))
				if (dwValueCount > 0)
				{
					regkey.Close();
					return TRUE;
				}
			regkey.Close();
		}
	}

	// Look in the disabled startup items folders.

	int		anFolders[] = { CSIDL_STARTUP, CSIDL_COMMON_STARTUP, 0 };
	TCHAR	szPath[MAX_PATH * 2];
	BOOL	fDisabledItem = FALSE;

	for (int i = 0; !fDisabledItem && anFolders[i] != 0; i++)
	{
		if (FAILED(::SHGetSpecialFolderPath(NULL, szPath, anFolders[i], FALSE)))
			continue;

		// We need to trim off the last part of the path and replace it with
		// "Disabled Startup".

		CString strPath(szPath);
		int iLastSlash = strPath.ReverseFind(_T('\\'));
		if (iLastSlash == -1)
			continue;
		strPath = strPath.Left(iLastSlash) + CString(DISABLED_STARTUP);

		// Now look for files in the folder.

		CString strSearch(strPath);
		strSearch += CString(_T("\\*.*"));

		WIN32_FIND_DATA fd;
		HANDLE hFind = FindFirstFile(strSearch, &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do
			{
				// We want to ignore the desktop.ini file which might appear in startup.

				if ((fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) == 0 || _tcsicmp(fd.cFileName, _T("desktop.ini")) != 0)
				{
					// We only want to examine files which aren't directories.

					if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
					{
						fDisabledItem = TRUE;
						break;
					}
				}
			} while (FindNextFile(hFind, &fd));

			FindClose(hFind);
		}
	}

	return fDisabledItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\rebootdlg.h ===
// rebootdlg.h : Declaration of the CRebootDlg

#ifndef __REBOOTDLG_H_
#define __REBOOTDLG_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

/////////////////////////////////////////////////////////////////////////////
// CRebootDlg
class CRebootDlg : 
	public CAxDialogImpl<CRebootDlg>
{
public:
	CRebootDlg()
	{
	}

	~CRebootDlg()
	{
	}

	enum { IDD = IDD_REBOOTDLG };

BEGIN_MSG_MAP(CRebootDlg)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
#ifdef RUN_FROM_MSDEV // It's a pain to accidentally restart your system while debugging.
		::EnableWindow(GetDlgItem(IDOK), FALSE);
#endif
		return 1;  // Let the system set the focus
	}

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		EndDialog(wID);
		return 0;
	}

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		EndDialog(wID);
		return 0;
	}
};

#endif //__REBOOTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MSConfig.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"



	#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#endif
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\undodialog.cpp ===
// UndoDialog.cpp : Implementation of CUndoDialog
#include "stdafx.h"
#include "UndoDialog.h"

/////////////////////////////////////////////////////////////////////////////
// CUndoDialog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8509634C_D0D8_4FF8_BAD1_5FA95312BEDC__INCLUDED_)
#define AFX_STDAFX_H__8509634C_D0D8_4FF8_BAD1_5FA95312BEDC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#define _ATL_APARTMENT_THREADED
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CMSConfigModule : public CComModule
{
public:
	LONG Unlock();
	LONG Lock();
	LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2);
	DWORD dwThreadID;
};
extern CMSConfigModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#ifndef ListView_SetCheckState
   #define ListView_SetCheckState(hwndLV, i, fCheck) \
      ListView_SetItemState(hwndLV, i, \
      INDEXTOSTATEIMAGEMASK((fCheck)+1), LVIS_STATEIMAGEMASK)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8509634C_D0D8_4FF8_BAD1_5FA95312BEDC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msconfig.rc
//
#define IDC_CLOSE                       1
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_GENERAL_CAPTION             101
#define IDD_MSCONFIG_DIALOG             102
#define IDB_MSCONFIGCTL                 102
#define IDS_BOOTINI_CAPTION             102
#define IDR_MSCONFIGCTL                 103
#define IDS_WININI_CAPTION              103
#define IDD_MSCONFIGCTL                 104
#define IDS_SYSTEMINI_CAPTION           104
#define IDD_PAGEGENERAL                 105
#define IDS_STARTUP_CAPTION             105
#define IDD_PAGEBOOTINI                 106
#define IDS_SERVICES_CAPTION            106
#define IDS_REGISTRY_CAPTION            107
#define IDS_INTERNATIONAL_CAPTION       108
#define IDS_CHANGEBOOTINI               109
#define IDD_UNDODIALOG                  110
#define IDS_DATECAPTION                 110
#define IDS_CHANGECAPTION               111
#define IDS_USERSHOULDRESTART           112
#define IDS_ABOUTBOX                    112
#define IDD_REBOOTDLG                   113
#define IDS_CHANGEFILE                  113
#define IDS_SERVICE_COLUMN              113
#define IDD_BOOTINIADVANCEDDLG          114
#define IDS_MANUFACTURER_COLUMN         114
#define IDR_MSCONFIG                    115
#define IDS_STATUS_COLUMN               115
#define IDS_SERVICESTOPPED              116
#define IDS_SERVICESTARTPENDING         117
#define IDS_SERVICESTOPPENDING          118
#define IDS_SERVICERUNNING              119
#define IDS_SERVICECONTINUEPENDING      120
#define IDS_SERVICEPAUSEPENDING         121
#define IDS_SERVICEPAUSED               122
#define IDS_UNKNOWN                     123
#define IDS_TIMEOUTVALUE                124
#define IDS_APPCAPTION                  125
#define IDS_DIALOGCAPTION               126
#define IDS_REQUIREDSERVICE             127
#define IDR_MAINFRAME                   128
#define IDS_YES                         128
#define IDS_STARTUP_ITEM                129
#define IDS_STARTUP_COMMAND             130
#define IDS_STARTUP_LOCATION            131
#define IDS_NOFIND                      132
#define IDS_ALBANIAN                    133
#define IDS_ARABIC_Algeria              134
#define IDS_ARABIC_Bahrain              135
#define IDS_ARABIC_Egypt                136
#define IDS_COUNTRY_SYS                 137
#define IDS_JKEYBRD_SYS                 138
#define IDS_EGA_CPI                     139
#define IDS_KEYBRD2_SYS                 140
#define IDS_KEYBRD4_SYS                 141
#define IDS_EGA3_CPI                    142
#define IDS_ARABIC_Iraq                 143
#define IDS_ARABIC_Jordan               144
#define IDS_ARABIC_Kuwait               145
#define IDS_ARABIC_Libya                146
#define IDS_ARABIC_Morocco              147
#define IDS_ARABIC_Oman                 148
#define IDS_ARABIC_Qatar                149
#define IDS_ARABIC_Saudi_Arabia         150
#define IDS_ARABIC_Syria                151
#define IDS_ARABIC_Tunisia              152
#define IDS_ARABIC_U_A_E                153
#define IDS_BASQUE                      154
#define IDS_BELARUSSIAN                 155
#define IDS_BULGARIAN                   156
#define IDS_CATALAN                     157
#define IDS_CHINA                       158
#define IDS_CROATIAN                    159
#define IDS_CZECH                       160
#define IDS_DANISH                      161
#define IDS_DUTCH_Belgian               162
#define IDS_DUTCH_Standard              163
#define IDS_ENGLISH_United_States       164
#define IDS_ENGLISH_Australian          165
#define IDS_ENGLISH_British             166
#define IDS_ENGLISH_Canadian            167
#define IDS_ENGLISH_Ireland             168
#define IDS_ENGLISH_New_Zealand         169
#define IDS_ESTONIAN                    170
#define IDS_FINISH                      171
#define IDS_FRENCH_Belgian              172
#define IDS_FRENCH_Canadian             173
#define IDS_FRENCH_Luxembourg           174
#define IDS_FRENCH_Standard             175
#define IDS_FRENCH_Swiss                176
#define IDS_GERMAN_Austrian             177
#define IDS_GERMAN_Liechtenstein        178
#define IDS_GERMAN_Luxembourg           179
#define IDS_GERMAN_Standard             180
#define IDS_GERMAN_Swiss                181
#define IDS_GREEK_737_LATIN             182
#define IDS_GREEK_737_437_LATIN         183
#define IDS_GREEK_869_LATIN             184
#define IDS_GREEK_869_851_LATIN         185
#define IDS_GREEK_737_IBM220            186
#define IDS_GREEK_737_437_IBM220        187
#define IDS_GREEK_869_IBM220            188
#define IDS_GREEK_869_851_IBM220        189
#define IDS_GREEK_737_IBM319            190
#define IDS_GREEK_737_437_IBM319        191
#define IDS_GREEK_869_IBM319            192
#define IDS_GREEK_869_851_IBM319        193
#define IDS_GREEK_737_LATIN_IBM319      194
#define IDS_GREEK_737_437_LATIN_IBM319  195
#define IDS_GREEK_869_LATIN_IBM319      196
#define IDS_GREEK_869_851_LATIN_IBM319  197
#define IDS_HEBREW                      198
#define IDS_HUNGARIAN                   199
#define IDS_ICELANDIC                   200
#define IDS_INDONESIAN                  201
#define IDC_MSCONFIGTAB                 201
#define IDD_PAGEINI                     201
#define IDS_ITALIAN_Standard            202
#define IDC_BUTTONOK                    202
#define IDD_PAGESTARTUP                 202
#define IDS_ITALIAN_142_Standard        203
#define IDC_BUTTONCANCEL                203
#define IDD_PAGESERVICES                203
#define IDS_ITALIAN_Swiss               204
#define IDC_BUTTONAPPLY                 204
#define IDD_PAGEREGISTRY                204
#define IDS_JAPANESE_101                205
#define IDC_PLACEHOLDER                 205
#define IDD_PAGEINTERNATIONAL           205
#define IDS_JAPANESE_106                206
#define IDC_LISTBOOTINI                 206
#define IDB_IMAGELIST                   206
#define IDS_KOREAN                      207
#define IDC_BOOTADVANCED                207
#define IDD_FINDDLG                     207
#define IDC_BUTTONHELP                  207
#define IDS_LATVIAN                     208
#define IDC_CHECKBOOTPATHS              208
#define IDD_DIALOG1                     208
#define IDS_LITHUANIAN                  209
#define IDC_SETASDEFAULT                209
#define IDD_AUTOSTART                   209
#define IDC_BOOTMOVEUP                  210
#define IDD_ESSENTIALSERVICE            210
#define IDS_NORWEGIAN                   211
#define IDC_BOOTMOVEDOWN                211
#define IDS_POLISH                      212
#define IDC_BOOTOPTIONS                 212
#define IDD_EXTRACT                     212
#define IDS_POLISH_Prgmers              213
#define IDC_TIMEOUT                     213
#define IDS_PORTUGUESE_Standard         214
#define IDC_EDITTIMEOUT                 214
#define IDD_RESTORE                     214
#define IDS_PORTUGUESE_Brazilian        215
#define IDC_SECONDS                     215
#define IDS_ROMANIAN                    216
#define IDC_SAFEBOOT                    216
#define IDS_RUSSIAN                     217
#define IDC_NOGUIBOOT                   217
#define IDS_SERBIAN                     218
#define IDC_BOOTLOG                     218
#define IDS_SLOVENIAN                   219
#define IDC_BASEVIDEO                   219
#define IDS_SPANISH_Argentina           220
#define IDC_SOS                         220
#define IDS_SPANISH_Bolivia             221
#define IDC_SBNORMAL                    221
#define IDS_SPANISH_Chile               222
#define IDC_SBNETWORK                   222
#define IDS_SPANISH_Colombia            223
#define IDC_SBDSREPAIR                  223
#define IDS_SPANISH_Costa_Rica          224
#define IDC_SBMINIMAL                   224
#define IDS_SPANISH_Ecuador             225
#define IDC_SBMINIMALALT                225
#define IDS_SPANISH_El_Salvador         226
#define IDC_NORMALSTARTUP               226
#define IDS_SPANISH_Honduras            227
#define IDC_DIAGNOSTICSTARTUP           227
#define IDS_SPANISH_Mexico              228
#define IDC_SELECTIVESTARTUP            228
#define IDS_SPANISH_Modern_Sort         229
#define IDC_CHECK_PROCSYSINI            229
#define IDS_SPANISH_Nicaragua           230
#define IDC_CHECKPROCWININI             230
#define IDS_SPANISH_Venezuela           231
#define IDC_CHECKLOADSYSSERVICES        231
#define IDS_SWEDISH                     232
#define IDC_CHECKLOADSTARTUPITEMS       232
#define IDS_TAIWAN                      233
#define IDC_BUTTONADVANCED              233
#define IDS_THAI                        234
#define IDC_BUTTONEXTRACT               234
#define IDS_TURKISH_F_TYPE              235
#define IDC_BUTTONMSCONFIGUNDO          235
#define IDC_CHECKLOADBOOTINI            235
#define IDS_TURKISH_Q_TYPE              236
#define IDC_BUTTONLAUNCHSYSRESTORE      236
#define IDS_UKRANIAN                    237
#define IDC_INITREE                     237
#define IDS_VIETNAMESE                  238
#define IDC_BUTTONSEARCH                238
#define IDS_KEYBRD3_SYS                 239
#define IDC_BUTTONINIMOVEUP             239
#define IDS_KEYBOARD_SYS                240
#define IDC_BUTTONINIMOVEDOWN           240
#define IDS_EGA2_CPI                    241
#define IDC_BUTTONINIENABLE             241
#define IDS_EGA4_CPI                    242
#define IDC_BUTTONINIDISABLE            242
#define IDS_HEBEGA_CPI                  243
#define IDC_BUTTONININEW                243
#define IDS_NO_LANG                     244
#define IDC_BUTTONINIEDIT               244
#define IDS_ARABIC_Lebanon              245
#define IDC_BUTTONINIENABLEALL          245
#define IDS_ARABIC_Yemen                246
#define IDC_BUTTONINIDISABLEALL         246
#define IDS_AFRICAN                     247
#define IDC_BUTTONSUENABLEALL           247
#define IDS_SLOVAK                      248
#define IDC_BUTTONSUDISABLEALL          248
#define IDC_BUTTONSUDISVIRUS            249
#define IDS_SELECTFROM                  249
#define IDC_BUTTONSURESTORE             249
#define IDC_BUTTONSUCLEANUP             250
#define IDS_SELECTTO                    250
#define IDC_LISTSTARTUP                 251
#define IDS_EXPANDEMPTYFIELD            251
#define IDC_BUTTONSERVENABLEALL         252
#define IDS_NOBADBOOTLINES              252
#define IDC_BUTTONSERVDISABLEALL        253
#define IDS_BADBOOTLINE                 253
#define IDC_CHECKHIDEMS                 254
#define IDS_SERVICEACCESSDENIED         254
#define IDC_CHECKDISABLENONESSENTIAL    255
#define IDS_SERVICEOTHERERROR           255
#define IDC_LISTSERVICES                256
#define IDS_COMMITMESSAGE               256
#define IDC_LISTBOXREGISTRY             257
#define IDS_EXPANDBADFILE               257
#define IDC_BUTTONRUNREGCLEAN           258
#define IDS_EXPANDSOURCEDOESNTEXIST     258
#define IDC_BUTTONCHECKREGISTRY         259
#define IDS_EXPANDDESTDOESNTEXIST       259
#define IDS_VERIFYRESTORE               260
#define IDC_EDITCODEPAGE                262
#define IDC_EDITCOUNTRYCODE             263
#define IDC_EDITCOUNTRYDATAFILE         264
#define IDC_EDITKEYBOARDDATAFILE        265
#define IDC_EDITKEYBOARDTYPE            266
#define IDC_EDITKEYBOARDLAYOUT          267
#define IDC_EDITLANGUAGEID              268
#define IDC_COMBOLANGUAGES              269
#define IDC_STATICWONTRUN               270
#define IDC_EDITDISPLAYDATAFILE         270
#define IDC_BUTTONUNDOSELECTED          271
#define IDC_BUTTONUNDOALL               272
#define IDC_LISTCHANGES                 273
#define IDC_SEARCHFOR                   274
#define IDC_CHECK1                      275
#define IDC_BIAMAXMEM                   276
#define IDC_BIANUMPROC                  277
#define IDC_BIAPCILOCK                  278
#define IDC_BIADEBUG                    279
#define IDC_BIADEBUGPORT                280
#define IDC_BIABAUDRATE                 281
#define IDC_SPIN1                       282
#define IDC_SPINMAXMEM                  282
#define IDC_COMBOPROCS                  283
#define IDC_COMBOCOMPORT                284
#define IDC_EDITMAXMEM                  285
#define IDC_SPIN2                       286
#define IDC_SPINBAUDRATE                286
#define IDC_BIACHANNEL                  286
#define IDC_EDITMAXMEM2                 287
#define IDC_EDITBAUDRATE                287
#define IDC_EDITCHANNEL                 287
#define IDC_COMBOBAUD                   288
#define IDC_SPINCHANNEL                 289
#define IDC_EDIT1                       1000
#define IDC_EDITFILE                    1000
#define IDC_RUNMSCONFIG                 1001
#define IDC_CHECKDONTSHOW               1002
#define IDC_AUTOSTARTTEXT1              1003
#define IDC_AUTOSTARTTEXT2              1004
#define IDC_BUTTON1                     1005
#define IDC_EXPANDBROWSEFILE            1005
#define IDC_AUTOSTARTTEXT3              1005
#define IDC_COMBOFROM                   1006
#define IDC_EXPANDBROWSEFROM            1007
#define IDC_COMBOTO                     1008
#define IDC_EXPANDBROWSETO              1009
#define IDC_RADIOORIGINAL               1010
#define IDC_RADIOMODIFIED               1011
#define IDC_RESTORELIST                 1012
#define IDS_NOPERMISSIONS               1013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        215
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\undolog.h ===
//=============================================================================
// The CUndoLog is used to implement a log of undo entries to allow MSConfig
// to reverse any changes it may have made. Each tab object is responsible for
// writing a string when it makes changes - this string can be used to undo
// the changes the tab made.
//
// The undo log file will look like this:
//
//		["timestamp" tabname "description" <SHOW|FINAL>]
//		tab specific string - any line starting with a "[" will have a
//		backslash preceding it
//
// The entries will be arranged in chronological order (most recent first).
// The "description" field will be the only one shown to the user - so it
// will be the only one which needs to be localized. The tab is responsible
// for supplying this text.
//=============================================================================

#pragma once

#include "pagebase.h"

//-----------------------------------------------------------------------------
// This class encapsulates an undo entry (instance of this class will be
// saved in a list).
//-----------------------------------------------------------------------------

class CUndoLogEntry
{
public:
	enum UndoEntryState { SHOW, FINAL, UNDONE };

	CUndoLogEntry() : m_state(SHOW) {};

	CUndoLogEntry(const CString & strTab, const CString & strDescription, const CString & strEntry, const COleDateTime & timestamp) 
		: m_strTab(strTab),
		  m_strDescription(strDescription),
		  m_strEntry(strEntry),
		  m_timestamp(timestamp),
		  m_state(SHOW)
	{};

	CUndoLogEntry(const CString & strTab, const CString & strDescription, const CString & strEntry) 
		: m_strTab(strTab),
		  m_strDescription(strDescription),
		  m_strEntry(strEntry),
		  m_timestamp(COleDateTime::GetCurrentTime()),
		  m_state(SHOW)
	{};

private:
	CUndoLogEntry(const CString & strTab, const CString & strDescription, const CString & strEntry, const COleDateTime & timestamp, UndoEntryState state) 
		: m_strTab(strTab),
		  m_strDescription(strDescription),
		  m_strEntry(strEntry),
		  m_timestamp(timestamp),
		  m_state(state)
	{};

public:
	static CUndoLogEntry * ReadFromFile(CStdioFile & infile)
	{
		CString			strTab, strDescription, strEntry;
		UndoEntryState	state;
		COleDateTime	timestamp;

		CString strLine;
		if (!infile.ReadString(strLine))
			return NULL;

		strLine.TrimLeft(_T("[\""));
		CString strTimestamp = strLine.SpanExcluding(_T("\""));
		strLine = strLine.Mid(strTimestamp.GetLength());
		timestamp.ParseDateTime(strTimestamp);

		strLine.TrimLeft(_T(" \""));
		strTab = strLine.SpanExcluding(_T(" "));
		strLine = strLine.Mid(strTab.GetLength());

		strLine.TrimLeft(_T(" \""));
		strDescription = strLine.SpanExcluding(_T("\""));
		strLine = strLine.Mid(strDescription.GetLength());

		strLine.TrimLeft(_T(" \""));
		CString strFinal = strLine.SpanExcluding(_T("]"));
		if (strFinal.CompareNoCase(_T("final")) == 0)
			state = FINAL;
		else if (strFinal.CompareNoCase(_T("show")) == 0)
			state = SHOW;
		else
			state = UNDONE;
		
		strLine.Empty();
		for (;;)
		{
			if (!infile.ReadString(strLine))
				break;

			if (strLine.IsEmpty())
				continue;

			if (strLine[0] == _T('['))
			{
				// We read the first line of the next entry. Back up in the file (including the
				// newline and CR characters).

				infile.Seek(-1 * (strLine.GetLength() + 2) * sizeof(TCHAR), CFile::current);
				break;
			}

			if (strLine[0] == _T('\\'))
				strLine = strLine.Mid(1);

			strEntry += strLine + _T("\n");
		}

		return new CUndoLogEntry(strTab, strDescription, strEntry, timestamp, state);
	}

	BOOL WriteToFile(CStdioFile & outfile)
	{
		ASSERT(!m_strTab.IsEmpty());

		CString strLine;
		strLine = _T("[\"") + m_timestamp.Format() + _T("\" ");
		strLine += m_strTab + _T(" \"");
		strLine += m_strDescription + _T("\" ");

		switch (m_state)
		{
		case FINAL:
			strLine += _T("FINAL");
			break;
		case UNDONE:
			strLine += _T("UNDONE");
			break;
		case SHOW:
		default:
			strLine += _T("SHOW");
			break;
		}

		strLine += _T("]\n");
		outfile.WriteString(strLine);	// TBD - catch the exception

		CString strWorking(m_strEntry);
		while (!strWorking.IsEmpty())
		{
			strLine = strWorking.SpanExcluding(_T("\n\r"));
			strWorking = strWorking.Mid(strLine.GetLength());
			strWorking.TrimLeft(_T("\n\r"));

			if (!strLine.IsEmpty() && strLine[0] == _T('['))
				strLine = _T("\\") + strLine;
			strLine += _T("\n");
			
			outfile.WriteString(strLine);
		}

		return TRUE;
	}

	~CUndoLogEntry() {};

	CString			m_strTab;
	CString			m_strDescription;
	CString			m_strEntry;
	COleDateTime	m_timestamp;
	UndoEntryState	m_state;
};

//-----------------------------------------------------------------------------
// This class implements the undo log.
//-----------------------------------------------------------------------------

class CUndoLog
{
public:
	CUndoLog() : m_fChanges(FALSE), m_pmapTabs(NULL)
	{
	}

	~CUndoLog()
	{
		while (!m_entrylist.IsEmpty())
		{
			CUndoLogEntry * pEntry = (CUndoLogEntry *)m_entrylist.RemoveHead();
			if (pEntry)
				delete pEntry;
		}
	};

	//-------------------------------------------------------------------------
	// These functions will load the undo log from a file, or save to a file.
	// Note - saving to a file will overwrite the contents of the file with
	// the contents of the undo log.
	//-------------------------------------------------------------------------

	BOOL LoadFromFile(LPCTSTR szFilename)
	{
		ASSERT(szFilename);
		if (szFilename == NULL)
			return FALSE;

		CStdioFile logfile;
		if (logfile.Open(szFilename, CFile::modeRead | CFile::typeText))
		{
			CUndoLogEntry * pEntry;

			while (pEntry = CUndoLogEntry::ReadFromFile(logfile))
				m_entrylist.AddTail((void *) pEntry);

			logfile.Close();
			return TRUE;
		}

		return FALSE;
	}
	
	BOOL SaveToFile(LPCTSTR szFilename)
	{
		ASSERT(szFilename);
		if (szFilename == NULL)
			return FALSE;

		if (!m_fChanges)
			return TRUE;

		CStdioFile logfile;
		if (logfile.Open(szFilename, CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive | CFile::typeText))
		{
			for (POSITION pos = m_entrylist.GetHeadPosition(); pos != NULL;)
			{
				CUndoLogEntry * pEntry = (CUndoLogEntry *)m_entrylist.GetNext(pos);
				if (pEntry != NULL)
					pEntry->WriteToFile(logfile);
			}

			logfile.Close();
			return TRUE;
		}

		return FALSE;
	}

	//-------------------------------------------------------------------------
	// How many undo entries are in this log?
	//-------------------------------------------------------------------------

	int GetUndoEntryCount() 
	{
		int iCount = 0;

		for (POSITION pos = m_entrylist.GetHeadPosition(); pos != NULL;)
		{
			CUndoLogEntry * pEntry = (CUndoLogEntry *)m_entrylist.GetNext(pos);
			if (pEntry != NULL && pEntry->m_state == CUndoLogEntry::SHOW)
				iCount += 1;
		}

		return iCount;
	}

	//-------------------------------------------------------------------------
	// Get information about a specific entry (returns FALSE for bad index).
	//-------------------------------------------------------------------------

	BOOL GetUndoEntryInfo(int iIndex, CString & strDescription, COleDateTime & timestamp)
	{
		CUndoLogEntry * pEntry = GetEntryByIndex(iIndex);
		if (pEntry != NULL)
		{
			strDescription = pEntry->m_strDescription;
			timestamp = pEntry->m_timestamp;
			return TRUE;
		}

		return FALSE;
	}

	//-------------------------------------------------------------------------
	// Get the entry data (to pass to a tab to undo). FALSE for bad index.
	//-------------------------------------------------------------------------

	BOOL GetUndoEntry(int iIndex, CString * pstrTab, CString * pstrEntry)
	{
		CUndoLogEntry * pEntry = GetEntryByIndex(iIndex);
		if (pEntry != NULL)
		{
			if (pstrTab) *pstrTab = pEntry->m_strTab;
			if (pstrEntry) *pstrEntry = pEntry->m_strEntry;
			return TRUE;
		}

		return FALSE;
	}

	//-------------------------------------------------------------------------
	// Mark an entry as final (stays in the file, but marked so it won't
	// appear in the undo log). FALSE for bad index.
	//-------------------------------------------------------------------------

	BOOL MarkUndoEntryFinal(int iIndex)
	{
		CUndoLogEntry * pEntry = GetEntryByIndex(iIndex);
		if (pEntry != NULL)
		{
			pEntry->m_state = CUndoLogEntry::FINAL;
			m_fChanges = TRUE;
			return TRUE;
		}

		return FALSE;
	}

	//-------------------------------------------------------------------------
	// Delete all entries in the log that are older than 
	// timestampOlderThanThis. The entries will be gone, purged from the file.
	//-------------------------------------------------------------------------
	
	BOOL DeleteOldUndoEntries(const COleDateTime & timestampOlderThanThis)
	{
		m_fChanges = TRUE;
		return FALSE;
	}

	//-------------------------------------------------------------------------
	// Create a new undo entry, using the current time, and add it to the
	// end of the undo log. Shouldn't return FALSE unless there is no memory.
	//-------------------------------------------------------------------------

	BOOL AddUndoEntry(const CString & strTab, const CString & strDescription, const CString & strEntry)
	{
		CUndoLogEntry * pEntry = new CUndoLogEntry(strTab, strDescription, strEntry);
		if (pEntry == NULL)
			return FALSE;

		m_entrylist.AddHead((void *)pEntry);
		m_fChanges = TRUE;
		return TRUE;
	}

	//-------------------------------------------------------------------------
	// Called to undo the effects of one of the entries. This function will
	// need to find the appropriate tab and call its undo function.
	//-------------------------------------------------------------------------

	BOOL UndoEntry(int iIndex)
	{
		CUndoLogEntry * pEntry = GetEntryByIndex(iIndex);
		if (!pEntry)
			return FALSE;

		if (pEntry->m_state != CUndoLogEntry::SHOW)
			return FALSE;

		if (!m_pmapTabs)
			return FALSE;

		CPageBase * pPage;
		if (!m_pmapTabs->Lookup(pEntry->m_strTab, (void * &)pPage) || !pPage)
			return FALSE;

//		if (!pPage->Undo(pEntry->m_strEntry))
//			return FALSE;

		pEntry->m_state = CUndoLogEntry::UNDONE;
		m_fChanges = TRUE;
		return TRUE;
	}

	//-------------------------------------------------------------------------
	// Sets a pointer to the map from tab name to pointer.
	//-------------------------------------------------------------------------

	void SetTabMap(CMapStringToPtr * pmap)
	{	
		m_pmapTabs = pmap;
	}

private:
	CUndoLogEntry * GetEntryByIndex(int iIndex)
	{
		CUndoLogEntry * pEntry = NULL;
		POSITION		pos = m_entrylist.GetHeadPosition();

		do
		{
			if (pos == NULL)
				return NULL;

			pEntry = (CUndoLogEntry *)m_entrylist.GetNext(pos);
			if (pEntry != NULL && pEntry->m_state == CUndoLogEntry::SHOW)
				iIndex -= 1;
		} while (iIndex >= 0);

		return pEntry;
	}

private:
	//-------------------------------------------------------------------------
	// Member variables.
	//-------------------------------------------------------------------------

	CMapStringToPtr *	m_pmapTabs;		// map from tab name to CPageBase pointers
	CPtrList			m_entrylist;	// list of CUndoLogEntry pointers
	BOOL				m_fChanges;		// was the log changed?
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\undodialog.h ===
// UndoDialog.h : Declaration of the CUndoDialog

#ifndef __UNDODIALOG_H_
#define __UNDODIALOG_H_

#include "resource.h"       // main symbols
#include <atlhost.h>
#include "undolog.h"

#ifndef ListView_SetCheckState
   #define ListView_SetCheckState(hwndLV, i, fCheck) \
      ListView_SetItemState(hwndLV, i, \
      INDEXTOSTATEIMAGEMASK((fCheck)+1), LVIS_STATEIMAGEMASK)
#endif

/////////////////////////////////////////////////////////////////////////////
// CUndoDialog
class CUndoDialog : 
	public CAxDialogImpl<CUndoDialog>
{
public:
	CUndoDialog(CUndoLog * pUndoLog, BOOL fFromUserClick = TRUE)
	{
		ASSERT(pUndoLog);
		m_pUndoLog = pUndoLog;
		m_fFromUserClick = fFromUserClick;
	}

	~CUndoDialog()
	{
	}

	enum { IDD = IDD_UNDODIALOG };

BEGIN_MSG_MAP(CUndoDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_HANDLER(IDC_CLOSE, BN_CLICKED, OnClickedClose)
	NOTIFY_HANDLER(IDC_LISTCHANGES, LVN_ITEMCHANGED, OnItemChangedListChanges)
	COMMAND_HANDLER(IDC_BUTTONUNDOALL, BN_CLICKED, OnClickedButtonUndoAll)
	COMMAND_HANDLER(IDC_BUTTONUNDOSELECTED, BN_CLICKED, OnClickedButtonUndoSelected)
	COMMAND_HANDLER(IDC_RUNMSCONFIG, BN_CLICKED, OnClickedRunMSConfig)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		m_list.Attach(GetDlgItem(IDC_LISTCHANGES));
		ListView_SetExtendedListViewStyle(m_list.m_hWnd, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

		// If this is launched by the user clicking on the button, hide the "Run MSConfig"
		// button and resize the dialog.

		if (m_fFromUserClick)
		{
			CWindow wndRun;
			RECT	rectRun, rectWindow;

			wndRun.Attach(GetDlgItem(IDC_RUNMSCONFIG));
			wndRun.ShowWindow(SW_HIDE);
			wndRun.GetWindowRect(&rectRun);
			GetWindowRect(&rectWindow);
			rectWindow.bottom -= (rectWindow.bottom - rectRun.top);
			MoveWindow(&rectWindow);
		}

		// Insert the columns.

		CRect rect;
		m_list.GetClientRect(&rect);
		int cxWidth = rect.Width();

		LVCOLUMN lvc;
		lvc.mask = LVCF_TEXT | LVCF_WIDTH;

		::AfxSetResourceHandle(_Module.GetResourceInstance());
		CString strColumn;
		strColumn.LoadString(IDS_DATECAPTION);
		lvc.pszText = (LPTSTR)(LPCTSTR)strColumn;
		lvc.cx = 4 * cxWidth / 10;
		ListView_InsertColumn(m_list.m_hWnd, 0, &lvc);

		strColumn.LoadString(IDS_CHANGECAPTION);
		lvc.pszText = (LPTSTR)(LPCTSTR)strColumn;
		lvc.cx = 6 * cxWidth / 10;
		ListView_InsertColumn(m_list.m_hWnd, 1, &lvc);

		FillChangeList();

		CenterWindow();

		return 1;  // Let the system set the focus
	}

	//-------------------------------------------------------------------------
	// When one of the items in the list view changes, we need to check the
	// state of the check boxes. In particular, if there are any boxes checked,
	// we need to enable to Undo Selected button. Also, we can't allow any
	// boxes items to be checked unless all of the more recent items for the
	// tab are also checked.
	//-------------------------------------------------------------------------

	LRESULT OnItemChangedListChanges(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		LPNMLISTVIEW pnmv = (LPNMLISTVIEW) pnmh;
		if (!pnmv)
			return 0;

		CString strTab, strCheckTab;
		m_pUndoLog->GetUndoEntry(pnmv->iItem, &strTab, NULL);

		BOOL fChecked = ListView_GetCheckState(m_list.m_hWnd, pnmv->iItem);
		if (fChecked)
		{
			// Make sure all previous entries in the list with the same
			// tab name are also checked.

			for (int i = pnmv->iItem - 1; i >= 0; i--)
				if (m_pUndoLog->GetUndoEntry(i, &strCheckTab, NULL) && strTab.Compare(strCheckTab) == 0)
					ListView_SetCheckState(m_list.m_hWnd, i, TRUE);
		}
		else
		{
			// Make sure all later entries in the list with the same tab
			// name are unchecked.

			int iCount = ListView_GetItemCount(m_list.m_hWnd);
			for (int i = pnmv->iItem + 1; i < iCount; i++)
				if (m_pUndoLog->GetUndoEntry(i, &strCheckTab, NULL) && strTab.Compare(strCheckTab) == 0)
					ListView_SetCheckState(m_list.m_hWnd, i, FALSE);
		}

		for (int i = ListView_GetItemCount(m_list.m_hWnd) - 1; i >= 0; i--)
			if (ListView_GetCheckState(m_list.m_hWnd, i))
			{
				::EnableWindow(GetDlgItem(IDC_BUTTONUNDOSELECTED), TRUE);
				return 0;
			}

		::EnableWindow(GetDlgItem(IDC_BUTTONUNDOSELECTED), FALSE);
		return 0;
	}

	LRESULT OnClickedClose(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		EndDialog(wID);
		return 0;
	}

	void FillChangeList()
	{
		ListView_DeleteAllItems(m_list.m_hWnd);

		ASSERT(m_pUndoLog);
		if (!m_pUndoLog)
			return;

		LVITEM lvi;
		lvi.mask = LVIF_TEXT;

		int nEntries = m_pUndoLog->GetUndoEntryCount();
		for (int i = 0; i < nEntries; i++)
		{
			COleDateTime	timestamp;
			CString			strDescription, strTimestamp;

			if (m_pUndoLog->GetUndoEntryInfo(i, strDescription, timestamp))
			{
				strTimestamp = timestamp.Format();
				lvi.pszText = (LPTSTR)(LPCTSTR)strTimestamp;
				lvi.iSubItem = 0;
				lvi.iItem = i;
				ListView_InsertItem(m_list.m_hWnd, &lvi);

				lvi.pszText = (LPTSTR)(LPCTSTR)strDescription;
				lvi.iSubItem = 1;
				ListView_SetItem(m_list.m_hWnd, &lvi);
			}
		}

		::EnableWindow(GetDlgItem(IDC_BUTTONUNDOALL), (nEntries != 0));
		if (nEntries == 0)
			::EnableWindow(GetDlgItem(IDC_BUTTONUNDOSELECTED), FALSE);
	}

	//-------------------------------------------------------------------------
	// When the user chooses to undo selected items or all items, we need
	// to locate the tab page for each change and call its undo function.
	//-------------------------------------------------------------------------
	
	LRESULT OnClickedButtonUndoAll(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		DoUndo(TRUE);
		return 0;
	}

	LRESULT OnClickedButtonUndoSelected(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		DoUndo(FALSE);
		return 0;
	}

	void DoUndo(BOOL fAll)
	{
		CString strTab, strEntry;
		int		iUndoIndex = 0, iCount = ListView_GetItemCount(m_list.m_hWnd);

		// Have to do something a little screwy here. Since the index into the
		// undo log is based on the number of changes into the log (not counting
		// undone entries), we need to keep track of the index into the undo log.
		// This undo index will not be incremented when we undo an entry (undoing
		// it makes it invisible, so the same index will then point to the next
		// undo entry).

		for (int i = 0; i < iCount; i++)
			if (fAll || ListView_GetCheckState(m_list.m_hWnd, i))
				m_pUndoLog->UndoEntry(iUndoIndex);
			else
				iUndoIndex += 1;

		FillChangeList();
	}

	HRESULT ShowDialog()
	{
		return ((DoModal() == IDC_RUNMSCONFIG) ? S_FALSE : S_OK);
	}

	LRESULT OnClickedRunMSConfig(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		EndDialog(IDC_RUNMSCONFIG);
		return 0;
	}

private:
	CWindow		m_list;
	CUndoLog *	m_pUndoLog;
	BOOL		m_fFromUserClick;
};

#endif //__UNDODIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\eventwrapper\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\admin\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Include file for standard system include files or project specific include
    files that are used frequently, but are changed infrequently

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Insert your headers here
//#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <atlbase.h>

// TODO: reference additional headers your program requires here


#include <stdio.h>
#include <stdlib.h>

#include <httpext.h>

extern CComModule _Module;

#include <UploadLibrary.h>

#include <UploadLibraryTrace.h>
#include <UploadLibraryISAPI.h>

#include <MPC_Utils.h>

#include <initguid.h>
#include <mstask.h>         // for task scheduler apis
#include <msterr.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\eventwrapper\eventwrapper.cpp ===
// EventWrapper.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f EventWrapperps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "EventWrapper.h"

#include "EventWrapper_i.c"
#include "UploadManager_i.c"
#include "UploadEventsWrapper.h"
#include "UploadManager.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_UploadEventsWrapper, CUploadEventsWrapper)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_EVENTWRAPPERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\sysinfo\msconfig\exe\version.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	version.CPP

Abstract:
	Implementation of class to provide version information about
    a file using functions pulled from the Dr. Watson source.

Revision History:

    Jim Martin          (a-jammar) 05/22/99
        - Created.

********************************************************************/

#include "stdafx.h"
#include <winver.h>
#include "mscfgver.h"

typedef CFileVersionInfo::VERSIONSTATE * PVERSIONSTATE;
typedef CFileVersionInfo::FILEVERSION * PFILEVERSION;

BOOL _GetVersionString(PVERSIONSTATE pvs, LPCTSTR ptszKey, LPTSTR ptszBuf);
BOOL __GetVersionString(PVOID pvData, LPCTSTR ptszLang, LPCTSTR ptszKey, LPTSTR ptszBuf);
void GetFileVersion(LPTSTR ptszFile, CFileVersionInfo::FILEVERSION * pfv);

#define pvSubPvCb(pv, cb) ((PVOID)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PVOID)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))
#define cbX(X) sizeof(X)
#define cA(a) (cbX(a)/cbX(a[0]))

TCHAR c_szStringFileInfo[] = _T("StringFileInfo");

//-----------------------------------------------------------------------------
// The constructor and destructor don't have too much to do.
//-----------------------------------------------------------------------------

CFileVersionInfo::CFileVersionInfo() : m_pfv(NULL)
{
}

CFileVersionInfo::~CFileVersionInfo()
{
    delete m_pfv;
}

//-----------------------------------------------------------------------------
// The Get functions are also really simple.
//-----------------------------------------------------------------------------

LPCTSTR CFileVersionInfo::GetVersion()
{
    return (m_pfv) ? (m_pfv->tszFileVersion) : NULL;
}

LPCTSTR CFileVersionInfo::GetDescription()
{
    return (m_pfv) ? (m_pfv->tszDesc) : NULL;
}

LPCTSTR CFileVersionInfo::GetCompany()
{
    return (m_pfv) ? (m_pfv->tszCompany) : NULL;
}

LPCTSTR CFileVersionInfo::GetProduct()
{
    return (m_pfv) ? (m_pfv->tszProduct) : NULL;
}

//-----------------------------------------------------------------------------
// QueryFile get information about the requested file. If necessary, it will
// convert a path with double backslashes to single backslashes before calling
// the helper function GetFileVersion from Dr. Watson code.
//-----------------------------------------------------------------------------

HRESULT CFileVersionInfo::QueryFile(LPCSTR szFile, BOOL fHasDoubleBackslashes)
{
    HRESULT hRes = S_OK;
    LPTSTR  szWorking = NULL;
    
    if (!m_pfv)
        m_pfv = new FILEVERSION;

    if (!m_pfv)
    {
        hRes = E_OUTOFMEMORY;
        goto END;
    }

    if (fHasDoubleBackslashes)
    {
        szWorking = new TCHAR[strlen(szFile)];
        if (!szWorking)
        {
            hRes = E_OUTOFMEMORY;
            goto END;
        }

        // Scan through the passed string, converting double backslashes to single
        // backslashes.

        int i = 0, j = 0;
        while (szFile[i])
        {
            if (szFile[i] == '\\' && szFile[i + 1] == '\\')
                i += 1;
            szWorking[j++] = (TCHAR)szFile[i++];
        }
        szWorking[j] = _T('\0');
    }
	else
	{
		USES_CONVERSION;
	    szWorking = A2T(szFile);
	}

    if (szWorking != NULL)
	{
		GetFileVersion(szWorking, m_pfv);

		if (fHasDoubleBackslashes)
			delete [] szWorking;
	}

END:
    return hRes;
}

//-----------------------------------------------------------------------------
// An alternate version of the previous function which takes a UNICODE string.
//-----------------------------------------------------------------------------

HRESULT CFileVersionInfo::QueryFile(LPCWSTR szFile, BOOL fHasDoubleBackslashes)
{
    // Convert the string from UNICODE to ANSI.

    USES_CONVERSION;
    LPSTR szConvertedFile = W2A(szFile); 

    HRESULT hRes = E_FAIL;
	if (szConvertedFile)
		hRes = this->QueryFile(szConvertedFile, fHasDoubleBackslashes);
    return hRes;
}


//-----------------------------------------------------------------------------
// Gets the version information for the file ptszFile, and fillsin the pfv
// FILEVERSION structure.
//-----------------------------------------------------------------------------

void GetFileVersion(LPTSTR ptszFile, CFileVersionInfo::FILEVERSION * pfv)
{
    // Open the file and suck out the description.

    DWORD cbScratch, cbRc;

    memset(pfv, 0, sizeof(CFileVersionInfo::FILEVERSION));

    cbRc = GetFileVersionInfoSize(ptszFile, &cbScratch);
    if (cbRc) 
    {
        CFileVersionInfo::VERSIONSTATE vs;
        memset(&vs, 0, sizeof(CFileVersionInfo::VERSIONSTATE));

        vs.pvData = new unsigned char[cbRc]; // BUGBUG
        if (vs.pvData) 
        {
            if (GetFileVersionInfo(ptszFile, cbScratch, cbRc, vs.pvData)) 
            {
                UINT    uiRc;
                LPDWORD pdwLang;

                if (VerQueryValue(vs.pvData, TEXT("VarFileInfo\\Translation"), (PVOID *) &pdwLang, &uiRc) && uiRc >= 4)
                {
                    wsprintf(vs.tszLang, TEXT("%04x%04x"), LOWORD(*pdwLang), HIWORD(*pdwLang));

                    if (cbRc > 0x70 && ((LPBYTE)pvAddPvCb(vs.pvData, 0x4C))[14] == 0 &&
                        lstrcmpi(c_szStringFileInfo, (LPCTSTR) pvAddPvCb(vs.pvData, 0x4C)) == 0)
                    {
                        lstrcpyn(vs.tszLang2, (LPCTSTR) pvAddPvCb(vs.pvData, 0x60), cA(vs.tszLang2));
                    } 
                    else 
                    {
                        vs.tszLang2[0] = 0;
                    }
                }

                if (vs.tszLang[0] == 0)
                {
#ifdef UNICODE
                    // Try English Unicode

                    lstrcpy(vs.tszLang, TEXT("040904B0"));
                    if (!_GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion))
                    {
#endif
                    // Try English

                    lstrcpy(vs.tszLang, TEXT("040904E4"));
                    if (!_GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion))
                    {
                        // Try English null codepage

                        lstrcpy(vs.tszLang, TEXT("04090000"));
                        if (!_GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion))
                            goto LNoVersion;
                    }
#ifdef UNICODE
                    }
#endif
                }
                else
                    _GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion);

                _GetVersionString(&vs, TEXT("FileDescription"), pfv->tszDesc);
                _GetVersionString(&vs, TEXT("CompanyName"), pfv->tszCompany);
                _GetVersionString(&vs, TEXT("ProductName"), pfv->tszProduct);
            }

LNoVersion:
            delete [] vs.pvData;
        }
    }
}

//-----------------------------------------------------------------------------
// Using the version state, retrieve the version string specified by ptszKey
// and put it in the ptszBuf. This just calls another internal function, trying
// both possible languages.
//-----------------------------------------------------------------------------

BOOL _GetVersionString(PVERSIONSTATE pvs, LPCTSTR ptszKey, LPTSTR ptszBuf)
{
    BOOL fRc;

    fRc = __GetVersionString(pvs->pvData, pvs->tszLang, ptszKey, ptszBuf);

    if (!fRc)
        fRc = __GetVersionString(pvs->pvData, pvs->tszLang2, ptszKey, ptszBuf);

    return fRc;
}

//-----------------------------------------------------------------------------
// An internal function to try to get the data specified by the ptszKey, using
// the ptszLang language and codepage.
//-----------------------------------------------------------------------------

BOOL __GetVersionString(PVOID pvData, LPCTSTR ptszLang, LPCTSTR ptszKey, LPTSTR ptszBuf)
{
    TCHAR   tszBuf[128];
    LPCTSTR ptszResult;
    UINT    uiRc;
    BOOL    fRc;

	// Replacing this unbounded string copy:
	//
	//    wsprintf(tszBuf, TEXT("\\%s\\%s\\%s"), c_szStringFileInfo, ptszLang, ptszKey);

	CString strBuf;
	strBuf.Format(TEXT("\\%s\\%s\\%s"), c_szStringFileInfo, ptszLang, ptszKey);
	lstrcpyn(tszBuf, (LPCTSTR)strBuf, sizeof(tszBuf) / sizeof(TCHAR));

    if (VerQueryValue(pvData, tszBuf, (PVOID *)&ptszResult, &uiRc))
        fRc = (lstrcpyn(ptszBuf, ptszResult, MAX_PATH) != NULL);
    else
        fRc = FALSE;

    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\eventwrapper\eventwrappercp.h ===
#ifndef _EVENTWRAPPERCP_H_
#define _EVENTWRAPPERCP_H_

template <class T>
class CProxy_IUploadEventsWrapperEvents : public IConnectionPointImpl<T, &DIID__IUploadEventsWrapperEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_onStatusChange(IMPCUploadJob * mpcujJob, tagUL_STATUS Status)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = mpcujJob;
				pvars[0] = Status;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_onProgressChange(IMPCUploadJob * mpcujJob, LONG lCurrentSize, LONG lTotalSize)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[2] = mpcujJob;
				pvars[1] = lCurrentSize;
				pvars[0] = lTotalSize;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\eventwrapper\eventwrapper.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue May 04 19:57:16 1999
 */
/* Compiler settings for S:\slm_pchealth\src\Upload\Client\EventWrapper\EventWrapper.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __EventWrapper_h__
#define __EventWrapper_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IUploadEventsWrapper_FWD_DEFINED__
#define __IUploadEventsWrapper_FWD_DEFINED__
typedef interface IUploadEventsWrapper IUploadEventsWrapper;
#endif 	/* __IUploadEventsWrapper_FWD_DEFINED__ */


#ifndef ___IUploadEventsWrapperEvents_FWD_DEFINED__
#define ___IUploadEventsWrapperEvents_FWD_DEFINED__
typedef interface _IUploadEventsWrapperEvents _IUploadEventsWrapperEvents;
#endif 	/* ___IUploadEventsWrapperEvents_FWD_DEFINED__ */


#ifndef __UploadEventsWrapper_FWD_DEFINED__
#define __UploadEventsWrapper_FWD_DEFINED__

#ifdef __cplusplus
typedef class UploadEventsWrapper UploadEventsWrapper;
#else
typedef struct UploadEventsWrapper UploadEventsWrapper;
#endif /* __cplusplus */

#endif 	/* __UploadEventsWrapper_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "UploadManager.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IUploadEventsWrapper_INTERFACE_DEFINED__
#define __IUploadEventsWrapper_INTERFACE_DEFINED__

/* interface IUploadEventsWrapper */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUploadEventsWrapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F341B81-0286-11D3-9397-00C04F72DAF7")
    IUploadEventsWrapper : public IMPCUploadEvents
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ IMPCUploadJob __RPC_FAR *mpcujJob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUploadEventsWrapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUploadEventsWrapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUploadEventsWrapper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUploadEventsWrapper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IUploadEventsWrapper __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IUploadEventsWrapper __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IUploadEventsWrapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IUploadEventsWrapper __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onStatusChange )( 
            IUploadEventsWrapper __RPC_FAR * This,
            /* [in] */ IMPCUploadJob __RPC_FAR *mpcujJob,
            /* [in] */ UL_STATUS status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onProgressChange )( 
            IUploadEventsWrapper __RPC_FAR * This,
            /* [in] */ IMPCUploadJob __RPC_FAR *mpcujJob,
            /* [in] */ long lCurrentSize,
            /* [in] */ long lTotalSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Register )( 
            IUploadEventsWrapper __RPC_FAR * This,
            /* [in] */ IMPCUploadJob __RPC_FAR *mpcujJob);
        
        END_INTERFACE
    } IUploadEventsWrapperVtbl;

    interface IUploadEventsWrapper
    {
        CONST_VTBL struct IUploadEventsWrapperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUploadEventsWrapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUploadEventsWrapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUploadEventsWrapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUploadEventsWrapper_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IUploadEventsWrapper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IUploadEventsWrapper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IUploadEventsWrapper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IUploadEventsWrapper_onStatusChange(This,mpcujJob,status)	\
    (This)->lpVtbl -> onStatusChange(This,mpcujJob,status)

#define IUploadEventsWrapper_onProgressChange(This,mpcujJob,lCurrentSize,lTotalSize)	\
    (This)->lpVtbl -> onProgressChange(This,mpcujJob,lCurrentSize,lTotalSize)


#define IUploadEventsWrapper_Register(This,mpcujJob)	\
    (This)->lpVtbl -> Register(This,mpcujJob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUploadEventsWrapper_Register_Proxy( 
    IUploadEventsWrapper __RPC_FAR * This,
    /* [in] */ IMPCUploadJob __RPC_FAR *mpcujJob);


void __RPC_STUB IUploadEventsWrapper_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUploadEventsWrapper_INTERFACE_DEFINED__ */



#ifndef __EVENTWRAPPERLib_LIBRARY_DEFINED__
#define __EVENTWRAPPERLib_LIBRARY_DEFINED__

/* library EVENTWRAPPERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_EVENTWRAPPERLib;

#ifndef ___IUploadEventsWrapperEvents_DISPINTERFACE_DEFINED__
#define ___IUploadEventsWrapperEvents_DISPINTERFACE_DEFINED__

/* dispinterface _IUploadEventsWrapperEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__IUploadEventsWrapperEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("5F341B83-0286-11D3-9397-00C04F72DAF7")
    _IUploadEventsWrapperEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IUploadEventsWrapperEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IUploadEventsWrapperEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IUploadEventsWrapperEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IUploadEventsWrapperEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _IUploadEventsWrapperEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _IUploadEventsWrapperEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _IUploadEventsWrapperEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _IUploadEventsWrapperEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _IUploadEventsWrapperEventsVtbl;

    interface _IUploadEventsWrapperEvents
    {
        CONST_VTBL struct _IUploadEventsWrapperEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IUploadEventsWrapperEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IUploadEventsWrapperEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IUploadEventsWrapperEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IUploadEventsWrapperEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _IUploadEventsWrapperEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _IUploadEventsWrapperEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _IUploadEventsWrapperEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IUploadEventsWrapperEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_UploadEventsWrapper;

#ifdef __cplusplus

class DECLSPEC_UUID("5F341B82-0286-11D3-9397-00C04F72DAF7")
UploadEventsWrapper;
#endif
#endif /* __EVENTWRAPPERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\test\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\admin\main.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the configuration tool for the server-side of Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  06/30/99
        created

******************************************************************************/

#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////

const WCHAR c_szISAPI_FileName   [] = L"\\UploadServer.dll";

const WCHAR c_szRegistryLog      [] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\UploadServer";
const WCHAR c_szRegistryLog_File [] = L"EventMessageFile";
const WCHAR c_szRegistryLog_Flags[] = L"TypesSupported";

const WCHAR c_szRegistryBase     [] = L"SOFTWARE\\Microsoft\\UploadLibrary\\Settings";
const WCHAR c_szRegistryBase2    [] = L"SOFTWARE\\Microsoft\\UploadLibrary";

const WCHAR c_szEscURL           [] = L"/pchealth/uploadserver.dll";
const WCHAR c_szEscTemp          [] = L"c:\\temp\\pchealth\\queue1";
const WCHAR c_szEscDest          [] = L"c:\\dpe\\xml";

const WCHAR c_szNonEscURL        [] = L"/pchealth/uploadserver.dll";
const WCHAR c_szNonEscTemp       [] = L"c:\\temp\\pchealth\\queue1";
const WCHAR c_szNonEscDest       [] = L"c:\\dpe\\xml_nonesc";

const WCHAR c_szLog              [] = L"c:\\temp\\pchealth\\log.txt";
const WCHAR c_szLogonURL         [] = L"http://www.highlander.com";

const WCHAR c_szEscProv          [] = L"Esc";
const WCHAR c_szNonEscProv       [] = L"NonEsc";

const WCHAR l_szMachine          [] = L"localhost";


const WCHAR c_szTask_NAME        [] = L"PurgeEngine";
const WCHAR c_szTask_EXE         [] = L"rundll32.exe";

/////////////////////////////////////////////////////////////////////////////

//
// Forward declarations.
//
struct CfgArgument;
struct CfgOption;
struct CfgCommand;
struct CfgStatus;

typedef HRESULT (*CfgHandleOpt)(CfgStatus&,CfgOption*);
typedef HRESULT (*CfgHandleCmd)(CfgStatus&);

/////////////////////////////////////////////////////////////////////////////

struct CfgArgument
{
    LPCWSTR szArgument;
    LPCWSTR szDescription;
    bool    fSeen;         // Set by ShowUsage.
};

struct CfgOption
{
    LPCWSTR      szOption;
    LPCWSTR      szDescription;
    CfgHandleOpt fnHandle;
    CfgArgument* caArgument;
};

struct CfgCommand
{
    LPCWSTR      szCommand;
    LPCWSTR      szDescription;
    CfgHandleCmd fnHandle;
    CfgOption**  coOptions;
};

struct CfgStatus
{
    int             m_argc;
    LPCWSTR*        m_argv;

    CfgCommand*     m_ccCmd;

    LPCWSTR         m_szISAPIloc; // NT event log message file
    LPCWSTR         m_szMachine;  // remote host
    MPC::wstring    m_szURL;      // instance
    MPC::wstring    m_szName;     // provider

    MPC::wstring    m_szUserName; // For Task Scheduler.
    MPC::wstring    m_szPassword; // For Task Scheduler.

    CISAPIinstance* m_pInst;
    CISAPIprovider* m_pProv;

    CISAPIconfig    m_Config;
    bool            m_fRootSet;
    bool            m_fRootLoaded;


    CfgStatus( int argc, LPCWSTR argv[] )
    {
        m_argc        = argc - 1;
        m_argv        = argv + 1;

        m_ccCmd       = NULL;

        m_szISAPIloc  = NULL;
        m_szMachine   = NULL;

        m_pInst       = NULL;
        m_pProv       = NULL;

        m_fRootSet    = false;
        m_fRootLoaded = false;
    }


    LPCWSTR    GetNextArgument( bool fAdvance = true );
    CfgOption* GetOption      (                      );
    void       ShowUsage      (                      );


    HRESULT SetRoot       (                                );
    HRESULT LocateData    ( bool fInstance, bool fProvider );
    HRESULT ProcessCommand(                                );
    HRESULT ProcessOptions(                                );
};

/////////////////////////////////////////////////////////////////////////////

HRESULT HandleOptISAPI       ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptHost        ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptEsc         ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptNonEsc      ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptInst        ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptProv        ( CfgStatus& cs, CfgOption* coOpt );

HRESULT HandleOptQueue_Add   ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptQueue_Del   ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptMaxQueueSize( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptMinQueueSize( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptMaxJobAge   ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptMaxPacket   ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptLog         ( CfgStatus& cs, CfgOption* coOpt );

HRESULT HandleOptDest_Add    ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptDest_Del    ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptAuth_Add    ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptAuth_Del    ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptLogon       ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptProviderGUID( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptJobsPerDay  ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptBytesPerDay ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptMaxJobSize  ( CfgStatus& cs, CfgOption* coOpt );

HRESULT HandleOptUserName    ( CfgStatus& cs, CfgOption* coOpt );
HRESULT HandleOptPassword    ( CfgStatus& cs, CfgOption* coOpt );


HRESULT HandleCmdList     ( CfgStatus& cs );
HRESULT HandleCmdInstall  ( CfgStatus& cs );
HRESULT HandleCmdUninstall( CfgStatus& cs );
HRESULT HandleCmdAdd      ( CfgStatus& cs );
HRESULT HandleCmdConfig   ( CfgStatus& cs );
HRESULT HandleCmdDelete   ( CfgStatus& cs );

/////////////////////////////////////////////////////////////////////////////


CfgArgument caISAPIloc      = { L"ISAPIloc"     , L"Location of the ISAPI for NT event registration"          };
CfgArgument caMachineName   = { L"MachineName"  , L"Host name for remote administration"                      };
CfgArgument caInstance      = { L"Instance"     , L"Instance identifier (relative path of the ISAPI"          };
CfgArgument caProvider      = { L"Provider"     , L"Name of the provider (ex: 'Esc' and 'NonEsc')"            };
CfgArgument caQueueLocation = { L"QueueLocation", L"UNC path to maintain partial uploaded data"               };
CfgArgument caDestination   = { L"Destination"  , L"UNC path to final destinations for uploaded data"         };
CfgArgument caLogLocation   = { L"LogLocation"  , L"Name of the log file for an instance"                     };
CfgArgument caLogonUrl      = { L"LogonUrl"     , L"URL used to redirect to the logon site"                   };
CfgArgument caProviderGUID  = { L"ProviderGUID" , L"GUID for the COM object implementing the custom behavior" };
CfgArgument caSize          = { L"Size"         , L"Size specification, can use KB, MB, ..."                  };
CfgArgument caAge           = { L"Age"          , L"Time specification"                                       };


CfgOption coISAPI        = { L"-isapi"          , L"specify the location of the ISAPI for NT events"    , HandleOptISAPI       , &caISAPIloc      };
CfgOption coHost         = { L"-host"           , L"specify host name for remote administration"        , HandleOptHost        , &caMachineName   };
CfgOption coEsc          = { L"-esc"            , L"use the default escalated instance and provider"    , HandleOptEsc         ,  NULL            };
CfgOption coNonEsc       = { L"-nonesc"         , L"use the default non-escalated instance and provider", HandleOptNonEsc      ,  NULL            };
CfgOption coInst         = { L"-inst"           , L"specify instance to configure"                      , HandleOptInst        , &caInstance      };
CfgOption coProv         = { L"-prov"           , L"specify provider to configure"                      , HandleOptProv        , &caProvider      };

CfgOption coQueue_Add    = { L"+queue"          , L"add one queue location"                             , HandleOptQueue_Add   , &caQueueLocation };
CfgOption coQueue_Del    = { L"-queue"          , L"remove one queue location"                          , HandleOptQueue_Del   , &caQueueLocation };
CfgOption coMaxQueueSize = { L"-maxqueuesize"   , L"set upper size limit for purging process"           , HandleOptMaxQueueSize, &caSize          };
CfgOption coMinQueueSize = { L"-minqueuesize"   , L"set lower size limit for purging processs"          , HandleOptMinQueueSize, &caSize          };
CfgOption coMaxJobAge    = { L"-maxjobage"      , L"maximum number of days a job can stay in the queue" , HandleOptMaxJobAge   , &caAge           };
CfgOption coMaxPacket    = { L"-maxpacket"      , L"maximum size for an incoming packet"                , HandleOptMaxPacket   , &caSize          };
CfgOption coLog          = { L"-log"            , L"set log file"                                       , HandleOptLog         , &caLogLocation   };

CfgOption coDest_Add     = { L"+dest"           , L"add one destination directory"                      , HandleOptDest_Add    , &caDestination   };
CfgOption coDest_Del     = { L"-dest"           , L"remove one destination directory"                   , HandleOptDest_Del    , &caDestination   };
CfgOption coAuth_Add     = { L"+auth"           , L"set authentication flag"                            , HandleOptAuth_Add    ,  NULL            };
CfgOption coAuth_Del     = { L"-auth"           , L"reset authentication flag"                          , HandleOptAuth_Del    ,  NULL            };
CfgOption coLogon        = { L"-logon"          , L"set logon site"                                     , HandleOptLogon       , &caLogonUrl      };
CfgOption coGUID         = { L"-guid"           , L"set the GUID for the custom provider"               , HandleOptProviderGUID, &caProviderGUID  };
CfgOption coJobsPerDay   = { L"-maxjobsperday"  , L"maximum allowed number of jobs per days"            , HandleOptJobsPerDay  , &caSize          };
CfgOption coBytesPerDay  = { L"-maxbytesperday" , L"maximum allowed number of bytes per days"           , HandleOptBytesPerDay , &caSize          };
CfgOption coMaxJobSize   = { L"-maxjobsize"     , L"maximum size for each job"                          , HandleOptMaxJobSize  , &caSize          };

CfgOption coUserName     = { L"-username"       , L"specify the username to use for the Task Scheduler" , HandleOptUserName    ,  NULL            };
CfgOption coPassword     = { L"-password"       , L"specify the password to use for the Task Scheduler" , HandleOptPassword    ,  NULL            };

////////////////////////////////////////

CfgOption* rgcoInstall  [] = { &coHost, &coISAPI, &coUserName, &coPassword, NULL };

CfgOption* rgcoUninstall[] = { &coHost, NULL };

CfgOption* rgcoConfig[] = { &coHost        ,
                            &coEsc         ,
                            &coNonEsc      ,
                            &coInst        ,
                            &coProv        ,
                            &coQueue_Add   ,
                            &coMaxQueueSize,
                            &coMinQueueSize,
                            &coMaxJobAge   ,
                            &coMaxPacket   ,
                            &coLog         ,
                            &coQueue_Del   ,
                            &coDest_Add    ,
                            &coDest_Del    ,
                            &coAuth_Add    ,
                            &coAuth_Del    ,
                            &coJobsPerDay  ,
                            &coBytesPerDay ,
                            &coMaxJobSize  ,
                            &coLogon       ,
                            &coGUID        ,
                             NULL          };

CfgOption* rgcoList[] = { &coHost  ,
                          &coEsc   ,
                          &coNonEsc,
                          &coInst  ,
                          &coProv  ,
                           NULL    };

CfgOption* rgcoAdd[] = { &coHost ,
                         &coInst ,
                         &coProv ,
                          NULL   };

CfgOption* rgcoDelete[] = { &coHost ,
                            &coInst ,
                            &coProv ,
                             NULL   };

////////////////////////////////////////

CfgCommand ccCommands[] =
{
    { L"LIST"     , L"Lists current configuration"                                   , HandleCmdList     , rgcoList      },
    { L"INSTALL"  , L"Creates default instances for escalated and non-escalated data", HandleCmdInstall  , rgcoInstall   },
    { L"UNINSTALL", L"Removes all configuration info"                                , HandleCmdUninstall, rgcoUninstall },
    { L"ADD"      , L"Creates instances and/or providers"                            , HandleCmdAdd      , rgcoAdd       },
    { L"CONFIG"   , L"Configures existing instances"                                 , HandleCmdConfig   , rgcoConfig    },
    { L"DELETE"   , L"Deletes instances and/or providers"                            , HandleCmdDelete   , rgcoDelete    }
};



/////////////////////////////////////////////////////////////////////////////

void OutputErrorMessage( HRESULT hr )
{
    if(HRESULT_FACILITY(hr) == FACILITY_WIN32)
    {
        LPWSTR lpMsgBuf = NULL;

        ::FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_SYSTEM     |
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          HRESULT_CODE(hr),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPWSTR)&lpMsgBuf,
                          0,
                          NULL );

        if(lpMsgBuf)
        {
            fwprintf( stderr, L"Error 0x%08x: %s\n", hr, lpMsgBuf );

            // Free the buffer.
            LocalFree( lpMsgBuf );
        }
    }
    else
    {
        fwprintf( stderr, L"Error 0x%08x\n", hr );
    }
}

/////////////////////////////////////////////////////////////////////////////

LPCWSTR CfgStatus::GetNextArgument( bool fAdvance )
{
    LPCWSTR szRes = NULL;

    if(m_argc > 0)
    {
        szRes = m_argv[0];

        if(fAdvance)
        {
            m_argc--;
            m_argv++;
        }
    }

    return szRes;
}

CfgOption* CfgStatus::GetOption()
{
    LPCWSTR szOpt = GetNextArgument();

    if(szOpt && m_ccCmd)
    {
        CfgOption** rcoOpt = m_ccCmd->coOptions;
        CfgOption*  coOpt;

        while((coOpt = *rcoOpt++))
        {
            if(_wcsicmp( szOpt, coOpt->szOption ) == 0)
            {
                if(coOpt->caArgument)
                {
                    if(GetNextArgument( false ) == NULL)
                    {
                        fwprintf( stderr, L"Missing argument: %s\n\n", coOpt->caArgument->szArgument );

                        ShowUsage();
                        return NULL;
                    }
                }

                return coOpt;
            }
        }

        fwprintf( stderr, L"Unknown Option: %s\n\n", szOpt );

        ShowUsage();
    }

    return NULL;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CfgStatus::SetRoot()
{
    HRESULT hr;


    if(m_fRootSet == false)
    {
        if(FAILED(hr = m_Config.SetRoot( c_szRegistryBase, m_szMachine )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Failed to set root of registry.\n" );
            return hr;
        }

        if(m_szMachine == NULL)
        {
            m_szMachine = l_szMachine;
        }

        m_fRootSet = true;
    }


    return S_OK;
}

HRESULT CfgStatus::LocateData( bool fInstance, bool fProvider )
{
    HRESULT                  hr;
    CISAPIconfig::Iter       itInst;
    CISAPIinstance::ProvIter itProv;
    bool                     fFound;


    m_pInst = NULL;
    m_pProv = NULL;


    if(FAILED(hr = SetRoot()))
    {
        return hr;
    }

    if(m_fRootLoaded == false)
    {
        if(FAILED(hr = m_Config.Load()))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Failed to load settings.\n" );
            return hr;
        }

        m_fRootLoaded = true;
    }


    // If URL is not set, don't search for any particular instance.
    if(fInstance == false) return S_OK;

    if(FAILED(hr = m_Config.GetInstance( itInst, fFound, m_szURL )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to get instance %s.\n", m_szURL.c_str() );
        return hr;
    }
    if(fFound == false)
    {
        fwprintf( stderr, L"Instance %s doens't exist!\n", m_szURL.c_str() );
        return E_INVALIDARG;
    }
    m_pInst = &(*itInst);


    // If name is not set, don't search for any particular provider.
    if(fProvider == false) return S_OK;

    if(FAILED(hr = m_pInst->GetProvider( itProv, fFound, m_szName )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to get provider %s.\n", m_szName.c_str() );
        return hr;
    }
    if(fFound == false)
    {
        fwprintf( stderr, L"Provider %s doens't exist!\n", m_szName.c_str() );
        return E_INVALIDARG;
    }
    m_pProv = &(itProv->second);

    return S_OK;
}

HRESULT CfgStatus::ProcessCommand()
{
    HRESULT hr;
    LPCWSTR szCmd;

    szCmd = GetNextArgument();
    if(szCmd)
    {
        for(int i=0; i<(sizeof(ccCommands) / sizeof(ccCommands[0])); i++)
        {
            if(_wcsicmp( szCmd, ccCommands[i].szCommand ) == 0)
            {
                m_ccCmd = &ccCommands[i];
            }
        }
    }

    if(m_ccCmd == NULL)
    {
        fwprintf( stderr, L"Unknown command: %s\n\n", szCmd );

        ShowUsage();
        hr = E_FAIL;
    }
    else
    {
        hr = m_ccCmd->fnHandle( *this );
    }

    return hr;
}

HRESULT CfgStatus::ProcessOptions()
{
    HRESULT    hr;
    CfgOption* coOpt;


    while((coOpt = GetOption()) != NULL)
    {
        if(FAILED(hr = coOpt->fnHandle( *this, coOpt )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Failed processing option %s.\n", coOpt->szOption );
            return hr;
        }
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////

void CfgStatus::ShowUsage()
{
    if(m_ccCmd == NULL)
    {
        int i;
        int nCmd = 0;

        fwprintf( stderr, L"Usage: uplibcfg <Command Type> [<options> ...]\n\n" );
        fwprintf( stderr, L"Command Types:\n"                                   );

        //
        // Calculate maximum width of commands.
        //
        for(i=0; i<(sizeof(ccCommands) / sizeof(ccCommands[0])); i++)
        {
            nCmd = max( nCmd, wcslen( ccCommands[i].szCommand ));
        }

        //
        // Print commands.
        //
        for(i=0; i<(sizeof(ccCommands) / sizeof(ccCommands[0])); i++)
        {
            fwprintf( stderr, L"  %-*s : %s.\n", nCmd, ccCommands[i].szCommand, ccCommands[i].szDescription );
        }

        fwprintf( stderr, L"\nTo see parameters for each command, use the '-help' option.\n\n" );
    }
    else
    {
        int         i;
        int         nCmd = 0;
        int         nOpt = 0;
        int         nArg = 0;
        WCHAR       rgHeader[256];
        CfgOption** rcoOpt;
        CfgOption*  coOpt;


        nCmd = swprintf( rgHeader, L"Usage: uplibcfg %s", m_ccCmd->szCommand );


        //
        // Calculate maximum width of options and their arguments
        //
        rcoOpt = m_ccCmd->coOptions;
        while((coOpt = *rcoOpt++))
        {
            nOpt = max( nOpt, wcslen( coOpt->szOption ));

            if(coOpt->caArgument)
            {
                nArg = max( nArg, wcslen( coOpt->caArgument->szArgument ));
            }
        }


        //
        // Print options.
        //
        i      = 0;
        rcoOpt = m_ccCmd->coOptions;
        while((coOpt = *rcoOpt++))
        {
            fwprintf( stderr, L"%*s [%s", nCmd, (i++ == 0) ? rgHeader : L"", coOpt->szOption );

            if(coOpt->caArgument)
            {
                fwprintf( stderr, L" <%s>]\n", coOpt->caArgument->szArgument );
            }
            else
            {
                fwprintf( stderr, L"]\n" );
            }
        }

        fwprintf( stderr, L"\nWhere:\n\n" );

        //
        // Print options' description.
        //
        rcoOpt = m_ccCmd->coOptions;
        while((coOpt = *rcoOpt++))
        {
            fwprintf( stderr, L" %-*s : %s.\n", nOpt, coOpt->szOption, coOpt->szDescription );
        }

        fwprintf( stderr, L"\n" );

        //
        // Print arguments' description.
        //
        rcoOpt = m_ccCmd->coOptions;
        while((coOpt = *rcoOpt++))
        {
            if(coOpt->caArgument && coOpt->caArgument->fSeen == false)
            {
                coOpt->caArgument->fSeen = true;

                fwprintf( stderr, L" %-*s : %s.\n", nArg, coOpt->caArgument->szArgument, coOpt->caArgument->szDescription );
            }
        }
    }

    exit( 10 );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT HandleOptISAPI( CfgStatus& cs, CfgOption* coOpt )
{
    cs.m_szISAPIloc = cs.GetNextArgument();

    return S_OK;
}

HRESULT HandleOptHost( CfgStatus& cs, CfgOption* coOpt )
{
    cs.m_szMachine = cs.GetNextArgument();

    return S_OK;
}

HRESULT HandleOptEsc( CfgStatus& cs, CfgOption* coOpt )
{
    cs.m_szURL  = c_szEscURL;
    cs.m_szName = c_szEscProv;

    return S_OK;
}

HRESULT HandleOptNonEsc( CfgStatus& cs, CfgOption* coOpt )
{
    cs.m_szURL  = c_szNonEscURL;
    cs.m_szName = c_szNonEscProv;

    return S_OK;
}

HRESULT HandleOptInst( CfgStatus& cs, CfgOption* coOpt )
{
    cs.m_szURL = cs.GetNextArgument();

    return S_OK;
}

HRESULT HandleOptProv( CfgStatus& cs, CfgOption* coOpt )
{
    cs.m_szName = cs.GetNextArgument();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT HandleOptQueue_Add( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT                  hr;
    CISAPIinstance::PathIter it;
    MPC::wstring             szPath = cs.GetNextArgument();


    if(FAILED(hr = cs.LocateData( true, false )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_pInst->NewLocation( it, szPath )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to add a queue location.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptQueue_Del( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT                  hr;
    CISAPIinstance::PathIter it;
    MPC::wstring             szPath = cs.GetNextArgument();
    bool                     fFound;


    if(FAILED(hr = cs.LocateData( true, false )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_pInst->GetLocation( it, fFound, szPath )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to get a queue location.\n" );
        return hr;
    }
    if(fFound)
    {
        if(FAILED(hr = cs.m_pInst->DelLocation( it )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Failed to delete a queue location.\n" );
            return hr;
        }
    }


    return S_OK;
}

HRESULT HandleOptMaxQueueSize( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szSize( cs.GetNextArgument() );
    DWORD        dwSize;


    if(FAILED(hr = cs.LocateData( true, false )))
    {
        return hr;
    }

    if(MPC::ConvertSizeUnit( szSize, dwSize ) != S_OK)
    {
        fwprintf( stderr, L"Invalid size format: %s\n", szSize.c_str() );
        return E_INVALIDARG;
    }

    if(FAILED(hr = cs.m_pInst->put_QueueSizeMax( dwSize )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set maximum queue size.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptMinQueueSize( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szSize( cs.GetNextArgument() );
    DWORD        dwSize;


    if(FAILED(hr = cs.LocateData( true, false )))
    {
        return hr;
    }

    if(MPC::ConvertSizeUnit( szSize, dwSize ) != S_OK)
    {
        fwprintf( stderr, L"Invalid size format: %s\n", szSize.c_str() );
        return E_INVALIDARG;
    }

    if(FAILED(hr = cs.m_pInst->put_QueueSizeThreshold( dwSize )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set minimum queue size.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptMaxJobAge( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szAge = cs.GetNextArgument();


    if(FAILED(hr = cs.LocateData( true, false )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_pInst->put_MaximumJobAge( _wtoi( szAge.c_str() ) )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set maximum job age.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptMaxPacket( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szSize( cs.GetNextArgument() );
    DWORD        dwSize;


    if(FAILED(hr = cs.LocateData( true, false )))
    {
        return hr;
    }

    if(MPC::ConvertSizeUnit( szSize, dwSize ) != S_OK)
    {
        fwprintf( stderr, L"Invalid size format: %s\n", szSize.c_str() );
        return E_INVALIDARG;
    }

    if(FAILED(hr = cs.m_pInst->put_MaximumPacketSize( dwSize )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set maximum packet size.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptLog( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szLogLocation = cs.GetNextArgument();


    if(FAILED(hr = cs.LocateData( true, false )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_pInst->put_LogLocation( szLogLocation )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set log file.\n" );
        return hr;
    }


    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT HandleOptDest_Add( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT                  hr;
    CISAPIprovider::PathIter it;
    MPC::wstring             szPath = cs.GetNextArgument();


    if(FAILED(hr = cs.LocateData( true, true )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_pProv->NewLocation( it, szPath )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to add a destination.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptDest_Del( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT                  hr;
    CISAPIprovider::PathIter it;
    MPC::wstring             szPath = cs.GetNextArgument();
    bool                     fFound;


    if(FAILED(hr = cs.LocateData( true, true )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_pProv->GetLocation( it, fFound, szPath )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to get a destination.\n" );
        return hr;
    }
    if(fFound)
    {
        if(FAILED(hr = cs.m_pProv->DelLocation( it )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Failed to delete a destination.\n" );
            return hr;
        }
    }


    return S_OK;
}

HRESULT HandleOptAuth_Add( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT hr;


    if(FAILED(hr = cs.LocateData( true, true )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_pProv->put_Authenticated( TRUE )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set authentication flag.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptAuth_Del( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT hr;


    if(FAILED(hr = cs.LocateData( true, true )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_pProv->put_Authenticated( FALSE )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to reset authentication flag.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptLogon( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szLogonURL = cs.GetNextArgument();


    if(FAILED(hr = cs.LocateData( true, true )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_pProv->put_LogonURL( szLogonURL )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set Logon Site.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptProviderGUID( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szProviderGUID = cs.GetNextArgument();
    CLSID        guid;



    if(FAILED(hr = cs.LocateData( true, true )))
    {
        return hr;
    }

    if(szProviderGUID.size() > 0)
    {
        if(FAILED(hr = ::CLSIDFromString( (LPWSTR)szProviderGUID.c_str(), &guid )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"The argument is not a valid GUID.\n" );
            return hr;
        }
    }

    if(FAILED(hr = cs.m_pProv->put_ProviderGUID( szProviderGUID )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set the GUID for the custom provider.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptJobsPerDay( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szSize( cs.GetNextArgument() );
    DWORD        dwSize;


    if(FAILED(hr = cs.LocateData( true, true )))
    {
        return hr;
    }

    if(MPC::ConvertSizeUnit( szSize, dwSize ) != S_OK)
    {
        fwprintf( stderr, L"Invalid size format: %s\n", szSize.c_str() );
        return E_INVALIDARG;
    }

    if(FAILED(hr = cs.m_pProv->put_MaxJobsPerDay( dwSize )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set maximum jobs per day.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptBytesPerDay( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szSize( cs.GetNextArgument() );
    DWORD        dwSize;


    if(FAILED(hr = cs.LocateData( true, true )))
    {
        return hr;
    }

    if(MPC::ConvertSizeUnit( szSize, dwSize ) != S_OK)
    {
        fwprintf( stderr, L"Invalid size format: %s\n", szSize.c_str() );
        return E_INVALIDARG;
    }

    if(FAILED(hr = cs.m_pProv->put_MaxBytesPerDay( dwSize )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set maximum number of bytes per day.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleOptMaxJobSize( CfgStatus& cs, CfgOption* coOpt )
{
    HRESULT      hr;
    MPC::wstring szSize( cs.GetNextArgument() );
    DWORD        dwSize;


    if(FAILED(hr = cs.LocateData( true, true )))
    {
        return hr;
    }

    if(MPC::ConvertSizeUnit( szSize, dwSize ) != S_OK)
    {
        fwprintf( stderr, L"Invalid size format: %s\n", szSize.c_str() );
        return E_INVALIDARG;
    }

    if(FAILED(hr = cs.m_pProv->put_MaxJobSize( dwSize )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to set maximum job size.\n" );
        return hr;
    }


    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT HandleOptUserName( CfgStatus& cs, CfgOption* coOpt )
{
    cs.m_szUserName = cs.GetNextArgument();
    return S_OK;
}

HRESULT HandleOptPassword( CfgStatus& cs, CfgOption* coOpt )
{
    cs.m_szPassword = cs.GetNextArgument();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT HandleCmdList_Provider( CfgStatus&      cs    ,
                                CISAPIinstance* pInst ,
                                CISAPIprovider* pProv )
{
    HRESULT                  hr = S_OK;

    MPC::wstring             szName;
    DWORD                    dwMaxJobsPerDay;
    DWORD                    dwMaxBytesPerDay;
    DWORD                    dwMaxJobSize;
    BOOL                     fAuthenticated;
    DWORD                    fProcessingMode;
    MPC::wstring             szLogonURL;
    MPC::wstring             szProviderGUID;

    CISAPIprovider::PathIter itDest;
    CISAPIprovider::PathIter itDestBegin;
    CISAPIprovider::PathIter itDestEnd;


    pProv->get_Name          ( szName           ); wprintf( L"\n  Provider: %s\n"         , szName.c_str()                    );
    pProv->get_MaxJobsPerDay ( dwMaxJobsPerDay  ); wprintf(   L"    MaxJobsPerDay : %d \n", dwMaxJobsPerDay                   );
    pProv->get_MaxBytesPerDay( dwMaxBytesPerDay ); wprintf(   L"    MaxBytesPerDay: %d \n", dwMaxBytesPerDay                  );
    pProv->get_MaxJobSize    ( dwMaxJobSize     ); wprintf(   L"    MaxJobsSize   : %d \n", dwMaxJobSize                      );
    pProv->get_Authenticated ( fAuthenticated   ); wprintf(   L"    Authenticated : %s \n", fAuthenticated ? "TRUE" : "FALSE" );
    pProv->get_ProcessingMode( fProcessingMode  ); wprintf(   L"    ProcessingMode: %d \n", fProcessingMode                   );
    pProv->get_LogonURL      ( szLogonURL       ); wprintf(   L"    LogonURL      : %s \n", szLogonURL.c_str()                );
    pProv->get_ProviderGUID  ( szProviderGUID   ); wprintf(   L"    ProviderGUID  : %s \n", szProviderGUID.c_str()            );


    pProv->GetLocations( itDestBegin, itDestEnd );
    for(itDest = itDestBegin; itDest != itDestEnd; itDest++)
    {
        wprintf( L"    Final Location: %s \n", itDest->c_str() );
    }


    return hr;
}

HRESULT HandleCmdList_Instance( CfgStatus&      cs    ,
                                CISAPIinstance* pInst )
{
    HRESULT                  hr = S_OK;

    MPC::wstring             szURL;
    DWORD                    dwQueueSizeMax;
    DWORD                    dwQueueSizeThreshold;
    DWORD                    dwMaximumJobAge;
    DWORD                    dwMaximumPacketSize;
    MPC::wstring             szLogLocation;

    CISAPIinstance::ProvIter itProv;
    CISAPIinstance::ProvIter itProvBegin;
    CISAPIinstance::ProvIter itProvEnd;

    CISAPIinstance::PathIter itQueue;
    CISAPIinstance::PathIter itQueueBegin;
    CISAPIinstance::PathIter itQueueEnd;


    pInst->get_URL               ( szURL                ); wprintf( L"\nInstance: %s\n"            , szURL.c_str()         );
    pInst->get_QueueSizeMax      ( dwQueueSizeMax       ); wprintf(   L"  QueueSizeMax      : %d\n", dwQueueSizeMax        );
    pInst->get_QueueSizeThreshold( dwQueueSizeThreshold ); wprintf(   L"  QueueSizeThreshold: %d\n", dwQueueSizeThreshold  );
    pInst->get_MaximumJobAge     ( dwMaximumJobAge      ); wprintf(   L"  MaximumJobAge     : %d\n", dwMaximumJobAge       );
    pInst->get_MaximumPacketSize ( dwMaximumPacketSize  ); wprintf(   L"  MaximumPacketSize : %d\n", dwMaximumPacketSize   );
    pInst->get_LogLocation       ( szLogLocation        ); wprintf(   L"  LogLocation       : %s\n", szLogLocation.c_str() );


    pInst->GetLocations( itQueueBegin, itQueueEnd );
    for(itQueue = itQueueBegin; itQueue != itQueueEnd; itQueue++)
    {
        wprintf( L"  Queue Location    : %s \n", itQueue->c_str() );
    }


    pInst->GetProviders( itProvBegin, itProvEnd );
    for(itProv = itProvBegin; itProv != itProvEnd; itProv++)
    {
        if(FAILED(hr = HandleCmdList_Provider( cs, pInst, &itProv->second )))
        {
            return hr;
        }
    }

    wprintf( L"\n" );

    return hr;
}

HRESULT HandleCmdList( CfgStatus& cs )
{
    HRESULT hr;


    if(FAILED(hr = cs.ProcessOptions()))
    {
        return hr;
    }


    if(FAILED(hr = cs.LocateData( (cs.m_szURL.length() != 0), (cs.m_szName.length() != 0) )))
    {
        return hr;
    }


    wprintf( L"Current PCHealth ISAPI Configuration\n\n" );
    wprintf( L"Machine: %s\n\n", cs.m_szMachine          );


    if(cs.m_pInst == NULL)
    {
        CISAPIconfig::Iter itInst;
        CISAPIconfig::Iter itInstBegin;
        CISAPIconfig::Iter itInstEnd;

        cs.m_Config.GetInstances( itInstBegin, itInstEnd );
        for(itInst = itInstBegin; itInst != itInstEnd; itInst++)
        {
            if(FAILED(hr = HandleCmdList_Instance( cs, &(*itInst) )))
            {
                return hr;
            }
        }
    }
    else if(cs.m_pProv == NULL)
    {
        if(FAILED(hr = HandleCmdList_Instance( cs, cs.m_pInst )))
        {
            return hr;
        }
    }
    else
    {
        if(FAILED(hr = HandleCmdList_Provider( cs, cs.m_pInst, cs.m_pProv )))
        {
            return hr;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT HandleCmdInstall_Inst( CfgStatus& cs     ,
                               LPCWSTR    szURL  ,
                               LPCWSTR    szTemp ,
                               LPCWSTR    szName ,
                               LPCWSTR    szDest ,
                               BOOL       fAuth  )
{
    HRESULT            hr;
    CISAPIconfig::Iter it;

    if(FAILED(hr = cs.m_Config.NewInstance( it, MPC::wstring( szURL ) )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Unable to allocate Instance %s.\n", szURL );
        return hr;
    }
    else
    {
        CISAPIinstance&          inst = *it;
        CISAPIinstance::PathIter itPath;
        CISAPIinstance::ProvIter itProv;

        inst.put_LogLocation( MPC::wstring( c_szLog ) );

        if(FAILED(hr = inst.NewLocation( itPath, MPC::wstring( szTemp ) )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Failed to add the queue location for %s.\n", szURL );
            return hr;
        }

        if(FAILED(hr = inst.NewProvider( itProv, MPC::wstring( szName ) )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Failed to allocate Provider %s for %s.\n", szName, szURL );
            return hr;
        }
        else
        {
            CISAPIprovider&          prov = itProv->second;
            CISAPIprovider::PathIter itPath2;

            prov.put_Authenticated (               fAuth          );
            prov.put_LogonURL      ( MPC::wstring( c_szLogonURL ) );
            prov.put_ProcessingMode(               0              );

            if(FAILED(hr = prov.NewLocation( itPath2, MPC::wstring( szDest ) )))
            {
                OutputErrorMessage( hr );
                fwprintf( stderr, L"Failed to add the destination for Provider %s.\n", szName );
                return hr;
            }
        }
    }

    return hr;
}

HRESULT HandleCmdInstall_Event( CfgStatus& cs )
{
    __ULT_FUNC_ENTRY( "HandleCmdInstall_Event" );

    HRESULT      hr = S_OK;
    MPC::RegKey  rkEventLog;
    CComVariant  vValue;
    MPC::wstring szPath;

    if(cs.m_szISAPIloc)
    {
        szPath = cs.m_szISAPIloc;
    }
    else
    {
        MPC::GetProgramDirectory( szPath );
        szPath.append( c_szISAPI_FileName );
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS, cs.m_szMachine ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.Attach ( c_szRegistryLog                                    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.Create (                                                    ));


    vValue = szPath.c_str(); __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.put_Value( vValue, c_szRegistryLog_File  ));
    vValue = (long)0x1F    ; __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.put_Value( vValue, c_szRegistryLog_Flags ));


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT HandleCmdInstall_Scheduler( CfgStatus& cs )
{
    __ULT_FUNC_ENTRY( "HandleCmdInstall_Scheduler" );

    HRESULT                       hr;
    CComPtr<ITaskScheduler>       pTaskScheduler;
    CComPtr<ITask>                pTask;
    CComPtr<ITaskTrigger>         pTaskTrigger;
    CComQIPtr<IScheduledWorkItem> pScheduledWorkItem;
    CComQIPtr<IPersistFile>       pIPF;
    WORD                          wTrigNumber;
    MPC::wstring                  szArguments;


    //
    // Creates the arguments string.
    //
    if(cs.m_szISAPIloc)
    {
        szArguments = cs.m_szISAPIloc;
    }
    else
    {
        MPC::GetProgramDirectory( szArguments );
        szArguments.append( c_szISAPI_FileName );
    }
    szArguments += L",PurgeEngine";


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskScheduler, (void**)&pTaskScheduler ));


    //
    // Delete old task, if present.
    //
    if(FAILED(hr = pTaskScheduler->Delete( c_szTask_NAME )))
    {
        if(hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            __ULT_FUNC_LEAVE;
        }
    }

    //
    // Create a new task and set its app name and parameters
    //
    if(FAILED(hr = pTaskScheduler->NewWorkItem( c_szTask_NAME, CLSID_CTask, IID_ITask, (IUnknown**)&pTask )))
    {
        if(hr != HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
        {
            __ULT_FUNC_LEAVE;
        }
    }

    pScheduledWorkItem = pTask;

    __MPC_EXIT_IF_METHOD_FAILS(hr, pTask->SetApplicationName( c_szTask_EXE        ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pTask->SetParameters     ( szArguments.c_str() ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetAccountInformation( cs.m_szUserName.c_str(), cs.m_szPassword.c_str() ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetComment           ( L"Purge Process for Upload Library"              ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetFlags             (  0                                               ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->CreateTrigger        ( &wTrigNumber, &pTaskTrigger                      ));


    //
    // Now, fill in the trigger as necessary.
    //
    {
        TASK_TRIGGER       ttTaskTrig;
        TRIGGER_TYPE_UNION ttu;
        DAILY              daily;
        SYSTEMTIME         stNow;


        ZeroMemory( &ttTaskTrig, sizeof(ttTaskTrig) );
        ttTaskTrig.cbTriggerSize = sizeof(ttTaskTrig);

        GetLocalTime( &stNow );
        ttTaskTrig.wBeginYear   = stNow.wYear;
        ttTaskTrig.wBeginMonth  = stNow.wMonth;
        ttTaskTrig.wBeginDay    = stNow.wDay;
        ttTaskTrig.wStartHour   = 3;
        ttTaskTrig.wStartMinute = 0;

        daily.DaysInterval      = 1;
        ttu.Daily               = daily;
        ttTaskTrig.Type         = ttu;
        ttTaskTrig.TriggerType  = TASK_TIME_TRIGGER_DAILY;

        // Add this trigger to the task.
        __MPC_EXIT_IF_METHOD_FAILS(hr, pTaskTrigger->SetTrigger( &ttTaskTrig ));
    }

    //
    // Make the changes permanent.
    //
    pIPF = pTask;
    __MPC_EXIT_IF_METHOD_FAILS(hr, pIPF->Save( NULL, FALSE ));


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT HandleCmdInstall( CfgStatus& cs )
{
    HRESULT            hr;
    CISAPIconfig::Iter it;

    if(FAILED(hr = cs.ProcessOptions()))
    {
        return hr;
    }


    if(FAILED(hr = cs.SetRoot()))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_Config.Uninstall()))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to install settings.\n" );
        return hr;
    }

    if(FAILED(hr = cs.m_Config.Install()))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to install settings.\n" );
        return hr;
    }

    if(FAILED(hr = HandleCmdInstall_Inst( cs, c_szEscURL, c_szEscTemp, c_szEscProv, c_szEscDest, TRUE )))
    {
        return hr;
    }

    if(FAILED(hr = HandleCmdInstall_Inst( cs, c_szNonEscURL, c_szNonEscTemp, c_szNonEscProv, c_szNonEscDest, FALSE )))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_Config.Save()))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Unable to completely write changed configuration.\n" );
        return hr;
    }

    if(FAILED(hr = HandleCmdInstall_Event( cs )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Unable to install the Message File for NT Event logs.\n" );
        return hr;
    }

    if(FAILED(hr = HandleCmdInstall_Scheduler( cs )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to install Task Scheduler entry.\n" );
        return hr;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT HandleCmdUninstall_Event( CfgStatus& cs )
{
    __ULT_FUNC_ENTRY( "HandleCmdUninstall_Event" );

    HRESULT     hr;
    MPC::RegKey rkEventLog;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS, cs.m_szMachine ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.Attach ( c_szRegistryLog                                    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.Delete ( true                                               ));


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT HandleCmdUninstall_Key( CfgStatus& cs )
{
    __ULT_FUNC_ENTRY( "HandleCmdUninstall_Key" );

    HRESULT     hr = S_OK;
    MPC::RegKey rkUploadLibrary;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkUploadLibrary.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS, cs.m_szMachine ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkUploadLibrary.Attach ( c_szRegistryBase2                                  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkUploadLibrary.Delete ( true                                               ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}



HRESULT HandleCmdUninstall( CfgStatus& cs )
{
    HRESULT hr;


    if(FAILED(hr = cs.ProcessOptions()))
    {
        return hr;
    }


    if(FAILED(hr = cs.SetRoot()))
    {
        return hr;
    }

    if(FAILED(hr = cs.m_Config.Uninstall()))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to uninstall settings.\n" );
        return hr;
    }

    if(FAILED(hr = HandleCmdUninstall_Key( cs )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Unable to uninstall settings.\n" );
        return hr;
    }

    if(FAILED(hr = HandleCmdUninstall_Event( cs )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Unable to uninstall the Message File for NT Event logs.\n" );
        return hr;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT HandleCmdAdd( CfgStatus& cs )
{
    HRESULT hr;

    if(FAILED(hr = cs.ProcessOptions()))
    {
        return hr;
    }

    //
    // Check arguments.
    //
    if(cs.m_szURL .length() == 0 &&
       cs.m_szName.length() == 0  )
    {
        fwprintf( stderr, L"No arguments supplied...\n" );
        return E_INVALIDARG;
    }


    if(FAILED(hr = cs.LocateData( false, false )))
    {
        return hr;
    }


    if(cs.m_szURL.length() != 0)
    {
        CISAPIconfig::Iter itInst;

        if(FAILED(hr = cs.m_Config.NewInstance( itInst, cs.m_szURL )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Unable to create instance %s.\n", cs.m_szURL.c_str() );
            return hr;
        }

        if(cs.m_szName.length() != 0)
        {
            CISAPIinstance::ProvIter itProv;

            if(FAILED(hr = itInst->NewProvider( itProv, cs.m_szName )))
            {
                OutputErrorMessage( hr );
                fwprintf( stderr, L"Unable to create provider %s.\n", cs.m_szName.c_str() );
                return hr;
            }
        }
    }

    if(FAILED(hr = cs.m_Config.Save()))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Unable to completely write changed configuration.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleCmdConfig( CfgStatus& cs )
{
    HRESULT hr;


    if(FAILED(hr = cs.ProcessOptions()))
    {
        return hr;
    }


    if(FAILED(hr = cs.m_Config.Save()))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Unable to completely write changed configuration.\n" );
        return hr;
    }


    return S_OK;
}

HRESULT HandleCmdDelete( CfgStatus& cs )
{
    HRESULT hr;
    bool    fFound;


    if(FAILED(hr = cs.ProcessOptions()))
    {
        return hr;
    }

    //
    // Check arguments.
    //
    if(cs.m_szURL .length() == 0 &&
       cs.m_szName.length() == 0  )
    {
        fwprintf( stderr, L"No arguments supplied...\n" );
        return E_INVALIDARG;
    }


    if(FAILED(hr = cs.LocateData( (cs.m_szURL.length() != 0), (cs.m_szName.length() != 0) )))
    {
        return hr;
    }


    if(cs.m_pProv)
    {
        CISAPIinstance::ProvIter it;

        if(FAILED(hr = cs.m_pInst->GetProvider( it, fFound, cs.m_szName )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Unable to delete provider %s.\n", cs.m_szName.c_str() );
            return hr;
        }
        if(fFound)
        {
            if(FAILED(hr = cs.m_pInst->DelProvider( it )))
            {
                OutputErrorMessage( hr );
                fwprintf( stderr, L"Unable to delete provider %s.\n", cs.m_szName.c_str() );
                return hr;
            }
        }
    }
    else if(cs.m_pInst)
    {
        CISAPIconfig::Iter it;

        if(FAILED(hr = cs.m_Config.GetInstance( it, fFound, cs.m_szURL )))
        {
            OutputErrorMessage( hr );
            fwprintf( stderr, L"Unable to delete instance %s.\n", cs.m_szURL.c_str() );
            return hr;
        }
        if(fFound)
        {
            if(FAILED(hr = cs.m_Config.DelInstance( it )))
            {
                OutputErrorMessage( hr );
                fwprintf( stderr, L"Unable to delete instance %s.\n", cs.m_szURL.c_str() );
                return hr;
            }
        }
    }

    if(FAILED(hr = cs.m_Config.Save()))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Unable to completely write changed configuration.\n" );
        return hr;
    }


    return S_OK;
}

int __cdecl wmain( int     argc   ,
                   LPCWSTR argv[] )
{
    WCHAR   szBuff[MAX_COMPUTERNAME_LENGTH+1];
    DWORD   dwSize = MAX_COMPUTERNAME_LENGTH;
    HRESULT hr     = S_OK;


    if(!::GetComputerNameW( szBuff, &dwSize ))
    {
        swprintf( szBuff, L"localhost" );
    }


    if(FAILED(hr = CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
        OutputErrorMessage( hr );
        fwprintf( stderr, L"Failed to initialize COM.\n" );
        return -1;
    }
    else
    {
        CfgStatus cs( argc, argv );

        hr = cs.ProcessCommand();
    }

    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\eventwrapper\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EventWrapper.rc
//
#define IDS_PROJNAME                    100
#define IDR_UPLOADEVENTSWRAPPER         101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\eventwrapper\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0DAA8F96_0286_11D3_9397_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__0DAA8F96_0286_11D3_9397_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0DAA8F96_0286_11D3_9397_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\eventwrapper\uploadeventswrapper.cpp ===
// UploadEventsWrapper.cpp : Implementation of CUploadEventsWrapper
#include "stdafx.h"
#include "EventWrapper.h"
#include "UploadEventsWrapper.h"

/////////////////////////////////////////////////////////////////////////////
// CUploadEventsWrapper



HRESULT CUploadEventsWrapper::FinalConstruct()
{
	return CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
}

void CUploadEventsWrapper::FinalRelease()
{
    UnregisterForEvents();

    m_pUnkMarshaler.Release();
}

void CUploadEventsWrapper::UnregisterForEvents()
{
    if(m_dwUploadEventsCookie)
    {
        if(AtlUnadvise( m_mpcujJob, IID_IMPCUploadEvents, m_dwUploadEventsCookie ) == S_OK)
        {
            m_dwUploadEventsCookie = 0;
        }
    }

    if(m_mpcujJob)
    {
        m_mpcujJob->Release(); m_mpcujJob = NULL;
    }
}

STDMETHODIMP CUploadEventsWrapper::Register( IMPCUploadJob* mpcujJob )
{
    HRESULT                   hr = S_OK;
    CComPtr<IMPCUploadEvents> pCallback;


    UnregisterForEvents();


    if(mpcujJob)
    {
        m_mpcujJob = mpcujJob; m_mpcujJob->AddRef();


        if(SUCCEEDED(hr = QueryInterface( IID_IMPCUploadEvents, (void**)&pCallback )))
        {
            hr = AtlAdvise( m_mpcujJob, pCallback, IID_IMPCUploadEvents, &m_dwUploadEventsCookie );
        }
    }


    return hr;
}

////////////////////////////////////////////////

STDMETHODIMP CUploadEventsWrapper::onStatusChange( IMPCUploadJob* mpcujJob, UL_STATUS fStatus )
{
    return Fire_onStatusChange  ( mpcujJob, fStatus );
}

STDMETHODIMP CUploadEventsWrapper::onProgressChange( IMPCUploadJob* mpcujJob, long lCurrentSize, long lTotalSize )
{
    return Fire_onProgressChange( mpcujJob, lCurrentSize, lTotalSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\eventwrapper\uploadeventswrapper.h ===
// UploadEventsWrapper.h : Declaration of the CUploadEventsWrapper

#ifndef __UPLOADEVENTSWRAPPER_H_
#define __UPLOADEVENTSWRAPPER_H_

#include "resource.h"       // main symbols
#include "EventWrapperCP.h"

typedef IDispatchImpl<IUploadEventsWrapper, &IID_IUploadEventsWrapper, &LIBID_EVENTWRAPPERLib> IIDisp1;
typedef IDispatchImpl<IMPCUploadEvents, &IID_IMPCUploadEvents, &LIBID_UPLOADMANAGERLib>        IIDisp2;

/////////////////////////////////////////////////////////////////////////////
// CUploadEventsWrapper
class ATL_NO_VTABLE CUploadEventsWrapper : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CUploadEventsWrapper, &CLSID_UploadEventsWrapper>,
	public IIDisp1,
    public IIDisp2,

	public IConnectionPointContainerImpl<CUploadEventsWrapper>,
	public CProxy_IUploadEventsWrapperEvents< CUploadEventsWrapper >
{
    IMPCUploadJob*    m_mpcujJob;
    DWORD             m_dwUploadEventsCookie;

	CComPtr<IUnknown> m_pUnkMarshaler;

public:
	CUploadEventsWrapper()
	{
        m_mpcujJob             = NULL;
        m_dwUploadEventsCookie = 0;

        m_pUnkMarshaler        = NULL;
	}

    HRESULT FinalConstruct();
    void FinalRelease();

    void UnregisterForEvents();


DECLARE_REGISTRY_RESOURCEID(IDR_UPLOADEVENTSWRAPPER)
DECLARE_NOT_AGGREGATABLE(CUploadEventsWrapper)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUploadEventsWrapper)
	COM_INTERFACE_ENTRY2(IDispatch, IIDisp1)
    COM_INTERFACE_ENTRY2(IMPCUploadEvents, IIDisp2)
	COM_INTERFACE_ENTRY(IUploadEventsWrapper)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CUploadEventsWrapper)
CONNECTION_POINT_ENTRY(DIID__IUploadEventsWrapperEvents)
END_CONNECTION_POINT_MAP()



public:
    // IMPCUploadEvents
    STDMETHOD(onStatusChange  )( IMPCUploadJob* mpcujJob, UL_STATUS fStatus                  );
    STDMETHOD(onProgressChange)( IMPCUploadJob* mpcujJob, long lCurrentSize, long lTotalSize );

    // IUploadEventsWrapper
    STDMETHOD(Register)( IMPCUploadJob* mpcujJob );
};

#endif //__UPLOADEVENTSWRAPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\test\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>

#include <UploadLibraryTrace.h>
#include <UploadManager.h>

#define SAFEBSTR( bstr )  (bstr ? bstr : L"")

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\module.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    module.h

Abstract:
    This file contains the declaration of the CComModule extension for the service.

Revision History:
    Davide Massarenti   (Dmassare)  03/14/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___MODULE_H___)
#define __INCLUDED___PCH___MODULE_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>

class CServiceModule : public CComModule
{
    HANDLE 				  	m_hEventShutdown;
    DWORD                   m_dwThreadID;
    HANDLE 				  	m_hMonitor;
    BOOL   				  	m_bActivity;
  
    LPCWSTR               	m_szServiceName;
	UINT                    m_iDisplayName;
	UINT                    m_iDescription;
    SERVICE_STATUS_HANDLE 	m_hServiceStatus;
    SERVICE_STATUS 		  	m_status;
	BOOL                  	m_bService;

public:
	CServiceModule();
	virtual ~CServiceModule();

	HRESULT RegisterServer  ( BOOL bRegTypeLib, BOOL bService, LPCWSTR szSvcHostGroup );
	HRESULT UnregisterServer(                                  LPCWSTR szSvcHostGroup );

	void Init( _ATL_OBJMAP_ENTRY* p, HINSTANCE h, LPCWSTR szServiceName, UINT iDisplayName, UINT iDescription, const GUID* plibid = NULL );

    BOOL	Start( BOOL bService );
    HRESULT Run  (               );

    BOOL IsInstalled(                        );
    BOOL Install    ( LPCWSTR szSvcHostGroup );
    BOOL Uninstall  ( LPCWSTR szSvcHostGroup );
    LONG Lock       (                        );
	LONG Unlock     (                        );

	void ServiceMain	 ( DWORD dwArgc, LPWSTR* lpszArgv );
    void Handler    	 ( DWORD dwOpcode                 );
    void SetServiceStatus( DWORD dwState                  );

#ifdef DEBUG
	static void ReadDebugSettings();
#endif

	void ForceShutdown();

//Implementation
private:
    void MonitorShutdown();
    BOOL StartMonitor   ();

	static void  WINAPI _ServiceMain( DWORD dwArgc, LPWSTR* lpszArgv );
    static void  WINAPI _Handler    ( DWORD dwOpcode                 );
	static DWORD WINAPI _Monitor    ( void* pv                       );
};

extern CServiceModule _Module;


#include <atlcom.h>

#include <NTEventMsg.h>

#endif // !defined(__INCLUDED___PCH___MODULE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcconfig.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCConfig.cpp

Abstract:
    This file contains the implementation of the MPCConfig class,
    the configuration repository for the UploadLibrary.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

#define MINIMUM_WAKEUP          (1)
#define MAXIMUM_WAKEUP          (24*60*60)

#define MINIMUM_WAITBETWEENJOBS (1)
#define MAXIMUM_WAITBETWEENJOBS (60*60)

#define MINIMUM_BANDWIDTHUSAGE (1)
#define MAXIMUM_BANDWIDTHUSAGE (100)

#define MINIMUM_REQUESTTIMEOUT (   5)
#define MAXIMUM_REQUESTTIMEOUT (2*60)

#define MINIMUM_PACKET_SIZE (256)
#define MAXIMUM_PACKET_SIZE (256*1024)

/////////////////////////////////////////////////////////////////////////////

CMPCConfig::CMPCConfig()
{
    __ULT_FUNC_ENTRY( "CMPCConfig::CMPCConfig" );

    m_szQueueLocation          = L"%TEMP%\\QUEUE\\"; // MPC::wstring m_QueueLocation;
    m_dwQueueSize              = 10*1024*1024;       // DWORD        m_QueueSize;
                                                     //
    m_dwTiming_WakeUp          = 30*60;              // DWORD        m_Timing_WakeUp;
    m_dwTiming_WaitBetweenJobs =    30;              // DWORD        m_Timing_WaitBetweenJobs;
    m_dwTiming_BandwidthUsage  =    20;              // DWORD        m_Timing_BandwidthUsage;
    m_dwTiming_RequestTimeout  =    20;              // DWORD        m_Timing_RequestTimeout;
                                                     //
                                                     // Map          m_ConnectionTypes;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCConfig::Load( /*[in] */ const MPC::wstring& szConfigFile ,
                          /*[out]*/ bool&               fLoaded      )
{
    __ULT_FUNC_ENTRY( "CMPCConfig::Load" );

    USES_CONVERSION;

    HRESULT                  hr;
    MPC::XmlUtil             xml;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnNode;
    MPC::wstring             szValue;
    long                     lValue;
    bool                     fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Load( szConfigFile.c_str(), L"UPLOADLIBRARYCONFIG", fLoaded ));
    if(fLoaded == false)
    {
        // Something went wrong, probably missing section or invalid format.
        xml.DumpError();

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    //
    // Parse QUEUE settings.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"./QUEUE", L"LOCATION", szValue, fFound ));
    if(fFound)
    {
        m_szQueueLocation = szValue.c_str();
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"./QUEUE", L"SIZE", szValue, fFound ));
    if(fFound)
    {
        MPC::ConvertSizeUnit( szValue, m_dwQueueSize );
    }


    //
    // Parse TIMING settings.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"./TIMING/WAKEUP", L"TIME", szValue, fFound ));
    if(fFound)
    {
        MPC::ConvertTimeUnit( szValue, m_dwTiming_WakeUp );
		if(m_dwTiming_WakeUp < MINIMUM_WAKEUP) m_dwTiming_WakeUp = MINIMUM_WAKEUP;
		if(m_dwTiming_WakeUp > MAXIMUM_WAKEUP) m_dwTiming_WakeUp = MAXIMUM_WAKEUP;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"./TIMING/WAITBETWEENJOBS", L"TIME", szValue, fFound ));
    if(fFound)
    {
        MPC::ConvertTimeUnit( szValue, m_dwTiming_WaitBetweenJobs );
		if(m_dwTiming_WaitBetweenJobs < MINIMUM_WAITBETWEENJOBS) m_dwTiming_WaitBetweenJobs = MINIMUM_WAITBETWEENJOBS;
		if(m_dwTiming_WaitBetweenJobs > MAXIMUM_WAITBETWEENJOBS) m_dwTiming_WaitBetweenJobs = MAXIMUM_WAITBETWEENJOBS;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"./TIMING/BANDWIDTHUSAGE", L"PERCENTAGE", lValue, fFound ));
    if(fFound)
    {
        m_dwTiming_BandwidthUsage = lValue;
		if(m_dwTiming_BandwidthUsage < MINIMUM_BANDWIDTHUSAGE) m_dwTiming_BandwidthUsage = MINIMUM_BANDWIDTHUSAGE;
		if(m_dwTiming_BandwidthUsage > MAXIMUM_BANDWIDTHUSAGE) m_dwTiming_BandwidthUsage = MAXIMUM_BANDWIDTHUSAGE;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"./TIMING/REQUESTTIMEOUT", L"TIME", szValue, fFound ));
    if(fFound)
    {
        MPC::ConvertTimeUnit( szValue, m_dwTiming_RequestTimeout );
		if(m_dwTiming_RequestTimeout < MINIMUM_REQUESTTIMEOUT) m_dwTiming_RequestTimeout = MINIMUM_REQUESTTIMEOUT;
		if(m_dwTiming_RequestTimeout > MAXIMUM_REQUESTTIMEOUT) m_dwTiming_RequestTimeout = MAXIMUM_REQUESTTIMEOUT;
    }


    //
    // Parse PACKETS settings.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNodes( L"./PACKETS/CONNECTIONTYPE", &xdnlList ));

    for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNode )) && xdnNode != NULL; xdnNode = NULL)
    {
        DWORD dwSize;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, L"SIZE", szValue, fFound, xdnNode ));
        if(fFound == false) continue;

        MPC::ConvertSizeUnit( szValue, dwSize );
		if(dwSize < MINIMUM_PACKET_SIZE) dwSize = MINIMUM_PACKET_SIZE;
		if(dwSize > MAXIMUM_PACKET_SIZE) dwSize = MAXIMUM_PACKET_SIZE;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, L"SPEED", szValue, fFound, xdnNode ));
        if(fFound == false) continue;

        m_mConnectionTypes[szValue] = dwSize;
    }


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

MPC::wstring CMPCConfig::get_QueueLocation()
{
    __ULT_FUNC_ENTRY( "CMPCConfig::get_QueueLocation" );

    MPC::wstring szRes = m_szQueueLocation;
	int          dwLen;

	MPC::SubstituteEnvVariables( szRes );

	if((dwLen = szRes.length()) > 0)
	{
        if(szRes[dwLen-1] != L'\\') szRes += L'\\';
	}

    __ULT_FUNC_EXIT(szRes);
}

DWORD CMPCConfig::get_QueueSize()
{
    __ULT_FUNC_ENTRY( "CMPCConfig::get_QueueSize" );

    DWORD dwRes = m_dwQueueSize;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD CMPCConfig::get_Timing_WakeUp()
{
    __ULT_FUNC_ENTRY( "CMPCConfig::get_Timing_WakeUp" );

    DWORD dwRes = m_dwTiming_WakeUp;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD CMPCConfig::get_Timing_WaitBetweenJobs()
{
    __ULT_FUNC_ENTRY( "CMPCConfig::get_Timing_WaitBetweenJobs" );

    DWORD dwRes = m_dwTiming_WaitBetweenJobs;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD CMPCConfig::get_Timing_BandwidthUsage()
{
    __ULT_FUNC_ENTRY( "CMPCConfig::get_Timing_BandwidthUsage" );

    DWORD dwRes = m_dwTiming_BandwidthUsage;

    //
    // Percent of bandwidth cannot be zero...
    //
    if(dwRes == 0) dwRes = 1;


    __ULT_FUNC_EXIT(dwRes);
}

DWORD CMPCConfig::get_Timing_RequestTimeout()
{
    __ULT_FUNC_ENTRY( "CMPCConfig::get_Timing_RequestTimeout" );

    DWORD dwRes = m_dwTiming_RequestTimeout;

    __ULT_FUNC_EXIT(dwRes);
}


DWORD CMPCConfig::get_PacketSize( /*[in]*/ const MPC::wstring& szConnectionType )
{
    __ULT_FUNC_ENTRY( "CMPCConfig::get_PacketSize" );

    DWORD dwRes = MINIMUM_PACKET_SIZE;

    for(IterConst it = m_mConnectionTypes.begin(); it != m_mConnectionTypes.end(); it++)
    {
        if((*it).first == szConnectionType)
        {
            dwRes = (*it).second;
            break;
        }
    }

    __ULT_FUNC_EXIT(dwRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\module.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    module.cpp

Abstract:
    This file contains the implementation of the CServiceModule class, which is
    used to handling service-related routines.

Revision History:
    Davide Massarenti   (Dmassare)  03/14/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

      DWORD dwTimeOut  = 8*1000; // time for EXE to be idle before shutting down
const DWORD dwPause    =   1000;  // time to wait for threads to finish up

CServiceModule _Module;
MPC::NTEvent   g_NTEvents;
CMPCConfig     g_Config;

/////////////////////////////////////////////////////////////////////////////
//
// These variables control the overriding of properties for debug.
//
bool         g_Override_History          = false;
UL_HISTORY   g_Override_History_Value    = UL_HISTORY_NONE;

bool         g_Override_Persist          = false;
VARIANT_BOOL g_Override_Persist_Value    = false;

bool         g_Override_Compressed       = false;
VARIANT_BOOL g_Override_Compressed_Value = false;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

const WCHAR c_szMessageFile      [] = L"%WINDIR%\\PCHealth\\UploadLB\\Binaries\\UploadM.exe";

const WCHAR c_szRegistryLog      [] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\UploadM";
const WCHAR c_szRegistryLog_File [] = L"EventMessageFile";
const WCHAR c_szRegistryLog_Flags[] = L"TypesSupported";

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
#define DEBUG_REGKEY       L"SOFTWARE\\Microsoft\\PCHealth\\UploadM\\Debug"
#define DEBUG_TIMEOUT      L"TIMEOUT"
#define DEBUG_BREAKONSTART L"BREAKONSTART"
#define DEBUG_HISTORY      L"HISTORY"
#define DEBUG_PERSIST      L"PERSIST"
#define DEBUG_COMPRESSED   L"COMPRESSED"

void CServiceModule::ReadDebugSettings()
{
	__ULT_FUNC_ENTRY( "CServiceModule::ReadDebugSettings" );

	HRESULT     hr;
	MPC::RegKey rkBase;
	bool        fFound;

	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SetRoot( HKEY_LOCAL_MACHINE ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Attach ( DEBUG_REGKEY       ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Exists ( fFound             ));

	if(fFound)
	{
		CComVariant vValue;
				
		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, DEBUG_BREAKONSTART ));
		if(fFound && vValue.vt == VT_I4)
		{
			if(vValue.lVal == 1) DebugBreak();
			if(vValue.lVal == 2) while(vValue.lVal) ::Sleep( 100 );
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, DEBUG_TIMEOUT ));
		if(fFound && vValue.vt == VT_I4)
		{
			dwTimeOut = 1000 * vValue.lVal;
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, DEBUG_HISTORY ));
		if(fFound && vValue.vt == VT_I4 && vValue.lVal != -1)
		{
			g_Override_History       =             true;
			g_Override_History_Value = (UL_HISTORY)vValue.lVal;
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, DEBUG_PERSIST ));
		if(fFound && vValue.vt == VT_I4 && vValue.lVal != -1)
		{
			g_Override_Persist       = true;
			g_Override_Persist_Value = vValue.lVal ? VARIANT_TRUE : VARIANT_FALSE;
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, DEBUG_COMPRESSED ));
		if(fFound && vValue.vt == VT_I4 && vValue.lVal != -1)
		{
			g_Override_Compressed       = true;
			g_Override_Compressed_Value = vValue.lVal ? VARIANT_TRUE : VARIANT_FALSE;
		}
	}

	__ULT_FUNC_CLEANUP;
}
#endif

/////////////////////////////////////////////////////////////////////////////

static const WCHAR s_SvcHost[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost";

static const WCHAR s_Key  [] = L"System\\CurrentControlSet\\Services\\%s";
static const WCHAR s_Key2 [] = L"\\Parameters";
static const WCHAR s_Name [] = L"ServiceDll";
static const WCHAR s_Value[] = L"%WINDIR%\\PCHealth\\HelpCtr\\Binaries\\pchsvc.dll";

static HRESULT ServiceHost_Install( LPCWSTR szName, LPCWSTR szGroup )
{
	__ULT_FUNC_ENTRY( "ServiceHost_Install" );

	HRESULT hr;


    //
    // Register the message file into the registry.
    //
    {
        MPC::wstring szPath ( c_szMessageFile ); MPC::SubstituteEnvVariables( szPath );
        MPC::RegKey  rkEventLog;
        CComVariant  vValue;


        __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.Attach ( c_szRegistryLog                    ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.Create (                                    ));

        vValue = szPath.c_str(); __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.put_Value( vValue, c_szRegistryLog_File  ));
        vValue = (long)0x1F    ; __MPC_EXIT_IF_METHOD_FAILS(hr, rkEventLog.put_Value( vValue, c_szRegistryLog_Flags ));
    }


	{
		WCHAR rgRegPath[_MAX_PATH]; swprintf( rgRegPath, s_Key, szName ); wcscat( rgRegPath, s_Key2 );

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::RegKey_Value_Write( s_Value, rgRegPath, s_Name, HKEY_LOCAL_MACHINE, true ));
	}

	{
		MPC::RegKey		 rk;
		MPC::WStringList lstValue;
		bool             fFound;
		bool             fGot = false;

		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach (                     s_SvcHost      ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Create (                                    ));


		if(SUCCEEDED(rk.Read( lstValue, fFound, szGroup )))
		{
			for(MPC::WStringIterConst it = lstValue.begin(); it != lstValue.end(); it++)
			{
				if(!MPC::StrICmp( *it, szName ))
				{
					fGot = true;
					break;
				}
			}
		}

		if(fGot == false)
		{
			lstValue.push_back( szName );
			__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Write( lstValue, szGroup ));
		}
	}

	hr = S_OK;


	__ULT_FUNC_CLEANUP;

	__ULT_FUNC_EXIT(hr);
}

static HRESULT ServiceHost_Uninstall( LPCWSTR szName, LPCWSTR szGroup )
{
	__ULT_FUNC_ENTRY( "ServiceHost_Uninstall" );

	HRESULT hr;

	{
		WCHAR	    rgRegPath[_MAX_PATH]; swprintf( rgRegPath, s_Key, szName );
		MPC::RegKey rk;

		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach (                     rgRegPath      ));
		(void)rk.Delete( /*fDeep*/true );
	}

	{
		MPC::RegKey      rk;
		MPC::WStringList lstValue;
		bool             fFound;


		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach (                     s_SvcHost      ));

		if(SUCCEEDED(rk.Read( lstValue, fFound, szGroup )))
		{
			MPC::WStringIterConst it   = lstValue.begin();
			bool                  fGot = false;

			while(it != lstValue.end())
			{
				MPC::WStringIterConst it2 = it++;

				if(!MPC::StrICmp( *it2, szName ))
				{
					lstValue.erase( it2 );
					fGot = true;
				}
			}

			if(fGot)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Write( lstValue, szGroup ));
			}
		}
	}

	hr = S_OK;


	__ULT_FUNC_CLEANUP;

	__ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

CServiceModule::CServiceModule()
{
    m_hEventShutdown = NULL;  //  HANDLE                m_hEventShutdown;
    m_dwThreadID     = 0;     //  DWORD                 m_dwThreadID;
    m_hMonitor       = NULL;  //  HANDLE                m_hMonitor;
    m_bActivity      = FALSE; //  BOOL                  m_bActivity;
	                          //  						
    m_szServiceName  = NULL;  //  LPCWSTR               m_szServiceName;
	m_iDisplayName   = 0;     //  UINT                  m_iDisplayName;
	m_iDescription   = 0;     //  UINT                  m_iDescription;
    m_hServiceStatus = NULL;  //  SERVICE_STATUS_HANDLE m_hServiceStatus;
                              //  SERVICE_STATUS        m_status;
    m_bService       = FALSE; //  BOOL                  m_bService;

	::ZeroMemory( &m_status, sizeof( m_status ) );
}

CServiceModule::~CServiceModule()
{
    if(m_hEventShutdown) ::CloseHandle( m_hEventShutdown );
	if(m_hMonitor      ) ::CloseHandle( m_hMonitor       );
}

/////////////////////////////////////////////////////////////////////////////

LONG CServiceModule::Lock()
{
    LONG lCount = CComModule::Lock();

	return lCount;
}

LONG CServiceModule::Unlock()
{
    LONG lCount = CComModule::Unlock();

    if(lCount == 0)
    {
        m_bActivity = TRUE;

        if(m_hEventShutdown) ::SetEvent( m_hEventShutdown ); // tell monitor that we transitioned to zero
    }

	return lCount;
}

void CServiceModule::MonitorShutdown()
{
    while(1)
    {
        DWORD dwWait;

        m_bActivity = FALSE;
        dwWait      = ::WaitForSingleObject( m_hEventShutdown, dwTimeOut );

        if(dwWait == WAIT_OBJECT_0) continue; // We are alive...

		if(g_Root.CanContinue()) continue;

		//
		// If no activity let's really bail.
		//
        if(m_bActivity == FALSE && m_nLockCnt <= 0)
        {
            ::CoSuspendClassObjects();

            if(m_bActivity == FALSE && m_nLockCnt <= 0) break;
        }
    }

    ForceShutdown();
}

void CServiceModule::ForceShutdown()
{

	//
	// Tell process to exit.
	//
    ::PostThreadMessage( m_dwThreadID, WM_QUIT, 0, 0 );
}

BOOL CServiceModule::StartMonitor()
{
    DWORD dwThreadID;


    m_hMonitor = ::CreateThread( NULL, 0, _Monitor, this, 0, &dwThreadID );
    if(m_hMonitor == NULL) return FALSE;


    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CServiceModule::RegisterServer( BOOL bRegTypeLib, BOOL bService, LPCWSTR szSvcHostGroup )
{
	HRESULT hr;

    // Remove any previous service since it may point to the incorrect file
    Uninstall( szSvcHostGroup );

    if(bService)
    {
        // Create service
        Install( szSvcHostGroup );
    }

    // Add object entries
    if(FAILED(hr = CComModule::RegisterServer( TRUE ))) return hr;

	if(FAILED(hr = _Module.UpdateRegistryFromResource( IDR_UPLOADMANAGER, TRUE ))) return hr;

	return S_OK;
}

HRESULT CServiceModule::UnregisterServer( LPCWSTR szSvcHostGroup )
{
	HRESULT hr;

    // Remove service
    Uninstall( szSvcHostGroup );

    // Remove object entries
    if(FAILED(hr = CComModule::UnregisterServer( TRUE ))) return hr;

	if(FAILED(hr = _Module.UpdateRegistryFromResource( IDR_UPLOADMANAGER, FALSE ))) return hr;

	return S_OK;
}

void CServiceModule::Init( _ATL_OBJMAP_ENTRY* p, HINSTANCE h, LPCWSTR szServiceName, UINT iDisplayName, UINT iDescription, const GUID* plibid )
{
    CComModule::Init( p, h, plibid );


    m_szServiceName = szServiceName;
	m_iDisplayName  = iDisplayName;
	m_iDescription  = iDescription;

    // set up the initial service status
    m_hServiceStatus = NULL;

    m_status.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState            = SERVICE_STOPPED;
    m_status.dwControlsAccepted        = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode           = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint              = 0;
    m_status.dwWaitHint                = 0;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL      bResult = FALSE;
    SC_HANDLE hSCM    = ::OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );


    if((hSCM = ::OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS )))
    {
        SC_HANDLE hService;

        if((hService = ::OpenServiceW( hSCM, m_szServiceName, SERVICE_QUERY_CONFIG )))
        {
            bResult = TRUE;

            ::CloseServiceHandle( hService );
        }

        ::CloseServiceHandle( hSCM );
    }

    return bResult;
}

BOOL CServiceModule::Install( LPCWSTR szSvcHostGroup )
{
    BOOL      bResult = FALSE;
    SC_HANDLE hSCM;


    if((hSCM = ::OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS )))
    {
		LPCWSTR             szDisplayName;
        WCHAR               rgDisplayName[512];
        WCHAR               rgDescription[512];
        WCHAR               rgFilePath   [_MAX_PATH];
        SC_HANDLE           hService;
		DWORD               dwServiceType;
		OSVERSIONINFOEXW    ver;
		DWORD               dwStartType;


        if(szSvcHostGroup)
		{
			dwServiceType = SERVICE_WIN32_SHARE_PROCESS;

			swprintf( rgFilePath, L"%%SystemRoot%%\\System32\\svchost.exe -k %s", szSvcHostGroup );
		}
		else
		{
			dwServiceType = SERVICE_WIN32_OWN_PROCESS;

			::GetModuleFileNameW( NULL, rgFilePath, _MAX_PATH );
		}

		if(::LoadStringW( _Module.GetResourceInstance(), m_iDisplayName, rgDisplayName, MAXSTRLEN(rgDisplayName) ) != 0)
		{
			szDisplayName = rgDisplayName;
		}
		else
		{
			szDisplayName = m_szServiceName;
		}

		if(::LoadStringW( _Module.GetResourceInstance(), m_iDescription, rgDescription, MAXSTRLEN(rgDescription) ) == 0)
		{
			rgDescription[0] = 0;
		}

		::ZeroMemory( &ver, sizeof(ver) ); ver.dwOSVersionInfoSize = sizeof(ver);
		::GetVersionExW( (LPOSVERSIONINFOW)&ver );
		if(ver.wSuiteMask & VER_SUITE_DATACENTER)
		{
		    dwStartType = SERVICE_DISABLED;
		}
		else
		{
		    dwStartType = SERVICE_DEMAND_START;
		}

        hService = ::OpenServiceW( hSCM, m_szServiceName, SERVICE_QUERY_CONFIG );
        if(hService == NULL)
        {
			hService = ::CreateServiceW( hSCM                ,
                                      	 m_szServiceName     ,
                                      	 szDisplayName       ,
                                      	 SERVICE_ALL_ACCESS  ,
                                      	 dwServiceType       ,
                                      	 dwStartType         ,
                                      	 SERVICE_ERROR_NORMAL,
                                      	 rgFilePath          ,
                                      	 NULL                ,
                                      	 NULL                ,
                                      	 L"RPCSS\0"          ,
                                      	 NULL                ,
                                      	 NULL                );
		}

        if(hService)
        {
            if(rgDescription[0])
            {
                SERVICE_DESCRIPTIONW     desc;     ::ZeroMemory( &desc    , sizeof(desc    ) );
				SERVICE_FAILURE_ACTIONSW recovery; ::ZeroMemory( &recovery, sizeof(recovery) ); 
				SC_ACTION                actions[] =
				{
					{ SC_ACTION_RESTART, 100 },
					{ SC_ACTION_RESTART, 100 },
					{ SC_ACTION_NONE   , 100 },
				};

                desc.lpDescription = rgDescription;

				recovery.dwResetPeriod = 24 * 60 * 60; // 1 day
				recovery.cActions      = ARRAYSIZE(actions);
				recovery.lpsaActions   =           actions;

                ::ChangeServiceConfig2W( hService, SERVICE_CONFIG_DESCRIPTION    , &desc     );
                ::ChangeServiceConfig2W( hService, SERVICE_CONFIG_FAILURE_ACTIONS, &recovery );
            }

            if(szSvcHostGroup)
            {
				if(SUCCEEDED(ServiceHost_Install( m_szServiceName, szSvcHostGroup )))
				{
                    bResult = TRUE;
                }
            }
            else
            {
                bResult = TRUE;
            }

            ::CloseServiceHandle( hService );
        }

        if(bResult == FALSE)
        {
			(void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, UPLOADM_ERR_CANNOTCREATESERVICE, NULL );
        }

        ::CloseServiceHandle( hSCM );
    }
    else
    {
		(void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, UPLOADM_ERR_CANNOTOPENSCM, NULL );
    }

    return bResult;
}

BOOL CServiceModule::Uninstall( LPCWSTR szSvcHostGroup )
{
    BOOL      bResult = FALSE;
    SC_HANDLE hSCM;


    if((hSCM = ::OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS )))
    {
        SC_HANDLE hService;

        if((hService = ::OpenServiceW( hSCM, m_szServiceName, SERVICE_STOP | DELETE )))
        {
            SERVICE_STATUS status;

            ::ControlService( hService, SERVICE_CONTROL_STOP, &status );

            bResult = ::DeleteService( hService );
			if(bResult)
			{
				::Sleep( 2000 ); // Let the service stop down...

				if(szSvcHostGroup)
				{
					if(FAILED(ServiceHost_Uninstall( m_szServiceName, szSvcHostGroup )))
					{
						bResult = FALSE;
					}
				}
			}

            if(bResult == FALSE)
            {
				(void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, UPLOADM_ERR_CANNOTDELETESERVICE, NULL );
            }

            ::CloseServiceHandle( hService );
        }

        ::CloseServiceHandle( hSCM );
    }
    else
    {
		(void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, UPLOADM_ERR_CANNOTOPENSCM, NULL );
    }


    return bResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
BOOL CServiceModule::Start( BOOL bService )
{
    SERVICE_TABLE_ENTRYW st[] =
    {
        { (LPWSTR)m_szServiceName, _ServiceMain },
        { NULL                   , NULL         }
    };

    m_hEventShutdown = ::CreateEvent( NULL, FALSE, FALSE, NULL );
    if(m_hEventShutdown == NULL) return FALSE;

    if((m_bService = bService) && !::StartServiceCtrlDispatcherW( st ))
    {
		DWORD dwRes = ::GetLastError();

		m_bService = FALSE;
    }

    if(m_bService == FALSE)
    {
		if(StartMonitor() == FALSE) return FALSE;

        if(FAILED(Run())) return FALSE;
    }

	return TRUE;
}

void CServiceModule::ServiceMain( DWORD dwArgc, LPWSTR lpszArgv[] )
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;

    if((m_hServiceStatus = ::RegisterServiceCtrlHandlerW( m_szServiceName, _Handler )))
    {
		SetServiceStatus( SERVICE_START_PENDING );

		m_status.dwWin32ExitCode = S_OK;
		m_status.dwCheckPoint    = 0;
		m_status.dwWaitHint      = 0;

		// When the Run function returns, the service has stopped.
		Run();

		SetServiceStatus( SERVICE_STOPPED );

		(void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, UPLOADM_INFO_STOPPED, NULL );
    }
    else
    {
        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, UPLOADM_ERR_REGISTERHANDLER, NULL );
    }

}

void CServiceModule::Handler( DWORD dwOpcode )
{
    switch(dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus( SERVICE_STOP_PENDING );
        ForceShutdown();
        break;

    case SERVICE_CONTROL_PAUSE:
        break;

    case SERVICE_CONTROL_CONTINUE:
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        break;

    default:
		(void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, UPLOADM_ERR_BADSVCREQUEST, NULL );
    }
}

HRESULT CServiceModule::Run()
{
    __ULT_FUNC_ENTRY( "CServiceModule::Run" );

	HRESULT hr;
	MSG     msg;


    m_dwThreadID = ::GetCurrentThreadId();


	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoInitializeEx( NULL, COINIT_MULTITHREADED )); // We need to be a multi-threaded application.


	__MPC_EXIT_IF_METHOD_FAILS(hr, RegisterClassObjects( CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE ));

	(void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, UPLOADM_INFO_STARTED, NULL );
    if(m_bService)
    {
        SetServiceStatus( SERVICE_RUNNING );
    }



    //
    // Load the state of the queue.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, g_Root.Init());

	while(::GetMessage( &msg, 0, 0, 0 ))
	{
		::DispatchMessage( &msg );
	}

    _Module.RevokeClassObjects();
	::Sleep( dwPause ); //wait for any threads to finish


    hr = S_OK;

    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

void CServiceModule::SetServiceStatus( DWORD dwState )
{
    m_status.dwCurrentState = dwState;

    ::SetServiceStatus( m_hServiceStatus, &m_status );
}

////////////////////////////////////////////////////////////////////////////////

void WINAPI CServiceModule::_ServiceMain( DWORD dwArgc, LPWSTR* lpszArgv )
{
    _Module.ServiceMain( dwArgc, lpszArgv );
}

void WINAPI CServiceModule::_Handler( DWORD dwOpcode )
{
    _Module.Handler( dwOpcode );
}

DWORD WINAPI CServiceModule::_Monitor( void* pv )
{
	((CServiceModule*)pv)->MonitorShutdown();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\test\uploadclient.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    UploadManager.cpp

Abstract:
    This file contains the initialization portion of the Upload Manager

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"

#include <UploadManager_i.c>

HRESULT QueueJob( LPCTSTR szSigClient,
				  LPCTSTR szServer   ,
				  LPCTSTR szProvider ,
				  LPCTSTR szUsername ,
				  LPCTSTR szPassword ,
				  LPCTSTR szFilename ,
				  BOOL    escalated  )
{
    __ULT_FUNC_ENTRY( "QueueJob" );

    HRESULT                hr;
    CComPtr<IMPCUpload>    mpcuRoot;
    CComPtr<IMPCUploadJob> mpcujJob;
	CComBSTR               bstrTmp;
	DWORD                  fFlags;
	UL_MODE                fMode;
	BOOL                   fQueue;
	long                   lPriority;

	if(escalated)
	{
		fFlags    = 0;
		fMode     = UL_FOREGROUND;
		fQueue    = FALSE;
		lPriority = 100;
	}
	else
	{
		fFlags    = UL_KEEP_LOG;
		fMode     = UL_BACKGROUND;
		fQueue    = TRUE;
		lPriority = 0;
	}


    if(FAILED(hr = CoCreateInstance( CLSID_MPCUpload, NULL, CLSCTX_SERVER, IID_IMPCUpload, (void**)&mpcuRoot )))
	{
        __ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}


    if(FAILED(hr = mpcuRoot->CreateJob( &mpcujJob )))
	{
        __ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}


	bstrTmp = szSigClient;
	if(FAILED(hr = mpcujJob->put_Sig( bstrTmp )))
	{
        __ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}

	bstrTmp = szServer;
	if(FAILED(hr = mpcujJob->put_Server( bstrTmp )))
	{
        __ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}

	bstrTmp = szProvider;
	if(FAILED(hr = mpcujJob->put_ProviderID( bstrTmp )))
	{
        __ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}

	if(szUsername)
	{
		bstrTmp = szUsername;
		if(FAILED(hr = mpcujJob->put_Username( bstrTmp )))
		{
			__ULT_TRACE_HRESULT(hr);
			__ULT_FUNC_LEAVE;
		}
	}

	if(szPassword)
	{
		bstrTmp = szPassword;
		if(FAILED(hr = mpcujJob->put_Password( bstrTmp )))
		{
			__ULT_TRACE_HRESULT(hr);
			__ULT_FUNC_LEAVE;
		}
	}

	if(FAILED(hr = mpcujJob->put_Flags( fFlags )))
	{
		__ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}

	if(FAILED(hr = mpcujJob->put_Mode( fMode )))
	{
		__ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}

	if(FAILED(hr = mpcujJob->put_Queue( fQueue )))
	{
		__ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}

	if(FAILED(hr = mpcujJob->put_Priority( lPriority )))
	{
		__ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}


	bstrTmp = szFilename;
	if(FAILED(hr = mpcujJob->GetDataFromFile( bstrTmp )))
	{
		__ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}

	if(FAILED(hr = mpcujJob->ActivateAsync()))
	{
		__ULT_TRACE_HRESULT(hr);
		__ULT_FUNC_LEAVE;
	}
	

    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain( HINSTANCE hInstance     ,
                                 HINSTANCE hPrevInstance ,
                                 LPTSTR    lpCmdLine     ,
                                 int       nShowCmd      )
{
    int nRet = 0;
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    HRESULT hRes = CoInitialize( NULL );
#endif

    _ASSERTE( SUCCEEDED(hRes) );

    CoUninitialize();

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcconnection.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCConnection.h

Abstract:
    This file contains the declaration of the CMPCConnection class, which is
    used as the entry point into the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULMANAGER___MPCCONNECTION_H___)
#define __INCLUDED___ULMANAGER___MPCCONNECTION_H___


class ATL_NO_VTABLE CMPCConnection : // Hungarian: mpcc
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public CComCoClass<CMPCConnection, &CLSID_MPCConnection>,
    public IDispatchImpl<IMPCConnection, &IID_IMPCConnection, &LIBID_UPLOADMANAGERLib>
{
public:
    CMPCConnection();

DECLARE_CLASSFACTORY_SINGLETON(CMPCConnection)
DECLARE_REGISTRY_RESOURCEID(IDR_MPCCONNECTION)
DECLARE_NOT_AGGREGATABLE(CMPCConnection)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMPCConnection)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IMPCConnection)
END_COM_MAP()

public:
    // IMPCConnection
    STDMETHOD(get_Available)( /*[out, retval]*/ VARIANT_BOOL *pfOnline     );
    STDMETHOD(get_IsAModem )( /*[out, retval]*/ VARIANT_BOOL *pfModem      );
    STDMETHOD(get_Bandwidth)( /*[out, retval]*/ long         *pdwBandwidth );
};


#endif // !defined(__INCLUDED___ULMANAGER___MPCCONNECTION_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcconfig.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCConfig.h

Abstract:
    This file contains the declaration of the MPCConfig class,
    the configuration repository for the UploadLibrary.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULMANAGER___MPCCONFIG_H___)
#define __INCLUDED___ULMANAGER___MPCCONFIG_H___


#define CONNECTIONTYPE_MODEM L"MODEM"
#define CONNECTIONTYPE_LAN   L"LAN"


class CMPCConfig // Hungarian: mpcc
{
    typedef std::map< MPC::wstring, DWORD > Map;
    typedef Map::iterator                   Iter;
    typedef Map::const_iterator             IterConst;


    MPC::wstring m_szQueueLocation;
    DWORD        m_dwQueueSize;

    DWORD        m_dwTiming_WakeUp;
    DWORD        m_dwTiming_WaitBetweenJobs;
    DWORD        m_dwTiming_BandwidthUsage;
    DWORD        m_dwTiming_RequestTimeout;

    Map          m_mConnectionTypes;

public:
    CMPCConfig();

    HRESULT Load( /*[in]*/ const MPC::wstring& szConfigFile, /*[out]*/ bool& fLoaded );

    MPC::wstring get_QueueLocation         (                                               );
    DWORD        get_QueueSize             (                                               );
    DWORD        get_Timing_WakeUp         (                                               );
    DWORD        get_Timing_WaitBetweenJobs(                                               );
    DWORD        get_Timing_BandwidthUsage (                                               );
    DWORD        get_Timing_RequestTimeout (                                               );
    DWORD        get_PacketSize            ( /*[in]*/ const MPC::wstring& szConnectionType );
};


#endif // !defined(__INCLUDED___ULMANAGER___MPCCONFIG_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcconnection.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCConnection.cpp

Abstract:
    This file contains the implementation of the CMPCConnection class, which is
    used as the entry point into the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"

CMPCConnection::CMPCConnection()
{
    __ULT_FUNC_ENTRY( "CMPCConnection::CMPCConnection" );
}


STDMETHODIMP CMPCConnection::get_Available( /*[out, retval]*/ VARIANT_BOOL *pfOnline )
{
    __ULT_FUNC_ENTRY( "CMPCConnection::get_Available" );

    DWORD dwMode = 0;


    //
    // First of all, set the values to some meaningful default.
    //
    if(pfOnline) *pfOnline = VARIANT_FALSE;

    if(InternetGetConnectedState( &dwMode, 0 ) == TRUE)
    {
        if(pfOnline) *pfOnline = VARIANT_TRUE;
    }


    __ULT_FUNC_EXIT(S_OK);
}

STDMETHODIMP CMPCConnection::get_IsAModem( /*[out, retval]*/ VARIANT_BOOL *pfModem )
{
    __ULT_FUNC_ENTRY( "CMPCConnection::get_IsAModem" );

    DWORD dwMode = 0;


    //
    // First of all, set the values to some meaningful default.
    //
    if(pfModem) *pfModem = VARIANT_TRUE;

    if(InternetGetConnectedState( &dwMode, 0 ) == TRUE)
    {
        if(pfModem)
        {
            if(dwMode & INTERNET_CONNECTION_MODEM) *pfModem = VARIANT_TRUE;
            if(dwMode & INTERNET_CONNECTION_LAN  ) *pfModem = VARIANT_FALSE;
        }
    }


    __ULT_FUNC_EXIT(S_OK);
}

STDMETHODIMP CMPCConnection::get_Bandwidth( /*[out, retval]*/ long *plBandwidth )
{
    __ULT_FUNC_ENTRY( "CMPCConnection::get_Bandwidth" );

    HRESULT hr;
    DWORD   dwMode = 0;


	__MPC_SET_ERROR_AND_EXIT(hr, E_NOTIMPL);


    //
    // First of all, set the values to some meaningful default.
    //
    if(plBandwidth) *plBandwidth = 28800;

    if(InternetGetConnectedState( &dwMode, 0 ) == TRUE)
    {
        //
        // NOTICE: under Win9X it's not possible to know the actual connection speed...
        //
        if(plBandwidth)
        {
            if(dwMode & INTERNET_CONNECTION_MODEM) *plBandwidth =  28800;
            if(dwMode & INTERNET_CONNECTION_LAN  ) *plBandwidth = 128000;
        }
    }

	hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpctransportagent.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCTransportAgent.cpp

Abstract:
    This file contains the implementation of the CMPCTransportAgent class,
    which is responsible for transfering the data.

Revision History:
    Davide Massarenti   (Dmassare)  04/18/99
        created

******************************************************************************/

#include "stdafx.h"

#include <process.h>


//
// Not defined under VC6
//
#ifndef INVALID_SET_FILE_POINTER
#define INVALID_SET_FILE_POINTER (DWORD)-1
#endif


#define TIMING_SECOND       (1000)
#define TIMING_NOCONNECTION (60 * TIMING_SECOND)


#define QUERY_STRING_USERNAME L"OnlineID"
#define QUERY_STRING_PASSWORD L"OnlineIDPassword"

#define REQUEST_VERB    L"POST"
#define REQUEST_VERSION L"HTTP/1.1"


static LPCWSTR rgAcceptedTypes[] =
{
    L"application/uploadlibrary",
    NULL
};

static const WCHAR s_ContentType[] = L"Content-Type: application/x-www-form-urlencoded\r\n";

#define RETRY_MAX    (10)

#define RETRY_SLOW   (30*60)
#define RETRY_MEDIUM ( 1*60)
#define RETRY_FAST   (    5)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CMPCRequestTimeout::CMPCRequestTimeout( /*[in]*/ CMPCTransportAgent& mpcta ) : m_mpcta( mpcta )
{
                     // CMPCTransportAgent& m_mpcta;
    m_dwTimeout = 0; // DWORD               m_dwTimeout;
}


HRESULT CMPCRequestTimeout::Run()
{
    __ULT_FUNC_ENTRY( "CMPCRequestTimeout::Run" );

    HRESULT hr;


    while(Thread_IsAborted() == false)
    {
        DWORD dwTimeout;

        ////////////////////////////////////////
        //
        // Start of Critical Section.
        //
        MPC::SmartLock<_ThreadModel> lock( this );

        if(m_dwTimeout == 0)
        {
            dwTimeout = 0;
        }
        else
        {
            dwTimeout = m_dwTimeout - ::GetTickCount();
        }

        lock = NULL; // Unlock.
        //
        // End of Critical Section.
        //
        ////////////////////////////////////////

        if((dwTimeout                                                      >  0x7FFFFFFF  ) || // Timer already expired.
           (Thread_WaitForEvents( NULL, dwTimeout ? dwTimeout : INFINITE ) == WAIT_TIMEOUT)  )
        {
            ////////////////////////////////////////
            //
            // Start of Critical Section.
            //
            lock = this;

            m_mpcta.CloseConnection();

            m_dwTimeout = 0;

            lock = NULL; // Unlock.
            //
            // End of Critical Section.
            //
            ////////////////////////////////////////
        }
    }

    Thread_Abort(); // To tell the MPC:Thread object to close the worker thread...

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}


HRESULT CMPCRequestTimeout::SetTimeout( /*[in]*/ DWORD dwTimeout )
{
    __ULT_FUNC_ENTRY( "CMPCRequestTimeout::SetTimeout" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    m_dwTimeout = dwTimeout + ::GetTickCount();


    if(Thread_IsRunning() == false)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, Run, NULL ));
    }

    Thread_Signal();

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CMPCTransportAgent::CMPCTransportAgent()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::CMPCTransportAgent" );


    m_mpcuRoot             = NULL;             // CMPCUpload*     m_mpcuRoot;             // private
    m_mpcujCurrentJob      = NULL;             // CMPCUploadJob*  m_mpcujCurrentJob;      // private
                                               //
    m_fState               = TA_IDLE;          // TA_STATE        m_fState;               // private
    m_fNextState           = TA_IDLE;          // TA_STATE        m_fNextState;           // private
    m_fLastError           = TA_NO_CONNECTION; // TA_ERROR_RATING m_fLastError;           // private
    m_fUseOldProtocol      = false;            // bool            m_fUseOldProtocol;      // private
    m_iRetries_Open        = 0;                // int             m_iRetries_Open;        // private
    m_iRetries_Write       = 0;                // int             m_iRetries_Write;       // private
    m_iRetries_FailedJob   = 0;                // ULONG           m_iRetries_FailedJob;   // private
                                               //
                                               // MPC::wstring    m_szLastServer;         // private
    m_dwLastServerPort     = 0;                // DWORD           m_dwLastServerPort;     // private
    m_hSession             = NULL;             // HINTERNET       m_hSession;             // private
    m_hConn                = NULL;             // HINTERNET       m_hConn;                // private
    m_hReq                 = NULL;             // HINTERNET       m_hReq;                 // private
                                               // MPC::URL        m_URL;                  // private
                                               //
    m_dwTransmission_Start = 0;                // DWORD           m_dwTransmission_Start; // private
    m_dwTransmission_End   = 0;                // DWORD           m_dwTransmission_End;   // private
    m_dwTransmission_Next  = 0;                // DWORD           m_dwTransmission_Next;  // private
}

CMPCTransportAgent::~CMPCTransportAgent()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::~CMPCTransportAgent" );


    //
    // This will force the worker thread to exit any WININET function,
    // so it can process the Abort request.
    //
    (void)CloseConnection();

    //
    // Stop the worker thread.
    //
    Thread_Wait();

    (void)ReleaseJob();
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCTransportAgent::LinkToSystem( /*[in]*/ CMPCUpload* mpcuRoot )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::LinkToSystem" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    m_mpcuRoot = mpcuRoot;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, Run, NULL ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::Run()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::Run" );

    HRESULT hr;


    while(1)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WaitEvents());

        if(Thread_IsAborted()) break;


        //
        // Value != 0 means it's not time to send anything.
        //
        if(WaitForNextTransmission() != 0) continue;
        m_dwTransmission_Start = 0;
        m_dwTransmission_End   = 0;
        m_dwTransmission_Next  = 0;


        //
        // Process the request.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ExecLoop());
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    //
    // Stop the worker thread.
    //
    Thread_Abort();

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::ExecLoop()
{
#define DO_ACTION_AND_LEAVE_IF_FAILS(hr,code) if(FAILED(hr = code)) { __MPC_EXIT_IF_METHOD_FAILS(hr, CheckInternetError( hr )); break; }

    __ULT_FUNC_ENTRY( "CMPCTransportAgent::ExecLoop" );

    HRESULT hr;

    m_fState = m_fNextState;
    switch(m_fState)
    {
    case TA_IDLE:
        break;

    case TA_INIT:
        //
        // Important, leave this call outside Locked Sections!!
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcujCurrentJob->try_Status( UL_ACTIVE, UL_TRANSMITTING ));

        m_fNextState = TA_OPEN; // Prepare to move to the next state.

        //
        // Parse the URL. The check should already been made by the put_XXX methods...
        //
        {
            CComBSTR bstrServer;
            CComBSTR bstrUserName;
            CComBSTR bstrPassword;

            (void)m_mpcujCurrentJob->get_Server  ( &bstrServer   );
            (void)m_mpcujCurrentJob->get_Username( &bstrUserName );
            (void)m_mpcujCurrentJob->get_Password( &bstrPassword );

            DO_ACTION_AND_LEAVE_IF_FAILS(hr, m_URL.put_URL( SAFEBSTR( bstrServer ) ));

            //
            // If there's a username, format the URL for Highlander authentication (?OnlineID=<username>&OnlineIDPassword=<password>).
            //
            if(bstrUserName && ::SysStringLen( bstrUserName ))
            {
                DO_ACTION_AND_LEAVE_IF_FAILS(hr, m_URL.AppendQueryParameter( QUERY_STRING_USERNAME, SAFEBSTR( bstrUserName ) ));
                DO_ACTION_AND_LEAVE_IF_FAILS(hr, m_URL.AppendQueryParameter( QUERY_STRING_PASSWORD, SAFEBSTR( bstrPassword ) ));

                DO_ACTION_AND_LEAVE_IF_FAILS(hr, m_URL.CheckFormat());
            }
        }

        DO_ACTION_AND_LEAVE_IF_FAILS(hr, OpenConnection());
        break;

    case TA_OPEN:
        m_fNextState = TA_WRITE; // Prepare to move to the next state.

        DO_ACTION_AND_LEAVE_IF_FAILS(hr, RecordStartOfTransmission(      ));
        DO_ACTION_AND_LEAVE_IF_FAILS(hr, CreateJobOnTheServer     (      ));
        DO_ACTION_AND_LEAVE_IF_FAILS(hr, RecordEndOfTransmission  ( true ));
        break;

    case TA_WRITE:
        DO_ACTION_AND_LEAVE_IF_FAILS(hr, RecordStartOfTransmission(      ));
        DO_ACTION_AND_LEAVE_IF_FAILS(hr, SendNextChunk            (      ));
        DO_ACTION_AND_LEAVE_IF_FAILS(hr, RecordEndOfTransmission  ( true ));
        break;

    case TA_DONE:
        DO_ACTION_AND_LEAVE_IF_FAILS(hr, RecordEndOfTransmission( false ));

        //
        // Important, leave this call outside Locked Sections!!
        //
        m_mpcujCurrentJob->try_Status( UL_TRANSMITTING, UL_COMPLETED );

        __MPC_EXIT_IF_METHOD_FAILS(hr, ReleaseJob());
        break;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::WaitEvents()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::WaitEvents" );

    HRESULT        hr;
    CMPCUploadJob* mpcujJob = NULL;
    DWORD          dwSleep  = WaitForNextTransmission();
	DWORD          dwWait;
    bool           fFound;

    //
    // It's important to put 'fSignal' to false, otherwise the TransportAgent will wake up itself...
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcuRoot->RescheduleJobs( false, &dwWait ));

    //
    // Wait until it's time to send something or we receive a signal.
    //
    (void)Thread_WaitForEvents( NULL, (dwSleep == INFINITE) ? dwWait : dwSleep );

    if(Thread_IsAborted()) // Master has requested to abort...
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcuRoot->RescheduleJobs( false            ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcuRoot->GetFirstJob   ( mpcujJob, fFound ));


    //
    // We are transmitting a job, check if it's still the top job.
    //
    if(m_mpcujCurrentJob && m_mpcujCurrentJob != mpcujJob)
    {
        //
        // No, stop sending.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ReleaseJob());
    }

    //
    // We are not transmitting and there's a job on top of the queue, so activate it.
    //
    if(m_mpcujCurrentJob == NULL && mpcujJob)
    {
        // CODEWORK: check if a connection is available...

        __MPC_EXIT_IF_METHOD_FAILS(hr, AcquireJob( mpcujJob ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(mpcujJob) mpcujJob->Release();

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCTransportAgent::AcquireJob( /*[in]*/ CMPCUploadJob* mpcujJob )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::AcquireJob" );

    _ASSERT( mpcujJob != NULL );

    HRESULT hr;
    ULONG   lSeq;


    m_mpcujCurrentJob = mpcujJob; mpcujJob->AddRef();


    //
    // If we are uploading a different job, reset failure counters.
    //
    if(SUCCEEDED(m_mpcujCurrentJob->get_Sequence( &lSeq )))
    {
        if(m_iRetries_FailedJob != lSeq)
        {
            m_iRetries_Open  = 0;
            m_iRetries_Write = 0;
        }
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, RestartJob());

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT CMPCTransportAgent::ReleaseJob()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::ReleaseJob" );

    HRESULT hr;


    if(m_mpcujCurrentJob)
    {
        m_mpcujCurrentJob->try_Status( UL_TRANSMITTING, UL_ACTIVE );

        m_mpcujCurrentJob->Release();
        m_mpcujCurrentJob = NULL;
    }

	//
	// We don't try to reuse the connection between jobs, because each job could have different proxy settings.
	//
    (void)CloseConnection();

    m_fNextState = TA_IDLE;
    hr           = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::RestartJob()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::RestartJob" );

    HRESULT hr;


    m_fNextState = TA_INIT;
    hr           = S_OK;


    __ULT_FUNC_EXIT(hr);
}


HRESULT CMPCTransportAgent::AbortJob( /*[in]*/ HRESULT hrErrorCode     ,
                                      /*[in]*/ DWORD   dwRetryInterval )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::AbortJob" );

    _ASSERT( m_mpcujCurrentJob != NULL );

    HRESULT hr;


    m_mpcujCurrentJob->put_ErrorCode    ( hrErrorCode                 );
    m_mpcujCurrentJob->put_RetryInterval( dwRetryInterval             );
    m_mpcujCurrentJob->try_Status       ( UL_TRANSMITTING, UL_ABORTED );


    (void)CloseConnection();
    hr = ReleaseJob();


    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::FailJob( /*[in]*/ HRESULT hrErrorCode )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::FailJob" );

    _ASSERT( m_mpcujCurrentJob != NULL );

    HRESULT hr;
    int&    iRetries = (m_fState == TA_OPEN ? m_iRetries_Open : m_iRetries_Write);

    //
    // Always retry a certain amount of times.
    //
    if(iRetries++ < RETRY_MAX)
    {
        DWORD dwDelay;

        switch(iRetries)
        {
        case  1: dwDelay =  1; break;
        case  2: dwDelay =  2; break;
        case  3: dwDelay =  4; break;
        case  4: dwDelay =  4; break;
        case  5: dwDelay =  6; break;
        case  6: dwDelay =  8; break;
        case  7: dwDelay = 10; break;
        case  8: dwDelay = 12; break;
        case  9: dwDelay = 15; break;
        default: dwDelay = 30; break;
        }

        (void)m_mpcujCurrentJob->get_Sequence( &m_iRetries_FailedJob );

        __MPC_EXIT_IF_METHOD_FAILS(hr, AbortJob( hrErrorCode, dwDelay ));
    }
    else
    {
        m_mpcujCurrentJob->put_ErrorCode( hrErrorCode                );
        m_mpcujCurrentJob->try_Status   ( UL_TRANSMITTING, UL_FAILED );

        (void)CloseConnection();

        __MPC_EXIT_IF_METHOD_FAILS(hr, ReleaseJob());
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCTransportAgent::CloseConnection()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::CloseConnection" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, CloseRequest());

    if(m_hConn)
    {
        ::InternetCloseHandle( m_hConn ); m_hConn = NULL;
    }

    if(m_hSession)
    {
        ::InternetCloseHandle( m_hSession ); m_hSession = NULL;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::OpenConnection()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::OpenConnection" );

    HRESULT                      hr;
    MPC::wstring                 szHostName;
    DWORD                        dwPort;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_URL.get_HostName( szHostName ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_URL.get_Port    ( dwPort     ));

    //
    // Open a new internet connection only if no one is present or server is different.
    //
    if(m_hSession == NULL               ||
       m_hConn    == NULL               ||
       szHostName != m_szLastServer     ||
       dwPort     != m_dwLastServerPort  )
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CloseConnection());

        //
        // Create an handle to the Internet (it's not needed to have an active connection at this point).
        //
        __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hSession = ::InternetOpenW( L"UploadClient"              ,
                                                                           INTERNET_OPEN_TYPE_PRECONFIG ,
                                                                           NULL                         ,
                                                                           NULL                         ,
                                                                           0                            )));

		//
		// Try to set the proxy using the user settings.
		//
		if(m_mpcujCurrentJob)
		{
			(void)m_mpcujCurrentJob->SetProxySettings( m_hSession );
		}

        __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hConn = ::InternetConnectW( m_hSession                 ,
                                                                           szHostName.c_str()         ,
                                                                           dwPort                     ,
                                                                           NULL                       ,
                                                                           NULL                       ,
                                                                           INTERNET_SERVICE_HTTP      ,
                                                                           0                          ,
                                                                           0                          )));

        m_szLastServer     = szHostName;
        m_dwLastServerPort = dwPort;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT CMPCTransportAgent::CloseRequest()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::CloseRequest" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_hReq)
    {
        ::InternetCloseHandle( m_hReq ); m_hReq = NULL;
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::OpenRequest()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::OpenRequest" );

    HRESULT                      hr;
    INTERNET_SCHEME              nScheme;
    MPC::wstring                 szPath;
    MPC::wstring                 szExtraInfo;
    DWORD                        dwFlags;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_URL.get_Scheme   ( nScheme     ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_URL.get_Path     ( szPath      ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_URL.get_ExtraInfo( szExtraInfo ));
    szPath.append( szExtraInfo );

    __MPC_EXIT_IF_METHOD_FAILS(hr, CloseRequest());

    dwFlags = INTERNET_FLAG_KEEP_CONNECTION  |
              INTERNET_FLAG_NO_AUTO_REDIRECT |
              INTERNET_FLAG_NO_CACHE_WRITE   |
              INTERNET_FLAG_PRAGMA_NOCACHE;

    if(nScheme == INTERNET_SCHEME_HTTPS)
    {
        dwFlags |= INTERNET_FLAG_SECURE;
    }

    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hReq = ::HttpOpenRequestW( m_hConn         ,
                                                                      REQUEST_VERB    ,
                                                                      szPath.c_str()  ,
                                                                      REQUEST_VERSION ,
                                                                      NULL            ,
                                                                      rgAcceptedTypes ,
                                                                      dwFlags         ,
                                                                      0               )));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCTransportAgent::SendPacket_OpenSession( /*[in]*/ MPC::Serializer&                                stream  ,
                                                    /*[in]*/ const UploadLibrary::ClientRequest_OpenSession& crosReq )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::SendPacket_OpenSession" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << crosReq.crHeader);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << crosReq         );

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::SendPacket_WriteSession( /*[in]*/ MPC::Serializer&                                 stream  ,
                                                     /*[in]*/ const UploadLibrary::ClientRequest_WriteSession& crwsReq ,
                                                     /*[in]*/ const BYTE*                                      pData   )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::SendPacket_WriteSession" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << crwsReq.crHeader);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << crwsReq         );

    {
        MPC::Serializer_Text streamText( stream );
        MPC::Serializer*     pstream = UploadLibrary::SelectStream( stream, streamText );

        __MPC_EXIT_IF_METHOD_FAILS(hr, pstream->write( pData, crwsReq.dwSize ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::WaitResponse( /*[out]*/ UploadLibrary::ServerResponse& srRep )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::WaitResponse" );

    HRESULT                      hr;
    DWORD                        dwStatus;
    DWORD                        dwStatusSize = sizeof( dwStatus );
    MPC::Serializer&             stream       = MPC::Serializer_Http( m_hReq );
    DWORD                        dwRes        = ERROR_SUCCESS;
    MPC::SmartLock<_ThreadModel> lock( NULL );


    if(::HttpEndRequestW( m_hReq, NULL, HSR_SYNC, 0 ) == FALSE)
    {
        //
        // Read the error, but don't use it now...
        //
        dwRes = ::GetLastError();
    }


    ////////////////////////////////////////
    //
    // Start of Critical Section.
    //
    lock = this;

    if(::HttpQueryInfoW( m_hReq, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, &dwStatus, &dwStatusSize, NULL))
    {
        if(dwStatus != HTTP_STATUS_OK)
        {
            if(dwStatus == HTTP_STATUS_DENIED)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_NOT_AUTHENTICATED);
            }

            __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_ACCESS_DENIED);
        }

    }
    else
    {
        //
        // The call to HttpQueryInfo failed.
        // If the previous call to HttpEndRequest failed too, use that error, otherwise use the new one.
        //
        if(dwRes == ERROR_SUCCESS)
        {
            dwRes = ::GetLastError();
        }

        __MPC_SET_WIN32_ERROR_AND_EXIT( hr, dwRes );
    }

    lock = NULL;
    //
    // End of Critical Section.
    //
    ////////////////////////////////////////

    //
    // Read the response and if for any reason it fails, flag the request as BAD_PROTOCOL.
    //
    if(FAILED(hr = stream >> srRep))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_WRONG_SERVER_VERSION);
    }

    //
    // Check proper version of the packet.
    //
    if(srRep.rhProlog.VerifyServer() == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_WRONG_SERVER_VERSION);
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCTransportAgent::ExecuteCommand_OpenSession( /*[out]*/ UploadLibrary::ServerResponse& srRep )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::ExecuteCommand_OpenSession" );

    HRESULT                                  hr;
    UploadLibrary::ClientRequest_OpenSession crosReq( GetProtocol() );
    MPC::Serializer_Memory                   streamConn;
    INTERNET_BUFFERSW                        ibBuffer;
    CMPCRequestTimeout                       mpcrt( *this );
    MPC::SmartLock<_ThreadModel>             lock( NULL );


    //
    // Create the request handle.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, mpcrt.SetTimeout( g_Config.get_Timing_RequestTimeout() * TIMING_SECOND ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenRequest());


    //
    // Extract info from the job.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcujCurrentJob->SetupRequest( crosReq ));


    //
    // Construct the packet.
    //
    ZeroMemory( &ibBuffer,   sizeof( ibBuffer ) );
    ibBuffer.dwStructSize  = sizeof( ibBuffer );

    __MPC_EXIT_IF_METHOD_FAILS(hr, SendPacket_OpenSession( streamConn, crosReq ));

    ibBuffer.dwBufferTotal  = streamConn.GetSize();
    ibBuffer.dwBufferLength = streamConn.GetSize();
    ibBuffer.lpvBuffer      = streamConn.GetData();

    ibBuffer.lpcszHeader     =           s_ContentType;
    ibBuffer.dwHeadersLength = MAXSTRLEN(s_ContentType);

    //
    // Send request.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, mpcrt.SetTimeout( g_Config.get_Timing_RequestTimeout() * TIMING_SECOND ));

    ////////////////////////////////////////
    //
    // Start of Critical Section.
    //
    lock = this;

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::HttpSendRequestExW( m_hReq, &ibBuffer, NULL, HSR_SYNC | HSR_INITIATE, 0 ));

    lock = NULL;
    //
    // End of Critical Section.
    //
    ////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, WaitResponse( srRep ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hr == HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE ))
    {
        hr = HRESULT_FROM_WIN32( ERROR_INTERNET_OPERATION_CANCELLED );
    }

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::ExecuteCommand_WriteSession( /*[out]*/ UploadLibrary::ServerResponse& srRep  ,
                                                         /*[in] */ DWORD                          dwSize ,
                                                         /*[in] */ const BYTE*                    pData  )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::ExecuteCommand_WriteSession" );

    HRESULT                                   hr;
    UploadLibrary::ClientRequest_WriteSession crwsReq( GetProtocol() );
    MPC::Serializer_Memory                    streamConn;
    INTERNET_BUFFERSW                         ibBuffer;
    CMPCRequestTimeout                        mpcrt( *this );
    MPC::SmartLock<_ThreadModel>              lock( NULL );


    //
    // Create the request handle.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, mpcrt.SetTimeout( g_Config.get_Timing_RequestTimeout() * TIMING_SECOND ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenRequest());


    //
    // Extract info from the job.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcujCurrentJob->SetupRequest( crwsReq, dwSize ));


    //
    // Construct the packet.
    //
    ZeroMemory( &ibBuffer,   sizeof( ibBuffer ) );
    ibBuffer.dwStructSize  = sizeof( ibBuffer );

    __MPC_EXIT_IF_METHOD_FAILS(hr, SendPacket_WriteSession( streamConn, crwsReq, pData ));

    ibBuffer.dwBufferTotal  = streamConn.GetSize();
    ibBuffer.dwBufferLength = streamConn.GetSize();
    ibBuffer.lpvBuffer      = streamConn.GetData();


    //
    // Send request.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, mpcrt.SetTimeout( g_Config.get_Timing_RequestTimeout() * TIMING_SECOND ));

    ////////////////////////////////////////
    //
    // Start of Critical Section.
    //
    lock = this;

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::HttpSendRequestExW( m_hReq, &ibBuffer, NULL, HSR_SYNC | HSR_INITIATE, 0 ));

    lock = NULL;
    //
    // End of Critical Section.
    //
    ////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, WaitResponse( srRep ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hr == HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE ))
    {
        hr = HRESULT_FROM_WIN32( ERROR_INTERNET_OPERATION_CANCELLED );
    }

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::CheckResponse( /*[in]*/ const UploadLibrary::ServerResponse& srRep )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::CheckResponse" );

    HRESULT hr;


    if((srRep.fResponse & UploadLibrary::UL_RESPONSE_FAILED) == UploadLibrary::UL_RESPONSE_SUCCESS)
    {
        long lTotalSize;
        int& iRetries = (m_fState == TA_OPEN ? m_iRetries_Open : m_iRetries_Write);

        //
        // If the server sends back a file position beyond the end of file, stop the transmission...
        //
        m_mpcujCurrentJob->get_TotalSize( &lTotalSize );
        if(srRep.dwPosition > lTotalSize)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, FailJob( E_UPLOADLIBRARY_UNEXPECTED_RESPONSE ));
        }

        m_mpcujCurrentJob->put_SentSize( srRep.dwPosition );
        iRetries = 0;
    }

    //
    // If we receive an error because of a mismatch in the protocol version, retry with the old protocol.
    //
    if(srRep.rhProlog.VerifyServer() == false                                  ||
       srRep.fResponse               == UploadLibrary::UL_RESPONSE_BAD_REQUEST  )
    {
        if(m_fUseOldProtocol == false)
        {
            m_fUseOldProtocol = true;

            __MPC_SET_ERROR_AND_EXIT(hr, AbortJob( E_UPLOADLIBRARY_SERVER_BUSY, RETRY_FAST ));
        }
    }


    //
    // Check for special cases that require a different reaction based on the command sent.
    //
    switch(m_fState)
    {
    case TA_OPEN:
        switch(srRep.fResponse)
        {
        case UploadLibrary::UL_RESPONSE_EXISTS   :
        case UploadLibrary::UL_RESPONSE_NOTACTIVE:
        case UploadLibrary::UL_RESPONSE_BADCRC   : __MPC_SET_ERROR_AND_EXIT(hr, FailJob( E_UPLOADLIBRARY_UNEXPECTED_RESPONSE ));
        }
        break;

    case TA_WRITE:
        switch(srRep.fResponse)
        {
        case UploadLibrary::UL_RESPONSE_EXISTS: __MPC_SET_ERROR_AND_EXIT(hr, FailJob( E_UPLOADLIBRARY_UNEXPECTED_RESPONSE ));
        }
        break;
    }

    switch(srRep.fResponse)
    {
    case UploadLibrary::UL_RESPONSE_SUCCESS       :                         hr =           S_OK;                                                break;
    case UploadLibrary::UL_RESPONSE_SKIPPED       :                         hr =           S_OK;                                                break;
    case UploadLibrary::UL_RESPONSE_COMMITTED     : m_fNextState = TA_DONE; hr =           S_OK;                                                break;
    case UploadLibrary::UL_RESPONSE_BAD_REQUEST   :                         hr = FailJob ( E_UPLOADLIBRARY_ACCESS_DENIED                     ); break;
    case UploadLibrary::UL_RESPONSE_DENIED        :                         hr = FailJob ( E_UPLOADLIBRARY_ACCESS_DENIED                     ); break;
    case UploadLibrary::UL_RESPONSE_NOT_AUTHORIZED:                         hr = FailJob ( E_UPLOADLIBRARY_NOT_AUTHENTICATED                 ); break;
    case UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED:                         hr = AbortJob( E_UPLOADLIBRARY_SERVER_QUOTA_EXCEEDED, RETRY_SLOW ); break;
    case UploadLibrary::UL_RESPONSE_BUSY          :                         hr = AbortJob( E_UPLOADLIBRARY_SERVER_BUSY          , RETRY_FAST ); break;
    case UploadLibrary::UL_RESPONSE_EXISTS        : m_fNextState = TA_DONE; hr =           S_OK;                                                break;
    case UploadLibrary::UL_RESPONSE_NOTACTIVE     : m_fNextState = TA_OPEN; hr =           S_OK;                                                break;
    case UploadLibrary::UL_RESPONSE_BADCRC        : m_fNextState = TA_OPEN; hr =           S_OK;                                                break;
    }

    //
    // If this was the last packet, read the rest of the response, if present.
    //
    if(m_fNextState == TA_DONE)
    {
        MPC::Serializer_Memory streamResponse;
        BYTE                   rgBuf[512];
        DWORD                  dwRead;

        while(1)
        {
            if(::InternetReadFile( m_hReq, rgBuf, sizeof(rgBuf), &dwRead ) == FALSE) break;

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamResponse.write( rgBuf, dwRead ));

            if(dwRead != sizeof(rgBuf)) break;
        }

        if(m_mpcujCurrentJob)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcujCurrentJob->put_Response( streamResponse.GetSize(), streamResponse.GetData() ));
        }
    }


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCTransportAgent::CreateJobOnTheServer()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::CreateJobOnTheServer" );

    HRESULT                       hr;
    UploadLibrary::ServerResponse srRep( 0 );


    __MPC_EXIT_IF_METHOD_FAILS(hr, ExecuteCommand_OpenSession( srRep ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CheckResponse( srRep ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::SendNextChunk()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::SendNextChunk" );

    HRESULT                       hr;
    BYTE*                         pBuffer = NULL;
    HANDLE                        hfFile  = NULL;
    UploadLibrary::ServerResponse srRep( 0 );
    CComBSTR                      bstrFileName;
    DWORD                         dwChunk;
    long                          lSentSize;
    long                          lTotalSize;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetPacketSize( dwChunk ));
    __MPC_EXIT_IF_ALLOC_FAILS(hr, pBuffer, new BYTE[dwChunk]);


    (void)m_mpcujCurrentJob->get_FileName ( &bstrFileName );
    (void)m_mpcujCurrentJob->get_SentSize ( &lSentSize    );
    (void)m_mpcujCurrentJob->get_TotalSize( &lTotalSize   );


    //
    // Open the data file and read a chunk from it.
    //
	__MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hfFile, ::CreateFileW( SAFEBSTR( bstrFileName ), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ));

    if(lSentSize < lTotalSize)
    {
        DWORD dwWanted = min( lTotalSize - lSentSize, dwChunk );
        DWORD dwRead;

		__MPC_EXIT_IF_CALL_RETURNS_THISVALUE(hr, ::SetFilePointer( hfFile, (DWORD)lSentSize, NULL, FILE_BEGIN ), INVALID_SET_FILE_POINTER);

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ReadFile( hfFile, pBuffer, dwWanted, &dwRead, NULL ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ExecuteCommand_WriteSession( srRep, dwRead, pBuffer ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, CheckResponse( srRep ));
    }
    else if(lSentSize == lTotalSize)
    {
        //
        // Everything has been uploaded, but the job is still uncommitted.
        // So try to sent a new OpenSession request, to just commit the job.
        //
        m_fNextState = TA_OPEN;
    }
    else
    {
        // Error!! You should never reach this point....
        __MPC_SET_ERROR_AND_EXIT(hr, FailJob( E_UPLOADLIBRARY_UNEXPECTED_RESPONSE ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(pBuffer) delete [] pBuffer;

    if(hfFile) ::CloseHandle( hfFile );

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCTransportAgent::CheckInternetError( /*[in]*/ HRESULT hr )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::CheckInternetError" );

    TA_ERROR_RATING erReason;


    switch(HRESULT_CODE( hr ))
    {
    case ERROR_INTERNET_DISCONNECTED             : erReason = TA_NO_CONNECTION        ; break;

    case ERROR_INTERNET_CONNECTION_RESET         :
    case ERROR_INTERNET_FORCE_RETRY              : erReason = TA_IMMEDIATE_RETRY      ; break;

    case ERROR_INTERNET_TIMEOUT                  :
    case ERROR_INTERNET_CONNECTION_ABORTED       :
    case ERROR_INTERNET_OPERATION_CANCELLED      : erReason = TA_TIMEOUT_RETRY        ; break;

    case ERROR_INTERNET_SERVER_UNREACHABLE       :
    case ERROR_INTERNET_PROXY_SERVER_UNREACHABLE :
    case ERROR_INTERNET_CANNOT_CONNECT           : erReason = TA_TEMPORARY_FAILURE    ; break;

    case ERROR_NOT_AUTHENTICATED                 :
    case ERROR_INTERNET_INCORRECT_USER_NAME      :
    case ERROR_INTERNET_INCORRECT_PASSWORD       :
    case ERROR_INTERNET_LOGIN_FAILURE            : erReason = TA_AUTHORIZATION_FAILURE; break;

    default                                      : erReason = TA_PERMANENT_FAILURE    ; break;
    }

    switch(erReason)
    {
    case TA_NO_CONNECTION        : hr = ReleaseJob(    );                                   break;
    case TA_IMMEDIATE_RETRY      : hr = RestartJob(    ); SetSleepInterval( 250, true );    break; // Allow a little period of sleep...
    case TA_TIMEOUT_RETRY        : hr = FailJob   ( hr ); RecordEndOfTransmission( false ); break;
    case TA_TEMPORARY_FAILURE    : hr = FailJob   ( hr ); RecordEndOfTransmission( false ); break;
    case TA_AUTHORIZATION_FAILURE: hr = FailJob   ( hr ); RecordEndOfTransmission( false ); break;
    case TA_PERMANENT_FAILURE    : hr = FailJob   ( hr ); RecordEndOfTransmission( false ); break;
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCTransportAgent::GetPacketSize( /*[out]*/ DWORD& dwChunk )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::GetPacketSize" );

    HRESULT hr;
    DWORD   dwConnectionKind = 0;


    dwChunk = -1;

    if(::InternetGetConnectedState( &dwConnectionKind, 0 ))
    {
        if(dwConnectionKind & INTERNET_CONNECTION_MODEM) dwChunk = g_Config.get_PacketSize( MPC::wstring( CONNECTIONTYPE_MODEM ) );
        if(dwConnectionKind & INTERNET_CONNECTION_LAN  ) dwChunk = g_Config.get_PacketSize( MPC::wstring( CONNECTIONTYPE_LAN   ) );
    }

    if(dwChunk == -1)
    {
        dwChunk = 8192;
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::RecordStartOfTransmission()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::RecordStartOfTransmission" );

    HRESULT hr;


    m_dwTransmission_Start = ::GetTickCount();
    m_dwTransmission_End   = 0;
    m_dwTransmission_Next  = 0;

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}


HRESULT CMPCTransportAgent::RecordEndOfTransmission( /*[in]*/ bool fBetweenPackets )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::RecordEndOfTransmission" );

    HRESULT hr;
    UL_MODE umMode;


    m_dwTransmission_End = ::GetTickCount();


    if(m_mpcujCurrentJob)
    {
        (void)m_mpcujCurrentJob->get_Mode( &umMode );

        //
        // Current job is a background one, sleep to preserve bandwidth for the user.
        //
        if(umMode == UL_BACKGROUND)
        {
            if(fBetweenPackets)
            {
                DWORD  dwTransmissionTime     = m_dwTransmission_End - m_dwTransmission_Start;
                double dblFractionOfBandwidth = 100.0 / g_Config.get_Timing_BandwidthUsage();  // It's safe, the method won't return zero...

                SetSleepInterval( m_dwTransmission_End + dwTransmissionTime * (dblFractionOfBandwidth - 1.0), false );
            }
            else
            {
                SetSleepInterval( m_dwTransmission_End + g_Config.get_Timing_WaitBetweenJobs() * TIMING_SECOND, false );
            }
        }
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCTransportAgent::SetSleepInterval( /*[in]*/ DWORD dwAmount  ,
                                              /*[in]*/ bool  fRelative )
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::SetSleepInterval" );

    HRESULT hr;

    m_dwTransmission_Start = ::GetTickCount();

    if(fRelative)
    {
        m_dwTransmission_Next = dwAmount + m_dwTransmission_Start;
    }
    else
    {
        m_dwTransmission_Next = dwAmount;
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

DWORD CMPCTransportAgent::WaitForNextTransmission()
{
    __ULT_FUNC_ENTRY( "CMPCTransportAgent::WaitForNextTransmission" );

    DWORD   dwRes;
    DWORD   dwConnectionKind = 0;
    DWORD   dwNow;
    UL_MODE umMode;


    //
    // No job to send, so keep sleeping.
    //
    if(m_mpcujCurrentJob == NULL)
    {
        dwRes = INFINITE;
    }
    else
    {
        //
        // No connection...
        //
        if(::InternetGetConnectedState( &dwConnectionKind, 0 ) == FALSE)
        {
            dwRes = TIMING_NOCONNECTION;
        }
        else
        {
            //
            // Current job is a foreground one, so don't sleep between packets.
            //
            (void)m_mpcujCurrentJob->get_Mode( &umMode );
            if(umMode == UL_FOREGROUND)
            {
                dwRes = 0;
            }
            else
            {
                //
                // If 'm_dwTransmission_Next' is set, we need to sleep until that time is reached.
                //
                // To handle the wrap around of the tick count, make sure 'dwNow' has a value
                // between 'm_dwTransmission_Start' and 'm_dwTransmission_Next'.
                //
                dwNow = ::GetTickCount();
                if(m_dwTransmission_Next && (m_dwTransmission_Start <= dwNow && m_dwTransmission_Next > dwNow))
                {
                    dwRes = m_dwTransmission_Next - dwNow;
                }
                else
                {
                    dwRes = 0;
                }
            }
        }
    }


    __ULT_FUNC_EXIT(dwRes);
}

DWORD CMPCTransportAgent::GetProtocol()
{
    return m_fUseOldProtocol ? UPLOAD_LIBRARY_PROTOCOL_VERSION_CLT : UPLOAD_LIBRARY_PROTOCOL_VERSION_CLT__TEXTONLY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcuploadenum.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCUploadEnum.cpp

Abstract:
    This file contains the implementation of the MPCUploadEnum class,
    the enumerator of the MPCUpload class.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"


CMPCUploadEnum::CMPCUploadEnum()
{
    __ULT_FUNC_ENTRY( "CMPCUploadEnum::CMPCUploadEnum" );

	                                 // List m_lstJobs
    m_itCurrent = m_lstJobs.begin(); // Iter m_itCurrent
}

void CMPCUploadEnum::FinalRelease()
{
    __ULT_FUNC_ENTRY( "CMPCUploadEnum::FinalRelease" );


	MPC::ReleaseAll( m_lstJobs );
}

HRESULT CMPCUploadEnum::AddItem( /*[in]*/ IMPCUploadJob* job )
{
    __ULT_FUNC_ENTRY( "CMPCUploadEnum::Init" );

	MPC::SmartLock<_ThreadModel> lock( this );


    m_lstJobs.push_back( job ); job->AddRef();
    m_itCurrent    = m_lstJobs.begin();


    __ULT_FUNC_EXIT(S_OK);
}


STDMETHODIMP CMPCUploadEnum::Next( /*[in]*/ ULONG celt, /*[out]*/ VARIANT *rgelt, /*[out]*/ ULONG *pceltFetched )
{
    __ULT_FUNC_ENTRY( "CMPCUploadEnum::Next" );

    HRESULT 			         hr;
    ULONG   			         cNum = 0;
    VARIANT 			        *pelt = rgelt;
	MPC::SmartLock<_ThreadModel> lock( this );


    if(rgelt == NULL || (celt != 1 && pceltFetched == NULL))
	{
        __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);
	}


    while(celt && m_itCurrent != m_lstJobs.end())
    {
        IMPCUploadJob* mpcujJob = *m_itCurrent++;

        pelt->vt = VT_DISPATCH;
        if(FAILED(hr = mpcujJob->QueryInterface( IID_IDispatch, (void**)&pelt->pdispVal )))
        {
            while(rgelt < pelt)
            {
                ::VariantClear( rgelt++ );
            }

            cNum = 0;
			__MPC_FUNC_LEAVE;
        }

        pelt++; cNum++; celt--;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(pceltFetched != NULL) *pceltFetched = cNum;

    if(SUCCEEDED(hr))
    {
        if(celt != 0) hr = S_FALSE;
    }

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadEnum::Skip( /*[in]*/ ULONG celt )
{
    __ULT_FUNC_ENTRY( "CMPCUploadEnum::Skip" );

    HRESULT                      hr;
	MPC::SmartLock<_ThreadModel> lock( this );


    while(celt && m_itCurrent != m_lstJobs.end())
    {
        m_itCurrent++;
        celt--;
    }

    hr = celt ? S_FALSE : S_OK;


    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadEnum::Reset()
{
    __ULT_FUNC_ENTRY( "CMPCUploadEnum::Reset" );

    HRESULT                      hr;
	MPC::SmartLock<_ThreadModel> lock( this );


    m_itCurrent = m_lstJobs.begin();
	hr          = S_OK;


    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadEnum::Clone( /*[out]*/ IEnumVARIANT* *ppEnum )
{
    __ULT_FUNC_ENTRY( "CMPCUploadEnum::Clone" );

    HRESULT    					 hr;
	Iter                         it;
    CComPtr<CMPCUploadEnum>      pEnum;
	MPC::SmartLock<_ThreadModel> lock( this );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(ppEnum,NULL);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pEnum ));

	for(it = m_lstJobs.begin(); it != m_lstJobs.end(); it++)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, pEnum->AddItem( *it ));
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, pEnum->QueryInterface( IID_IEnumVARIANT, (void**)ppEnum ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcupload.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCUpload.h

Abstract:
    This file contains the declaration of the CMPCUpload class, which is
    used as the entry point into the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULMANAGER___MPCUPLOAD_H___)
#define __INCLUDED___ULMANAGER___MPCUPLOAD_H___


#include "MPCUploadEnum.h"
#include "MPCUploadJob.h"

#include "MPCTransportAgent.h"


class ATL_NO_VTABLE CMPCUpload : // Hungarian: mpcu
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IMPCUpload, &IID_IMPCUpload, &LIBID_UPLOADMANAGERLib>,

    public IMPCPersist // Persistence
{
    typedef std::list< CMPCUploadJob* > List;
    typedef List::iterator              Iter;
    typedef List::const_iterator        IterConst;

    DWORD              m_dwLastJobID;
    List               m_lstActiveJobs;
    CMPCTransportAgent m_mpctaThread;
    mutable bool       m_fDirty;
    mutable bool       m_fPassivated;

	////////////////////

	void CleanUp();

    HRESULT InitFromDisk();
    HRESULT UpdateToDisk();

	HRESULT CreateChild ( /*[in/out]*/ CMPCUploadJob*& mpcujJob                                 );
	HRESULT ReleaseChild( /*[in/out]*/ CMPCUploadJob*& mpcujJob                                 );
	HRESULT WrapChild   ( /*[in    ]*/ CMPCUploadJob*  mpcujJob, /*[out]*/ IMPCUploadJob* *pVal );

public:
    CMPCUpload();
    virtual ~CMPCUpload();

	HRESULT Init     ();
    void    Passivate();

    bool CanContinue();

    HRESULT TriggerRescheduleJobs(                                                        );
    HRESULT RescheduleJobs       ( /*[in]*/ bool fSignal, /*[out]*/ DWORD *pdwWait = NULL );
    HRESULT RemoveNonQueueableJob( /*[in]*/ bool fSignal                                  );


    HRESULT GetFirstJob ( /*[out]*/ CMPCUploadJob*& mpcujJob, /*[out]*/ bool& fFound                         );
    HRESULT GetJobByName( /*[out]*/ CMPCUploadJob*& mpcujJob, /*[out]*/ bool& fFound, /*[in]*/ BSTR bstrName );

    HRESULT CalculateQueueSize( /*[out]*/ DWORD& dwSize );

BEGIN_COM_MAP(CMPCUpload)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IMPCUpload)
END_COM_MAP()

public:
    // IMPCPersist
    STDMETHOD_(bool,IsDirty)();
    STDMETHOD(Load)( /*[in]*/ MPC::Serializer& streamIn  );
    STDMETHOD(Save)( /*[in]*/ MPC::Serializer& streamOut );


    // IMPCUpload
    STDMETHOD(get__NewEnum)(                      /*[out]*/ IUnknown*      *pVal );
    STDMETHOD(Item        )( /*[in]*/ long index, /*[out]*/ IMPCUploadJob* *pVal );
    STDMETHOD(get_Count   )(                      /*[out]*/ long           *pVal );

    STDMETHOD(CreateJob)( /*[out]*/ IMPCUploadJob* *pVal );
};

extern MPC::CComObjectGlobalNoLock<CMPCUpload> g_Root;

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CMPCUploadWrapper : // Hungarian: mpcuw
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public CComCoClass<CMPCUpload, &CLSID_MPCUpload>,
    public IDispatchImpl<IMPCUpload, &IID_IMPCUpload, &LIBID_UPLOADMANAGERLib>
{
	CMPCUpload* m_Object;

public:
    CMPCUploadWrapper();

	HRESULT FinalConstruct();
	void    FinalRelease  ();

DECLARE_REGISTRY_RESOURCEID(IDR_MPCUPLOAD)
DECLARE_NOT_AGGREGATABLE(CMPCUploadWrapper)

BEGIN_COM_MAP(CMPCUploadWrapper)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IMPCUpload)
END_COM_MAP()

public:
    // IMPCUpload
    STDMETHOD(get__NewEnum)(                      /*[out]*/ IUnknown*      *pVal );
    STDMETHOD(Item        )( /*[in]*/ long index, /*[out]*/ IMPCUploadJob* *pVal );
    STDMETHOD(get_Count   )(                      /*[out]*/ long           *pVal );

    STDMETHOD(CreateJob)( /*[out]*/ IMPCUploadJob* *pVal );
};


#endif // !defined(__INCLUDED___ULMANAGER___MPCUPLOAD_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcupload.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCUpload.cpp

Abstract:
    This file contains the implementation of the CMPCUpload class, which is
    used as the entry point into the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"

#include <Sddl.h>

////////////////////////////////////////////////////////////////////////////////

static const WCHAR l_ConfigFile   [] = L"%WINDIR%\\PCHEALTH\\UPLOADLB\\CONFIG\\CONFIG.XML";
static const WCHAR l_DirectoryFile[] = L"upload_library.db";

static const DWORD l_dwVersion       = 0x03004C55; // UL 03

static const DATE  l_SecondsInDay    = (86400.0);

////////////////////////////////////////////////////////////////////////////////

MPC::CComObjectGlobalNoLock<CMPCUpload> g_Root;

////////////////////////////////////////////////////////////////////////////////

CMPCUpload::CMPCUpload()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::CMPCUpload" );

    //
    // Seed the random-number generator with current time so that
    // the numbers will be different every time we run.
    //
    srand( ::GetTickCount() );

    m_dwLastJobID = rand(); // DWORD              m_dwLastJobID
                            // List               m_lstActiveJobs
                            // CMPCTransportAgent m_mpctaThread;
    m_fDirty      = false;  // mutable bool       m_fDirty
    m_fPassivated = false;  // mutable bool       m_fPassivated;

    (void)MPC::_MPC_Module.RegisterCallback( this, (void (CMPCUpload::*)())Passivate );
}

CMPCUpload::~CMPCUpload()
{
    MPC::_MPC_Module.UnregisterCallback( this );

    Passivate();
}

////////////////////////////////////////

HRESULT CMPCUpload::Init()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::Init" );

    HRESULT                      hr;
    MPC::wstring                 str( l_ConfigFile ); MPC::SubstituteEnvVariables( str );
    bool                         fLoaded;
    MPC::SmartLock<_ThreadModel> lock( this );


    //
    // Load configuration.
    //
    g_Config.Load( str, fLoaded );

    //
    // Initialize Transport Agent
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpctaThread.LinkToSystem( this ));

    //
    // Load queue from disk.
    //
    if(FAILED(hr = InitFromDisk()))
    {
        //
        // If, for any reason, loading failed, discard all the jobs and recreate a clean database...
        //
        CleanUp();
        m_fDirty = true;
    }



    //
    // Remove objects marked as DON'T QUEUE.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveNonQueueableJob( false ) );

    //
    // Remove entry from Task Scheduler
    //
    (void)Handle_TaskScheduler( false );

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

void CMPCUpload::Passivate()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::Passivate" );

    MPC::SmartLock<_ThreadModel> lock( NULL );


    //
    // Stop the worker thread before starting the cleanup.
    //
    m_mpctaThread.Thread_Wait();

    lock = this; // Get the lock.


    if(m_fPassivated == false)
    {
        //
        // Remove objects marked as DON'T QUEUE.
        //
        (void)RemoveNonQueueableJob( false );


        //
        // See if we need to reschedule ourself.
        //
        {
            bool fNeedTS = false;
            Iter it;

            //
            // Search for active jobs.
            //
            for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end(); it++)
            {
                CMPCUploadJob* mpcujJob = *it;
                UL_STATUS      ulStatus;

                (void)mpcujJob->get_Status( &ulStatus );
                switch(ulStatus)
                {
                case UL_ACTIVE      :
                case UL_TRANSMITTING:
                case UL_ABORTED     : fNeedTS = true; break;
                }
            }

            if(fNeedTS)
            {
                (void)Handle_TaskScheduler( true );
            }
        }


        CleanUp();

        m_fPassivated = true;
    }
}

void CMPCUpload::CleanUp()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::CleanUp" );

    IterConst it;


    //
    // Release all the jobs.
    //
    for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end(); it++)
    {
        CMPCUploadJob* mpcujJob = *it;

        mpcujJob->Unlink();
        mpcujJob->Release();
    }

    m_lstActiveJobs.clear();
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUpload::CreateChild( /*[in/out]*/ CMPCUploadJob*& mpcujJob )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::CreateChild" );

    HRESULT                      hr;
    CMPCUploadJob_Object*        newobj;
    MPC::SmartLock<_ThreadModel> lock( this );


    mpcujJob = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, newobj->CreateInstance( &newobj )); newobj->AddRef();

    newobj->LinkToSystem( this );

    m_lstActiveJobs.push_back( mpcujJob = newobj );

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUpload::ReleaseChild( /*[in/out]*/ CMPCUploadJob*& mpcujJob )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::ReleaseChild" );

    MPC::SmartLock<_ThreadModel> lock( this );


    if(mpcujJob)
    {
        m_lstActiveJobs.remove( mpcujJob );

        mpcujJob->Unlink ();
        mpcujJob->Release();

        mpcujJob = NULL;
    }


    __ULT_FUNC_EXIT(S_OK);
}

HRESULT CMPCUpload::WrapChild( /*[in]*/ CMPCUploadJob* mpcujJob, /*[out]*/ IMPCUploadJob* *pVal )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::WrapChild" );

    HRESULT                       hr;
    CComPtr<CMPCUploadJobWrapper> wrap;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &wrap ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, wrap->Init( mpcujJob ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, wrap.QueryInterface( pVal ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

bool CMPCUpload::CanContinue()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::CanContinue" );

    bool                         fRes   = false;
    DWORD                        dwMode = 0;
    IterConst                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    //
    // If no connection is available, there's no reason to continue.
    //
    if(::InternetGetConnectedState( &dwMode, 0 ) == TRUE)
    {
        //
        // Search for at least one pending job.
        //
        for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end(); it++)
        {
            CMPCUploadJob* mpcujJob = *it;
            UL_STATUS      usStatus;

            (void)mpcujJob->get_Status( &usStatus );

            switch(usStatus)
            {
            case UL_ACTIVE      :
            case UL_TRANSMITTING:
            case UL_ABORTED     :
                // This job can be executed, so we can continue.
                fRes = true; __ULT_FUNC_LEAVE;
            }
        }
    }


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(fRes);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUpload::InitFromDisk()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::InitFromDisk" );

    HRESULT      hr;
    HANDLE       hFile = NULL;
    MPC::wstring str;
    MPC::wstring str_bak;


    str = g_Config.get_QueueLocation(); str.append( l_DirectoryFile );
    str_bak = str + L"_backup";

    //
    // First of all, try to open the backup file, if present.
    //
    hFile = ::CreateFileW( str_bak.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if(hFile == INVALID_HANDLE_VALUE)
    {
        //
        // No backup present, so open the real file.
        //
        hFile = ::CreateFileW( str.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    else
    {
        //
        // backup present, so delete the corrupted .db file.
        //
        (void)MPC::DeleteFile( str );
    }


    if(hFile == INVALID_HANDLE_VALUE)
    {
        hFile = NULL; // For cleanup.

        DWORD dwRes = ::GetLastError();
        if(dwRes != ERROR_FILE_NOT_FOUND)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes );
        }

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // Load the real data from storage.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Load( MPC::Serializer_File( hFile ) ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hFile) ::CloseHandle( hFile );

    //
    // "RescheduleJobs" should be executed after the file is closed...
    //
    if(SUCCEEDED(hr))
    {
        hr = RescheduleJobs( true );
    }

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUpload::UpdateToDisk()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::UpdateToDisk" );

    HRESULT      hr;
    HANDLE       hFile = NULL;
    MPC::wstring str;
    MPC::wstring str_bak;


    str = g_Config.get_QueueLocation(); str.append( l_DirectoryFile );
    str_bak = str + L"_backup";


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( str ) );


    //
    // First of all, remove any old backup.
    //
    (void)MPC::DeleteFile( str_bak );


    //
    // Then, make a backup of current file.
    //
    (void)MPC::MoveFile( str, str_bak );


    //
    // Create the new file.
    //
    __MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hFile, ::CreateFileW( str.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, NULL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Save( MPC::Serializer_File( hFile ) ));

    //
    // Remove the backup.
    //
    (void)MPC::DeleteFile( str_bak );

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hFile)
    {
        ::FlushFileBuffers( hFile );
        ::CloseHandle     ( hFile );
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUpload::TriggerRescheduleJobs()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::TriggerRescheduleJobs" );

    HRESULT hr;


    //
    // Signal the Transport Agent.
    //
    m_mpctaThread.Thread_Signal();

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}


HRESULT CMPCUpload::RemoveNonQueueableJob( /*[in]*/ bool fSignal )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::RemoveNonQueueableJob" );

    HRESULT                      hr;
    SYSTEMTIME                   stTime;
    DATE                         dTime;
    Iter                         it;
    MPC::SmartLock<_ThreadModel> lock( this );

    //
    // Search for jobs which need to be updated.
    //
    for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end();)
    {
        CMPCUploadJob* mpcujJob = *it;
        VARIANT_BOOL   fPersistToDisk;

        (void)mpcujJob->get_PersistToDisk( &fPersistToDisk );
        if(fPersistToDisk == VARIANT_FALSE)
        {
            bool fSuccess;

            (void)mpcujJob->put_Status( UL_DELETED );

            __MPC_EXIT_IF_METHOD_FAILS(hr, mpcujJob->CanRelease( fSuccess ));
            if(fSuccess)
            {
                //
                // Remove from the system.
                //
                ReleaseChild( mpcujJob );

                m_fDirty = true;

                it = m_lstActiveJobs.begin(); // Iterator is no longer valid, start from the beginning.
                continue;
            }
        }

        it++;
    }


    //
    // Save if needed.
    //
    if(IsDirty())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, UpdateToDisk());
    }


    //
    // Signal the Transport Agent.
    //
    if(fSignal) m_mpctaThread.Thread_Signal();

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUpload::RescheduleJobs( /*[in]*/ bool fSignal, /*[out]*/ DWORD *pdwWait )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::RescheduleJobs" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CMPCUploadJob*               mpcujFirstJob = NULL;
    DATE                         dTime         = MPC::GetLocalTime();
    DWORD                        dwWait        = INFINITE;
    Iter                         it;


    //
    // Search for jobs which need to be updated.
    //
    for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end();)
    {
        CMPCUploadJob* mpcujJob = *it;
        UL_STATUS      usStatus;        (void)mpcujJob->get_Status        ( &usStatus        );
        DATE           dCompleteTime;   (void)mpcujJob->get_CompleteTime  ( &dCompleteTime   );
        DATE           dExpirationTime; (void)mpcujJob->get_ExpirationTime( &dExpirationTime );
        DWORD          dwRetryInterval; (void)mpcujJob->get_RetryInterval ( &dwRetryInterval );


        //
        // If the job has an expiration date and it has passed, remove it.
        //
        if(dExpirationTime && dTime >= dExpirationTime)
        {
            (void)mpcujJob->put_Status( usStatus = UL_DELETED );
        }

        //
        // Check if the job is ready for transmission.
        //
        switch(usStatus)
        {
        case UL_ACTIVE      :
        case UL_TRANSMITTING:
        case UL_ABORTED     :
            //
            // Pick the higher priority job.
            //
            if(mpcujFirstJob == NULL || *mpcujFirstJob < *mpcujJob) mpcujFirstJob = mpcujJob;

            break;
        }

        //
        // If the job is marked as ABORTED and a certain amount of time is elapsed, retry to send.
        //
        if(usStatus == UL_ABORTED)
        {
            DATE dDiff = (dCompleteTime + (dwRetryInterval / l_SecondsInDay)) - dTime;

            if(dDiff > 0)
            {
                if(dwWait > dDiff * l_SecondsInDay)
                {
                    dwWait = dDiff * l_SecondsInDay;
                }
            }
            else
            {
                (void)mpcujJob->put_Status( usStatus = UL_ACTIVE );
            }
        }


        //
        // If the job is marked as DELETED, remove it.
        //
        if(usStatus == UL_DELETED)
        {
            bool fSuccess;

            __MPC_EXIT_IF_METHOD_FAILS(hr, mpcujJob->CanRelease( fSuccess ));
            if(fSuccess)
            {
                //
                // Remove from the system.
                //
                m_lstActiveJobs.remove( mpcujJob );
                mpcujJob->Unlink ();
                mpcujJob->Release();

                m_fDirty = true;

                it = m_lstActiveJobs.begin(); // Iterator is no longer valid, start from the beginning.
                continue;
            }
        }

        it++;
    }

    //
    // If the best job is ready, set the wait delay to zero.
    //
    if(mpcujFirstJob)
    {
        UL_STATUS usStatus; (void)mpcujFirstJob->get_Status( &usStatus );

        if(usStatus == UL_ACTIVE       ||
           usStatus == UL_TRANSMITTING  )
        {
            dwWait = 0;
        }
    }

    //
    // Save if needed.
    //
    if(IsDirty())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, UpdateToDisk());
    }


    //
    // Signal the Transport Agent.
    //
    if(fSignal) m_mpctaThread.Thread_Signal();

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(pdwWait) *pdwWait = dwWait;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUpload::GetFirstJob( /*[out]*/ CMPCUploadJob*& mpcujJob ,
                                 /*[out]*/ bool&           fFound   )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::GetFirstJob" );

    HRESULT                      hr;
    UL_STATUS                    usStatus;
    IterConst                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    mpcujJob = NULL;
    fFound   = false;

    //
    // Rebuild the queue.
    //
    for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end(); it++)
    {
        CMPCUploadJob* mpcujJob2 = *it;

        (void)mpcujJob2->get_Status( &usStatus );

        //
        // Check if the job is ready for transmission.
        //
        switch(usStatus)
        {
        case UL_ACTIVE      :
        case UL_TRANSMITTING:
        case UL_ABORTED     :
            //
            // Pick the higher priority job.
            //
            if(mpcujJob == NULL || *mpcujJob < *mpcujJob2) mpcujJob = mpcujJob2;

            break;
        }
    }


    if(mpcujJob)
    {
        (void)mpcujJob->get_Status( &usStatus );

        if(usStatus != UL_ABORTED)
        {
            mpcujJob->AddRef();
            fFound = true;
        }
        else
        {
            mpcujJob = NULL;
        }
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUpload::GetJobByName( /*[out]*/ CMPCUploadJob*& mpcujJob ,
                                  /*[out]*/ bool&           fFound   ,
                                  /*[in] */ BSTR            bstrName )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::GetJobByName" );

    HRESULT                      hr;
    IterConst                    it;
    MPC::wstring                 szName = SAFEBSTR( bstrName );
    MPC::SmartLock<_ThreadModel> lock( this );


    mpcujJob = NULL;
    fFound   = false;

    //
    // Rebuild the queue.
    //
    for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end(); it++)
    {
        CMPCUploadJob* mpcujJob2 = *it;
        CComBSTR       bstrName2;
        MPC::wstring   szName2;

        (void)mpcujJob2->get_JobID( &bstrName2 );

        szName2 = SAFEBSTR( bstrName2 );
        if(szName == szName2)
        {
            mpcujJob2->AddRef();
            mpcujJob = mpcujJob2;
            fFound   = true;
            break;
        }
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUpload::CalculateQueueSize( /*[out]*/ DWORD& dwSize )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::CalculateQueueSize" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    dwSize = 0;


    {
        MPC::wstring                szQueue = g_Config.get_QueueLocation();
        WIN32_FILE_ATTRIBUTE_DATA   wfadInfo;
        MPC::FileSystemObject       fso( szQueue.c_str() );
        MPC::FileSystemObject::List lst;
        MPC::FileSystemObject::Iter it;


        __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFiles( lst ));

        for(it = lst.begin(); it != lst.end(); it++)
        {
            DWORD dwFileSize;

            __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->get_FileSize( dwFileSize ));

            dwSize += dwFileSize;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

//////////////////////////////////////////////////////////////////////
// Persistence
//////////////////////////////////////////////////////////////////////

bool CMPCUpload::IsDirty()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::IsDirty" );

    bool                         fRes = true; // Default result.
    IterConst                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_fDirty == true) __ULT_FUNC_LEAVE;

    for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end(); it++)
    {
        CMPCUploadJob* mpcujJob = *it;

        if(mpcujJob->IsDirty() == true) __ULT_FUNC_LEAVE;
    }

    fRes = false;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(fRes);
}

HRESULT CMPCUpload::Load( /*[in]*/ MPC::Serializer& streamIn )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::Load" );

    HRESULT                      hr;
    DWORD                        dwVer;
    CMPCUploadJob*               mpcujJob = NULL;
    MPC::SmartLock<_ThreadModel> lock( this );


    CleanUp();


    //
    // Version doesn't match, so force a rewrite and exit.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> dwVer);
    if(dwVer != l_dwVersion)
    {
        m_fDirty = true;

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwLastJobID);

    m_lstActiveJobs.clear();

    while(1)
    {
        HRESULT hr2;

        __MPC_EXIT_IF_METHOD_FAILS(hr, CreateChild( mpcujJob ));

        if(FAILED(hr2 = mpcujJob->Load( streamIn )))
        {
            if(hr2 != HRESULT_FROM_WIN32( ERROR_HANDLE_EOF ))
            {
                __MPC_SET_ERROR_AND_EXIT(hr, hr2);
            }

            break;
        }

        mpcujJob = NULL;
    }

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;

    ReleaseChild( mpcujJob );

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUpload::Save( /*[in]*/ MPC::Serializer& streamOut )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::Save" );

    HRESULT                      hr;
    IterConst                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << l_dwVersion  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwLastJobID);

    for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end(); it++)
    {
        CMPCUploadJob* mpcujJob = *it;

        __MPC_EXIT_IF_METHOD_FAILS(hr, mpcujJob->Save( streamOut ));
    }

    m_fDirty = false;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

//////////////////////////////////////////////////////////////////////
// Enumerator
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUpload::get__NewEnum( /*[out]*/ IUnknown* *pVal )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::get__NewEnum" );

    HRESULT                      hr;
    Iter                         it;
    CComPtr<CMPCUploadEnum>      pEnum;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Create the Enumerator and fill it with jobs.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pEnum ));

    for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end(); it++)
    {
        CComBSTR bstrUser;

        __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->get_Creator( &bstrUser ));
        if(SUCCEEDED(MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, bstrUser, MPC::IDENTITY_SYSTEM | MPC::IDENTITY_ADMIN | MPC::IDENTITY_ADMINS )))
        {
            CComPtr<IMPCUploadJob> job;

            __MPC_EXIT_IF_METHOD_FAILS(hr, WrapChild( *it, &job ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, pEnum->AddItem( job ));
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pEnum->QueryInterface( IID_IEnumVARIANT, (void**)pVal ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUpload::Item( /*[in]*/ long index, /*[out]*/ IMPCUploadJob* *pVal )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::Item" );

    HRESULT                      hr;
    IterConst                    it;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Look for the N-th job.
    //
    for(it = m_lstActiveJobs.begin(); it != m_lstActiveJobs.end(); it++)
    {
        if(index-- == 0)
        {
            (*pVal = *it)->AddRef();

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    hr = E_INVALIDARG;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUpload::get_Count( /*[out]*/ long *pVal )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::get_Count" );

    if(pVal == NULL) __ULT_FUNC_EXIT(E_POINTER);

    MPC::SmartLock<_ThreadModel> lock( this );


    *pVal = m_lstActiveJobs.size();


    __ULT_FUNC_EXIT(S_OK);
}

STDMETHODIMP CMPCUpload::CreateJob( /*[out]*/ IMPCUploadJob* *pVal )
{
    __ULT_FUNC_ENTRY( "CMPCUpload::CreateJob" );

    HRESULT                      hr;
    CMPCUploadJob*               mpcujJob = NULL;
    DWORD                        dwSize;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Check quota limits.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CalculateQueueSize( dwSize ));
    if(dwSize > g_Config.get_QueueSize())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_CLIENT_QUOTA_EXCEEDED);
    }


    //
    // Create a new job and link it to the system.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateChild( mpcujJob ));


    //
    // Assign a unique ID to the job.
    //
    while(1)
    {
        WCHAR rgBuf[64];

        swprintf( rgBuf, L"INNER_%08x", m_dwLastJobID );

        __MPC_EXIT_IF_METHOD_FAILS(hr, mpcujJob->SetSequence( m_dwLastJobID++ ));

        if(SUCCEEDED(hr = mpcujJob->put_JobID( CComBSTR( rgBuf ) ))) break;

        if(hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
        {
            //
            // Some other error, bailing out...
            //
            __MPC_FUNC_LEAVE;
        }
    }

    //
    // Find out the ID of the caller.
    //
    {
        CComBSTR bstrUser;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetCallerPrincipal( /*fImpersonate*/true, bstrUser ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, mpcujJob->put_Creator( bstrUser ));
    }

    //
    // Get the proxy settings from the caller...
    //
    (void)mpcujJob->GetProxySettings();

    //
    // Cast it to an IMPCUploadJob.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, WrapChild( mpcujJob, pVal ));

    mpcujJob = NULL;
    m_fDirty = true;


    //
    // Reschedule jobs, so the status of the queue will be updated to disk.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, RescheduleJobs( true ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    ReleaseChild( mpcujJob );

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpctransportagent.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCTransportAgent.h

Abstract:
    This file contains the declaration of the CMPCTransportAgent class,
    which is responsible for transfering the data.

Revision History:
    Davide Massarenti   (Dmassare)  04/18/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULMANAGER___MPCTRANSPORTAGENT_H___)
#define __INCLUDED___ULMANAGER___MPCTRANSPORTAGENT_H___


#include "MPCUploadJob.h"

class CMPCTransportAgent;
class CMPCRequestTimeout;

class CMPCRequestTimeout : // hungarian: mpcrt
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>, // For the locking support...
    public MPC::Thread<CMPCRequestTimeout,IUnknown>
{
    CMPCTransportAgent& m_mpcta;
    DWORD               m_dwTimeout;


    HRESULT Run();

public:
    CMPCRequestTimeout( /*[in]*/ CMPCTransportAgent& mpcta );

    HRESULT SetTimeout( /*[in]*/ DWORD dwTimeout );
};

class CMPCTransportAgent : // hungarian: mpcta
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>, // For the locking support...
    public MPC::Thread<CMPCTransportAgent,IUnknown>
{
    friend class CMPCRequestTimeout;

    typedef enum
    {
        TA_IDLE ,
        TA_INIT ,
        TA_OPEN ,
        TA_WRITE,
        TA_DONE ,
        TA_ERROR
    } TA_STATE;

    typedef enum
    {
        TA_NO_CONNECTION        ,
        TA_IMMEDIATE_RETRY      ,
        TA_TIMEOUT_RETRY        ,
        TA_TEMPORARY_FAILURE    ,
        TA_AUTHORIZATION_FAILURE,
        TA_PERMANENT_FAILURE
    } TA_ERROR_RATING;


    CMPCUpload*     m_mpcuRoot;             // private
    CMPCUploadJob*  m_mpcujCurrentJob;      // private
					
    TA_STATE        m_fState;               // private
    TA_STATE        m_fNextState;           // private
    TA_ERROR_RATING m_fLastError;           // private
    bool            m_fUseOldProtocol;      // private
    int             m_iRetries_Open;        // private
    int             m_iRetries_Write;       // private
    ULONG           m_iRetries_FailedJob;   // private
					
    MPC::wstring    m_szLastServer;         // private
    DWORD           m_dwLastServerPort;     // private
    HINTERNET       m_hSession;             // private
    HINTERNET       m_hConn;                // private
    HINTERNET       m_hReq;                 // private
    MPC::URL        m_URL;                  // private
					
    DWORD           m_dwTransmission_Start; // private
    DWORD           m_dwTransmission_End;   // private
    DWORD           m_dwTransmission_Next;  // private


    HRESULT Run       ();
    HRESULT ExecLoop  ();
    HRESULT WaitEvents();

    HRESULT AcquireJob( /*[in]*/ CMPCUploadJob* mpcujJob                             );
    HRESULT ReleaseJob(                                                              );
    HRESULT RestartJob(                                                              );
    HRESULT AbortJob  ( /*[in]*/ HRESULT hrErrorCode, /*[in]*/ DWORD dwRetryInterval );
    HRESULT FailJob   ( /*[in]*/ HRESULT hrErrorCode                                 );

    HRESULT CheckResponse     ( /*[in]*/ const UploadLibrary::ServerResponse& srRep );
    HRESULT CheckInternetError( /*[in]*/ HRESULT                              hr    );


    HRESULT CloseConnection();
    HRESULT OpenConnection ();
    HRESULT CloseRequest   ();
    HRESULT OpenRequest    ();

    HRESULT SendPacket_OpenSession ( /*[in]*/ MPC::Serializer& stream, /*[in]*/ const UploadLibrary::ClientRequest_OpenSession&  crosReq                             );
    HRESULT SendPacket_WriteSession( /*[in]*/ MPC::Serializer& stream, /*[in]*/ const UploadLibrary::ClientRequest_WriteSession& crosReq, /*[in]*/ const BYTE* pData );

    HRESULT ExecuteCommand_OpenSession ( /*[out]*/ UploadLibrary::ServerResponse& srRep                                                    );
    HRESULT ExecuteCommand_WriteSession( /*[out]*/ UploadLibrary::ServerResponse& srRep, /*[in]*/ DWORD dwSize, /*[in]*/ const BYTE* pData );
    HRESULT WaitResponse               ( /*[out]*/ UploadLibrary::ServerResponse& srRep                                                    );

    HRESULT CreateJobOnTheServer();
    HRESULT SendNextChunk       ();


    HRESULT GetPacketSize( /*[out]*/ DWORD& dwChunk );

    HRESULT RecordStartOfTransmission(                                                        );
    HRESULT RecordEndOfTransmission  (                          /*[in]*/ bool fBetweenPackets );
    HRESULT SetSleepInterval         ( /*[in]*/ DWORD dwAmount, /*[in]*/ bool fRelative       );
    DWORD   WaitForNextTransmission  (                                                        );

    DWORD   GetProtocol();

public:
    CMPCTransportAgent();
    ~CMPCTransportAgent();

    HRESULT LinkToSystem( /*[in]*/ CMPCUpload* mpcuRoot );
    HRESULT Unlink      (                               );
};


#endif // !defined(__INCLUDED___ULMANAGER___MPCTRANSPORTAGENT_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcuploadenum.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCUploadEnum.h

Abstract:
    This file contains the declaration of the MPCUploadEnum class,
    the enumerator of the MPCUpload class.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULMANAGER___MPCUPLOADENUM_H___)
#define __INCLUDED___ULMANAGER___MPCUPLOADENUM_H___


#include "MPCUploadJob.h"


class ATL_NO_VTABLE CMPCUploadEnum : // Hungarian: mpcue
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IEnumVARIANT
{
    typedef std::list< IMPCUploadJob* > List;
    typedef List::iterator            	Iter;
    typedef List::const_iterator      	IterConst;

    List m_lstJobs;
    Iter m_itCurrent;

public:
    CMPCUploadEnum();

    void FinalRelease();

    HRESULT AddItem( /*[in]*/ IMPCUploadJob* job );

BEGIN_COM_MAP(CMPCUploadEnum)
    COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

public:
    // IEnumVARIANT
    STDMETHOD(Next)( /*[in]*/ ULONG celt, /*[out]*/ VARIANT *rgelt, /*[out]*/ ULONG *pceltFetched );
    STDMETHOD(Skip)( /*[in]*/ ULONG celt                                                          );
    STDMETHOD(Reset)();
    STDMETHOD(Clone)( /*[out]*/ IEnumVARIANT* *ppEnum );
};

#endif // !defined(__INCLUDED___ULMANAGER___MPCUPLOADENUM_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcuploadevents.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCUploadEvents.h

Abstract:
    This file contains the declaration of the DMPCUploadEvents interface,
    which is used in the ActiveSync method to receive event from a job.

Revision History:
    Davide Massarenti   (Dmassare)  04/30/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULMANAGER___MPCUPLOADEVENTS_H___)
#define __INCLUDED___ULMANAGER___MPCUPLOADEVENTS_H___


class ATL_NO_VTABLE CMPCUploadEvents : // Hungarian: mpcc
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<DMPCUploadEvents, &DIID_DMPCUploadEvents, &LIBID_UPLOADMANAGERLib>
{
    CComPtr<IMPCUploadJob> m_mpcujJob;
    DWORD  		   		   m_dwUploadEventsCookie;
    HANDLE 		   		   m_hEvent;


    bool IsCompleted( /*[in]*/ UL_STATUS usStatus );

    void    UnregisterForEvents(                                  );
    HRESULT RegisterForEvents  ( /*[in]*/ IMPCUploadJob* mpcujJob );

public:
    CMPCUploadEvents();

    HRESULT FinalConstruct();
    void    FinalRelease();

    HRESULT WaitForCompletion( /*[in]*/ IMPCUploadJob* mpcujJob );

BEGIN_COM_MAP(CMPCUploadEvents)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(DMPCUploadEvents)
END_COM_MAP()

public:
    STDMETHOD(Invoke)( /*[in]    */ DISPID      dispIdMember,
                       /*[in]    */ REFIID      riid        ,
                       /*[in]    */ LCID        lcid        ,
                       /*[in]    */ WORD        wFlags      ,
                       /*[in/out]*/ DISPPARAMS *pDispParams ,
                       /*[out]   */ VARIANT    *pVarResult  ,
                       /*[out]   */ EXCEPINFO  *pExcepInfo  ,
                       /*[out]   */ UINT       *puArgErr    );
};

#endif // !defined(__INCLUDED___ULMANAGER___MPCUPLOADEVENTS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcuploadevents.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCUploadEvents.cpp

Abstract:
    This file contains the implementation of the DMPCUploadEvents interface,
    which is used in the ActiveSync method to receive event from a job.

Revision History:
    Davide Massarenti   (Dmassare)  04/30/99
        created

******************************************************************************/

#include "stdafx.h"


CMPCUploadEvents::CMPCUploadEvents()
{
    __ULT_FUNC_ENTRY( "CMPCUploadEvents::CMPCUploadEvents" );

                                    // CComPtr<IMPCUploadJob> m_mpcujJob;
    m_dwUploadEventsCookie = 0;     // DWORD                  m_dwUploadEventsCookie;
    m_hEvent               = NULL;  // HANDLE                 m_hEvent;
}


HRESULT CMPCUploadEvents::FinalConstruct()
{
    __ULT_FUNC_ENTRY( "CMPCUpload::FinalConstruct" );

    HRESULT hr;


    //
    // Create the event used to signal the completion of the transfer.
    //
    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hEvent = CreateEvent( NULL, false, false, NULL )));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


void CMPCUploadEvents::FinalRelease()
{
    __ULT_FUNC_ENTRY( "CMPCUploadEvents::FinalRelease" );


    UnregisterForEvents();

    if(m_hEvent)
    {
        ::CloseHandle( m_hEvent ); m_hEvent = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////

bool CMPCUploadEvents::IsCompleted( /*[in]*/ UL_STATUS usStatus )
{
    __ULT_FUNC_ENTRY( "CMPCUploadEvents::IsCompleted" );

    bool res = false;


    switch(usStatus)
    {
    case UL_FAILED:
    case UL_COMPLETED:
    case UL_DELETED:
        res = true;
        break;
    }


    __ULT_FUNC_EXIT(res);
}

HRESULT CMPCUploadEvents::RegisterForEvents( /*[in]*/ IMPCUploadJob* mpcujJob )
{
    __ULT_FUNC_ENTRY( "CMPCUploadEvents::RegisterForEvents" );

    HRESULT                   hr;
    CComPtr<DMPCUploadEvents> pCallback;


    m_mpcujJob = mpcujJob;

    __MPC_EXIT_IF_METHOD_FAILS(hr, QueryInterface( DIID_DMPCUploadEvents, (void**)&pCallback ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, AtlAdvise( m_mpcujJob, pCallback, DIID_DMPCUploadEvents, &m_dwUploadEventsCookie ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

void CMPCUploadEvents::UnregisterForEvents()
{
    __ULT_FUNC_ENTRY( "CMPCUploadEvents::UnregisterForEvents" );


    if(m_dwUploadEventsCookie)
    {
        if(AtlUnadvise( m_mpcujJob, DIID_DMPCUploadEvents, m_dwUploadEventsCookie ) == S_OK)
        {
            m_dwUploadEventsCookie = 0;
        }
    }

    m_mpcujJob.Release();
}

HRESULT CMPCUploadEvents::WaitForCompletion( /*[in]*/ IMPCUploadJob* mpcujJob )
{
    __ULT_FUNC_ENTRY( "CMPCUploadEvents::WaitForCompletion" );

    _ASSERT(m_mpcujJob == NULL && mpcujJob != NULL);

    HRESULT                      hr;
    UL_STATUS                    usStatus;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, RegisterForEvents( mpcujJob ));

    (void)mpcujJob->get_Status( &usStatus );
    if(IsCompleted( usStatus ) == false)
    {
        lock = NULL; // Release the lock while waiting.
        WaitForSingleObject( m_hEvent, INFINITE );
        lock = this; // Reget the lock.
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    UnregisterForEvents();

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUploadEvents::Invoke( /*[in]    */ DISPID      dispIdMember,
                                  /*[in]    */ REFIID      riid        ,
                                  /*[in]    */ LCID        lcid        ,
                                  /*[in]    */ WORD        wFlags      ,
                                  /*[in/out]*/ DISPPARAMS *pDispParams ,
                                  /*[out]   */ VARIANT    *pVarResult  ,
                                  /*[out]   */ EXCEPINFO  *pExcepInfo  ,
                                  /*[out]   */ UINT       *puArgErr    )
{
    __ULT_FUNC_ENTRY( "CMPCUploadEvents::Invoke" );

    if(dispIdMember == DISPID_UL_UPLOADEVENTS_ONSTATUSCHANGE)
    {
        CComVariant argJob    = pDispParams->rgvarg[1];
        CComVariant argStatus = pDispParams->rgvarg[0];

        CComQIPtr<IMPCUploadJob, &IID_IMPCUploadJob> mpcujJob = argJob.punkVal;

        Lock();

        if(mpcujJob.p == m_mpcujJob && IsCompleted( (UL_STATUS)argStatus.lVal ))
        {
            SetEvent( m_hEvent );
        }

        Unlock();
    }

    __ULT_FUNC_EXIT(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcuploadjob.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCUploadJob.cpp

Abstract:
    This file contains the implementation of the CMPCUploadJob class,
    the descriptor of all jobs present in the Upload Library system.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"


////////////////////////////////////////////////////////////////////////////////

HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       UL_HISTORY& val ) { return stream.read ( &val, sizeof(val) ); }
HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const UL_HISTORY& val ) { return stream.write( &val, sizeof(val) ); }

HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       UL_STATUS& val ) { return stream.read ( &val, sizeof(val) ); }
HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const UL_STATUS& val ) { return stream.write( &val, sizeof(val) ); }

HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       UL_MODE& val ) { return stream.read ( &val, sizeof(val) ); }
HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const UL_MODE& val ) { return stream.write( &val, sizeof(val) ); }

////////////////////////////////////////////////////////////////////////////////

const WCHAR c_szUploadLibPath[] = L"SOFTWARE\\Microsoft\\PCHealth\\MachineInfo";
const WCHAR c_szUploadIDValue[] = L"PID";

static HRESULT ReadGUID( MPC::RegKey& rkBase ,
                         LPCWSTR      szName ,
                         GUID&        guid   )
{
    __ULT_FUNC_ENTRY( "ReadGUID" );

    HRESULT     hr;
    CComVariant vValue;
    bool        fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, szName ));
    if(fFound && vValue.vt == VT_BSTR && vValue.bstrVal != NULL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::IIDFromString( vValue.bstrVal, &guid ));
    }
    else
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

static HRESULT WriteGUID( MPC::RegKey& rkBase ,
                          LPCWSTR      szName ,
                          GUID&        guid   )
{
    __ULT_FUNC_ENTRY( "WriteGUID" );

    HRESULT     hr;
    CComBSTR    bstrGUID( guid );
    CComVariant vValue = bstrGUID;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.put_Value( vValue, szName ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

static void GenGUID( LPBYTE rgBuf  ,
                     DWORD  dwSize ,
                     GUID&  guid   ,
                     DWORD  seed   )
{
    DWORD* dst = (DWORD*)&guid;
    int    i;

    dwSize /= 4; // Divide the buffer in four parts.

    for(i=0;i<4;i++)
    {
        MPC::ComputeCRC( seed, &rgBuf[dwSize*i], dwSize ); *dst++ = seed;
    }
}

static HRESULT GetGUID( /*[out]*/ GUID& guid )
{
    __ULT_FUNC_ENTRY( "GetGUID" );

    HRESULT            hr;
    MPC::RegKey        rkBase;
    MPC::Impersonation imp;


    ////////////////////////////////////////////////////////////////////////////////
    //
    // Open the registry, impersonating the caller.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SetRoot( HKEY_CURRENT_USER, KEY_ALL_ACCESS ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Attach ( c_szUploadLibPath                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Create (                                   ));


    if(FAILED(ReadGUID( rkBase, c_szUploadIDValue, guid )))
    {
        GUID guidSEED;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateGuid( &guidSEED ));

        GenGUID( (LPBYTE)&guidSEED, sizeof(guidSEED), guid, 0xEAB63459 );

        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteGUID( rkBase, c_szUploadIDValue, guid ));
    }
    //
    ////////////////////////////////////////////////////////////////////////////////

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#define CHECK_MODIFY() __MPC_EXIT_IF_METHOD_FAILS(hr, CanModifyProperties())


/////////////////////////////////////////////////////////////////////////////
// CMPCUploadJob

CMPCUploadJob::CMPCUploadJob()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::CMPCUploadJob" );


    m_mpcuRoot        = NULL;                // CMPCUpload*        		 m_mpcuRoot;
    m_dwRetryInterval = 0;                   // DWORD              		 m_dwRetryInterval;
                                             //		 
    m_dwInternalSeq   = -1;                  // ULONG              		 m_dwInternalSeq;
                                             //		 
                                             // Sig                		 m_sigClient;
                                             // CComBSTR           		 m_bstrServer;
                                             // CComBSTR           		 m_bstrJobID;
                                             // CComBSTR           		 m_bstrProviderID;
                                             //		 
                                             // CComBSTR           		 m_bstrCreator;
                                             // CComBSTR           		 m_bstrUsername;
                                             // CComBSTR           		 m_bstrPassword;
                                             //		 
                                             // CComBSTR           		 m_bstrFileNameResponse;
                                             // CComBSTR           		 m_bstrFileName;
    m_lOriginalSize   = 0;                   // long               		 m_lOriginalSize;
    m_lTotalSize      = 0;                   // long               		 m_lTotalSize;
    m_lSentSize       = 0;                   // long               		 m_lSentSize;
    m_dwCRC           = 0;                   // DWORD              		 m_dwCRC;
                                             //		 
    m_uhHistory       = UL_HISTORY_NONE;     // UL_HISTORY         		 m_uhHistory;
    m_usStatus        = UL_NOTACTIVE;        // UL_STATUS          		 m_usStatus;
    m_dwErrorCode     = 0;                   // DWORD              		 m_dwErrorCode;
                                             //		 
    m_umMode          = UL_BACKGROUND;       // UL_MODE            		 m_umMode;
    m_fPersistToDisk  = VARIANT_FALSE;       // VARIANT_BOOL       		 m_fPersistToDisk;
    m_fCompressed     = VARIANT_FALSE;       // VARIANT_BOOL       		 m_fCompressed;
    m_lPriority       = 0;                   // long               		 m_lPriority;
                                             //		 
    m_dCreationTime   = MPC::GetLocalTime(); // DATE               		 m_dCreationTime;
    m_dCompleteTime   = 0;                   // DATE               		 m_dCompleteTime;
    m_dExpirationTime = 0;                   // DATE               		 m_dExpirationTime
                                             //
                                             // MPC::Connectivity::Proxy m_Proxy
                                             //
                                             // CComPtr<IDispatch> 		 m_sink_onStatusChange;
                                             // CComPtr<IDispatch> 		 m_sink_onProgressChange;
                                             //		 
    m_fDirty          = true;                // mutable bool       		 m_fDirty;
}

CMPCUploadJob::~CMPCUploadJob()
{
	Unlink();
}

HRESULT CMPCUploadJob::LinkToSystem( /*[in]*/ CMPCUpload* mpcuRoot )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::LinkToSystem" );

    m_mpcuRoot = mpcuRoot; mpcuRoot->AddRef();

    __ULT_FUNC_EXIT(S_OK);
}

HRESULT CMPCUploadJob::Unlink()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::Unlink" );

    if(m_mpcuRoot)
    {
        m_mpcuRoot->Release();

        m_mpcuRoot = NULL;
    }

    __ULT_FUNC_EXIT(S_OK);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUploadJob::CreateFileName( /*[out]*/ CComBSTR& bstrFileName )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::CreateFileName" );

    HRESULT      hr;
    MPC::wstring szFile( g_Config.get_QueueLocation() );
    WCHAR        rgID[64];


    swprintf( rgID, L"%08x.data", m_dwInternalSeq ); szFile.append( rgID );


    hr = MPC::PutBSTR( bstrFileName, szFile.c_str() );


    __ULT_FUNC_EXIT(hr);
}


HRESULT CMPCUploadJob::CreateTmpFileName( /*[out]*/ CComBSTR& bstrTmpFileName )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::CreateTmpFileName" );

    HRESULT      hr;
    MPC::wstring szFile;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( szFile, g_Config.get_QueueLocation().c_str() ));

    hr = MPC::PutBSTR( bstrTmpFileName, szFile.c_str(), false );


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT CMPCUploadJob::CreateDataFromStream( /*[in]*/ IStream* streamIn, /*[in]*/ DWORD dwQueueSize )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::CreateDataFromStream" );

    HRESULT                  hr;
    STATSTG                  statstg;
    CComBSTR                 bstrTmpFileName;
    CComPtr<MPC::FileStream> stream;
    bool                     fRemove = true; // Clean everything in case of error.

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(streamIn);
    __MPC_PARAMCHECK_END();


    //
    // Get original file size.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn->Stat( &statstg, STATFLAG_NONAME ));
    if(statstg.cbSize.LowPart == 0) // Zero-length files are not allowed.
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, E_INVALIDARG);
    }

    m_lOriginalSize = statstg.cbSize.LowPart;
    m_lTotalSize    = 0;
    m_lSentSize     = 0;
    m_fDirty        = true;



    //
    // Delete old data.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveData    ());
    __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveResponse());


    //
    // Generate the file name for the data.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateFileName( m_bstrFileName ));


    if(m_fCompressed == VARIANT_TRUE)
    {
        //
        // Generate a temporary file name.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, CreateTmpFileName( bstrTmpFileName ));

        //
        // Copy the data to a tmp file and compress it.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForWrite( bstrTmpFileName ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamIn, stream ));
        stream.Release();

        //
        // Compress it.
        //
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CompressAsCabinet( SAFEBSTR( bstrTmpFileName ), SAFEBSTR( m_bstrFileName ), L"PAYLOAD" ));

        //
        // Reopen the data file, to compute the CRC.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForRead( SAFEBSTR( m_bstrFileName ) ));
    }
    else
    {
        LARGE_INTEGER li;

        //
        // Copy the data.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForReadWrite( SAFEBSTR( m_bstrFileName ) ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamIn, stream ));

        //
        // Reset stream to beginning.
        //
        li.LowPart  = 0;
        li.HighPart = 0;
        __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Seek( li, STREAM_SEEK_SET, NULL ));
    }

    //
    // Compute CRC.
    //
    MPC::InitCRC( m_dwCRC );
    while(1)
    {
        UCHAR rgBuf[512];
        ULONG dwRead;

        __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Read( rgBuf, sizeof(rgBuf), &dwRead ));
        if(hr == S_FALSE || dwRead == 0) // End of File.
        {
            fRemove = false;
            break;
        }

        MPC::ComputeCRC( m_dwCRC, rgBuf, dwRead );

        m_lTotalSize += dwRead;
    }

    //
    // Check quota limits.
    //
    if(dwQueueSize + m_lTotalSize > g_Config.get_QueueSize())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_CLIENT_QUOTA_EXCEEDED);
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    stream.Release();

    if(bstrTmpFileName.Length())
    {
        (void)MPC::DeleteFile( bstrTmpFileName );
    }

    if(fRemove || FAILED(hr))
    {
        (void)RemoveData    ();
        (void)RemoveResponse();

        m_lOriginalSize = 0;
        m_lTotalSize    = 0;
        m_lSentSize     = 0;
        m_fDirty        = true;
    }

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUploadJob::OpenReadStreamForData( /*[out]*/ IStream* *pstreamOut )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::OpenReadStreamForData" );

    HRESULT                  hr;
    CComBSTR                 bstrTmpFileName;
    CComPtr<MPC::FileStream> stream;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pstreamOut,NULL);
    __MPC_PARAMCHECK_END();


    if(m_lTotalSize            == 0 ||
       m_bstrFileName.Length() == 0  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_NO_DATA);
    }


    //
    // Generate a temporary file name.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateTmpFileName( bstrTmpFileName ));

    if(m_fCompressed == VARIANT_TRUE)
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DecompressFromCabinet( m_bstrFileName, bstrTmpFileName, L"PAYLOAD" ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyFile( m_bstrFileName, bstrTmpFileName ));
    }

    //
    // Open the file as a stream and set the DeleteOnRelease flag.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForRead    ( bstrTmpFileName ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->DeleteOnRelease( true            ));

    *pstreamOut = stream.Detach();
    hr          = S_OK;


    __ULT_FUNC_CLEANUP;

    stream.Release();

    if(FAILED(hr) && bstrTmpFileName.Length())
    {
        (void)MPC::DeleteFile( bstrTmpFileName );
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


HRESULT CMPCUploadJob::SetSequence( /*[in]*/ ULONG lSeq )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::SetSequence" );


    m_dwInternalSeq = lSeq;
    m_fDirty        = true;


    __ULT_FUNC_EXIT(S_OK);
}


HRESULT CMPCUploadJob::CanModifyProperties()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::CanModifyProperties" );

    HRESULT hr;


    switch(m_usStatus)
    {
    case UL_NOTACTIVE:
    case UL_SUSPENDED:
    case UL_FAILED   : hr = S_OK;           break;
    default          : hr = E_ACCESSDENIED; break;
    }


    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUploadJob::CanRelease( bool& fResult )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::CanRelease" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    fResult = false;

    (void)RemoveData    ();
    (void)RemoveResponse();

    if(!m_bstrFileName         &&
       !m_bstrFileNameResponse  )
    {
        fResult = true;
    }


    hr = S_OK;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUploadJob::RemoveData()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::RemoveData" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_bstrFileName != NULL)
    {
        if(SUCCEEDED(MPC::DeleteFile( m_bstrFileName )))
        {
            m_bstrFileName.Empty();
            m_fDirty = true;
        }
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUploadJob::RemoveResponse()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::RemoveResponse" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_bstrFileNameResponse != NULL)
    {
        if(SUCCEEDED(MPC::DeleteFile( m_bstrFileNameResponse )))
        {
            m_bstrFileNameResponse.Empty();
            m_fDirty = true;
        }
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////
//                      //
// Event Firing Methods //
//                      //
//////////////////////////

HRESULT CMPCUploadJob::Fire_onStatusChange( IMPCUploadJob* mpcujJob, tagUL_STATUS usStatus )
{
    CComVariant        pvars[2];
    CComPtr<IDispatch> pSink;


    //
    // Only this part should be inside a critical section, otherwise deadlocks could occur.
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        pSink = m_sink_onStatusChange;
    }

    pvars[1] = mpcujJob;
    pvars[0] = usStatus;

    return FireAsync_Generic( DISPID_UL_UPLOADEVENTS_ONSTATUSCHANGE, pvars, ARRAYSIZE( pvars ), pSink );
}

HRESULT CMPCUploadJob::Fire_onProgressChange( IMPCUploadJob* mpcujJob, LONG lCurrentSize, LONG lTotalSize )
{
    CComVariant        pvars[3];
    CComPtr<IDispatch> pSink;


    //
    // Only this part should be inside a critical section, otherwise deadlocks could occur.
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        pSink = m_sink_onProgressChange;
    }

    pvars[2] = mpcujJob;
    pvars[1] = lCurrentSize;
    pvars[0] = lTotalSize;

    return FireAsync_Generic( DISPID_UL_UPLOADEVENTS_ONPROGRESSCHANGE, pvars, ARRAYSIZE( pvars ), pSink );
}

/////////////////////////////////////////////////////////////////////////////

/////////////////
//             //
// Persistence //
//             //
/////////////////


bool CMPCUploadJob::IsDirty()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::IsDirty" );

    bool                         fRes;
    MPC::SmartLock<_ThreadModel> lock( this );


    fRes = m_fDirty;


    __ULT_FUNC_EXIT(fRes);
}

HRESULT CMPCUploadJob::Load( /*[in]*/ MPC::Serializer& streamIn  )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::Load" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwInternalSeq       );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_sigClient           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrServer          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrJobID           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrProviderID      );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrCreator         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrUsername        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrPassword        );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrFileNameResponse);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrFileName        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_lOriginalSize       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_lTotalSize          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_lSentSize           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwCRC               );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_uhHistory           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_usStatus            );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwErrorCode         );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_umMode              );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_fPersistToDisk      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_fCompressed         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_lPriority           );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dCreationTime       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dCompleteTime       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dExpirationTime     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_Proxy               );

    m_fDirty = false;
    hr       = S_OK;


    if(m_usStatus == UL_TRANSMITTING)
    {
        m_usStatus = UL_ACTIVE;
    }


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUploadJob::Save( /*[in]*/ MPC::Serializer& streamOut )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::Save" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwInternalSeq       );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_sigClient           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrServer          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrJobID           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrProviderID      );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrCreator         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrUsername        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrPassword        );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrFileNameResponse);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrFileName        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_lOriginalSize       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_lTotalSize          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_lSentSize           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwCRC               );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_uhHistory           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_usStatus            );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwErrorCode         );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_umMode              );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_fPersistToDisk      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_fCompressed         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_lPriority           );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dCreationTime       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dCompleteTime       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dExpirationTime     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_Proxy               );

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

////////////////
//            //
// Properties //
//            //
////////////////


HRESULT CMPCUploadJob::get_Sequence( /*[out]*/ ULONG *pVal ) // INTERNAL METHOD
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_Sequence",hr,pVal,m_dwInternalSeq);

    __ULT_END_PROPERTY(hr);
}


STDMETHODIMP CMPCUploadJob::get_Sig( /*[out]*/ BSTR *pVal )
{
    __ULT_BEGIN_PROPERTY_GET("CMPCUploadJob::get_Sig",hr,pVal);

    CComBSTR bstrSig = m_sigClient.guidMachineID;

    *pVal = bstrSig.Detach();

    __ULT_END_PROPERTY(hr);
}

//
// if newVal is NULL, the function will try to read the GUID from the registry.
// this is to help the script writer use upload library.
//    -- DanielLi
//
STDMETHODIMP CMPCUploadJob::put_Sig( /*[in]*/ BSTR newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_Sig",hr);

    GUID guid = GUID_NULL;


    CHECK_MODIFY();


    if(newVal == NULL || ::SysStringLen( newVal ) == 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, GetGUID( guid ));

        m_sigClient.guidMachineID = guid;
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::IIDFromString( newVal, &m_sigClient.guidMachineID ));
    }

    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_Server( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrServer, pVal );
}

STDMETHODIMP CMPCUploadJob::put_Server( /*[in]*/ BSTR newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_Server",hr);

    BOOL            fUrlCorrect;
    MPC::URL        url;
    INTERNET_SCHEME nScheme;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(newVal);
    __MPC_PARAMCHECK_END();

    CHECK_MODIFY();


    //
    // Check for proper URL syntax and only allow HTTP and HTTPS protocols.
    //
    hr = url.put_URL( newVal );
    if(SUCCEEDED(hr))
    {
        if(SUCCEEDED(hr = url.get_Scheme( nScheme )))
        {
            if(nScheme != INTERNET_SCHEME_HTTP  &&
               nScheme != INTERNET_SCHEME_HTTPS  )
            {
                hr = E_FAIL;
            }
        }
    }

    if(FAILED(hr))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, url.get_Scheme( nScheme ));

    m_bstrServer = newVal;
    m_fDirty     = true;


    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_JobID( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrJobID, pVal );
}

STDMETHODIMP CMPCUploadJob::put_JobID( /*[in]*/ BSTR newVal )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::put_JobID" );

    HRESULT                      hr;
    CMPCUploadJob*               mpcujJob = NULL;
    bool                         fFound;
    MPC::SmartLock<_ThreadModel> lock( NULL ); // Don't get the lock immediately.

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(newVal);
    __MPC_PARAMCHECK_END();


    //
    // Important, keep these calls outside Locked section, otherwise deadlocks are possibles.
    //
    if(m_mpcuRoot)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcuRoot->GetJobByName( mpcujJob, fFound, newVal ));
    }

    lock = this; // Get the lock.


    if(fFound)
    {
        //
        // Found a job with the same ID.
        //
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ALREADY_EXISTS );
    }

    CHECK_MODIFY();

    m_bstrJobID = newVal;
    m_fDirty    = true;
    hr          = S_OK;


    __ULT_FUNC_CLEANUP;

    if(mpcujJob) mpcujJob->Release();

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_ProviderID( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrProviderID, pVal );
}

STDMETHODIMP CMPCUploadJob::put_ProviderID( /*[in]*/ BSTR newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_ProviderID",hr);

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(newVal);
    __MPC_PARAMCHECK_END();

    CHECK_MODIFY();


    m_bstrProviderID = newVal;
    m_fDirty         = true;


    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUploadJob::put_Creator( /*[in]*/ BSTR newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_Creator",hr);

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrCreator, newVal, false ));

    m_fDirty = true;


    __ULT_END_PROPERTY(hr);
}

STDMETHODIMP CMPCUploadJob::get_Creator( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrCreator, pVal );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_Username( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrUsername, pVal );
}

STDMETHODIMP CMPCUploadJob::put_Username( /*[in]*/ BSTR newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_Username",hr);

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrUsername, newVal ));

    m_fDirty = true;


    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_Password( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrPassword, pVal );
}

STDMETHODIMP CMPCUploadJob::put_Password( /*[in]*/ BSTR newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_Password",hr);

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrPassword, newVal ));

    m_fDirty = true;


    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUploadJob::get_FileName( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrFileName, pVal );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_OriginalSize( /*[out]*/ long *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_OriginalSize",hr,pVal,m_lOriginalSize);

    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_TotalSize( /*[out]*/ long *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_TotalSize",hr,pVal,m_lTotalSize);

    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_SentSize( /*[out]*/ long *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_SentSize",hr,pVal,m_lSentSize);

    __ULT_END_PROPERTY(hr);
}

HRESULT CMPCUploadJob::put_SentSize( /*[in]*/ long newVal ) // INTERNAL METHOD.
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_SentSize",hr);

    long lSentSize;
    long lTotalSize;


    m_lSentSize = newVal;
    m_fDirty    = true;


    lSentSize  = m_lSentSize;
    lTotalSize = m_lTotalSize;

    lock = NULL; // Release the lock before firing the event.

    //
    // Important, leave this call outside Locked Sections!!
    //
    Fire_onProgressChange( this, lSentSize, lTotalSize );


    __ULT_END_PROPERTY(hr);
}

HRESULT CMPCUploadJob::put_Response ( /*[in] */ long lSize, /*[in]*/ LPBYTE pData ) // INTERNAL METHOD
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::put_Response" );

    HRESULT                      hr;
    CComPtr<MPC::FileStream>     stream;
    MPC::SmartLock<_ThreadModel> lock( this );


    //
    // Delete old data.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveResponse());


    if(lSize && m_bstrFileName.Length())
    {
        ULONG lWritten;


        //
        // Create the name for the response file.
        //
        m_bstrFileNameResponse = m_bstrFileName; m_bstrFileNameResponse.Append( L".resp" );


        //
        // Copy the data to a file.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForWrite( SAFEBSTR( m_bstrFileNameResponse ) ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Write( pData, lSize, &lWritten ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    stream.Release();

    if(FAILED(hr))
    {
        (void)RemoveResponse();
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_History( /*[out]*/ UL_HISTORY *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_History",hr,pVal,m_uhHistory);

    __ULT_END_PROPERTY(hr);
}

STDMETHODIMP CMPCUploadJob::put_History( /*[in]*/ UL_HISTORY newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_History",hr);

    CHECK_MODIFY();

    //
    // During debug, override user settings.
    //
    if(g_Override_History)
    {
        newVal = g_Override_History_Value;
    }

    //
    // Check for proper value of input parameters.
    //
    switch(newVal)
    {
    case UL_HISTORY_NONE        :
    case UL_HISTORY_LOG         :
    case UL_HISTORY_LOG_AND_DATA: break;

    default:
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }


    m_uhHistory = newVal;
    m_fDirty    = true;


    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_Status( /*[out]*/ UL_STATUS *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_Status",hr,pVal,m_usStatus);

    __ULT_END_PROPERTY(hr);
}

HRESULT CMPCUploadJob::put_Status( /*[in]*/ UL_STATUS newVal ) // INTERNAL METHOD.
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::put_Status" );

    HRESULT hr = try_Status( (UL_STATUS)-1, newVal );

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUploadJob::try_Status( /*[in]*/ UL_STATUS usPreVal  ,
                                   /*[in]*/ UL_STATUS usPostVal )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::try_Status" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    bool                         fChanged = false;
    UL_STATUS                    usStatus;


    if(usPreVal == m_usStatus ||
       usPreVal == -1          )
    {
        m_usStatus = usPostVal;
        m_fDirty   = true;

        usStatus   = m_usStatus;
        fChanged   = true;

        //
        // Clean error while tranmitting.
        //
        if(m_usStatus == UL_TRANSMITTING)
        {
            m_dwErrorCode = 0;
        }


        switch(m_usStatus)
        {
        case UL_FAILED:
        case UL_COMPLETED:
        case UL_DELETED:
            //
            // The job is done, successfully or not, so it's time to do some cleanup.
            //
            switch(m_uhHistory)
            {
            case UL_HISTORY_NONE:
                m_usStatus = UL_DELETED;

            case UL_HISTORY_LOG:
                __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveData());

            case UL_HISTORY_LOG_AND_DATA:
                break;
            }

        case UL_ABORTED:
            m_dCompleteTime = MPC::GetLocalTime();
            break;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    lock = NULL; // Release the lock before firing the event.

    //
    // Important, leave these calls outside Locked Sections!!
    //
    if(SUCCEEDED(hr) && fChanged)
    {
        Fire_onStatusChange( this, usStatus );

        //
        // Recompute queue.
        //
        if(m_mpcuRoot)
        {
            hr = m_mpcuRoot->TriggerRescheduleJobs();
        }
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_ErrorCode( /*[out]*/ long *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_ErrorCode",hr,pVal,(long)m_dwErrorCode);

    __ULT_END_PROPERTY(hr);
}

HRESULT CMPCUploadJob::put_ErrorCode( /*[in]*/ DWORD newVal ) // INTERNAL METHOD.
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_ErrorCode",hr);

    m_dwErrorCode = newVal;
    m_fDirty      = true;

    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUploadJob::get_RetryInterval( /*[out]*/ DWORD *pVal ) // INTERNAL METHOD
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_RetryInterval",hr,pVal,m_dwRetryInterval);

    __ULT_END_PROPERTY(hr);
}

HRESULT CMPCUploadJob::put_RetryInterval( /*[in] */ DWORD newVal ) // INTERNAL METHOD
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_RetryInterval",hr);

    m_dwRetryInterval = newVal;

    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_Mode( /*[out]*/ UL_MODE *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_Mode",hr,pVal,m_umMode);

    __ULT_END_PROPERTY(hr);
}

STDMETHODIMP CMPCUploadJob::put_Mode( /*[in]*/ UL_MODE newVal )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::put_Mode" );

    HRESULT                      hr;
    bool                         fChanged = false;
    MPC::SmartLock<_ThreadModel> lock( this );

    CHECK_MODIFY();


    //
    // Check for proper value of input parameters.
    //
    switch(newVal)
    {
    case UL_BACKGROUND:
    case UL_FOREGROUND: break;

    default:
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }


    if(m_umMode != newVal)
    {
        m_umMode = newVal;
        m_fDirty = true;

        fChanged = true;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    lock = NULL; // Release the lock before firing the event.

    //
    // Important, keep this call outside Locked section, otherwise deadlocks are possibles.
    //
    if(SUCCEEDED(hr) && fChanged)
    {
        //
        // Recompute queue.
        //
        if(m_mpcuRoot)
        {
            hr = m_mpcuRoot->TriggerRescheduleJobs();
        }
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_PersistToDisk( /*[out]*/ VARIANT_BOOL *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_PersistToDisk",hr,pVal,m_fPersistToDisk);

    __ULT_END_PROPERTY(hr);
}

STDMETHODIMP CMPCUploadJob::put_PersistToDisk( /*[in]*/ VARIANT_BOOL newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_PersistToDisk",hr);

    CHECK_MODIFY();


    //
    // During debug, override user settings.
    //
    if(g_Override_Persist)
    {
        newVal = g_Override_Persist_Value;
    }


    m_fPersistToDisk = newVal;
    m_fDirty         = true;


    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_Compressed( /*[out]*/ VARIANT_BOOL *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_Compressed",hr,pVal,m_fCompressed);

    __ULT_END_PROPERTY(hr);
}

STDMETHODIMP CMPCUploadJob::put_Compressed( /*[in]*/ VARIANT_BOOL newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_Compressed",hr);

    CHECK_MODIFY();

    //
    // You can't change the compression flag after having set the data!!
    //
    if(m_lOriginalSize != 0)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    }

    //
    // During debug, override user settings.
    //
    if(g_Override_Compressed)
    {
        newVal = g_Override_Compressed_Value;
    }



    m_fCompressed = newVal;
    m_fDirty      = true;


    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_Priority( /*[out]*/ long *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_Priority",hr,pVal,m_lPriority);

    __ULT_END_PROPERTY(hr);
}

STDMETHODIMP CMPCUploadJob::put_Priority( /*[in]*/ long newVal )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::put_Priority" );

    HRESULT                      hr;
    bool                         fChanged = false;
    MPC::SmartLock<_ThreadModel> lock( this );


    CHECK_MODIFY();


    if(m_lPriority != newVal)
    {
        m_lPriority = newVal;
        m_fDirty    = true;

        fChanged    = true;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    lock = NULL; // Release the lock before firing the event.

    //
    // Important, keep this call outside Locked section, otherwise deadlocks are possibles.
    //
    if(SUCCEEDED(hr) && fChanged)
    {
        //
        // Recompute queue.
        //
        if(m_mpcuRoot)
        {
            hr = m_mpcuRoot->TriggerRescheduleJobs();
        }
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_CreationTime( /*[out]*/ DATE *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_CreationTime",hr,pVal,m_dCreationTime);

    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_CompleteTime( /*[out]*/ DATE *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_CompleteTime",hr,pVal,m_dCompleteTime);

    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::get_ExpirationTime( /*[out]*/ DATE *pVal )
{
    __ULT_BEGIN_PROPERTY_GET2("CMPCUploadJob::get_ExpirationTime",hr,pVal,m_dExpirationTime);

    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::put_ExpirationTime( /*[in]*/ DATE newVal )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_ExpirationTime",hr);

    CHECK_MODIFY();


    m_dExpirationTime = newVal;


    __ULT_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////
// Methods //
/////////////

STDMETHODIMP CMPCUploadJob::ActivateSync()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::ActivateSync" );

    HRESULT                   hr;
    CComPtr<CMPCUploadEvents> mpcueEvent;
    CComPtr<IMPCUploadJob>    mpcujJob;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ActivateAsync());

    //
    // Create a new job and link it to the system.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &mpcueEvent ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, QueryInterface( IID_IMPCUploadJob, (void**)&mpcujJob ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, mpcueEvent->WaitForCompletion( mpcujJob ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadJob::ActivateAsync()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::ActivateAsync" );

    HRESULT                      hr;
    UploadLibrary::Signature     sigEmpty;
    MPC::SmartLock<_ThreadModel> lock( this );


    CHECK_MODIFY();


    if(m_lOriginalSize == 0)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_NO_DATA);
    }


    if(m_sigClient               == sigEmpty ||
       m_bstrServer    .Length() == 0        ||
       m_bstrProviderID.Length() == 0         )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_INVALID_PARAMETERS);
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    lock = NULL; // Release the lock before firing the event.

    //
    // Important, leave this call outside Locked Sections!!
    //
    if(SUCCEEDED(hr)) put_Status( UL_ACTIVE );

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadJob::Suspend()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::Suspend" );

    HRESULT                      hr;
    UL_STATUS                    usStatus;
    MPC::SmartLock<_ThreadModel> lock( this );


    usStatus = m_usStatus;


    if(usStatus == UL_ACTIVE       ||
       usStatus == UL_TRANSMITTING ||
       usStatus == UL_ABORTED       )
    {
        lock = NULL; // Release the lock before firing the event.

        //
        // Important, leave this call outside Locked Sections!!
        //
        hr = try_Status( usStatus, UL_SUSPENDED );
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadJob::Delete()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::Delete" );

    HRESULT hr;


    hr = put_Status( UL_DELETED );


    __ULT_FUNC_EXIT(hr);
}



STDMETHODIMP CMPCUploadJob::GetDataFromFile( /*[in]*/ BSTR bstrFileName )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::GetDataFromFile" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> streamIn;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFileName);
    __MPC_PARAMCHECK_END();


    ////////////////////////////////////////////////////////////////////////////////
    //
    // Open the destination file, impersonating the caller.
    //
    {
        MPC::Impersonation imp;

        __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
        __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamIn ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn->InitForRead( bstrFileName ));
    }
    //
    ////////////////////////////////////////////////////////////////////////////////

    //
    // Copy the source file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDataFromStream( streamIn ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadJob::PutDataIntoFile( /*[in]*/ BSTR bstrFileName )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::PutDataIntoFile" );

    HRESULT                  hr;
    CComPtr<IUnknown>        unk;
    CComPtr<IStream>         streamIn;
    CComPtr<MPC::FileStream> streamOut;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFileName);
    __MPC_PARAMCHECK_END();


    //
    // Open the source file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, PutDataIntoStream( &unk ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, unk.QueryInterface( &streamIn ));


    ////////////////////////////////////////////////////////////////////////////////
    //
    // Open the destination file, impersonating the caller.
    //
    {
        MPC::Impersonation imp;

        __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
        __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamOut ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut->InitForWrite( bstrFileName ));
    }
    //
    ////////////////////////////////////////////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamIn, streamOut ));


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadJob::GetDataFromStream( /*[in]*/ IUnknown* stream )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::GetDataFromStream" );

    HRESULT                      hr;
    DWORD                        dwQueueSize;
    CComPtr<IStream>             streamIn;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(stream);
    __MPC_PARAMCHECK_END();

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->QueryInterface( IID_IStream, (void**)&streamIn ));


    //
    // Calculate current queue size.
    //
    lock = NULL; // Release the lock before calling the root.
    if(m_mpcuRoot)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcuRoot->CalculateQueueSize( dwQueueSize ));
    }
    lock = this; // Reget the lock.

    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateDataFromStream( streamIn, dwQueueSize ));


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadJob::PutDataIntoStream( /*[out, retval]*/ IUnknown* *pstream )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::PutDataIntoStream" );

    HRESULT                      hr;
    CComPtr<IStream>             streamOut;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pstream,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenReadStreamForData( &streamOut ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut.QueryInterface( pstream ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP CMPCUploadJob::GetResponseAsStream( /*[out, retval]*/ IUnknown* *pstream )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::GetResponseAsStream" );

    HRESULT                      hr;
    CComBSTR                     bstrTmpFileName;
    CComPtr<MPC::FileStream>     stream;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pstream,NULL);
    __MPC_PARAMCHECK_END();


    if(m_bstrFileNameResponse.Length() == 0)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_UPLOADLIBRARY_NO_DATA);
    }


    //
    // Generate a temporary file name.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateTmpFileName( bstrTmpFileName ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyFile( m_bstrFileNameResponse, bstrTmpFileName ));

    //
    // Open the file as a stream and set the DeleteOnRelease flag.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForRead    ( bstrTmpFileName ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->DeleteOnRelease( true            ));

    *pstream = stream.Detach();
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;

    stream.Release();

    if(FAILED(hr) && bstrTmpFileName.Length())
    {
        (void)MPC::DeleteFile( bstrTmpFileName );
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMPCUploadJob::put_onStatusChange( /*[in]*/ IDispatch* function )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_onStatusChange",hr);

    m_sink_onStatusChange = function;

    __ULT_END_PROPERTY(hr);
}

STDMETHODIMP CMPCUploadJob::put_onProgressChange( /*[in]*/ IDispatch* function )
{
    __ULT_BEGIN_PROPERTY_PUT("CMPCUploadJob::put_onProgressChange",hr);

    m_sink_onProgressChange = function;

    __ULT_END_PROPERTY(hr);
}


/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUploadJob::SetupRequest( /*[out]*/ UploadLibrary::ClientRequest_OpenSession& crosReq )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::SetupRequest" );

    HRESULT hr;


    crosReq.crHeader.sigClient =           m_sigClient;
    crosReq.szJobID            = SAFEBSTR( m_bstrJobID      );
    crosReq.szProviderID       = SAFEBSTR( m_bstrProviderID );
    crosReq.szUsername         = SAFEBSTR( m_bstrUsername   );
    crosReq.dwSize             =           m_lTotalSize;
    crosReq.dwSizeOriginal     =           m_lOriginalSize;
    crosReq.dwCRC              =           m_dwCRC;
    crosReq.fCompressed        =          (m_fCompressed == VARIANT_TRUE ? true : false);

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUploadJob::SetupRequest( /*[out]*/ UploadLibrary::ClientRequest_WriteSession& crwsReq, /*[in]*/ DWORD dwSize )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::SetupRequest" );

    HRESULT hr;


    crwsReq.crHeader.sigClient =           m_sigClient;
    crwsReq.szJobID            = SAFEBSTR( m_bstrJobID );
    crwsReq.dwOffset           =           m_lSentSize;
    crwsReq.dwSize             =           dwSize;

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMPCUploadJob::GetProxySettings()
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::GetProxySettings" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_Proxy.Initialize( true ));


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CMPCUploadJob::SetProxySettings( /*[in]*/ HINTERNET hSession )
{
    __ULT_FUNC_ENTRY( "CMPCUploadJob::SetProxySettings" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_Proxy.Apply( hSession ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcuploadjob.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCUploadJob.h

Abstract:
    This file contains the declaration of the CMPCUploadJob class,
    the descriptor of all jobs present in the Upload Library system.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULMANAGER___MPCUPLOADJOB_H___)
#define __INCLUDED___ULMANAGER___MPCUPLOADJOB_H___


class CMPCUpload;


class ATL_NO_VTABLE CMPCUploadJob : // Hungarian: mpcuj
    public MPC::ConnectionPointImpl<CMPCUploadJob, &DIID_DMPCUploadEvents, MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IMPCUploadJob, &IID_IMPCUploadJob, &LIBID_UPLOADMANAGERLib>,
    public IMPCPersist // Persistence
{
    typedef UploadLibrary::Signature Sig;


    CMPCUpload*              m_mpcuRoot;              // Volatile
    DWORD                    m_dwRetryInterval;       // Volatile

    ULONG                    m_dwInternalSeq;         // Local

    Sig                      m_sigClient;             // Global
    CComBSTR                 m_bstrServer;            // Local
    CComBSTR                 m_bstrJobID;             // Global
    CComBSTR                 m_bstrProviderID;        // Global

    CComBSTR                 m_bstrCreator;           // Local
    CComBSTR                 m_bstrUsername;          // Global
    CComBSTR                 m_bstrPassword;          // Global

    CComBSTR                 m_bstrFileNameResponse;  // Local
    CComBSTR                 m_bstrFileName;          // Local
    long                     m_lOriginalSize;         // Global
    long                     m_lTotalSize;            // Global
    long                     m_lSentSize;             // Global
    DWORD                    m_dwCRC;                 // Global

    UL_HISTORY               m_uhHistory;             // Local
    UL_STATUS                m_usStatus;              // Local
    DWORD                    m_dwErrorCode;           // Local

    UL_MODE                  m_umMode;                // Local
    VARIANT_BOOL             m_fPersistToDisk;        // Local
    VARIANT_BOOL             m_fCompressed;           // Local
    long                     m_lPriority;             // Local

    DATE                     m_dCreationTime;         // Local
    DATE                     m_dCompleteTime;         // Local
    DATE                     m_dExpirationTime;       // Local

    MPC::Connectivity::Proxy m_Proxy;                 // Local

    CComPtr<IDispatch>       m_sink_onStatusChange;   // Volatile
    CComPtr<IDispatch>       m_sink_onProgressChange; // Volatile

    mutable bool             m_fDirty;                // Volatile


    ////////////////////////////////////////

    HRESULT CreateFileName   ( /*[out]*/ CComBSTR& bstrFileName    );
    HRESULT CreateTmpFileName( /*[out]*/ CComBSTR& bstrTmpFileName );

    HRESULT CreateDataFromStream ( /*[in ]*/ IStream*   streamIn , /*[in]*/ DWORD dwQueueSize );
    HRESULT OpenReadStreamForData( /*[out]*/ IStream* *pstreamOut                             );

public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CMPCUploadJob)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMPCUploadJob)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IMPCUploadJob)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()

    CMPCUploadJob();
    virtual ~CMPCUploadJob();


    HRESULT LinkToSystem( /*[in]*/ CMPCUpload* mpcuRoot );
    HRESULT Unlink      (                               );

    ////////////////////////////////////////

    HRESULT SetSequence( /*[in]*/ ULONG lSeq );

    ////////////////////////////////////////

    HRESULT CanModifyProperties();
    HRESULT CanRelease( bool& fResult );

    HRESULT RemoveData    ();
    HRESULT RemoveResponse();

    bool operator<( /*[in]*/ const CMPCUploadJob& x ) const
    {
        if(m_lPriority < x.m_lPriority) return true;
        if(m_umMode    < x.m_umMode   ) return true; // Works, because BACKGROUND < FOREGROUND.

        return false;
    }


    HRESULT Fire_onStatusChange  ( IMPCUploadJob* mpcujJob, tagUL_STATUS usStatus              );
    HRESULT Fire_onProgressChange( IMPCUploadJob* mpcujJob, LONG lCurrentSize, LONG lTotalSize );


public:
    // IMPCPersist
    STDMETHOD_(bool,IsDirty)();
    STDMETHOD(Load)( /*[in]*/ MPC::Serializer& streamIn  );
    STDMETHOD(Save)( /*[in]*/ MPC::Serializer& streamOut );


    // IMPCUploadJob
    HRESULT   get_Sequence       ( /*[out]*/ ULONG        *pVal   ); // INTERNAL METHOD
    STDMETHOD(get_Sig           )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_Sig           )( /*[in] */ BSTR          newVal );
    STDMETHOD(get_Server        )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_Server        )( /*[in] */ BSTR          newVal );
    STDMETHOD(get_JobID         )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_JobID         )( /*[in] */ BSTR          newVal );
    STDMETHOD(get_ProviderID    )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_ProviderID    )( /*[in] */ BSTR          newVal );

    HRESULT   put_Creator        ( /*[out]*/ BSTR          newVal ); // INTERNAL METHOD
    STDMETHOD(get_Creator       )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(get_Username      )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_Username      )( /*[in] */ BSTR          newVal );
    STDMETHOD(get_Password      )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_Password      )( /*[in] */ BSTR          newVal );

    HRESULT   get_FileName       ( /*[out]*/ BSTR         *pVal                         ); // INTERNAL METHOD
    STDMETHOD(get_OriginalSize  )( /*[out]*/ long         *pVal                         );
    STDMETHOD(get_TotalSize     )( /*[out]*/ long         *pVal                         );
    STDMETHOD(get_SentSize      )( /*[out]*/ long         *pVal                         );
    HRESULT   put_SentSize       ( /*[in] */ long          newVal                       ); // INTERNAL METHOD
    HRESULT   put_Response       ( /*[in] */ long          lSize, /*[in]*/ LPBYTE pData ); // INTERNAL METHOD

    STDMETHOD(get_History       )( /*[out]*/ UL_HISTORY   *pVal   );
    STDMETHOD(put_History       )( /*[in] */ UL_HISTORY    newVal );
    STDMETHOD(get_Status        )( /*[out]*/ UL_STATUS    *pVal   );
    HRESULT   put_Status         ( /*[in] */ UL_STATUS     newVal ); // INTERNAL METHOD
    STDMETHOD(get_ErrorCode     )( /*[out]*/ long         *pVal   );
    HRESULT   put_ErrorCode      ( /*[in] */ DWORD         newVal ); // INTERNAL METHOD

    HRESULT   get_RetryInterval  ( /*[in] */ DWORD        *pVal   ); // INTERNAL METHOD
    HRESULT   put_RetryInterval  ( /*[in] */ DWORD         newVal ); // INTERNAL METHOD

    HRESULT   try_Status         ( /*[in]*/  UL_STATUS     ulPreVal, /*[in]*/ UL_STATUS ulPostVal ); // INTERNAL METHOD

    STDMETHOD(get_Mode          )( /*[out]*/ UL_MODE      *pVal   );
    STDMETHOD(put_Mode          )( /*[in] */ UL_MODE       newVal );
    STDMETHOD(get_PersistToDisk )( /*[out]*/ VARIANT_BOOL *pVal   );
    STDMETHOD(put_PersistToDisk )( /*[in] */ VARIANT_BOOL  newVal );
    STDMETHOD(get_Compressed    )( /*[out]*/ VARIANT_BOOL *pVal   );
    STDMETHOD(put_Compressed    )( /*[in] */ VARIANT_BOOL  newVal );
    STDMETHOD(get_Priority      )( /*[out]*/ long         *pVal   );
    STDMETHOD(put_Priority      )( /*[in] */ long          newVal );

    STDMETHOD(get_CreationTime  )( /*[out]*/ DATE         *pVal   );
    STDMETHOD(get_CompleteTime  )( /*[out]*/ DATE         *pVal   );
    STDMETHOD(get_ExpirationTime)( /*[out]*/ DATE         *pVal   );
    STDMETHOD(put_ExpirationTime)( /*[in] */ DATE          newVal );


    STDMETHOD(ActivateSync )();
    STDMETHOD(ActivateAsync)();
    STDMETHOD(Suspend      )();
    STDMETHOD(Delete       )();


    STDMETHOD(GetDataFromFile)( /*[in]*/ BSTR bstrFileName );
    STDMETHOD(PutDataIntoFile)( /*[in]*/ BSTR bstrFileName );

    STDMETHOD(GetDataFromStream  )( /*[in] */ IUnknown*  stream  );
    STDMETHOD(PutDataIntoStream  )( /*[out]*/ IUnknown* *pstream );
    STDMETHOD(GetResponseAsStream)( /*[out]*/ IUnknown* *pstream );

    STDMETHOD(put_onStatusChange  )( /*[in]*/ IDispatch* function );
    STDMETHOD(put_onProgressChange)( /*[in]*/ IDispatch* function );

    //
    // Support Methods.
    //
    HRESULT SetupRequest( /*[out]*/ UploadLibrary::ClientRequest_OpenSession&  crosReq                        );
    HRESULT SetupRequest( /*[out]*/ UploadLibrary::ClientRequest_WriteSession& crwsReq, /*[in]*/ DWORD dwSize );

    HRESULT GetProxySettings(                             );
    HRESULT SetProxySettings( /*[in]*/ HINTERNET hSession );
};

typedef MPC::CComObjectNoLock<CMPCUploadJob> CMPCUploadJob_Object;

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CMPCUploadJobWrapper : // Hungarian: mpcujr
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IMPCUploadJob, &IID_IMPCUploadJob, &LIBID_UPLOADMANAGERLib>,
    public IConnectionPointContainer
{
    CMPCUploadJob* m_Object;

public:
    CMPCUploadJobWrapper();

    HRESULT Init        ( /*[in]*/ CMPCUploadJob* obj );
    void    FinalRelease(                             );

BEGIN_COM_MAP(CMPCUploadJobWrapper)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IMPCUploadJob)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()

public:
    // IMPCUploadJob
    STDMETHOD(get_Sig           )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_Sig           )( /*[in] */ BSTR          newVal );
    STDMETHOD(get_Server        )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_Server        )( /*[in] */ BSTR          newVal );
    STDMETHOD(get_JobID         )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_JobID         )( /*[in] */ BSTR          newVal );
    STDMETHOD(get_ProviderID    )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_ProviderID    )( /*[in] */ BSTR          newVal );

    STDMETHOD(get_Creator       )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(get_Username      )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_Username      )( /*[in] */ BSTR          newVal );
    STDMETHOD(get_Password      )( /*[out]*/ BSTR         *pVal   );
    STDMETHOD(put_Password      )( /*[in] */ BSTR          newVal );

    STDMETHOD(get_OriginalSize  )( /*[out]*/ long         *pVal   );
    STDMETHOD(get_TotalSize     )( /*[out]*/ long         *pVal   );
    STDMETHOD(get_SentSize      )( /*[out]*/ long         *pVal   );

    STDMETHOD(get_History       )( /*[out]*/ UL_HISTORY   *pVal   );
    STDMETHOD(put_History       )( /*[in] */ UL_HISTORY    newVal );
    STDMETHOD(get_Status        )( /*[out]*/ UL_STATUS    *pVal   );
    STDMETHOD(get_ErrorCode     )( /*[out]*/ long         *pVal   );

    STDMETHOD(get_Mode          )( /*[out]*/ UL_MODE      *pVal   );
    STDMETHOD(put_Mode          )( /*[in] */ UL_MODE       newVal );
    STDMETHOD(get_PersistToDisk )( /*[out]*/ VARIANT_BOOL *pVal   );
    STDMETHOD(put_PersistToDisk )( /*[in] */ VARIANT_BOOL  newVal );
    STDMETHOD(get_Compressed    )( /*[out]*/ VARIANT_BOOL *pVal   );
    STDMETHOD(put_Compressed    )( /*[in] */ VARIANT_BOOL  newVal );
    STDMETHOD(get_Priority      )( /*[out]*/ long         *pVal   );
    STDMETHOD(put_Priority      )( /*[in] */ long          newVal );

    STDMETHOD(get_CreationTime  )( /*[out]*/ DATE         *pVal   );
    STDMETHOD(get_CompleteTime  )( /*[out]*/ DATE         *pVal   );
    STDMETHOD(get_ExpirationTime)( /*[out]*/ DATE         *pVal   );
    STDMETHOD(put_ExpirationTime)( /*[in] */ DATE          newVal );


    STDMETHOD(ActivateSync )();
    STDMETHOD(ActivateAsync)();
    STDMETHOD(Suspend      )();
    STDMETHOD(Delete       )();


    STDMETHOD(GetDataFromFile)( /*[in]*/ BSTR bstrFileName );
    STDMETHOD(PutDataIntoFile)( /*[in]*/ BSTR bstrFileName );

    STDMETHOD(GetDataFromStream  )( /*[in] */ IUnknown*  stream  );
    STDMETHOD(PutDataIntoStream  )( /*[out]*/ IUnknown* *pstream );
    STDMETHOD(GetResponseAsStream)( /*[out]*/ IUnknown* *pstream );

    STDMETHOD(put_onStatusChange  )( /*[in]*/ IDispatch* function );
    STDMETHOD(put_onProgressChange)( /*[in]*/ IDispatch* function );

    // IConnectionPointContainer
    STDMETHOD(EnumConnectionPoints)( /*[out]*/ IEnumConnectionPoints* *ppEnum );
    STDMETHOD(FindConnectionPoint )( /*[in] */ REFIID riid, /*[out]*/ IConnectionPoint* *ppCP );
};

#endif // !defined(__INCLUDED___ULMANAGER___MPCUPLOADJOB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\persist.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Persist.h

Abstract:
    This file contains the declaration of the IMPCPersist interface,
    which should be implemented by all the objects participating to
    persistent storage.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULMANAGER___PERSIST_H___)
#define __INCLUDED___ULMANAGER___PERSIST_H___

#include <UploadLibrary.h>

class IMPCPersist : public IUnknown // Hungarian: mpcp
{
public:
    virtual bool    STDMETHODCALLTYPE IsDirty() = 0;

    virtual HRESULT STDMETHODCALLTYPE Load( /*[in]*/ MPC::Serializer& streamIn  ) = 0;
    virtual HRESULT STDMETHODCALLTYPE Save( /*[in]*/ MPC::Serializer& streamOut ) = 0;
};

#endif // !defined(__INCLUDED___ULMANAGER___PERSIST_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\mpcwrappers.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPCWrapper.cpp

Abstract:
    This file contains the implementation of the COM wrappers, to export to clients
	the internal objects.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

CMPCUploadWrapper::CMPCUploadWrapper()
{
	m_Object = NULL; // CMPCUpload* m_Object;
}

HRESULT CMPCUploadWrapper::FinalConstruct()
{
	m_Object = &g_Root; g_Root.AddRef();

	return S_OK;
}

void CMPCUploadWrapper::FinalRelease()
{
	if(m_Object)
	{
		m_Object->Release();

		m_Object = NULL;
	}
}

////////////////////////////////////////

STDMETHODIMP CMPCUploadWrapper::get__NewEnum( /*[out]*/ IUnknown* *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get__NewEnum, pVal);
}

STDMETHODIMP CMPCUploadWrapper::Item( /*[in]*/ long index, /*[out]*/ IMPCUploadJob* *pVal )
{
	MPC_FORWARD_CALL_2(m_Object,Item, index, pVal);
}

STDMETHODIMP CMPCUploadWrapper::get_Count( /*[out]*/ long *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Count, pVal);
}

STDMETHODIMP CMPCUploadWrapper::CreateJob( /*[out]*/ IMPCUploadJob* *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,CreateJob, pVal);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CMPCUploadJobWrapper::CMPCUploadJobWrapper()
{
	m_Object = NULL; // CMPCUploadJob* m_Object;
}

HRESULT CMPCUploadJobWrapper::Init( CMPCUploadJob* obj )
{
	m_Object = obj; obj->AddRef();

	return S_OK;
}

void CMPCUploadJobWrapper::FinalRelease()
{
	if(m_Object)
	{
		m_Object->Release();

		m_Object = NULL;
	}
}

////////////////////////////////////////

STDMETHODIMP CMPCUploadJobWrapper::get_Sig( /*[out]*/ BSTR *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Sig,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_Sig( /*[in]*/ BSTR newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_Sig,newVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_Server( /*[out]*/ BSTR *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Server,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_Server( /*[in]*/ BSTR newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_Server,newVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_JobID( /*[out]*/ BSTR *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_JobID,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_JobID( /*[in] */ BSTR newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_JobID,newVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_ProviderID( /*[out]*/ BSTR *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_ProviderID,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_ProviderID( /*[in] */ BSTR newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_ProviderID,newVal);
}


STDMETHODIMP CMPCUploadJobWrapper::get_Creator( /*[out]*/ BSTR *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Creator,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_Username( /*[out]*/ BSTR *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Username,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_Username( /*[in] */ BSTR newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_Username,newVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_Password( /*[out]*/ BSTR *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Password,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_Password( /*[in] */ BSTR newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_Password,newVal);
}


STDMETHODIMP CMPCUploadJobWrapper::get_OriginalSize( /*[out]*/ long *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_OriginalSize,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_TotalSize( /*[out]*/ long *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_TotalSize,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_SentSize( /*[out]*/ long *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_SentSize,pVal);
}


STDMETHODIMP CMPCUploadJobWrapper::get_History( /*[out]*/ UL_HISTORY *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_History,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_History( /*[in] */ UL_HISTORY newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_History,newVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_Status( /*[out]*/ UL_STATUS *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Status,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_ErrorCode( /*[out]*/ long *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_ErrorCode,pVal);
}


STDMETHODIMP CMPCUploadJobWrapper::get_Mode( /*[out]*/ UL_MODE *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Mode,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_Mode( /*[in] */ UL_MODE newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_Mode,newVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_PersistToDisk( /*[out]*/ VARIANT_BOOL *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_PersistToDisk,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_PersistToDisk( /*[in] */ VARIANT_BOOL newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_PersistToDisk,newVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_Compressed( /*[out]*/ VARIANT_BOOL *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Compressed,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_Compressed( /*[in] */ VARIANT_BOOL newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_Compressed,newVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_Priority( /*[out]*/ long *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_Priority,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_Priority( /*[in] */ long newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_Priority,newVal);
}


STDMETHODIMP CMPCUploadJobWrapper::get_CreationTime( /*[out]*/ DATE *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_CreationTime,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_CompleteTime( /*[out]*/ DATE *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_CompleteTime,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::get_ExpirationTime( /*[out]*/ DATE *pVal )
{
	MPC_FORWARD_CALL_1(m_Object,get_ExpirationTime,pVal);
}

STDMETHODIMP CMPCUploadJobWrapper::put_ExpirationTime( /*[in] */ DATE newVal )
{
	MPC_FORWARD_CALL_1(m_Object,put_ExpirationTime,newVal);
}


STDMETHODIMP CMPCUploadJobWrapper::ActivateSync()
{
	MPC_FORWARD_CALL_0(m_Object,ActivateSync);
}

STDMETHODIMP CMPCUploadJobWrapper::ActivateAsync()
{
	MPC_FORWARD_CALL_0(m_Object,ActivateAsync);
}

STDMETHODIMP CMPCUploadJobWrapper::Suspend()
{
	MPC_FORWARD_CALL_0(m_Object,Suspend);
}

STDMETHODIMP CMPCUploadJobWrapper::Delete()
{
	MPC_FORWARD_CALL_0(m_Object,Delete);
}



STDMETHODIMP CMPCUploadJobWrapper::GetDataFromFile( /*[in]*/ BSTR bstrFileName )
{
	MPC_FORWARD_CALL_1(m_Object,GetDataFromFile,bstrFileName);
}

STDMETHODIMP CMPCUploadJobWrapper::PutDataIntoFile( /*[in]*/ BSTR bstrFileName )
{
	MPC_FORWARD_CALL_1(m_Object,PutDataIntoFile,bstrFileName);
}


STDMETHODIMP CMPCUploadJobWrapper::GetDataFromStream( /*[in] */ IUnknown* stream )
{
	MPC_FORWARD_CALL_1(m_Object,GetDataFromStream,stream);
}

STDMETHODIMP CMPCUploadJobWrapper::PutDataIntoStream( /*[in] */ IUnknown* *pstream )
{
	MPC_FORWARD_CALL_1(m_Object,PutDataIntoStream,pstream);
}

STDMETHODIMP CMPCUploadJobWrapper::GetResponseAsStream( /*[out]*/ IUnknown* *ppstream )
{
	MPC_FORWARD_CALL_1(m_Object,GetResponseAsStream,ppstream);
}


STDMETHODIMP CMPCUploadJobWrapper::put_onStatusChange( /*[in]*/ IDispatch* function )
{
	MPC_FORWARD_CALL_1(m_Object,put_onStatusChange,function);
}

STDMETHODIMP CMPCUploadJobWrapper::put_onProgressChange( /*[in]*/ IDispatch* function )
{
	MPC_FORWARD_CALL_1(m_Object,put_onProgressChange,function);
}


// IConnectionPointContainer
STDMETHODIMP CMPCUploadJobWrapper::EnumConnectionPoints( /*[out]*/ IEnumConnectionPoints* *ppEnum )
{
	MPC_FORWARD_CALL_1(m_Object,EnumConnectionPoints,ppEnum);
}

STDMETHODIMP CMPCUploadJobWrapper::FindConnectionPoint( /*[in] */ REFIID riid, /*[out]*/ IConnectionPoint* *ppCP )
{
	MPC_FORWARD_CALL_2(m_Object,FindConnectionPoint, riid, ppCP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

//#pragma warning(disable:4192)

#include <module.h>

#include <UploadLibrary.h>
#include <UploadLibraryTrace.h>

#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_logging.h>
#include <MPC_security.h>

#include <UploadManager.h>
#include <UploadManagerDID.h>

#include "resource.h"      // Resource symbols

#include "Persist.h"

#include "MPCUpload.h"
#include "MPCUploadEnum.h"
#include "MPCUploadJob.h"
#include "MPCUploadEvents.h"

#include "MPCTransportAgent.h"

#include "MPCConnection.h"

#include "MPCConfig.h"


/////////////////////////////////////////////////////////////////////////////

#define BUFFER_SIZE_TMP      (64)
#define BUFFER_SIZE_FILECOPY (512)

/////////////////////////////////////////////////////////////////////////////

HRESULT Handle_TaskScheduler( bool fActivate );

extern MPC::NTEvent     g_NTEvents;

extern CMPCConfig       g_Config;

extern bool         	g_Override_History;
extern UL_HISTORY   	g_Override_History_Value;
	
extern bool         	g_Override_Persist;
extern VARIANT_BOOL 	g_Override_Persist_Value;
	
extern bool         	g_Override_Compressed;
extern VARIANT_BOOL 	g_Override_Compressed_Value;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\common\isapiconfig.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ISAPIconfig.cpp

Abstract:
    This file contains the implementation of the CISAPIconfig class,
    the support class for accessing and modifying the configuration of the
    ISAPI extension used by the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/28/99
        created

******************************************************************************/

#include "stdafx.h"


CISAPIconfig::CISAPIconfig()
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::CISAPIconfig" );
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIconfig::ConnectToRegistry( /*[out]*/ MPC::RegKey&  rkRoot       ,
                                         /*[in] */ bool          fWriteAccess )
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::ConnectToRegistry" );

    _ASSERT(m_szRoot.length() != 0);

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.SetRoot( HKEY_LOCAL_MACHINE, fWriteAccess ? KEY_ALL_ACCESS : KEY_READ, m_szMachine.c_str() ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.Attach( m_szRoot.c_str() ));


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIconfig::SetRoot( /*[in]*/ LPCWSTR szRoot    ,
                               /*[in]*/ LPCWSTR szMachine )
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::SetRoot" );


    m_szRoot = szRoot;

    if(szMachine)
    {
        m_szMachine = szMachine;
    }


    __ULT_FUNC_EXIT(S_OK);
}


HRESULT CISAPIconfig::Install()
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::Install" );

    HRESULT     hr;
    MPC::RegKey rkRoot;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConnectToRegistry( rkRoot, true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.Create());

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIconfig::Uninstall()
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::Uninstall" );

    HRESULT     hr;
    MPC::RegKey rkRoot;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConnectToRegistry( rkRoot, true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.Delete( true ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT CISAPIconfig::Load()
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::Load" );

    HRESULT          hr;
    MPC::RegKey      rkRoot;
    MPC::WStringList lstKeys;
    MPC::WStringIter itKey;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConnectToRegistry( rkRoot, false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.EnumerateSubKeys( lstKeys ));


    m_lstInstances.clear();

    for(itKey=lstKeys.begin(); itKey != lstKeys.end(); itKey++)
    {
        CISAPIinstance isapiInstance( *itKey );

        __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance.Load( rkRoot ));

        m_lstInstances.push_back( isapiInstance );
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT CISAPIconfig::Save()
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::Save" );

    HRESULT     hr;
    MPC::RegKey rkRoot;
    Iter        itInstance;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConnectToRegistry( rkRoot, true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.DeleteSubKeys());

    for(itInstance=m_lstInstances.begin(); itInstance != m_lstInstances.end(); itInstance++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*itInstance).Save( rkRoot ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIconfig::GetInstances( /*[out]*/ Iter& itBegin ,
                                    /*[out]*/ Iter& itEnd   )
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::GetInstances" );

    HRESULT hr;


    itBegin = m_lstInstances.begin();
    itEnd   = m_lstInstances.end  ();
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIconfig::NewInstance( /*[out]*/ Iter&               itNew ,
                                   /*[in]*/  const MPC::wstring& szURL )
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::NewInstance" );

    HRESULT hr;
    bool    fFound;

    //
    // First of all, check if the given URL already exists.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetInstance( itNew, fFound, szURL ));
    if(fFound == false)
    {
        //
        // If not, create it.
        //
        itNew = m_lstInstances.insert( m_lstInstances.end(), CISAPIinstance( szURL ) );
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIconfig::GetInstance( /*[out]*/ Iter&               itOld  ,
                                   /*[out]*/ bool&               fFound ,
                                   /*[in] */ const MPC::wstring& szURL  )
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::GetInstance" );

    HRESULT hr;


    fFound = false;


    itOld = m_lstInstances.begin();
    while(itOld != m_lstInstances.end())
    {
        if(*itOld == szURL)
        {
            fFound = true;
            break;
        }

        ++itOld;
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIconfig::DelInstance( /*[in]*/ Iter& itOld )
{
    __ULT_FUNC_ENTRY( "CISAPIconfig::DelInstances" );

    HRESULT hr;


    m_lstInstances.erase( itOld );

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UploadManager.rc
//
#define IDS_PROJNAME                    100
#define IDR_UPLOADMANAGER               101
#define IDR_MPCUPLOAD                   102
#define IDR_MPCCONNECTION               103

#define IDS_UPLOADM_DISPLAYNAME         200
#define IDS_UPLOADM_DESCRIPTION         201

#define IDS_TASKNAME                    210
#define IDS_COMMENT                     211

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\client\uploadmanager\uploadmanager.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    UploadManager.cpp

Abstract:
    This file contains the initialization portion of the Upload Manager

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"

#include <initguid.h>

#include <mstask.h>         // for task scheduler apis
#include <msterr.h>

#include "UploadManager_i.c"

/////////////////////////////////////////////////////////////////////////////

#define UL_RESCHEDULE_PERIOD (30*60) // Every thirty minutes.

#define SECONDS_IN_A_DAY     (24 * 60 * 60)
#define SECONDS_IN_A_MINUTE  (          60)
#define MINUTES_IN_A_DAY     (24 * 60     )

HRESULT Handle_TaskScheduler( bool fActivate )
{
    __ULT_FUNC_ENTRY( "Handle_TaskScheduler" );

    HRESULT                     hr;
    WCHAR                       rgFileName[MAX_PATH + 1];
    WCHAR                       rgTaskName[MAX_PATH];
    WCHAR                       rgComment [MAX_PATH];
    CComBSTR                    bstrFileName;
    CComBSTR                    bstrTaskName;
    CComBSTR                    bstrComments;
    CComPtr<ITaskScheduler>     pTaskScheduler;
    CComPtr<ITask>              pTask;
    CComPtr<IScheduledWorkItem> pScheduledWorkItem;


    //
    // First create the task scheduler.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskScheduler, (void**)&pTaskScheduler ));


    //
    // Get our complete filename -- needed to create a task in the task scheduler.
    //
    __MPC_EXIT_IF_CALL_RETURNS_ZERO(hr, ::GetModuleFileNameW( NULL, rgFileName, MAX_PATH ));
    rgFileName[MAX_PATH] = 0;

    //
    // Load localized strings.
    //
    ::LoadStringW( _Module.GetResourceInstance(), IDS_TASKNAME, rgTaskName, MAXSTRLEN(rgTaskName) );
    ::LoadStringW( _Module.GetResourceInstance(), IDS_COMMENT , rgComment , MAXSTRLEN(rgComment ) );


    bstrFileName = rgFileName;
    bstrTaskName = rgTaskName;
    bstrComments = rgComment;


    hr = pTaskScheduler->Delete( bstrTaskName );
    if(FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        __MPC_TRACE_HRESULT(hr);
        __MPC_FUNC_LEAVE;
    }


    if(fActivate)
    {
        //
        // Create a new task and set its app name and parameters.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, pTaskScheduler->NewWorkItem( bstrTaskName, CLSID_CTask, IID_ITask, (IUnknown**)&pTask ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, pTask->QueryInterface( IID_IScheduledWorkItem, (void **)&pScheduledWorkItem ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, pTask->SetApplicationName( bstrFileName           ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, pTask->SetParameters     ( CComBSTR( L"-WakeUp" ) ));

        //
        // Set a NULL account information, so the task will be run as SYSTEM.
        //
		__MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetAccountInformation( L"", NULL ));


        //
        // Set the comment, so we know how this job got there.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetComment( bstrComments ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetFlags  ( 0            ));


        //
        // Now, fill in the trigger as necessary.
        //
        {
            CComPtr<ITaskTrigger> pTaskTrigger;
            WORD                  wTrigNumber;
            TASK_TRIGGER          ttTaskTrig;
            TRIGGER_TYPE_UNION    ttu;
            DAILY                 daily;


            ::ZeroMemory( &ttTaskTrig, sizeof(ttTaskTrig) ); ttTaskTrig.cbTriggerSize = sizeof(ttTaskTrig);


            //
            // Let's create it.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->CreateTrigger( &wTrigNumber, &pTaskTrigger ));


            //
            // Calculate the exact time of next activation
            //
            {
                SYSTEMTIME stNow;
                DOUBLE     dblNextScheduledTime;

                ::GetLocalTime           ( &stNow                        );
                ::SystemTimeToVariantTime( &stNow, &dblNextScheduledTime );

                dblNextScheduledTime += (double)(g_Config.get_Timing_WakeUp()) / SECONDS_IN_A_DAY;
                ::VariantTimeToSystemTime( dblNextScheduledTime, &stNow );

                ttTaskTrig.wBeginYear   = stNow.wYear;
                ttTaskTrig.wBeginMonth  = stNow.wMonth;
                ttTaskTrig.wBeginDay    = stNow.wDay;
                ttTaskTrig.wStartHour   = stNow.wHour;
                ttTaskTrig.wStartMinute = stNow.wMinute;
            }

            ttTaskTrig.MinutesDuration  = MINUTES_IN_A_DAY;
            ttTaskTrig.MinutesInterval  = (double)(g_Config.get_Timing_WakeUp()) / SECONDS_IN_A_MINUTE;
            ttTaskTrig.TriggerType      = TASK_TIME_TRIGGER_DAILY;

            daily.DaysInterval          = 1;
            ttu.Daily                   = daily;
            ttTaskTrig.Type             = ttu;

            //
            // Add this trigger to the task.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, pTaskTrigger->SetTrigger( &ttTaskTrig ));
        }

        //
        // Make the changes permanent
        //
        {
            CComPtr<IPersistFile> pIPF;

            __MPC_EXIT_IF_METHOD_FAILS(hr, pTask->QueryInterface( IID_IPersistFile, (void **)&pIPF ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, pIPF->Save( NULL, FALSE ));
        }
    }


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MPCUploadReal    , CMPCUploadWrapper)
OBJECT_ENTRY(CLSID_MPCConnectionReal, CMPCConnection   )
END_OBJECT_MAP()


static HRESULT ProcessArguments( int      argc ,
                                 LPCWSTR* argv )
{
    __ULT_FUNC_ENTRY( "ProcessArguments" );

    HRESULT hr;
    int     i;
    LPCWSTR szSvcHostGroup = NULL;
    bool    fCOM_reg      = false;
    bool    fCOM_unreg    = false;
    bool    fRunAsService = true;
	bool    fRun          = true;
    bool    fWakeUp       = false;


    for(i=1; i<argc; i++)
    {
        LPCWSTR szArg = argv[i];

        if(szArg[0] == '-' ||
           szArg[0] == '/'  )
        {
            szArg++;

            if(_wcsicmp( szArg, L"SvcHost" ) == 0 && i < argc-1)
            {
				szSvcHostGroup = argv[++i];
                continue;
            }

            if(_wcsicmp( szArg, L"UnregServer" ) == 0)
            {
                fCOM_unreg = true;
				fRun       = false;
                continue;
            }

            if(_wcsicmp( szArg, L"RegServer" ) == 0)
            {
                fCOM_reg = true;
				fRun     = false;
                continue;
            }

            if(_wcsicmp( szArg, L"Embedding" ) == 0)
            {
                fRunAsService = false;
                continue;
            }

            if(_wcsicmp( szArg, L"WakeUp" ) == 0)
            {
                fWakeUp = true;
				fRun    = false;
                continue;
            }
        }

        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    //////////////////////////////////////////////////////////////////////

	if     (fCOM_reg  ) _Module.RegisterServer  ( TRUE, (szSvcHostGroup != NULL), szSvcHostGroup );
	else if(fCOM_unreg) _Module.UnregisterServer(                                 szSvcHostGroup );

    //////////////////////////////////////////////////////////////////////

    if(fWakeUp)
    {
		CComPtr<IMPCUpload> svc;

		__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_MPCUpload, NULL, CLSCTX_ALL, IID_IMPCUpload, (void**)&svc ));

		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    //////////////////////////////////////////////////////////////////////

	if(fRun)
	{
#ifdef DEBUG
		_Module.ReadDebugSettings();
#endif

		_Module.Start( fRunAsService ? TRUE : FALSE );
	}

    //////////////////////////////////////////////////////////////////////

    hr = S_OK;

    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

BOOL JettisonPrivileges()
{
    HANDLE              hToken;
    DWORD               dwSize;
    DWORD               dwError;
    DWORD               dwIndex;
    VOID*               TokenInformation     = NULL;
    TOKEN_PRIVILEGES*   pTokenPrivileges;
    BOOL                fRet                 = FALSE;

    hToken = NULL;
    if (!OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
        &hToken))
    {
        goto LEnd;
    }

    if (!GetTokenInformation(
        hToken,
        TokenPrivileges,
        NULL, 0,
        &dwSize))
    {
        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto LEnd;
        }
    }

    TokenInformation = LocalAlloc(LPTR, dwSize);

    if (NULL == TokenInformation)
    {
        goto LEnd;
    }

    if (!GetTokenInformation(
        hToken,
        TokenPrivileges,
        TokenInformation, dwSize,
        &dwSize))
    {
        goto LEnd;
    }

    pTokenPrivileges = (TOKEN_PRIVILEGES*) TokenInformation;

    for (dwIndex = 0; dwIndex < pTokenPrivileges->PrivilegeCount; dwIndex++)
    {
        pTokenPrivileges->Privileges[dwIndex].Attributes = 4; //SE_PRIVILEGE_REMOVED;
    }

    if (!AdjustTokenPrivileges(
        hToken,
        FALSE,
        pTokenPrivileges, dwSize,
        NULL, NULL))
    {
        dwError = GetLastError();
        goto LEnd;
    }

    fRet = TRUE;    

LEnd:

    LocalFree(TokenInformation);
    return fRet;
}

extern "C" int WINAPI wWinMain( HINSTANCE   hInstance    ,
                                HINSTANCE   hPrevInstance,
                                LPWSTR      lpCmdLine    ,
                                int         nShowCmd     )
{
    HRESULT  hr;
    int      argc;
    LPCWSTR* argv;

    if (!JettisonPrivileges())
    {
        return 10;
    }

    if(SUCCEEDED(hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED ))) // We need to be a multi-threaded application.
    {
        if(SUCCEEDED(hr = ::CoInitializeSecurity( NULL                      ,
                                                  -1                        , // We don't care which authentication service we use.
                                                  NULL                      ,
                                                  NULL                      ,
                                                  RPC_C_AUTHN_LEVEL_CONNECT , // We want to identify the callers.
                                                  RPC_C_IMP_LEVEL_IDENTIFY  ,
                                                  NULL                      ,
                                                  EOAC_DYNAMIC_CLOAKING     , // Let's use the thread token for outbound calls.
                                                  NULL                      )))
        {
            __MPC_TRACE_INIT();

            g_NTEvents.Init( L"UPLOADM" );

            //
            // Parse the command line.
            //
            if(SUCCEEDED(hr = MPC::CommandLine_Parse( argc, argv )))
            {
                //
                // Initialize ATL modules.
                //
                _Module.Init( ObjectMap, hInstance, L"uploadmgr", IDS_UPLOADM_DISPLAYNAME, IDS_UPLOADM_DESCRIPTION );

                //
                // Initialize MPC module.
                //
                if(SUCCEEDED(hr = MPC::_MPC_Module.Init()))
                {
                    //
                    // Process arguments.
                    //
                    hr = ProcessArguments( argc, argv );

                    MPC::_MPC_Module.Term();
                }

                _Module.Term();

                MPC::CommandLine_Free( argc, argv );
            }

            __MPC_TRACE_TERM();
        }

        ::CoUninitialize();
    }

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\common\isapiinstance.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ISAPIinstance.cpp

Abstract:
    This file contains the implementation of the CISAPIinstance class,
    the support class for accessing and modifying the configuration of the
    ISAPI extension used by the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/28/99
        created

******************************************************************************/

#include "stdafx.h"

static WCHAR text_QUEUE_LOCATIONS     [] = L"QUEUE_LOCATIONS"     ;
static WCHAR text_QUEUE_SIZE_MAX      [] = L"QUEUE_SIZE_MAX"      ;
static WCHAR text_QUEUE_SIZE_THRESHOLD[] = L"QUEUE_SIZE_THRESHOLD";
static WCHAR text_MAXIMUM_JOB_AGE     [] = L"MAXIMUM_JOB_AGE"     ;
static WCHAR text_MAXIMUM_PACKET_SIZE [] = L"MAXIMUM_PACKET_SIZE" ;
static WCHAR text_LOG_LOCATION        [] = L"LOG_LOCATION"        ;


CISAPIinstance::CISAPIinstance( /*[in]*/ MPC::wstring szURL ) : m_flLogHandle(false) // Don't keep the log file opened.
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::CISAPIinstance" );


    m_szURL                = szURL;          //  MPC::wstring m_szURL;
                                             //
                                             //  ProvMap      m_mapProviders;
                                             //  PathList     m_lstQueueLocations;
                                             //
    m_dwQueueSizeMax       = 0;              //  DWORD        m_dwQueueSizeMax;
    m_dwQueueSizeThreshold = 0;              //  DWORD        m_dwQueueSizeThreshold;
    m_dwMaximumJobAge      = 7;              //  DWORD        m_dwMaximumJobAge;
    m_dwMaximumPacketSize  = 64*1024;        //  DWORD        m_dwMaximumPacketSize;
                                             //
                                             //  MPC::wstring m_szLogLocation;
                                             //  MPC::FileLog m_flLogHandle;
}

bool CISAPIinstance::operator==( /*[in]*/ const MPC::wstring& rhs )
{
    __ULT_FUNC_ENTRY("CISAPIinstance::operator==");

    MPC::NocaseCompare cmp;
    bool               fRes;


    fRes = cmp( m_szURL, rhs );


    __ULT_FUNC_EXIT(fRes);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIinstance::Load( /*[in]*/ MPC::RegKey& rkBase )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::Load" );

    HRESULT          hr;
    MPC::RegKey      rkRoot;
    MPC::WStringList lstKeys;
    MPC::WStringIter itKey;
    CComVariant      vValue;
    bool             fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SubKey( m_szURL.c_str(), rkRoot ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.EnumerateSubKeys( lstKeys ));

    m_mapProviders     .clear();
    m_lstQueueLocations.clear();

    for(itKey=lstKeys.begin(); itKey != lstKeys.end(); itKey++)
    {
        CISAPIprovider isapiProvider( *itKey );

        __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider.Load( rkRoot ));

        m_mapProviders[*itKey] = isapiProvider;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_QUEUE_SIZE_MAX ));
    if(fFound && vValue.vt == VT_I4) m_dwQueueSizeMax = vValue.lVal;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_QUEUE_SIZE_THRESHOLD ));
    if(fFound && vValue.vt == VT_I4) m_dwQueueSizeThreshold = vValue.lVal;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_MAXIMUM_JOB_AGE ));
    if(fFound && vValue.vt == VT_I4) m_dwMaximumJobAge = vValue.lVal;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_MAXIMUM_PACKET_SIZE ));
    if(fFound && vValue.vt == VT_I4) m_dwMaximumPacketSize = vValue.lVal;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_LOG_LOCATION ));
    if(fFound && vValue.vt == VT_BSTR)
    {
        m_szLogLocation = SAFEBSTR( vValue.bstrVal );

        if(m_szLogLocation.length())
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_flLogHandle.SetLocation( m_szLogLocation.c_str() ));
        }
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_QUEUE_LOCATIONS ));
    if(fFound && vValue.vt == VT_BSTR)
    {
        //
        // Split the registry value, a semicolon-separated list of paths, into individual paths.
        //
        MPC::wstring            szQueueLocations = SAFEBSTR( vValue.bstrVal );
        MPC::wstring::size_type iPos             = 0;
        MPC::wstring::size_type iEnd;

        while(1)
        {
            iEnd = szQueueLocations.find( L";", iPos );

            if(iEnd == MPC::string::npos) // Last component.
            {
                m_lstQueueLocations.push_back( MPC::wstring( &szQueueLocations[iPos] ) );

                break;
            }
            else
            {
                m_lstQueueLocations.push_back( MPC::wstring( &szQueueLocations[iPos], &szQueueLocations[iEnd] ) );

                iPos = iEnd+1;
            }
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT CISAPIinstance::Save( /*[in]*/ MPC::RegKey& rkBase )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::Save" );

    HRESULT     hr;
    MPC::RegKey rkRoot;
    ProvIter    itInstance;
    CComVariant vValue;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SubKey( m_szURL.c_str(), rkRoot ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.Create(                         ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.DeleteSubKeys());
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.DeleteValues ());

    for(itInstance=m_mapProviders.begin(); itInstance != m_mapProviders.end(); itInstance++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*itInstance).second.Save( rkRoot ));
    }


    vValue = (long)m_dwQueueSizeMax;
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_QUEUE_SIZE_MAX ));

    vValue = (long)m_dwQueueSizeThreshold;
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_QUEUE_SIZE_THRESHOLD ));

    vValue = (long)m_dwMaximumJobAge;
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_MAXIMUM_JOB_AGE ));

    vValue = (long)m_dwMaximumPacketSize;
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_MAXIMUM_PACKET_SIZE ));

    vValue = m_szLogLocation.c_str();
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_LOG_LOCATION ));


    {
        MPC::wstring szQueueLocations;
        PathIter     it = m_lstQueueLocations.begin();

        while(it != m_lstQueueLocations.end())
        {
            szQueueLocations.append( *it++ );

            if(it != m_lstQueueLocations.end()) szQueueLocations.append( L";" );
        }

        if(szQueueLocations.length() != 0)
        {
            vValue = szQueueLocations.c_str();
            __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_QUEUE_LOCATIONS ));
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIinstance::GetProviders( /*[out]*/ ProvIter& itBegin ,
                                      /*[out]*/ ProvIter& itEnd   )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::GetProviders" );

    HRESULT hr;


    itBegin = m_mapProviders.begin();
    itEnd   = m_mapProviders.end  ();
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIinstance::GetProvider( /*[out]*/ ProvIter&           itOld  ,
                                     /*[out]*/ bool&               fFound ,
                                     /*[in] */ const MPC::wstring& szName )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::GetProvider" );

    HRESULT hr;


    itOld = m_mapProviders.find( szName );
    if(itOld == m_mapProviders.end())
    {
        fFound = false;
    }
    else
    {
        fFound = true;
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIinstance::NewProvider( /*[out]*/ ProvIter&           itNew  ,
                                     /*[in] */ const MPC::wstring& szName )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::NewProvider" );

    HRESULT                   hr;
    std::pair<ProvIter, bool> res;
    bool                      fFound;

    //
    // First of all, check if the given URL already exists.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetProvider( itNew, fFound, szName ));
    if(fFound == false)
    {
        //
        // If not, create it.
        //
        res = m_mapProviders.insert( ProvMap::value_type( szName, CISAPIprovider( szName ) ) );
        itNew = res.first;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIinstance::DelProvider( /*[in]*/ ProvIter& itOld )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::DelProvider" );

    HRESULT hr;


    m_mapProviders.erase( itOld );

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIinstance::GetLocations( /*[out]*/ PathIter& itBegin ,
                                      /*[out]*/ PathIter& itEnd   )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::GetLocations" );

    HRESULT hr;


    itBegin = m_lstQueueLocations.begin();
    itEnd   = m_lstQueueLocations.end  ();
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIinstance::NewLocation( /*[out]*/ PathIter&           itNew  ,
                                     /*[in] */ const MPC::wstring& szPath )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::NewLocation" );

    HRESULT hr;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetLocation( itNew, fFound, szPath ));
    if(fFound == false)
    {
        itNew = m_lstQueueLocations.insert( m_lstQueueLocations.end(), szPath );
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIinstance::GetLocation( /*[out]*/ PathIter&           itOld  ,
                                     /*[out]*/ bool&               fFound ,
                                     /*[in] */ const MPC::wstring& szPath )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::GetLocation" );

    HRESULT hr;


    itOld = std::find( m_lstQueueLocations.begin(), m_lstQueueLocations.end(), szPath );
    if(itOld == m_lstQueueLocations.end())
    {
        fFound = false;
    }
    else
    {
        fFound = true;
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIinstance::DelLocation( /*[in]*/ PathIter& itOld )
{
    __ULT_FUNC_ENTRY( "CISAPIinstance::DelLocation" );

    HRESULT hr;


    m_lstQueueLocations.erase( itOld );

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIinstance::get_URL( /*[out]*/ MPC::wstring& szURL )
{
    szURL = m_szURL;

    return S_OK;
}

HRESULT CISAPIinstance::get_QueueSizeMax( /*[out]*/ DWORD& dwQueueSizeMax )
{
    dwQueueSizeMax = m_dwQueueSizeMax;

    return S_OK;
}

HRESULT CISAPIinstance::get_QueueSizeThreshold( /*[out]*/ DWORD& dwQueueSizeThreshold )
{
    dwQueueSizeThreshold = m_dwQueueSizeThreshold;

    return S_OK;
}

HRESULT CISAPIinstance::get_MaximumJobAge( /*[out]*/ DWORD& dwMaximumJobAge )
{
    dwMaximumJobAge = m_dwMaximumJobAge;

    return S_OK;
}

HRESULT CISAPIinstance::get_MaximumPacketSize( /*[out]*/ DWORD& dwMaximumPacketSize )
{
    dwMaximumPacketSize = m_dwMaximumPacketSize;

    return S_OK;
}

HRESULT CISAPIinstance::get_LogLocation( /*[out]*/ MPC::wstring& szLogLocation )
{
    szLogLocation = m_szLogLocation;

    return S_OK;
}

HRESULT CISAPIinstance::get_LogHandle( /*[out]*/ MPC::FileLog*& flLogHandle )
{
    HRESULT hr;


    if(m_szLogLocation.length())
    {
        flLogHandle = &m_flLogHandle;

        //
        // Check if it's been more than one day since the last time we rotated the log file.
        //
        hr = m_flLogHandle.Rotate( 1 );
    }
    else
    {
        flLogHandle = NULL;
        hr          = E_INVALIDARG;
    }


    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIinstance::put_QueueSizeMax( /*[in]*/ DWORD dwQueueSizeMax )
{
    m_dwQueueSizeMax = dwQueueSizeMax;

    return S_OK;
}

HRESULT CISAPIinstance::put_QueueSizeThreshold( /*[in]*/ DWORD dwQueueSizeThreshold )
{
    m_dwQueueSizeThreshold = dwQueueSizeThreshold;

    return S_OK;
}

HRESULT CISAPIinstance::put_MaximumJobAge( /*[in]*/ DWORD dwMaximumJobAge )
{
    m_dwMaximumJobAge = dwMaximumJobAge;

    return S_OK;
}

HRESULT CISAPIinstance::put_MaximumPacketSize( /*[in]*/ DWORD dwMaximumPacketSize )
{
    m_dwMaximumPacketSize = dwMaximumPacketSize;

    return S_OK;
}

HRESULT CISAPIinstance::put_LogLocation( /*[in]*/ const MPC::wstring& szLogLocation )
{
    HRESULT hr;


    m_szLogLocation = szLogLocation;

    if(m_szLogLocation.length())
    {
        hr = m_flLogHandle.SetLocation( m_szLogLocation.c_str() );
    }
    else
    {
        hr = S_OK;
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\common\isapiprovider.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ISAPIprovider.cpp

Abstract:
    This file contains the implementation of the CISAPIprovider class,
    the support class for accessing and modifying the configuration of the
    ISAPI extension used by the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/28/99
        created

******************************************************************************/

#include "stdafx.h"

static const WCHAR text_FINAL_DESTINATIONS[] = L"FINAL_DESTINATIONS";
static const WCHAR text_MAX_JOBS_PER_DAY  [] = L"MAX_JOBS_PER_DAY"  ;
static const WCHAR text_MAX_BYTES_PER_DAY [] = L"MAX_BYTES_PER_DAY" ;
static const WCHAR text_MAX_JOB_SIZE      [] = L"MAX_JOB_SIZE"      ;
static const WCHAR text_AUTHENTICATED     [] = L"AUTHENTICATED"     ;
static const WCHAR text_PROCESSING_MODE   [] = L"PROCESSING_MODE"   ;
static const WCHAR text_LOGON_URL         [] = L"LOGON_URL"         ;
static const WCHAR text_PROVIDER_CLASS    [] = L"PROVIDER_CLASS"    ;


CISAPIprovider::CISAPIprovider()
{
    __ULT_FUNC_ENTRY( "CISAPIprovider::CISAPIprovider" );

										  //  MPC::wstring m_szName;
										  //  
										  //  PathList     m_lstFinalDestinations;
										  //  
    m_dwMaxJobsPerDay  = 100;         	  //  DWORD        m_dwMaxJobsPerDay;
    m_dwMaxBytesPerDay = 10*1024*1024;	  //  DWORD        m_dwMaxBytesPerDay;
    m_dwMaxJobSize     =  2*1024*1024;	  //  DWORD        m_dwMaxJobSize;
										  //  
	m_fAuthenticated   = FALSE;			  //  BOOL         m_fAuthenticated;
	m_fProcessingMode  = 0;    			  //  DWORD        m_fProcessingMode;
										  //  
										  //  MPC::wstring m_szLogonURL;
										  //  MPC::wstring m_szProviderGUID;
}

CISAPIprovider::CISAPIprovider( /*[in]*/ MPC::wstring szName )
{
    __ULT_FUNC_ENTRY( "CISAPIprovider::CISAPIprovider" );


    m_szName           = szName;          //  MPC::wstring m_szName;
										  //  
										  //  PathList     m_lstFinalDestinations;
										  //  
    m_dwMaxJobsPerDay  = 100;         	  //  DWORD        m_dwMaxJobsPerDay;
    m_dwMaxBytesPerDay = 10*1024*1024;	  //  DWORD        m_dwMaxBytesPerDay;
    m_dwMaxJobSize     =  2*1024*1024;	  //  DWORD        m_dwMaxJobSize;
										  //  
	m_fAuthenticated   = FALSE;			  //  BOOL         m_fAuthenticated;
	m_fProcessingMode  = 0;    			  //  DWORD        m_fProcessingMode;
										  //  
										  //  MPC::wstring m_szLogonURL;
										  //  MPC::wstring m_szProviderGUID;
}

bool CISAPIprovider::operator==( /*[in]*/ const MPC::wstring& rhs )
{
    __ULT_FUNC_ENTRY("CISAPIprovider::operator==");

    MPC::NocaseCompare cmp;
    bool               fRes;


    fRes = cmp( m_szName, rhs );


    __ULT_FUNC_EXIT(fRes);
}


/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIprovider::Load( /*[in]*/ MPC::RegKey& rkBase )
{
    __ULT_FUNC_ENTRY( "CISAPIprovider::Load" );

    HRESULT     hr;
    MPC::RegKey rkRoot;
    CComVariant vValue;
    bool        fFound;


    m_lstFinalDestinations.clear();

	//
	// If the registry key doesn't exist, simply exit.
	//
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SubKey( m_szName.c_str(), rkRoot ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.Exists( fFound ));
	if(fFound == false)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_MAX_JOBS_PER_DAY ));
    if(fFound && vValue.vt == VT_I4) m_dwMaxJobsPerDay = vValue.lVal;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_MAX_BYTES_PER_DAY ));
    if(fFound && vValue.vt == VT_I4) m_dwMaxBytesPerDay = vValue.lVal;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_MAX_JOB_SIZE ));
    if(fFound && vValue.vt == VT_I4) m_dwMaxJobSize = vValue.lVal;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_AUTHENTICATED ));
    if(fFound && vValue.vt == VT_I4) m_fAuthenticated = vValue.lVal;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_PROCESSING_MODE ));
    if(fFound && vValue.vt == VT_I4) m_fProcessingMode = vValue.lVal;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_LOGON_URL ));
    if(fFound && vValue.vt == VT_BSTR) m_szLogonURL = SAFEBSTR( vValue.bstrVal );

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_PROVIDER_CLASS ));
    if(fFound && vValue.vt == VT_BSTR) m_szProviderGUID = SAFEBSTR( vValue.bstrVal );


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.get_Value( vValue, fFound, text_FINAL_DESTINATIONS ));
    if(fFound && vValue.vt == VT_BSTR)
    {
        //
        // Split the registry value, a semicolon-separated list of paths, into individual paths.
        //
        MPC::wstring            szFinalDestinations = SAFEBSTR( vValue.bstrVal );
        MPC::wstring::size_type iPos                = 0;
        MPC::wstring::size_type iEnd;

        while(1)
        {
            iEnd = szFinalDestinations.find( L";", iPos );

            if(iEnd == MPC::string::npos) // Last component.
            {
                m_lstFinalDestinations.push_back( MPC::wstring( &szFinalDestinations[iPos] ) );

                break;
            }
            else
            {
                m_lstFinalDestinations.push_back( MPC::wstring( &szFinalDestinations[iPos], &szFinalDestinations[iEnd] ) );

                iPos = iEnd+1;
            }
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT CISAPIprovider::Save( /*[in]*/ MPC::RegKey& rkBase )
{
    __ULT_FUNC_ENTRY( "CISAPIProvider::Save" );

    HRESULT     hr;
    MPC::RegKey rkRoot;
    CComVariant vValue;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SubKey( m_szName.c_str(), rkRoot ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.Create(                          ));



    vValue = (long)m_dwMaxJobsPerDay;
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_MAX_JOBS_PER_DAY ));

    vValue = (long)m_dwMaxBytesPerDay;
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_MAX_BYTES_PER_DAY ));

    vValue = (long)m_dwMaxJobSize;
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_MAX_JOB_SIZE ));

    vValue = (long)m_fAuthenticated;
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_AUTHENTICATED ));

    vValue = (long)m_fProcessingMode;
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_PROCESSING_MODE ));

    vValue = m_szLogonURL.c_str();
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_LOGON_URL ));

    vValue = m_szProviderGUID.c_str();
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_PROVIDER_CLASS ));


    {
        MPC::wstring szFinalDestinations;
        PathIter     it = m_lstFinalDestinations.begin();

        while(it != m_lstFinalDestinations.end())
        {
            szFinalDestinations.append( *it++ );

            if(it != m_lstFinalDestinations.end()) szFinalDestinations.append( L";" );
        }

        if(szFinalDestinations.length() != 0)
        {
            vValue = szFinalDestinations.c_str();
            __MPC_EXIT_IF_METHOD_FAILS(hr, rkRoot.put_Value( vValue, text_FINAL_DESTINATIONS ));
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIprovider::GetLocations( /*[out]*/ PathIter& itBegin ,
                                      /*[out]*/ PathIter& itEnd   )
{
    __ULT_FUNC_ENTRY( "CISAPIprovider::GetLocations" );

    HRESULT hr;


    itBegin = m_lstFinalDestinations.begin();
    itEnd   = m_lstFinalDestinations.end  ();
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIprovider::NewLocation( /*[out]*/ PathIter&           itNew  ,
                                     /*[in] */ const MPC::wstring& szPath )
{
    __ULT_FUNC_ENTRY( "CISAPIprovider::NewLocation" );

    HRESULT hr;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetLocation( itNew, fFound, szPath ));
	if(fFound == false)
	{
		itNew = m_lstFinalDestinations.insert( m_lstFinalDestinations.end(), szPath );
	}

	hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIprovider::GetLocation( /*[out]*/ PathIter&           itOld  ,
                                     /*[out]*/ bool&               fFound ,
                                     /*[in] */ const MPC::wstring& szPath )
{
    __ULT_FUNC_ENTRY( "CISAPIprovider::GetLocation" );

    HRESULT hr;


    itOld = std::find( m_lstFinalDestinations.begin(), m_lstFinalDestinations.end(), szPath );
    if(itOld == m_lstFinalDestinations.end())
    {
        fFound = false;
    }
    else
    {
        fFound = true;
    }

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT CISAPIprovider::DelLocation( /*[in]*/ PathIter& itOld )
{
    __ULT_FUNC_ENTRY( "CISAPIprovider::DelLocation" );

    HRESULT hr;


    m_lstFinalDestinations.erase( itOld );

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CISAPIprovider::get_Name( /*[out]*/ MPC::wstring& szName )
{
    szName = m_szName;

    return S_OK;
}

HRESULT CISAPIprovider::get_MaxJobsPerDay( /*[out]*/ DWORD& dwMaxJobsPerDay )
{
    dwMaxJobsPerDay = m_dwMaxJobsPerDay;

    return S_OK;
}

HRESULT CISAPIprovider::get_MaxBytesPerDay( /*[out]*/ DWORD& dwMaxBytesPerDay )
{
    dwMaxBytesPerDay = m_dwMaxBytesPerDay;

    return S_OK;
}

HRESULT CISAPIprovider::get_MaxJobSize( /*[out]*/ DWORD& dwMaxJobSize )
{
    dwMaxJobSize = m_dwMaxJobSize;

    return S_OK;
}

HRESULT CISAPIprovider::get_Authenticated( /*[out]*/ BOOL& fAuthenticated )
{
    fAuthenticated = m_fAuthenticated;

    return S_OK;
}

HRESULT CISAPIprovider::get_ProcessingMode( /*[out]*/ DWORD& fProcessingMode )
{
    fProcessingMode = m_fProcessingMode;

    return S_OK;
}

HRESULT CISAPIprovider::get_LogonURL( /*[out]*/ MPC::wstring& szLogonURL )
{
    szLogonURL = m_szLogonURL;

    return S_OK;
}

HRESULT CISAPIprovider::get_ProviderGUID( /*[out]*/ MPC::wstring& szProviderGUID )
{
    szProviderGUID = m_szProviderGUID;

    return S_OK;
}

////////////////////////////////////////

HRESULT CISAPIprovider::put_MaxJobsPerDay( /*[in]*/ DWORD dwMaxJobsPerDay )
{
    m_dwMaxJobsPerDay = dwMaxJobsPerDay;

    return S_OK;
}

HRESULT CISAPIprovider::put_MaxBytesPerDay( /*[in]*/ DWORD dwMaxBytesPerDay )
{
    m_dwMaxBytesPerDay = dwMaxBytesPerDay;

    return S_OK;
}

HRESULT CISAPIprovider::put_MaxJobSize( /*[in]*/ DWORD dwMaxJobSize )
{
    m_dwMaxJobSize = dwMaxJobSize;

    return S_OK;
}

HRESULT CISAPIprovider::put_Authenticated( /*[in]*/ BOOL fAuthenticated )
{
    m_fAuthenticated = fAuthenticated;

    return S_OK;
}

HRESULT CISAPIprovider::put_ProcessingMode( /*[in]*/ DWORD fProcessingMode )
{
    m_fProcessingMode = fProcessingMode;

    return S_OK;
}

HRESULT CISAPIprovider::put_LogonURL( /*[in]*/ const MPC::wstring& szLogonURL )
{
    m_szLogonURL = szLogonURL;

    return S_OK;
}

HRESULT CISAPIprovider::put_ProviderGUID( /*[in]*/ const MPC::wstring& szProviderGUID )
{
    m_szProviderGUID = szProviderGUID;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\common\serializer.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Serializer.cpp

Abstract:
    This file contains the implementation of various Serializer In/Out operators.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include <stdafx.h>

/////////////////////////////////////////////////////////////////////////
namespace UploadLibrary
{
	MPC::Serializer* SelectStream( MPC::Serializer& stream, MPC::Serializer_Text& streamText )
	{
		switch(stream.get_Flags())
		{
		case UPLOAD_LIBRARY_PROTOCOL_VERSION_CLT__TEXTONLY:
		case UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV__TEXTONLY: return &streamText;
		}

		return &stream;
	}

	////////////////////////////////////////////////////////////////////////////////

	bool RequestHeader::VerifyClient() const
	{
		if(dwSignature == UPLOAD_LIBRARY_PROTOCOL_SIGNATURE)
		{
			switch(dwVersion)
			{
			case UPLOAD_LIBRARY_PROTOCOL_VERSION_CLT:
			case UPLOAD_LIBRARY_PROTOCOL_VERSION_CLT__TEXTONLY: return true;
			}
		}
		
		return false;
	}

	bool RequestHeader::VerifyServer() const
	{
		if(dwSignature == UPLOAD_LIBRARY_PROTOCOL_SIGNATURE)
		{
			switch(dwVersion)
			{
			case UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV:
			case UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV__TEXTONLY: return true;
			}
		}

		return false;
	}

    //
    // In/Out operators for RequestHeader
    //
    HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ struct RequestHeader& rhVal )
    {
        __ULT_FUNC_ENTRY( "operator>> struct RequestHeader" );

        HRESULT hr;


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> rhVal.dwSignature);
        __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> rhVal.dwVersion  ); stream.put_Flags( rhVal.dwVersion );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

    HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in]*/ const struct RequestHeader& rhVal )
    {
        __ULT_FUNC_ENTRY( "operator<< struct RequestHeader" );

        HRESULT hr;


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream << rhVal.dwSignature);
        __MPC_EXIT_IF_METHOD_FAILS(hr, stream << rhVal.dwVersion  ); stream.put_Flags( rhVal.dwVersion );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

	////////////////////////////////////////////////////////////////////////////////

    //
    // In/Out operators for Signature
    //
    HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ struct Signature& sigVal )
    {
        __ULT_FUNC_ENTRY( "operator>> struct Signature" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream = SelectStream( stream, streamText );

        __MPC_EXIT_IF_METHOD_FAILS(hr, pstream->read( &sigVal, sizeof(sigVal) ));

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

    HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const struct Signature& sigVal )
    {
        __ULT_FUNC_ENTRY( "operator<< struct Signature" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream = SelectStream( stream, streamText );


        __MPC_EXIT_IF_METHOD_FAILS(hr, pstream->write( &sigVal, sizeof(sigVal) ));

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

	////////////////////////////////////////////////////////////////////////////////

	bool ServerResponse::MatchVersion( /*[in]*/ const ClientRequest& cr )
	{
		rhProlog.dwVersion = UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV; // Set the version to the old default.

        if(cr.rhProlog.VerifyClient())
		{
			switch(cr.rhProlog.dwVersion)
			{
			case UPLOAD_LIBRARY_PROTOCOL_VERSION_CLT          : rhProlog.dwVersion = UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV          ; break;
			case UPLOAD_LIBRARY_PROTOCOL_VERSION_CLT__TEXTONLY: rhProlog.dwVersion = UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV__TEXTONLY; break; 
			default                                           : return false; // Just in case...
			}

			return true;
		}

		return false;
	}

    //
    // In/Out operators for ServerResponse
    //
    HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ struct ServerResponse& srVal )
    {
        __ULT_FUNC_ENTRY( "operator>> struct ServerResponse" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream;


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> srVal.rhProlog);

		pstream = SelectStream( stream, streamText );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> srVal.fResponse  );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> srVal.dwPosition );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

    HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in]*/ const struct ServerResponse& srVal )
    {
        __ULT_FUNC_ENTRY( "operator<< struct ServerResponse" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream;


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream << srVal.rhProlog);


		pstream = SelectStream( stream, streamText );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << srVal.fResponse  );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << srVal.dwPosition );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

	////////////////////////////////////////////////////////////////////////////////

    //
    // In/Out operators for ClientRequest
    //
    HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ struct ClientRequest& crVal )
    {
        __ULT_FUNC_ENTRY( "operator>> struct ClientRequest" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream;


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> crVal.rhProlog);


		pstream = SelectStream( stream, streamText );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crVal.sigClient  );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crVal.dwCommand  );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

    HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in]*/ const struct ClientRequest& crVal )
    {
        __ULT_FUNC_ENTRY( "operator<< struct ClientRequest" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream;


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream << crVal.rhProlog);


		pstream = SelectStream( stream, streamText );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crVal.sigClient  );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crVal.dwCommand  );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

	////////////////////////////////////////////////////////////////////////////////

    //
    // In/Out operators for ClientRequest_OpenSession
    //
    HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ struct ClientRequest_OpenSession& crosVal )
    {
        __ULT_FUNC_ENTRY( "operator>> struct ClientRequest_OpenSession" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream = SelectStream( stream, streamText );


        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crosVal.szJobID       );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crosVal.szProviderID  );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crosVal.szUsername    );

        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crosVal.dwSize        );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crosVal.dwSizeOriginal);
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crosVal.dwCRC         );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crosVal.fCompressed   );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

    HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in]*/ const struct ClientRequest_OpenSession& crosVal )
    {
        __ULT_FUNC_ENTRY( "operator<< struct ClientRequest_OpenSession" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream = SelectStream( stream, streamText );


        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crosVal.szJobID       );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crosVal.szProviderID  );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crosVal.szUsername    );

        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crosVal.dwSize        );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crosVal.dwSizeOriginal);
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crosVal.dwCRC         );
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crosVal.fCompressed   );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

	////////////////////////////////////////////////////////////////////////////////

    //
    // In/Out operators for ClientRequest_WriteSession
    //
    HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ struct ClientRequest_WriteSession& crwsVal )
    {
        __ULT_FUNC_ENTRY( "operator>> struct ClientRequest_WriteSession" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream = SelectStream( stream, streamText );


        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crwsVal.szJobID );

        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crwsVal.dwOffset);
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) >> crwsVal.dwSize  );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

    HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in]*/ const struct ClientRequest_WriteSession& crwsVal )
    {
        __ULT_FUNC_ENTRY( "operator<< struct ClientRequest_WriteSession" );

        HRESULT              hr;
		MPC::Serializer_Text streamText( stream );
		MPC::Serializer*     pstream = SelectStream( stream, streamText );


        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crwsVal.szJobID );

        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crwsVal.dwOffset);
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*pstream) << crwsVal.dwSize  );

        hr = S_OK;


        __ULT_FUNC_CLEANUP;

        __ULT_FUNC_EXIT(hr);
    }

    /////////////////////////////////////////////////////////////////////////

}; // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\common\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

//
// Warning, always leave these includes BEFORE <atlbase.h>, otherwise you won't get the right MSXML.
//
#define __msxml_h__
#include <basetyps.h>
typedef interface IXMLElement IXMLElement;
#include <msxml.h>
#undef  __msxml_h__
#include <msxml.h>

#include <atlbase.h>

extern CComModule _Module;

#include <UploadLibrary.h>
#include <UploadLibraryTrace.h>
#include <UploadLibraryISAPI.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\commonincludes\uploadlibrary.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    UploadLibrary.h

Abstract:
    This file contains the declaration of support structures and typedefs
    for the Transport Procotol used by the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___UL___UPLOADLIBRARY_H___)
#define __INCLUDED___UL___UPLOADLIBRARY_H___

#include <MPC_main.h>
#include <MPC_utils.h>
#include <MPC_streams.h>

#define UPLOAD_LIBRARY_PROTOCOL_SIGNATURE  				(0x55504C42) // UPLB

#define UPLOAD_LIBRARY_PROTOCOL_VERSION_CLT				(0xBEEF0102)
#define UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV				(0xBEEF0202)
			
#define UPLOAD_LIBRARY_PROTOCOL_VERSION_CLT__TEXTONLY   (0x434c5431) // CLT1
#define UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV__TEXTONLY   (0x53525631) // SRV1

/////////////////////////////////////////////////////////////////////////

namespace UploadLibrary
{
    //
    // This enumeration defines the commands understood by the server.
    //
    typedef enum
    {
        UL_COMMAND_OPENSESSION  = 0x00,
        UL_COMMAND_WRITESESSION = 0x01
    } Command;

    //
    // This enumeration defines the response codes generated by the server.
    //
    typedef enum
    {
        UL_RESPONSE_SUCCESS                = 0x00000000,
        UL_RESPONSE_SKIPPED                = 0x00000001 | UL_RESPONSE_SUCCESS, // Ok, but move forward.
        UL_RESPONSE_COMMITTED              = 0x00000002 | UL_RESPONSE_SUCCESS, // File has been committed.

        UL_RESPONSE_FAILED                 = 0x80000000,
        UL_RESPONSE_BAD_REQUEST            = 0x00000001 | UL_RESPONSE_FAILED, // Bad packet format.
        UL_RESPONSE_DENIED                 = 0x00000002 | UL_RESPONSE_FAILED, // Generic access deny.
        UL_RESPONSE_NOT_AUTHORIZED         = 0x00000003 | UL_RESPONSE_FAILED, // Authorization failure.
        UL_RESPONSE_QUOTA_EXCEEDED         = 0x00000004 | UL_RESPONSE_FAILED, // Quota exceeded.
        UL_RESPONSE_BUSY                   = 0x00000005 | UL_RESPONSE_FAILED, // Server is busy, retry later.
        UL_RESPONSE_EXISTS                 = 0x00000006 | UL_RESPONSE_FAILED, // File already exists and is committed.
        UL_RESPONSE_NOTACTIVE              = 0x00000007 | UL_RESPONSE_FAILED, // Session not active.
        UL_RESPONSE_BADCRC                 = 0x00000008 | UL_RESPONSE_FAILED  // The sent bytes and the CRC don't match!!
    } Response;

    /////////////////////////////////////////////////////////////////////////

	//
	// Forward declaractions.
	//
    struct Signature;
    struct RequestHeader;
    struct ClientRequest;
    struct ClientRequest_OpenSession;
    struct ClientRequest_WriteSession;
    struct ServerResponse;

    /////////////////////////////////////////////////////////////////////////

	MPC::Serializer* SelectStream( MPC::Serializer& stream, MPC::Serializer_Text& streamText );

    /////////////////////////////////////////////////////////////////////////

    //
    // This structure defines the authentication signature of a client.
    //
    struct Signature // Hungarian: sig
    {
        GUID  guidMachineID;
        DWORD dwHash;

        Signature( /*[in]*/ GUID id = IID_IUnknown ) : guidMachineID( id ),
                                                       dwHash       ( 0  ) {}

        bool operator==( /*[in]*/ const Signature& sig ) const
        {
            if(IsEqualGUID( guidMachineID, sig.guidMachineID ) == FALSE) return false;

            if(dwHash != sig.dwHash) return false;

            return true;
        }

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       struct Signature& sigVal );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const struct Signature& sigVal );
    };

    //
    // This structure defines the start of every request.
    //
    struct RequestHeader // Hungarian: rh
    {
        DWORD dwSignature;
        DWORD dwVersion;

        RequestHeader( /*[in]*/ DWORD dwMode ) : dwSignature( UPLOAD_LIBRARY_PROTOCOL_SIGNATURE ), dwVersion( dwMode ) {}


        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       struct RequestHeader& rhVal );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const struct RequestHeader& rhVal );

		bool VerifyClient() const;
		bool VerifyServer() const;
    };

    //
    // This structure defines the tipical response from the server.
    //
    struct ServerResponse // Hungarian: sr
    {
		RequestHeader rhProlog;

        DWORD         fResponse;
        DWORD         dwPosition;

        ServerResponse( /*[in]*/ DWORD dwVer, /*[in]*/ DWORD fRes = UL_RESPONSE_DENIED ) : rhProlog   ( dwVer ),
                                                                     					   fResponse  ( fRes  ),
                                                                     					   dwPosition ( 0     ) {}


        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       struct ServerResponse& srVal );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const struct ServerResponse& srVal );

		bool MatchVersion( /*[in]*/ const ClientRequest& cr );
    };

    //
    // This structure defines the start of every client request.
    //
    struct ClientRequest // Hungarian: cr
    {
		RequestHeader rhProlog;

        Signature     sigClient;

        DWORD         dwCommand;

        ClientRequest( /*[in]*/ DWORD dwVer, /*[in]*/ DWORD dwCmd = -1 ) : rhProlog ( dwVer ),
                                                                           dwCommand( dwCmd ) {}


        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       struct ClientRequest& crVal );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const struct ClientRequest& crVal );
    };

    //
    // This structure defines an 'Open New or Old File' request.
    //
    struct ClientRequest_OpenSession // Hungarian: cros
    {
        ClientRequest crHeader;

        MPC::wstring  szJobID;
        MPC::wstring  szProviderID;
        MPC::wstring  szUsername;

        DWORD         dwSize;
        DWORD         dwSizeOriginal;
        DWORD         dwCRC;
        bool          fCompressed;

        ClientRequest_OpenSession( /*[in]*/ DWORD dwVer ) : crHeader      ( dwVer, UL_COMMAND_OPENSESSION ),
                                      						dwSize        ( 0                             ),
                                      						dwSizeOriginal( 0                             ),
                                      						fCompressed   ( false                         ) {}


        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       struct ClientRequest_OpenSession& crosVal );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const struct ClientRequest_OpenSession& crosVal );
    };

    //
    // This structure defines a request to add new data to an opened file.
    //
    struct ClientRequest_WriteSession // Hungarian: crws
    {
        ClientRequest crHeader;

        MPC::wstring  szJobID;

        DWORD         dwOffset;
        DWORD         dwSize;

        ClientRequest_WriteSession( /*[in]*/ DWORD dwVer ) : crHeader( dwVer, UL_COMMAND_WRITESESSION ),
                                       						 dwOffset( 0                              ),
                                       						 dwSize  ( 0                              ) {}


        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       struct ClientRequest_WriteSession& crwsVal );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const struct ClientRequest_WriteSession& crwsVal );
    };

}; // namespace
/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___UL___UPLOADLIBRARY_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\commonincludes\uploadmanagerdid.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    UploadLibraryDID.h

Abstract:
    This file contains the definition of some constants used by
	the UploadManager Classes.

Revision History:
    Davide Massarenti   (Dmassare)  06/13/99
        created

******************************************************************************/

#if !defined(__INCLUDED___UL___UPLOADLIBRARYDID_H___)
#define __INCLUDED___UL___UPLOADLIBRARYDID_H___

/////////////////////////////////////////////////////////////////////////

#define E_UPLOADLIBRARY_NOT_AUTHENTICATED          MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x1001)
#define E_UPLOADLIBRARY_ACCESS_DENIED              MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x1002)
#define E_UPLOADLIBRARY_SERVER_QUOTA_EXCEEDED      MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x1003)
#define E_UPLOADLIBRARY_SERVER_BUSY                MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x1004)
																								   
#define E_UPLOADLIBRARY_NO_DATA                    MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x1005)
#define E_UPLOADLIBRARY_INVALID_PARAMETERS         MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x1006)
#define E_UPLOADLIBRARY_CLIENT_QUOTA_EXCEEDED      MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x1007)

#define E_UPLOADLIBRARY_WRONG_SERVER_VERSION       MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x1008)

#define E_UPLOADLIBRARY_UNEXPECTED_RESPONSE        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x1009)

/////////////////////////////////////////////////////////////////////////

#define DISPID_UL_BASE              			 0x08010000
#define DISPID_UL_BASE_UPLOAD       			 (DISPID_UL_BASE + 0x0000)
#define DISPID_UL_BASE_UPLOADJOB    			 (DISPID_UL_BASE + 0x0100)
#define DISPID_UL_BASE_UPLOADEVENTS 			 (DISPID_UL_BASE + 0x0200)
#define DISPID_UL_BASE_CONNECTION   			 (DISPID_UL_BASE + 0x0300)

/////////////////////////////////////////////////////////////////////////

#define DISPID_UL_UPLOAD_COUNT      			 (DISPID_UL_BASE_UPLOAD + 0x0000)
#define DISPID_UL_UPLOAD_CREATEJOB  			 (DISPID_UL_BASE_UPLOAD + 0x0001)

/////////////////////////////////////////////////////////////////////////

#define DISPID_UL_UPLOADJOB_SIG               	 (DISPID_UL_BASE_UPLOADJOB + 0x0000)
#define DISPID_UL_UPLOADJOB_SERVER            	 (DISPID_UL_BASE_UPLOADJOB + 0x0001)
#define DISPID_UL_UPLOADJOB_JOBID             	 (DISPID_UL_BASE_UPLOADJOB + 0x0002)
#define DISPID_UL_UPLOADJOB_PROVIDERID        	 (DISPID_UL_BASE_UPLOADJOB + 0x0003)

#define DISPID_UL_UPLOADJOB_CREATOR          	 (DISPID_UL_BASE_UPLOADJOB + 0x0010)
#define DISPID_UL_UPLOADJOB_USERNAME          	 (DISPID_UL_BASE_UPLOADJOB + 0x0011)
#define DISPID_UL_UPLOADJOB_PASSWORD          	 (DISPID_UL_BASE_UPLOADJOB + 0x0012)

#define DISPID_UL_UPLOADJOB_ORIGINALSIZE     	 (DISPID_UL_BASE_UPLOADJOB + 0x0020)
#define DISPID_UL_UPLOADJOB_TOTALSIZE    	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0021)
#define DISPID_UL_UPLOADJOB_SENTSIZE     	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0022)

#define DISPID_UL_UPLOADJOB_HISTORY      	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0030)
#define DISPID_UL_UPLOADJOB_STATUS       	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0031)
#define DISPID_UL_UPLOADJOB_ERRORCODE    	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0032)

#define DISPID_UL_UPLOADJOB_MODE         	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0040)
#define DISPID_UL_UPLOADJOB_PERSISTTODISK	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0041)
#define DISPID_UL_UPLOADJOB_COMPRESSED   	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0042)
#define DISPID_UL_UPLOADJOB_PRIORITY     	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0043)

#define DISPID_UL_UPLOADJOB_CREATIONTIME 	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0050)
#define DISPID_UL_UPLOADJOB_COMPLETETIME 	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0051)
#define DISPID_UL_UPLOADJOB_EXPIRATIONTIME 	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0052)
 
#define DISPID_UL_UPLOADJOB_ONSTATUSCHANGE  	 (DISPID_UL_BASE_UPLOADJOB + 0x0060)
#define DISPID_UL_UPLOADJOB_ONPROGRESSCHANGE	 (DISPID_UL_BASE_UPLOADJOB + 0x0061)

#define DISPID_UL_UPLOADJOB_ACTIVATESYNC 	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0080)
#define DISPID_UL_UPLOADJOB_ACTIVATEASYNC	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0081)
#define DISPID_UL_UPLOADJOB_SUSPEND      	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0082)
#define DISPID_UL_UPLOADJOB_DELETE       	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0083)

#define DISPID_UL_UPLOADJOB_GETDATAFROMFILE  	 (DISPID_UL_BASE_UPLOADJOB + 0x0090)
#define DISPID_UL_UPLOADJOB_PUTDATAINTOFILE  	 (DISPID_UL_BASE_UPLOADJOB + 0x0091)
#define DISPID_UL_UPLOADJOB_GETDATAFROMSTREAM	 (DISPID_UL_BASE_UPLOADJOB + 0x0092)
#define DISPID_UL_UPLOADJOB_PUTDATAINTOSTREAM	 (DISPID_UL_BASE_UPLOADJOB + 0x0093)
#define DISPID_UL_UPLOADJOB_GETRESPONSEASSTREAM	 (DISPID_UL_BASE_UPLOADJOB + 0x0094)

/////////////////////////////////////////////////////////////////////////

#define DISPID_UL_UPLOADEVENTS_ONSTATUSCHANGE    (DISPID_UL_BASE_UPLOADEVENTS + 0x0000)
#define DISPID_UL_UPLOADEVENTS_ONPROGRESSCHANGE  (DISPID_UL_BASE_UPLOADEVENTS + 0x0001)

/////////////////////////////////////////////////////////////////////////

#define DISPID_UL_CONNECTION_AVAILABLE    		 (DISPID_UL_BASE_CONNECTION + 0x0000)
#define DISPID_UL_CONNECTION_ISAMODEM     		 (DISPID_UL_BASE_CONNECTION + 0x0001)
#define DISPID_UL_CONNECTION_BANDWIDTH    		 (DISPID_UL_BASE_CONNECTION + 0x0002)

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___UL___UPLOADLIBRARYDID_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\commonincludes\uploadlibraryisapi.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    UploadLibraryISAPI.h

Abstract:
    This file contains the declaration of the support classes for accessing and
    modifying the configuration of theISAPI extension used by the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/28/99
        created

******************************************************************************/

#if !defined(__INCLUDED___UPLOADLIBRARY___ISAPI_H___)
#define __INCLUDED___UPLOADLIBRARY___ISAPI_H___

#include <MPC_utils.h>
#include <MPC_logging.h>


class CISAPIprovider
{
public:
    typedef std::list<MPC::wstring>  PathList;
    typedef PathList::iterator       PathIter;
    typedef PathList::const_iterator PathIterConst;

private:
    MPC::wstring m_szName;               // Name of the provider (DPE).

    PathList     m_lstFinalDestinations; // List of directories where to move complete jobs for this provider.

    DWORD        m_dwMaxJobsPerDay;      // Maximum number of jobs per day (per client).
    DWORD        m_dwMaxBytesPerDay;     // Maximum number of bytes transferred per day (per client).
    DWORD        m_dwMaxJobSize;         // Size of the largest allowed job.

    BOOL         m_fAuthenticated;       // Is authentication required for posting data to this provider?
    DWORD        m_fProcessingMode;      // Status of the DPE (0=Ok, !=0 Error condition).

    MPC::wstring m_szLogonURL;           // URL of the logon server (for PassPort....)
    MPC::wstring m_szProviderGUID;       // GUID for the custom provider.

public:
    CISAPIprovider();
    CISAPIprovider( /*[in]*/ const MPC::wstring szName );

    bool operator==( /*[in]*/ const MPC::wstring& rhs );


    HRESULT Load( /*[in]*/ MPC::RegKey& rkBase );
    HRESULT Save( /*[in]*/ MPC::RegKey& rkBase );


    HRESULT GetLocations( /*[out]*/ PathIter& itBegin,                         /*[out]*/ PathIter&           itEnd  );
    HRESULT NewLocation ( /*[out]*/ PathIter& itNew  ,                         /*[in] */ const MPC::wstring& szPath );
    HRESULT GetLocation ( /*[out]*/ PathIter& itOld  , /*[out]*/ bool& fFound, /*[in] */ const MPC::wstring& szPath );
    HRESULT DelLocation ( /*[in] */ PathIter& itOld                                                                 );


    HRESULT get_Name          ( /*[out]*/ MPC::wstring&       szName           );
    HRESULT get_MaxJobsPerDay ( /*[out]*/ DWORD&              dwMaxJobsPerDay  );
    HRESULT get_MaxBytesPerDay( /*[out]*/ DWORD&              dwMaxBytesPerDay );
    HRESULT get_MaxJobSize    ( /*[out]*/ DWORD&              dwMaxJobSize     );
    HRESULT get_Authenticated ( /*[out]*/ BOOL&               fAuthenticated   );
    HRESULT get_ProcessingMode( /*[out]*/ DWORD&              fProcessingMode  );
    HRESULT get_LogonURL      ( /*[out]*/ MPC::wstring&       szLogonURL       );
    HRESULT get_ProviderGUID  ( /*[out]*/ MPC::wstring&       szProviderGUID   );


    HRESULT put_MaxJobsPerDay ( /*[in] */ DWORD               dwMaxJobsPerDay  );
    HRESULT put_MaxBytesPerDay( /*[in] */ DWORD               dwMaxBytesPerDay );
    HRESULT put_MaxJobSize    ( /*[in] */ DWORD               dwMaxJobSize     );
    HRESULT put_Authenticated ( /*[in] */ BOOL                fAuthenticated   );
    HRESULT put_ProcessingMode( /*[in] */ DWORD               fProcessingMode  );
    HRESULT put_LogonURL      ( /*[in] */ const MPC::wstring& szLogonURL       );
    HRESULT put_ProviderGUID  ( /*[in] */ const MPC::wstring& szProviderGUID   );
};

class CISAPIinstance
{
public:
    typedef std::list<MPC::wstring>                               PathList;
    typedef PathList::iterator                                    PathIter;
    typedef PathList::const_iterator                              PathIterConst;

    typedef std::map<MPC::wstring,CISAPIprovider,MPC::NocaseLess> ProvMap;
    typedef ProvMap::iterator                                     ProvIter;
    typedef ProvMap::const_iterator                               ProvIterConst;


private:
    MPC::wstring m_szURL;                // URL of the instance.

    ProvMap      m_mapProviders;         // Set of providers handled by the instance.
    PathList     m_lstQueueLocations;    // List of directories where to store partially sent jobs.

    DWORD        m_dwQueueSizeMax;       // Size of the queue triggering the activation of the purge engine.
    DWORD        m_dwQueueSizeThreshold; // Size of the queue below which the purge engine stops processing old jobs.
    DWORD        m_dwMaximumJobAge;      // Maximum number of days a partially sent job can stay in the queue.
    DWORD        m_dwMaximumPacketSize;  // Maximum packet size accepted by this instance.

    MPC::wstring m_szLogLocation;        // Location of the application log for this instance.
    MPC::FileLog m_flLogHandle;          // Object used to write entries in the application log.


public:
    CISAPIinstance( /*[in]*/ const MPC::wstring szURL );

    bool operator==( /*[in]*/ const MPC::wstring& rhs );


    HRESULT Load( /*[in]*/ MPC::RegKey& rkBase );
    HRESULT Save( /*[in]*/ MPC::RegKey& rkBase );


    HRESULT GetProviders( /*[out]*/ ProvIter& itBegin,                         /*[out]*/ ProvIter&           itEnd  );
    HRESULT NewProvider ( /*[out]*/ ProvIter& itNew  ,                         /*[in] */ const MPC::wstring& szName );
    HRESULT GetProvider ( /*[out]*/ ProvIter& itOld  , /*[out]*/ bool& fFound, /*[in] */ const MPC::wstring& szName );
    HRESULT DelProvider ( /*[in] */ ProvIter& itOld                                                                 );


    HRESULT GetLocations( /*[out]*/ PathIter& itBegin,                         /*[out]*/ PathIter&           itEnd  );
    HRESULT NewLocation ( /*[out]*/ PathIter& itNew  ,                         /*[in] */ const MPC::wstring& szPath );
    HRESULT GetLocation ( /*[out]*/ PathIter& itOld  , /*[out]*/ bool& fFound, /*[in] */ const MPC::wstring& szPath );
    HRESULT DelLocation ( /*[in] */ PathIter& itOld                                                                 );


    HRESULT get_URL               ( /*[out]*/ MPC::wstring &      szURL                );
    HRESULT get_QueueSizeMax      ( /*[out]*/ DWORD        &      dwQueueSizeMax       );
    HRESULT get_QueueSizeThreshold( /*[out]*/ DWORD        &      dwQueueSizeThreshold );
    HRESULT get_MaximumJobAge     ( /*[out]*/ DWORD        &      dwMaximumJobAge      );
    HRESULT get_MaximumPacketSize ( /*[out]*/ DWORD        &      dwMaximumPacketSize  );
    HRESULT get_LogLocation       ( /*[out]*/ MPC::wstring &      szLogLocation        );
    HRESULT get_LogHandle         ( /*[out]*/ MPC::FileLog*&      flLogHandle          );


    HRESULT put_QueueSizeMax      ( /*[in] */ DWORD               dwQueueSizeMax       );
    HRESULT put_QueueSizeThreshold( /*[in] */ DWORD               dwQueueSizeThreshold );
    HRESULT put_MaximumJobAge     ( /*[in] */ DWORD               dwMaximumJobAge      );
    HRESULT put_MaximumPacketSize ( /*[in] */ DWORD               dwMaximumPacketSize  );
    HRESULT put_LogLocation       ( /*[in] */ const MPC::wstring& szLogLocation        );
};

class CISAPIconfig
{
public:
    typedef std::list<CISAPIinstance> List;
    typedef List::iterator            Iter;
    typedef List::const_iterator      IterConst;

private:
    MPC::wstring m_szRoot;       // Registry position of the tree.
    MPC::wstring m_szMachine;    // Machine hosting the tree.
    List         m_lstInstances;

    HRESULT ConnectToRegistry( /*[out]*/ MPC::RegKey& rkBase       ,
                               /*[in] */ bool         fWriteAccess );

public:
    CISAPIconfig();

    HRESULT SetRoot( LPCWSTR szRoot, LPCWSTR szMachine = NULL  );

    HRESULT Install  (); // It will create the root key.
    HRESULT Uninstall(); // It will remove the root key and all its subkeys.

    HRESULT Load();
    HRESULT Save();


    HRESULT GetInstances( /*[out]*/ Iter& itBegin,                         /*[out]*/ Iter&               itEnd );
    HRESULT NewInstance ( /*[out]*/ Iter& itNew  ,                         /*[in] */ const MPC::wstring& szURL );
    HRESULT GetInstance ( /*[out]*/ Iter& itOld  , /*[out]*/ bool& fFound, /*[in] */ const MPC::wstring& szURL );
    HRESULT DelInstance ( /*[in] */ Iter& itOld                                                                );
};

#endif // !defined(__INCLUDED___UPLOADLIBRARY___ISAPI_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\commonincludes\uploadlibrarytrace.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    UploadLibraryTrace.h

Abstract:
    This file contains the declaration of Tracing Macrons for the Upload Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/
// UploadLibraryTrace.h : include file for common declarations and definitions.
//

#if !defined(__INCLUDED___UL___UPLOADLIBRARYTRACE_H___)
#define __INCLUDED___UL___UPLOADLIBRARYTRACE_H___

#include <MPC_trace.h>

/////////////////////////////////////////////////////////////////////////

#define __ULT_FUNC_ENTRY(x)     __MPC_FUNC_ENTRY(UPLOADLIBID,x)
#define __ULT_FUNC_LEAVE        __MPC_FUNC_LEAVE
#define __ULT_FUNC_CLEANUP      __MPC_FUNC_CLEANUP
#define __ULT_FUNC_EXIT(x)      __MPC_FUNC_EXIT(x)

#define __ULT_TRACE_HRESULT(hr) __MPC_TRACE_HRESULT(hr)
#define __ULT_TRACE_FATAL       __MPC_TRACE_FATAL
#define __ULT_TRACE_ERROR       __MPC_TRACE_ERROR
#define __ULT_TRACE_DEBUG       __MPC_TRACE_DEBUG
#define __ULT_TRACE_STATE       __MPC_TRACE_STATE
#define __ULT_TRACE_FUNCT       __MPC_TRACE_FUNCT

/////////////////////////////////////////////////////////////////////////

#define __ULT_BEGIN_PROPERTY_GET(func,hr,pVal)                __MPC_BEGIN_PROPERTY_GET(UPLOADLIBID,func,hr,pVal)               
#define __ULT_BEGIN_PROPERTY_GET__NOLOCK(func,hr,pVal)        __MPC_BEGIN_PROPERTY_GET__NOLOCK(UPLOADLIBID,func,hr,pVal)  
#define __ULT_BEGIN_PROPERTY_GET2(func,hr,pVal,value)         __MPC_BEGIN_PROPERTY_GET2(UPLOADLIBID,func,hr,pVal,value) 
#define __ULT_BEGIN_PROPERTY_GET2__NOLOCK(func,hr,pVal,value) __MPC_BEGIN_PROPERTY_GET2__NOLOCK(UPLOADLIBID,func,hr,pVal,value) 
#define __ULT_BEGIN_PROPERTY_PUT(func,hr)                     __MPC_BEGIN_PROPERTY_PUT(UPLOADLIBID,func,hr)       
#define __ULT_BEGIN_PROPERTY_PUT__NOLOCK(func,hr)             __MPC_BEGIN_PROPERTY_PUT__NOLOCK(UPLOADLIBID,func,hr) 
#define __ULT_END_PROPERTY(hr)                                __MPC_END_PROPERTY(hr) 

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___UL___UPLOADLIBRARYTRACE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\client.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Client.h

Abstract:
    This file contains the declaration of the MPCClient class,
    that describes a client's state.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___CLIENT_H___)
#define __INCLUDED___ULSERVER___CLIENT_H___


#include <Wrapper.h>


#define CLIENT_DB_VERSION 0xDB000003

#define CLIENT_CONST__DB_EXTENSION  L".db"


class MPCClient : public MPCPersist
{
public:
    typedef UploadLibrary::Signature Sig;
    typedef std::list<MPCSession>    List;
    typedef List::iterator           Iter;
    typedef List::const_iterator     IterConst;

private:
    MPCServer*         m_mpcsServer;
    MPC::wstring       m_szFile; // For direct access.
   
    Sig                m_sigID;
    List               m_lstActiveSessions;
    SYSTEMTIME         m_stLastUsed;
    DWORD              m_dwLastSession;
   
    mutable bool       m_fDirty;
    mutable HANDLE     m_hfFile;

	static const DWORD c_dwVersion = CLIENT_DB_VERSION;

    //////////////////////////////////////////////////////////////////

    HRESULT IDtoPath( /*[out]*/ MPC::wstring& szStr ) const;

    //////////////////////////////////////////////////////////////////

public:
    MPCClient( /*[in]*/ MPCServer* mpcsServer, /*[in]*/ const Sig&          sigID  );
    MPCClient( /*[in]*/ MPCServer* mpcsServer, /*[in]*/ const MPC::wstring& szFile );
    virtual ~MPCClient();

	MPCServer* GetServer();

    /////////////////////////////////////////////

    virtual bool    IsDirty() const;

    virtual HRESULT Load( /*[in]*/ MPC::Serializer& streamIn  );
    virtual HRESULT Save( /*[in]*/ MPC::Serializer& streamOut ) const;

    /////////////////////////////////////////////

    bool operator==( /*[in]*/ const UploadLibrary::Signature& rhs );

    bool Find ( /*[in]*/ const MPC::wstring& szJobID, /*[out]*/ Iter& it );
    void Erase(                                       /*[in] */ Iter& it );

    /////////////////////////////////////////////

    HRESULT GetInstance( /*[out]*/ CISAPIinstance*& isapiInstance, /*[out]*/ bool& fFound ) const;
    HRESULT GetInstance( /*[out]*/ MPC::wstring&    szURL                                 ) const;

    /////////////////////////////////////////////

    HRESULT BuildClientPath( /*[out]*/ MPC::wstring& szPath ) const;
    HRESULT GetFileName    ( /*[out]*/ MPC::wstring& szFile ) const;
    HRESULT GetFileSize    ( /*[out]*/ DWORD&        dwSize ) const;
    HRESULT FormatID       ( /*[out]*/ MPC::wstring& szID   ) const;

    bool CheckSignature() const;

    /////////////////////////////////////////////

    HRESULT OpenStorage ( /*[in]*/ bool fCheckFreeSpace );
    HRESULT InitFromDisk( /*[in]*/ bool fCheckFreeSpace );
    HRESULT SaveToDisk  (                               );
    HRESULT SyncToDisk  (                               );

    HRESULT GetSessions( /*[out]*/ Iter& itBegin, /*[out]*/ Iter& itEnd );

    /////////////////////////////////////////////

    Iter NewSession( /*[in]*/ UploadLibrary::ClientRequest_OpenSession& crosReq );

    HRESULT AppendData( /*[in]*/ MPCSession& mpcsSession, /*[in]*/ MPC::Serializer& streamConn, /*[in]*/ DWORD dwSize );

    HRESULT CheckQuotas( /*[in]*/ MPCSession& mpcsSession, /*[out]*/ bool& fServerBusy, /*[out]*/ bool& fAccessDenied, /*[out]*/ bool& fExceeded );
};

#endif // !defined(__INCLUDED___ULSERVER___CLIENT_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\client.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Client.cpp

Abstract:
    This file contains the implementation of the MPCClient class,
    that describes a client's state.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"

#define BUFFER_SIZE_FILECOPY (512)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Construction/Destruction
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::MPCClient
//
// Parameters  : MPCServer* mpcsServer: callback for getting information about the current request.
//               const Sig& sigID     : a reference to the ID for this client.
//
// Synopsis    : Initializes the MPCClient object with the ID of a client.
//
/////////////////////////////////////////////////////////////////////////////
MPCClient::MPCClient( /*[in]*/ MPCServer* mpcsServer ,
                      /*[in]*/ const Sig& sigID      )
{
    __ULT_FUNC_ENTRY("MPCClient::MPCClient");

    m_mpcsServer    = mpcsServer;  // MPCServer*     m_mpcsServer;
                                   // MPC::wstring   m_szFile;
                                   //
    m_sigID         = sigID;       // Sig            m_sigID;
                                   // List           m_lstActiveSessions;
                                   // SYSTEMTIME     m_stLastUsed;
    m_dwLastSession = 0;           // DWORD          m_dwLastSession;
                                   //
    m_fDirty        = false;       // mutable bool   m_fDirty;
    m_hfFile        = NULL;        // mutable HANDLE m_hfFile;
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::MPCClient
//
// Parameters  : MPCServer*          mpcsServer : callback for getting information about the current request.
//               const MPC::wstring& szFile     : the file holding the DB.
//
// Synopsis    : Initializes the MPCClient object suppling the filename of the DB of a client.
//
/////////////////////////////////////////////////////////////////////////////
MPCClient::MPCClient( /*[in]*/ MPCServer*          mpcsServer ,
                      /*[in]*/ const MPC::wstring& szFile     )
{
    __ULT_FUNC_ENTRY("MPCClient::MPCClient");

    MPC::wstring::size_type iPos;

    m_mpcsServer    = mpcsServer;  // MPCServer*     m_mpcsServer;
    m_szFile        = szFile;      // MPC::wstring   m_szFile;
                                   //
                                   // Sig            m_sigID;
                                   // List           m_lstActiveSessions;
                                   // SYSTEMTIME     m_stLastUsed;
    m_dwLastSession = 0;           // DWORD          m_dwLastSession;
                                   //
    m_fDirty        = false;       // mutable bool   m_fDirty;
    m_hfFile        = NULL;        // mutable HANDLE m_hfFile;


    if((iPos = szFile.find( CLIENT_CONST__DB_EXTENSION, 0 )) != MPC::wstring::npos)
    {
        m_szFile = MPC::wstring( &szFile[0], &szFile[iPos] );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::~MPCClient
//
// Synopsis    : Before destructing the object, ensures its state is updated
//               to disk.
//
/////////////////////////////////////////////////////////////////////////////
MPCClient::~MPCClient()
{
    __ULT_FUNC_ENTRY("MPCClient::~MPCClient");

    if(m_hfFile)
    {
        (void)SyncToDisk();

        ::CloseHandle( m_hfFile ); m_hfFile = NULL;
    }
}

MPCServer* MPCClient::GetServer() { return m_mpcsServer; }

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Persistence
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::IsDirty
//
// Return      : bool : 'true' is the object is out-of-sync with the disk.
//
// Synopsis    : Checks if the object needs to be written to disk.
//
/////////////////////////////////////////////////////////////////////////////
bool MPCClient::IsDirty() const
{
    __ULT_FUNC_ENTRY("MPCClient::IsDirty");

    bool fRes = true; // Default result.


    if(m_fDirty)
    {
        __ULT_FUNC_LEAVE;
    }
    else
    {
        //
        // Recursively check the 'Dirty' state of each session.
        //
        for(IterConst it = m_lstActiveSessions.begin(); it != m_lstActiveSessions.end(); it++)
        {
            if(it->IsDirty()) __ULT_FUNC_LEAVE;
        }
    }

    fRes = false;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(fRes);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::Load
//
// Parameters  : MPC::Serializer& in : the stream used to initialize the object.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Loads the state of this object from the stream.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::Load( /*[in]*/ MPC::Serializer& streamIn )
{
    __ULT_FUNC_ENTRY("MPCClient::Load");

    HRESULT    hr;
    DWORD      dwVer;
    Sig        sigID;
    MPCSession mpcsSession(this);


    //
    // Clean up the previous state of the object.
    //
    m_lstActiveSessions.clear();


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> dwVer);

    if(dwVer != c_dwVersion)
    {
        m_fDirty = true; // Force rewrite...

        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> sigID          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_stLastUsed   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwLastSession);

    if(m_szFile.length())
    {
        //
        // In case of direct access (m_szFile != ""), initialize the sigID from disk.
        //
        m_sigID = sigID;
    }
    else if(m_sigID == sigID)
    {
        //
        // IDs match...
        //
    }
    else
    {
        //
        // IDs don't match, fail.
        //
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }


    //
    // While it's successful to read MPCSession objects from the stream,
    // keep adding them to the list of active sessions.
    //
    while(SUCCEEDED(mpcsSession.Load( streamIn )))
    {
        m_lstActiveSessions.push_back( mpcsSession );
    }

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::Save
//
// Parameters  : MPC::Serializer& out : the stream used to persist the state of the object.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Saves the state of this object to the stream.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::Save( /*[in]*/ MPC::Serializer& streamOut ) const
{
    __ULT_FUNC_ENTRY("MPCClient::Save");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << c_dwVersion    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_sigID        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_stLastUsed   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwLastSession);

    //
    // Recursively save each session.
    //
    {
        for(IterConst it = m_lstActiveSessions.begin(); it != m_lstActiveSessions.end(); it++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, it->Save( streamOut ));
        }
    }

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;


    __ULT_FUNC_EXIT(hr);
}


//////////////////////////////////////////////////////////////////////
// Operators
//////////////////////////////////////////////////////////////////////

bool MPCClient::operator==( /*[in]*/ const UploadLibrary::Signature& rhs )
{
    __ULT_FUNC_ENTRY("MPCClient::operator==");


    bool fRes = (m_sigID == rhs);


    __ULT_FUNC_EXIT(fRes);
}

bool MPCClient::Find( /*[in] */ const MPC::wstring& szJobID ,
                      /*[out]*/ Iter&               it      )
{
    __ULT_FUNC_ENTRY("MPCClient::Find");

    bool fRes;


    it = std::find( m_lstActiveSessions.begin(), m_lstActiveSessions.end(), szJobID );

    fRes = (it != m_lstActiveSessions.end());


    __ULT_FUNC_EXIT(fRes);
}

void MPCClient::Erase( /*[in]*/ Iter& it )
{
    __ULT_FUNC_ENTRY("MPCClient::Erase");


    m_lstActiveSessions.erase( it );
    m_fDirty = true;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Methods
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetInstance
//
// Parameters  : CISAPIistance*& isapiInstance : instance of this request.
//               bool&           fFound        : true if instance exists.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Locates the configuration settings for the server
//               associated with this client.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetInstance( /*[out]*/ CISAPIinstance*& isapiInstance ,
                                /*[out]*/ bool&            fFound        ) const
{
    __ULT_FUNC_ENTRY("MPCClient::GetInstance");

    HRESULT hr;

    isapiInstance = m_mpcsServer->getInstance();
    fFound        = (isapiInstance != NULL);

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetInstance
//
// Parameters  : MPC::wstring& szURL : variable where to store the server name.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Returns the URL associated with this client.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetInstance( /*[out]*/ MPC::wstring& szURL ) const
{
    __ULT_FUNC_ENTRY("MPCClient::GetInstance");

    HRESULT hr;


    m_mpcsServer->getURL( szURL );
    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::IDtoPath
//
// Parameters  : MPC::wstring& szStr : output buffer for the path.
//
// Synopsis    : Hashing algorithm, to transform from the client ID to the
//               temporary queue location.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::IDtoPath( /*[out]*/ MPC::wstring& szStr ) const
{
    __ULT_FUNC_ENTRY("MPCClient::IDtoPath");

    HRESULT hr;
    WCHAR   rgBuf1[4*2+1];
    WCHAR   rgBuf2[2*2+1];
    WCHAR   rgBuf3[2*2+1];
    WCHAR   rgBuf4[8*2+1];


    swprintf( rgBuf1, L"%08lx",      m_sigID.guidMachineID.Data1 );
    swprintf( rgBuf2, L"%04x" , (int)m_sigID.guidMachineID.Data2 );
    swprintf( rgBuf3, L"%04x" , (int)m_sigID.guidMachineID.Data3 );

    for(int i=0; i<8; i++)
    {
        swprintf( &rgBuf4[i*2], L"%02x", (int)m_sigID.guidMachineID.Data4[i] );
    }

    //
    // Debug Format: XXYYYZZZ-AAAA-BBBB-CCCCCCCC
    //
    szStr.append( L"\\"  );
    szStr.append( rgBuf1 );
    szStr.append( L"-"   );
    szStr.append( rgBuf2 );
    szStr.append( L"-"   );
    szStr.append( rgBuf3 );
    szStr.append( L"-"   );
    szStr.append( rgBuf4 );

    //
    // Format: XX\YYY\ZZZ\AAAA-BBBB-CCCCCCCC
    //
/*
    szStr.append( &rgBuf1[0], &rgBuf1[2] );
    szStr.append( L"\\"                  );
    szStr.append( &rgBuf1[2], &rgBuf1[5] );
    szStr.append( L"\\"                  );
    szStr.append( &rgBuf1[5], &rgBuf1[8] );
    szStr.append( L"\\"                  );
    szStr.append(  rgBuf2                );
    szStr.append( L"-"                   );
    szStr.append(  rgBuf3                );
    szStr.append( L"-"                   );
    szStr.append(  rgBuf4                );
*/
    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::BuildClientPath
//
// Parameters  : MPC::wstring& szPath : output buffer for the path.
//
// Synopsis    : Returns in 'szPath' the location of this client's data.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::BuildClientPath( /*[out]*/ MPC::wstring& szPath ) const
{
    __ULT_FUNC_ENTRY("MPCClient::BuildClientPath");

    HRESULT hr;


    if(m_szFile.length())
    {
        szPath = m_szFile;
    }
    else
    {
        CISAPIinstance* isapiInstance;
        bool            fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, GetInstance( isapiInstance, fFound ));
        if(fFound == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }
        else
        {
            CISAPIinstance::PathIter itBegin;
            CISAPIinstance::PathIter itEnd;

            __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->GetLocations( itBegin, itEnd ));

            if(itBegin == itEnd)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
            }

            szPath = *itBegin; IDtoPath( szPath );
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetFileName
//
// Parameters  : MPC::wstring& szFile : output buffer for the path.
//
// Synopsis    : Returns the filename of the directory file.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetFileName( /*[out]*/ MPC::wstring& szFile ) const
{
    __ULT_FUNC_ENTRY("MPCClient::GetFileName");

    //
    // The filename for the Directory File is "<ID>.db"
    //
    BuildClientPath( szFile );

    szFile.append( CLIENT_CONST__DB_EXTENSION );


    __ULT_FUNC_EXIT(S_OK);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetFileSize
//
// Parameters  : DWORD& dwSize : size of the Directory File.
//
// Synopsis    : Returns the size of the directory file, if opened.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetFileSize( /*[out]*/ DWORD& dwSize ) const
{
    __ULT_FUNC_ENTRY("MPCClient::GetFileSize");

    HRESULT hr;


    if(m_hfFile)
    {
        BY_HANDLE_FILE_INFORMATION info;

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetFileInformationByHandle( m_hfFile, &info ));

        dwSize = info.nFileSizeLow;
    }
    else
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT( hr, ERROR_INVALID_HANDLE );
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::FormatID
//
// Parameters  : MPC::wstring& szID : output buffer for the ID.
//
// Synopsis    : Returns a textual representation of the client ID.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::FormatID( /*[out]*/ MPC::wstring& szID ) const
{
    __ULT_FUNC_ENTRY("MPCClient::FormatID");

    HRESULT  hr;
    CComBSTR bstrSig;

    bstrSig = m_sigID.guidMachineID;
    szID    = bstrSig;
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::CheckSignature
//
// Return      : bool : 'true' on success.
//
// Synopsis    : Validates the ID of this client, to ensure it's not a fake.
//
/////////////////////////////////////////////////////////////////////////////
bool MPCClient::CheckSignature() const
{
    __ULT_FUNC_ENTRY("MPCClient::CheckSignature");

    bool fRes = true;

    __ULT_FUNC_EXIT(fRes);
}

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::OpenStorage
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Opens the Directory File for this client, trying to
//               lock it for exclusive usage.
//               The file is kept open until this object is deleted.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::OpenStorage( /*[in]*/ bool fCheckFreeSpace )
{
    __ULT_FUNC_ENTRY("MPCClient::OpenStorage");

    HRESULT      hr;
    MPC::wstring szFile;
    bool         fLocked = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFile ));

    //
    // If requested, make sure there's enough free space before opening the file.
    //
    if(fCheckFreeSpace)
    {
        bool fEnough;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFile, DISKSPACE_SAFETYMARGIN, fEnough ));
        if(fEnough == false)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_DISK_FULL );
        }
    }


    if(m_hfFile == NULL)
    {

        // Ensure the directory exists.
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( szFile ) );

        m_hfFile = ::CreateFileW( szFile.c_str(), GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        if(m_hfFile == INVALID_HANDLE_VALUE)
        {
            m_hfFile = NULL;

            DWORD dwRes = ::GetLastError();
            if(dwRes == ERROR_SHARING_VIOLATION)
            {
                fLocked = true;
            }

            __MPC_SET_WIN32_ERROR_AND_EXIT( hr, dwRes );
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        MPC::wstring szURL;      m_mpcsServer->getURL( szURL );
        MPC::wstring szID; (void)FormatID            ( szID  );

        if(fLocked)
        {
            (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, PCHUL_WARN_COLLISION,
                                       szURL .c_str(), // %1 = SERVER
                                       szID  .c_str(), // %2 = CLIENT
                                       szFile.c_str(), // %3 = FILE
                                       NULL          );
        }
        else
        {
            (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_CLIENT_DB,
                                       szURL .c_str(), // %1 = SERVER
                                       szID  .c_str(), // %2 = CLIENT
                                       szFile.c_str(), // %3 = FILE
                                       NULL          );
        }
    }

    __ULT_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::InitFromDisk
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Opens the Directory File (if not already opened) and reads
//               the state of the client from disk.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::InitFromDisk( /*[in]*/ bool fCheckFreeSpace )
{
    __ULT_FUNC_ENTRY("MPCClient::InitFromDisk");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStorage( fCheckFreeSpace ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, Load( MPC::Serializer_File( m_hfFile ) ));


    //
    // Now check that all the files exist.
    //
    {
        Iter it = m_lstActiveSessions.begin();
        while(it != m_lstActiveSessions.end())
        {
            bool    fPassed;
            HRESULT hr2 = it->Validate( true, fPassed );

            if(FAILED(hr2) || fPassed == false)
            {
                m_lstActiveSessions.erase( it ); // Remove session.
                m_fDirty = true;

                it = m_lstActiveSessions.begin(); // Iterator corrupted, restart from beginning.
            }
            else
            {
                it++;
            }
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    //
    // If the file is not correctly loaded, try to recreate it.
    //
    if(hr == HRESULT_FROM_WIN32( ERROR_HANDLE_EOF ))
    {
        hr = SaveToDisk();
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::SaveToDisk
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Opens the Directory File (if not already opened) and writes
//               the state of the client to disk.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::SaveToDisk()
{
    __ULT_FUNC_ENTRY("MPCClient::SaveToDisk");

    HRESULT hr;
    DWORD   dwRes;


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStorage( false ));


    //
    // Move to the beginning of the file and truncate it.
    //
    __MPC_EXIT_IF_CALL_RETURNS_THISVALUE(hr, ::SetFilePointer( m_hfFile, 0, NULL, FILE_BEGIN ), INVALID_SET_FILE_POINTER);

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetEndOfFile( m_hfFile ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, Save( MPC::Serializer_File( m_hfFile ) ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::SyncToDisk
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : If the Directory File has been read and modified, update it to disk.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::SyncToDisk()
{
    __ULT_FUNC_ENTRY("MPCClient::SyncToDisk");

    HRESULT hr;


    if(m_hfFile && IsDirty())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, SaveToDisk());
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetSessions
//
// Parameters  : Iter& itBegin : first session.
//               Iter& itEnd   : end session marker.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Returns two iterators to access the sessions.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetSessions( /*[out]*/ Iter& itBegin ,
                                /*[out]*/ Iter& itEnd   )
{
    __ULT_FUNC_ENTRY("MPCClient::GetSessions");

    HRESULT hr;


    itBegin = m_lstActiveSessions.begin();
    itEnd   = m_lstActiveSessions.end  ();
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::NewSession
//
// Parameters  : UploadLibrary::ClientRequest_OpenSession& req :
//                holds the information for the new session about to create.
//
// Return      : MPCClient::Iter : an iterator pointing to the new session.
//
// Synopsis    : Based on the values of 'req', creates a new session.
//
/////////////////////////////////////////////////////////////////////////////
MPCClient::Iter MPCClient::NewSession( /*[in]*/ UploadLibrary::ClientRequest_OpenSession& crosReq )
{
    __ULT_FUNC_ENTRY("MPCClient::NewSession");

    MPCClient::Iter it;
    MPCSession      mpcsNewSession( this, crosReq, m_dwLastSession++ );

    it = m_lstActiveSessions.insert( m_lstActiveSessions.end(), mpcsNewSession );

    ::GetSystemTime( &m_stLastUsed );
    m_fDirty = true;


    __ULT_FUNC_EXIT(it);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::AppendData
//
// Parameters  : UploadLibrary::ClientRequest_OpenSession& req : holds the information for the new session about to create.
//
// Return      : MPCClient::Iter : an iterator pointing to the new session.
//
// Synopsis    : Based on the values of 'req', creates a new session.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::AppendData( /*[in]*/ MPCSession&      mpcsSession ,
                               /*[in]*/ MPC::Serializer& streamConn  ,
                               /*[in]*/ DWORD            dwSize      )
{
    __ULT_FUNC_ENTRY("MPCClient::AppendData");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, mpcsSession.AppendData( streamConn, dwSize ));

    ::GetSystemTime( &m_stLastUsed );
    m_fDirty = true;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCClient::CheckQuotas( /*[in] */ MPCSession& mpcsSession  ,
                                /*[out]*/ bool&       fServerBusy  ,
                                /*[out]*/ bool&       fAccessDenied,
                                /*[out]*/ bool&       fExceeded    )
{
    __ULT_FUNC_ENTRY("MPCClient::CheckQuotas");

    HRESULT         hr;
    DWORD           dwError       = 0;
    DWORD           dwJobsPerDay  = 0;
    DWORD           dwBytesPerDay = 0;
    DWORD           dwJobSize     = 0;
    DWORD           dwMaxJobsPerDay;
    DWORD           dwMaxBytesPerDay;
    DWORD           dwMaxJobSize;
    DWORD           fProcessingMode;
    CISAPIprovider* isapiProvider;
    IterConst       it;
    bool            fFound;


    fServerBusy   = false;
    fAccessDenied = false;
    fExceeded     = false;


    //
    // If the related provider doesn't exist, validation fails.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, mpcsSession.GetProvider( isapiProvider, fFound ));
    if(fFound == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_MaxJobSize    ( dwMaxJobSize     ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_MaxJobsPerDay ( dwMaxJobsPerDay  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_MaxBytesPerDay( dwMaxBytesPerDay ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_ProcessingMode( fProcessingMode  ));

    if(fProcessingMode != 0)
    {
        fServerBusy = true;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    mpcsSession.get_TotalSize( dwJobSize );

	//
	// Find inactive sessions.
	//
	{
		double dblNow = MPC::GetSystemTime();

		for(it = m_lstActiveSessions.begin(); it != m_lstActiveSessions.end(); it++)
		{
			double dblLastModified;

			it->get_LastModified( dblLastModified );
			
			if(dblNow - dblLastModified < 1.0) // Within 24 hours.
			{
				DWORD dwTotalSize; it->get_TotalSize( dwTotalSize );

				dwJobsPerDay  += 1;
				dwBytesPerDay += dwTotalSize;
			}
		}
	}

    if(dwMaxJobSize && dwMaxJobSize < dwJobSize)
    {
        dwError       = PCHUL_INFO_QUOTA_JOB_SIZE;
        fAccessDenied = true;
    }

    if(dwMaxJobsPerDay && dwMaxJobsPerDay < dwJobsPerDay)
    {
        dwError   = PCHUL_INFO_QUOTA_DAILY_JOBS;
        fExceeded = true;
    }

    if(dwMaxBytesPerDay && dwMaxBytesPerDay < dwBytesPerDay)
    {
        dwError   = PCHUL_INFO_QUOTA_DAILY_BYTES;
        fExceeded = true;
    }


    //
    // Check if enough free space is available.
    //
    {
        MPC::wstring szFile;
        bool         fEnough;

        __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFile ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFile, DISKSPACE_SAFETYMARGIN, fEnough ));
        if(fEnough == false)
        {
            dwError   = PCHUL_INFO_QUOTA_DAILY_BYTES;
            fExceeded = true;
        }
    }


    if(dwError != 0)
    {
        //
        // Quota limits exceeded.
        //
        MPC::wstring szURL;        m_mpcsServer->getURL   ( szURL  );
        MPC::wstring szID;   (void)FormatID               ( szID   );
        MPC::wstring szName; (void)isapiProvider->get_Name( szName );

        (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, dwError,
                                   szURL .c_str(), // %1 = SERVER
                                   szID  .c_str(), // %2 = CLIENT
                                   szName.c_str(), // %3 = PROVIDER
                                   NULL          );
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\config.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Config.cpp

Abstract:
    This file contains the implementation of the MPCConfig class,
    that extends the CISAPIconfig class.

Revision History:
    Davide Massarenti   (Dmassare)  05/02/99
        created

******************************************************************************/

#include "stdafx.h"


static MPC::wstring l_DefaultInstance   = L"DEFAULT";
static DWORD        l_MaximumPacketSize = 64*1024;


HRESULT Config_GetInstance( /*[in] */ const MPC::wstring& szURL         ,
                            /*[out]*/ CISAPIinstance*&    isapiInstance ,
                            /*[out]*/ bool&               fFound        )
{
    __ULT_FUNC_ENTRY("Config_GetInstance");

    HRESULT            hr;
    CISAPIconfig::Iter it;

    isapiInstance = NULL;

    __MPC_EXIT_IF_METHOD_FAILS(hr, g_Config.GetInstance( it, fFound, szURL ));

    if(fFound == false)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, g_Config.GetInstance( it, fFound, l_DefaultInstance ));
    }

    if(fFound)
    {
        isapiInstance = &(*it);
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT Config_GetProvider( /*[in] */ const MPC::wstring& szURL         ,
                            /*[in] */ const MPC::wstring& szName        ,
                            /*[out]*/ CISAPIprovider*&    isapiProvider ,
                            /*[out]*/ bool&               fFound        )
{
    __ULT_FUNC_ENTRY("Config_GetProvider");

    HRESULT                  hr;
    CISAPIinstance*          isapiInstance;
    CISAPIinstance::ProvIter it;

    isapiProvider = NULL;

    //
    // First of all, check if the provider is supplied directly by the instance.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::Config_GetInstance( szURL, isapiInstance, fFound ));
    if(fFound == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->GetProvider( it, fFound, szName ));
    if(fFound == false)
    {
        //
        // No, the provider is not provided directly by this instance, try using the DEFAULT one.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Config_GetInstance( l_DefaultInstance, isapiInstance, fFound ));
        if(fFound == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->GetProvider( it, fFound, szName ));
    }

    if(fFound)
    {
        isapiProvider = &((*it).second);
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT Config_GetMaximumPacketSize( /*[in] */ const MPC::wstring& szURL               ,
                                     /*[out]*/ DWORD&              dwMaximumPacketSize )
{
    __ULT_FUNC_ENTRY("Config_GetMaximumPacketSize");

    HRESULT         hr;
    CISAPIinstance* isapiInstance;
    bool            fFound;


    dwMaximumPacketSize = l_MaximumPacketSize;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::Config_GetInstance( szURL, isapiInstance, fFound ));
    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->get_MaximumPacketSize( dwMaximumPacketSize ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT Util_CheckDiskSpace( /*[in] */ const MPC::wstring& szFile     ,
							 /*[in] */ DWORD               dwLowLevel ,
							 /*[out]*/ bool&               fEnough    )
{
    __ULT_FUNC_ENTRY("Util_CheckDiskSpace");

	HRESULT        hr;
	ULARGE_INTEGER liFree;
	ULARGE_INTEGER liTotal;


	fEnough = false;


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetDiskSpace( szFile, liFree, liTotal ));

	if(liFree.HighPart > 0          ||
	   liFree.LowPart  > dwLowLevel  )
	{
		fEnough = true;
	}

	hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\config.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Config.h

Abstract:
    This file contains the declaration of the MPCConfig class,
    that extends the CISAPIconfig class.

Revision History:
    Davide Massarenti   (Dmassare)  05/02/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___CONFIG_H___)
#define __INCLUDED___ULSERVER___CONFIG_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


HRESULT Config_GetInstance         ( /*[in]*/ const MPC::wstring& szURL,                                      /*[out]*/ CISAPIinstance*& isapiInstance      , /*[out]*/ bool& fFound );
HRESULT Config_GetProvider         ( /*[in]*/ const MPC::wstring& szURL, /*[in]*/ const MPC::wstring& szName, /*[out]*/ CISAPIprovider*& isapiProvider      , /*[out]*/ bool& fFound );
HRESULT Config_GetMaximumPacketSize( /*[in]*/ const MPC::wstring& szURL,                                      /*[out]*/ DWORD&           dwMaximumPacketSize                         );

HRESULT Util_CheckDiskSpace( /*[in]*/ const MPC::wstring& szFile, /*[in]*/ DWORD dwLowLevel, /*[out]*/ bool& fEnough );


#endif // !defined(__INCLUDED___ULSERVER___CONFIG_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\persist.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Persist.h

Abstract:
    This file contains the declaration of the MPCPersist interface,
    used by MPCClient and MPCSession to persist their state.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___PERSIST_H___)
#define __INCLUDED___ULSERVER___PERSIST_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class MPCPersist
{
public:
    virtual bool    IsDirty() const = 0;

    virtual HRESULT Load( /*[in]*/ MPC::Serializer& streamIn  )       = 0;
    virtual HRESULT Save( /*[in]*/ MPC::Serializer& streamOut ) const = 0;
};


#endif // !defined(__INCLUDED___ULSERVER___PERSIST_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\httpcontext.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HttpContext.h

Abstract:
    This file contains the declaration of the MPCHttpContext class,
    which handles the interface with IIS.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___HTTPCONTEXT_H___)
#define __INCLUDED___ULSERVER___HTTPCONTEXT_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// Forward declarations.
//
class MPCServer;
class MPCHttpPipe;


class MPCHttpContext
{
    enum FSMstate
    {
        FSM_REGISTER,
        FSM_INPUT   ,
        FSM_PROCESS ,
        FSM_OUTPUT  ,
        FSM_DELETE
    };

    enum IOstate
    {
        IO_IDLE   ,
        IO_READING,
        IO_WRITING
    };


    LPEXTENSION_CONTROL_BLOCK m_pECB;

    MPCServer*                m_mpcsServer;
	DWORD                     m_dwSkippedInput;
    BOOL                      m_fRequestProcessed;
    BOOL                      m_fKeepConnection;

    BOOL                      m_fAsync;
    FSMstate                  m_FSMstate;
    IOstate                   m_IOstate;


    MPC::Serializer_Memory    m_hsInput;
    MPC::Serializer_Memory    m_hsOutput;

    BYTE                      m_rgBuffer[4096];
    DWORD                     m_dwIOcount;

    //////////////////////////////////////////////////////////////////

protected:
    DWORD AsyncRead();
    DWORD AsyncWrite();

    DWORD AdvanceFSM();

    DWORD Fsm_Register();
    DWORD Fsm_ReceiveInput();
    DWORD Fsm_Process();
    DWORD Fsm_SendOutput();

    static VOID WINAPI IOCompletion( /*[in]*/ EXTENSION_CONTROL_BLOCK* pECB     ,
                                     /*[in]*/ PVOID                    pContext ,
                                     /*[in]*/ DWORD                    cbIO     ,
                                     /*[in]*/ DWORD                    dwError  );

    //////////////////////////////////////////////////////////////////

public:
    MPCHttpContext();
    virtual ~MPCHttpContext();

    DWORD Init( /*[in]*/ LPEXTENSION_CONTROL_BLOCK pECB );

    HRESULT GetServerVariable ( /*[in]*/ LPCSTR      szVar  , /*[out]*/ MPC::wstring& szValue                             );
    HRESULT GetRequestSize    (                               /*[out]*/ DWORD& 		  dwCount                             );
    HRESULT CheckDataAvailable(                               /*[in] */ DWORD  		  dwCount, /*[out]*/ bool& fAvailable );
    HRESULT Read              ( /*[in]*/       void* pBuffer, /*[in] */ DWORD  		  dwCount                             );
    HRESULT Write             ( /*[in]*/ const void* pBuffer, /*[in] */ DWORD  		  dwCount                             );

    //////////////////////////////////////////////////////////////////

#ifdef DEBUG
    bool                      m_Debug_NO_RESPONSE_TO_OPEN;

    bool                      m_Debug_NO_RESPONSE_TO_WRITE;

    bool                      m_Debug_RESPONSE_TO_OPEN;
    DWORD                     m_Debug_RESPONSE_TO_OPEN_response;
    DWORD                     m_Debug_RESPONSE_TO_OPEN_position;
    DWORD                     m_Debug_RESPONSE_TO_OPEN_protocol;

    bool                      m_Debug_RESPONSE_TO_WRITE;
    DWORD                     m_Debug_RESPONSE_TO_WRITE_response;
    DWORD                     m_Debug_RESPONSE_TO_WRITE_position;
    DWORD                     m_Debug_RESPONSE_TO_WRITE_protocol;

    bool                      m_Debug_RANDOM_POINTER_ERROR;
    DWORD                     m_Debug_RANDOM_POINTER_ERROR_pos_low;
    DWORD                     m_Debug_RANDOM_POINTER_ERROR_pos_high;

    bool                      m_Debug_FIXED_POINTER_ERROR;
    DWORD                     m_Debug_FIXED_POINTER_ERROR_pos;
#endif

    //////////////////////////////////////////////////////////////////
};

#endif // !defined(__INCLUDED___ULSERVER___HTTPCONTEXT_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\purgeengine.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    PurgeEngine.cpp

Abstract:
    This file contains the implementation of the MPCPurgeEngine class,
    that controls the cleaning of the temporary directories.

Revision History:
    Davide Massarenti   (Dmassare)  07/12/99
        created

******************************************************************************/

#include "stdafx.h"


HRESULT MPCPurgeEngine::Process()
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::Process");

    HRESULT                  hr;
    HRESULT                  hr2;
    CISAPIconfig::Iter       itInstanceBegin;
    CISAPIconfig::Iter       itInstanceEnd;
    CISAPIinstance::PathIter itPathBegin;
    CISAPIinstance::PathIter itPathEnd;
    double                   dblNow = MPC::GetSystemTime();


    //
    // Enumerate all the instances.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, g_Config.GetInstances( itInstanceBegin, itInstanceEnd ));
    for(;itInstanceBegin != itInstanceEnd; itInstanceBegin++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->get_URL               ( m_szURL                ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->get_QueueSizeMax      ( m_dwQueueSizeMax       ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->get_QueueSizeThreshold( m_dwQueueSizeThreshold ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->get_MaximumJobAge     ( m_dwMaximumJobAge      ));

        m_dblMaximumJobAge = dblNow - m_dwMaximumJobAge;


		MPCServer mpcsServer( NULL, m_szURL.c_str(), NULL );
		m_mpcsServer = &mpcsServer;

        //
        // For each instance, enumerate all the temporary directories.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->GetLocations( itPathBegin, itPathEnd ));
        for(;itPathBegin != itPathEnd; itPathBegin++)
        {
            MPC::FileSystemObject fso( itPathBegin->c_str() );

            if(SUCCEEDED(hr2 = fso.Scan( true )))
            {
                DWORD dwTotalSize = 0;

                m_lstClients.clear();

                __MPC_EXIT_IF_METHOD_FAILS(hr, AnalyzeFolders( &fso, dwTotalSize ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveOldJobs( dwTotalSize ));

                if(dwTotalSize > m_dwQueueSizeMax)
                {
                    while(dwTotalSize && dwTotalSize > m_dwQueueSizeThreshold)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveOldestJob   ( dwTotalSize ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveEmptyClients( dwTotalSize ));
                    }
                }
            }
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

static bool MatchExtension( const MPC::wstring& szPath ,
                            LPCWSTR             szExt  )
{
    MPC::wstring::size_type iPos;

    iPos = szPath.find( szExt, 0 );
    if(iPos != MPC::wstring::npos && iPos + wcslen( szExt ) == szPath.length())
    {
        return true;
    }

    return false;
}

HRESULT MPCPurgeEngine::AnalyzeFolders( /*[in]*/ MPC::FileSystemObject* fso         ,
                                        /*[in]*/ DWORD&                 dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::AnalyzeFolders");

    HRESULT                     hr;
    HRESULT                     hr2;
    MPC::FileSystemObject::List lst;
    MPC::FileSystemObject::Iter it;


    //
    // Process all folders.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso->EnumerateFolders( lst ));
    for(it = lst.begin(); it != lst.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, AnalyzeFolders( *it, dwTotalSize ));
    }

    //
    // Process all files.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso->EnumerateFiles( lst ));
    for(it = lst.begin(); it != lst.end(); it++)
    {
        MPC::wstring szPath;

        __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->get_Path( szPath ));

        if(MatchExtension( szPath, CLIENT_CONST__DB_EXTENSION ))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, AddClient( szPath, dwTotalSize ));
        }
        else if(MatchExtension( szPath, SESSION_CONST__IMG_EXTENSION ))
        {
            ;
        }
        else
        {
            //
            // Any other file should be deleted.
            //
            (void)(*it)->Delete();
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::AddClient( /*[in]*/     const MPC::wstring& szPath      ,
                                   /*[in/out]*/ DWORD&              dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::AddClient");

    HRESULT   hr;
    HRESULT   hr2;
    MPCClient mpccClient( m_mpcsServer, szPath );
    Iter      itClient = m_lstClients.insert( m_lstClients.end(), MPCPurge_ClientSummary( szPath ) );

    if(SUCCEEDED(hr2 = mpccClient.InitFromDisk( false )))
    {
        MPCClient::Iter itBegin;
        MPCClient::Iter itEnd;

        //
        // Adjust total count with size of the Directory File.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, mpccClient.GetFileSize( itClient->m_dwFileSize ));
        dwTotalSize += itClient->m_dwFileSize;


        __MPC_EXIT_IF_METHOD_FAILS(hr, mpccClient.GetSessions( itBegin, itEnd ));
        while(itBegin != itEnd)
        {
            MPCPurge_SessionSummary pssSession;

            itBegin->get_JobID       ( pssSession.m_szJobID         );
            itBegin->get_LastModified( pssSession.m_dblLastModified );
            itBegin->get_CurrentSize ( pssSession.m_dwCurrentSize   );

            //
            // Don't count "committed" jobs in total size, because the file has already been moved.
            //
            if(itBegin->get_Committed())
            {
                pssSession.m_dwCurrentSize = 0;
            }

            itClient->m_lstSessions.push_back( pssSession );

            dwTotalSize += pssSession.m_dwCurrentSize;
            itBegin++;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::RemoveOldJobs( /*[in/out]*/ DWORD& dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::RemoveOldJobs");

    HRESULT hr;
    HRESULT hr2;
    Iter    it;

    for(it = m_lstClients.begin(); it != m_lstClients.end(); it++)
    {
        MPCPurge_ClientSummary::Iter itSession;
        MPCClient                    mpccClient( m_mpcsServer, it->m_szPath );
        bool                         fInitialized = false;

        while(it->GetOldestSession( itSession ))
        {
            //
            // If the oldest session is younger than the limit, leave the loop.
            //
            if(itSession->m_dblLastModified > m_dblMaximumJobAge)
            {
                break;
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveSession( mpccClient, fInitialized, it, itSession, dwTotalSize ));
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::RemoveOldestJob( /*[in/out]*/ DWORD& dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::RemoveOldestJob");

    HRESULT hr;
    HRESULT hr2;
    Iter    it;
    Iter    itOldestClient;
    double  dblOldestClient = DBL_MAX;
    bool    fFound          = false;

    //
    // Look for the oldest job.
    //
    for(it = m_lstClients.begin(); it != m_lstClients.end(); it++)
    {
        if(it->m_dblLastModified < dblOldestClient)
        {
            itOldestClient  = it;
            dblOldestClient = it->m_dblLastModified;
            fFound          = true;
        }
    }

    if(fFound)
    {
        MPCPurge_ClientSummary::Iter itSession;
        MPCClient                    mpccClient( m_mpcsServer, itOldestClient->m_szPath );
        bool                         fInitialized = false;

        if(itOldestClient->GetOldestSession( itSession ))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveSession( mpccClient, fInitialized, itOldestClient, itSession, dwTotalSize ));

            //
            // Update the m_dblLastModified of the MPCPurge_ClientSummary object.
            //
            itOldestClient->GetOldestSession( itSession );
        }

        if(fInitialized)
        {
            DWORD dwPost;

            __MPC_EXIT_IF_METHOD_FAILS(hr, mpccClient.SyncToDisk (        ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, mpccClient.GetFileSize( dwPost ));

            //
            // Update Directory File size.
            //
            dwTotalSize                  -= itOldestClient->m_dwFileSize;
            dwTotalSize                  += dwPost;
            itOldestClient->m_dwFileSize  = dwPost;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::RemoveSession( /*[in]*/     MPCClient&                    mpccClient   ,
                                       /*[in/out]*/ bool&                         fInitialized ,
                                       /*[in]*/     Iter                          itClient     ,
                                       /*[in]*/     MPCPurge_ClientSummary::Iter& itSession    ,
                                       /*[in/out]*/ DWORD&                        dwTotalSize  )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::RemoveSession");

    HRESULT hr;
    HRESULT hr2;


    //
    // Lock the client.
    //
    if(fInitialized == false)
    {
        if(SUCCEEDED(hr2 = mpccClient.InitFromDisk( false )))
        {
            fInitialized = true;
        }
    }

    if(fInitialized)
    {
        MPCClient::Iter itSessionReal;

        //
        // If the session exists, remove it.
        //
        if(mpccClient.Find( itSession->m_szJobID, itSessionReal ) == true)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, itSessionReal->RemoveFile());

            mpccClient.Erase( itSessionReal );
        }

        //
        // Update the total size counter and remove the session from memory.
        //
        dwTotalSize -=                 itSession->m_dwCurrentSize;
        itClient->m_lstSessions.erase( itSession );
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::RemoveEmptyClients( /*[in/out]*/ DWORD& dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::RemoveEmptyClients");

    HRESULT hr;
    Iter    it;

    for(it = m_lstClients.begin(); it != m_lstClients.end(); it++)
    {
        //
        // If the client has no more sessions, don't count it.
        //
        if(it->m_lstSessions.size() == 0)
        {
            dwTotalSize -= it->m_dwFileSize;

            m_lstClients.erase( it ); it = m_lstClients.begin();
        }
    }

    hr = S_OK;


    //    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

MPCPurge_ClientSummary::MPCPurge_ClientSummary( const MPC::wstring& szPath )
{
    m_szPath          = szPath; // MPC::wstring m_szPath;
                              	// List         m_lstSessions;
    m_dwFileSize      = 0;    	// DWORD        m_dwFileSize;
    m_dblLastModified = 0;    	// double       m_dblLastModified;
}

bool MPCPurge_ClientSummary::GetOldestSession( /*[out]*/ Iter& itSession )
{
    Iter it;

    m_dblLastModified = DBL_MAX;
    itSession         = m_lstSessions.end();

    for(it = m_lstSessions.begin(); it != m_lstSessions.end(); it++)
    {
        if(it->m_dblLastModified < m_dblLastModified)
        {
            itSession = it;
            m_dblLastModified = it->m_dblLastModified;
        }
    }

    return (itSession != m_lstSessions.end());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\httpcontext.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HttpContext.cpp

Abstract:
    This file contains the implementation of the MPCHttpContext class,
    which handles the interface with IIS.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"


#define BUFFER_SIZE_TMP      (64)


static const char szStatus [] = "200 OK";
static const char szNewLine[] = "\r\n";


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Static functions.
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


static void SupportAddHeader( /*[in/out]*/ MPC::string& szHeaders     ,
                              /*[in]    */ const char*  szHeaderName  ,
                              /*[in]    */ const char*  szHeaderValue )
{
    __ULT_FUNC_ENTRY("SupportAddHeader");


    szHeaders.append( szHeaderName  );
    szHeaders.append( ": "          );
    szHeaders.append( szHeaderValue );
    szHeaders.append( szNewLine     );
}

static void SupportAddHeader( /*[in/out]*/ MPC::string& szHeaders     ,
                              /*[in]    */ const char*  szHeaderName  ,
                              /*[in]    */ DWORD        dwHeaderValue )
{
    __ULT_FUNC_ENTRY("SupportAddHeader");

    char rgBuf[BUFFER_SIZE_TMP];


    sprintf( rgBuf, "%lu", dwHeaderValue );

    SupportAddHeader( szHeaders, szHeaderName, rgBuf );
}

static void SupportEndHeaders( /*[in/out]*/ MPC::string& szHeaders )
{
    __ULT_FUNC_ENTRY("SupportEndHeaders");


    szHeaders.append( szNewLine );
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Construction/Destruction
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

MPCHttpContext::MPCHttpContext() : m_hsInput (g_Heap),
                                   m_hsOutput(g_Heap)
{
    __ULT_FUNC_ENTRY("MPCHttpContext::MPCHttpContext");


    m_pECB              = NULL;

    m_mpcsServer        = NULL;
    m_dwSkippedInput    = 0;
    m_fRequestProcessed = FALSE;
    m_fKeepConnection   = TRUE;

    m_fAsync            = FALSE;
    m_FSMstate          = FSM_REGISTER;
    m_IOstate           = IO_IDLE;


#ifdef DEBUG
    m_Debug_NO_RESPONSE_TO_OPEN           = false;

    m_Debug_NO_RESPONSE_TO_WRITE          = false;

    m_Debug_RESPONSE_TO_OPEN              = false;
    m_Debug_RESPONSE_TO_OPEN_response     = 0;
    m_Debug_RESPONSE_TO_OPEN_position     = -1;
    m_Debug_RESPONSE_TO_OPEN_protocol     = UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV;

    m_Debug_RESPONSE_TO_WRITE             = false;
    m_Debug_RESPONSE_TO_WRITE_response    = 0;
    m_Debug_RESPONSE_TO_WRITE_position    = -1;
    m_Debug_RESPONSE_TO_WRITE_protocol    = UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV;

    m_Debug_RANDOM_POINTER_ERROR          = false;
    m_Debug_RANDOM_POINTER_ERROR_pos_low  = 0;
    m_Debug_RANDOM_POINTER_ERROR_pos_high = -1;

    m_Debug_FIXED_POINTER_ERROR           = false;
    m_Debug_FIXED_POINTER_ERROR_pos       = 0;
#endif
}

MPCHttpContext::~MPCHttpContext()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::~MPCHttpContext");


    if(m_mpcsServer) delete m_mpcsServer;

    if(m_fAsync && m_pECB)
    {
        //
        //  Close session.
        //
        m_pECB->ServerSupportFunction( m_pECB->ConnID            ,
                                       HSE_REQ_DONE_WITH_SESSION ,
                                       NULL                      ,
                                       NULL                      ,
                                       NULL                      );
    }
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Callbacks
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

VOID WINAPI MPCHttpContext::IOCompletion( /*[in]*/ EXTENSION_CONTROL_BLOCK* pECB     ,
                                          /*[in]*/ PVOID                    pContext ,
                                          /*[in]*/ DWORD                    cbIO     ,
                                          /*[in]*/ DWORD                    dwError  )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::IOCompletion");

    MPCHttpContext* ptr = NULL;

    try
    {
        ptr = reinterpret_cast<MPCHttpContext*>(pContext);

        ptr->m_pECB = pECB;

        if(dwError != ERROR_SUCCESS)
        {
            delete ptr; ptr = NULL;
        }
        else
        {
            switch( ptr->m_IOstate )
            {
            case IO_IDLE:
                break;

            case IO_READING:
                //
                // If the request has already been processed, simply count the number of bytes received.
                //
                if(ptr->m_fRequestProcessed)
                {
                    ptr->m_dwSkippedInput += cbIO;
                }
                else
                {
                    ptr->m_hsInput.write( ptr->m_rgBuffer, cbIO );
                }

                //
                // If this is the last request (cbIO==0) or the number of bytes skipped is equal to the number of missing bytes,
                // proceed to the next phase.
                //
                if(cbIO == 0 || ptr->m_dwSkippedInput == ptr->m_hsInput.GetAvailableForWrite())
                {
                    ptr->m_IOstate = IO_IDLE;
                }
                else
                {
                    if(ptr->Fsm_Process() == HSE_STATUS_ERROR)
                    {
                        delete ptr; ptr = NULL;
                    }
                    else
                    {
                        ptr->AsyncRead();
                    }
                }
                break;

            case IO_WRITING:
                if(cbIO == 0 || ptr->m_hsOutput.IsEOR())
                {
                    ptr->m_IOstate = IO_IDLE;
                }
                else
                {
                    ptr->AsyncWrite();
                }
                break;
            }

            if(ptr->m_IOstate == IO_IDLE)
            {
                ptr->AdvanceFSM();
            }
        }
    }
    catch(...)
    {
        __ULT_TRACE_ERROR( UPLOADLIBID, "Upload Server raised an exception. Gracefully exiting..." );

        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_EXCEPTION,
                                   L""            , // %1 = SERVER
                                   L"IOCompletion", // %2 = CLIENT
                                   NULL           );

        if(ptr)
        {
            delete ptr; ptr = NULL;
        }
    }
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Protected Methods.
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

DWORD MPCHttpContext::AsyncRead()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::AsyncRead");

    DWORD dwRes  = HSE_STATUS_SUCCESS;
    DWORD dwSize = m_hsInput.GetAvailableForWrite();


    //
    // If not all the data has been read, ask for async I/O operation.
    //
    if(dwSize)
    {
        DWORD dwTmp = HSE_IO_ASYNC;

        m_fAsync  = TRUE;
        m_IOstate = IO_READING;

        dwSize = min( dwSize, sizeof(m_rgBuffer) );

        if(!m_pECB->ServerSupportFunction(  m_pECB->ConnID           ,
                                            HSE_REQ_ASYNC_READ_CLIENT,
                                            m_rgBuffer               ,
                                           &dwSize                   ,
                                           &dwTmp                    ))
        {
            dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
        }
        else
        {
            dwRes = HSE_STATUS_PENDING; __ULT_FUNC_LEAVE;
        }
    }


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD MPCHttpContext::AsyncWrite()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::AsyncWrite");

    DWORD dwRes  = HSE_STATUS_SUCCESS;
    DWORD dwSize = m_hsOutput.GetAvailableForRead();


    //
    // If not all the data has been read, ask for async I/O operation.
    //
    if(dwSize)
    {
        m_fAsync  = TRUE;
        m_IOstate = IO_WRITING;

        dwSize = min( dwSize, sizeof(m_rgBuffer) );

        if(FAILED(m_hsOutput.read( m_rgBuffer, dwSize )))
        {
            dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
        }

        if(m_pECB->WriteClient( m_pECB->ConnID, m_rgBuffer, &dwSize, HSE_IO_ASYNC ) == FALSE)
        {
            dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
        }

        dwRes = HSE_STATUS_PENDING; __ULT_FUNC_LEAVE;
    }


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}


DWORD MPCHttpContext::AdvanceFSM()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::AdvanceFSM");

    DWORD dwRes  = HSE_STATUS_SUCCESS;
    bool  fClean = false;


    while(dwRes == HSE_STATUS_SUCCESS)
    {
        switch(m_FSMstate)
        {
        case FSM_REGISTER: m_FSMstate = FSM_INPUT  ; dwRes = Fsm_Register    (); break; // Register IO callback.
        case FSM_INPUT   : m_FSMstate = FSM_PROCESS; dwRes = Fsm_ReceiveInput(); break; // Read all the input.
        case FSM_PROCESS : m_FSMstate = FSM_OUTPUT ; dwRes = Fsm_Process     (); break; // Process request.
        case FSM_OUTPUT  : m_FSMstate = FSM_DELETE ; dwRes = Fsm_SendOutput  (); break; // Send output.
        case FSM_DELETE  : fClean     = true;        __ULT_FUNC_LEAVE;                  // Delete the request object.
        }
    }

    if(dwRes != HSE_STATUS_SUCCESS &&
       dwRes != HSE_STATUS_PENDING  )
    {
        fClean = true;
    }


    __ULT_FUNC_CLEANUP;

    if(fClean) delete this;

    __ULT_FUNC_EXIT(dwRes);
}


DWORD MPCHttpContext::Fsm_Register()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Fsm_Register");

    DWORD dwRes = HSE_STATUS_SUCCESS;


    if(!m_pECB->ServerSupportFunction( m_pECB->ConnID       ,
                                       HSE_REQ_IO_COMPLETION,
                                       IOCompletion         ,
                                       NULL                 ,
                                       (LPDWORD)this        ))
    {
        dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
    }


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD MPCHttpContext::Fsm_ReceiveInput()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Fsm_ReceiveInput");

    DWORD dwRes = HSE_STATUS_SUCCESS;


    //
    // Alloc a buffer large enough to hold the request data.
    //
    if(FAILED(m_hsInput.SetSize(                  m_pECB->cbTotalBytes ))) { dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE; }
    if(FAILED(m_hsInput.write  ( m_pECB->lpbData, m_pECB->cbAvailable  ))) { dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE; }

    dwRes = AsyncRead();


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD MPCHttpContext::Fsm_Process()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Fsm_Process");

    HRESULT hr;
    DWORD   dwRes = HSE_STATUS_SUCCESS;


    if(m_fRequestProcessed == TRUE) __ULT_FUNC_LEAVE;

    m_hsInput .Rewind();
    m_hsOutput.Reset ();

    if(FAILED(hr = m_mpcsServer->Process( m_fKeepConnection )))
    {
        if(hr == E_PENDING)
        {
            dwRes = HSE_STATUS_PENDING; __ULT_FUNC_LEAVE;
        }

        m_fRequestProcessed = TRUE;

        dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
    }

    m_fRequestProcessed = TRUE;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD MPCHttpContext::Fsm_SendOutput()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Fsm_SendOutput");

    HSE_SEND_HEADER_EX_INFO headerInfo;
    MPC::string             szHeaders;
    DWORD                   dwRes;


    //
    // Built headers.
    //
    SupportAddHeader( szHeaders, "Content-Length", m_hsOutput.GetSize()        );
    SupportAddHeader( szHeaders, "Content-Type"  , "application/uploadlibrary" );

    SupportEndHeaders( szHeaders );

    //
    //  Populate HSE_SEND_HEADER_EX_INFO struct.
    //
    headerInfo.pszStatus = szStatus;
    headerInfo.cchStatus = strlen( szStatus );
    headerInfo.pszHeader = szHeaders.c_str();
    headerInfo.cchHeader = szHeaders.length();
    headerInfo.fKeepConn = TRUE;

    //
    //  Send response.
    //
    if(!m_pECB->ServerSupportFunction(  m_pECB->ConnID                  ,
                                        HSE_REQ_SEND_RESPONSE_HEADER_EX ,
                                       &headerInfo                      ,
                                        NULL                            ,
                                        NULL                            ))
    {
        dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
    }

    //
    // Send data, if present.
    //
    dwRes = AsyncWrite();


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Methods.
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

DWORD MPCHttpContext::Init( /*[in]*/ LPEXTENSION_CONTROL_BLOCK pECB )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Init");

    DWORD        dwRes;
    MPC::wstring szURL;
    MPC::wstring szUser;


    m_pECB = pECB;


    if(FAILED(GetServerVariable( "URL", szURL )))
    {
        szURL = L"DEFAULT";
    }

    if(FAILED(GetServerVariable( "REMOTE_USER", szUser )))
    {
        szUser = L"";
    }


#ifdef DEBUG
    if(pECB->lpszQueryString)
    {
        static MPC::string constNO_RESPONSE_TO_OPEN ( "NO_RESPONSE_TO_OPEN"  );
        static MPC::string constNO_RESPONSE_TO_WRITE( "NO_RESPONSE_TO_WRITE" );
        static MPC::string constRESPONSE_TO_OPEN    ( "RESPONSE_TO_OPEN"     );
        static MPC::string constRESPONSE_TO_WRITE   ( "RESPONSE_TO_WRITE"    );
        static MPC::string constRANDOM_POINTER_ERROR( "RANDOM_POINTER_ERROR" );
        static MPC::string constFIXED_POINTER_ERROR ( "FIXED_POINTER_ERROR"  );


        std::vector<MPC::string> vec;
        std::vector<MPC::string> vec2;
        std::vector<MPC::string> vec3;
        MPC::NocaseCompare       cmp;
        int                      i;

        MPC::SplitAtDelimiter( vec, pECB->lpszQueryString, "&" );

        for(i=0; i<vec.size(); i++)
        {
            MPC::SplitAtDelimiter( vec2, vec[i].c_str(), "=" );

            switch( vec2.size() )
            {
            default:
            case 2 : MPC::SplitAtDelimiter( vec3, vec2[1].c_str(), "," );
            case 1 : break;
            case 0 : continue;
            }

            MPC::string& name = vec2[0];

            if(cmp( name, constNO_RESPONSE_TO_OPEN ))
            {
                m_Debug_NO_RESPONSE_TO_OPEN = true;
            }
            else if(cmp( name, constNO_RESPONSE_TO_WRITE ))
            {
                m_Debug_NO_RESPONSE_TO_WRITE = true;
            }
            else if(cmp( name, constRESPONSE_TO_OPEN ))
            {
                switch( vec3.size() )
                {
                case 3 : m_Debug_RESPONSE_TO_OPEN_protocol = atol( vec3[2].c_str() );
                case 2 : m_Debug_RESPONSE_TO_OPEN_position = atol( vec3[1].c_str() );
                case 1 : m_Debug_RESPONSE_TO_OPEN_response = atol( vec3[0].c_str() );
                         m_Debug_RESPONSE_TO_OPEN          = true;
                }
            }
            else if(cmp( name, constRESPONSE_TO_WRITE ))
            {
                switch( vec3.size() )
                {
                case 3 : m_Debug_RESPONSE_TO_WRITE_protocol = atol( vec3[2].c_str() );
                case 2 : m_Debug_RESPONSE_TO_WRITE_position = atol( vec3[1].c_str() );
                case 1 : m_Debug_RESPONSE_TO_WRITE_response = atol( vec3[0].c_str() );
                         m_Debug_RESPONSE_TO_WRITE          = true;
                }
            }
            else if(cmp( name, constRANDOM_POINTER_ERROR ))
            {
                switch( vec3.size() )
                {
                case 2: m_Debug_RANDOM_POINTER_ERROR_pos_high = atol( vec3[1].c_str() );
                        m_Debug_RANDOM_POINTER_ERROR_pos_low  = atol( vec3[0].c_str() );
                        m_Debug_RANDOM_POINTER_ERROR          = true;
                }
            }
            else if(cmp( name, constFIXED_POINTER_ERROR ))
            {
                switch( vec3.size() )
                {
                case 1 : m_Debug_FIXED_POINTER_ERROR_pos = atol( vec3[0].c_str() );
                         m_Debug_FIXED_POINTER_ERROR     = true;
                }
            }
        }
    }
#endif

    m_mpcsServer = new MPCServer( this, szURL.c_str(), szUser.c_str() );

    if(m_mpcsServer == NULL)
    {
        dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
    }

    dwRes = AdvanceFSM();


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}


HRESULT MPCHttpContext::GetServerVariable( /*[in]*/ LPCSTR szVar, /*[out]*/ MPC::wstring& szValue )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::GetServerVariable");

    USES_CONVERSION;

    HRESULT hr;
    DWORD   dwRes;
    LPSTR   szData = NULL;
    DWORD   dwSize = 0;


    m_pECB->GetServerVariable( m_pECB->ConnID, (LPSTR)szVar, NULL, &dwSize );

    dwRes = ::GetLastError();
    if(dwRes != ERROR_INSUFFICIENT_BUFFER)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    __MPC_EXIT_IF_ALLOC_FAILS(hr, szData, new CHAR[dwSize+1]);

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, m_pECB->GetServerVariable( m_pECB->ConnID, (LPSTR)szVar, szData, &dwSize ));

    szValue = A2W( szData );
    hr      = S_OK;


    __ULT_FUNC_CLEANUP;

    if(szData) delete [] szData;

    __ULT_FUNC_EXIT(hr);

}
HRESULT MPCHttpContext::GetRequestSize( /*[out]*/ DWORD& dwCount )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::GetRequestSize");

    HRESULT hr;


    dwCount = m_hsInput.GetSize();
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCHttpContext::CheckDataAvailable( /*[in] */ DWORD dwCount    ,
                                            /*[out]*/ bool& fAvailable )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::CheckDataAvailable");

    HRESULT hr;


    fAvailable = (m_hsInput.GetAvailableForRead() >= dwCount);
    hr         = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCHttpContext::Read( /*[in]*/ void* pBuffer ,
                              /*[in]*/ DWORD dwCount )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Read");

    HRESULT hr = m_hsInput.read( pBuffer, dwCount );


    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCHttpContext::Write( /*[in]*/ const void* pBuffer ,
                               /*[in]*/ DWORD       dwCount )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Write");

    HRESULT hr = m_hsOutput.write( pBuffer, dwCount );


    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\purgeengine.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    PurgeEngine.h

Abstract:
    This file contains the declaration of the MPCPurgeEngine class,
    that controls the cleaning of the temporary directories.

Revision History:
    Davide Massarenti   (Dmassare)  07/12/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___PURGEENGINE_H___)
#define __INCLUDED___ULSERVER___PURGEENGINE_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


struct MPCPurge_SessionSummary // Hungarian: pss
{
    MPC::wstring m_szJobID;
    double       m_dblLastModified;
    DWORD        m_dwCurrentSize;
};

struct MPCPurge_ClientSummary // Hungarian: pcs
{
    typedef std::list<MPCPurge_SessionSummary> List;
    typedef List::iterator                     Iter;
    typedef List::const_iterator               IterConst;

    MPC::wstring m_szPath;
    List         m_lstSessions;
    DWORD        m_dwFileSize;
    double       m_dblLastModified;


    MPCPurge_ClientSummary( /*[in]*/ const MPC::wstring& szPath );

    bool GetOldestSession( /*[out]*/ Iter& itSession );
};

class MPCPurgeEngine
{
    typedef std::list<MPCPurge_ClientSummary> List;
    typedef List::iterator                    Iter;
    typedef List::const_iterator              IterConst;

    MPC::wstring m_szURL;
	MPCServer*   m_mpcsServer;
    DWORD        m_dwQueueSizeMax;
    DWORD        m_dwQueueSizeThreshold;
    DWORD        m_dwMaximumJobAge;
    double       m_dblMaximumJobAge;

    List         m_lstClients;


    HRESULT AnalyzeFolders    ( /*[in]*/ MPC::FileSystemObject* fso, /*[in/out]*/ DWORD& dwTotalSize );
    HRESULT AddClient         ( /*[in]*/ const MPC::wstring& szPath, /*[in/out]*/ DWORD& dwTotalSize );
    HRESULT RemoveOldJobs     (                                      /*[in/out]*/ DWORD& dwTotalSize );
    HRESULT RemoveOldestJob   (                                      /*[in/out]*/ DWORD& dwTotalSize );
    HRESULT RemoveEmptyClients(                                      /*[in/out]*/ DWORD& dwTotalSize );

    HRESULT RemoveSession  ( /*[in]*/     MPCClient&                    mpccClient   ,
                             /*[in/out]*/ bool&                         fInitialized ,
                             /*[in]*/     Iter                          itClient     ,
                             /*[in]*/     MPCPurge_ClientSummary::Iter& itSession    ,
                             /*[in/out]*/ DWORD&                        dwTotalSize  );

public:
    HRESULT Process();
};


#endif // !defined(__INCLUDED___ULSERVER___PURGEENGINE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\serializer.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Serializer.h

Abstract:
    This file contains the declaration of some Serializer interfaces,
    allowing to use the FileSystem or the HTTP channel in a similar way.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___SERIALIZER_H___)
#define __INCLUDED___ULSERVER___SERIALIZER_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class MPCSerializerHttp : public MPC::Serializer
{
    MPCHttpContext* m_context;

    //////////////////////////////////////////////////////////////////

public:
    MPCSerializerHttp( /*[in]*/ MPCHttpContext* context );

    virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL );
    virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 );
};


#endif // !defined(__INCLUDED___ULSERVER___SERIALIZER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\serializer.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Serializer.cpp

Abstract:
    This file contains the implementation of some Serializer interfaces,
    allowing to use the FileSystem or the HTTP channel in a similar way.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"
#include "Serializer.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

MPCSerializerHttp::MPCSerializerHttp( /*[in]*/ MPCHttpContext* context )
{
    __ULT_FUNC_ENTRY( "MPCSerializerHttp::MPCSerializerHttp" );


    m_context = context;
}

//////////////////////////////////////////////////////////////////////
// Methods.
//////////////////////////////////////////////////////////////////////

HRESULT MPCSerializerHttp::read( /*[in]*/  void*   pBuf   ,
								 /*[in]*/  DWORD   dwLen  ,
								 /*[out]*/ DWORD* pdwRead )
{
    __ULT_FUNC_ENTRY("MPCSerializerHttp::read");


    HRESULT hr = m_context->Read( pBuf, dwLen );

	if(pdwRead) *pdwRead = dwLen;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSerializerHttp::write( /*[in]*/ const void* pBuf  ,
                                  /*[in]*/ DWORD       dwLen )
{
    __ULT_FUNC_ENTRY("MPCSerializerHttp::write");


    HRESULT hr = m_context->Write( pBuf, dwLen );


    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\server.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Server.cpp

Abstract:
    This file contains the implementation of the MPCServer class,
    that controls the overall interaction between client and server.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

MPCServer::MPCServer( /*[in]*/ MPCHttpContext* hcCallback, /*[in]*/ LPCWSTR szURL, /*[in]*/ LPCWSTR szUser )
    : m_SelfCOM         ( this                                ),
      m_crClientRequest ( 0                                   ),
      m_srServerResponse( UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV ) // Prepare default response protocol.
{
    __ULT_FUNC_ENTRY("MPCServer::MPCServer");

    bool fFound;

    m_szURL          = SAFEWSTR( szURL  ); // MPC::wstring                  m_szURL;
    m_szUser         = SAFEWSTR( szUser ); // MPC::wstring                  m_szUser;
    m_isapiInstance  = NULL;               // CISAPIinstance*               m_isapiInstance;
    m_flLogHandle    = NULL;               // MPC::FileLog*                 m_flLogHandle;
                                           //
    m_hcCallback     = hcCallback;         // MPCHttpContext*               m_hcCallback;
    m_mpccClient     = NULL;               // MPCClient*                    m_mpccClient;
                                           //
                                           // UploadLibrary::ClientRequest  m_crClientRequest;
                                           // UploadLibrary::ServerResponse m_srServerResponse;
                                           //
                                           // MPC::Serializer_Memory        m_streamResponseData;
                                           // MPCServerCOMWrapper           m_SelfCOM;
    m_Session        = NULL;               // MPCSession*            		m_Session;
    m_customProvider = NULL;               // IULProvider*                  m_customProvider;
	m_fTerminated    = false;              // bool                          m_fTerminated;


    if(SUCCEEDED(::Config_GetInstance( m_szURL, m_isapiInstance, fFound )))
    {
        if(fFound)
        {
            m_isapiInstance->get_LogHandle( m_flLogHandle );
        }
    }
}

MPCServer::~MPCServer()
{
    __ULT_FUNC_ENTRY("MPCServer::~MPCServer");


    ReleaseClient();
}

IULServer* MPCServer::COM() { return &m_SelfCOM; }

//////////////////////////////////////////////////////////////////////
// Methods.
//////////////////////////////////////////////////////////////////////

void MPCServer::getURL ( MPC::wstring& szURL  ) { szURL  = m_szURL ; }
void MPCServer::getUser( MPC::wstring& szUser ) { szUser = m_szUser; }

CISAPIinstance* MPCServer::getInstance() { return m_isapiInstance;  }
MPC::FileLog*   MPCServer::getFileLog () { return m_flLogHandle  ;  }

//////////////////////////////////////////////////////////////////////

HRESULT MPCServer::Process( BOOL& fKeepAlive )
{
    __ULT_FUNC_ENTRY("MPCServer::Process");

    MPC::Serializer& streamConn = MPCSerializerHttp( m_hcCallback );
    HRESULT          hr;

    m_fKeepAlive = TRUE;

    try
    {
#ifdef DEBUG
        if(m_hcCallback->m_Debug_FIXED_POINTER_ERROR)
        {
            m_srServerResponse.dwPosition = m_hcCallback->m_Debug_FIXED_POINTER_ERROR_pos;

			SetResponse( UploadLibrary::UL_RESPONSE_SKIPPED, TRUE );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
#endif

        //
        // Enforce maximum request size.
        //
        {
            DWORD dwMaximumPacketSize;
            DWORD dwCount;


            __MPC_EXIT_IF_METHOD_FAILS(hr, ::Config_GetMaximumPacketSize( m_szURL, dwMaximumPacketSize ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_hcCallback->GetRequestSize( dwCount ));

            if(dwCount > dwMaximumPacketSize)
            {
                WCHAR rgSize[16]; swprintf( rgSize, L"%d", dwCount );

                (void)g_NTEvents.LogEvent( EVENTLOG_WARNING_TYPE, PCHUL_WARN_PACKET_SIZE,
                                           m_szURL.c_str(), // %1 = SERVER
                                           rgSize         , // %2 = SIZE
                                           NULL           );

                if(m_flLogHandle)
                {
                    m_flLogHandle->LogRecord( L"ERROR     | Received a packet too large: %ld, limit %ld", dwCount, dwMaximumPacketSize );
                }


				SetResponse( UploadLibrary::UL_RESPONSE_BAD_REQUEST );
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
            }
        }


        //
        // Read request.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamConn >> m_crClientRequest);

        if(m_srServerResponse.MatchVersion( m_crClientRequest ) == false)
        {
            if(m_flLogHandle)
            {
                m_flLogHandle->LogRecord( L"ERROR     | Received an invalid packet: SIG:%08lx VER:%08lx", m_crClientRequest.rhProlog.dwSignature, m_crClientRequest.rhProlog.dwVersion );
            }

			SetResponse( UploadLibrary::UL_RESPONSE_BAD_REQUEST );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        if(FAILED(hr = GrabClient()))
        {
            //
            // If another process is handling the file, reply with warning BUSY.
            //
            if(hr == HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION ))
            {
				SetResponse( UploadLibrary::UL_RESPONSE_BUSY );

                hr = S_OK;
            }

            __ULT_FUNC_LEAVE;
        }


        if(m_crClientRequest.dwCommand == UploadLibrary::UL_COMMAND_OPENSESSION)
        {
            hr = HandleCommand_OpenSession ( streamConn );
        }
        else if(m_crClientRequest.dwCommand == UploadLibrary::UL_COMMAND_WRITESESSION)
        {
            hr = HandleCommand_WriteSession( streamConn );
        }
        else
        {
			SetResponse( UploadLibrary::UL_RESPONSE_BAD_REQUEST );
        }
    }
    catch(...)
    {
        __ULT_TRACE_ERROR( UPLOADLIBID, "Upload Server raised an exception. Gracefully exiting..." );

        MPC::wstring szID;

        if(m_mpccClient)
        {
            (void)m_mpccClient->FormatID( szID );
        }
        else
        {
            szID = L"<UNKNOWN>";
        }

        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_EXCEPTION,
                                   m_szURL.c_str(), // %1 = SERVER
                                   szID   .c_str(), // %2 = CLIENT
                                   NULL           );

        //
        // Something ugly happened, reply with SERVER_BUSY...
        //
        SetResponse( UploadLibrary::UL_RESPONSE_BUSY );
    }


    __ULT_FUNC_CLEANUP;


    if(hr != S_FALSE   &&
       hr != E_PENDING  )
    {
        MPC::Serializer_Memory streamRes;

        streamRes << m_srServerResponse;

        m_hcCallback->Write( streamRes           .GetData(), streamRes           .GetSize() );
        m_hcCallback->Write( m_streamResponseData.GetData(), m_streamResponseData.GetSize() );
    }

    //
    // Never return a real failure!
    //
    if(hr != E_PENDING) hr = S_OK;

    ReleaseClient();

    fKeepAlive = m_fKeepAlive;

    __ULT_FUNC_EXIT(hr);
}

//////////////////////////////////////////////////////////////////////
// Helpers.
//////////////////////////////////////////////////////////////////////

HRESULT MPCServer::GrabClient()
{
    __ULT_FUNC_ENTRY("MPCServer::GrabClient");

    HRESULT hr;


    if(m_mpccClient)
    {
        if(*m_mpccClient == m_crClientRequest.sigClient)
        {
            //
            // It's for the same client, dont' do anything...
            //
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, ReleaseClient());
    }


    //
    // Get instance's settings and create client object.
    //
    m_mpccClient = new MPCClient( this, m_crClientRequest.sigClient );


    //
    // Check authenticity of ID.
    //
    if(m_mpccClient->CheckSignature() == false)
    {
        SetResponse( UploadLibrary::UL_RESPONSE_DENIED );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    if(FAILED(hr = m_mpccClient->InitFromDisk( true )))
    {
        if(hr == HRESULT_FROM_WIN32( ERROR_DISK_FULL ))
        {
            SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );

            hr = S_OK;
        }

        __ULT_FUNC_LEAVE;
    }


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::ReleaseClient()
{
    __ULT_FUNC_ENTRY("MPCServer::ReleaseClient");


    HRESULT hr;


    (void)CustomProvider_Release();


    if(m_mpccClient)
    {
        hr = m_mpccClient->SyncToDisk();

        delete m_mpccClient; m_mpccClient = NULL;

        if(FAILED(hr)) __ULT_FUNC_LEAVE;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCServer::HandleCommand_OpenSession( /*[in] */ MPC::Serializer& streamConn )
{
    __ULT_FUNC_ENTRY("MPCServer::HandleCommand_OpenSession");

    UploadLibrary::ClientRequest_OpenSession crosReq( 0 );
    MPCClient::Iter                          it;
    HRESULT                                  hr;
    bool                                     fServerBusy;
    bool                                     fAccessDenied;
    bool                                     fExceeded;

    crosReq.crHeader = m_crClientRequest;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamConn >> crosReq );


#ifdef DEBUG
    if(m_hcCallback->m_Debug_NO_RESPONSE_TO_OPEN)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    if(m_hcCallback->m_Debug_RESPONSE_TO_OPEN)
    {
        m_srServerResponse.dwPosition         = m_hcCallback->m_Debug_RESPONSE_TO_OPEN_position;
        m_srServerResponse.rhProlog.dwVersion = m_hcCallback->m_Debug_RESPONSE_TO_OPEN_protocol;

        SetResponse( m_hcCallback->m_Debug_RESPONSE_TO_OPEN_response );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }
#endif

    //
    // Reject any request whose length is zero.
    //
    if(crosReq.dwSize         == 0 ||
       crosReq.dwSizeOriginal == 0  )
    {
        SetResponse( UploadLibrary::UL_RESPONSE_BAD_REQUEST );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    if(m_mpccClient->Find( crosReq.szJobID, it ))
    {
        if(it->get_Committed() == true)
        {
            if(it->MatchRequest( crosReq ) == true)
            {
                SetResponse( UploadLibrary::UL_RESPONSE_COMMITTED, TRUE );
            }
            else
            {
                SetResponse( UploadLibrary::UL_RESPONSE_EXISTS );
            }
        }
        else
        {
            SetResponse( UploadLibrary::UL_RESPONSE_SKIPPED, TRUE );
        }
    }
    else
    {
        bool fPassed;

        if(m_flLogHandle)
        {
            m_flLogHandle->LogRecord( L"PROGRESS  | Created new session: '%s' (%s)", crosReq.szJobID.c_str(), crosReq.szProviderID.c_str() );
        }


        it = m_mpccClient->NewSession( crosReq );

        if(SUCCEEDED(hr = it->Validate( false, fPassed )) && fPassed)
        {
            if(SUCCEEDED(hr = m_mpccClient->CheckQuotas( *it, fServerBusy, fAccessDenied, fExceeded  )))
            {
                if(fServerBusy == true)
                {
                    SetResponse( UploadLibrary::UL_RESPONSE_BUSY );
                }
                else if(fAccessDenied == true)
                {
                    SetResponse( UploadLibrary::UL_RESPONSE_DENIED );
                }
                else if(fExceeded == true)
                {
                    SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );
                }
                else
                {
                    SetResponse( UploadLibrary::UL_RESPONSE_SUCCESS, TRUE );
                }
            }
        }

        if(FAILED(hr)         ||
           fPassed   == false ||
           fExceeded == true   )
        {
            m_mpccClient->Erase( it );

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_Create( *it ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_ValidateClient());
	if(m_fTerminated) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);


    it->get_CurrentSize( m_srServerResponse.dwPosition );
    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::HandleCommand_WriteSession( /*[in] */ MPC::Serializer& streamConn )
{
    __ULT_FUNC_ENTRY("MPCServer::HandleCommand_WriteSession");

    HRESULT                                   hr;
    UploadLibrary::ClientRequest_WriteSession crwsReq( 0 );
    MPCClient::Iter                           it;
    DWORD                                     dwCurrentSize;
    DWORD                                     dwTotalSize;
    bool                                      fServerBusy;
    bool                                      fAccessDenied;
    bool                                      fExceeded;
    bool                                      fAvailable;


    crwsReq.crHeader = m_crClientRequest;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamConn >> crwsReq);


#ifdef DEBUG
    if(m_hcCallback->m_Debug_NO_RESPONSE_TO_WRITE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    if(m_hcCallback->m_Debug_RESPONSE_TO_WRITE)
    {
        m_srServerResponse.dwPosition         = m_hcCallback->m_Debug_RESPONSE_TO_WRITE_position;
        m_srServerResponse.rhProlog.dwVersion = m_hcCallback->m_Debug_RESPONSE_TO_WRITE_protocol;

        SetResponse( m_hcCallback->m_Debug_RESPONSE_TO_WRITE_response );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }
#endif


    //
    // Session couldn't be found, reply with error NOTACTIVE.
    //
    if(m_mpccClient->Find( crwsReq.szJobID, it ) == false)
    {
        SetResponse( UploadLibrary::UL_RESPONSE_NOTACTIVE );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_Create( *it ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_ValidateClient());
	if(m_fTerminated) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);


    if(SUCCEEDED(hr = m_mpccClient->CheckQuotas( *it, fServerBusy, fAccessDenied, fExceeded )))
    {
        if(fServerBusy == true)
        {
            SetResponse( UploadLibrary::UL_RESPONSE_BUSY );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        if(fAccessDenied == true)
        {
            SetResponse( UploadLibrary::UL_RESPONSE_DENIED );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        if(fExceeded == true)
        {
            SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }


    //
    // Session has already being finished, reply with warning COMMITTED.
    //
    if(it->get_Committed())
    {
        SetResponse( UploadLibrary::UL_RESPONSE_COMMITTED, TRUE );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


#ifdef DEBUG
    if(m_hcCallback->m_Debug_RANDOM_POINTER_ERROR)
    {
        double pick = (double)rand() / (double)RAND_MAX;

        m_srServerResponse.dwPosition =  m_hcCallback->m_Debug_RANDOM_POINTER_ERROR_pos_low +
                                        (m_hcCallback->m_Debug_RANDOM_POINTER_ERROR_pos_high - m_hcCallback->m_Debug_RANDOM_POINTER_ERROR_pos_low) * pick;

        SetResponse( UploadLibrary::UL_RESPONSE_SKIPPED, TRUE );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }
#endif

    it->get_CurrentSize( dwCurrentSize );
    it->get_TotalSize  ( dwTotalSize   );

    //
    // If request offset and file size don't match, reply with warning SKIPPED.
    //
    if(dwCurrentSize != crwsReq.dwOffset)
    {
        if(m_flLogHandle)
        {
            m_flLogHandle->LogRecord( L"WARN      | Resync the client to %ld", dwCurrentSize );
        }

        m_srServerResponse.dwPosition = dwCurrentSize;

        SetResponse( UploadLibrary::UL_RESPONSE_SKIPPED, TRUE );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // Trim request size (don't overwrite past the declared file size).
    //
    crwsReq.dwSize = min( dwTotalSize - dwCurrentSize, crwsReq.dwSize );

    //
    // If data is not all available, wait.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_hcCallback->CheckDataAvailable( crwsReq.dwSize, fAvailable ));
    if(fAvailable == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_PENDING);
    }


    if(m_flLogHandle)
    {
        m_flLogHandle->LogRecord( L"PROGRESS  | Writing chunk: %ld bytes at %ld", crwsReq.dwSize, crwsReq.dwOffset );
    }


    //
    // Try to add the chunk to the file. If it fails due to low free disk space, reply with QUOTA_EXCEEDED.
    //
    {
        MPC::Serializer_Text streamText( streamConn );
        MPC::Serializer*     pstream = UploadLibrary::SelectStream( streamConn, streamText );

        if(FAILED(hr = m_mpccClient->AppendData( *it, *pstream, crwsReq.dwSize )))
        {
            if(hr == HRESULT_FROM_WIN32( ERROR_DISK_FULL ))
            {
                SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );

                hr = S_OK;
            }

            __ULT_FUNC_LEAVE;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_DataAvailable());
		if(m_fTerminated) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // Check for end of transmission.
    //
    it->get_CurrentSize( dwCurrentSize );
    if(dwCurrentSize >= dwTotalSize)
    {
        bool fMatch;

        __MPC_EXIT_IF_METHOD_FAILS(hr, it->CompareCRC( fMatch ));

        if(fMatch == false)
        {
            if(m_flLogHandle)
            {
                m_flLogHandle->LogRecord( L"WARN      | Wrong CRC, restarting..." );
            }

            //
            // The CRC is wrong, so remove the session completely...
            //
            (void)it->RemoveFile();

            m_mpccClient->Erase( it );

            SetResponse( UploadLibrary::UL_RESPONSE_BADCRC );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
        else
        {
            if(m_flLogHandle)
            {
                m_flLogHandle->LogRecord( L"PROGRESS  | Transfer complete" );
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_TransferComplete());
			if(m_fTerminated) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }
    else
    {
        SetResponse( UploadLibrary::UL_RESPONSE_SUCCESS, TRUE );
    }

    it->get_CurrentSize( m_srServerResponse.dwPosition );
    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

void MPCServer::SetResponse( /*[in]*/ DWORD fResponse, /*[in]*/ BOOL fKeepAlive )
{
	m_srServerResponse.fResponse = fResponse;
	m_fKeepAlive                 = fKeepAlive;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPCServer::CustomProvider_Create( /*[in]*/ MPCSession& mpcsSession )
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_Create");

    HRESULT hr;


    if(m_customProvider == NULL)
    {
        CISAPIprovider* isapiProvider;
        bool            fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, mpcsSession.GetProvider( isapiProvider, fFound ));
        if(fFound)
        {
            MPC::wstring szProviderGUID;
            CLSID        guid;

            __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_ProviderGUID( szProviderGUID ));

            if(szProviderGUID.size() && SUCCEEDED(::CLSIDFromString( (LPOLESTR)szProviderGUID.c_str(), &guid )))
            {
                hr = ::CoCreateInstance( guid, NULL, CLSCTX_INPROC_SERVER, IID_IULProvider, (void**)&m_customProvider );

                if(FAILED(hr))
                {
					m_customProvider = NULL;
                }
            }
        }
    }

	m_Session = &mpcsSession;
    hr        = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::CustomProvider_ValidateClient()
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_ValidateClient");

    HRESULT hr;
    bool    fMatch;


    //
    // Before doing anything, check client identity.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Session->CheckUser( m_szUser, fMatch ))
    if(fMatch == false)
    {
		SetResponse( UploadLibrary::UL_RESPONSE_NOT_AUTHORIZED );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if(m_customProvider)
    {
        hr = m_customProvider->ValidateClient( COM(), m_Session->COM() );

        if(FAILED(hr) && hr != E_NOTIMPL) __ULT_FUNC_LEAVE;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT MPCServer::CustomProvider_DataAvailable()
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_DataAvailable");

    HRESULT hr;


    if(m_customProvider)
    {
        hr = m_customProvider->DataAvailable( COM(), m_Session->COM() );

        if(FAILED(hr) && hr != E_NOTIMPL) __ULT_FUNC_LEAVE;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::CustomProvider_TransferComplete()
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_TransferComplete");

    HRESULT hr;


	//
	// Set the commit flag, but only move the file if we don't have a custom provider.
	//
	if(FAILED(hr = m_Session->put_Committed( true, m_customProvider ? false : true )))
	{
		if(hr == HRESULT_FROM_WIN32( ERROR_DISK_FULL ))
		{
			SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );

			hr = S_OK;
		}

		__ULT_FUNC_LEAVE;
	}


	SetResponse( UploadLibrary::UL_RESPONSE_COMMITTED, TRUE );


    if(m_customProvider)
    {
        hr = m_customProvider->TransferComplete( COM(), m_Session->COM() );

        if(FAILED(hr) && hr != E_NOTIMPL) __ULT_FUNC_LEAVE;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::CustomProvider_SetResponse( /*[in]*/ IStream* data )
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_SetResponse");

    HRESULT hr;


	//
	// Set the commit flag, but only move the file if we don't have a custom provider.
	//
	if(FAILED(hr = m_Session->put_Committed( true, m_customProvider ? false : true )))
	{
		if(hr == HRESULT_FROM_WIN32( ERROR_DISK_FULL ))
		{
			SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );

			hr = S_OK;
		}

		__ULT_FUNC_LEAVE;
	}


	SetResponse( UploadLibrary::UL_RESPONSE_COMMITTED, TRUE );


    if(data)
    {
		BYTE  buf[512];
		DWORD dwRead;

		while(1)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, data->Read( buf, sizeof(buf), &dwRead ));

			if(dwRead == 0) break;

			__MPC_EXIT_IF_METHOD_FAILS(hr, m_streamResponseData.write( buf, dwRead ));
		}
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT MPCServer::CustomProvider_Release()
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_Release");

    HRESULT hr;


    if(m_customProvider)
    {
		if(m_fTerminated)
		{
			if(m_Session) m_Session->RemoveFile();
		}

        m_customProvider->Release();
		m_customProvider = NULL;
    }

	m_Session = NULL;

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Include file for standard system include files or project specific include
    files that are used frequently, but are changed infrequently

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_

#include <windows.h>
#include <atlbase.h>

extern CComModule _Module;

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <httpext.h>
#include <lzexpand.h>

#include <UploadLibrary.h>

#include <UploadLibraryTrace.h>
#include <UploadLibraryISAPI.h>

#include <MPC_Main.h>
#include <MPC_Utils.h>
#include <MPC_Logging.h>
#include <MPC_COM.h>

// For NT Event messages.
#include "UploadServerMsg.h"

#include "HttpContext.h"

#include "Serializer.h"
#include "Persist.h"
#include "Config.h"
#include "Session.h"
#include "Client.h"
#include "Server.h"
#include "Wrapper.h"
#include "PurgeEngine.h"


#define DISKSPACE_SAFETYMARGIN (100*1024)


extern HANDLE       g_Heap;
extern CISAPIconfig g_Config;
extern MPC::NTEvent g_NTEvents;


#endif // !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\server.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Server.h

Abstract:
    This file contains the declaration of the MPCServer class,
    that controls the overall interaction between client and server.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___SERVER_H___)
#define __INCLUDED___ULSERVER___SERVER_H___


#include <Wrapper.h>


class MPCServer // Hungarian: mpcs
{
	friend class MPCServerCOMWrapper;
	friend class MPCSessionCOMWrapper;

	////////////////////

    MPC::wstring    	   		  m_szURL;
    MPC::wstring    	   		  m_szUser;
	CISAPIinstance* 	   		  m_isapiInstance;
	MPC::FileLog*   	   		  m_flLogHandle;
	BOOL            	   		  m_fKeepAlive;
	   		  
    MPCHttpContext* 	   		  m_hcCallback;
    MPCClient*      	   		  m_mpccClient;

    UploadLibrary::ClientRequest  m_crClientRequest;
    UploadLibrary::ServerResponse m_srServerResponse;

	MPC::Serializer_Memory 		  m_streamResponseData;
	MPCServerCOMWrapper    		  m_SelfCOM;
	MPCSession*            		  m_Session;
	IULProvider*           		  m_customProvider;
	bool                          m_fTerminated;

	////////////////////////////////////////

    HRESULT GrabClient   ();
    HRESULT ReleaseClient();


    HRESULT HandleCommand_OpenSession ( /*[in] */ MPC::Serializer& streamConn );
    HRESULT HandleCommand_WriteSession( /*[in] */ MPC::Serializer& streamConn );

	void SetResponse( /*[in]*/ DWORD fResponse, /*[in]*/ BOOL fKeepAlive = FALSE );

	////////////////////////////////////////

	HRESULT CustomProvider_Create          ( /*[in]*/ MPCSession& mpcsSession );
	HRESULT CustomProvider_ValidateClient  (                                  );
	HRESULT CustomProvider_DataAvailable   (                                  );
	HRESULT CustomProvider_TransferComplete(                                  );
	HRESULT CustomProvider_SetResponse     ( /*[in]*/ IStream*    data        );
	HRESULT CustomProvider_Release         (                                  );

    //////////////////////////////////////////////////////////////////

public:
    MPCServer( /*[in]*/ MPCHttpContext* hcCallback, /*[in]*/ LPCWSTR szURL, /*[in]*/ LPCWSTR szUser );
    virtual ~MPCServer();

	IULServer* COM();

    /////////////////////////////////////////////

    HRESULT Process( BOOL& fKeepAlive );

    /////////////////////////////////////////////

	void getURL ( MPC::wstring& szURL  );
	void getUser( MPC::wstring& szUser );

	CISAPIinstance* getInstance();
	MPC::FileLog*   getFileLog ();
};

#endif // !defined(__INCLUDED___ULSERVER___SERVER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\session.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Session.cpp

Abstract:
    This file contains the implementation of the MPCSession class,
    that describes the state of a transfer.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"


#define BUFFER_SIZE_FILECOPY (512)


static void EncodeBuffer( /*[in]*/ LPWSTR  rgBufOut ,
                          /*[in]*/ LPCWSTR rgBufIn  ,
                          /*[in]*/ DWORD   iSize    )
{
    int   iLen;
    WCHAR c;

    iLen     = wcslen( rgBufOut );
    iSize    -= iLen + 1;
    rgBufOut += iLen;


    while(iSize > 0 && (c = *rgBufIn++))
    {
        if(_istalnum( c ))
        {
            if(iSize > 1)
            {
                *rgBufOut = c;

                rgBufOut += 1;
                iSize    -= 1;
            }
        }
        else
        {
            if(iSize > 3)
            {
                swprintf( rgBufOut, L"%%%02x", (int)c );

                rgBufOut += 3;
                iSize    -= 3;
            }
        }
    }

    *rgBufOut = 0;
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Construction/Destruction
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

MPCSession::MPCSession( /*[in]*/ MPCClient* mpccParent ) : m_SelfCOM( this )
{
    __ULT_FUNC_ENTRY("MPCSession::MPCSession");

                                   // MPCSessionCOMWrapper m_SelfCOM;
    m_mpccParent     = mpccParent; // MPCClient*           m_mpccParent;
    m_dwID           = 0;          // DWORD                m_dwID;
                                   //
                                   // MPC::wstring         m_szJobID;
                                   // MPC::wstring         m_szProviderID;
                                   // MPC::wstring         m_szUsername;
                                   //
    m_dwTotalSize    = 0;          // DWORD                m_dwTotalSize;
    m_dwOriginalSize = 0;          // DWORD                m_dwOriginalSize;
    m_dwCRC          = 0;          // DWORD                m_dwCRC;
    m_fCompressed    = false;      // bool                 m_fCompressed;
                                   //
    m_dwCurrentSize  = 0;          // DWORD                m_dwCurrentSize;
                                   // SYSTEMTIME           m_stLastModified;
    m_fCommitted     = false;      // bool                 m_fCommitted;
                                   //
    m_dwProviderData = 0;          // DWORD                m_dwProviderData;
                                   //
    m_fDirty         = false;      // mutable bool         m_fDirty;
}

MPCSession::MPCSession( /*[in]*/ MPCClient*                                      mpccParent ,
                        /*[in]*/ const UploadLibrary::ClientRequest_OpenSession& crosReq    ,
                        /*[in]*/ DWORD                                           dwID       ) : m_SelfCOM( this )
{
    __ULT_FUNC_ENTRY("MPCSession::MPCSession");

                                                     // MPCSessionCOMWrapper m_SelfCOM;
    m_mpccParent     = mpccParent;                   // MPCClient*           m_mpccParent;
    m_dwID           = dwID;                         // DWORD                m_dwID;
                                                     //
    m_szJobID        = crosReq.szJobID;              // MPC::wstring         m_szJobID;
    m_szProviderID   = crosReq.szProviderID;         // MPC::wstring         m_szProviderID;
    m_szUsername     = crosReq.szUsername;           // MPC::wstring         m_szUsername;
                                                     //
    m_dwTotalSize    = crosReq.dwSize;               // DWORD                m_dwTotalSize;
    m_dwOriginalSize = crosReq.dwSizeOriginal;       // DWORD                m_dwOriginalSize;
    m_dwCRC          = crosReq.dwCRC;                // DWORD                m_dwCRC;
    m_fCompressed    = crosReq.fCompressed;          // bool                 m_fCompressed;
                                                     //
    m_dwCurrentSize  = 0;                            // DWORD                m_dwCurrentSize;
    m_fCommitted     = false;                        // SYSTEMTIME           m_stLastModified;
    ::GetSystemTime( &m_stLastModified );            // bool                 m_fCommitted;
                                                     //
    m_dwProviderData = 0;                            // DWORD                m_dwProviderData;
                                                     //
    m_fDirty         = true;                         // mutable bool         m_fDirty;
}

MPCSession::MPCSession( /*[in]*/ const MPCSession& sess ) : m_SelfCOM( this )
{
    __ULT_FUNC_ENTRY("MPCSession::MPCSession");

                                               // MPCSessionCOMWrapper m_SelfCOM;
    m_mpccParent      = sess.m_mpccParent;     // MPCClient*           m_mpccParent;
    m_dwID            = sess.m_dwID;           // DWORD                m_dwID;
                                               //
    m_szJobID         = sess.m_szJobID;        // MPC::wstring         m_szJobID;
    m_szProviderID    = sess.m_szProviderID;   // MPC::wstring         m_szProviderID;
    m_szUsername      = sess.m_szUsername;     // MPC::wstring         m_szUsername;
                                               //
    m_dwTotalSize     = sess.m_dwTotalSize;    // DWORD                m_dwTotalSize;
    m_dwOriginalSize  = sess.m_dwOriginalSize; // DWORD                m_dwOriginalSize;
    m_dwCRC           = sess.m_dwCRC;          // DWORD                m_dwCRC;
    m_fCompressed     = sess.m_fCompressed;    // bool                 m_fCompressed;
                                               //
    m_dwCurrentSize   = sess.m_dwCurrentSize;  // DWORD                m_dwCurrentSize;
    m_stLastModified  = sess.m_stLastModified; // SYSTEMTIME           m_stLastModified;
    m_fCommitted      = sess.m_fCommitted;     // bool                 m_fCommitted;
                                               //
    m_dwProviderData  = sess.m_dwProviderData; // DWORD                m_dwProviderData;
                                               //
    m_fDirty          = sess.m_fDirty;         // mutable bool         m_fDirty;
}

MPCSession::~MPCSession()
{
    __ULT_FUNC_ENTRY("MPCSession::~MPCSession");
}

MPCClient* MPCSession::GetClient() { return m_mpccParent; }

IULSession* MPCSession::COM() { return &m_SelfCOM; }

//////////////////////////////////////////////////////////////////////
// Persistence
//////////////////////////////////////////////////////////////////////

bool MPCSession::IsDirty() const
{
    __ULT_FUNC_ENTRY("MPCSession::IsDirty");


    bool fRes = m_fDirty;


    __ULT_FUNC_EXIT(fRes);
}

HRESULT MPCSession::Load( /*[in]*/ MPC::Serializer& streamIn )
{
    __ULT_FUNC_ENTRY("MPCSession::Load");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwID          );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_szJobID       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_szProviderID  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_szUsername    );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwTotalSize   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwOriginalSize);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwCRC         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_fCompressed   );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwCurrentSize );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_stLastModified);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_fCommitted    );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwProviderData);

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSession::Save( /*[in]*/ MPC::Serializer& streamOut ) const
{
    __ULT_FUNC_ENTRY("MPCSession::Save");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwID          );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_szJobID       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_szProviderID  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_szUsername    );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwTotalSize   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwOriginalSize);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwCRC         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_fCompressed   );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwCurrentSize );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_stLastModified);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_fCommitted    );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwProviderData);

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


//////////////////////////////////////////////////////////////////////
// Operators
//////////////////////////////////////////////////////////////////////

bool MPCSession::operator==( /*[in]*/ const MPC::wstring& rhs )
{
    __ULT_FUNC_ENTRY("MPCSession::operator==");


    bool fRes = (m_szJobID == rhs);


    __ULT_FUNC_EXIT(fRes);
}


bool MPCSession::MatchRequest( /*[in]*/ const UploadLibrary::ClientRequest_OpenSession& crosReq )
{
    __ULT_FUNC_ENTRY("MPCSession::MatchRequest");

    bool fRes = false;

    if(m_szProviderID   == crosReq.szProviderID   &&
       m_szUsername     == crosReq.szUsername     &&
       m_dwTotalSize    == crosReq.dwSize         &&
       m_dwOriginalSize == crosReq.dwSizeOriginal &&
       m_dwCRC          == crosReq.dwCRC          &&
       m_fCompressed    == crosReq.fCompressed     )
    {
        fRes = true;
    }

    return fRes;
}


bool MPCSession::get_Committed() const
{
    bool fRes = m_fCommitted;

    return fRes;
}

HRESULT MPCSession::put_Committed( /*[in]*/ bool fState, /*[in]*/ bool fMove )
{
    __ULT_FUNC_ENTRY("MPCSession::put_Committed");

    HRESULT         hr;


    if(fState)
    {
        if(fMove)
        {
            CISAPIprovider* isapiProvider;
            bool            fFound;

            __MPC_EXIT_IF_METHOD_FAILS(hr, GetProvider( isapiProvider, fFound ));
            if(fFound)
            {
                MPC::wstring szFileDst;

                __MPC_EXIT_IF_METHOD_FAILS(hr, SelectFinalLocation( isapiProvider, szFileDst, fFound ));
                if(fFound == false)
                {
                    __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
                }

                __MPC_EXIT_IF_METHOD_FAILS(hr, MoveToFinalLocation( szFileDst ));
            }

            //
            // Make sure we get rid of the file.
            //
            (void)RemoveFile();
        }
    }

    m_fCommitted = fState;
    m_fDirty     = true;

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

void MPCSession::get_JobID( MPC::wstring& szJobID ) const
{
    szJobID = m_szJobID;
}

void MPCSession::get_LastModified( SYSTEMTIME& stLastModified ) const
{
    stLastModified = m_stLastModified;
}

void MPCSession::get_LastModified( double& dblLastModified ) const
{
    ::SystemTimeToVariantTime( const_cast<SYSTEMTIME*>(&m_stLastModified), &dblLastModified );
}

void MPCSession::get_CurrentSize( DWORD& dwCurrentSize ) const
{
    dwCurrentSize = m_dwCurrentSize;
}

void MPCSession::get_TotalSize( DWORD& dwTotalSize ) const
{
    dwTotalSize = m_dwTotalSize;
}

//////////////////////////////////////////////////////////////////////
// Methods
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCSession::GetProvider
//
// Parameters  : CISAPIprovider*& isapiProvider : provider of current session.
//               bool&            fFound        : true if provider exists.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    :
//
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCSession::GetProvider( /*[out]*/ CISAPIprovider*& isapiProvider ,
                                 /*[out]*/ bool&            fFound        )
{
    __ULT_FUNC_ENTRY("MPCSession::GetProvider");

    HRESULT         hr;
    CISAPIinstance* isapiInstance;
    MPC::wstring    szURL;


    isapiProvider = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpccParent->GetInstance( isapiInstance, fFound ));
    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->get_URL( szURL ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, Config_GetProvider( szURL, m_szProviderID, isapiProvider, fFound ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCSession::SelectFinalLocation
//
// Parameters  : CISAPIprovider* isapiProvider : provider of current session.
//               MPC::wstring&   szFileDst     : Output file directory
//               bool&           fFound        : true if successful.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    :
//
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCSession::SelectFinalLocation( /*[in] */ CISAPIprovider* isapiProvider ,
                                         /*[out]*/ MPC::wstring&   szFileDst     ,
                                         /*[out]*/ bool&           fFound        )
{
    __ULT_FUNC_ENTRY("MPCSession::SelectFinalLocation");

    HRESULT                  hr;
    CISAPIprovider::PathIter itBegin;
    CISAPIprovider::PathIter itEnd;


    fFound = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->GetLocations( itBegin, itEnd ));

    if(itBegin != itEnd)
    {
        WCHAR        rgBuf[MAX_PATH+1];
        MPC::wstring szID;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpccParent->FormatID( szID ));

        wcsncpy     ( rgBuf, L"U_"                 , MAX_PATH );
        EncodeBuffer( rgBuf, m_szProviderID.c_str(), MAX_PATH );
        wcsncat     ( rgBuf, L"_"                  , MAX_PATH );
        wcsncat     ( rgBuf, szID          .c_str(), MAX_PATH );
        wcsncat     ( rgBuf, L"_"                  , MAX_PATH );
        EncodeBuffer( rgBuf, m_szJobID     .c_str(), MAX_PATH );
        wcsncat     ( rgBuf, L"_"                  , MAX_PATH );
        EncodeBuffer( rgBuf, m_szUsername  .c_str(), MAX_PATH );

        szFileDst = *itBegin;
        szFileDst.append( L"\\" );
        szFileDst.append( rgBuf );

        fFound = true;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCSession::MoveToFinalLocation
//
// Parameters  : MPC::wstring& szFileDst : Output file name
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    :
//
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCSession::MoveToFinalLocation( /*[in]*/ const MPC::wstring& szFileDst )
{
    __ULT_FUNC_ENTRY("MPCSession::MoveToFinalLocation");

    HRESULT      hr;
    ULONG        dwRes;
    MPC::wstring szFileSrc;
    MPC::wstring szFileSrcUncompressed;
    bool         fEnough;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFileSrc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( szFileDst ) );

    //
    // Check for space in the final destination.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFileDst, m_dwOriginalSize + DISKSPACE_SAFETYMARGIN, fEnough ));
    if(fEnough == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_DISK_FULL );
    }


    if(m_fCompressed)
    {
        //
        // Check for space in the queue directory.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFileSrc, m_dwOriginalSize + DISKSPACE_SAFETYMARGIN, fEnough ));
        if(fEnough == false)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_DISK_FULL );
        }


        szFileSrcUncompressed = szFileSrc;
        szFileSrcUncompressed.append( L"_decomp" );

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DecompressFromCabinet( szFileSrc.c_str(), szFileSrcUncompressed.c_str(), L"PAYLOAD" ));


        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MoveFile( szFileSrcUncompressed, szFileDst ));
    }
    else
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MoveFile( szFileSrc, szFileDst ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(szFileSrcUncompressed.length() != 0)
    {
        (void)MPC::DeleteFile( szFileSrcUncompressed );
    }

    //
    // Create entry in the Event Log.
    //
    {
        MPC::wstring    szURL;      (void)m_mpccParent->GetInstance( szURL );
        MPC::wstring    szID;       (void)m_mpccParent->FormatID   ( szID  );
        WCHAR           rgSize[16]; (void)swprintf( rgSize, L"%d", m_dwOriginalSize );

        if(SUCCEEDED(hr))
        {
#ifdef DEBUG
            (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, PCHUL_SUCCESS_COMPLETEJOB,
                                       szURL         .c_str(), // %1 = SERVER
                                       szID          .c_str(), // %2 = CLIENT
                                       m_szProviderID.c_str(), // %3 = PROVIDER
                                       rgSize                , // %4 = BYTES
                                       szFileDst     .c_str(), // %5 = DESTINATION
                                       NULL                  );
#endif
        }
        else
        {
            (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_FINALCOPY,
                                       szURL         .c_str(), // %1 = SERVER
                                       szID          .c_str(), // %2 = CLIENT
                                       m_szProviderID.c_str(), // %3 = PROVIDER
                                       rgSize                , // %4 = BYTES
                                       szFileDst     .c_str(), // %5 = DESTINATION
                                       NULL                  );
        }
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCSession::GetFileName( /*[out]*/ MPC::wstring& szFile )
{
    __ULT_FUNC_ENTRY("MPCSession::GetFileName");

    HRESULT hr;
    WCHAR   rgBuf[32];


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpccParent->BuildClientPath( szFile ));

    //
    // The filename for the Data File is "<ID>-<SEQ>.img"
    //
    swprintf( rgBuf, SESSION_CONST__IMG_FORMAT, m_dwID ); szFile.append( rgBuf );

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT MPCSession::RemoveFile()
{
    __ULT_FUNC_ENTRY("MPCSession::RemoveFile");

    HRESULT      hr;
    MPC::wstring szFile;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFile ));

    (void)MPC::DeleteFile( szFile );

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSession::OpenFile( /*[out]*/ HANDLE& hfFile             ,
                              /*[in] */ DWORD   dwMinimumFreeSpace ,
                              /*[in] */ bool    fSeek              )
{
    __ULT_FUNC_ENTRY("MPCSession::OpenFile");

    HRESULT      hr;
    MPC::wstring szFile;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFile ));


    //
    // Check if enough free space is available.
    //
    if(dwMinimumFreeSpace)
    {
        bool fEnough;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFile, dwMinimumFreeSpace, fEnough ));
        if(fEnough == false)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_DISK_FULL );
        }
    }


    //
    // Ensure the directory exists.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( szFile ) );

	__MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hfFile, ::CreateFileW( szFile.c_str(), GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ));

    if(fSeek)
    {
        //
        // Move to the correct Last Written position.
        //
        ::SetFilePointer( hfFile, m_dwCurrentSize, NULL, FILE_BEGIN );

        //
        // If current position differs from wanted position, truncate to zero the file.
        //
        if(::SetFilePointer( hfFile, 0, NULL, FILE_CURRENT ) != m_dwCurrentSize)
        {
            ::SetFilePointer( hfFile, 0, NULL, FILE_BEGIN );
            ::SetEndOfFile  ( hfFile                      );

            m_dwCurrentSize = 0;
            m_fDirty        = true;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSession::Validate( /*[in] */ bool  fCheckFile ,
                              /*[out]*/ bool& fPassed    )
{
    __ULT_FUNC_ENTRY("MPCSession::Validate");

    HRESULT         hr;
    HANDLE          hfFile = NULL;
    CISAPIprovider* isapiProvider;
    bool            fFound;


    fPassed = false;


    //
    // If the related provider doesn't exist, validation fails.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetProvider( isapiProvider, fFound ));
    if(fFound == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if(m_fCommitted == true)
    {
        fPassed = true;

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    /////////////////////////////////////////////////////////
    //
    // If we reach this point, the session is still not committed.
    //

    if(fCheckFile)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, OpenFile( hfFile ));

        //
        // All the bytes have been received, so try to commit the job (deferred due to low disk probably).
        //
        if(m_dwCurrentSize >= m_dwTotalSize)
        {
            //
            // Ignore result, if it fails the session won't be committed.
            //
            (void)put_Committed( true, true );
        }
    }

    fPassed = true;
    hr      = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hfFile) ::CloseHandle( hfFile );

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSession::CheckUser( /*[in] */ const MPC::wstring& szUser ,
                               /*[out]*/ bool&               fMatch )
{
    __ULT_FUNC_ENTRY("MPCSession::CheckUser");

    HRESULT         hr;
    CISAPIprovider* isapiProvider;
    BOOL            fAuthenticated;
    bool            fFound;


    fMatch = false;

    //
    // If the related provider doesn't exist, validation fails.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetProvider( isapiProvider, fFound ));
    if(fFound == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_Authenticated( fAuthenticated ));
    if(fAuthenticated)
    {
        if(m_szUsername != szUser)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    fMatch = true; // User check is positive.
    hr     = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCSession::CompareCRC( /*[out]*/ bool& fMatch )
{
    __ULT_FUNC_ENTRY("MPCSession::CompareCRC");

    HRESULT hr;
    HANDLE  hfFile = NULL;
    UCHAR   rgBuf[BUFFER_SIZE_FILECOPY];
    DWORD   dwCRC;


    fMatch = false;

    MPC::InitCRC( dwCRC );


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenFile( hfFile ));

    //
    // Move to the beginning.
    //
    ::SetFilePointer( hfFile, 0, NULL, FILE_BEGIN );


    //
    // Calculate the CRC, reading all the data.
    //
    while(1)
    {
        DWORD dwRead;

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ReadFile( hfFile, rgBuf, sizeof( rgBuf ), &dwRead, NULL ));

        if(dwRead == 0) // End of File.
        {
            break;
        }


        MPC::ComputeCRC( dwCRC, rgBuf, dwRead );
    }

    fMatch = (dwCRC == m_dwCRC);
    hr     = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hfFile) ::CloseHandle( hfFile );

    __ULT_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCSession::AppendData
//
// Parameters  : MPC::Serializer& conn : stream sourcing the data.
//               DWORD                   size : size of the data.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Writes a block of data from the 'conn' stream to the end of
//               the Data File for this session.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCSession::AppendData( /*[in]*/ MPC::Serializer& streamConn ,
                                /*[in]*/ DWORD            dwSize     )
{
    __ULT_FUNC_ENTRY("MPCSession::AppendData");

    HRESULT hr;
    HANDLE  hfFile = NULL;


    //
    // Open file and make sure there's enough free space.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenFile( hfFile, dwSize * 3 ));


    {
        MPC::Serializer_File streamConnOut( hfFile );
        BYTE                 rgBuf[BUFFER_SIZE_FILECOPY];

        hr = S_OK;
        while(dwSize)
        {
            DWORD dwRead = min( BUFFER_SIZE_FILECOPY, dwSize );

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamConn   .read ( rgBuf, dwRead ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamConnOut.write( rgBuf, dwRead ));

            dwSize          -= dwRead;
            m_dwCurrentSize += dwRead;

            ::GetSystemTime( &m_stLastModified );
            m_fDirty         = true;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hfFile) ::CloseHandle( hfFile );

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\uploadserver.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    UploadServer.cpp

Abstract:
    This file contains the implementation of the stubs needed
    by an ISAPI extension.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"

#include <initguid.h>

#include "UploadServerCustom_i.c"


////////////////////////////////////////////////////////////////////////////////

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

////////////////////////////////////////////////////////////////////////////////

HANDLE                  g_Heap;
CISAPIconfig            g_Config;
MPC::NTEvent            g_NTEvents;

static CRITICAL_SECTION g_CritSec;
static BOOL             g_Initialized;

static WCHAR	 		g_AppName     [] = L"UploadServer";
static WCHAR	 		g_RegistryBase[] = L"SOFTWARE\\Microsoft\\UploadLibrary\\Settings";


BOOL WINAPI DllMain( HINSTANCE hinstDLL    ,
                     DWORD     fdwReason   ,
                     LPVOID    lpvReserved )
{
    switch( fdwReason )
    {
    case DLL_PROCESS_ATTACH:
        g_Heap = HeapCreate( 0, 0, 0 ); if(g_Heap == NULL) return FALSE;

        InitializeCriticalSection( &g_CritSec );
        g_Initialized = false;

        _Module.Init( ObjectMap, hinstDLL );
        break;

    case DLL_PROCESS_DETACH:
        _Module.Term();

        if(g_Initialized)
        {
            ;
        }

        DeleteCriticalSection( &g_CritSec );

        HeapDestroy( g_Heap );
        break;
    }

    return TRUE;
}

DWORD WINAPI HttpExtensionProc( LPEXTENSION_CONTROL_BLOCK pECB )
{
    __ULT_FUNC_ENTRY("HttpExtensionProc");

	DWORD dwRes;


    if(pECB->lpszQueryString)
    {
        //
        // Exit if there's a query string beginning with DEBUG
        //
        if(!strncmp( pECB->lpszQueryString, "DEBUG", 5 ))
        {
            return HSE_STATUS_ERROR;
        }
    }

	//
	// Process the request.
	//
	try
	{
		MPCHttpContext* ptr = new MPCHttpContext();

		dwRes = ptr->Init( pECB );
	}
	catch(...)
	{
        __ULT_TRACE_ERROR( UPLOADLIBID, "Upload Server raised an exception. Gracefully exiting..." );

        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_EXCEPTION,
                                   L""                 , // %1 = SERVER
                                   L"HttpExtensionProc", // %2 = CLIENT
                                   NULL			       );

		dwRes =  HSE_STATUS_ERROR;
    }

	return dwRes;
}

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO* pVer )
{
    BOOL fRes = TRUE;

    // Create the extension version string, and
    // copy string to HSE_VERSION_INFO structure
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    // Copy description string into HSE_VERSION_INFO structure
    strcpy( pVer->lpszExtensionDesc, "My ISAPI Extension" );


    //
    // Load config settings if it's the first time we are invoked.
    //
    if(g_Initialized == FALSE)
    {
        EnterCriticalSection( &g_CritSec );

        if(g_Initialized == FALSE)
        {
            g_Initialized = TRUE;

			__MPC_TRACE_INIT();

            (void)g_NTEvents.Init   ( g_AppName      );
            (void)g_Config  .SetRoot( g_RegistryBase );

            if(FAILED(g_Config.Load()))
            {
                (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_NOCONFIG, NULL );

                fRes = FALSE;
            }
        }

        LeaveCriticalSection( &g_CritSec );
    }

    (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, PCHUL_SUCCESS_STARTED, NULL );


    return fRes;
}

BOOL WINAPI TerminateExtension( DWORD dwFlags )
{
    (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, PCHUL_SUCCESS_STOPPED, NULL );

	__MPC_TRACE_TERM();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

void WINAPI PurgeEngine(void)
{
	__MPC_TRACE_INIT();

    (void)g_NTEvents.Init   ( g_AppName      );
    (void)g_Config  .SetRoot( g_RegistryBase );

    if(FAILED(g_Config.Load()))
    {
        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_NOCONFIG, NULL );
    }
    else
    {
        MPCPurgeEngine mpcpe;

        mpcpe.Process();
    }

	__MPC_TRACE_TERM();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\wrapper.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Wrapper.cpp

Abstract:
    This file contains the implementation of the COM wrapper classes,
	used for interfacing with the Custom Providers.

Revision History:
    Davide Massarenti   (Dmassare)  04/25/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

MPCServerCOMWrapper::MPCServerCOMWrapper( /*[in]*/ MPCServer* mpcsServer )
{
	m_mpcsServer = mpcsServer; // MPCServer* m_mpcsServer;
}

MPCServerCOMWrapper::~MPCServerCOMWrapper()
{
}

STDMETHODIMP MPCServerCOMWrapper::GetRequestVariable( /*[in]*/ BSTR bstrName, /*[out]*/ BSTR *pbstrVal )
{
    __ULT_FUNC_ENTRY( "MPCServerCOMWrapper::GetRequestVariable" );

	USES_CONVERSION;

	HRESULT      hr;
	MPC::wstring szValue;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
		__MPC_PARAMCHECK_POINTER_AND_SET(pbstrVal,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcsServer->m_hcCallback->GetServerVariable( W2A( bstrName ), szValue ));

	hr = MPC::GetBSTR( szValue.c_str(), pbstrVal );


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP MPCServerCOMWrapper::AbortTransfer()
{
    __ULT_FUNC_ENTRY( "MPCServerCOMWrapper::AbortTransfer" );


	m_mpcsServer->SetResponse( UploadLibrary::UL_RESPONSE_DENIED );
	m_mpcsServer->m_fTerminated = true;


    __ULT_FUNC_EXIT(S_OK);
}

STDMETHODIMP MPCServerCOMWrapper::CompleteTransfer( /*[in]*/ IStream* data )
{
    __ULT_FUNC_ENTRY( "MPCServerCOMWrapper::CompleteTransfer" );

	HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcsServer->CustomProvider_SetResponse( data ));
	m_mpcsServer->m_fTerminated = true;

	hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

MPCSessionCOMWrapper::MPCSessionCOMWrapper( /*[in]*/ MPCSession* mpcsSession )
{
	m_mpcsSession = mpcsSession; // MPCSession* m_mpcsSession;
}

MPCSessionCOMWrapper::~MPCSessionCOMWrapper()
{
}

////////////////////

STDMETHODIMP MPCSessionCOMWrapper::get_Client( /*[out]*/ BSTR *pVal )
{
	CComBSTR tmp( m_mpcsSession->GetClient()->GetServer()->m_crClientRequest.sigClient.guidMachineID );

	return MPC::GetBSTR( tmp, pVal );
}

STDMETHODIMP MPCSessionCOMWrapper::get_Command( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->GetClient()->GetServer()->m_crClientRequest.dwCommand;

	return S_OK;
}

STDMETHODIMP MPCSessionCOMWrapper::get_ProviderID( /*[out]*/ BSTR *pVal )
{
	return MPC::GetBSTR( m_mpcsSession->m_szProviderID.c_str(), pVal );
}

STDMETHODIMP MPCSessionCOMWrapper::get_Username( /*[out]*/ BSTR *pVal )
{
	return MPC::GetBSTR( m_mpcsSession->m_szUsername.c_str(), pVal );
}

STDMETHODIMP MPCSessionCOMWrapper::get_JobID( /*[out]*/ BSTR *pVal )
{
	return MPC::GetBSTR( m_mpcsSession->m_szJobID.c_str(), pVal );
}

STDMETHODIMP MPCSessionCOMWrapper::get_SizeAvailable( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->m_dwCurrentSize;

	return S_OK;
}

STDMETHODIMP MPCSessionCOMWrapper::get_SizeTotal( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->m_dwTotalSize;

	return S_OK;
}

STDMETHODIMP MPCSessionCOMWrapper::get_SizeOriginal( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->m_dwOriginalSize;

	return S_OK;
}


STDMETHODIMP MPCSessionCOMWrapper::get_Data( /*[out]*/ IStream* *pStm )
{
    __ULT_FUNC_ENTRY( "MPCServerCOMWrapper::GetRequestVariable" );

	HRESULT                  hr;
	HANDLE                   hfFile = NULL;
    CComPtr<MPC::FileStream> stream;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pStm,NULL);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcsSession->OpenFile( hfFile, 0, false ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForRead( L"", hfFile ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, stream.QueryInterface( pStm ));


    __ULT_FUNC_CLEANUP;

    if(hfFile) ::CloseHandle( hfFile );

    __ULT_FUNC_EXIT(hr);
}


STDMETHODIMP MPCSessionCOMWrapper::get_ProviderData( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->m_dwProviderData;

	return S_OK;
}

STDMETHODIMP MPCSessionCOMWrapper::put_ProviderData( /*[in]*/ DWORD newVal )
{
	m_mpcsSession->m_dwProviderData = newVal;
	m_mpcsSession->m_fDirty         = true;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\wrapper.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Wrapper.h

Abstract:
    This file contains the declaration of the COM wrapper classes,
	used for interfacing with the Custom Providers.

Revision History:
    Davide Massarenti   (Dmassare)  04/25/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___WRAPPER_H___)
#define __INCLUDED___ULSERVER___WRAPPER_H___

#include <UploadServerCustom.h>

class MPCServer;
class MPCClient;
class MPCSession;

template <class Base> class CComUnknown : public Base
{
public:
	STDMETHOD_(ULONG, AddRef )() { return 2; }
	STDMETHOD_(ULONG, Release)() { return 1; }

	STDMETHOD(QueryInterface)( REFIID iid, void* *ppvObject )
	{
		if(ppvObject == NULL) return E_POINTER;

		if(IsEqualGUID( iid, IID_IUnknown   ) ||
		   IsEqualGUID( iid, __uuidof(Base) )  )
		{
			*ppvObject = this;
			return S_OK;
		}
			
		return E_NOINTERFACE;
	}
};

class MPCServerCOMWrapper : public CComUnknown<IULServer>
{
    MPCServer* m_mpcsServer;

public:
	MPCServerCOMWrapper( /*[in]*/ MPCServer* mpcsServer );
	virtual ~MPCServerCOMWrapper();

	// IULServer
    STDMETHOD(GetRequestVariable)( /*[in]*/ BSTR bstrName, /*[out]*/ BSTR *pbstrVal );

    STDMETHOD(AbortTransfer   )(                        );
    STDMETHOD(CompleteTransfer)( /*[in]*/ IStream* data );
};

class MPCSessionCOMWrapper : public CComUnknown<IULSession>
{
    MPCSession* m_mpcsSession;

public:
	MPCSessionCOMWrapper( /*[in]*/ MPCSession* mpcsSession );
	virtual ~MPCSessionCOMWrapper();

	// IULSession
    STDMETHOD(get_Client       )( /*[out]*/ BSTR     *pVal   );
    STDMETHOD(get_Command      )( /*[out]*/ DWORD    *pVal   );

    STDMETHOD(get_ProviderID   )( /*[out]*/ BSTR     *pVal   );
    STDMETHOD(get_Username     )( /*[out]*/ BSTR     *pVal   );

    STDMETHOD(get_JobID        )( /*[out]*/ BSTR     *pVal   );
    STDMETHOD(get_SizeAvailable)( /*[out]*/ DWORD    *pVal   );
    STDMETHOD(get_SizeTotal    )( /*[out]*/ DWORD    *pVal   );
    STDMETHOD(get_SizeOriginal )( /*[out]*/ DWORD    *pVal   );

    STDMETHOD(get_Data         )( /*[out]*/ IStream* *pStm   );

    STDMETHOD(get_ProviderData )( /*[out]*/ DWORD    *pVal   );
    STDMETHOD(put_ProviderData )( /*[in]*/  DWORD     newVal );
};

#endif // !defined(__INCLUDED___ULSERVER___SERVER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\upload\server\isapi\session.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Session.h

Abstract:
    This file contains the declaration of the MPCSession class,
    that describes the state of a transfer.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___SESSION_H___)
#define __INCLUDED___ULSERVER___SESSION_H___


#include <Wrapper.h>


#define SESSION_CONST__IMG_FORMAT    L"-%08x.img"
#define SESSION_CONST__IMG_EXTENSION L".img"


class MPCSession : public MPCPersist
{
	friend class MPCSessionCOMWrapper;

	////////////////////

	MPCSessionCOMWrapper m_SelfCOM;
    MPCClient*   		 m_mpccParent;
    DWORD        		 m_dwID;

    MPC::wstring 		 m_szJobID;
    MPC::wstring 		 m_szProviderID;
    MPC::wstring 		 m_szUsername;
		
    DWORD        		 m_dwTotalSize;
    DWORD        		 m_dwOriginalSize;
    DWORD        		 m_dwCRC;
    bool         		 m_fCompressed;
		
    DWORD        		 m_dwCurrentSize;
    SYSTEMTIME   		 m_stLastModified;
    bool         		 m_fCommitted;

    DWORD        		 m_dwProviderData;
		
    mutable bool 		 m_fDirty;

    //////////////////////////////////////////////////////////////////

private:
	MPCSession& operator=( /*[in]*/ const MPCSession& sess );

public:
    MPCSession( /*[in]*/ MPCClient* mpccParent                                                                                        );
    MPCSession( /*[in]*/ MPCClient* mpccParent, /*[in]*/ const UploadLibrary::ClientRequest_OpenSession& crosReq, /*[in]*/ DWORD dwID );
	MPCSession( /*[in]*/ const MPCSession& sess                                                                                       );
    virtual ~MPCSession();

	MPCClient*  GetClient();

	IULSession* COM();

    /////////////////////////////////////////////

    virtual bool    IsDirty() const;

    virtual HRESULT Load( /*[in]*/ MPC::Serializer& streamIn  );
    virtual HRESULT Save( /*[in]*/ MPC::Serializer& streamOut ) const;

    bool operator==( /*[in]*/ const MPC::wstring& rhs );

    bool MatchRequest( /*[in]*/ const UploadLibrary::ClientRequest_OpenSession& crosReq );

    bool    get_Committed(                                           ) const;
    HRESULT put_Committed( /*[in]*/ bool fState, /*[in]*/ bool fMove );

    void    get_JobID       ( MPC::wstring& szJobID         ) const;
    void    get_LastModified( SYSTEMTIME&   stLastModified  ) const;
    void    get_LastModified( double&       dblLastModified ) const;
    void    get_CurrentSize ( DWORD&        dwCurrentSize   ) const;
    void    get_TotalSize   ( DWORD&        dwTotalSize     ) const;

    /////////////////////////////////////////////

    HRESULT GetProvider( /*[out]*/ CISAPIprovider*& isapiProvider, /*[out]*/ bool& fFound );

    HRESULT SelectFinalLocation( /*[in]*/ CISAPIprovider* isapiProvider, /*[out]*/ MPC::wstring&       szFileDst, /*[out]*/ bool& fFound );
    HRESULT MoveToFinalLocation(                                         /*[in] */ const MPC::wstring& szFileDst                         );

    /////////////////////////////////////////////

    HRESULT GetFileName( /*[out]*/ MPC::wstring&       szFile                                                                );
    HRESULT RemoveFile (                                                                                                     );
    HRESULT OpenFile   ( /*[out]*/ HANDLE&             hfFile    , /*[in] */ DWORD dwMinimumFreeSpace = 0, bool fSeek = true );
    HRESULT Validate   ( /*[in] */ bool                fCheckFile, /*[out]*/ bool& fPassed                                   );
    HRESULT CheckUser  ( /*[in] */ const MPC::wstring& szUser    , /*[out]*/ bool& fMatch                                    );
    HRESULT CompareCRC (                                           /*[out]*/ bool& fMatch                                    );

    HRESULT AppendData( /*[in]*/ MPC::Serializer& streamConn, /*[in]*/ DWORD dwSize );
};

#endif // !defined(__INCLUDED___ULSERVER___SESSION_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\dload\adminpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\mmc\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

TARGETSRCS= $(SDK_INC_PATH)\mmc.h \
            $(SDK_INC_PATH)\mmc.idl \
            $(PRIVATE_INC_PATH)\mmc\mmcGUID.h 

TARGETMOVED= $(BASEDIR)\private\admin\activec\inc\mmc.h \
             $(BASEDIR)\private\admin\activec\lib\mmc_i.c

mmc: $(TARGETSRCS)

clean:
    del /Q /F $(TARGETSRCS)
    del /Q /F $(TARGETMOVED) 

$(SDK_INC_PATH)\mmc.h: $(PASS0_HEADERDIR)\mmc.h
    copy $** $@

$(PRIVATE_INC_PATH)\mmc\mmcGUID.h: $(PASS0_HEADERDIR)\mmc_i.c
    copy $** $@
   
$(SDK_INC_PATH)\mmc.idl: mmc.idl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\dload\msi.c ===
#include "adminpch.h"
#pragma hdrstop

#include <msi.h>
#include <msiquery.h>

static
UINT
WINAPI
MsiCloseHandle(MSIHANDLE hAny)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiConfigureProductW(LPCWSTR szProduct, int iInstallLevel, INSTALLSTATE eInstallState)
{
    return ERROR_PROC_NOT_FOUND;
}

static
MSIHANDLE
WINAPI
MsiCreateRecord(UINT cParams)
{
    return 0;
}

static
UINT
WINAPI
MsiDatabaseCommit(MSIHANDLE hDatabase)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiDatabaseOpenViewW(MSIHANDLE hDatabase, LPCWSTR szQuery, MSIHANDLE*  phView)
{
    return ERROR_PROC_NOT_FOUND;
}

static
INSTALLSTATE
WINAPI
MsiGetComponentPathW(LPCWSTR  szProduct,
	             LPCWSTR  szComponent,
                     LPWSTR   lpPathBuf,
                     DWORD    *pcchBuf)
{
    return INSTALLSTATE_UNKNOWN;
}

static
UINT
WINAPI
MsiGetProductInfoW(LPCWSTR  szProduct,
	               LPCWSTR  szAttribute,
                   LPWSTR   lpValueBuf,
                   DWORD    *pcchValueBuf)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiGetSummaryInformationW(MSIHANDLE hDatabase,
                    	  LPCWSTR   szDatabasePath,
                    	  UINT      uiUpdateCount,
                    	  MSIHANDLE *phSummaryInfo)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiInstallProductW(LPCWSTR szPackagePath, LPCWSTR szCommandLine)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiOpenDatabaseW(LPCWSTR szDatabasePath, LPCWSTR szPersist, MSIHANDLE *phDatabase)
{
    return ERROR_PROC_NOT_FOUND;
}

static
INSTALLSTATE
WINAPI
MsiQueryFeatureStateW(LPCWSTR szProduct, LPCWSTR szFeature)
{
    return INSTALLSTATE_UNKNOWN;
}

static
UINT
WINAPI
MsiRecordGetStringA(MSIHANDLE hRecord, UINT iField, LPSTR szValueBuf, DWORD *pcchValueBuf)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiRecordGetStringW(MSIHANDLE hRecord, UINT iField, LPWSTR szValueBuf, DWORD *pcchValueBuf)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiRecordReadStream(MSIHANDLE hRecord, UINT iField, char *szDataBuf, DWORD* pcbDataBuf)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiRecordSetStreamW(MSIHANDLE hRecord, UINT iField, LPCWSTR szFilePath)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiRecordSetStringW(MSIHANDLE hRecord, UINT iField, LPCWSTR szValue)
{
    return ERROR_PROC_NOT_FOUND;
}

INSTALLUILEVEL 
WINAPI
MsiSetInternalUI(INSTALLUILEVEL dwUILevel, HWND* phWnd)
{
    // If msi.dll failed to load, then it's certainly not
    // going to display any UI
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INSTALLUILEVEL_NONE;
}

static
UINT
WINAPI
MsiSummaryInfoGetPropertyW(MSIHANDLE hSummaryInfo,
                    	   UINT      uiProperty,
                    	   UINT      *puiDataType,
                    	   INT       *piValue,
                    	   FILETIME  *pftValue,
                    	   LPWSTR    szValueBuf,
                    	   DWORD     *pcchValueBuf)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiSummaryInfoPersist(MSIHANDLE hSummaryInfo)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiSummaryInfoSetPropertyW(MSIHANDLE hSummaryInfo,
                           UINT      uiProperty,
                           UINT      uiDataType,
                           INT       iValue,
                           FILETIME  *pftValue,
                           LPCWSTR   szValue)
{
    return ERROR_PROC_NOT_FOUND;
}
                        
static
UINT
WINAPI
MsiViewExecute(MSIHANDLE hView, MSIHANDLE hRecord)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiViewFetch(MSIHANDLE hView, MSIHANDLE *phRecord)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiViewModify(MSIHANDLE hView, MSIMODIFY eModifyMode, MSIHANDLE hRecord)
{
    return ERROR_PROC_NOT_FOUND;
}

static
INSTALLSTATE
WINAPI
MsiQueryFeatureStateFromDescriptorW(LPCWSTR szDescriptor)
{
    return INSTALLSTATE_UNKNOWN;
}

static
UINT
WINAPI
MsiDecomposeDescriptorW(LPCWSTR	szDescriptor,
                        LPWSTR szProductCode,
                        LPWSTR szFeatureId,
                        LPWSTR szComponentCode,
                        DWORD* pcchArgsOffset)
{
    return ERROR_PROC_NOT_FOUND;
}

static
UINT
WINAPI
MsiEnumRelatedProductsW(LPCWSTR lpUpgradeCode,
	                    DWORD   dwReserved,
	                    DWORD   iProductIndex,
	                    LPWSTR  lpProductBuf)
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(msi)
{
    DLOENTRY(8, MsiCloseHandle)
    DLOENTRY(16, MsiConfigureProductW)
    DLOENTRY(17, MsiCreateRecord)
    DLOENTRY(20, MsiDatabaseCommit)
    DLOENTRY(32, MsiDatabaseOpenViewW)
    DLOENTRY(70, MsiGetProductInfoW)
    DLOENTRY(78, MsiGetSummaryInformationW)
    DLOENTRY(88, MsiInstallProductW)
    DLOENTRY(92, MsiOpenDatabaseW)
    DLOENTRY(111, MsiQueryFeatureStateW)
    DLOENTRY(117, MsiRecordGetStringA)
    DLOENTRY(118, MsiRecordGetStringW)
    DLOENTRY(120, MsiRecordReadStream)
    DLOENTRY(123, MsiRecordSetStreamW)
    DLOENTRY(125, MsiRecordSetStringW)
    DLOENTRY(141, MsiSetInternalUI)
    DLOENTRY(150, MsiSummaryInfoGetPropertyW)
    DLOENTRY(151, MsiSummaryInfoPersist)
    DLOENTRY(153, MsiSummaryInfoSetPropertyW)
    DLOENTRY(159, MsiViewExecute)
    DLOENTRY(160, MsiViewFetch)
    DLOENTRY(163, MsiViewModify)
    DLOENTRY(173, MsiGetComponentPathW)
    DLOENTRY(188, MsiQueryFeatureStateFromDescriptorW)
    DLOENTRY(201, MsiDecomposeDescriptorW)
    DLOENTRY(205, MsiEnumRelatedProductsW)
};

DEFINE_ORDINAL_MAP(msi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\dload\mprui.c ===
#include "adminpch.h"
#pragma hdrstop


static
DWORD
MPRUI_DoPasswordDialog(
    HWND          hwndOwner,
    TCHAR *       pchResource,
    TCHAR *       pchUserName,
    TCHAR *       pchPasswordReturnBuffer,
    DWORD         cbPasswordReturnBuffer,
    BOOL *        pfDidCancel,
    BOOL          fDownLevel
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
MPRUI_DoProfileErrorDialog(
    HWND          hwndOwner,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDidCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfHideErrors
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_ShowReconnectDialog(
    HWND    hwndParent,
    LPVOID  Params
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetClearConnections(
     HWND    hWnd
     )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetConnectionDialog(
    IN HWND  hwnd,
    IN DWORD dwType
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetConnectionDialog1A(
    IN OUT LPCONNECTDLGSTRUCTA lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetConnectionDialog1W(
    IN OUT LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetDisconnectDialog(
    IN HWND  hwnd,
    IN DWORD dwType
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetDisconnectDialog1A(
    IN LPDISCDLGSTRUCTA lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetDisconnectDialog1W(
    IN LPDISCDLGSTRUCTW lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(mprui)
{
    DLPENTRY(MPRUI_DoPasswordDialog)
    DLPENTRY(MPRUI_DoProfileErrorDialog)
    DLPENTRY(MPRUI_ShowReconnectDialog)
    DLPENTRY(MPRUI_WNetClearConnections)
    DLPENTRY(MPRUI_WNetConnectionDialog)
    DLPENTRY(MPRUI_WNetConnectionDialog1A)
    DLPENTRY(MPRUI_WNetConnectionDialog1W)
    DLPENTRY(MPRUI_WNetDisconnectDialog)
    DLPENTRY(MPRUI_WNetDisconnectDialog1A)
    DLPENTRY(MPRUI_WNetDisconnectDialog1W)
};

DEFINE_PROCNAME_MAP(mprui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\dload\ntlanman.c ===
#include "adminpch.h"
#pragma hdrstop

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    )
{
    return ERROR_PROC_NOT_FOUND;
}

DWORD APIENTRY
NPCancelConnectionForCSCAgent(
    LPCTSTR         szName,
    BOOL            fForce
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntlanman)
{
    DLPENTRY(NPAddConnection3ForCSCAgent)
    DLPENTRY(NPCancelConnectionForCSCAgent)
};

DEFINE_PROCNAME_MAP(ntlanman)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\msi\makefile.inc ===
#
# Build for public Windows installer headers.
#

!IFNDEF NO_STRICT
STRICT=1
!ENDIF

msiinc:\
        $(SDK_INC_PATH)\msi.h \
        $(ADMIN_INC_PATH)\msip.h \
        $(SDK_INC_PATH)\msiquery.h

#
# msi.h, msip.h
#

$(O)\msi.x $(O)\msip.x: msi.w
    hsplit -e -o $(O)\msi.x $(O)\msip.x msi.w

$(O)\msi.h: $(O)\msi.x
    wcshdr < $? > $@

$(O)\msip.h: $(O)\msip.x
    wcshdr < $? > $@
    
$(O)\msiquery.h: msiquery.w
    wcshdr < $? > $@

$(SDK_INC_PATH)\msi.h: $(O)\msi.h
    $(PUBLISH_CMD) {$?=$@}

$(ADMIN_INC_PATH)\msip.h: $(O)\msip.h
    $(PUBLISH_CMD) {$?=$@}
    
$(SDK_INC_PATH)\msiquery.h: $(O)\msiquery.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\wmiscmgr\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

TARGETSRCS= $(ADMIN_INC_PATH)\SchemaManager.h \
            $(ADMIN_INC_PATH)\SchemaManager.idl 

clean:
    del /Q /F $(TARGETSRCS)

$(ADMIN_INC_PATH)\SchemaManager.h: $(PASS0_HEADERDIR)\SchemaManager.h
    copy $** $@

$(ADMIN_INC_PATH)\SchemaManager.idl: SchemaManager.idl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\msi\msidefs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation.  All rights reserved.
//
//  File:       msidefs.h
//
//--------------------------------------------------------------------------

/* msidefs.h   Windows Installer data definitions

____________________________________________________________________________*/

#ifndef __MSIDEFS
#define __MSIDEFS

#ifndef _WIN32_MSI
#if (_WIN32_WINNT >= 0x0510)
#define _WIN32_MSI   200
#elif (_WIN32_WINNT >= 0x0500)
#define _WIN32_MSI   110
#else
#define _WIN32_MSI   100
#endif //_WIN32_WINNT
#endif // !_WIN32_MSI

//__________________________________________________________________________
//
// INSTALLER PROPERTY DEFINITIONS
//__________________________________________________________________________

// Required properties: set in Property table
#define IPROPNAME_PRODUCTNAME      TEXT("ProductName")      // name registered for display
#define IPROPNAME_PRODUCTCODE      TEXT("ProductCode")      // unique string GUID for product
#define IPROPNAME_PRODUCTVERSION   TEXT("ProductVersion")   // string product version
#define IPROPNAME_INSTALLLANGUAGE  TEXT("ProductLanguage")  // install language of product, use to load resources        
#define IPROPNAME_MANUFACTURER     TEXT("Manufacturer")     // name of manufacturer

// Customization properties: set in Property table
#define IPROPNAME_UPGRADECODE      TEXT("UpgradeCode")      // unique string GUID for product family
#define IPROPNAME_PIDTEMPLATE      TEXT("PIDTemplate")      // drives Product ID processing
#define IPROPNAME_DISKPROMPT       TEXT("DiskPrompt")       // prompt for CD
#define IPROPNAME_LEFTUNIT         TEXT("LeftUnit")         // name of unit placed to left of number instead of right
#define IPROPNAME_ADMIN_PROPERTIES TEXT("AdminProperties")  // properties to stuff in admin package
#define IPROPNAME_DEFAULTUIFONT    TEXT("DefaultUIFont")    // the font used in the UI if no other font is specified
#define IPROPNAME_ALLOWEDPROPERTIES TEXT("SecureCustomProperties")
#define IPROPNAME_ENABLEUSERCONTROL TEXT("EnableUserControl") // allows user to specify any public property
#define IPROPNAME_HIDDEN_PROPERTIES TEXT("MsiHiddenProperties")  // properties that should not be dumped into the log file

// Customization properties: set on command-line or in Property table
#define IPROPNAME_USERNAME         TEXT("USERNAME")
#define IPROPNAME_COMPANYNAME      TEXT("COMPANYNAME")
#define IPROPNAME_PIDKEY           TEXT("PIDKEY")           // used with PIDTemplate to form ProductID
#define IPROPNAME_PATCH            TEXT("PATCH")            // patch package to apply - SET BY INSTALLER
#define IPROPNAME_TARGETDIR        TEXT("TARGETDIR")        // target location - defaults to ROOTDRIVE
#define IPROPNAME_ACTION           TEXT("ACTION")           // top-level action to perform - default to INSTALL
#define IPROPNAME_LIMITUI          TEXT("LIMITUI")          // limit ui level to Basic
#define IPROPNAME_LOGACTION        TEXT("LOGACTION")        // log only these actions
#define IPROPNAME_ALLUSERS         TEXT("ALLUSERS")         // install for all users
#define IPROPNAME_INSTALLLEVEL     TEXT("INSTALLLEVEL")
#define IPROPNAME_REBOOT           TEXT("REBOOT")           // force or suppress reboot
#if (_WIN32_MSI >=  110)
#define IPROPNAME_REBOOTPROMPT     TEXT("REBOOTPROMPT")     // allow or suppress reboot prompt
#endif //(_WIN32_MSI >=  110)
#define IPROPNAME_EXECUTEMODE      TEXT("EXECUTEMODE")      // NONE or SCRIPT
#define IPROPVALUE_EXECUTEMODE_NONE TEXT("NONE")            // do not update system
#define IPROPVALUE_EXECUTEMODE_SCRIPT TEXT("SCRIPT")        // default - run script to update system
#define IPROPNAME_EXECUTEACTION    TEXT("EXECUTEACTION")    // run action on server side
#define IPROPNAME_SOURCELIST       TEXT("SOURCELIST")
#define IPROPNAME_ROOTDRIVE        TEXT("ROOTDRIVE")        // default drive to install - SET BY INSTALLER
#define IPROPNAME_TRANSFORMS       TEXT("TRANSFORMS")       // transforms to apply
#define IPROPNAME_TRANSFORMSATSOURCE TEXT("TRANSFORMSATSOURCE") // transforms can be found at source
#define IPROPNAME_TRANSFORMSSECURE   TEXT("TRANSFORMSSECURE")   // file transforms are secured
#define IPROPNAME_SEQUENCE         TEXT("SEQUENCE")         // sequence table to run with SEQUENCE action
#define IPROPNAME_SHORTFILENAMES   TEXT("SHORTFILENAMES")   // force short file names
#define IPROPNAME_PRIMARYFOLDER    TEXT("PRIMARYFOLDER")	   // Folder on the volume the author wants costing info for
#define IPROPNAME_AFTERREBOOT      TEXT("AFTERREBOOT")      // install is after a ForceReboot triggered reboot
#define IPROPNAME_NOCOMPANYNAME    TEXT("NOCOMPANYNAME")
#define IPROPNAME_NOUSERNAME       TEXT("NOUSERNAME")
#define IPROPNAME_DISABLEROLLBACK  TEXT("DISABLEROLLBACK")  // disable rollback for this install
#define IPROPNAME_AVAILABLEFREEREG TEXT("AVAILABLEFREEREG") // set up the free space in the registry before commencing the install
#define IPROPNAME_DISABLEADVTSHORTCUTS TEXT("DISABLEADVTSHORTCUTS") // disable creating darwin shortcuts even if supported
#define IPROPNAME_PATCHNEWPACKAGECODE TEXT("PATCHNEWPACKAGECODE")   // added to property table by patch transforms - used to update
																						  // PackageCode of admin packages when patching admin installs
#define IPROPNAME_PATCHNEWSUMMARYSUBJECT TEXT("PATCHNEWSUMMARYSUBJECT") // added to property table by patch transforms - used to update
																								// Subject summary info property of admin packages when patching admin installs
#define IPROPNAME_PATCHNEWSUMMARYCOMMENTS TEXT("PATCHNEWSUMMARYCOMMENTS") // added to property table by patch transforms - used to update
																								  // Comments summary info property of admin packages when patching admin installs
#define IPROPNAME_PRODUCTLANGUAGE  TEXT("PRODUCTLANGUAGE")   // requested language, must be one in summary information list, selects language transform

#if (_WIN32_MSI >= 150)
#define IPROPNAME_CHECKCRCS        TEXT("MSICHECKCRCS")      // requests Darwin to check CRCs after copying, moving, patching & duplicating files.
#define IPROPNAME_MSINODISABLEMEDIA TEXT("MSINODISABLEMEDIA")  // if set, DISABLEMEDIA won't be set in the AdminProperties stream during an admin install of
																					// a package with compressed source
																					
// property used for URT bootstrapping
#define IPROPNAME_CARRYINGNDP	TEXT("CARRYINGNDP")
#define IPROPVALUE__CARRYINGNDP_URTREINSTALL  TEXT("URTREINSTALL")   // reinstalling/ uninstalling core URT files
#define IPROPVALUE__CARRYINGNDP_URTUPGRADE  TEXT("URTUPGRADE")  // upgrading core URT files
																					
// property used for multiple instance support
#define IPROPNAME_MSINEWINSTANCE TEXT("MSINEWINSTANCE")
#define IPROPNAME_MSIINSTANCEGUID TEXT("MSIINSTANCEGUID")

// properties used for URL download reduction for admins
#define IPROPNAME_MSIPACKAGEDOWNLOADLOCALCOPY TEXT("MSIPACKAGEDOWNLOADLOCALCOPY")
#define IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY TEXT("MSIPATCHDOWNLOADLOCALCOPY")

#endif // (_WIN32_MSI >= 150)


// Properties used to populate Add/Remove Control Panel values 
#define IPROPNAME_ARPAUTHORIZEDCDFPREFIX  TEXT("ARPAUTHORIZEDCDFPREFIX")
#define IPROPNAME_ARPCOMMENTS             TEXT("ARPCOMMENTS")
#define IPROPNAME_ARPCONTACT              TEXT("ARPCONTACT")
#define IPROPNAME_ARPHELPLINK             TEXT("ARPHELPLINK")
#define IPROPNAME_ARPHELPTELEPHONE        TEXT("ARPHELPTELEPHONE")
#define IPROPNAME_ARPINSTALLLOCATION      TEXT("ARPINSTALLLOCATION")
#define IPROPNAME_ARPNOMODIFY             TEXT("ARPNOMODIFY")
#define IPROPNAME_ARPNOREMOVE             TEXT("ARPNOREMOVE")
#define IPROPNAME_ARPNOREPAIR             TEXT("ARPNOREPAIR")
#define IPROPNAME_ARPREADME               TEXT("ARPREADME")
#define IPROPNAME_ARPSIZE                 TEXT("ARPSIZE")
#define IPROPNAME_ARPSYSTEMCOMPONENT      TEXT("ARPSYSTEMCOMPONENT")
#define IPROPNAME_ARPURLINFOABOUT         TEXT("ARPURLINFOABOUT")
#define IPROPNAME_ARPURLUPDATEINFO        TEXT("ARPURLUPDATEINFO")
#if (_WIN32_MSI >=  110)
#define IPROPNAME_ARPPRODUCTICON          TEXT("ARPPRODUCTICON")
#endif //(_WIN32_MSI >=  110)

// Dynamic properties set by installer during install
#define IPROPNAME_INSTALLED        TEXT("Installed")        // product already installed
#define IPROPNAME_PRODUCTSTATE     TEXT("ProductState")     // state of product (installed,advertised,etc...)
#define IPROPNAME_PRESELECTED      TEXT("Preselected")      // selections made on command line
#define IPROPNAME_RESUME           TEXT("RESUME")           // resuming suspended install
#define IPROPNAME_UPDATESTARTED    TEXT("UpdateStarted")    // have begun to update system
#define IPROPNAME_PRODUCTID        TEXT("ProductID")        // the complete validated Product ID
#define IPROPNAME_OUTOFDISKSPACE   TEXT("OutOfDiskSpace")
#define IPROPNAME_OUTOFNORBDISKSPACE TEXT("OutOfNoRbDiskSpace")
#define IPROPNAME_COSTINGCOMPLETE  TEXT("CostingComplete")
#define IPROPNAME_SOURCEDIR        TEXT("SourceDir")        // source location - SET BY INSTALLER
#define IPROPNAME_REPLACEDINUSEFILES TEXT("ReplacedInUseFiles") // need reboot to completely install one or more files
#define IPROPNAME_PRIMARYFOLDER_PATH TEXT("PrimaryVolumePath")
#define IPROPNAME_PRIMARYFOLDER_SPACEAVAILABLE TEXT("PrimaryVolumeSpaceAvailable")
#define IPROPNAME_PRIMARYFOLDER_SPACEREQUIRED TEXT("PrimaryVolumeSpaceRequired")
#define IPROPNAME_PRIMARYFOLDER_SPACEREMAINING TEXT("PrimaryVolumeSpaceRemaining")
#define IPROPNAME_ISADMINPACKAGE   TEXT("IsAdminPackage")
#define IPROPNAME_ROLLBACKDISABLED TEXT("RollbackDisabled")
#define IPROPNAME_RESTRICTEDUSERCONTROL TEXT("RestrictedUserControl")

// Dynamic properties evaluated upon use
#define IPROPNAME_TIME             TEXT("Time")
#define IPROPNAME_DATE             TEXT("Date")
#define IPROPNAME_DATETIME         TEXT("DateTime")

// Hardware properties: set by installer at initialization
#define IPROPNAME_INTEL            TEXT("Intel")
#if (_WIN32_MSI >= 150)
#define IPROPNAME_AMD64            TEXT("AMD64")
#define IPROPNAME_INTEL64          TEXT("Intel64")
#else // (_WIN32_MSI >= 150)
#define IPROPNAME_IA64             TEXT("IA64")
#endif // (_WIN32_MSI >= 150)
#define IPROPNAME_TEXTHEIGHT       TEXT("TextHeight")
#define IPROPNAME_SCREENX          TEXT("ScreenX")
#define IPROPNAME_SCREENY          TEXT("ScreenY")
#define IPROPNAME_CAPTIONHEIGHT    TEXT("CaptionHeight")
#define IPROPNAME_BORDERTOP        TEXT("BorderTop")
#define IPROPNAME_BORDERSIDE       TEXT("BorderSide")
#define IPROPNAME_COLORBITS        TEXT("ColorBits")
#define IPROPNAME_PHYSICALMEMORY   TEXT("PhysicalMemory")
#define IPROPNAME_VIRTUALMEMORY    TEXT("VirtualMemory")
#if (_WIN32_MSI >= 150)
#define IPROPNAME_TEXTHEIGHT_CORRECTION  TEXT("TextHeightCorrection")
#endif // (_WIN32_MSI >= 150)

// Operating System properties: set by installer at initialization
#define IPROPNAME_VERSIONNT         TEXT("VersionNT")
#define IPROPNAME_VERSION9X         TEXT("Version9X")
#if (_WIN32_MSI >= 150)
#define IPROPNAME_VERSIONNT64       TEXT("VersionNT64")
#endif // (_WIN32_MSI >= 150)
#define IPROPNAME_WINDOWSBUILD      TEXT("WindowsBuild")
#define IPROPNAME_SERVICEPACKLEVEL  TEXT("ServicePackLevel")
#if (_WIN32_MSI >=  110)
#define IPROPNAME_SERVICEPACKLEVELMINOR TEXT("ServicePackLevelMinor")
#endif //(_WIN32_MSI >=  110)
#define IPROPNAME_SHAREDWINDOWS     TEXT("SharedWindows")
#define IPROPNAME_COMPUTERNAME      TEXT("ComputerName")
#define IPROPNAME_SHELLADVTSUPPORT  TEXT("ShellAdvtSupport")
#define IPROPNAME_OLEADVTSUPPORT    TEXT("OLEAdvtSupport")
#define IPROPNAME_SYSTEMLANGUAGEID  TEXT("SystemLanguageID")
#define IPROPNAME_TTCSUPPORT        TEXT("TTCSupport")
#define IPROPNAME_TERMSERVER		TEXT("TerminalServer")
#if (_WIN32_MSI >=  110)
#define IPROPNAME_REMOTEADMINTS		TEXT("RemoteAdminTS")
#define IPROPNAME_REDIRECTEDDLLSUPPORT TEXT("RedirectedDllSupport")
#endif //(_WIN32_MSI >=  110)
#if (_WIN32_MSI >= 150)
#define IPROPNAME_NTPRODUCTTYPE                   TEXT("MsiNTProductType")
#define IPROPNAME_NTSUITEBACKOFFICE               TEXT("MsiNTSuiteBackOffice")
#define IPROPNAME_NTSUITEDATACENTER               TEXT("MsiNTSuiteDataCenter")
#define IPROPNAME_NTSUITEENTERPRISE               TEXT("MsiNTSuiteEnterprise")
#define IPROPNAME_NTSUITESMALLBUSINESS            TEXT("MsiNTSuiteSmallBusiness")
#define IPROPNAME_NTSUITESMALLBUSINESSRESTRICTED  TEXT("MsiNTSuiteSmallBusinessRestricted")
#define IPROPNAME_NTSUITEPERSONAL                 TEXT("MsiNTSuitePersonal")
#define IPROPNAME_NTSUITEWEBSERVER                TEXT("MsiNTSuiteWebServer")
#define IPROPNAME_NETASSEMBLYSUPPORT              TEXT("MsiNetAssemblySupport")
#define IPROPNAME_WIN32ASSEMBLYSUPPORT            TEXT("MsiWin32AssemblySupport")
#endif // (_WIN32_MSI >= 150)


// User properties: set by installer at initialization
#define IPROPNAME_LOGONUSER        TEXT("LogonUser")
#define IPROPNAME_USERSID          TEXT("UserSID")
#define IPROPNAME_ADMINUSER        TEXT("AdminUser")
#define IPROPNAME_USERLANGUAGEID   TEXT("UserLanguageID")
#define IPROPNAME_PRIVILEGED       TEXT("Privileged")

// System folder properties: set by installer at initialization
#define IPROPNAME_WINDOWS_FOLDER   TEXT("WindowsFolder")
#define IPROPNAME_SYSTEM_FOLDER    TEXT("SystemFolder")
#define IPROPNAME_SYSTEM16_FOLDER  TEXT("System16Folder")
#define IPROPNAME_WINDOWS_VOLUME   TEXT("WindowsVolume")
#define IPROPNAME_TEMP_FOLDER      TEXT("TempFolder")
#define IPROPNAME_PROGRAMFILES_FOLDER TEXT("ProgramFilesFolder")
#define IPROPNAME_COMMONFILES_FOLDER TEXT("CommonFilesFolder")
#if (_WIN32_MSI >= 150)
#define IPROPNAME_SYSTEM64_FOLDER    TEXT("System64Folder")
#define IPROPNAME_PROGRAMFILES64_FOLDER TEXT("ProgramFiles64Folder")
#define IPROPNAME_COMMONFILES64_FOLDER TEXT("CommonFiles64Folder")
#endif // (_WIN32_MSI >= 150)
#define IPROPNAME_STARTMENU_FOLDER TEXT("StartMenuFolder")
#define IPROPNAME_PROGRAMMENU_FOLDER TEXT("ProgramMenuFolder")
#define IPROPNAME_STARTUP_FOLDER   TEXT("StartupFolder")
#define IPROPNAME_NETHOOD_FOLDER   TEXT("NetHoodFolder")
#define IPROPNAME_PERSONAL_FOLDER  TEXT("PersonalFolder")
#define IPROPNAME_SENDTO_FOLDER    TEXT("SendToFolder")
#define IPROPNAME_DESKTOP_FOLDER   TEXT("DesktopFolder")
#define IPROPNAME_TEMPLATE_FOLDER  TEXT("TemplateFolder")
#define IPROPNAME_FONTS_FOLDER     TEXT("FontsFolder")
#define IPROPNAME_FAVORITES_FOLDER TEXT("FavoritesFolder")
#define IPROPNAME_RECENT_FOLDER    TEXT("RecentFolder")
#define IPROPNAME_APPDATA_FOLDER   TEXT("AppDataFolder")
#define IPROPNAME_PRINTHOOD_FOLDER TEXT("PrintHoodFolder")
#if (_WIN32_MSI >=  110)
#define IPROPNAME_ADMINTOOLS_FOLDER TEXT("AdminToolsFolder")
#define IPROPNAME_COMMONAPPDATA_FOLDER TEXT("CommonAppDataFolder")
#define IPROPNAME_LOCALAPPDATA_FOLDER TEXT("LocalAppDataFolder")
#define IPROPNAME_MYPICTURES_FOLDER TEXT("MyPicturesFolder")
#endif //(_WIN32_MSI >=  110)

// Feature/Component installation properties: set on command-line
#define IPROPNAME_FEATUREADDLOCAL  TEXT("ADDLOCAL")
#define IPROPNAME_FEATUREADDSOURCE TEXT("ADDSOURCE")
#define IPROPNAME_FEATUREADDDEFAULT TEXT("ADDDEFAULT")
#define IPROPNAME_FEATUREREMOVE    TEXT("REMOVE")
#define IPROPNAME_FEATUREADVERTISE TEXT("ADVERTISE")
#define IPROPVALUE_FEATURE_ALL  TEXT("ALL")

#define IPROPNAME_COMPONENTADDLOCAL  TEXT("COMPADDLOCAL")
#define IPROPNAME_COMPONENTADDSOURCE TEXT("COMPADDSOURCE")
#define IPROPNAME_COMPONENTADDDEFAULT TEXT("COMPADDDEFAULT")

#define IPROPNAME_FILEADDLOCAL     TEXT("FILEADDLOCAL")
#define IPROPNAME_FILEADDSOURCE    TEXT("FILEADDSOURCE")
#define IPROPNAME_FILEADDDEFAULT   TEXT("FILEADDDEFAULT")

#define IPROPNAME_REINSTALL        TEXT("REINSTALL")
#define IPROPNAME_REINSTALLMODE    TEXT("REINSTALLMODE")
#define IPROPNAME_PROMPTROLLBACKCOST  TEXT("PROMPTROLLBACKCOST")
#define IPROPVALUE_RBCOST_PROMPT      TEXT("P")
#define IPROPVALUE_RBCOST_SILENT      TEXT("D")
#define IPROPVALUE_RBCOST_FAIL        TEXT("F")

// Property for custom actions to communicate
#define IPROPNAME_CUSTOMACTIONDATA     TEXT("CustomActionData")

//__________________________________________________________________________
//
// TOP-LEVEL ACTION NAMES
//__________________________________________________________________________

#define IACTIONNAME_INSTALL        TEXT("INSTALL")
#define IACTIONNAME_ADVERTISE      TEXT("ADVERTISE")
#define IACTIONNAME_ADMIN          TEXT("ADMIN")
#define IACTIONNAME_SEQUENCE       TEXT("SEQUENCE")
#define IACTIONNAME_COLLECTUSERINFO TEXT("CollectUserInfo")
#define IACTIONNAME_FIRSTRUN       TEXT("FirstRun")

//__________________________________________________________________________
//
//  SummaryInformation property stream property IDs
//__________________________________________________________________________

#undef PID_SECURITY // defined as ( 0x80000002 ) in objidl.h, need to redefine here

// standard property definitions, from OLE2 documentation
#define PID_DICTIONARY  ( 0 )// integer count + array of entries
#define PID_CODEPAGE  ( 0x1 )// short integer
#define PID_TITLE         2  // string
#define PID_SUBJECT       3  // string
#define PID_AUTHOR        4  // string
#define PID_KEYWORDS      5  // string
#define PID_COMMENTS      6  // string
#define PID_TEMPLATE      7  // string
#define PID_LASTAUTHOR    8  // string
#define PID_REVNUMBER     9  // string
#define PID_EDITTIME     10  // datatime
#define PID_LASTPRINTED  11  // datetime
#define PID_CREATE_DTM   12  // datetime
#define PID_LASTSAVE_DTM 13  // datetime
#define PID_PAGECOUNT    14  // integer 
#define PID_WORDCOUNT    15  // integer 
#define PID_CHARCOUNT    16  // integer 
#define PID_THUMBNAIL    17  // clipboard format + metafile/bitmap (not supported)
#define PID_APPNAME      18  // string
#define PID_SECURITY     19  // integer

// PIDs given specific meanings for Installer
#define PID_MSIVERSION     PID_PAGECOUNT  // integer, Installer version number (major*100+minor)
#define PID_MSISOURCE      PID_WORDCOUNT  // integer, type of file image, short/long, media/tree
#define PID_MSIRESTRICT    PID_CHARCOUNT  // integer, transform restrictions

//__________________________________________________________________________
//
// INSTALLER DATABASE INTEGER COLUMN DEFINITIONS
//__________________________________________________________________________

// BBControl.Attributes
// Control.Attributes
enum msidbControlAttributes
{
	msidbControlAttributesVisible           = 0x00000001,
	msidbControlAttributesEnabled           = 0x00000002,
	msidbControlAttributesSunken            = 0x00000004,
	msidbControlAttributesIndirect          = 0x00000008,
	msidbControlAttributesInteger           = 0x00000010,
	msidbControlAttributesRTLRO             = 0x00000020,
	msidbControlAttributesRightAligned      = 0x00000040,
	msidbControlAttributesLeftScroll        = 0x00000080,
	msidbControlAttributesBiDi              = msidbControlAttributesRTLRO |
	                                          msidbControlAttributesRightAligned |
										               msidbControlAttributesLeftScroll,
	
	// Text controls
	msidbControlAttributesTransparent       = 0x00010000,
	msidbControlAttributesNoPrefix          = 0x00020000,
	msidbControlAttributesNoWrap            = 0x00040000,
	msidbControlAttributesFormatSize        = 0x00080000,
	msidbControlAttributesUsersLanguage     = 0x00100000,

	// Edit controls
	msidbControlAttributesMultiline         = 0x00010000,
#if (_WIN32_MSI >=  110)
	msidbControlAttributesPasswordInput     = 0x00200000,
#endif //(_WIN32_MSI >=  110)
	
	// ProgressBar controls
	msidbControlAttributesProgress95        = 0x00010000,
	
	// VolumeSelectCombo and DirectoryCombo controls
	msidbControlAttributesRemovableVolume   = 0x00010000,
	msidbControlAttributesFixedVolume       = 0x00020000,
	msidbControlAttributesRemoteVolume      = 0x00040000,
	msidbControlAttributesCDROMVolume       = 0x00080000,
	msidbControlAttributesRAMDiskVolume     = 0x00100000,
	msidbControlAttributesFloppyVolume      = 0x00200000,
	// VolumeCostList controls
	msidbControlShowRollbackCost            = 0x00400000,
	
	// ListBox and ComboBox controls
	msidbControlAttributesSorted            = 0x00010000,
	msidbControlAttributesComboList         = 0x00020000,
	
	// picture button controls
	msidbControlAttributesImageHandle       = 0x00010000,
	msidbControlAttributesPushLike          = 0x00020000,
	msidbControlAttributesBitmap            = 0x00040000,
	msidbControlAttributesIcon              = 0x00080000,
	msidbControlAttributesFixedSize         = 0x00100000,
	msidbControlAttributesIconSize16        = 0x00200000,
	msidbControlAttributesIconSize32        = 0x00400000,
	msidbControlAttributesIconSize48        = 0x00600000,
	
	// RadioButton controls
	msidbControlAttributesHasBorder         = 0x01000000,
};

// CompLocator.Type
// IniLocator.Type
// RegLocator.Type
typedef enum _msidbLocatorType
{
	msidbLocatorTypeDirectory = 0x00000000,
	msidbLocatorTypeFileName  = 0x00000001,
#if (_WIN32_MSI >=  110)
	msidbLocatorTypeRawValue  = 0x00000002,
#endif //(_WIN32_MSI >=  110)
#if (_WIN32_MSI >= 150)
	msidbLocatorType64bit     = 0x00000010,
#endif //(_WIN32_MSI >= 150)
} msidbLocatorType;

// Component.Attributes
enum msidbComponentAttributes
{
	msidbComponentAttributesLocalOnly          = 0x00000000,
	msidbComponentAttributesSourceOnly         = 0x00000001,
	msidbComponentAttributesOptional           = 0x00000002, // local or source
	msidbComponentAttributesRegistryKeyPath    = 0x00000004, // KeyPath is key to Registry table
	msidbComponentAttributesSharedDllRefCount  = 0x00000008, // increment SharedDll count
	msidbComponentAttributesPermanent          = 0x00000010, // never uninstall component
	msidbComponentAttributesODBCDataSource     = 0x00000020, // KeyFile is key to ODBCDataSource table
	msidbComponentAttributesTransitive         = 0x00000040, // Can transition to/from installed/uninstalled based on changing conditional
	msidbComponentAttributesNeverOverwrite     = 0x00000080, // dont stomp over existing component if key path exists (file/ regkey)
#if (_WIN32_MSI >= 150)
	msidbComponentAttributes64bit              = 0x00000100, // designates a 64-bit component; 32-bit if missing.
#endif // (_WIN32_MSI >= 150)
};

#if (_WIN32_MSI >= 150)
// Assembly.Attributes
enum msidbAssemblyAttributes
{
	msidbAssemblyAttributesURT   = 0x00000000,
	msidbAssemblyAttributesWin32 = 0x00000001,
};
#endif // (_WIN32_MSI >= 150)

// CustomAction.Type
enum msidbCustomActionType
{
	// executable types
	msidbCustomActionTypeDll              = 0x00000001,  // Target = entry point name
	msidbCustomActionTypeExe              = 0x00000002,  // Target = command line args
	msidbCustomActionTypeTextData         = 0x00000003,  // Target = text string to be formatted and set into property
	msidbCustomActionTypeJScript          = 0x00000005,  // Target = entry point name, null if none to call
	msidbCustomActionTypeVBScript         = 0x00000006,  // Target = entry point name, null if none to call
	msidbCustomActionTypeInstall          = 0x00000007,  // Target = property list for nested engine initialization

	// source of code
	msidbCustomActionTypeBinaryData       = 0x00000000,  // Source = Binary.Name, data stored in stream
	msidbCustomActionTypeSourceFile       = 0x00000010,  // Source = File.File, file part of installation
	msidbCustomActionTypeDirectory        = 0x00000020,  // Source = Directory.Directory, folder containing existing file
	msidbCustomActionTypeProperty         = 0x00000030,  // Source = Property.Property, full path to executable

	// return processing                  // default is syncronous execution, process return code
	msidbCustomActionTypeContinue         = 0x00000040,  // ignore action return status, continue running
	msidbCustomActionTypeAsync            = 0x00000080,  // run asynchronously
	
	// execution scheduling flags               // default is execute whenever sequenced
	msidbCustomActionTypeFirstSequence    = 0x00000100,  // skip if UI sequence already run
	msidbCustomActionTypeOncePerProcess   = 0x00000200,  // skip if UI sequence already run in same process
	msidbCustomActionTypeClientRepeat     = 0x00000300,  // run on client only if UI already run on client
	msidbCustomActionTypeInScript         = 0x00000400,  // queue for execution within script
	msidbCustomActionTypeRollback         = 0x00000100,  // in conjunction with InScript: queue in Rollback script
	msidbCustomActionTypeCommit           = 0x00000200,  // in conjunction with InScript: run Commit ops from script on success

	// security context flag, default to impersonate as user, valid only if InScript
	msidbCustomActionTypeNoImpersonate    = 0x00000800,  // no impersonation, run in system context
#if (_WIN32_MSI >= 150)
	msidbCustomActionTypeTSAware          = 0x00004000,  // impersonate for per-machine installs on TS machines
#endif // (_WIN32_MSI >= 150)

#if (_WIN32_MSI >= 150)
	// script requires 64bit process
	msidbCustomActionType64BitScript      = 0x00001000,  // script should run in 64bit process

	// don't record the contents of the Target field in the log file.
	msidbCustomActionTypeHideTarget       = 0x00002000,
#endif // (_WIN32_MSI >= 150)
};

// Dialog.Attributes
enum msidbDialogAttributes
{
	msidbDialogAttributesVisible          = 0x00000001,
	msidbDialogAttributesModal            = 0x00000002,
	msidbDialogAttributesMinimize         = 0x00000004,
	msidbDialogAttributesSysModal         = 0x00000008,
	msidbDialogAttributesKeepModeless     = 0x00000010,
	msidbDialogAttributesTrackDiskSpace   = 0x00000020,
	msidbDialogAttributesUseCustomPalette = 0x00000040,
	msidbDialogAttributesRTLRO            = 0x00000080,
	msidbDialogAttributesRightAligned     = 0x00000100,
	msidbDialogAttributesLeftScroll       = 0x00000200,
	msidbDialogAttributesBiDi             = msidbDialogAttributesRTLRO |
										             msidbDialogAttributesRightAligned |
										             msidbDialogAttributesLeftScroll,
	msidbDialogAttributesError            = 0x00010000,
};

// Feature.Attributes
enum msidbFeatureAttributes
{
	msidbFeatureAttributesFavorLocal            = 0x00000000,
	msidbFeatureAttributesFavorSource           = 0x00000001,
	msidbFeatureAttributesFollowParent          = 0x00000002,
	msidbFeatureAttributesFavorAdvertise        = 0x00000004,
	msidbFeatureAttributesDisallowAdvertise     = 0x00000008,
	msidbFeatureAttributesUIDisallowAbsent      = 0x00000010,
	msidbFeatureAttributesNoUnsupportedAdvertise= 0x00000020,
};

// File.Attributes
enum msidbFileAttributes
{
	msidbFileAttributesReadOnly       = 0x00000001,
	msidbFileAttributesHidden         = 0x00000002,
	msidbFileAttributesSystem         = 0x00000004,
	msidbFileAttributesReserved0      = 0x00000008, // Internal use only - must be 0
	msidbFileAttributesReserved1      = 0x00000040, // Internal use only - must be 0
	msidbFileAttributesReserved2      = 0x00000080, // Internal use only - must be 0
	msidbFileAttributesReserved3      = 0x00000100, // Internal use only - must be 0
	msidbFileAttributesVital          = 0x00000200,
	msidbFileAttributesChecksum       = 0x00000400,
	msidbFileAttributesPatchAdded     = 0x00001000, // Internal use only - set by patches
	msidbFileAttributesNoncompressed  = 0x00002000,
	msidbFileAttributesCompressed     = 0x00004000,
	msidbFileAttributesReserved4      = 0x00008000, // Internal use only - must be 0
};

// IniFile.Action
// RemoveIniFile.Action
typedef enum _msidbIniFileAction
{
	msidbIniFileActionAddLine    = 0x00000000,
	msidbIniFileActionCreateLine = 0x00000001,
	msidbIniFileActionRemoveLine = 0x00000002,
	msidbIniFileActionAddTag     = 0x00000003,
	msidbIniFileActionRemoveTag  = 0x00000004,
} msidbIniFileAction;

// MoveFile.Options
enum msidbMoveFileOptions
{
	msidbMoveFileOptionsMove = 0x00000001,
};

// ODBCDataSource.Registration
typedef enum _msidbODBCDataSourceRegistration
{
	msidbODBCDataSourceRegistrationPerMachine  = 0x00000000,
	msidbODBCDataSourceRegistrationPerUser     = 0x00000001,
} msidbODBCDataSourceRegistration;

#if (_WIN32_MSI >=  110)

// Class.Attributes
enum msidbClassAttributes
{
	msidbClassAttributesRelativePath  = 0x00000001,
};

#endif //(_WIN32_MSI >=  110)

// Patch.Attributes
enum msidbPatchAttributes
{
	msidbPatchAttributesNonVital = 0x00000001,
};

// Registry.Root
// RegLocator.Root
// RemoveRegistry.Root
enum msidbRegistryRoot
{
	msidbRegistryRootClassesRoot  = 0,
	msidbRegistryRootCurrentUser  = 1,
	msidbRegistryRootLocalMachine = 2,
	msidbRegistryRootUsers        = 3,
};

// RemoveFile.InstallMode
enum msidbRemoveFileInstallMode
{
	msidbRemoveFileInstallModeOnInstall = 0x00000001,
	msidbRemoveFileInstallModeOnRemove  = 0x00000002,
	msidbRemoveFileInstallModeOnBoth    = 0x00000003,
};

// ServiceControl.Event
enum msidbServiceControlEvent
{
	msidbServiceControlEventStart             = 0x00000001,
	msidbServiceControlEventStop              = 0x00000002,
	msidbServiceControlEventDelete            = 0x00000008,
	msidbServiceControlEventUninstallStart    = 0x00000010,
	msidbServiceControlEventUninstallStop     = 0x00000020,
	msidbServiceControlEventUninstallDelete   = 0x00000080,
};

// ServiceInstall.ErrorControl
enum msidbServiceInstallErrorControl
{
	msidbServiceInstallErrorControlVital = 0x00008000,
};

// TextStyle.StyleBits
enum msidbTextStyleStyleBits
{
	msidbTextStyleStyleBitsBold         = 0x00000001,
	msidbTextStyleStyleBitsItalic       = 0x00000002,
	msidbTextStyleStyleBitsUnderline    = 0x00000004,
	msidbTextStyleStyleBitsStrike       = 0x00000008,
};

#if (_WIN32_MSI >=  110)

// Upgrade.Attributes
enum msidbUpgradeAttributes
{
	msidbUpgradeAttributesMigrateFeatures     = 0x00000001,
	msidbUpgradeAttributesOnlyDetect          = 0x00000002,
	msidbUpgradeAttributesIgnoreRemoveFailure = 0x00000004,
	msidbUpgradeAttributesVersionMinInclusive = 0x00000100,
	msidbUpgradeAttributesVersionMaxInclusive = 0x00000200,
	msidbUpgradeAttributesLanguagesExclusive  = 0x00000400,
};

#endif //(_WIN32_MSI >=  110)


//__________________________________________________________________________
//
// SUMMARY INFORMATION PROPERTY DEFINITIONS
//__________________________________________________________________________

enum msidbSumInfoSourceType
{
	msidbSumInfoSourceTypeSFN            = 0x00000001,  // source uses short filenames
	msidbSumInfoSourceTypeCompressed     = 0x00000002,  // source is compressed
	msidbSumInfoSourceTypeAdminImage     = 0x00000004,  // source is an admin image
};

#endif // __MSIDEFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\mstask\idletask.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idletask.h

Abstract:

    This module contains the API and type declaration to support
    idle/background tasks.

Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLETASK_H_
#define _IDLETASK_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Idle task identifier, used as aid in tracking registered idle
// tasks, especially for debugging. Contact code's maintainers if you
// wish to use idletask functionality.
//

// FUTURE-2002/03/26-ScottMa -- Consider applying the [v1_enum] MIDL
//   attribute to the following enumeration for increased efficiency.

typedef enum _IT_IDLE_TASK_ID {
    ItPrefetcherMaintenanceIdleTaskId,
    ItSystemRestoreIdleTaskId,
    ItOptimalDiskLayoutTaskId,
    ItPrefetchDirectoryCleanupTaskId,
    ItDiskMaintenanceTaskId,
    ItHelpSvcDataCollectionTaskId,
    ItMaxIdleTaskId
} IT_IDLE_TASK_ID, *PIT_IDLE_TASK_ID;

#ifndef MIDL_PASS

DWORD
RegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    );

// ISSUE-2002/03/26-ScottMa -- The parameters to the UnregisterIdleTask
//   function should be IN/OUT so that they can be set to NULL be the client
//   side function after the RPC completes.  This helps reduce the risk of
//   the app accidentally double-unregistering.

DWORD
UnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent
    );

DWORD
ProcessIdleTasks (
    VOID
    );

#endif // MIDL_PASS

#ifdef __cplusplus
}
#endif

#endif // _IDLETASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published\wmi\makefile.inc ===
$(O)\wmicore.bmf: wmicore.mof

$(O)\wmidata.h : $(O)\wmicore.bmf
    wmimofck -h$@ $?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\published_tests\encryptedstringtest\test-encryptedstring.cpp ===
// test the published EncryptedString class

#include <windows.h>

#include <time.h>
#include <stdlib.h>
#include <stdio.h>

// Make sure we have an ASSERT() function defined for our test.
#ifndef ASSERT

#ifdef NDEBUG
#undef NDEBUG
#endif 

#include <assert.h>
#define ASSERT assert

#endif


// Uncomment the #define if you want to trace the test harness.
#ifndef TRACE
//#define TRACE
#endif

class ScopeTracer
{
public:
    ScopeTracer(const char* message)
        : m_message(NULL)
    {
#ifdef TRACE
        if (message)
        {
            m_message = new char[strlen(message) + 1];
            strcpy(m_message, message);
        }
        else
        {
            m_message = new char[1];
            m_message[0] = NULL;
        }

        PrintIndents();
        printf("->%s\n", m_message);
        ++g_indentLevel;
#else
        // Make the compiler happy.
        message = NULL;
#endif
    }

    ~ScopeTracer(void)
    {
#ifdef TRACE
        --g_indentLevel;
        PrintIndents();
        printf("<-%s\n", m_message);

        delete [] m_message;
#endif
    }

    unsigned int GetIndentLevel(void) const
    {
        return g_indentLevel;
    }

private:

    void PrintIndents(void)
    {
        for (unsigned int level = 0; 
            level < g_indentLevel;
            ++level)
        {
            printf("   ");
        }
    }

    char* m_message;

    static unsigned int g_indentLevel;
};

unsigned int ScopeTracer::g_indentLevel = 0;

#include "EncryptedString.hpp"

#include <list>
using namespace std;

HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"test";

//DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;

const size_t MAX_CHARACTER_COUNT = 2047;

void
TestEmptyness(const EncryptedString& empty)
{
   ScopeTracer scope("TestEmptyness");

   ASSERT(empty.IsEmpty());
   ASSERT(empty.GetLength() == 0);

   // the cleartext of an empty instance should also be empty

   WCHAR* emptyClear = empty.GetClearTextCopy();

   ASSERT(emptyClear);

   ASSERT(*emptyClear == 0);

   empty.DestroyClearTextCopy(emptyClear);
}



void
TestEmptyStrings()
{
   ScopeTracer scope("TestEmptyStrings");
   
   EncryptedString empty1;

   TestEmptyness(empty1);
   
   // copies of empty strings are themselves empty
   
   EncryptedString empty2(empty1);

   // source should still be empty
   
   TestEmptyness(empty1);
   TestEmptyness(empty2);

   EncryptedString empty3;
   
   TestEmptyness(empty3);

   empty3 = empty2;
   
   // source should still be empty
   
   TestEmptyness(empty2);
   TestEmptyness(empty3);

   empty3 = empty1;

   TestEmptyness(empty1);
   TestEmptyness(empty2);
   TestEmptyness(empty3);
   
   // strings built from empty strings should be empty

   EncryptedString empty4;

   TestEmptyness(empty4);

   empty4.Encrypt(L"");
   
   TestEmptyness(empty4);

   // a string made from an empty string is still empty when the source
   // is made non-empty

   EncryptedString empty5;
   EncryptedString empty6(empty5);

   TestEmptyness(empty5);
   TestEmptyness(empty6);

   empty5.Encrypt(L"not empty any more");

   ASSERT(!empty5.IsEmpty());
   ASSERT(empty5.GetLength() != 0);
   TestEmptyness(empty6);

   // A cleared string is empty

   EncryptedString empty7;
   empty7.Encrypt(L"some text");
   empty7.Clear();
   TestEmptyness(empty7);
   
   // empty strings are equal

   ASSERT(empty1 == empty1);
   ASSERT(empty1 == empty2);
   ASSERT(empty1 == empty3);
   ASSERT(empty1 == empty4);
   ASSERT(empty1 == empty6);      
   ASSERT(empty1 == empty7);      
   ASSERT(empty2 == empty1);
   ASSERT(empty2 == empty2);     
   ASSERT(empty2 == empty3);
   ASSERT(empty2 == empty4);
   ASSERT(empty2 == empty6);
   ASSERT(empty2 == empty7);
   ASSERT(empty3 == empty1);
   ASSERT(empty3 == empty2);
   ASSERT(empty3 == empty3);
   ASSERT(empty3 == empty4);
   ASSERT(empty3 == empty6);
   ASSERT(empty3 == empty7);
   ASSERT(empty4 == empty1);   
   ASSERT(empty4 == empty2);   
   ASSERT(empty4 == empty3);   
   ASSERT(empty4 == empty4);
   ASSERT(empty4 == empty6);
   ASSERT(empty4 == empty7);
   ASSERT(empty6 == empty1);
   ASSERT(empty6 == empty2);
   ASSERT(empty6 == empty3);
   ASSERT(empty6 == empty4);
   ASSERT(empty6 == empty6);
   ASSERT(empty6 == empty7);
   ASSERT(empty7 == empty1);
   ASSERT(empty7 == empty2);
   ASSERT(empty7 == empty3);
   ASSERT(empty7 == empty4);
   ASSERT(empty7 == empty6);
   ASSERT(empty7 == empty7);
}



WCHAR*
MakeRandomString(size_t length)
{
   //LOG_FUNCTION2(MakeRandomString, String::format(L"%1!d!", length));

   WCHAR* result = new WCHAR[length + 1];

   for (size_t i = 0; i < length; ++i)
   {
      // 32 = space, the lowest printable character
      
      int r1 = rand() % 0xFFEE;

      // careful not to use an expression as a parameter to max...
      
      int r2 = max(32, r1);

      ASSERT(r2);
      ASSERT(r2 >= 32);
      ASSERT(r2 < 0xFFEE);
      
      result[i] = (WCHAR) r2;
      ASSERT(result[i]);
   }

   result[length] = 0;

   return result;
}



void
TestEncryption(const EncryptedString& s, const WCHAR* sourceClearText)
{
   ScopeTracer scope("TestEncryption");

   // decrypt s, compare it to sourceClearText

   WCHAR* clearText = s.GetClearTextCopy();

   // the decryption shouldn't fail (barring out-of-memory);
   
   ASSERT(clearText);
   ASSERT(wcscmp(clearText, sourceClearText) == 0);

   s.DestroyClearTextCopy(clearText);
}



void
TestEncryptionForStringOfLengthN(size_t length)
{
   //LOG_FUNCTION2(TestEncryptionForStringOfLengthN, String::format(L"%1!d!", length));
   ASSERT(length <= MAX_CHARACTER_COUNT);
   
   WCHAR* source = MakeRandomString(length);

   EncryptedString s;
   s.Encrypt(source);
   
   TestEncryption(s, source);

   EncryptedString s1(s);
   TestEncryption(s1, source);
   
   EncryptedString s2;
   s2 = s;

   TestEncryption(s2, source);

   delete[] source;
}



void
TestEncryptionFidelity()
{
   ScopeTracer scope("TestEncryptionFidelity");

   // do we get out what we put in?

   srand(time(0));
   
   // test increasing lengths of random strings
   
   for (
      size_t length = 0;
      length <= MAX_CHARACTER_COUNT;
      ++length)
   {
      TestEncryptionForStringOfLengthN(length);
   }

   // test decreasing lengths of random strings
   
   for (
      size_t length = MAX_CHARACTER_COUNT;
      length != 0;
      --length)
   {
      TestEncryptionForStringOfLengthN(length);
   }

   // test strings of random length, with lots of outstanding encrypted
   // strings

   typedef std::list<EncryptedString*> ESPList;
   ESPList strings;
   
   for (
      int count = 0;
      count < 1000;
      ++count)
   {
      size_t length = rand() % MAX_CHARACTER_COUNT;

      WCHAR* source = MakeRandomString(length);

      EncryptedString* ps = new EncryptedString;
      strings.push_back(ps);
      
      ps->Encrypt(source);
         
      TestEncryption(*ps, source);

      // make a copy via copy ctor
      
      EncryptedString* ps1 = new EncryptedString(*ps);
      strings.push_back(ps1);
      
      TestEncryption(*ps1, source);

      // make a copy via operator =
         
      EncryptedString* ps2 = new EncryptedString;
      strings.push_back(ps2);

      *ps2 = *ps;
   
      TestEncryption(*ps2, source);
   
      delete[] source;
   }
   
   for (
      ESPList::iterator i = strings.begin();
      i != strings.end();
      ++i)
   {
      (*i)->Clear();
      TestEmptyness(**i);
      delete *i;
   }
}



void
TestClearTextCopying()
{
   ScopeTracer scope("TestClearTextCopying");

   // make a bunch of copies, make sure the count balances

   typedef char foo[2];


   // An encrypted string and the source string used to build it.
   
   typedef
      std::pair<EncryptedString*, WCHAR*>
      EncryptedAndSourcePair;

   // A list of results from EncryptedString::GetClearTextCopy
      
   typedef std::list<WCHAR*> ClearTextList;

   // A tuple of the encrypted string, its source string, and a list
   // of clear-text copies made from the encrypted string
   
   typedef
      std::pair<EncryptedAndSourcePair*, ClearTextList*>
      MasterAndClearTextCopiesPair;

   // A list of the above tuples.
      
   typedef
      std::list<MasterAndClearTextCopiesPair*>
      MasterAndCopiesList;

   MasterAndCopiesList mcList;
   
   for (int count = 0; count < 1000; ++count)
   {
      // Make a random source string
      
      size_t length = rand() % MAX_CHARACTER_COUNT;
      WCHAR* source = MakeRandomString(length);

      // Make an encrypted string from it
      
      EncryptedString* ps = new EncryptedString;
      ps->Encrypt(source);

      // Make a pair of the encrypted string and its source string

      EncryptedAndSourcePair* esp = new EncryptedAndSourcePair(ps, source);
      
      // Make a list of clear-text copies of the encrypted string

      ClearTextList* ctList = new ClearTextList;

      // Make a master and copies pair

      MasterAndClearTextCopiesPair* mcPair = new MasterAndClearTextCopiesPair(esp, ctList);

      // add the master and copies pair to the master and copies list

      mcList.push_back(mcPair);

      int copyMax = max(1, rand() % 50);
      for (int copyCount = 0; copyCount < copyMax; ++copyCount)
      {
         // make some copies

         ctList->push_back(ps->GetClearTextCopy());
      }
   }

   for (
      MasterAndCopiesList::iterator i = mcList.begin();
      i != mcList.end();
      ++i)
   {
      EncryptedAndSourcePair* esp = (*i)->first;
      ClearTextList* ctList = (*i)->second;

      // delete each element of the ClearTextList

      for (
         ClearTextList::iterator j = ctList->begin();
         j != ctList->end();
         ++j)
      {
         // all copies should be identical

         ASSERT(wcscmp(esp->second, *j) == 0);

         esp->first->DestroyClearTextCopy(*j);
      }
      
      // delete the ClearTextList

      delete ctList;
      
      // delete the encrypted string

      delete esp->first;

      // delete the source string;

      delete[] esp->second;

      // delete the encrypted string/source string pair

      delete esp;

      // delete the master and copies pair

      delete *i;
   }
}



void
TestAssignment()
{
   ScopeTracer scope("TestAssignment");
}



void
TestEquality(const EncryptedString& s, const EncryptedString& s1, size_t length)
{
   ScopeTracer scope("TestEquality");

   // a string is equal to itself

   ASSERT(s == s);
   ASSERT(s1 == s1);

   // a string is equal to a copy of itself

   ASSERT(s1 == s);

   // a copy is equal to its source
   
   ASSERT(s == s1);

   // a copy is equal to itself

   ASSERT(s1 == s1);
   
   // a copy is the same length as its source

   ASSERT(s1.GetLength() == length);
   ASSERT(s.GetLength() == length);
   
   // a string is the same length as its copy

   ASSERT(s1.GetLength() == s.GetLength());
}



void
TestEqualityForStringOfLengthN(size_t length)
{
   //LOG_FUNCTION2(TestEncryptionForStringOfLengthN, String::format(L"%1!d!", length));
   ASSERT(length <= MAX_CHARACTER_COUNT);
   
   WCHAR* source = MakeRandomString(length);

   EncryptedString s;
   s.Encrypt(source);
   ASSERT(s.GetLength() == length);
   
   EncryptedString s1(s);
   ASSERT(s1.GetLength() == length);

   TestEquality(s, s1, length);
   
   EncryptedString s2;
   s2 = s;

   TestEquality(s, s2, length);
   TestEquality(s1, s2, length);
      
   // a copy is not equal to its source when the source is changed

   s.Encrypt(L"Something else...");
   ASSERT(s != s1);
   ASSERT(s != s2);
   ASSERT(s2 != s);
   ASSERT(s1 != s);
   
   TestEquality(s1, s2, length);
   
   delete[] source;
}
   


void
DoEqualityTests()
{
   ScopeTracer scope("DoEqualityTests");

   for (
      size_t length = 0;
      length <= MAX_CHARACTER_COUNT;
      ++length)
   {
      TestEqualityForStringOfLengthN(length);
   }
   
}



void
TestInequality()
{
   ScopeTracer scope("TestInequality");
}



void
TestBoundaries()
{
   ScopeTracer scope("TestBoundaries");
}

      

void
TestLegitimateUse()
{
   ScopeTracer scope("TestLegitimateUse");


   TestEmptyStrings();

   TestClearTextCopying();

   TestEncryptionFidelity();

   TestAssignment();

   DoEqualityTests();

   TestInequality();

   TestBoundaries();
}



void
TestIlllegitimateUse()
{
   ScopeTracer scope("TestIlllegitimateUse");
   
   // make strings that are too long,
   // make unbalanced cleartext copyies (call Destroy too many times, not enough times)   
}



VOID
_cdecl
main(int, char **)
{
   ScopeTracer scope("main");

   TestLegitimateUse();
   TestIlllegitimateUse();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\admincustomizer.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       AdminCustomizer.cxx
//
//  Contents:   Implementation of class to provide default customization
//              of queries by adding objects and offering prefix searching
//              of those objects.
//
//  Classes:    CAdminCustomizer
//
//  History:    03-10-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::CAdminCustomizer
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing object picker instance
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAdminCustomizer::CAdminCustomizer(
    const CObjectPicker &rop):
        m_rop(rop)
{
    TRACE_CONSTRUCTOR(CAdminCustomizer);

    //REVIEWED-2002-02-19-lucios
    ZeroMemory(m_aSidInfo, sizeof m_aSidInfo);

    //REVIEWED-2002-02-19-lucios. We are not setting the ACL in an object 
    // to use SECURITY_WORLD_SID_AUTHORITY. These sids are the default sids
    // for well known security principals to be returned in downlevel domains.
    SID_IDENTIFIER_AUTHORITY siiWorld   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siiNT      = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siiCreator = SECURITY_CREATOR_SID_AUTHORITY;

    m_aSidInfo[0].sii = siiWorld;
    m_aSidInfo[0].rid = SECURITY_WORLD_RID;

    m_aSidInfo[1].sii = siiNT;
    m_aSidInfo[1].rid = SECURITY_AUTHENTICATED_USER_RID;

    m_aSidInfo[2].sii = siiNT;
    m_aSidInfo[2].rid = SECURITY_ANONYMOUS_LOGON_RID;

    m_aSidInfo[3].sii = siiNT;
    m_aSidInfo[3].rid = SECURITY_BATCH_RID;

    m_aSidInfo[4].sii = siiCreator;
    m_aSidInfo[4].rid = SECURITY_CREATOR_OWNER_RID;

    m_aSidInfo[5].sii = siiCreator;
    m_aSidInfo[5].rid = SECURITY_CREATOR_GROUP_RID;

    m_aSidInfo[6].sii = siiNT;
    m_aSidInfo[6].rid = SECURITY_DIALUP_RID;

    m_aSidInfo[7].sii = siiNT;
    m_aSidInfo[7].rid = SECURITY_INTERACTIVE_RID;

    m_aSidInfo[8].sii = siiNT;
    m_aSidInfo[8].rid = SECURITY_NETWORK_RID;

    m_aSidInfo[9].sii = siiNT;
    m_aSidInfo[9].rid = SECURITY_SERVICE_RID;

    m_aSidInfo[10].sii = siiNT;
    m_aSidInfo[10].rid = SECURITY_LOCAL_SYSTEM_RID;

    m_aSidInfo[11].sii = siiNT;
    m_aSidInfo[11].rid = SECURITY_TERMINAL_SERVER_RID;

    m_aSidInfo[12].sii = siiNT;
    m_aSidInfo[12].rid = SECURITY_LOCAL_SERVICE_RID;

    m_aSidInfo[13].sii = siiNT;
    m_aSidInfo[13].rid = SECURITY_NETWORK_SERVICE_RID;

    m_aSidInfo[14].sii = siiNT;
    m_aSidInfo[14].rid = SECURITY_REMOTE_LOGON_RID;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::~CAdminCustomizer
//
//  Synopsis:   dtor
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAdminCustomizer::~CAdminCustomizer()
{
    TRACE_DESTRUCTOR(CAdminCustomizer);

    for (ULONG i = 0; i < ARRAYLEN(m_aSidInfo); i++)
    {
        if (m_aSidInfo[i].psid)
        {
            FreeSid(m_aSidInfo[i].psid);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Interface:  ICustomizeDsBrowser
//
//  Member:     CAdminCustomizer::AddObjects
//
//  Synopsis:   Adds whatever custom objects caller asked for via flags
//              such as DSOP_FILTER_WELL_KNOWN_PRINCIPALS or
//              DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER.
//
//  Arguments:  [hwnd]         - for bind
//              [ForScope]     - current scope
//              [pdsolMatches] - filled with objects to add
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::AddObjects(
    HWND hwnd,
    const CScope &ForScope,
    CDsObjectList *pdsolMatches) const
{
    if (IsUplevel(ForScope))
    {
        _GetUplevelAddition(hwnd, ForScope.GetID(), pdsolMatches);
    }
    else
    {
        _GetDownlevelAddition(pdsolMatches);
    }
}

#define ADD_IF_MATCHES(x)      _AddDownlevelIfMatches(idOwningScope,\
                                                      (x),          \
                                                      flFilter,     \
                                                      strName,      \
                                                      pdsol)


//+--------------------------------------------------------------------------
//
//  Interface:  ICustomizeDsBrowser
//
//  Member:     CAdminCustomizer::LookupDownlevelName
//
//  Synopsis:   Return the SID of downlevel object with name [strName]
//
//  Arguments:  [strName] - name of object to look for
//
//  Returns:    SID or NULL if name not found
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

PSID
CAdminCustomizer::LookupDownlevelName(
    const String &strName) const
{
    ULONG i;

    for (i = 0; i < NUM_SID_INFOS; i++)
    {
        if (!strName.icompare(m_aSidInfo[i].wzAccountName))
        {
            return m_aSidInfo[i].psid;
        }
    }

    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Interface:  ICustomizeDsBrowser
//
//  Member:     CAdminCustomizer::LookupDownlevelPath
//
//  Synopsis:   Return the ADsPath of downlevel object with name
//              [pwzAccountName].
//
//  Arguments:  [pwzAccountName] - name of object to search for
//
//  Returns:    Path of object, or NULL if name not found
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

PCWSTR
CAdminCustomizer::LookupDownlevelPath(
    PCWSTR pwzAccountName) const
{
    TRACE_METHOD(CCustomizeDsBrowser, LookupDownlevelName);

    ULONG i;

    for (i = 0; i < NUM_SID_INFOS; i++)
    {
        //REVIEWED-2002-02-19-lucios
        if (!lstrcmpi(pwzAccountName, m_aSidInfo[i].wzAccountName))
        {
            return m_aSidInfo[i].wzPath;
        }
    }

    return NULL;
}



//+--------------------------------------------------------------------------
//
//  Interface:  ICustomizeDsBrowser
//
//  Member:     CAdminCustomizer::PrefixSearch
//
//  Synopsis:   Add to [pdsol] all objects that would belong in scope
//              [ForScope] which have names starting with [strName].
//
//  Arguments:  [hwnd]     - for bind
//              [ForScope] - scope in which added objects should live
//              [strName]  - start of name of objects to find
//              [pdsol]    - list to which objects are added
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::PrefixSearch(
    HWND hwnd,
    const CScope &ForScope,
    const String &strName,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, PrefixSearch);

    //
    // Add matching objects for downlevel scopes
    //

    ULONG flFilter;
    HRESULT hr = m_rop.GetFilterManager().GetSelectedFilterFlags(hwnd,
                                                                 ForScope,
                                                                 &flFilter);
    RETURN_ON_FAIL_HRESULT(hr);

    if (IsDownlevel(ForScope))
    {
        //
        // Add NT4 well known sids matching prefix
        //

        if (flFilter)
        {
            ULONG idOwningScope = ForScope.GetID();

            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_WORLD             );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER);
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_ANONYMOUS         );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_BATCH             );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER     );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP     );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_DIALUP            );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_INTERACTIVE       );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_NETWORK           );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_SERVICE           );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_SYSTEM            );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER   );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE     );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE   );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON      );
        }
    }

    //
    // Add matching objects for uplevel scopes
    //

    if (IsUplevel(ForScope))
    {
        //
        // Add matching items from builtin container
        //

        if (flFilter & DSOP_FILTER_BUILTIN_GROUPS)
        {
            const CAdsiScope *pAdsiScope =
                dynamic_cast<const CAdsiScope *>(&ForScope);

            if (pAdsiScope)
            {
                String strScopeADsPath;
                HRESULT hrAux = pAdsiScope->GetADsPath(hwnd,
                                                    &strScopeADsPath);

                if (SUCCEEDED(hrAux))
                {
                    _AddBuiltins(hwnd,
                                 pAdsiScope->GetID(),
                                 strScopeADsPath,
                                 strName,
                                 pdsol);
                }
            }
        }

        //
        // Add matching items from well-known principals container
        //

        if (flFilter & DSOP_FILTER_WELL_KNOWN_PRINCIPALS)
        {
            _AddWellKnownPrincipals(hwnd, ForScope.GetID(), strName, pdsol);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddWellKnownPrincipals
//
//  Synopsis:   Add the contents of the Well Known Security Principals
//              container to [pDsSelList].
//
//  Arguments:  [pDsScope]   - scope for which to add well known principals
//                              from well known security principals
//                              container.
//              [pDsSelList] - selection list to which contents of container
//                              should be added.
//
//  History:    02-24-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddWellKnownPrincipals(
    HWND hwnd,
    ULONG idOwningScope,
    const String &strSearchFor,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _AddWellKnownPrincipals);

    if (m_dsolWKSP.empty())
    {
        _InitWellKnownPrincipalsList(hwnd, idOwningScope);
    }

    if (!m_dsolWKSP.empty())
    {
        _AddFromList(strSearchFor, &m_dsolWKSP, pdsol);
        ASSERT(!m_dsolWKSP.empty());
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_InitWellKnownPrincipalsList
//
//  Synopsis:   Fill the cached list of objects appearing in the "Well-Known
//              security principals" container.
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------
void
CAdminCustomizer::_InitWellKnownPrincipalsList(
    HWND hwnd,
    ULONG idOwningScope) const
{
    TRACE_METHOD(CAdminCustomizer, _InitWellKnownPrincipalsList);

    HRESULT                 hr = S_OK;
    IADsContainer          *pADsContainer = NULL;
    IEnumVARIANT           *pEnumVariant = NULL;
    VARIANT                 var;
    VARIANT                 varFilter;
    ULONG                   cFetched;
    NTSTATUS                nts;
    LSA_HANDLE              hLsa = NULL;
    LSA_OBJECT_ATTRIBUTES   ObjectAttributes;
    PCWSTR                  apwzFilter[1] = { c_wzForeignPrincipalsClass };

    VariantInit(&var);
    VariantInit(&varFilter);

    do
    {
        //
        // Need an lsa policy handle to do sid name lookup.  Failing to
        // obtain one is a nonfatal error, since it just means the names
        // of the well-known security principals will not appear in
        // localized form.
        //
        
        //REVIEWED-2002-02-19-lucios
        ZeroMemory(&ObjectAttributes, sizeof ObjectAttributes);

        ObjectAttributes.Length = sizeof ObjectAttributes;

        nts = LsaOpenPolicy(NULL,
                            &ObjectAttributes,
                            POLICY_EXECUTE,
                            &hLsa);

        if (NT_ERROR(nts))
        {
            DBG_OUT_HRESULT(nts);
            ASSERT(!hLsa);
        }

        const CRootDSE &RootDSE = m_rop.GetRootDSE();
        hr = RootDSE.BindToWellKnownPrincipalsContainer(hwnd,
                                                        IID_IADsContainer,
                                                        (void**)&pADsContainer);

        // NTRAID#NTBUG9-649997-2002/09/30-lucios
        // Since idOwningScope is the currently selected scope and
        // we are not searching there, but rather in the WellKnownSecurity
        // container of RootDSE's m_wzTargetDomain, a scope out of 
        // RootDSE's m_wzTargetDomain will be more correct.
        const CScopeManager &rsm=m_rop.GetScopeManager();
        const CScope *scope=NULL;
        scope=&rsm.LookupScopeByDisplayName(RootDSE.GetTargetComputerRootDomain());
        if(!scope || scope->Type()==ST_INVALID)
        {
            scope=&rsm.LookupScopeByFlatName(RootDSE.GetTargetComputerRootDomain());
        }
        if( scope && (scope->Type()!=ST_INVALID) ) 
        {
            idOwningScope=scope->GetID();
        }
        
        
        BREAK_ON_FAIL_HRESULT(hr);

        hr = ADsBuildVarArrayStr((PWSTR*)apwzFilter, 1, &varFilter);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pADsContainer->put_Filter(varFilter);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = ADsBuildEnumerator(pADsContainer, &pEnumVariant);
        BREAK_ON_FAIL_HRESULT(hr);

        while (1)
        {
            IADs *pADs = NULL;

            hr = ADsEnumerateNext(pEnumVariant, 1, &var, &cFetched);
            BREAK_ON_FAIL_HRESULT(hr);

            if (!cFetched)
            {
                break;
            }

            if (var.vt != VT_DISPATCH)
            {
                hr = S_FALSE;
                Dbg(DEB_ERROR,
                    "_AddWellKnownPrincipals: unexpected vt %uL\n",
                    var.vt);
                break;
            }

            hr = var.pdispVal->QueryInterface(IID_IADs, (void**)&pADs);
            BREAK_ON_FAIL_HRESULT(hr);

            VariantClear(&var);

            if (hLsa)
            {
                hr = pADs->Get(AutoBstr(c_wzObjectSidAttr), &var);

                if (SUCCEEDED(hr))
                {
                    _AddLocalizedWKSP(idOwningScope, hLsa, pADs, &var);
                    VariantClear(&var);
                }
                else
                {
                    DBG_OUT_HRESULT(hr);
                }
            }
            else
            {
                m_dsolWKSP.push_back(CDsObject(idOwningScope, pADs));
            }

            pADs->Release();
            pADs = NULL;
        }

    } while (0);

    if (hLsa)
    {
        LsaClose(hLsa);
    }

    SAFE_RELEASE(pADsContainer);
    ADsFreeEnumerator(pEnumVariant);
    VariantClear(&var);
    VariantClear(&varFilter);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddLocalizedWKSP
//
//  Synopsis:   Look up the localized name of the sid [pvarSid] and add
//              the object [pADs] to m_dsolWKSP.
//
//  Arguments:  [hLsa]           - lsa policy handle
//              [pADs]           - object to add
//              [pvarSid]        - objectSid of object to add
//
//  History:    11-13-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddLocalizedWKSP(
    ULONG idOwningScope,
    LSA_HANDLE hLsa,
    IADs *pADs,
    VARIANT *pvarSid) const
{
    VOID   *pvData = NULL;
    PLSA_TRANSLATED_NAME    pTranslatedName = NULL;
    PLSA_REFERENCED_DOMAIN_LIST pReferencedDomains = NULL;
    HRESULT hr;
    NTSTATUS nts;
    BOOL fAccessed = FALSE;
    BOOL fAdded = FALSE;

    do
    {
        hr = SafeArrayAccessData(V_ARRAY(pvarSid), &pvData);
        BREAK_ON_FAIL_HRESULT(hr);

        fAccessed = TRUE;

        PSID psid = (PSID) pvData;

        ASSERT(IsValidSid(psid));

        nts = LsaLookupSids(hLsa,
                            1,
                            &psid,
                            &pReferencedDomains,
                            &pTranslatedName);
        BREAK_ON_FAIL_NTSTATUS(nts);

        if (pTranslatedName->Use == SidTypeInvalid ||
            pTranslatedName->Use == SidTypeUnknown)
        {
            Dbg(DEB_ERROR,
                "pTranslatedName->Use == %uL\n",
                pTranslatedName->Use);
            break;
        }

        WCHAR wzLocalizedName[MAX_PATH];

        UnicodeStringToWsz(pTranslatedName->Name,
                           wzLocalizedName,
                           ARRAYLEN(wzLocalizedName));

        PCWSTR pwzName;
        Bstr bstrName;
        Bstr bstrClass;
        Bstr bstrPath;

        hr = pADs->get_Name(&bstrName);
        BREAK_ON_FAIL_HRESULT(hr);

        PWSTR pwzEqual = wcschr(bstrName.c_str(), L'=');

        if (pwzEqual)
        {
            pwzName = pwzEqual + 1;
        }
        else
        {
            pwzName = bstrName.c_str();
        }

        hr = pADs->get_Class(&bstrClass);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pADs->get_ADsPath(&bstrPath);
        BREAK_ON_FAIL_HRESULT(hr);

        SDsObjectInit Init;

        Init.pwzName = wzLocalizedName;
        Init.pwzLocalizedName = wzLocalizedName;
        Init.pwzClass = bstrClass.c_str();
        Init.pwzADsPath = bstrPath.c_str();
        Init.fDisabled = IsDisabled(pADs);
        Init.idOwningScope = idOwningScope;

        m_dsolWKSP.push_back(CDsObject(Init));
        fAdded = TRUE;

    } while (0);

    //
    // On failure, just add the unlocalized version.
    //

    if (!fAdded)
    {
        m_dsolWKSP.push_back(CDsObject(idOwningScope, pADs));
    }

    if (fAccessed)
    {
        SafeArrayUnaccessData(V_ARRAY(pvarSid));
    }

    if (pTranslatedName)
    {
        LsaFreeMemory((PVOID)pTranslatedName);
    }

    if (pReferencedDomains)
    {
        LsaFreeMemory((PVOID)pReferencedDomains);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddDownlevelIfMatches
//
//  Synopsis:   Add the NT4 well-known SID object represented by
//              [flCurObject] to [pdsol] if it is one of the bits set
//              in [flObjectsToCompare] AND its name starts with the string
//              in [pwzSearchFor].
//
//  Arguments:  [flCurObject]        - exactly one of UGOP_USER_* bits
//              [flObjectsToCompare] - bitmask of UGOP_USER_* bits
//              [pwzSearchFor]       - string for prefix match
//              [pdsol]              - list to which to add items
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddDownlevelIfMatches(
    ULONG idOwningScope,
    ULONG flCurObject,
    ULONG flObjectsToCompare,
    const String &strSearchFor,
    CDsObjectList *pdsol) const
{
    if ((flObjectsToCompare & flCurObject) == flCurObject)
    {
        String strCurName = _GetAccountName(flCurObject);
        PWSTR pwzMatch = wcsistr(strCurName.c_str(), strSearchFor.c_str());

        if (pwzMatch == strCurName.c_str())
        {
            pdsol->push_back(CDsObject(idOwningScope, strCurName, c_wzGlobalGroupClass));
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_GetUplevelAddition
//
//  Synopsis:   Find the builtin and well-known security principals and
//              create a list in [pdsol] to contain them.
//
//  Arguments:  [pdsol]    - list to which to add items
//
//  Modifies:   *[pdsol]
//
//  History:    02-16-1998   DavidMun   Created
//              03-10-2000   davidmun   convert from old code
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_GetUplevelAddition(
    HWND hwnd,
    ULONG idOwningScope,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _GetUplevelAddition);

    //
    // GC & NT5 Domain scope - enumerate from
    //
    // LDAP://CN=WellKnown Security Principals, CN=Configuration,
    //  DC=<domain>... and
    // LDAP://CN=Builtin,DC=<domain>....
    //

    const CFilterManager &rfm = m_rop.GetFilterManager();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    ULONG flObjectsToAdd = rfm.GetCurScopeSelectedFilterFlags();

    //
    // If the scope for which to add custom objects is the Global Catalog,
    // and it doesn't already include the builtin and WKSP objects, we
    // should add them if there is a joined domain scope and that scope
    // wants them, since the joined domain query is integrated with the GC's.
    //

    if (rsm.GetCurScope().Type() == DSOP_SCOPE_TYPE_GLOBAL_CATALOG)
    {
        const CScope &rJoinedDomainScope = rsm.LookupScopeByType(
                                            ST_UPLEVEL_JOINED_DOMAIN);

        if (!IsInvalid(rJoinedDomainScope))
        {
            ULONG flJoined;
            HRESULT hr = rfm.GetSelectedFilterFlags(hwnd,
                                                    rJoinedDomainScope,
                                                    &flJoined);
            RETURN_ON_FAIL_HRESULT(hr);


            if (flJoined & DSOP_FILTER_WELL_KNOWN_PRINCIPALS)
            {
                flObjectsToAdd |= DSOP_FILTER_WELL_KNOWN_PRINCIPALS;
            }

            if (!(flObjectsToAdd & DSOP_FILTER_BUILTIN_GROUPS) &&
                (flJoined & DSOP_FILTER_BUILTIN_GROUPS))
            {
                const CAdsiScope *padsiJoinedDomainScope =
                    dynamic_cast<const CAdsiScope*>(&rJoinedDomainScope);
                ASSERT(padsiJoinedDomainScope);

                if (padsiJoinedDomainScope)
                {
                    String strADsPath;
                    HRESULT hrAux;
                    hrAux = padsiJoinedDomainScope->GetADsPath(hwnd, &strADsPath);

                    if (SUCCEEDED(hrAux))
                    {
                        _AddBuiltins(hwnd,
                                     idOwningScope,
                                     strADsPath,
                                     L"",
                                     pdsol);
                    }
                }
            }
        }
    }

    do
    {
        //
        // If caller doesn't want contents of builtin or well known
        // principals containers, there's nothing to add.
        //

        if (!(flObjectsToAdd &
             (DSOP_FILTER_BUILTIN_GROUPS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS)))
        {
            break;
        }

        if (flObjectsToAdd & DSOP_FILTER_BUILTIN_GROUPS)
        {
            const CAdsiScope *padsiCurScope =
                dynamic_cast<const CAdsiScope*>(&rsm.GetCurScope());
            ASSERT(padsiCurScope);

            if (padsiCurScope)
            {
                String strADsPath;
                HRESULT hr = padsiCurScope->GetADsPath(hwnd, &strADsPath);

                if (SUCCEEDED(hr))
                {
                    _AddBuiltins(hwnd,
                                 idOwningScope,
                                 strADsPath,
                                 L"",
                                 pdsol);
                }
            }
        }

        if (flObjectsToAdd & DSOP_FILTER_WELL_KNOWN_PRINCIPALS)
        {
            _AddWellKnownPrincipals(hwnd, idOwningScope, L"", pdsol);
        }
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddBuiltins
//
//  Synopsis:   Add the contents of the Builtin container to [pdsol].
//
//  Arguments:  [pDsScope]     - scope for which to add builtin objects
//              [pwzSearchFor] - NULL or prefix string to match against
//              [pdsol]        - list to which to add objects
//
//  History:    02-24-1998   DavidMun   Created
//
//  Notes:      If [pwzSearchFor] is non-NULL, only builtin objects whose
//              names start with a string matching [pwzSearchFor] will be
//              added.
//
//              Don't pop up errors here since failure isn't necessarily
//              fatal; it just means some objects won't appear that should.
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddBuiltins(
    HWND hwnd,
    ULONG idOwningScope,
    const String &strScopePath,
    const String &strSearchFor,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _AddBuiltins);

    //
    // Search for an entry in the map for this scope's path
    //

    CStringDsObjectListMap::iterator itmap;

    itmap = m_dsomapBuiltins.find(strScopePath);

    if (itmap == m_dsomapBuiltins.end())
    {
        CDsObjectList dsolBuiltins;

        //
        // Not found.  Add a new entry.
        //

        _InitBuiltinsList(hwnd, idOwningScope, strScopePath, &dsolBuiltins);
        CStringDsObjectListMap::value_type v(strScopePath, dsolBuiltins);
        itmap = m_dsomapBuiltins.insert(m_dsomapBuiltins.begin(), v);
    }

    ASSERT(itmap != m_dsomapBuiltins.end());

    _AddFromList(strSearchFor, &itmap->second, pdsol);
}




#define BUILTIN_SEARCH_PAGE_SIZE    100


//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_InitBuiltinsList
//
//  Synopsis:   Fill [pdsol] with the list of Builtin type security enabled
//              domain local groups.
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_InitBuiltinsList(
    HWND hwnd,
    ULONG idOwningScope,
    const String &strScopePath,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _InitBuiltinsList);

    HRESULT hr = S_OK;

    do
    {
        //
        // Get the dir search interface.  If it isn't available, bail since
        // we won't be able to get any objects to add.
        //

        RpIDirectorySearch rpDirSearch;

        hr = g_pBinder->BindToObject(hwnd,
                                     strScopePath.c_str(),
                                     IID_IDirectorySearch,
                                     (void**)&rpDirSearch);
        BREAK_ON_FAIL_HRESULT(hr);

        ADS_SEARCHPREF_INFO aSearchPrefs[4];

        aSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
        aSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[0].vValue.Integer = BUILTIN_SEARCH_PAGE_SIZE;

        aSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
        aSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[1].vValue.Integer = ADS_DEREF_NEVER;

        aSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        aSearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[2].vValue.Integer = ADS_SCOPE_SUBTREE;

        aSearchPrefs[3].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
        aSearchPrefs[3].vValue.dwType = ADSTYPE_BOOLEAN;
        aSearchPrefs[3].vValue.Integer = FALSE;

        hr = rpDirSearch->SetSearchPreference(aSearchPrefs,
                                              ARRAYLEN(aSearchPrefs));
        BREAK_ON_FAIL_HRESULT(hr);

        AttrKeyVector vAttrToRead;

        vAttrToRead.push_back(AK_NAME);
        vAttrToRead.push_back(AK_OBJECT_CLASS);
        vAttrToRead.push_back(AK_ADSPATH);
        vAttrToRead.push_back(AK_USER_ACCT_CTRL);
        vAttrToRead.push_back(AK_USER_PRINCIPAL_NAME);

        CRow Row(hwnd,
                 m_rop,
                 rpDirSearch.get(),
                 c_wzBuiltinGroupFilter,
                 vAttrToRead);

#if (DBG == 1)
        ULONG cRows = 0;
#endif // (DBG == 1)

        while (1)
        {
            hr = Row.Next();

            if (hr == S_ADS_NOMORE_ROWS)
            {
#if (DBG == 1)
                Dbg(DEB_TRACE,
                    "S_ADS_NOMORE_ROWS (got %u) for builtin query\n",
                    cRows);
#endif // (DBG == 1)
                ULONG ulADsLastError;
                WCHAR wzError[MAX_PATH];
                WCHAR wzProvider[MAX_PATH];

                HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                              wzError,
                                              ARRAYLEN(wzError),
                                              wzProvider,
                                              ARRAYLEN(wzProvider));

                if (SUCCEEDED(hr2) && ulADsLastError == ERROR_MORE_DATA)
                {
                    Dbg(DEB_TRACE, "Got ERROR_MORE_DATA, trying again\n");
                    continue;
                }
                break;
            }

            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                break;
            }

            SDsObjectInit Init;

            Init.pwzName = Row.GetColumnStr(AK_NAME);
            Init.pwzClass = Row.GetColumnStr(AK_OBJECT_CLASS);
            Init.pwzADsPath = Row.GetColumnStr(AK_ADSPATH);

            if (!Init.pwzClass || !Init.pwzName || !Init.pwzADsPath)
            {
                Dbg(DEB_WARN,
                    "Skipping item missing class ('%ws'), name ('%ws'), or path ('%ws')\n",
                    Init.pwzClass ? Init.pwzClass : L"",
                    Init.pwzName ? Init.pwzName : L"",
                    Init.pwzADsPath ? Init.pwzADsPath : L"");
                continue;
            }

            Init.idOwningScope = idOwningScope;
            Init.pwzUpn = Row.GetColumnStr(AK_USER_PRINCIPAL_NAME);
            Init.fDisabled = (Row.GetColumnInt(AK_USER_ACCT_CTRL) & UF_ACCOUNTDISABLE);

            CDsObject dsoNew(Init);

            pdsol->push_back(dsoNew);

#if (DBG == 1)
            cRows++;
#endif // (DBG == 1)
        }
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddFromList
//
//  Synopsis:   Add all objects in [pdsolIn] which have name starting with
//              [strSearchFor] (or all objects if [strSearchFor] is empty)
//              to [pdsolOut].
//
//  Arguments:  [strSearchFor] - empty string or prefix to match
//              [pdsolIn]      - source list
//              [pdsolOut]     - destination list
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddFromList(
    const String &strSearchFor,
    const CDsObjectList *pdsolIn,
    CDsObjectList *pdsolOut) const
{
    //
    // If no prefix search is required, add all input list objects
    // to output list.  Note splice removes everything from the source
    // list, hence we make a copy of pdsolIn in a temporary variable.
    //

    if (strSearchFor.empty())
    {
        CDsObjectList   dsolTemp(*pdsolIn);

        pdsolOut->splice(pdsolOut->end(), dsolTemp);
        return;
    }

    //
    // Add only those objects having names that start with
    // pwzSearchFor.
    //

    CDsObjectList::const_iterator itdso;

    for (itdso = pdsolIn->begin();
         itdso != pdsolIn->end();
         itdso++)
    {
        PCWSTR pwzVisibleName = itdso->GetLocalizedName();

        if (!*pwzVisibleName)
        {
            pwzVisibleName = itdso->GetName();
        }

        if (wcsistr(pwzVisibleName, strSearchFor.c_str()) == pwzVisibleName)
        {
            pdsolOut->push_back(*itdso);
        }
    }
}





#define ADD_IF_SET(flag)                                        \
    if ((flObjectsToAdd & (flag)) == (flag))                    \
    {                                                           \
        pdsol->push_back(CDsObject(idOwningScope,               \
                                   _GetAccountName(flag),       \
                                   c_wzGlobalGroupClass));      \
    }

//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_GetDownlevelAddition
//
//  Synopsis:   Add the downlevel well-known SIDs as specified by the caller
//              into [pdsol].
//
//  Arguments:  [pDsScope] - current scope
//              [pdsol]    - list to which to add items
//
//  Returns:    S_OK
//
//  Modifies:   *[pdsol]
//
//  History:    02-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_GetDownlevelAddition(
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _GetDownlevelAddition);

    const CFilterManager &rfm = m_rop.GetFilterManager();
    const CScopeManager &rsm = m_rop.GetScopeManager();

    ULONG idOwningScope = rsm.GetCurScope().GetID();
    ULONG flObjectsToAdd = rfm.GetCurScopeSelectedFilterFlags();

    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_WORLD             );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER);
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_ANONYMOUS         );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_BATCH             );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER     );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP     );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_DIALUP            );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_INTERACTIVE       );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_NETWORK           );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_SERVICE           );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_SYSTEM            );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER   );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE     );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE   );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON      );
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_GetAccountName
//
//  Synopsis:   Return the account name associated with the well-known sid
//              flag in [flUser].
//
//  Arguments:  [flUser] - one of the UGOP_USER_* flags.
//
//  Returns:    Account name, or empty string on error.
//
//  History:    02-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CAdminCustomizer::_GetAccountName(
    ULONG flUser) const
{
    ULONG idx;

    switch (flUser)
    {
    case DSOP_DOWNLEVEL_FILTER_WORLD:
        idx = 0;
        break;

    case DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER:
        idx = 1;
        break;

    case DSOP_DOWNLEVEL_FILTER_ANONYMOUS:
        idx = 2;
        break;

    case DSOP_DOWNLEVEL_FILTER_BATCH:
        idx = 3;
        break;

    case DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER:
        idx = 4;
        break;

    case DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP:
        idx = 5;
        break;

    case DSOP_DOWNLEVEL_FILTER_DIALUP:
        idx = 6;
        break;

    case DSOP_DOWNLEVEL_FILTER_INTERACTIVE:
        idx = 7;
        break;

    case DSOP_DOWNLEVEL_FILTER_NETWORK:
        idx = 8;
        break;

    case DSOP_DOWNLEVEL_FILTER_SERVICE:
        idx = 9;
        break;

    case DSOP_DOWNLEVEL_FILTER_SYSTEM:
        idx = 10;
        break;

    case DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER:
        idx = 11;
        break;

    case DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE:
        idx = 12;
        break;

    case DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE:
        idx = 13;
        break;

    case DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON:
        idx = 14;
        break;

    default:
        ASSERT(FALSE && "_GetAccountName: invalid user flag");
        return L"";
    }

    //
    // If we've already done a LookupAccountSid to get the name,
    // return it.
    //

    if (m_aSidInfo[idx].wzAccountName[0])
    {
        return m_aSidInfo[idx].wzAccountName;
    }

    //
    // Create the sid and get its name
    //

    BOOL fOk;
    
    // REVIEWED-2002-02-19-lucios.
    fOk = AllocateAndInitializeSid(&m_aSidInfo[idx].sii,
                                   1,
                                   m_aSidInfo[idx].rid,
                                   0,0,0,0,0,0,0,
                                   &m_aSidInfo[idx].psid);

    if (!fOk || !m_aSidInfo[idx].psid)
    {
        DBG_OUT_LASTERROR;
        return L"";
    }

    ULONG cchAccount = CREDUI_MAX_USERNAME_LENGTH;
    WCHAR wzDomain[MAX_PATH];
    ULONG cchDomain = MAX_PATH;
    SID_NAME_USE snu;

    //REVIEWED-2002-02-19-lucios cchDomain and cchAccount are correct.
    fOk = LookupAccountSid(NULL,
                           m_aSidInfo[idx].psid,
                           m_aSidInfo[idx].wzAccountName,
                           &cchAccount,
                           wzDomain,
                           &cchDomain,
                           &snu);

    if (!fOk)
    {
        DBG_OUT_LASTERROR;
        return L"";
    }

    if (*wzDomain)
    {
        //NTRAID#NTBUG9-547507-2002/02/19-lucios. Pending fix.
        wsprintf(m_aSidInfo[idx].wzPath,
                 L"WinNT://%ws/%ws",
                 wzDomain,
                 m_aSidInfo[idx].wzAccountName);
    }
    else
    {
        //NTRAID#NTBUG9-547507-2002/02/19-lucios. Pending fix.
        wsprintf(m_aSidInfo[idx].wzPath,
                 L"WinNT://%ws",
                 m_aSidInfo[idx].wzAccountName);
    }

    return m_aSidInfo[idx].wzAccountName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\sample\sample.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       sample.cxx
//
//  Contents:   Sample DS object picker client.
//
//---------------------------------------------------------------------------

#define INC_OLE2
#include <windows.h>
#include <stdio.h>
#include <objsel.h>

#define BREAK_ON_FAIL_HRESULT(hr)       \
    if (FAILED(hr)) { printf("line %u err 0x%x\n", __LINE__, hr); break; }

#undef ASSERT
#define ASSERT(x) \
    if (!(x)) printf("line %u assert failed\n", __LINE__)


UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForGroups(
    IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                          | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly =
        DSOP_FILTER_GLOBAL_GROUPS_SE
      | DSOP_FILTER_UNIVERSAL_GROUPS_SE
      | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
    aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_GLOBAL_GROUPS_SE;
    aScopeInit[1].FilterFlags.flDownlevel =
      DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly =
       DSOP_FILTER_GLOBAL_GROUPS_SE
       | DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_GLOBAL_GROUPS_SE;

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[3].flType =
       DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
       | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

    aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly =
       DSOP_FILTER_GLOBAL_GROUPS_SE
       | DSOP_FILTER_UNIVERSAL_GROUPS_SE;

    aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly =
       DSOP_FILTER_GLOBAL_GROUPS_SE;

    aScopeInit[3].FilterFlags.flDownlevel =
       DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

    //
    // The Global Catalog
    //

    aScopeInit[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[4].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

    // Only native mode applies to gc scope.

    aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      | DSOP_FILTER_UNIVERSAL_GROUPS_SE
      | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);

    if (FAILED(hr))
    {
        ULONG i;

        for (i = 0; i < SCOPE_INIT_COUNT; i++)
        {
            if (FAILED(InitInfo.aDsScopeInfos[i].hr))
            {
                printf("Initialization failed because of scope %u\n", i);
            }
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(
    IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}




//+--------------------------------------------------------------------------
//
//  Function:   ProcessSelectedObjects
//
//  Synopsis:   Retrieve the list of selected items from the data object
//              created by the object picker and print out each one.
//
//  Arguments:  [pdo] - data object returned by object picker
//
//---------------------------------------------------------------------------

void
ProcessSelectedObjects(
    IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    bool fGotStgMedium = false;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = true;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            printf("GlobalLock error %u\n", GetLastError());
            break;
        }

        ULONG i;

        for (i = 0; i < pDsSelList->cItems; i++)
        {
            printf("Object %u'\n", i);
            printf("  Name '%ws'\n", pDsSelList->aDsSelection[i].pwzName);
            printf("  Class '%ws'\n", pDsSelList->aDsSelection[i].pwzClass);
            printf("  Path '%ws'\n", pDsSelList->aDsSelection[i].pwzADsPath);
            printf("  UPN '%ws'\n", pDsSelList->aDsSelection[i].pwzUPN);
        }

        GlobalUnlock(stgmedium.hGlobal);
    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Demonstrate use of DS object picker.
//
//---------------------------------------------------------------------------

void _cdecl
main(int argc, char * argv[])
{
    HRESULT hr = S_OK;
    IDsObjectPicker *pDsObjectPicker = NULL;
    IDataObject *pdo = NULL;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) return;

    do
    {
        //
        // Create an instance of the object picker.
        //

        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = InitObjectPickerForGroups(pDsObjectPicker);

        //
        // Invoke the modal dialog.
        //

        HWND hwndParent = NULL; // supply a window handle to your app

        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //

        if (hr == S_FALSE)
        {
            printf("User canceled object picker dialog\n");
            break;
        }

        //
        // Process the user's selections
        //

        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;

        //
        // Reinitialize the object picker to choose computers
        //

        hr = InitObjectPickerForComputers(pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now pick a computer
        //

        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;
    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\advanceddlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       AdvancedDlg.cxx
//
//  Contents:   Declaration of dialog that appears when user hits
//              Advanced button on base dialog.
//
//  Classes:    CAdvancedDlg
//
//  History:    04-03-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

const WCHAR c_wzBannerClass[] = L"ObjectPickerQueryBanner";

static ULONG
s_aulHelpIds[] =
{
    IDC_LOOK_FOR_PB,        IDH_LOOK_FOR_PB,
    IDC_LOOK_FOR_EDIT,      IDH_LOOK_FOR_EDIT,
    IDC_LOOK_IN_PB,         IDH_LOOK_IN_PB,
    IDC_LOOK_IN_EDIT,       IDH_LOOK_IN_EDIT,
    IDC_COLUMNS_PB,         IDH_COLUMNS_PB,
    IDC_FIND_NOW_PB,        IDH_FIND_NOW_PB,
    IDC_STOP_PB,            IDH_STOP_PB,
    IDC_QUERY_LISTVIEW,     IDH_QUERY_LISTVIEW,
    IDC_ANIMATION,          ULONG_MAX,
    IDC_TAB,                ULONG_MAX,
    0,0
};


//
// Forward refs
//

LRESULT CALLBACK
_BannerWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

AttrKeyVector
AttributesFromColumns(
    const AttrKeyVector &vakListviewColumns);

//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::CAdvancedDlg
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - owning object picker instance
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAdvancedDlg::CAdvancedDlg(
    const CObjectPicker &rop):
        m_rop(rop),
        m_CommonQueriesTab(rop),
        m_pCurTab(&m_CommonQueriesTab),
        m_fResizeableModeOn(FALSE),
        m_usnLatestQueryWorkItem(0),
        m_pvSelectedObjects(NULL),
        m_ulPrevFilterFlags(0),
        m_hwndAnimation(NULL),
        m_hwndBanner(NULL),
        m_cxMin(0),
        m_cyMin(0),
        m_cxSeparation(0),
        m_cySeparation(0),
        m_cxLvSeparation(0),
        m_cyLvSeparation(0),
        m_cxFrameLast(0),
        m_cyFrameLast(0),
        m_cxFour(0)
{
    TRACE_CONSTRUCTOR(CAdvancedDlg);
    // REVIEWED-2002-02-19-lucios.
    ZeroMemory(&m_rcDlgOriginal, sizeof m_rcDlgOriginal);
    ZeroMemory(&m_rcWrDlgOriginal, sizeof m_rcWrDlgOriginal);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::DoModalDlg
//
//  Synopsis:   Invoke the advanced dialog and block until it is closed.
//
//  Arguments:  [hwndParent]        - parent of modal dialog
//              [pvSelectedObjects] - filled with objects user selected
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::DoModalDlg(
    HWND hwndParent,
    vector<CDsObject> *pvSelectedObjects)
{
    m_pvSelectedObjects = pvSelectedObjects;
    ASSERT(m_pvSelectedObjects);

    if (!m_pvSelectedObjects)
    {
        return;
    }
    _DoModalDlg(hwndParent, IDD_ADVANCED);
    m_cxMin= 0;
    m_cyMin= 0;
    m_cxSeparation= 0;
    m_cySeparation= 0;
    m_cxFour = 0;
    m_cxLvSeparation= 0;
    m_cyLvSeparation= 0;
    m_cxFrameLast= 0;
    m_cyFrameLast= 0;
    m_pCurTab = &m_CommonQueriesTab;
    m_fResizeableModeOn = FALSE;
    m_pvSelectedObjects = NULL;
    m_ulPrevFilterFlags = 0;
    m_vakListviewColumns.clear();
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnInit
//
//  Synopsis:   Initialize the dialog
//
//  Arguments:  [pfSetFocus] -
//
//  Returns:    S_OK
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAdvancedDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CAdvancedDlg, _OnInit);
    
    //
    // Make prefix shut up
    //

    if (!_hCtrl(IDC_TAB) ||
        !_hCtrl(IDOK) ||
        !_hCtrl(IDC_FIND_NOW_PB) ||
        !_hCtrl(IDC_STOP_PB) ||
        !_hCtrl(IDC_QUERY_LISTVIEW))
    {
        return E_FAIL;
    }

    //
    // Init data needed for resizing.
    //
    // First translate the separation distance between controls from
    // dialog units to pixels.
    //

    RECT rc;

    rc.left = rc.top = 1;
    rc.right = DIALOG_SEPARATION_X;
    rc.bottom = DIALOG_SEPARATION_Y;
    VERIFY(MapDialogRect(m_hwnd, &rc));
    m_cxSeparation = rc.right;
    m_cySeparation = rc.bottom;

    rc.left = rc.top = 1;
    rc.right = 4;
    rc.bottom = DIALOG_SEPARATION_Y;
    VERIFY(MapDialogRect(m_hwnd, &rc));
    m_cxFour = rc.right;

    GetWindowRect(m_hwnd, &rc);

    m_cxFrameLast = WindowRectWidth(rc);
    m_cyFrameLast = WindowRectHeight(rc);

    GetWindowRect(m_hwnd, &rc);
    m_cxMin = rc.right - rc.left + 1;
    m_cyMin = rc.bottom - rc.top + 1;

    //
    // Init the Look For and Look In r/o edit controls and the caption
    //

    UpdateLookForInText(m_hwnd, m_rop);

    //
    // Add the Common Queries tab
    //

    TCITEM tci;
    
    // REVIEWED-2002-02-19-lucios.
    ZeroMemory(&tci, sizeof tci);
    tci.mask = TCIF_TEXT;

    String  strTabCaption;

    strTabCaption = String::load(IDS_COMMON_QUERIES, g_hinst);
    tci.pszText = const_cast<PWSTR>(strTabCaption.c_str());
    TabCtrl_InsertItem(_hCtrl(IDC_TAB), 0, &tci);
    //
    // Give the enable-find-now method to the tabs for callback
    //

    m_CommonQueriesTab.SetFindValidCallback(
        &FindValidCallback,
        reinterpret_cast<LPARAM>(this));
    //
    // Create the corresponding Common Queries dialog
    //

    HWND hwndTab = _hCtrl(IDC_TAB);

    m_CommonQueriesTab.DoModelessDlg(hwndTab);

    //
    // Position it so it fits within tab's bounding rectangle
    //

    RECT rcTab;

    VERIFY(GetWindowRect(hwndTab, &rcTab));
    TabCtrl_AdjustRect(hwndTab, FALSE, &rcTab);
    //ScreenToClient(hwndTab, reinterpret_cast<LPPOINT>(&rcTab.left));
    //ScreenToClient(hwndTab, reinterpret_cast<LPPOINT>(&rcTab.right));
    //ScreenToClient has some problem with mirrored apps and was causing
    //problems in Arabic build
    MapWindowPoints(NULL, hwndTab, (LPPOINT)&rcTab, 2);

    SetWindowPos(m_CommonQueriesTab.GetHwnd(),
                 hwndTab,
                 rcTab.left,
                 rcTab.top,
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOZORDER);

    //
    // Disable OK, it is only enabled if a find has been done and a
    // selection in the find results listview has been made.
    //

    SafeEnableWindow(_hCtrl(IDOK), FALSE);

    //
    // Disable both Find Now and Stop.  Stop is only enabled after
    // Find Now has been clicked and a query is ongoing.  Find Now
    // is enabled whenever the current tab tells us it should be.
    //

    SafeEnableWindow(_hCtrl(IDC_FIND_NOW_PB), FALSE);
    SafeEnableWindow(_hCtrl(IDC_STOP_PB), FALSE);

    //
    // Disable Columns button if we're in a downlevel scope, column chooser
    // is for uplevel only.
    //

    if (IsDownlevel(m_rop.GetScopeManager().GetCurScope().Type()))
    {
        SafeEnableWindow(_hCtrl(IDC_COLUMNS_PB), FALSE);
    }

    //
    // Put the listview in single select mode if that's how the object
    // picker was invoked.
    //

    HWND hwndLv = _hCtrl(IDC_QUERY_LISTVIEW);

    if (!(m_rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT))
    {
        LONG_PTR lStyle = GetWindowLongPtr(hwndLv, GWL_STYLE);
        SetWindowLongPtr(hwndLv, GWL_STYLE, lStyle | LVS_SINGLESEL);
    }

    //
    // Put the display cache's imagelist in the listview
    //

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    HIMAGELIST himl = NULL;
    HRESULT hrImageList = ram.GetImageList(&himl);

    if (SUCCEEDED(hrImageList))
    {
        ListView_SetImageList(hwndLv, himl, LVSIL_SMALL);
    }

    //
    // Make sure we start out looking at the tab 0 dialog.
    //

    m_CommonQueriesTab.Show(); // does a refresh

    //
    // Save the client area size before we allow resizing
    //

    GetClientRect(m_hwnd, &m_rcDlgOriginal);
    GetWindowRect(m_hwnd, &m_rcWrDlgOriginal);

    //
    // Create the animation control
    //

    m_hwndAnimation = Animate_Create(m_hwnd,
                                     IDC_ANIMATION,
                                     WS_CHILD
                                     | WS_VISIBLE
                                     | ACS_CENTER
                                     | ACS_TRANSPARENT,
                                     g_hinst);
    if (m_hwndAnimation)
    {
        Animate_Open(m_hwndAnimation, MAKEINTRESOURCE(IDA_SEARCH));
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    //
    // Register banner window class and create a banner instance
    //

    WNDCLASS wc;
    // REVIEWED-2002-02-19-lucios.
    ZeroMemory(&wc, sizeof wc);
    wc.lpfnWndProc = _BannerWndProc;
    wc.hInstance = g_hinst;
    wc.lpszClassName = c_wzBannerClass;
    RegisterClass(&wc);

    // NTRAID#NTBUG9-490633-2001/11/06-lucios
    // Create the banner window, this used to be a child of the ListView,
    // but as narrator only reads direct sons of the DialogBox it is
    // now a direct son of m_hwnd. As a result the code to position
    // the banner over the ListBox got a little more complex, since
    // it can no longer use GetClientRect(_hCtrl(IDC_QUERY_LISTVIEW)).
    // Also, the pieces of code using GetParent(banner) have to use
    // GetDlgItem(GetParent(banner),IDC_QUERY_LISTVIEW).
    // It is used to display information about the query being issued

    m_hwndBanner = CreateWindow(c_wzBannerClass, NULL,
                                WS_CHILD,
                                0, 0, 0, 0, // nb: size fixed later
                                m_hwnd,
                                0,
                                g_hinst,
                                NULL);
    if (!m_hwndBanner)
    {
        DBG_OUT_LASTERROR;
    }

    HRESULT hr = _ResizeableModeOn();
    if(FAILED(hr))
    {
        //
        //Show a popup
        //
        String strError = GetErrorMessage(hr);
        String strMsg;
        if(strError.empty())
            PopupMessage(GetParent(m_hwnd),IDS_CANNOT_INVOKE_ADV_NOERROR);
        else
            PopupMessage(GetParent(m_hwnd),IDS_CANNOT_INVOKE_ADV, strError.c_str());
    }
    return hr;
     
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnCommand
//
//  Synopsis:   Handle notification that the user has entered or changed
//              something in the UI.
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAdvancedDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDC_LOOK_IN_PB:
    {
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Look In button\n");
        const CScopeManager &rsm = m_rop.GetScopeManager();

        //
        // do the look in dlg and update look in/for text
        //

        rsm.DoLookInDialog(m_hwnd);
        m_rop.GetFilterManager().HandleScopeChange(m_hwnd);
        UpdateLookForInText(m_hwnd, m_rop);
        _UpdateColumns();

        SafeEnableWindow(_hCtrl(IDC_COLUMNS_PB),
                     IsUplevel(m_rop.GetScopeManager().GetCurScope()));

        //
        // tell current tab to update itself per current look in.
        // since changing the look in might have changed the look for,
        // request an update of that also.
        //

        m_pCurTab->Refresh();
        break;
    }

    case IDC_LOOK_FOR_PB:
    {
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Look For button\n");
        const CFilterManager &rfm = m_rop.GetFilterManager();

        rfm.DoLookForDialog(m_hwnd);

        Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_FOR_EDIT),
                     rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());
        _UpdateColumns();
        m_pCurTab->Refresh();
        break;
    }

    case IDC_COLUMNS_PB:
        _InvokeColumnChooser();
        break;

    case IDC_FIND_NOW_PB:
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Find Now button\n");

        //
        // If we're querying against an uplevel scope, we'll need
        // to ensure the attribute manager has been initialized
        // first.
        //

        if (IsUplevel(m_rop.GetScopeManager().GetCurScope().Type()))
        {
            HRESULT hr = m_rop.GetAttributeManager().DemandInit(m_hwnd);

            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                break;
            }
        }
        SafeEnableWindow(_hCtrl(IDC_STOP_PB), TRUE);
        SetFocus(_hCtrl(IDC_STOP_PB));
        SafeEnableWindow(_hCtrl(IDC_FIND_NOW_PB), FALSE);
        ListView_DeleteAllItems(_hCtrl(IDC_QUERY_LISTVIEW));
        SafeEnableWindow(_hCtrl(IDOK), FALSE);
        Animate_Play(m_hwndAnimation, 0, -1, -1);
        _StartQuery();
        break;

    case IDC_STOP_PB:
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Stop button\n");
        _StopQuery();
        Animate_Stop(m_hwndAnimation);
        Animate_Seek(m_hwndAnimation, 0);
        SafeEnableWindow(_hCtrl(IDC_FIND_NOW_PB), TRUE);
        SetFocus(_hCtrl(IDC_QUERY_LISTVIEW));
        SafeEnableWindow(_hCtrl(IDC_STOP_PB), FALSE);
        break;

    case IDOK:
        _OnOk();
        m_pvSelectedObjects = NULL;
        EndDialog(GetHwnd(), TRUE);
        break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Cancel\n");
        _StopQuery();
        m_pvSelectedObjects = NULL;
        EndDialog(GetHwnd(), FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CAdvancedDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnNotify
//
//  Synopsis:   Handle UI change notification
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAdvancedDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR pnmh = reinterpret_cast<LPNMHDR> (lParam);
    BOOL    fReturn = FALSE;

    switch (pnmh->code)
    {
    case LVN_ITEMCHANGED:
        SafeEnableWindow(_hCtrl(IDOK), ListView_GetSelectedCount(pnmh->hwndFrom));
        break;
    // NTRAID#NTBUG9-450352-2001/08/22-lucios. Begin
    // If the list view was double clicked and if
    // the OK button is enabled then click OK.
    case NM_DBLCLK:
       if(
            pnmh->idFrom == IDC_QUERY_LISTVIEW && 
            IsWindowEnabled(_hCtrl(IDOK))
         )
       {
         PostMessage(m_hwnd,WM_COMMAND,IDOK,NULL);
       }
       break;
    // NTRAID#NTBUG9-450352-2001/08/22-lucios. End

    default:
/*
        Dbg(DEB_ITRACE,
            "WM_NOTIFY idCtrl=%u hwndFrom=%#x code=%d\n",
            wParam,
            ((LPNMHDR)lParam)->hwndFrom,
            ((LPNMHDR)lParam)->code);
*/
        break;
    }

    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnHelp
//
//  Synopsis:   Handle the WM_HELP or WM_CONTEXTMENU message
//
//  Arguments:  [message] - WM_HELP or WM_CONTEXTMENU
//              [wParam]  - standard windows
//              [lParam]  - standard windows
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CAdvancedDlg, _OnHelp);

    HMENU hmenu = NULL;

    //
    // If the window in which this was invoked was the header or listview
    // window, display a context menu containing an item to invoke the
    // column picker.
    //

    do
    {
        if (message == WM_HELP)
        {
            InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
            break;
        }
        ASSERT(message == WM_CONTEXTMENU);

        HWND hwndClickedIn = reinterpret_cast<HWND>(wParam);

        //  NTRAID#NTBUG9-481002-2001/11/06-lucios
        if (hwndClickedIn != _hCtrl(IDC_QUERY_LISTVIEW))
        {
            InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
            break;
        }

        //
        // Column chooser not supported in downlevel mode
        //

        if (IsDownlevel(m_rop.GetScopeManager().GetCurScope()))
        {
            break;
        }

        hmenu = CreatePopupMenu();

        if (!hmenu)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        String strMenuItem = String::load(IDS_CHOOSE_COLUMNS);

        if (strMenuItem.empty())
        {
            break;
        }

        UINT uiFlags = MF_STRING;

        if (!IsWindowEnabled(_hCtrl(IDC_TAB)))
        {
            uiFlags |= (MF_GRAYED | MF_DISABLED);
        }

        BOOL fOk = AppendMenu(hmenu, uiFlags, 101, strMenuItem.c_str());

        if (!fOk)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        int x = GET_X_LPARAM(lParam);
        int y = GET_Y_LPARAM(lParam);

        if (x == -1 || y == -1)
        {
            Dbg(DEB_TRACE, "UA: WM_CONTEXTMENU generated via keyboard\n");
            HWND hwndFocus = GetFocus();
            RECT rc;

            if (GetWindowRect((hwndFocus ? hwndFocus : m_hwnd), &rc))
            {
                x = (rc.left + rc.right) / 2;
                y = (rc.top + rc.bottom) / 2;
            }
            else
            {
                DBG_OUT_LASTERROR;
                break;
            }
        }

        BOOL fReturn = TrackPopupMenu(hmenu,
                                      TPM_NONOTIFY | TPM_RETURNCMD,
                                      x,
                                      y,
                                      0,
                                      m_hwnd,
                                      NULL);

        if (!fReturn)
        {
            Dbg(DEB_TRACE, "UA: user cancelled context menu\n");
            break;
        }

        _InvokeColumnChooser();
    } while (0);

    if (hmenu)
    {
        VERIFY(DestroyMenu(hmenu));
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_InvokeColumnChooser
//
//  Synopsis:   Present the column chooser dialog and allow the user to
//              change the set of columns displayed in the listview.
//
//  History:    07-31-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_InvokeColumnChooser()
{
    //
    // Invoke the column chooser dialog
    //

    AttrKeyVector vakNew(m_vakListviewColumns);
    CColumnPickerDlg Dlg(m_rop, &vakNew);

    BOOL fMadeChanges = Dlg.DoModal(m_hwnd);

    if (!fMadeChanges)
    {
        return;
    }

    //
    // Remove all items from the listview
    //

    HWND hwndLV = _hCtrl(IDC_QUERY_LISTVIEW);
    ListView_DeleteAllItems(hwndLV);

    //
    // Remove all listview columns
    //

    size_t i;

    for (i = 0; i < m_vakListviewColumns.size(); i++)
    {
        ListView_DeleteColumn(hwndLV, 0);
    }

    //
    // Insert new set of columns
    //

    m_vakListviewColumns = vakNew;

    for (i = 0; i < m_vakListviewColumns.size(); i++)
    {
        _AddColToListview(m_vakListviewColumns[i]);
    }

    //
    // Disable the OK button, since the listview is empty
    //

    if (GetFocus() == _hCtrl(IDOK))
    {
        SetFocus(_hCtrl(IDCANCEL));
    }
    SafeEnableWindow(_hCtrl(IDOK), FALSE);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_StartQuery
//
//  Synopsis:   Ensure the dialog is in resizeable mode and ask the
//              QueryEngine to start an asynchronous query (an LDAP query or
//              a WinNT enumeration).
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_StartQuery()
{
    TRACE_METHOD(CAdvancedDlg, _StartQuery);

    //
    // Ask the current tab for any extra columns we should have
    //

    AttrKeyVector vakTabColumns;

    m_pCurTab->GetDefaultColumns(&vakTabColumns);

    AttrKeyVector::iterator itCol;

    for (itCol = vakTabColumns.begin(); itCol != vakTabColumns.end(); itCol++)
    {
        _AddColIfNotPresent(*itCol);
    }

    //
    // Disable look for, look in, and tabs
    //

    SafeEnableWindow(_hCtrl(IDC_LOOK_FOR_PB), FALSE);
    SafeEnableWindow(_hCtrl(IDC_LOOK_IN_PB), FALSE);
    SafeEnableWindow(_hCtrl(IDC_COLUMNS_PB), FALSE);
    SafeEnableWindow(_hCtrl(IDC_TAB), FALSE);
    m_pCurTab->Disable();

    //
    // If current scope is downlevel perform an enumeration
    //

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();

    if (rCurScope.Type() == ST_INVALID)
    {
        Dbg(DEB_ERROR, "Cur scope invalid, can't do query\n");
        return;
    }

    //
    // Display "Searching..." in the banner window
    //

    _ShowBanner(SWP_SHOWWINDOW, IDS_SEARCHING);

    //
    // Kick off the query in the worker thread
    //

    if (IsDownlevel(rCurScope))
    {
        _StartWinNtQuery();
    }
    else
    {
        _StartLdapQuery();
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::GetDownlevelCustomizerInteraction
//
//  Synopsis:   Sets the behavior for external and default customizer for searches
//
//  History:    06-24-2002   Lucios   Created
//
//---------------------------------------------------------------------------
void
CAdvancedDlg::GetDownlevelCustomizerInteraction
(
    CUSTOMIZER_INTERACTION  *pInteraction,
    BOOL *pPerformExternalCustomization,
    BOOL *pPerformDefaultCustomization
)
{
    *pInteraction = CUSTINT_IGNORE_CUSTOM_OBJECTS;

    ULONG flags = m_rop.GetFilterManager().GetCurScopeSelectedFilterFlags();

    if
    (
        IsDownlevelFlagSet
        (
            flags,
            ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS
        ) ||
        (flags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS)
    )
    {
        *pPerformDefaultCustomization=TRUE;
    }

    if (m_rop.GetExternalCustomizer())
    {
        *pPerformExternalCustomization=TRUE;
    }
    // for downlevel Name is not enabled, so we return all custom objects if 
    // the scope is set for any customization
    if (pPerformDefaultCustomization || pPerformExternalCustomization)
    {
        *pInteraction = CUSTINT_INCLUDE_ALL_CUSTOM_OBJECTS;
    }
}

//NTRAID#NTBUG9-529086-2002/06/24-lucios
//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_StartWinNtQuery
//
//  Synopsis:   Ask the QueryEngine to perform an asynchronous WinNT
//              enumeration
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_StartWinNtQuery()
{
    TRACE_METHOD(CAdvancedDlg, _StartWinNtQuery);

    const CQueryEngine &rqe = m_rop.GetQueryEngine();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    const CWinNtScope *pCurScopeWinNt =
        dynamic_cast<const CWinNtScope *>(&rCurScope);
    const CFilterManager &rfm = m_rop.GetFilterManager();

    do
    {
        if (!pCurScopeWinNt)
        {
            Dbg(DEB_ERROR,
                "Current scope '%ws' is not WinNT container\n",
                rCurScope.GetDisplayName().c_str());
            break;
        }

        SQueryParams qp;
        HRESULT hr;

        hr = pCurScopeWinNt->GetADsPath(m_hwnd, &qp.strADsPath);
        BREAK_ON_FAIL_HRESULT(hr);

        qp.rpScope = const_cast<CScope *>(&rCurScope);
        qp.vakAttributesToRead.push_back(AK_NAME);
        qp.vakAttributesToRead.push_back(AK_ADSPATH);
        qp.vakAttributesToRead.push_back(AK_OBJECT_CLASS);
        qp.hwndCredPromptParentDlg = m_hwnd;
        qp.hwndNotify = m_hwnd;
        qp.Limit = QL_NO_LIMIT;
        rfm.GetWinNtFilter(m_hwnd, rCurScope, &qp.vstrWinNtFilter);

        //NTRAID#NTBUG9-529086-2002/06/24-lucios
        GetDownlevelCustomizerInteraction
        (
            &qp.CustomizerInteraction,
            &qp.performExternalCustomization,
            &qp.perfromDefaultCustomization
        );

        hr = rqe.AsyncDirSearch(qp, &m_usnLatestQueryWorkItem);
        BREAK_ON_FAIL_HRESULT(hr);

    } while (0);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_StartLdapQuery
//
//  Synopsis:   Ask the QueryEngine to perform an asynchronous LDAP query
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_StartLdapQuery()
{
    TRACE_METHOD(CAdvancedDlg, _StartLdapQuery);

    const CQueryEngine &rqe = m_rop.GetQueryEngine();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    const CLdapContainerScope *pCurScopeLdap =
        dynamic_cast<const CLdapContainerScope *>(&rCurScope);

    if (!pCurScopeLdap)
    {
        Dbg(DEB_ERROR,
            "Current scope '%ws' is not LDAP container\n",
            rCurScope.GetDisplayName().c_str());
        return;
    }

    SQueryParams qp;

    HRESULT hr = pCurScopeLdap->GetADsPath(m_hwnd, &qp.strADsPath);
    RETURN_ON_FAIL_HRESULT(hr);

    qp.strLdapFilter = m_pCurTab->GetLdapFilter();
    qp.rpScope = const_cast<CScope *>(&rCurScope);
    qp.ADsScope = ADS_SCOPE_SUBTREE;
    qp.hwndCredPromptParentDlg = m_hwnd;
    qp.hwndNotify = m_hwnd;
    qp.Limit = QL_USE_REGISTRY_LIMIT;
    //NTRAID#NTBUG9-529086-2002/06/24-lucios
    m_pCurTab->GetCustomizerInteraction(&qp.CustomizerInteraction,
                                        &qp.performExternalCustomization,
                                        &qp.perfromDefaultCustomization,
                                        &qp.strCustomizerArg);
    qp.vakAttributesToRead = AttributesFromColumns(m_vakListviewColumns);
    if(rCurScope.Type() == ST_XFOREST)
    {
        qp.vakAttributesToRead.push_back(AK_OBJECT_SID);
        qp.vakAttributesToRead.push_back(AK_SAMACCOUNTNAME);
    }

    //
    // If there is an LDAP filter, tack on a bit to prevent disabled
    // objects from being returned, if applicable.
    //

    if (!qp.strLdapFilter.empty() && g_fExcludeDisabled)
    {
        qp.strLdapFilter.insert(0, L"(&");
        qp.strLdapFilter += L"(!";
        qp.strLdapFilter += c_wzDisabledUac;
        qp.strLdapFilter += L"))";
    }

    const CFilterManager &rfm = m_rop.GetFilterManager();

    if (rfm.GetCurScopeSelectedFilterFlags() &
        (DSOP_FILTER_CONTACTS | DSOP_FILTER_USERS))
    {
        AddIfNotPresent(&qp.vakAttributesToRead, AK_USER_PRINCIPAL_NAME);
    }

    // Dbg(DEB_TRACE, "ldap filter: \n%ws\n", qp.strLdapFilter.c_str());
    
    hr = rqe.AsyncDirSearch(qp, &m_usnLatestQueryWorkItem);
    CHECK_HRESULT(hr);
}




//+--------------------------------------------------------------------------
//
//  Function:   AttributesFromColumns
//
//  Synopsis:   Return a vector of ATTR_KEYs which is a copy of
//              [vakListviewColumns] modified so that it doesn't contain any
//              duplicates, and all synthesized attributes are replaced by
//              the non-synthesized attributes on which they depend.
//
//  Arguments:  [vakListviewColumns] - vector of attribute keys representing
//                                      the columns to display in a listview
//
//  Returns:    Modified copy of [vakListviewColumns].
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

AttrKeyVector
AttributesFromColumns(
    const AttrKeyVector &vakListviewColumns)
{
    TRACE_FUNCTION(AttributesFromColumns);

    AttrKeyVector vak;
    AttrKeyVector::const_iterator it;

    for (it = vakListviewColumns.begin();
         it != vakListviewColumns.end();
         it++)
    {
        switch (*it)
        {
        case AK_FLAGS:
        case AK_USER_ENTERED_TEXT:
        case AK_PROCESSED_ADSPATH:
            ASSERT(0 && "unexpected synthesized attribute key in column vector");
            break;

        case AK_LOCALIZED_NAME:
        case AK_NAME:
        case AK_DISPLAY_PATH:
            // These are always added, see below
            break;

        default:
            AddIfNotPresent(&vak, *it);
            break;
        }
    }

    //
    // There are a few attributes which should always be read, add
    // them in regardless of whether they appear in the columns.
    //

    AddIfNotPresent(&vak, AK_NAME);
    AddIfNotPresent(&vak, AK_ADSPATH);
    AddIfNotPresent(&vak, AK_OBJECT_CLASS);
    AddIfNotPresent(&vak, AK_USER_ACCT_CTRL);

    return vak;
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnNewBlock
//
//  Synopsis:   Handle a notification message from the query engine that it
//              has added more items to its buffer of objects.
//
//  Arguments:  [wParam] - number of rows in buffer
//              [lParam] - work item number the rows were fetched for
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_OnNewBlock(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CAdvancedDlg, _OnNewBlock);

    ULONG cRowsInBuffer = static_cast<ULONG>(wParam);
    ULONG usnWorkItem = static_cast<ULONG>(lParam);

    // ignore notifications for old queries
    if (usnWorkItem != m_usnLatestQueryWorkItem)
    {
        Dbg(DEB_TRACE,
            "Ignoring notification for old work item %u, current is %u\n",
            usnWorkItem,
            m_usnLatestQueryWorkItem);
        return;
    }
    // NTRAID#NTBUG9-527708-2002/04/02-lucios
    // This is the cache of objects from the search engine, so
    // this is safe because there is nothing to add, if we don't
    // have objects there. In one IA64 machine, we had a message
    // after EndDialog and we could reach this code after the 
    // QueryEngine was cleared. If this happens now, we return
    // here preventing an AV
    const CQueryEngine &rqe = m_rop.GetQueryEngine();
    if(rqe.GetItemCount()==0) return;

    // add the rows that aren't already in the listview

    HWND hwndLv = _hCtrl(IDC_QUERY_LISTVIEW);
    ULONG cRowsInLv = ListView_GetItemCount(hwndLv);

    ASSERT(cRowsInBuffer >= cRowsInLv);

    //
    // If we're about to add items to the listview and it doesn't have any,
    // hide the banner window
    //

    if (cRowsInBuffer > cRowsInLv
        && m_hwndBanner
        && IsWindowVisible(m_hwndBanner))
    {
        ASSERT(!cRowsInLv);
        _ShowBanner(SWP_HIDEWINDOW, 0);
    }

    const CAttributeManager &ram = m_rop.GetAttributeManager();

    ULONG idxRow;
    for (idxRow = cRowsInLv; idxRow < cRowsInBuffer; idxRow++)
    {
        CDsObject dso(rqe.GetObject(idxRow));
        LVITEM lvi;

        //
        // Skip disabled items if we're supposed to.  Even though we modify
        // the LDAP query to filter these out server-side, there's still
        // the customizer which might unknowingly supply disabled objects,
        // plus we could also get disabled objects via the WinNT provider.
        //

        if (g_fExcludeDisabled && dso.GetDisabled())
        {
            continue;
        }

        // REVIEWED-2002-02-19-lucios.
        ZeroMemory(&lvi, sizeof lvi);
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.lParam = idxRow;

        // NTRAID#NTBUG9-689768-2002/08/23-lucios
        // vAux was being allocated inside the if for
        // the fix 651555 below, and was being freed 
        // before used by the listBox
        Variant vAux;

        // NTRAID#NTBUG9-651555-2002/06/27-lucios
        if(m_vakListviewColumns[0]==AK_NAME)
        {
            vAux=dso.GetAttr(AK_LOCALIZED_NAME);
            lvi.pszText=vAux.Empty() ? dso.GetAttr(AK_NAME).GetBstr():
                                       vAux.GetBstr();
        }
        else
        {
            lvi.pszText = dso.GetAttr(m_vakListviewColumns[0]).GetBstr();
        }

        HRESULT hrImage;

        hrImage = ram.GetIconIndexFromObject(m_hwnd, dso, &lvi.iImage);

        if (SUCCEEDED(hrImage))
        {
            lvi.mask |= LVIF_IMAGE;
        }

        int iRet = ListView_InsertItem(hwndLv, &lvi);

        if (iRet == -1)
        {
            DBG_OUT_LASTERROR;
            continue;
        }

        size_t i;

        for (i = 1; i < m_vakListviewColumns.size(); i++)
        {
            // NTRAID#NTBUG9-651555-2002/06/27-lucios
            BSTR columnText=NULL;
            if(m_vakListviewColumns[i]==AK_NAME)
            {
                vAux=dso.GetAttr(AK_LOCALIZED_NAME);
                columnText=vAux.Empty() ? dso.GetAttr(AK_NAME).GetBstr():
                                           vAux.GetBstr();
            }
            else
            {
                columnText = dso.GetAttr(m_vakListviewColumns[i]).GetBstr();
            }
            ListView_SetItemText(hwndLv,
                                 iRet,
                                 static_cast<int>(i),
                                 const_cast<PWSTR>(columnText));
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnQueryDone
//
//  Synopsis:   Handle a notification from the query engine that it has
//              completed (or stopped) a query.
//
//  Arguments:  [wParam] - number of rows in buffer
//              [lParam] - work item number the rows were fetched for
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_OnQueryDone(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CAdvancedDlg, _OnQueryDone);

    // ignore notifications for old queries
    if (lParam != (LPARAM)(m_usnLatestQueryWorkItem))
    {
        return;
    }

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();

    _OnNewBlock(wParam, lParam);
    Animate_Stop(m_hwndAnimation);
    Animate_Seek(m_hwndAnimation, 0);

    SafeEnableWindow(_hCtrl(IDC_FIND_NOW_PB), TRUE);
    SafeEnableWindow(_hCtrl(IDC_LOOK_FOR_PB), TRUE);
    SafeEnableWindow(_hCtrl(IDC_LOOK_IN_PB), TRUE);
    SafeEnableWindow(_hCtrl(IDC_TAB), TRUE);

    if (IsUplevel(rCurScope))
    {
        SafeEnableWindow(_hCtrl(IDC_COLUMNS_PB), TRUE);
    }

    m_pCurTab->Enable();

    if (ListView_GetItemCount(_hCtrl(IDC_QUERY_LISTVIEW)) <= 0)
    {
        CQueryEngine &rqe = m_rop.GetQueryEngine();
        HRESULT hrQuery = rqe.GetLastQueryResult();
        String strEmptyText;

        if (FAILED(hrQuery))
        {
            String strTemp = String::load(IDS_QUERY_ERROR);
            strEmptyText = String::format(strTemp.c_str(),
                                            GetErrorMessage(hrQuery).c_str());
        }
        else
        {
            strEmptyText = String::load(IDS_NOTHINGFOUND);
        }

        // NTRAID#NTBUG9-513313-2002/04/08-lucios
        _ShowBanner(SWP_SHOWWINDOW, strEmptyText);
        SendMessage(m_hwnd,WM_NEXTDLGCTL,(WPARAM)m_hwndBanner,TRUE);

        if (GetFocus() == _hCtrl(IDC_STOP_PB))
        {
            SetFocus(_hCtrl(IDC_FIND_NOW_PB));
        }
    }
    else
    {
        ListView_SetItemState(_hCtrl(IDC_QUERY_LISTVIEW),
                              0,
                              LVIS_FOCUSED | LVIS_SELECTED,
                              LVIS_FOCUSED | LVIS_SELECTED);

        if (GetFocus() == _hCtrl(IDC_STOP_PB))
        {
            SetFocus(_hCtrl(IDC_QUERY_LISTVIEW));
        }
    }
    ASSERT(GetFocus() != _hCtrl(IDC_STOP_PB));
    SafeEnableWindow(_hCtrl(IDC_STOP_PB), FALSE);
}




const ULONG c_ulStyle = LVS_EX_LABELTIP
                        | LVS_EX_FULLROWSELECT
                        | LVS_EX_HEADERDRAGDROP;

//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_ResizeableModeOn
//
//  Synopsis:   Make the listview visible and make the dialog window
//              resizeable
//
//  History:    06-14-2000   DavidMun   Created
//
//  Notes:      Once the dialog has entered resizeable mode, it stays in
//              that mode.
//
//---------------------------------------------------------------------------

HRESULT
CAdvancedDlg::_ResizeableModeOn()
{
    TRACE_METHOD(CAdvancedDlg, _ResizeableModeOn);

    if (m_fResizeableModeOn)
    {
        return S_OK;
    }

    HRESULT hr = _UpdateColumns();

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    m_fResizeableModeOn = TRUE;

    //
    // Double (roughly) the vertical client size
    //
    // NTRAID#NTBUG9-191862-2001/03/06-hiteshr
    // 
    //
    //
    GetClientRect(m_hwnd, &m_rcDlgOriginal);


    //
    //Get the workarea info. 
    //
    RECT rcWorkArea;
    SystemParametersInfo(   SPI_GETWORKAREA,
                            NULL,
                            &rcWorkArea,
                            0);

    //
    //Limit the height of the dialog to WorkArea height
    //
    int yDlg = WindowRectHeight(m_rcDlgOriginal) * 17/10;

    if( yDlg > WindowRectHeight(rcWorkArea))
        yDlg = WindowRectHeight(rcWorkArea);

    SetWindowPos(m_hwnd,
                 NULL,
                 0,0,
                 WindowRectWidth(m_rcWrDlgOriginal),
                 yDlg,
                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOOWNERZORDER);

    //
    // Resize, reposition, and make visible child listview
    //

    RECT rcDlgNew;
    GetClientRect(m_hwnd, &rcDlgNew);
    HWND hwndLv = _hCtrl(IDC_QUERY_LISTVIEW);

    SetWindowPos(hwndLv,
                 NULL,
                 rcDlgNew.left,
                 m_rcDlgOriginal.bottom,
                 rcDlgNew.right,
                 rcDlgNew.bottom - m_rcDlgOriginal.bottom,
                 SWP_NOZORDER | SWP_NOOWNERZORDER);

    //
    // If taskbar is covering listview move the dialog box up.
    //

    RECT rcDlgNewW;
    GetWindowRect(m_hwnd, &rcDlgNewW);
    if(rcDlgNewW.bottom > rcWorkArea.bottom)
    {
        SetWindowPos(   m_hwnd,
                        NULL,
                        rcDlgNewW.left,
                        rcDlgNewW.top - (rcDlgNewW.bottom - rcWorkArea.bottom),
                        0,
                        0,
                        SWP_NOZORDER | SWP_NOOWNERZORDER |SWP_NOSIZE);
    }

    //
    // Initialize listview
    //

    ListView_SetExtendedListViewStyleEx(hwndLv, c_ulStyle, c_ulStyle);
    ShowWindow(hwndLv, SW_SHOW);

    //
    // Increase the minimum size so the listview can't be completely
    // hidden
    //

    DWORD dwLvMinSize = ListView_ApproximateViewRect(hwndLv, -1, -1, 1);
    m_cyMin += HIWORD(dwLvMinSize);

    RECT rcLv;
    _GetChildWindowRect(hwndLv, &rcLv);
    m_cxLvSeparation = rcDlgNew.right - rcLv.right;
    m_cyLvSeparation = rcDlgNew.bottom - rcLv.bottom;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_StopQuery
//
//  Synopsis:   Ask the query engine to stop whatever query it's working on
//              and update the UI to reflect a stopping query.
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_StopQuery()
{
    const CQueryEngine &rqe = m_rop.GetQueryEngine();

    rqe.StopWorkItem();
    SafeEnableWindow(_hCtrl(IDC_LOOK_FOR_PB), TRUE);
    SafeEnableWindow(_hCtrl(IDC_LOOK_IN_PB), TRUE);
    SafeEnableWindow(_hCtrl(IDC_TAB), TRUE);
    m_pCurTab->Enable();

    if (m_hwndBanner && IsWindowVisible(m_hwndBanner))
    {
        _ShowBanner(0, IDS_STOPPING_QUERY);
        // NTRAID#NTBUG9-513313-2002/04/08-lucios
        SendMessage(m_hwnd,WM_NEXTDLGCTL,(WPARAM)m_hwndBanner,TRUE);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnMinMaxInfo
//
//  Synopsis:   Respond to a WM_MINMAXINFO message based on whether the
//              dialog is in resizeable mode.
//
//  Arguments:  [lpmmi] - pointer to struct to fill with minimum and maximum
//                          allowed window size
//
//  Returns:    FALSE
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAdvancedDlg::_OnMinMaxInfo(
    LPMINMAXINFO lpmmi)
{
    if (m_fResizeableModeOn)
    {
        lpmmi->ptMinTrackSize.x = m_cxMin;
        lpmmi->ptMinTrackSize.y = m_cyMin;
    }
    else
    {
        lpmmi->ptMaxTrackSize.x = m_cxMin - 1;
        lpmmi->ptMaxTrackSize.y = m_cyMin - 1;
        lpmmi->ptMinTrackSize.x = m_cxMin - 1;
        lpmmi->ptMinTrackSize.y = m_cyMin - 1;
    }
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnSize
//
//  Synopsis:   Handle a WM_SIZE message.
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAdvancedDlg::_OnSize(
    WPARAM wParam,
    LPARAM lParam)
{
    if (!m_fResizeableModeOn)
    {
        return TRUE;
    }

    RECT rcDlg;
    GetClientRect(m_hwnd, &rcDlg);

    if (!m_cxFrameLast || !m_cyFrameLast)
    {
        Dbg(DEB_TRACE, "FrameLast not set yet, returning\n");
        m_cxFrameLast = rcDlg.right;
        m_cyFrameLast = rcDlg.bottom;
        return TRUE;
    }

    LONG cxDelta = rcDlg.right - m_cxFrameLast;

    //
    // Move the OK/Cancel buttons so they're always at lower right
    // corner of upper half of dialog.
    //

    RECT rcCancel;
    RECT rcLv;

    GetWindowRect(_hCtrl(IDCANCEL), &rcCancel);
    _GetChildWindowRect(_hCtrl(IDC_QUERY_LISTVIEW), &rcLv);

    SetWindowPos(_hCtrl(IDCANCEL),
                 NULL,
                 rcDlg.right - WindowRectWidth(rcCancel) - m_cxSeparation,
                 rcLv.top - WindowRectHeight(rcCancel) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcOk;
    _GetChildWindowRect(_hCtrl(IDOK), &rcOk);
    _GetChildWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDOK),
                 NULL,
                 rcCancel.left - WindowRectWidth(rcCancel) - m_cxFour,
                 rcCancel.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    // Find now, Columns, and stop buttons never change their vertical
    // position; their right edge stays aligned with the Cancel button.
    //

    RECT rcFindNow;
    _GetChildWindowRect(_hCtrl(IDC_FIND_NOW_PB), &rcFindNow);

    SetWindowPos(_hCtrl(IDC_FIND_NOW_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcFindNow),
                 rcFindNow.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcStop;
    _GetChildWindowRect(_hCtrl(IDC_STOP_PB), &rcStop);

    SetWindowPos(_hCtrl(IDC_STOP_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcStop),
                 rcStop.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcColumns;
    _GetChildWindowRect(_hCtrl(IDC_COLUMNS_PB), &rcColumns);

    SetWindowPos(_hCtrl(IDC_COLUMNS_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcColumns),
                 rcColumns.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // Animate control is always centered beneath the stop PB
    //

    RECT rcAni;
    _GetChildWindowRect(m_hwndAnimation, &rcAni);

    SetWindowPos(m_hwndAnimation,
                 NULL,
                 rcCancel.left +
                    (WindowRectWidth(rcStop) - 64) / 2,
                 rcStop.bottom + m_cySeparation,
                 64,
                 64,
                 SWP_NOOWNERZORDER
                 | SWP_NOZORDER);

    //
    // Resize tab control
    //

    RECT rcTab;
    _GetChildWindowRect(_hCtrl(IDC_TAB), &rcTab);

    SetWindowPos(_hCtrl(IDC_TAB),
                 NULL,
                 0,
                 0,
                 WindowRectWidth(rcTab) + cxDelta,
                 WindowRectHeight(rcTab),
                 SWP_NOMOVE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    // Resize listview & banner
    //
    _ShowBanner(0,0);


    //
    // Resize look in edit and button
    //

    RECT rcLookIn;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_IN_EDIT), &rcLookIn);

    SetWindowPos(_hCtrl(IDC_LOOK_IN_EDIT),
                 NULL,
                 0,
                 0,
                 WindowRectWidth(rcLookIn) + cxDelta,
                 WindowRectHeight(rcLookIn),
                 SWP_NOMOVE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    _GetChildWindowRect(_hCtrl(IDC_LOOK_IN_EDIT), &rcLookIn);
    RECT rcLookInPb;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_IN_PB), &rcLookInPb);

    //
    //Button's left is FOUR DLU right of Edit's Right
    //

    SetWindowPos(_hCtrl(IDC_LOOK_IN_PB),
                 NULL,
                 rcLookIn.right + m_cxFour,
                 rcLookInPb.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // Resize look for(locations) edit and button
    //

    RECT rcLookFor;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_EDIT), &rcLookFor);

    SetWindowPos(_hCtrl(IDC_LOOK_FOR_EDIT),
                 NULL,
                 0,
                 0,
                 WindowRectWidth(rcLookFor) + cxDelta,
                 WindowRectHeight(rcLookFor),
                 SWP_NOMOVE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    _GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_EDIT), &rcLookFor);
    RECT rcLookForPb;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_PB), &rcLookForPb);

    SetWindowPos(_hCtrl(IDC_LOOK_FOR_PB),
                 NULL,
                 rcLookFor.right + m_cxFour,
                 rcLookForPb.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // Update the saved size of the advanced dialog
    //

    m_cxFrameLast = rcDlg.right;
    m_cyFrameLast = rcDlg.bottom;

    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::FindValidCallback
//
//  Synopsis:   Called by child dialog to enable or disable the find now
//              button.
//
//  Arguments:  [fValid] - TRUE=>enable Find Now, FALSE=>disable
//              [lParam] - pointer to this
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::FindValidCallback(
    BOOL fValid,
    LPARAM lParam)
{
    TRACE_FUNCTION(FindValidCallback);

    CAdvancedDlg *pThis = reinterpret_cast<CAdvancedDlg *>(lParam);
    SafeEnableWindow(pThis->_hCtrl(IDC_FIND_NOW_PB), fValid);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnOk
//
//  Synopsis:   Stop any query in progress and fill the output vector with
//              the items in the listview which are selected.
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_OnOk()
{
    TRACE_METHOD(CAdvancedDlg, _OnOk);
    HWND hwndLV = _hCtrl(IDC_QUERY_LISTVIEW);
    const CQueryEngine &rqe = m_rop.GetQueryEngine();

    rqe.StopWorkItem();

    //
    // Copy each of the ds objects whose item in the listview is
    // selected to the output list.
    //

    LVITEM lvi;
    int iItem = -1;
    // REVIEWED-2002-02-19-lucios.
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;

    while ((iItem = ListView_GetNextItem(hwndLV,
                                         iItem,
                                         LVNI_SELECTED)) != -1)
    {
        lvi.iItem = iItem;
        ListView_GetItem(hwndLV, &lvi);
        m_pvSelectedObjects->push_back(rqe.GetObject(lvi.lParam));
    }

    ASSERT(!m_pvSelectedObjects->empty());

    Dbg(DEB_TRACE,
        "UA: (AdvancedDlg) hit OK, %u items in output vector, first is %ws\n",
        m_pvSelectedObjects->size(),
        m_pvSelectedObjects->front().GetName());

    //
    // No need to leave a large buffer of query results lying around
    //

    rqe.Clear();
}




//+--------------------------------------------------------------------------
//
//  Function:   _BannerWndProc
//
//  Synopsis:   Paint the current message inside the banner window.
//
//  Arguments:  standard Windows
//
//  Returns:    standard Windows
//
//  History:    06-22-2000   DavidMun   Ported from DS Find source
//
//  Notes:      The banner window covers the top portion of the listview's
//              client area when the listview is empty.  Its purpose is to
//              display some text that indicates why the listview is empty.
//
//---------------------------------------------------------------------------

LRESULT CALLBACK
_BannerWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lResult = 0;

    switch ( uMsg )
    {
        case WM_SIZE:
            InvalidateRect(hwnd, NULL, FALSE);
            break;

        case WM_ERASEBKGND:
           // NTRAID#NTBUG9-421812-2001/06/22-lucios - Begin
           // The background must be explicitly erased here 
           // since this window's brush is NULL


           HWND listHWnd;
           listHWnd=GetDlgItem(GetParent(hwnd),IDC_QUERY_LISTVIE